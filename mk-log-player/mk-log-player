#!/usr/bin/env perl

# This program is copyright 2008-@CURRENTYEAR@ Percona Inc.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

our $VERSION = '@VERSION@';
our $DISTRIB = '@DISTRIB@';
our $SVN_REV = sprintf("%d", (q$Revision$ =~ m/(\d+)/g, 0));

# ###########################################################################
# OptionParser package 2825
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package OptionParser;

use Getopt::Long;
use List::Util qw(max);
use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG};

my $POD_link_re = '[LC]<"?([^">]+)"?>';

sub new {
   my ( $class, @opts ) = @_;
   my %key_seen;
   my %long_seen;
   my %key_for;
   my %defaults;
   my @mutex;
   my @atleast1;
   my %long_for;
   my %disables;
   my %copyfrom;
   my @allowed_with;
   unshift @opts,
      { s => 'help',    d => 'Show this help message' },
      { s => 'version', d => 'Output version information and exit' };
   foreach my $opt ( @opts ) {
      if ( ref $opt ) {
         my ( $long, $short ) = $opt->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
         $opt->{k} = $short || $long;
         $key_for{$long} = $opt->{k};
         $long_for{$opt->{k}} = $long;
         $long_for{$long} = $long;
         $opt->{l} = $long;
         die "Duplicate option $opt->{k}" if $key_seen{$opt->{k}}++;
         die "Duplicate long option $opt->{l}" if $long_seen{$opt->{l}}++;
         $opt->{t} = $short;
         $opt->{n} = $opt->{s} =~ m/!/;
         $opt->{g} ||= 'o';
         if ( (my ($y) = $opt->{s} =~ m/=([mdHhAaz])/) ) {
            MKDEBUG && _d("Option $opt->{k} type: $y");
            $opt->{y} = $y;
            $opt->{s} =~ s/=./=s/;
         }
         if ( $opt->{d} =~ m/required/ ) {
            $opt->{r} = 1;
            MKDEBUG && _d("Option $opt->{k} is required");
         }
         if ( (my ($def) = $opt->{d} =~ m/default\b(?: ([^)]+))?/) ) {
            $defaults{$opt->{k}} = defined $def ? $def : 1;
            MKDEBUG && _d("Option $opt->{k} has a default");
         }
         if ( (my ($dis) = $opt->{d} =~ m/(disables .*)/) ) {
            $disables{$opt->{k}} = [ $class->get_participants($dis) ];
            MKDEBUG && _d("Option $opt->{k} $dis");
         }
      }
      else { # It's an instruction.

         if ( $opt =~ m/at least one|mutually exclusive|one and only one/ ) {
            my @participants = map {
                  die "No such option '$_' in $opt" unless $long_for{$_};
                  $long_for{$_};
               } $class->get_participants($opt);
            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
               push @mutex, \@participants;
               MKDEBUG && _d(@participants, ' are mutually exclusive');
            }
            if ( $opt =~ m/at least one|one and only one/ ) {
               push @atleast1, \@participants;
               MKDEBUG && _d(@participants, ' require at least one');
            }
         }
         elsif ( $opt =~ m/default to/ ) {
            my @participants = map {
                  die "No such option '$_' in $opt" unless $long_for{$_};
                  $key_for{$_};
               } $class->get_participants($opt);
            $copyfrom{$participants[0]} = $participants[1];
            MKDEBUG && _d(@participants, ' copy from each other');
         }
         elsif ( $opt  =~ m/allowed with/ ) {
            my @participants = map {
                  die "No such option '$_' while processing $opt"
                     unless $long_for{$_};
                  $key_for{$_};
               } $class->get_participants($opt);
            push @allowed_with, \@participants;
         }

      }
   }

   foreach my $dis ( keys %disables ) {
      $disables{$dis} = [
            map {
               if ( !defined $long_for{$_} ) {
                  die "No such option '$_' while processing $dis";
               }
               $long_for{$_};
            } @{$disables{$dis}}
      ];
   }

   my $self = {
      specs        => [ grep { ref $_ } @opts ],
      notes        => [],
      instr        => [ grep { !ref $_ } @opts ],
      mutex        => \@mutex,
      defaults     => \%defaults,
      long_for     => \%long_for,
      atleast1     => \@atleast1,
      disables     => \%disables,
      key_for      => \%key_for,
      copyfrom     => \%copyfrom,
      strict       => 1,
      groups       => [ { k => 'o', d => 'Options' } ],
      allowed_with => \@allowed_with,
   };

   return bless $self, $class;
}

sub get_participants {
   my ( $self, $str ) = @_;
   my @participants;
   foreach my $thing ( $str =~ m/(--?[\w-]+)/g ) {
      if ( (my ($long) = $thing =~ m/--(.+)/) ) {
         push @participants, $long;
      }
      else {
         foreach my $short ( $thing =~ m/([^-])/g ) {
            push @participants, $short;
         }
      }
   }
   MKDEBUG && _d("Participants for $str: ", @participants);
   return @participants;
}

sub parse {
   my ( $self, %defaults ) = @_;
   my @specs = @{$self->{specs}};
   my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);

   my %opt_seen;
   my %vals = %{$self->{defaults}};
   @vals{keys %defaults} = values %defaults;
   foreach my $spec ( @specs ) {
      $vals{$spec->{k}} = undef unless defined $vals{$spec->{k}};
      $opt_seen{$spec->{k}} = 1;
   }

   foreach my $key ( keys %defaults ) {
      die "Cannot set default for non-existent option '$key'\n"
         unless $opt_seen{$key};
   }

   Getopt::Long::Configure('no_ignore_case', 'bundling');
   GetOptions( map { $_->{s} => \$vals{$_->{k}} } @specs )
      or $self->error('Error parsing options');

   if ( $vals{version} ) {
      my $prog = $self->prog;
      printf("%s  Ver %s Distrib %s Changeset %s\n",
         $prog, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
         or die "Cannot print: $OS_ERROR";
      exit(0);
   }

   if ( @ARGV && $self->{strict} ) {
      $self->error("Unrecognized command-line options @ARGV");
   }

   foreach my $dis ( grep { defined $vals{$_} } keys %{$self->{disables}} ) {
      my @disses = map { $self->{key_for}->{$_} } @{$self->{disables}->{$dis}};
      MKDEBUG && _d("Unsetting options: ", @disses);
      @vals{@disses} = map { undef } @disses;
   }

   foreach my $spec ( grep { $_->{r} } @specs ) {
      if ( !defined $vals{$spec->{k}} ) {
         $self->error("Required option --$spec->{l} must be specified");
      }
   }

   foreach my $mutex ( @{$self->{mutex}} ) {
      my @set = grep { defined $vals{$self->{key_for}->{$_}} } @$mutex;
      if ( @set > 1 ) {
         my $note = join(', ',
            map { "--$self->{long_for}->{$_}" }
                @{$mutex}[ 0 .. scalar(@$mutex) - 2] );
         $note .= " and --$self->{long_for}->{$mutex->[-1]}"
               . " are mutually exclusive.";
         $self->error($note);
      }
   }

   foreach my $required ( @{$self->{atleast1}} ) {
      my @set = grep { defined $vals{$self->{key_for}->{$_}} } @$required;
      if ( !@set ) {
         my $note = join(', ',
            map { "--$self->{long_for}->{$_}" }
                @{$required}[ 0 .. scalar(@$required) - 2] );
         $note .= " or --$self->{long_for}->{$required->[-1]}";
         $self->error("Specify at least one of $note");
      }
   }

   foreach my $spec ( grep { $_->{y} && defined $vals{$_->{k}} } @specs ) {
      my $val = $vals{$spec->{k}};
      if ( $spec->{y} eq 'm' ) {
         my ( $num, $suffix ) = $val =~ m/(\d+)([a-z])?$/;
         if ( !$suffix ) {
            my ( $s ) = $spec->{d} =~ m/\(suffix (.)\)/;
            $suffix = $s || 's';
            MKDEBUG && _d("No suffix given; using $suffix for $spec->{k} "
               . "(value: '$val')");
         }
         if ( $suffix =~ m/[smhd]/ ) {
            $val = $suffix eq 's' ? $num            # Seconds
                 : $suffix eq 'm' ? $num * 60       # Minutes
                 : $suffix eq 'h' ? $num * 3600     # Hours
                 :                  $num * 86400;   # Days
            $vals{$spec->{k}} = $val;
            MKDEBUG && _d("Setting option $spec->{k} to $val");
         }
         else {
            $self->error("Invalid --$spec->{l} argument");
         }
      }
      elsif ( $spec->{y} eq 'd' ) {
         MKDEBUG && _d("Parsing option $spec->{y} as a DSN");
         my $from_key = $self->{copyfrom}->{$spec->{k}};
         my $default = {};
         if ( $from_key ) {
            MKDEBUG && _d("Option $spec->{y} DSN copies from option $from_key");
            $default = $self->{dsn}->parse($self->{dsn}->as_string($vals{$from_key}));
         }
         $vals{$spec->{k}} = $self->{dsn}->parse($val, $default);
      }
      elsif ( $spec->{y} eq 'z' ) {
         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
         if ( defined $num ) {
            if ( $factor ) {
               $num *= $factor_for{$factor};
               MKDEBUG && _d("Setting option $spec->{y} to num * factor");
            }
            $vals{$spec->{k}} = ($pre || '') . $num;
         }
         else {
            $self->error("Invalid --$spec->{l} argument");
         }
      }
   }

   foreach my $spec ( grep { $_->{y} } @specs ) {
      MKDEBUG && _d("Treating option $spec->{k} as a list");
      my $val = $vals{$spec->{k}};
      if ( $spec->{y} eq 'H' || (defined $val && $spec->{y} eq 'h') ) {
         $vals{$spec->{k}} = { map { $_ => 1 } split(',', ($val || '')) };
      }
      elsif ( $spec->{y} eq 'A' || (defined $val && $spec->{y} eq 'a') ) {
         $vals{$spec->{k}} = [ split(',', ($val || '')) ];
      }
   }

   foreach my $allowed_opts ( @{ $self->{allowed_with} } ) {
      my $opt = $allowed_opts->[0];
      next if !defined $vals{$opt};
      my %defined_opts = map { $_ => 1 } grep { defined $vals{$_} } keys %vals;
      delete @defined_opts{ @$allowed_opts };
      foreach my $defined_opt ( keys %defined_opts ) {
         MKDEBUG
            && _d("Unsetting options: $defined_opt (not allowed with $opt)");
         $vals{$defined_opt} = undef;
      }
   }

   return %vals;
}

sub error {
   my ( $self, $note ) = @_;
   $self->{__error__} = 1;
   push @{$self->{notes}}, $note;
}

sub prog {
   (my $prog) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
   return $prog || $PROGRAM_NAME;
}

sub prompt {
   my ( $self ) = @_;
   my $prog   = $self->prog;
   my $prompt = $self->{prompt} || '<options>';
   return "Usage: $prog $prompt\n";
}

sub descr {
   my ( $self ) = @_;
   my $prog = $self->prog;
   my $descr  = $prog . ' ' . ($self->{descr} || '')
          . "  For more details, please use the --help option, "
          . "or try 'perldoc $prog' for complete documentation.";
   $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
   $descr =~ s/ +$//mg;
   return $descr;
}

sub usage_or_errors {
   my ( $self, %opts ) = @_;
   if ( $opts{help} ) {
      print $self->usage(%opts)
         or die "Cannot print: $OS_ERROR";
      exit(0);
   }
   elsif ( $self->{__error__} ) {
      print $self->errors()
         or die "Cannot print: $OS_ERROR";
      exit(0);
   }
}

sub errors {
   my ( $self ) = @_;
   my $usage = $self->prompt() . "\n";
   if ( (my @notes = @{$self->{notes}}) ) {
      $usage .= join("\n  * ", 'Errors in command-line arguments:', @notes) . "\n";
   }
   return $usage . "\n" . $self->descr();
}

sub usage {
   my ( $self, %vals ) = @_;
   my @specs = @{$self->{specs}};

   my $maxl = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @specs);

   my $maxs = max(0,
      map { length($_->{l}) + ($_->{n} ? 4 : 0)}
      grep { $_->{t} } @specs);

   my $lcol = max($maxl, ($maxs + 3));
   my $rcol = 80 - $lcol - 6;
   my $rpad = ' ' x ( 80 - $rcol );

   $maxs = max($lcol - 3, $maxs);

   my $usage = $self->descr() . "\n" . $self->prompt();
   foreach my $g ( @{$self->{groups}} ) {
      $usage .= "\n$g->{d}:\n";
      foreach my $spec (
         sort { $a->{l} cmp $b->{l} } grep { $_->{g} eq $g->{k} } @specs )
      {
         my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
         my $short = $spec->{t};
         my $desc  = $spec->{d};
         if ( $spec->{y} && $spec->{y} eq 'm' ) {
            my ($s) = $desc =~ m/\(suffix (.)\)/;
            $s    ||= 's';
            $desc =~ s/\s+\(suffix .\)//;
            $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
                   . "d=days; if no suffix, $s is used.";
         }
         $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
         $desc =~ s/ +$//mg;
         if ( $short ) {
            $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
         }
         else {
            $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
         }
      }
   }

   if ( (my @instr = @{$self->{instr}}) ) {
      $usage .= join("\n", map { "  $_" } @instr) . "\n";
   }
   if ( $self->{dsn} ) {
      $usage .= "\n" . $self->{dsn}->usage();
   }
   $usage .= "\nOptions and values after processing arguments:\n";
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @specs ) {
      my $val   = $vals{$spec->{k}};
      my $type  = $spec->{y} || '';
      my $bool  = $spec->{s} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
      $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
                : !defined $val             ? '(No value)'
                : $type eq 'd'              ? $self->{dsn}->as_string($val)
                : $type =~ m/H|h/           ? join(',', sort keys %$val)
                : $type =~ m/A|a/           ? join(',', @$val)
                :                             $val;
      $usage .= sprintf("  --%-${lcol}s  %s\n", $spec->{l}, $val);
   }
   return $usage;
}

sub pod_to_spec {
   my ( $self, $file ) = @_;

   my %types = (
      'time' => 'm',
      'int'  => 'i',
      string => 's',
      hash   => 'h',
      Hash   => 'H',
      array  => 'a',
      Array  => 'A',
      size   => 'z',
      DSN    => 'd',
      float  => 'f',
   );

   my @spec = ();
   my @special_options = ();
   $file ||= __FILE__;
   open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
   my $para;
   my $option;

   local $INPUT_RECORD_SEPARATOR = '';
   while ( $para = <$fh> ) {
      next unless $para =~ m/^=head1 OPTIONS/;
      last;
   }

   while ( $para = <$fh> ) {
      MKDEBUG && _d($para);
      last if $para =~ m/^=over/;
      chomp $para;
      $para =~ s/\s+/ /g;
      $para =~ s/$POD_link_re/$1/go;
      push @special_options, $para;
   }

   do {
      if ( ($option) = $para =~ m/^=item --(.*)/ ) {
         MKDEBUG && _d($para);
         my %props;
         $para = <$fh>;
         if ( $para =~ m/: / ) {
            $para =~ s/\s+\Z//g;
            %props = map { split(/: /, $_) } split(/; /, $para);
            if ( $props{'short form'} ) {
               $props{'short form'} =~ s/-//;
            }
            $para = <$fh>;
         }
         $para =~ s/\s+\Z//g;
         $para =~ s/\s+/ /g;
         $para =~ s/$POD_link_re/$1/go;
         if ( $para =~ m/^[^.]+\.$/ ) {
            $para =~ s/\.$//;
         }

         if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
            $option = $base_option;
            $props{'negatable'} = 1;
         }

         push @spec, {
            s => $option
               . ( $props{'short form'} ? '|' . $props{'short form'} : '' )
               . ( $props{'negatable'}  ? '!'                        : '' )
               . ( $props{'cumulative'} ? '+'                        : '' )
               . ( $props{type}         ? '=' . $types{$props{type}} : '' ),
            d => $para
               . (defined $props{default} ? " (default $props{default})" : ''),
         };
      }
      while ( $para = <$fh> ) {
         last unless $para;

         if ( $option ) {
            if ( my ($line)
                  = $para =~ m/(allowed with --$option[:]?.*?)\./ ) {
               1 while ( $line =~ s/$POD_link_re/$1/go );
               push @special_options, $line;
            }
         }

         if ( $para =~ m/^=head1/ ) {
            $para = undef; # Can't 'last' out of a do {} block.
            last;
         }
         last if $para =~ m/^=item --/;
      }
   } while ( $para );

   close $fh;
   return @spec, @special_options;
}

sub prompt_noecho {
   shift @_ if ref $_[0] eq __PACKAGE__;
   my ( $prompt ) = @_;
   local $OUTPUT_AUTOFLUSH = 1;
   print $prompt
      or die "Cannot print: $OS_ERROR";
   my $response;
   eval {
      require Term::ReadKey;
      Term::ReadKey::ReadMode('noecho');
      chomp($response = <STDIN>);
      Term::ReadKey::ReadMode('normal');
      print "\n"
         or die "Cannot print: $OS_ERROR";
   };
   if ( $EVAL_ERROR ) {
      die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
   }
   return $response;
}

sub groups {
   my ( $self, @groups ) = @_;
   push @{$self->{groups}}, @groups;
}

if ( MKDEBUG ) {
   print '# ', $^X, ' ', $], "\n";
   my $uname = `uname -a`;
   if ( $uname ) {
      $uname =~ s/\s+/ /g;
      print "# $uname\n";
   }
   printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
      $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
      ($main::SVN_REV || ''), __LINE__);
   print('# Arguments: ',
      join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print "# $package:$line $$ ", @_, "\n";
}

1;

# ###########################################################################
# End OptionParser package
# ###########################################################################

# ###########################################################################
# LogParser package 2879
# ###########################################################################
package LogParser;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG};

sub new {
   my ( $class ) = @_;
   bless {}, $class;
}

my $general_log_first_line = qr{
   \A
   (?:(\d{6}\s+\d{1,2}:\d\d:\d\d)|\t)? # Timestamp
   \t
   (?:\s*(\d+))                        # Thread ID
   \s
   (.*)                                # Everything else
   \Z
}xs;

my $general_log_any_line = qr{
   \A(
      Connect
      |Field\sList
      |Init\sDB
      |Query
      |Quit
   )
   (?:\s+(.*\Z))?
}xs;

my $slow_log_ts_line = qr/^# Time: (\d{6}\s+\d{1,2}:\d\d:\d\d)/;
my $slow_log_uh_line = qr/# User\@Host: ([^\[]+|\[[^[]+\]).*?@ (\S*) \[(.*)\]/;

my $binlog_line_1 = qr{^# at (\d+)};
my $binlog_line_2 = qr/^#(\d{6}\s+\d{1,2}:\d\d:\d\d)\s+server\s+id\s+(\d+)\s+end_log_pos\s+(\d+)\s+(\S+)\s*([^\n]*)$/;
my $binlog_line_2_rest = qr{Query\s+thread_id=(\d+)\s+exec_time=(\d+)\s+error_code=(\d+)};

sub parse_event {
   my ( $self, $fh, $code, $mode ) = @_;
   my $event; # Don't initialize, that'll cause a loop.

   my $done = 0;
   my $type = 0; # 0 = comments, 1 = USE and SET etc, 2 = the actual query
   my $line = defined $self->{last_line} ? $self->{last_line} : <$fh>;
   $mode  ||= '';

   LINE:
   while ( !$done && defined $line ) {
      MKDEBUG && _d('type: ', $type, ' ', $line);
      my $handled_line = 0;

      if ( !$mode && $line =~ m/^# [A-Z]/ ) {
         MKDEBUG && _d('Setting mode to slow log');
         $mode ||= 'slow';
      }

      if ( $line =~ m/Version:.+ started with:/ ) {
         MKDEBUG && _d('Chomping out header lines');
         <$fh>; # Tcp port: etc
         <$fh>; # Column headers
         $line = <$fh>;
         $type = 0;
         redo LINE;
      }

      elsif ( $mode ne 'slow'
         && (my ( $ts, $id, $rest ) = $line =~ m/$general_log_first_line/s)
      ) {
         MKDEBUG && _d('Beginning of general log event');
         $handled_line = 1;
         $mode ||= 'log';
         $self->{last_line} = undef;
         if ( $type == 0 ) {
            MKDEBUG && _d('Type 0');
            my ( $cmd, $arg ) = $rest =~ m/$general_log_any_line/;
            $event = {
               ts  => $ts || '',
               id  => $id,
               cmd => $cmd,
               arg => $arg || '',
            };
            if ( $cmd ne 'Query' ) {
               MKDEBUG && _d('Not a query, done with this event');
               $done = 1;
               chomp $event->{arg} if $event->{arg};
            }
            $type = 2;
         }
         else {
            MKDEBUG && _d('Saving line for next invocation');
            $self->{last_line} = $line;
            $done = 1;
            chomp $event->{arg} if $event->{arg};
         }
      }

      elsif ( $mode eq 'slow' ) {
         if ( $line =~ m/^# No InnoDB statistics available/ ) {
            $handled_line = 1;
            MKDEBUG && _d('Ignoring line');
            $line = <$fh>;
            $type = 0;
            next LINE;
         }

         elsif ( my ( $time ) = $line =~ m/$slow_log_ts_line/ ) {
            $handled_line = 1;
            MKDEBUG && _d('Beginning of slow log event');
            $self->{last_line} = undef;
            if ( $type == 0 ) {
               MKDEBUG && _d('Type 0');
               $event->{ts} = $time;
               if ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/ ) {
                  @{$event}{qw(user host ip)} = ($user, $host, $ip);
               }
            }
            else {
               MKDEBUG && _d('Saving line for next invocation');
               $self->{last_line} = $line;
               $done = 1;
            }
            $type = 0;
         }

         elsif ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/ ) {
            $handled_line = 1;
            if ( $type == 0 ) {
               MKDEBUG && _d('Type 0');
               @{$event}{qw(user host ip)} = ($user, $host, $ip);
            }
            else {
               MKDEBUG && _d('Saving line for next invocation');
               $self->{last_line} = $line;
               $done = 1;
            }
            $type = 0;
         }

         elsif ( $line =~ m/^# / && (my %hash = $line =~ m/(\w+):\s+(\S+)/g ) ) {

            if ( $type == 0 ) {
               if ( $line =~ m/^#.+;/ ) {
                  MKDEBUG && _d('Commented event line ends header');
               }
               else {
                  $handled_line = 1;
                  MKDEBUG && _d('Splitting line into fields');
                  @{$event}{keys %hash} = values %hash;
               }
            }
            elsif ( $type == 1 && $line =~ m/^#.+;/ ) {
               MKDEBUG && _d('Commented event line after type 1 line');
               $handled_line = 0;
            }
            else {
               $handled_line = 1;
               MKDEBUG && _d('Saving line for next invocation');
               $self->{last_line} = $line;
               $done = 1;
            }
            $type = 0;
         }
      }

      if ( !$handled_line ) {
         $event->{cmd} = 'Query';
         if ( $mode eq 'slow' && $line =~ m/;\s+\Z/ ) {
            MKDEBUG && _d('Line is the end of a query within event');
            if ( my ( $db ) = $line =~ m/^use (.*);/i ) {
               MKDEBUG && _d('Setting event DB to ', $db);
               $event->{db} = $db;
               $type = 1;
            }
            elsif ( $type < 2 && (my ( $setting ) = $line =~ m/^(SET .*);\s+\Z/ ) ) {
               MKDEBUG && _d('Setting a property for event');
               push @{$event->{settings}}, $setting;
               $type = 1;
            }
            else {
               MKDEBUG && _d('Line is a continuation of prev line');
               if ( $line =~ m/^# / ) {
                  MKDEBUG && _d('Line is a commented event line');
                  $line =~ s/.+: (.+);\n/$1/;
                  $event->{cmd} = 'Admin';
               }
               $event->{arg} .= $line;
               $type = 2;
            }
         }
         else {
            MKDEBUG && _d('Line is a continuation of prev line');
            $event->{arg} .= $line;
            $type = 2;
         }
      }

      $event->{NR} = $NR;

      $line = <$fh> unless $done;
   }

   if ( !defined $line ) {
      MKDEBUG && _d('EOF found');
      $self->{last_line} = undef;
   }

   if ( $mode && $mode eq 'slow' ) {
      MKDEBUG && _d('Slow log, trimming');
      $event->{arg} =~ s/;\s*\Z// if $event->{arg};
   }

   $code->($event) if $event && $code;
   return $event;
}

sub parse_slowlog_event {
   my ( $self, $fh, $misc, @callbacks ) = @_;
   my $num_events = 0;

   my @pending;
   local $INPUT_RECORD_SEPARATOR = ";\n#";
   my $trimlen    = length($INPUT_RECORD_SEPARATOR);
   my $pos_in_log = tell($fh);
   my $stmt;

   EVENT:
   while ( defined($stmt = shift @pending) or defined($stmt = <$fh>) ) {
      my @properties = ('cmd', 'Query', 'pos_in_log', $pos_in_log);
      $pos_in_log = tell($fh);

      if ( $stmt =~ s{
            ^(?:
            Tcp\sport:\s+\d+
            |
            /.*Version.*started
            |
            Time\s+Id\s+Command
            ).*\n
         }{}gmxo
      ){
         my @chunks = split(/$INPUT_RECORD_SEPARATOR/o, $stmt);
         if ( @chunks > 1 ) {
            $stmt = shift @chunks;
            unshift @pending, @chunks;
         }
      }

      $stmt = '#' . $stmt unless $stmt =~ m/\A#/;
      $stmt =~ s/;\n#?\Z//;


      my ($got_ts, $got_uh, $got_ac, $got_db, $got_set);
      my $pos = 0;
      my $len = length($stmt);
      my $found_arg = 0;
      LINE:
      while ( $stmt =~ m/^(.*)$/mg ) { # /g is important, requires scalar match.
         $pos     = pos($stmt);  # Be careful not to mess this up!
         my $line = $1;          # Necessary for /g and pos() to work.

         if ($line =~ m/^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/oi) {

            if ( !$got_ts
               && (my ( $time ) = $line =~ m/$slow_log_ts_line/o)
               && ++$got_ts
            ) {
               push @properties, 'ts', $time;
               if ( !$got_uh
                  && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
                  && ++$got_uh
               ) {
                  push @properties, 'user', $user, 'host', $host, 'ip', $ip;
               }
            }

            elsif ( !$got_uh
                  && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
                  && ++$got_uh
            ) {
               push @properties, 'user', $user, 'host', $host, 'ip', $ip;
            }

            elsif ( !$got_ac
                  && $line =~ m/^# (?:administrator command:.*)$/
                  && ++$got_ac
            ) {
               push @properties, 'cmd', 'Admin', 'arg', $line;
               $found_arg++;
            }

            elsif ( my @temp = $line =~ m/(\w+):\s+(\d+(?:\.\d+)?|\S+)/g ) {
               push @properties, @temp;
            }

            elsif ( !$got_db
                  && (my ( $db ) = $line =~ m/^USE ([^;]+)/i )
                  && ++$got_db
            ) {
               push @properties, 'db', $db;
            }

            elsif ( !$got_set
                  && ( my ( $setting ) = $line =~ m/^SET\s+([^;]*)/i )
                  && ++$got_set
            ) {
               push @properties, split(/,|\s*=\s*/, $setting);
            }

            if ( !$found_arg && $pos == $len ) {
               local $INPUT_RECORD_SEPARATOR = ";\n";
               if ( defined(my $l = <$fh>) ) {
                  chomp $l;
                  push @properties, 'cmd', 'Admin', 'arg', '#' . $l;
                  $found_arg++;
               }
               else {
                  next EVENT;
               }
            }
         }
         else {
            push @properties, 'arg', substr($stmt, $pos - length($line));
            last LINE;
         }
      }

      my $event = { @properties };
      foreach my $callback ( @callbacks ) {
         last unless $event = $callback->($event);
      }
      ++$num_events;
      last EVENT unless @pending;
   }
   return $num_events;
}

sub parse_binlog_event {
   my ( $self, $fh, $code ) = @_;
   my $event;

   my $term  = $self->{term} || ";\n"; # Corresponds to DELIMITER
   my $tpat  = quotemeta $term;
   local $RS = $term;
   my $line  = <$fh>;

   LINE: {
      return unless $line;

      if ( $line =~ m/^DELIMITER/m ) {
         my($del)      = $line =~ m/^DELIMITER ([^\n]+)/m;
         $self->{term} = $del;
         local $RS     = $del;
         $line         = <$fh>; # Throw away DELIMITER line
         MKDEBUG && _d('New record separator: ', $del);
         redo LINE;
      }

      $line =~ s/$tpat\Z//;

      if ( my ( $offset ) = $line =~ m/$binlog_line_1/m ) {
         $self->{last_line} = undef;
         $event = {
            offset => $offset,
         };
         my ( $ts, $sid, $end, $type, $rest ) = $line =~ m/$binlog_line_2/m;
         @{$event}{qw(ts server_id end type)} = ($ts, $sid, $end, $type);
         (my $arg = $line) =~ s/\n*^#.*\n//gm; # Remove comment lines
         $event->{arg} = $arg;
         if ( $type eq 'Xid' ) {
            my ($xid) = $rest =~ m/(\d+)/;
            $event->{xid} = $xid;
         }
         elsif ( $type eq 'Query' ) {
            @{$event}{qw(id time code)} = $rest =~ m/$binlog_line_2_rest/;
         }
         else {
            die "Unknown event type $type"
               unless $type =~ m/Rotate|Start|Execute_load_query|Append_block|Begin_load_query|Rand|User_var|Intvar/;
         }
      }
      else {
         $event = {
            arg => $line,
         };
      }
   }

   if ( !defined $line ) {
      delete $self->{term};
   }

   $code->($event) if $event && $code;
   return $event;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print "# $package:$line $$ ", @_, "\n";
}

1;

# ###########################################################################
# End LogParser package
# ###########################################################################

# ###########################################################################
# QueryRewriter package 3007
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package QueryRewriter;

use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG};

our $verbs   = qr{^SHOW|^FLUSH|^COMMIT|^ROLLBACK|^BEGIN|SELECT|INSERT
                  |UPDATE|DELETE|REPLACE|^SET|UNION|^START}xi;
my $quote_re = qr/"(?:(?!(?<!\\)").)*"|'(?:(?!(?<!\\)').)*'/; # Costly!
my $bal;
$bal         = qr/
                  \(
                  (?:
                     (?> [^()]+ )    # Non-parens without backtracking
                     |
                     (??{ $bal })    # Group with matching parens
                  )*
                  \)
                 /x;

my $olc_re = qr/(?:--|#)[^'"\r\n]*(?=[\r\n]|\Z)/;  # One-line comments
my $mlc_re = qr#/\*[^!].*?\*/#sm;                  # But not /*!version */

sub new {
   my ( $class, %args ) = @_;
   my $self = { %args };
   return bless $self, $class;
}

sub strip_comments {
   my ( $self, $query ) = @_;
   $query =~ s/$olc_re//go;
   $query =~ s/$mlc_re//go;
   return $query;
}

sub fingerprint {
   my ( $self, $query ) = @_;

   $query =~ m#\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `# # mysqldump query
      && return 'mysqldump';
   $query =~ m#/\*\w+\.\w+:\d/\d\*/#     # mk-table-checksum, etc query
      && return 'maatkit';
   $query =~ m/\A# administrator command: /
      && return $query;
   $query =~ m/\A\s*(call\s+\S+)\(/i
      && return lc($1); # Warning! $1 used, be careful.
   if ( my ($beginning) = $query =~ m/\A(INSERT INTO \S+ VALUES \(.*?\)),\(/ ) {
      $query = $beginning; # Shorten multi-value INSERT statements ASAP
   }

   $query =~ s/$olc_re//go;
   $query =~ s/$mlc_re//go;
   $query =~ s/\Ause \S+\Z/use ?/i       # Abstract the DB in USE
      && return $query;

   $query =~ s/\\["']//g;                # quoted strings
   $query =~ s/".*?"/?/sg;               # quoted strings
   $query =~ s/'.*?'/?/sg;               # quoted strings

   $query =~ s{                          # Anything vaguely resembling numbers
      (?<=[^0-9+-])
      [0-9+-].*?
      (?=[^0-9a-f.xb+-]|\Z)
      }{?}gx;
   $query =~ s/[xb.+-]\?/?/g;            # Clean up leftovers
   $query =~ s/\A\s+//;                  # Chop off leading whitespace
   chomp $query;                         # Kill trailing whitespace
   $query =~ tr[ \n\t\r\f][ ]s;          # Collapse whitespace
   $query = lc $query;
   $query =~ s/\bnull\b/?/g;             # Get rid of NULLs
   $query =~ s{
               \b(in|values?)(?:[\s,]*\([\s?,]*\))+
              }
              {$1(?+)}gx;      # Collapse IN() and VALUES() lists
   $query =~ s{
               \b(select\s.*?)(?:(\sunion(?:\sall)?)\s\1)+
              }
              {$1 /*repeat$2*/}xg; # UNION
   $query =~ s/\blimit \?(?:, ?\?| offset \?)?/limit ?/; # LIMIT
   return $query;
}

sub distill {
   my ( $self, $query, %args ) = @_;
   my $qp = $args{qp} || $self->{QueryParser};
   die "I need a qp argument" unless $qp;

   $query =~ m/\A\s*call\s+(\S+)\(/i
      && return "CALL $1"; # Warning! $1 used, be careful.
   $query =~ m/\A# administrator/
      && return "ADMIN";
   $query =~ m/\A\s*use\s+/
      && return "USE";

   my @verbs = $query =~ m/\b($verbs)\b/gio;
   @verbs    = do {
      my $last = '';
      grep { my $pass = $_ ne $last; $last = $_; $pass } map { uc } @verbs;
   };
   my $verbs = join(q{ }, @verbs);
   $verbs =~ s/( UNION SELECT)+/ UNION/g;

   my @tables = map {
      $_ =~ s/`//g;
      $_ =~ s/(_?)\d+/$1?/g;
      $_;
   } $qp->get_tables($query);

   @tables = do {
      my $last = '';
      grep { my $pass = $_ ne $last; $last = $_; $pass } @tables;
   };

   $query = join(q{ }, $verbs, @tables);
   return $query;
}

sub convert_to_select {
   my ( $self, $query ) = @_;
   return unless $query;
   $query =~ s{
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*\d+(?:\s*,\s*\d+)?)?
                 \Z
              }
              {__update_to_select($1, $2, $3, $4)}exsi
      || $query =~ s{
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 }
                 {__insert_to_select($1, $2, $3)}exsi
      || $query =~ s{
                    \A.*?
                    delete\s+(.*?)
                    \bfrom\b(.*)
                    \Z
                 }
                 {__delete_to_select($1, $2)}exsi;
   $query =~ s/\s*on\s+duplicate\s+key\s+update.*\Z//si;
   $query =~ s/\A.*?(?=\bSELECT\s*\b)//ism;
   return $query;
}

sub convert_select_list {
   my ( $self, $query ) = @_;
   $query =~ s{
               \A\s*select(.*?)\bfrom\b
              }
              {$1 =~ m/\*/ ? "select 1 from" : "select isnull(coalesce($1)) from"}exi;
   return $query;
}

sub __delete_to_select {
   my ( $delete, $join ) = @_;
   if ( $join =~ m/\bjoin\b/ ) {
      return "select 1 from $join";
   }
   return "select * from $join";
}

sub __insert_to_select {
   my ( $tbl, $cols, $vals ) = @_;
   MKDEBUG && _d('Args: ', @_);
   my @cols = split(/,/, $cols);
   MKDEBUG && _d('Cols: ', @cols);
   $vals =~ s/^\(|\)$//g; # Strip leading/trailing parens
   my @vals = $vals =~ m/($quote_re|[^,]*${bal}[^,]*|[^,]+)/g;
   MKDEBUG && _d('Vals: ', @vals);
   if ( @cols == @vals ) {
      return "select * from $tbl where "
         . join(' and ', map { "$cols[$_]=$vals[$_]" } (0..$#cols));
   }
   else {
      return "select * from $tbl limit 1";
   }
}

sub __update_to_select {
   my ( $from, $set, $where, $limit ) = @_;
   return "select $set from $from "
      . ( $where ? "where $where" : '' )
      . ( $limit ? " $limit "      : '' );
}

sub wrap_in_derived {
   my ( $self, $query ) = @_;
   return unless $query;
   return $query =~ m/\A\s*select/i
      ? "select 1 from ($query) as x limit 1"
      : $query;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print "# $package:$line $$ ", @_, "\n";
}

1;

# ###########################################################################
# End QueryRewriter package
# ###########################################################################

# ###########################################################################
# LogSplitter package 2801
# ###########################################################################

package LogSplitter;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);

use constant MKDEBUG           => $ENV{MKDEBUG};
use constant MAX_OPEN_FILES    => 1000;
use constant CLOSE_N_LRU_FILES => 100;

sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(attribute saveto_dir LogParser) ) {
      die "I need a $arg argument" unless $args{$arg};
   }

   $args{saveto_dir} .= '/' if substr($args{saveto_dir}, -1, 1) ne '/';

   my $self = {
      %args,
      n_dirs          => 0,  # number of dirs created
      n_files         => -1, # number of session files in current dir
      n_sessions      => 0,  # number of sessions saved
      n_session_files => 0,  # number of session files created
      session_fhs     => [], # filehandles for each session
      n_open_fhs      => 0,  # number of open session filehandles
      sessions        => {}, # sessions data store
   };
   $self->{maxfiles}          ||= 100;
   $self->{maxdirs}           ||= 100;
   $self->{maxsessions}       ||= 100000;
   $self->{maxsessionfiles}   ||= 0;
   $self->{verbosity}         ||= 0;
   $self->{session_file_name} ||= 'mysql_log_session_';

   return bless $self, $class;
}

sub split_logs {
   my ( $self, $logs ) = @_;
   my $oktorun = 1; # true as long as we haven't created too many

   @{$self}{qw(n_dirs n_files n_sessions n_session_files)} = qw(0 -1 0 0);
   $self->{sessions} = {};

   if ( !defined $logs || scalar @$logs == 0 ) {
      MKDEBUG && _d('Implicitly reading STDIN because no logs were given');
      push @$logs, '-';
   }

   my $callback;
   if ( $self->{maxsessionfiles} ) {
      $callback = sub {
         my ( $event ) = @_;
         my ($session, $sesion_id) = $self->_get_session_ds($event);
         return 1 unless defined $session;
         $self->{n_sessions}++ if !$session->{already_seen}++;
         my $db = $event->{db} || $event->{Schema};
         if ( $db && ( !defined $session->{db} || $session->{db} ne $db ) ) {
            push @{$session->{queries}}, "USE `$db`";
            $session->{db} = $db;
         }
         push @{$session->{queries}}, $event->{arg};
         return 1;
      };
   }
   else {
      $callback = sub {
         my ( $event ) = @_; 
         my ($session, $session_id) = $self->_get_session_ds($event);
         return 1 unless defined $session;

         if ( !defined $session->{fh} ) {
            $self->{n_sessions}++;
            MKDEBUG && _d("New session: $session_id "
                          . "($self->{n_sessions} of $self->{maxsessions})");

            my $session_file = $self->_next_session_file();
            if ( !$session_file ) {
               $oktorun = 0;
               MKDEBUG && _d('No longer oktorun because no _next_session_file');
               return 1;
            }

            $self->_close_lru_session() if $self->{n_open_fhs} >= MAX_OPEN_FILES;

            open my $fh, '>', $session_file
               or die "Cannot open log split file $session_file: $OS_ERROR";
            print $fh "-- ONE SESSION\n";
            $session->{fh} = $fh;
            $self->{n_open_fhs}++;

            $session->{active}       = 1;
            $session->{session_file} = $session_file;
            push @{ $self->{session_fhs} },
               { fh => $fh, session_id => $session_id };

            MKDEBUG && _d("Created $session_file "
                          . "for session $self->{attribute}=$session_id");
         }
         elsif ( !$session->{active} ) {

            $self->_close_lru_session() if $self->{n_open_fhs} >= MAX_OPEN_FILES;

             open $session->{fh}, '>>', $session->{session_file}
                or die "Cannot reopen log split file "
                  . "$session->{session_file}: $OS_ERROR";
             $self->{n_open_fhs}++;

             $session->{active} = 1;

             MKDEBUG && _d("Reopend $session->{session_file} "
                           . "for session $self->{attribute}=$session_id");
         }
         else {
            MKDEBUG && _d("Event belongs to active session $session_id");
         }

         my $session_fh = $session->{fh};

         my $db = $event->{db} || $event->{Schema};
         if ( $db && ( !defined $session->{db} || $session->{db} ne $db ) ) {
            print $session_fh "USE `$db`\n\n";
            $session->{db} = $db;
         }

         print $session_fh "$event->{arg}\n\n";

         return 1;
      };
   }

   LOG:
   foreach my $log ( @$logs ) {
      next unless defined $log;
      if ( !-f $log && $log ne '-' ) {
         warn "Skipping $log because it is not a file";
         next LOG;
      }
      my $fh;
      if ( $log eq '-' ) {
         $fh = *STDIN;
      }
      else {
         open $fh, "<", $log or warn "Cannot open $log: $OS_ERROR\n";
      }
      if ( $fh ) {
         1 while $oktorun && $self->{LogParser}->parse_slowlog_event(
            $fh, undef, $callback);
         close $fh;
         last LOG if !$oktorun;
      }
   }

   if ( $self->{maxsessionfiles} ) {   
      for my $i ( 1..$self->{maxsessionfiles} ) {
         my $session_file = $self->_next_session_file($i);
         last if !$session_file;
         open my $fh, '>', $session_file
            or die "Cannot open session file $session_file: $OS_ERROR";
         $self->{n_session_files}++;
         print $fh "-- MULTIPLE SESSIONS\n";
         push @{ $self->{session_fhs} },
            { fh => $fh, session_file => $session_file };
      }

      my $sessions_per_file = int( $self->{n_sessions}
                                   / $self->{maxsessionfiles} );
      MKDEBUG && _d("$self->{n_sessions} session, "
                    . "$sessions_per_file per file");

      my $i      = 0;
      my $file_n = 0;
      my $fh     = $self->{session_fhs}->[0]->{fh};
      while ( my ($session_id, $session) = each %{$self->{sessions}} ) {
         $session->{session_file}
            = $self->{session_fhs}->[$file_n]->{session_file}; 
         print $fh join("\n\n", @{$session->{queries}});
         print $fh "\n"; # because join() doesn't do this
         print $fh "-- END SESSION\n\n";
         if ( ++$i >= $sessions_per_file ) {
            $i = 0;
            $file_n++ if $file_n < $self->{n_session_files} - 1;
            $fh = $self->{session_fhs}->[$file_n]->{fh};
         }
      }
   }

   while ( my $fh = pop @{ $self->{session_fhs} } ) {
      close $fh->{fh};
   }
   $self->{n_open_fhs}  = 0;

   if ( $self->{verbosity} >= 1 ) {
      print "Parsed $self->{n_sessions} sessions:\n";
      my $fmt = "   %-16s %-60s\n";
      printf($fmt, $self->{attribute}, 'Saved to log split file');
      foreach my $session_id ( sort keys %{ $self->{sessions} } ) {
         my $session = $self->{sessions}->{ $session_id };
         printf($fmt, $session_id, $session->{session_file}); 
      }
   }

   return;
}

sub _get_session_ds {
   my ( $self, $event ) = @_;

   my $attrib = $self->{attribute};
   if ( !exists $event->{ $attrib } ) {
      if ( MKDEBUG ) {
         use Data::Dumper;
         _d("No attribute $attrib in event: " . Dumper($event));
      }
      return;
   }

   return if !defined $event->{arg};

   return if $event->{cmd} eq 'Admin';

   my $session;
   my $session_id = $event->{ $attrib };

   if ( $self->{n_sessions} < $self->{maxsessions} ) {
      $session = $self->{sessions}->{ $session_id } ||= {};
   }
   elsif ( exists $self->{sessions}->{ $session_id } ) {
      $session = $self->{sessions}->{ $session_id };
   }
   else {
      MKDEBUG && _d("Skipping new session $session_id because "
                    . "maxsessions is reached");
   }

   return ($session, $session_id);
}

sub _close_lru_session {
   my ( $self ) = @_;
   my $session_fhs = $self->{session_fhs};
   my $lru_n       = $self->{n_sessions} - MAX_OPEN_FILES - 1;
   my $close_to_n  = $lru_n + CLOSE_N_LRU_FILES - 1;

   MKDEBUG && _d("Closing session fhs $lru_n..$close_to_n "
                 . "($self->{n_sessions} sessions, "
                 . "$self->{n_open_fhs} open fhs)");

   foreach my $session ( @$session_fhs[ $lru_n..$close_to_n ] ) {
      close $session->{fh};
      $self->{n_open_fhs}--;
      $self->{sessions}->{ $session->{session_id} }->{active} = 0;
   }

   return;
}

sub _next_session_file {
   my ( $self, $n ) = @_;
   return '' if $self->{n_dirs} >= $self->{maxdirs};

   if ( $self->{n_files} >= $self->{maxfiles} || $self->{n_files} < 0) {
      $self->{n_dirs}++;
      $self->{n_files} = 0;
      my $new_dir = "$self->{saveto_dir}$self->{n_dirs}";
      if ( !-d $new_dir ) {
         my $retval = system("mkdir $new_dir");
         if ( ($retval >> 8) != 0 ) {
            die "Cannot create new directory $new_dir: $OS_ERROR";
         }
         MKDEBUG && _d("Created new saveto_dir $new_dir");
      }
      elsif ( MKDEBUG ) {
         _d("saveto_dir $new_dir already exists");
      }
   }

   $self->{n_files}++;
   my $dir_n        = $self->{n_dirs} . '/';
   my $session_n    = sprintf '%04d', $n || $self->{n_sessions};
   my $session_file = $self->{saveto_dir}
                    . $dir_n
                    . $self->{session_file_name} . $session_n;
   MKDEBUG && _d("Next session file $session_file");
   return $session_file;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print "# $package:$line $$ ", @_, "\n";
}

1;

# ###########################################################################
# End LogSplitter package
# ###########################################################################

# ###########################################################################
# DSNParser package 3136
# ###########################################################################
use strict;
use warnings FATAL => 'all';

package DSNParser;

use DBI;
use Data::Dumper;
$Data::Dumper::Indent    = 0;
$Data::Dumper::Quotekeys = 0;
use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG};

sub new {
   my ( $class, @opts ) = @_;
   my $self = {
      opts => {
         A => {
            desc => 'Default character set',
            dsn  => 'charset',
            copy => 1,
         },
         D => {
            desc => 'Database to use',
            dsn  => 'database',
            copy => 1,
         },
         F => {
            desc => 'Only read default options from the given file',
            dsn  => 'mysql_read_default_file',
            copy => 1,
         },
         h => {
            desc => 'Connect to host',
            dsn  => 'host',
            copy => 1,
         },
         p => {
            desc => 'Password to use when connecting',
            dsn  => 'password',
            copy => 1,
         },
         P => {
            desc => 'Port number to use for connection',
            dsn  => 'port',
            copy => 1,
         },
         S => {
            desc => 'Socket file to use for connection',
            dsn  => 'mysql_socket',
            copy => 1,
         },
         u => {
            desc => 'User for login if not current user',
            dsn  => 'user',
            copy => 1,
         },
      },
   };
   foreach my $opt ( @opts ) {
      MKDEBUG && _d('Adding extra property ' . $opt->{key});
      $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
   }
   return bless $self, $class;
}

sub prop {
   my ( $self, $prop, $value ) = @_;
   if ( @_ > 2 ) {
      MKDEBUG && _d("Setting $prop property");
      $self->{$prop} = $value;
   }
   return $self->{$prop};
}

sub parse {
   my ( $self, $dsn, $prev, $defaults ) = @_;
   if ( !$dsn ) {
      MKDEBUG && _d('No DSN to parse');
      return;
   }
   MKDEBUG && _d("Parsing $dsn");
   $prev     ||= {};
   $defaults ||= {};
   my %given_props;
   my %final_props;
   my %opts = %{$self->{opts}};
   my $prop_autokey = $self->prop('autokey');

   foreach my $dsn_part ( split(/,/, $dsn) ) {
      if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
         $given_props{$prop_key} = $prop_val;
      }
      elsif ( $prop_autokey ) {
         MKDEBUG && _d("Interpreting $dsn_part as $prop_autokey=$dsn_part");
         $given_props{$prop_autokey} = $dsn_part;
      }
      else {
         MKDEBUG && _d("Bad DSN part: $dsn_part");
      }
   }

   foreach my $key ( keys %opts ) {
      MKDEBUG && _d("Finding value for $key");
      $final_props{$key} = $given_props{$key};
      if (   !defined $final_props{$key}
           && defined $prev->{$key} && $opts{$key}->{copy} )
      {
         $final_props{$key} = $prev->{$key};
         MKDEBUG && _d("Copying value for $key from previous DSN");
      }
      if ( !defined $final_props{$key} ) {
         $final_props{$key} = $defaults->{$key};
         MKDEBUG && _d("Copying value for $key from defaults");
      }
   }

   foreach my $key ( keys %given_props ) {
      die "Unrecognized DSN part '$key' in '$dsn'\n"
         unless exists $opts{$key};
   }
   if ( (my $required = $self->prop('required')) ) {
      foreach my $key ( keys %$required ) {
         die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
      }
   }

   return \%final_props;
}

sub as_string {
   my ( $self, $dsn ) = @_;
   return $dsn unless ref $dsn;
   return join(',',
      map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
      grep { defined $dsn->{$_} && $self->{opts}->{$_} }
      sort keys %$dsn );
}

sub usage {
   my ( $self ) = @_;
   my $usage
      = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n"
      . "  KEY  COPY  MEANING\n"
      . "  ===  ====  =============================================\n";
   my %opts = %{$self->{opts}};
   foreach my $key ( sort keys %opts ) {
      $usage .= "  $key    "
             .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
             .  ($opts{$key}->{desc} || '[No description]')
             . "\n";
   }
   if ( (my $key = $self->prop('autokey')) ) {
      $usage .= "  If the DSN is a bareword, the word is treated as the '$key' key.\n";
   }
   return $usage;
}

sub get_cxn_params {
   my ( $self, $info ) = @_;
   my $dsn;
   my %opts = %{$self->{opts}};
   my $driver = $self->prop('dbidriver') || '';
   if ( $driver eq 'Pg' ) {
      $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
         . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
                     grep { defined $info->{$_} }
                     qw(h P));
   }
   else {
      $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
         . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
                     grep { defined $info->{$_} }
                     qw(F h P S A))
         . ';mysql_read_default_group=mysql';
   }
   MKDEBUG && _d($dsn);
   return ($dsn, $info->{u}, $info->{p});
}

sub fill_in_dsn {
   my ( $self, $dbh, $dsn ) = @_;
   my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
   my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
   $user =~ s/@.*//;
   $dsn->{h} ||= $vars->{hostname}->{Value};
   $dsn->{S} ||= $vars->{'socket'}->{Value};
   $dsn->{P} ||= $vars->{port}->{Value};
   $dsn->{u} ||= $user;
   $dsn->{D} ||= $db;
}

sub get_dbh {
   my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
   $opts ||= {};
   my $defaults = {
      AutoCommit        => 0,
      RaiseError        => 1,
      PrintError        => 0,
      mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
   };
   @{$defaults}{ keys %$opts } = values %$opts;

   my $dbh;
   my $tries = 2;
   while ( !$dbh && $tries-- ) {
      MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
         join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');

      eval {
         $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);

         if ( $cxn_string =~ m/mysql/i ) {
            my $sql;

            $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
                 . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
            MKDEBUG && _d("$dbh: $sql");
            $dbh->do($sql);

            if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
               $sql = "/*!40101 SET NAMES $charset*/";
               MKDEBUG && _d("$dbh: $sql");
               $dbh->do($sql);
               MKDEBUG && _d('Enabling charset for STDOUT');
               if ( $charset eq 'utf8' ) {
                  binmode(STDOUT, ':utf8')
                     or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
               }
               else {
                  binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
               }
            }

            if ( $self->prop('setvars') ) {
               $sql = "SET " . $self->prop('setvars');
               MKDEBUG && _d("$dbh: $sql");
               $dbh->do($sql);
            }
         }
      };
      if ( !$dbh && $EVAL_ERROR ) {
         MKDEBUG && _d($EVAL_ERROR);
         if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
            MKDEBUG && _d("Going to try again without utf8 support");
            delete $defaults->{mysql_enable_utf8};
         }
         if ( !$tries ) {
            die $EVAL_ERROR;
         }
      }
   }

   MKDEBUG && _d('DBH info: ',
      $dbh,
      Dumper($dbh->selectrow_hashref(
         'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
      ' Connection info: ', ($dbh->{mysql_hostinfo} || 'undef'),
      ' Character set info: ',
      Dumper($dbh->selectall_arrayref(
         'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
      ' $DBD::mysql::VERSION: ', $DBD::mysql::VERSION,
      ' $DBI::VERSION: ', $DBI::VERSION,
   );

   return $dbh;
}

sub get_hostname {
   my ( $self, $dbh ) = @_;
   if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
      return $host;
   }
   my ( $hostname, $one ) = $dbh->selectrow_array(
      'SELECT /*!50038 @@hostname, */ 1');
   return $hostname;
}

sub disconnect {
   my ( $self, $dbh ) = @_;
   MKDEBUG && $self->print_active_handles($dbh);
   $dbh->disconnect;
}

sub print_active_handles {
   my ( $self, $thing, $level ) = @_;
   $level ||= 0;
   printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
      or die "Cannot print: $OS_ERROR";
   foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      $self->print_active_handles( $handle, $level + 1 );
   }
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print "# $package:$line $$ ", @_, "\n";
}

1;

# ###########################################################################
# End DSNParser package
# ###########################################################################

# ###########################################################################
# Transformers package 2999
# ###########################################################################

package Transformers;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Time::Local qw(timelocal);
use Digest::MD5 qw(md5_hex);

use constant MKDEBUG => $ENV{MKDEBUG};

require Exporter;
our @ISA         = qw(Exporter);
our %EXPORT_TAGS = ();
our @EXPORT      = ();
our @EXPORT_OK   = qw(
   micro_t
   percentage_of
   secs_to_time
   shorten
   ts
   parse_timestamp
   unix_timestamp
   make_checksum
);

sub micro_t {
   my ( $t, %args ) = @_;
   my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
   my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
   my $f;

   $t = 0 if $t < 0;

   $t = sprintf('%.17f', $t) if $t =~ /e/;

   $t =~ s/\.(\d{1,6})\d*/\.$1/;

   if ($t > 0 && $t <= 0.000999) {
      $f = ($t * 1000000) . 'us';
   }
   elsif ($t >= 0.001000 && $t <= 0.999999) {
      $f = sprintf("%.${p_ms}f", $t * 1000);
      $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
   }
   elsif ($t >= 1) {
      $f = sprintf("%.${p_s}f", $t);
      $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
   }
   else {
      $f = 0;  # $t should = 0 at this point
   }

   return $f;
}

sub percentage_of {
   my ( $is, $of, %args ) = @_;
   my $p   = $args{p} || 0; # float precision
   my $fmt = $p ? "%.${p}f" : "%d";
   return sprintf $fmt, ($is * 100) / ($of ||= 1);
}

sub secs_to_time {
   my ( $secs, $fmt ) = @_;
   $secs ||= 0;
   return '00:00' unless $secs;

   $fmt ||= $secs >= 86_400 ? 'd'
          : $secs >= 3_600  ? 'h'
          :                   'm';

   return
      $fmt eq 'd' ? sprintf(
         "%d+%02d:%02d:%02d",
         int($secs / 86_400),
         int(($secs % 86_400) / 3_600),
         int(($secs % 3_600) / 60),
         $secs % 60)
      : $fmt eq 'h' ? sprintf(
         "%02d:%02d:%02d",
         int(($secs % 86_400) / 3_600),
         int(($secs % 3_600) / 60),
         $secs % 60)
      : sprintf(
         "%02d:%02d",
         int(($secs % 3_600) / 60),
         $secs % 60);
}

sub shorten {
   my ( $num, %args ) = @_;
   my $p = defined $args{p} ? $args{p} : 2;     # float precision
   my $d = defined $args{d} ? $args{d} : 1_024; # divisor
   my $n = 0;
   my @units = ('', qw(k M G T P E Z Y));
   while ( $num >= $d && $n < @units - 1 ) {
      $num /= $d;
      ++$n;
   }
   return sprintf(
      $num =~ m/\./ || $n
         ? "%.${p}f%s"
         : '%d',
      $num, $units[$n]);
}

sub ts {
   my ( $time ) = @_;
   my ( $sec, $min, $hour, $mday, $mon, $year )
      = localtime($time);
   $mon  += 1;
   $year += 1900;
   return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
      $year, $mon, $mday, $hour, $min, $sec);
}

sub parse_timestamp {
   my ( $val ) = @_;
   if ( my($y, $m, $d, $h, $i, $s)
         = $val =~ m/^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)$/ )
   {
      return sprintf "%d-%02d-%02d %02d:%02d:%02d",
                     $y + 2000, $m, $d, $h, $i, $s;
   }
   return $val;
}

sub unix_timestamp {
   my ( $val ) = @_;
   if ( my($y, $m, $d, $h, $i, $s)
         = $val =~ m/^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)$/ )
   {
      return timelocal($s, $i, $h, $d, $m - 1, $y);
   }
   return $val;
}

sub make_checksum {
   my ( $val ) = @_;
   my $checksum = uc substr(md5_hex($val), -16);
   MKDEBUG && _d("$checksum checksum for $val");
   return $checksum;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print "# $package:$line $$ ", @_, "\n";
}

1;

# ###########################################################################
# End Transformers package
# ###########################################################################

# ###########################################################################
# EventAggregator package 3018
# ###########################################################################

package EventAggregator;

# This package's function is to take hashrefs and aggregate them as you specify.
# It basically does a GROUP BY.  If you say to group by z and calculate
# aggregate statistics for a, b, c then it manufactures functions to record
# various kinds of stats for the a per z, b per z, and c per z in incoming
# hashrefs.  Usually you'll use it a little less abstractly: you'll say the
# incoming hashrefs are parsed query events from the MySQL slow query log, and
# you want it to calculate stats for Query_time, Rows_read etc aggregated by
# query fingerprint.  It automatically determines whether a specified property
# is a string, number or Yes/No value and aggregates them appropriately.

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use POSIX qw(floor);

# ###########################################################################
# Set up some constants for bucketing values.  It is impossible to keep all
# values seen in memory, but putting them into logarithmically scaled buckets
# and just incrementing the bucket each time works, although it is imprecise.
# ###########################################################################
use constant MKDEBUG      => $ENV{MKDEBUG};
use constant BUCK_SIZE    => 1.05;
use constant BASE_LOG     => log(BUCK_SIZE);
use constant BASE_OFFSET  => -floor(log(.000001) / BASE_LOG); # typically 284
use constant NUM_BUCK     => 1000;
use constant MIN_BUCK     => .000001;

our @buckets  = map { 0 } (1 .. NUM_BUCK);
my @buck_vals = (MIN_BUCK, MIN_BUCK * BUCK_SIZE);
{
   my $cur = BUCK_SIZE;
   for ( 2 .. NUM_BUCK - 1 ) {
      push @buck_vals, MIN_BUCK * ($cur *= BUCK_SIZE);
   }
}

# The best way to see how to use this is to look at the .t file.
#
# %args is a hash containing:
# groupby      The name of the property to group/aggregate by.
# attributes   A hashref.  Each key is the name of an element to aggregate.
#              And the values of those elements are arrayrefs of the
#              values to pull from the hashref, with any second or subsequent
#              values being fallbacks for the first in case it's not defined.
# worst        The name of an element which defines the "worst" hashref in its
#              class.  If this is Query_time, then each class will contain
#              a sample that holds the event with the largest Query_time.
# unroll_limit If this many events have been processed and some handlers haven't
#              been generated yet (due to lack of sample data) unroll the loop
#              anyway.  Defaults to 50.
# attrib_limit Sanity limit for attribute values.  If the value exceeds the
#              limit, use the last-seen for this class; if none, then 0.
sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(groupby worst attributes) ) {
      die "I need a $arg argument" unless $args{$arg};
   }

   return bless {
      groupby      => $args{groupby},
      attributes   => {
         map  { $_ => $args{attributes}->{$_} }
         grep { $_ ne $args{groupby} }
         keys %{$args{attributes}}
      },
      worst        => $args{worst},
      unroll_limit => $args{unroll_limit} || 50,
      attrib_limit => $args{attrib_limit},
   }, $class;
}

# Aggregate an event hashref's properties.
sub aggregate {
   my ( $self, $event ) = @_;

   my $group_by = $event->{$self->{groupby}};
   return unless defined $group_by;

   ATTRIB:
   foreach my $attrib ( keys %{$self->{attributes}} ) {
      # The value of the attribute ( $group_by ) may be an arrayref.
      GROUPBY:
      foreach my $val ( ref $group_by ? @$group_by : ($group_by) ) {
         my $class_attrib  = $self->{result_class}->{$val}->{$attrib} ||= {};
         my $global_attrib = $self->{result_globals}->{$attrib} ||= {};
         my $handler = $self->{handlers}->{ $attrib };
         if ( !$handler ) {
            $handler = $self->make_handler(
               $attrib,
               $event,
               wor => $self->{worst} eq $attrib,
               alt => $self->{attributes}->{$attrib},
            );
            $self->{handlers}->{$attrib} = $handler;
         }
         next GROUPBY unless $handler;
         $handler->($event, $class_attrib, $global_attrib);
      }
   }
}

# Return the aggregated results.
sub results {
   my ( $self ) = @_;
   return {
      classes => $self->{result_class},
      globals => $self->{result_globals},
   };
}

# Return the attributes that this object is tracking, and their data types, as
# a hashref of name => type.
sub attributes {
   my ( $self ) = @_;
   return $self->{type_for};
}

# Make subroutines that do things with events.
#
# $attrib: the name of the attrib (Query_time, Rows_read, etc)
# $event:  a sample event
# %args:
#     min => keep min for this attrib (default except strings)
#     max => keep max (default except strings)
#     sum => keep sum (default for numerics)
#     cnt => keep count (default except strings)
#     unq => keep all unique values per-class (default for strings and bools)
#     all => keep a bucketed list of values seen per class (default for numerics)
#     glo => keep stats globally as well as per-class (default)
#     trf => An expression to transform the value before working with it
#     wor => Whether to keep worst-samples for this attrib (default no)
#     alt => Arrayref of other name(s) for the attribute, like db => Schema.
#
# The bucketed list works this way: each range of values from MIN_BUCK in
# increments of BUCK_SIZE (that is 5%) we consider a bucket.  We keep NUM_BUCK
# buckets.  The upper end of the range is more than 1.5e15 so it should be big
# enough for almost anything.  The buckets are accessed by a log base BUCK_SIZE,
# so floor(log(N)/log(BUCK_SIZE)).  The smallest bucket's index is -284. We
# shift all values up 284 so we have values from 0 to 999 that can be used as
# array indexes.  A value that falls into a bucket simply increments the array
# entry.
#
# This eliminates the need to keep and sort all values to calculate median,
# standard deviation, 95th percentile etc.  Thus the memory usage is bounded by
# the number of distinct aggregated values, not the number of events.
#
# Return value:
# a subroutine with this signature:
#    my ( $event, $class, $global ) = @_;
# where
#  $event   is the event
#  $class   is the container to store the aggregated values
#  $global  is is the container to store the globally aggregated values
sub make_handler {
   my ( $self, $attrib, $event, %args ) = @_;
   die "I need an attrib" unless defined $attrib;
   my ($val) = grep { defined $_ } map { $event->{$_} } @{ $args{alt} };
   my $is_array = 0;
   if (ref $val eq 'ARRAY') {
      $is_array = 1;
      $val      = $val->[0];
   }
   return unless defined $val; # Can't decide type if it's undef.

   # Ripped off from Regexp::Common::number.
   my $float_re = qr{[+-]?(?:(?=\d|[.])\d*(?:[.])\d{0,})?(?:[E](?:[+-]?\d+)|)}i;
   my $type = $val  =~ m/^(?:\d+|$float_re)$/o ? 'num'
            : $val  =~ m/^(?:Yes|No)$/         ? 'bool'
            :                                    'string';
   MKDEBUG && _d("Type for $attrib is $type (sample: $val), is array: $is_array");
   $self->{type_for}->{$attrib} = $type;

   %args = ( # Set up defaults
      min => 1,
      max => 1,
      sum => $type =~ m/num|bool/    ? 1 : 0,
      cnt => 1,
      unq => $type =~ m/bool|string/ ? 1 : 0,
      all => $type eq 'num'          ? 1 : 0,
      glo => 1,
      trf => ($type eq 'bool') ? q{($val || '' eq 'Yes') ? 1 : 0} : undef,
      wor => 0,
      alt => [],
      %args,
   );

   my @lines = ("# type: $type"); # Lines of code for the subroutine
   if ( $args{trf} ) {
      push @lines, q{$val = } . $args{trf} . ';';
   }

   foreach my $place ( qw($class $global) ) {
      my @tmp;
      if ( $args{min} ) {
         my $op   = $type eq 'num' ? '<' : 'lt';
         push @tmp, (
            'PLACE->{min} = $val if !defined PLACE->{min} || $val '
               . $op . ' PLACE->{min};',
         );
      }
      if ( $args{max} ) {
         my $op = ($type eq 'num') ? '>' : 'gt';
         push @tmp, (
            'PLACE->{max} = $val if !defined PLACE->{max} || $val '
               . $op . ' PLACE->{max};',
         );
      }
      if ( $args{sum} ) {
         push @tmp, 'PLACE->{sum} += $val;';
      }
      if ( $args{cnt} ) {
         push @tmp, '++PLACE->{cnt};';
      }
      if ( $args{all} ) {
         push @tmp, (
            # If you change this code, change the similar code in bucketize.
            'PLACE->{all} ||= [ @buckets ];',
            '$idx = BASE_OFFSET + ($val > 0 ? floor(log($val) / BASE_LOG) : 0);',
            '++PLACE->{all}->[ $idx > NUM_BUCK ? NUM_BUCK : $idx ];',
         );
      }
      push @lines, map { s/PLACE/$place/g; $_ } @tmp;
   }

   # We only save unique/worst values for the class, not globally.
   if ( $args{unq} ) {
      push @lines, '++$class->{unq}->{$val};';
   }
   if ( $args{wor} ) {
      my $op = $type eq 'num' ? '>=' : 'ge';
      push @lines, (
         'if ( $val ' . $op . ' ($class->{max} || 0) ) {',
         '   $class->{sample} = $event;',
         '}',
      );
   }

   # Make sure the value is constrained to legal limits.  If it's out of bounds,
   # just use the last-seen value for it.
   my @limit;
   if ( $args{all} && $type eq 'num' && $self->{attrib_limit} ) {
      push @limit, (
         "if ( \$val > $self->{attrib_limit} ) {",
         '   $val = $class->{last} ||= 0;',
         '}',
         '$class->{last} = $val;',
      );
   }

   # Save the code for later, as part of an "unrolled" subroutine.
   my @unrolled = (
      "\$val = \$event->{'$attrib'};",
      (map { "\$val = \$event->{'$_'} unless defined \$val;" } @{$args{alt}}),
      'defined $val && do {',
      ( map { s/^/   /gm; $_ } (@limit, @lines) ), # Indent for debugging
      '};',
   );
   $self->{unrolled_for}->{$attrib} = join("\n", @unrolled);

   # Build a subroutine with the code.
   unshift @lines, (
      'sub {',
      'my ( $event, $class, $global ) = @_;',
      'my ($val, $idx);', # NOTE: define all variables here
      (map { "\$val = \$event->{'$_'} unless defined \$val;" } @{$args{alt}}),
      'return unless defined $val;',
      ($is_array ? ('foreach my $val ( @$val ) {') : ()),
      @limit,
      ($is_array ? ('}') : ()),
   );
   push @lines, '}';
   my $code = join("\n", @lines);
   $self->{code_for}->{$attrib} = $code;

   MKDEBUG && _d("Metric handler for '$attrib': ", @lines);
   my $sub = eval join("\n", @lines);
   die if $EVAL_ERROR;
   return $sub;
}

# This method is for testing only.  If you change this code, change the code
# above too (look for bucketize).
sub bucketize {
   my ( $self, $vals ) = @_;
   my @bucketed = @buckets;
   my ($sum, $max, $min);
   $max = $min = $vals->[0];
   foreach my $val ( @$vals ) {
      my $idx = BASE_OFFSET + ($val > 0 ? floor(log($val) / BASE_LOG) : 0);
      ++$bucketed[ $idx > NUM_BUCK ? NUM_BUCK : $idx ];
      $max = $max > $val ? $max : $val;
      $min = $min < $val ? $min : $val;
      $sum += $val;
   }
   return (\@bucketed, { sum => $sum, max => $max, min => $min, cnt => scalar @$vals});
}

# This method is for testing only.
sub unbucketize {
   my ( $self, $vals ) = @_;
   my @result;
   foreach my $i ( 0 .. NUM_BUCK - 1 ) {
      next unless $vals->[$i];
      foreach my $j ( 1 .. $vals->[$i] ) {
         push @result, $buck_vals[$i];
      }
   }
   return @result;
}

# Break the buckets down into powers of ten, in 8 coarser buckets.  Bucket 0
# represents (0 <= val < 10us) and 7 represents 10s and greater.  The powers are
# thus constrained to between -6 and 1.  Because these are used as array
# indexes, we shift up so it's non-negative, to get 0 to 7.  Now you have a list
# of 1000 buckets that act as a lookup table between the 5% buckets and buckets
# of 10. TODO: right now it's hardcoded to buckets of 10, in the future maybe
# not.
{
   my @buck_tens;
   sub buckets_of {
      return @buck_tens if @buck_tens;
      @buck_tens = map {
         my $f = floor(log($_) / log(10)) + 6;
         $f > 7 ? 7 : $f;
      } @buck_vals;
      return @buck_tens;
   }
}

# Given an arrayref of vals, returns a hashref with the following
# statistical metrics:
#
#    pct_95    => The 95th percentile
#    cutoff    => How many values fall into the 95th percentile
#    stddev    => of 95% values
#    median    => of 95% values
#
# The vals arrayref is the buckets as per the above (see the comments at the top
# of this file).  $args should contain cnt, min, max and sum properties.
sub calculate_statistical_metrics {
   my ( $self, $vals, $args ) = @_;
   my $statistical_metrics = {
      pct_95    => 0,
      stddev    => 0,
      median    => 0,
      cutoff    => undef,
   };

   # These cases might happen when there is nothing to get from the event, for
   # example, processlist sniffing doesn't gather Rows_examined, so $args won't
   # have {cnt} or other properties.
   return $statistical_metrics
      unless defined $vals && @$vals && $args->{cnt};

   # Return accurate metrics for some cases.
   my $n_vals = $args->{cnt};
   if ( $n_vals == 1 || $args->{max} == $args->{min} ) {
      my $v      = $args->{max} || 0;
      my $bucket = floor( log($v > 0 ? $v : MIN_BUCK) / log(10)) + 6;
      $bucket    = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      return {
         pct_95 => $v,
         stddev => 0,
         median => $v,
         cutoff => $n_vals,
      };
   }
   elsif ( $n_vals == 2 ) {
      foreach my $v ( $args->{min}, $args->{max} ) {
         my $bucket = floor( log($v && $v > 0 ? $v : MIN_BUCK) / log(10)) + 6;
         $bucket = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      }
      my $v      = $args->{max} || 0;
      my $mean = (($args->{min} || 0) + $v) / 2;
      return {
         pct_95 => $v,
         stddev => sqrt((($v - $mean) ** 2) *2),
         median => $mean,
         cutoff => $n_vals,
      };
   }

   # Determine cutoff point for 95% if there are at least 10 vals.  Cutoff
   # serves also for the number of vals left in the 95%.  E.g. with 50 vals the
   # cutoff is 47 which means there are 47 vals: 0..46.  $cutoff is NOT an array
   # index.
   my $cutoff = $n_vals >= 10 ? int ( $n_vals * 0.95 ) : $n_vals;
   $statistical_metrics->{cutoff} = $cutoff;

   my $total_left = $n_vals;
   my $i = NUM_BUCK - 1;

   # Find the 95th percentile biggest value.  And calculate the values of the
   # ones we exclude.
   my $sum_excl  = 0;
   while ( $i-- && $total_left > $cutoff ) {
      if ( $vals->[$i] ) {
         $total_left -= $vals->[$i];
         $sum_excl   += $buck_vals[$i] * $vals->[$i];
      }
   }

   # Continue until we find the next array element that has a value.
   my $bucket_95;
   while ( $i-- ){
      $bucket_95 = $i;
      last if $vals->[$i];
   }
   return $statistical_metrics unless $vals->[$bucket_95];
   # At this point, $bucket_95 points to the first value we want to keep.

   # Calculate the standard deviation, median, and max value of the 95th
   # percentile of values.
   my $sum    = $buck_vals[$bucket_95] * $vals->[$bucket_95];
   my $sumsq  = $sum ** 2;
   my $mid    = int($cutoff / 2);
   my $median = 0;
   my $prev   = $bucket_95; # Used for getting median when $cutoff is odd

   # Continue through the rest of the values.
   while ( $i-- ) {
      my $val = $vals->[$i];
      if ( $val ) {
         $total_left -= $val;
         if ( !$median && $total_left <= $mid ) {
            $median = (($cutoff % 2) || ($val > 1)) ? $buck_vals[$i]
                    : ($buck_vals[$i] + $buck_vals[$prev]) / 2;
         }
         $sum        += $buck_vals[$i] * $val;
         $sumsq      += ($buck_vals[$i] ** 2 ) * $val;
         $prev       =  $i;
      }
   }

   my $stddev   = sqrt (($sumsq - (($sum**2) / $cutoff)) / ($cutoff -1 || 1));
   my $maxstdev = (($args->{max} || 0) - ($args->{min} || 0)) / 2;
   $stddev      = $stddev > $maxstdev ? $maxstdev : $stddev;

   MKDEBUG && _d("95 cutoff $cutoff, sum $sum, sumsq $sumsq, stddev $stddev");

   $statistical_metrics->{stddev} = $stddev;
   $statistical_metrics->{pct_95} = $buck_vals[$bucket_95];
   $statistical_metrics->{median} = $median;

   return $statistical_metrics;
}

# Find the top N or top % event keys, in sorted order, optionally including
# outliers (ol_...) that are notable for some reason.  %args looks like this:
#
#  attrib      order-by attribute (usually Query_time)
#  orderby     order-by aggregate expression (should be numeric, usually sum)
#  total       include events whose summed attribs are <= this number...
#  count       ...or this many events, whichever is less...
#  ol_attrib   ...or events where the 95th percentile of this attribute...
#  ol_limit    ...is greater than this value, AND...
#  ol_freq     ...the event occurred at least this many times.
sub top_events {
   my ( $self, %args ) = @_;
   my $classes = $self->{result_class};
   my @sorted = reverse sort { # Sorted list of $groupby values
      $classes->{$a}->{$args{attrib}}->{$args{orderby}}
         <=> $classes->{$b}->{$args{attrib}}->{$args{orderby}}
      } grep {
         # Defensive programming
         defined $classes->{$_}->{$args{attrib}}->{$args{orderby}}
      } keys %$classes;
   my @chosen;
   my ($total, $count) = (0, 0);
   foreach my $groupby ( @sorted ) {
      # Events that fall into the top criterion for some reason
      if ( 
         (!$args{total} || $total < $args{total} )
         && ( !$args{count} || $count < $args{count} )
      ) {
         push @chosen, $groupby;
      }

      # Events that are notable outliers
      elsif ( $args{ol_attrib} && (!$args{ol_freq}
         || $classes->{$groupby}->{$args{ol_attrib}}->{cnt} >= $args{ol_freq})
      ) {
         # Calculate the 95th percentile of this event's specified attribute.
         my $stats = $self->calculate_statistical_metrics(
            $classes->{$groupby}->{$args{ol_attrib}}->{all},
            $classes->{$groupby}->{$args{ol_attrib}}
         );
         if ( $stats->{pct_95} >= $args{ol_limit} ) {
            push @chosen, $groupby;
         }
      }

      $total += $classes->{$groupby}->{$args{attrib}}->{$args{orderby}};
      $count++;
   }
   return @chosen;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   # Use $$ instead of $PID in case the package
   # does not use English.
   print "# $package:$line $$ ", @_, "\n";
}

1;

# ###########################################################################
# End EventAggregator package
# ###########################################################################

# ###########################################################################
# And now for the "program".
# ###########################################################################
package main;

use POSIX;
use Time::HiRes qw(time usleep);
use Data::Dumper;
$Data::Dumper::Indent    = 1;
$Data::Dumper::Quotekeys = 0;

use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG};

Transformers->import( qw(micro_t shorten) );

# #############################################################################
# Get configuration information.
# #############################################################################
my $dp = new DSNParser();
$dp->prop('autokey', 'h');
my @opt_spec = OptionParser::pod_to_spec();
my $opt_parser = new OptionParser(@opt_spec);
$opt_parser->{dsn}    = $dp;
$opt_parser->{strict} = 0;
$opt_parser->{prompt} = '[OPTION].. DSN [DSN...]';
$opt_parser->{descr}  = q{splits and plays slow log files.};
my %opts = $opt_parser->parse();
$dp->prop('setvars', $opts{setvars});

# If not --split, then the remaining argv should be a DSN.
my $dsn;
if ( !$opts{s} && !$opts{print} ) {
   my $dsn_args = shift @ARGV;
   if ( $opts{p} && !$dsn_args ) {
      $opt_parser->error('At least one DSN is required with --play');
   }
   $dsn = $dp->parse($dsn_args);
}

$opt_parser->usage_or_errors(%opts);

# #############################################################################
# Split the logs into session files and exit.
# #############################################################################
if ( $opts{s} ) {
   if ( $opts{saveto} && !-d $opts{saveto} ) {
      die "$opts{saveto} is not a directory"
   }

   # It's sad because I wrote this script but I still frequently forget
   # to specify the split attribute (Thread_id, etc.). So the log file
   # is taken to be the split attrib and then LogSplitter tries to read
   # from STDIN. This is my self-reminder.
   warn "The --split attribute $opts{s} does not seem to be valid"
      if $opts{s} !~ m/^[\w]+$/;

   $ARGV[0] = '-' if scalar @ARGV == 0; # causes LogSplitter to read STDIN

   my $lp = new LogParser;
   my $ls = new LogSplitter(
      attribute         => $opts{s},
      saveto_dir        => $opts{saveto},
      maxdirs           => $opts{D},
      maxfiles          => $opts{F},
      maxsessions       => $opts{S},
      maxsessionfiles   => $opts{M},
      verbosity         => $opts{v},
      session_file_name => $opts{sessionfilename},
      LogParser         => $lp,
   );
   $ls->split_logs(\@ARGV);

   exit;
}

# #############################################################################
# Make list of session files to play. If playing a whole, the log is
# treated as one big session file.
# #############################################################################
my @session_files;
foreach my $session_file ( split ',', $opts{p} ) {
   # The session "file" might actually be a dir, in which case we
   # read ALL files in that dir.
   if ( -d $session_file ) {
      MKDEBUG && _d("Reading all session log files in $session_file");
      opendir my $dir, $session_file
         or die "Cannot open directory $session_file: $OS_ERROR";
      push @session_files,
         map     { "$session_file/$_"    } # 3. Save full dir/file
         grep    { -f "$session_file/$_" } # 2. If it's a file
         readdir $dir;                     # 1. Each file in dir
      closedir $dir;
   }
   else {
      push @session_files, $session_file;
   }
}

MKDEBUG && _d('Session files: ' . Dumper(\@session_files));

if ( @session_files == 0 ) {
   die 'No valid session files';
}

# #############################################################################
# Connect parent to MySQL.
# #############################################################################
my $parent_dbh;
if ( !$opts{print} ) {
   if ( !$dsn->{p} && $opts{askpass} ) {
      $dsn->{p} = OptionParser::prompt_noecho("Enter password for $dsn->{h}: ");
   }
   $parent_dbh = get_cxn($dsn);
   $parent_dbh->{InactiveDestroy} = 1; # Don't die on fork().
}

# #############################################################################
# Assign sessions to child processes.
# #############################################################################
my %children;
my %exited_children;
# This signal handler will do nothing but wake up the sleeping parent process
# and record the exit status and time of the child that exited (as a side
# effect of not discarding the signal).
# -- Presently, however, we do not use this information.
$SIG{CHLD} = sub {
   my $pid;
   while (($pid = waitpid(-1, POSIX::WNOHANG)) > 0) {
      # Must right-shift to get the actual exit status of the child.
      $exited_children{$pid}->{exit_status} = $CHILD_ERROR >> 8;
      $exited_children{$pid}->{exit_time}   = time;
   }
};

my $qr = new QueryRewriter(); # shared by the children
my $session_n = 0;
my $session_itr;

# These 3 vars are used by get_next_session_itr().
# TODO: modularize this; something like SessionItr.pm.
my $session_file;
my $session_fh;
my $done_reading_session_file = 1;

do {
   wait_for_server($parent_dbh, $dsn) unless $opts{print};

   while ( $opts{c} > keys %children
           && ($session_itr = get_next_session_itr()) ) {
      usleep( get_delay($opts{'delaysessions'}) );
      $session_n++;
      my $pid = fork();
      die "Cannot fork: $OS_ERROR" unless defined $pid;
      if ( $pid ) {              # I'm the parent.
         $children{$pid} = $session_file;
      }
      else {                     # I'm the child.
         $SIG{CHLD} = 'DEFAULT'; # See bug #1886444
         MKDEBUG && _d("Child PID $PID got $session_file ($session_n)");
         play_session($session_n, $session_itr);
         MKDEBUG && _d("Child PID $PID done");
         exit;
      }
   } 

   # Possibly wait for child.
   my $reaped = 0;
   foreach my $pid ( keys %exited_children ) { 
      delete $children{$pid};
      delete $exited_children{$pid};
      $reaped = 1;
      MKDEBUG && _d("Reaped child PID $pid");
   }

   if ( keys %children && !$reaped ) {
      # Don't busy-wait.  But don't wait forever either, as a child may exit
      # and signal while we're not sleeping, so if we sleep forever we may
      # not get the signal.
      MKDEBUG && _d("Sleeping to wait for children");
      sleep(1);
   }
   MKDEBUG && _d(scalar keys %children, ' children are still working');

} while ( $session_itr || keys %children );

exit;

# #############################################################################
# Subroutines.
# #############################################################################

sub wait_for_server {
   my ( $dbh, $dsn ) = @_;
   my $tries = 0;
   while ( !$dbh->ping && $tries++ < $opts{w} ) {
      sleep(1);
      eval {
         $dbh = get_cxn($dsn);
      };
      if ( $EVAL_ERROR ) {
         info(0, 'Waiting: ' . scalar(localtime) . ' '
            . mysql_error_msg($EVAL_ERROR));
      }
   }
   if ( $tries >= $opts{w} ) {
      die "Too many retries while waiting for server, exiting.\n";
   }
}

sub get_next_session_itr {
   if ( $done_reading_session_file ) {
      MKDEBUG && _d("Done reading session file "
         . ($session_file || '(opening first session file)'));
      close $session_fh if defined $session_fh;
      $session_file = shift @session_files;
      return unless defined $session_file;
      MKDEBUG && _d("Opened session file $session_file");

      if ( $session_file eq '-' ) {
         $session_fh = *STDIN;
      }
      else {
         if ( !open $session_fh, '<', $session_file ) {
            warn "Cannot open session file $session_file: $OS_ERROR";
            $done_reading_session_file = 1;
            return get_next_session_itr();
         }
      }

      # TODO: don't hard-code the delimiters below. Make them constants
      # or something in LogSplitter.
      # TODO: will this even work if reading STDIN?
      my $first_line = <$session_fh>;
      if ( $first_line =~ m/-- MULTIPLE SESSIONS/ ) {
         MKDEBUG && _d('Multiple sessions in this file');
         $done_reading_session_file = 0;
         return get_next_session_itr();
      }
      elsif ( $first_line =~ m/-- ONE SESSION/ ) {
         MKDEBUG && _d('One session in this file');
         $done_reading_session_file = 1;
         return sub {
            local $INPUT_RECORD_SEPARATOR = '';
            my $query = <$session_fh>;
            $query =~ s/\n+$// if $query;
            return $query;
         };
      }
      else {
         warn "Malformed session file: $session_file\n"
            . "First line is not -- MULTIPLE SESSION or -- ONE SESSION";
         $done_reading_session_file = 1;
         return get_next_session_itr();
      }
   }
   else {
      local $INPUT_RECORD_SEPARATOR = "\n-- END SESSION\n\n";
      my $session = <$session_fh>;
      if ( $session ) {
         MKDEBUG && _d("Read a session in $session_file");
         $done_reading_session_file = 0;
         chomp $session;
         my @queries = split("\n\n", $session);
         return sub { return shift @queries; };
      }
      else {
         MKDEBUG && _d("No more sessions in $session_file");
         $done_reading_session_file = 1;
         return get_next_session_itr();
      }
   }
}

sub play_session {
   my ( $session_n, $get_next_query ) = @_;
   my $dbh        = get_cxn($dsn) unless $opts{print};
   my $query_n    = 0;
   my $ea         = new EventAggregator(
      groupby      => 'arg',
      attributes   => {
         query_time => [qw(query_time)],
         n_rows     => [qw(n_rows)],
      },
      worst=>       => 'query_time',
   );

   my $total_time = time;
   QUERY:
   while ( defined (my $query = $get_next_query->()) ) {

      if ( $opts{onlyselect} && $query !~ m/^(?:SELECT|USE) /i ) {
         MKDEBUG && _d("Skipping query for --onlyselect: $query");
         next QUERY;
      }

      $query_n++;

      if ( $opts{print} ) {
         print "/* session $session_n query $query_n */ $query\n";
         next QUERY;
      }

      # USE statements are not timed.
      if ( $query =~ /^USE /i ) {
         eval { $dbh->do($query); };
         if ( $EVAL_ERROR ) {
            # TODO: save errors to be optionally reported later
         }
         next QUERY;
      }

      usleep( get_delay($opts{'delayqueries'}) );

      my $n_rows           = 0;
      my $query_start_time = time;

      if ( $query =~ m/^SELECT /i ) {
         # Count number of rows returned by SELECTs.
         my $results = $dbh->selectall_arrayref($query);
         $n_rows = scalar @$results;
      }
      else {
         # Non-SELECTs do not return anything, therefore we can
         # just do() them.
         $dbh->do($query);
      }

      my $event = {
         arg        => $query,
         query_time => time - $query_start_time,
         n_rows     => $n_rows,
      };
      $ea->aggregate($event);
   }

   if ( !$opts{print} ) {
      $total_time = time - $total_time;
      $dbh->disconnect();
      my $results = $ea->results();
      report_session_stats($session_n, $total_time, $results);
   }

   return;
}

sub report_session_stats {
   my ( $session_n, $total_time, $results ) = @_;
   my $global = $results->{globals};

   if ( !$global->{query_time}->{cnt} ) {
      # This can happen if a session was all non-SELECTs and
      # --onlyselect was given.
      MKDEBUG && _d("Session $session_n has no valid queries");
      return;
   }

   # Global Queries and Rows per second, and avg query time.
   my $qps = sprintf '%.6f',
      $global->{query_time}->{cnt} / $global->{query_time}->{sum};
   my $rps = sprintf '%.6f',
      $global->{n_rows}->{sum} / $global->{query_time}->{sum};
   my $avg = sprintf '%.6f',
      $global->{query_time}->{sum} / $global->{query_time}->{cnt};

   # Stats for all queries (global).
   my $s = $opts{csv} ? ',' : "\t";
   print "session number"
      .  "$s"."total time"
      .  "$s"."min query time"
      .  "$s"."max query time"
      .  "$s"."avg query time"
      .  "$s"."number of queries"
      .  "$s"."queries per second"
      .  "$s"."number of rows"
      .  "$s"."rows per second"
      .  "\n";

   print "$session_n"
      .  "$s$total_time"
      .  "$s$global->{query_time}->{min}"
      .  "$s$global->{query_time}->{max}"
      .  "$s$avg"
      .  "$s$global->{query_time}->{cnt}"
      .  "$s$qps"
      .  "$s$global->{n_rows}->{sum}"
      .  "$s$rps"
      .  "\n";

   # Per-query stats.
   print "query count"
      .  "$s"."total time"
      .  "$s"."min time"
      .  "$s"."max time"
      .  "$s"."avg time"
      .  "$s"."total rows"
      .  "$s"."min rows"
      .  "$s"."max rows"
      .  "$s"."sample"
      .  "\n";

   foreach my $query ( values %{$results->{classes}} ) {
      $avg = sprintf('%.6f',
         $query->{query_time}->{sum} / $query->{query_time}->{cnt});
      print "$query->{query_time}->{cnt}"
         .  "$s$query->{query_time}->{sum}"
         .  "$s$query->{query_time}->{min}"
         .  "$s$query->{query_time}->{max}"
         .  "$s$avg"
         .  "$s$query->{n_rows}->{sum}"
         .  "$s$query->{n_rows}->{min}"
         .  "$s$query->{n_rows}->{max}"
         .  "$s$query->{query_time}->{sample}->{arg}"
         .  "\n";
   }
   print "\n";

   return;
}

sub get_delay {
   my ( $delay ) = @_;
   return 0 if !defined $delay || scalar @$delay == 0;
   my $t = 0;

   my ( $from, $to ) = @$delay[0..1];
   if ( defined $to ) {
      $t = rand($to) + $from;
   }
   else {
      $t = $from;
   }

   # Return time is expressed in microseconds because this value
   # is used with usleep() which takes a microsecond time value.
   return $t *= 1_000_000;
}

sub get_cxn {
   my ( $dsn ) = @_;
   return $dp->get_dbh( $dp->get_cxn_params($dsn) );
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   # Use $$ instead of $PID in case the package
   # does not use English.
   print "# $package:$line $$ ", @_, "\n";
}

# ############################################################################
# Documentation.
# ############################################################################

=pod

=head1 NAME

mk-log-player - Split and play MySQL slow logs.

=head1 SYNOPSIS

   # Split mysql-slow.log into sessions grouped by Thread_id 
   # (one session per file). Then play all those sessions against host1.
   mk-log-player --split Thread_id mysql-slow.log
   mk-log-player --play  /tmp/mysql_log_session_* h=host1

=head1 DESCRIPTION

=head1 DOWNLOADING

You can download Maatkit from Google Code at
L<http://code.google.com/p/maatkit/>, or you can get any of the tools
easily with a command like the following:

   wget http://www.maatkit.org/get/toolname
   or
   wget http://www.maatkit.org/trunk/toolname

Where C<toolname> can be replaced with the name (or fragment of a name) of any
of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
needed.  The first URL gets the latest released version of the tool, and the
second gets the latest trunk code from Subversion.

=head1 OPTIONS

Specify at least one of --play or --split.

--play and --split are mutually exclusive.

=over

=item --askpass

Prompt for a password when connecting to MySQL.

=item --concurrency

short form: -c; type: int; default: 1

Number of concurrent sessions to play.

=item --csv

Comma-separate output of performance metrics.

=item --delaysessions

type: array; default: 0

Amount of delay time between playing sessions.

Delay time is given in seconds (with microsecond precision) and can either be
a single value or a range. Single values cause an exact delay of the value time
(example: 0.010 = delay 10 milliseconds). Ranges cause a random delay between
the given value times (example: 0.001,1 = random delay from 1 millisecond to
1 second).

=item --delayqueries

type: array; default: 0

Amount of delay time between executing queries in each session.

Delay time is given in seconds (with microsecond precision) and can either be
a single value or a range. Single values cause an exact delay of the value time
(example: 0.010 = delay 10 milliseconds). Ranges cause a random delay between
the given value times (example: 0.001,1 = random delay from 1 millisecond to
1 second).

=item --maxdirs

short form: -D; type: int; default: 100

Max number of directories to create for saving session files.

So that one directory does not become overloaded with session files,
C<mk-log-player> creates up to this many directories and saves up to
L<"--maxfiles"> in each directory.

Each directory is a sub-directory of L<"--saveto">, numbered sequentially
starting with 1/.

L<"--maxdirs"> and L<"--maxfiles"> and L<"--maxsessions"> are never exceeded.
If one option limits another, the most restrictive option is respected and
the other options will not reach their maxes. The default values for
L<"--maxdirs"> and L<"--maxfiles"> allow for 100,000 sessions: 100 files
in 100 directories.

=item --maxfiles

short form: -F; type: int; default: 100

Max number of session failes to create per directory.

L<"--maxdirs"> and L<"--maxfiles"> and L<"--maxsessions"> are never exceeded.
If one option limits another, the most restrictive option is respected and
the other options will not reach their maxes. The default values for
L<"--maxdirs"> and L<"--maxfiles"> allow for 100,000 sessions: 100 files
in 100 directories.

=item --maxsessions

short form: -S; type: int

Max number of sessions to save with --split.

By default, C<mk-log-player> tries to save every session from the main
log file. For huge logs, however, this can result in hundreds of thousands of
sessions. This option causes only the first N number of sessions to be saved.

See also L<"--maxdirs"> and L<"--maxfiles">.

=item --maxsessionfiles

short form: -M; type: int; default: 0

Max number of session files in which sessions are saved with --split.

By default, one session is saved in one file up to L<"--maxsessions">
(and L<"--maxfiles"> and L<"--maxdirs">). This option causes several sessions
to be saved to a limited number of files up to L<"--maxsessions">.

For example, if you want to split a lot with 10,000 sessions into only two
session files, each one containing 5,000 session, then specify
--maxsessionfiles 2.

If, for the same 10,000 session log, you specify --maxsessionfiles 2
and --maxsessions 2000, then the two session files will each contain 1,000
sessions.

=item --onlyselect

Play only SELECT queries.

=item --play

short form: -p; type: string

Play (execute) session files created by --split.

The argument to play must be a commaxn-separated list of session files
created by L<"--split"> or a directory. If the argument is a directory,
ALL files in that directory will be played.

=item --print

Print queries instead of playing them.

=item --saveto

type: string; default: /tmp/

Base directory under  which to save session files.

Up to L<"--maxdirs"> additional directories will be created under this
directory.

=item --sessionfilename

type: string; default: mysql_log_session_

Base name for session files saved by --split.

Each session file saved by L<"--split"> will begin with this base session
name and then be postfixed with a 4-digit, zero-padded session ID. For
example, with the default session file name: mysql_log_session_0001,
mysql_log_session_0002, etc.

=item --split

short form: -s; type: string

Split log by given attribute to create session files.

Valid attributes are any which appear in the log: Thread_id, Schema,
etc.

=item --verbosity

short form: -v; cumulative: yes; default: 0

Increase verbosity; can specifiy multiple times.

=item --wait

short form: -w; type: time; default: 5m

Wait limit when server is down.

=back

=head1 SYSTEM REQUIREMENTS

You need Perl and some core packages that ought to be
installed in any reasonably new version of Perl.

=head1 ENVIRONMENT

The environment variable C<MKDEBUG> enables verbose debugging output in all of
the Maatkit tools:

   MKDEBUG=1 mk-....

=head1 BUGS

Please use Google Code Issues and Groups to report bugs or request support:
L<http://code.google.com/p/maatkit/>.

Please include the complete command-line used to reproduce the problem you are
seeing, the version of all MySQL servers involved, the complete output of the
tool when run with L<"--version">, and if possible, debugging output produced by
running with the C<MKDEBUG=1> environment variable.

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright 2008-@CURRENTYEAR@ Percona Inc.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Daniel Nichter

=head1 VERSION

This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision$.

=cut
