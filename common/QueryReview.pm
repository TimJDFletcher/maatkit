# This program is copyright 2008-@CURRENTYEAR@ Percona Inc.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.
# ###########################################################################
# QueryReview package $Revision$
# ###########################################################################
package QueryReview;

# qv is short for "query review" throughout this module.

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);

use Digest::MD5 qw(md5_hex);

use constant MKDEBUG => $ENV{MKDEBUG};

# Required args:
# dbh         A dbh to the server with the query review table.
# qv_tbl      Full db.tbl name of the query review table.
#             Make sure the table exists! It's not checked here;
#             check it before instantiating an object.
# tbl_struct  Return val from TableParser::parse() for qv_tbl.
#             This is used to discover what columns qv_tbl has.
sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(dbh qv_tbl tbl_struct) ) {
      die "I need a $arg argument" unless $args{$arg};
   }

   # Pre-load the fingerprints that are in the query review table
   # (qv_tbl) to avoid unnecessary lookups in store_events().
   my %fingerprints
      = map {
           $_->[0] => {
              checksum => $_->[1],
              sample   => $_->[2],
           }
        }
        @{ $args{dbh}->selectall_arrayref(
              "SELECT fingerprint, checksum, sample FROM $args{qv_tbl}") };

   my $store_new_sth = $args{dbh}->prepare(
         'INSERT IGNORE INTO ' . $args{qv_tbl}
         . '(checksum, fingerprint, sample, first_seen, last_seen) VALUES( '
         . '?, ?, ?, COALESCE(?, NOW()), COALESCE(?, NOW()))');

   my $self = {
      dbh           => $args{dbh},
      qv_tbl        => $args{qv_tbl},
      fingerprints  => \%fingerprints,
      store_new_sth => $store_new_sth,
   };
   return bless $self, $class;
}

# Save or update the given query in the query review table (qv_tbl).
# The fingerprint is given so that it does not have to be computed
# multiple times (since fingerprinting is our most expensive operation).
sub store_event {
   my ( $self, $fingerprint, $event ) = @_;

   if ( exists $self->{fingerprints}->{$fingerprint} ) {
      my $fp = $self->{fingerprints}->{$fingerprint};
      $self->{dbh}->do("UPDATE $self->{qv_tbl} "
         . "SET cnt=cnt+1 WHERE checksum=$fp->{checksum}"); 
      # TODO: update other columsn as need (i.e. optional metric columns)
   }
   else {
      # The primary key value (checksum column) is generated by checksumming
      # the query and then converting part of the checksum into a bigint.
      my $ts       = _parse_timestamp($event->{ts});
      my $checksum = fingerprint_checksum($fingerprint);

      # fingerprint_checksum() above returns a hex string which is
      # stored as a bigint (64-bit) in MySQL. So we need to convert
      # the hex string (base 16) to a number (base 10). Perl's
      # built-in hex function does this, but it complains that it's
      # not portable. So we'll just use MySQL to do the converstion.
      # TODO: Can't this be done w/ unpack('Q', $checksum)?
      my $conv = $self->{dbh}->selectall_arrayref(
         "SELECT CONV('$checksum', 16, 10)");
      $checksum = $conv->[0]->[0];

      $self->{store_new_sth}->execute(
         $checksum,
         $fingerprint,
         $event->{arg},
         $ts,
         $ts);

      $self->{fingerprints}->{$fingerprint} = {
         checksum  => $checksum,
         sample    => $event->{sample} || '',
      };
   }
   return;
}

# Takes the rightmost 64 bits of an MD5 checksum of the argument.
sub fingerprint_checksum {
   my ( $fingerprint ) = @_;
   return substr(md5_hex($fingerprint), -16);
}

# Turns 071015 21:43:52 into a proper datetime format.
# TODO: this should probably go in Transformers
sub _parse_timestamp {
   my ( $val ) = @_;
   return $val unless defined $val;
   $val =~ s/^(\d\d)(\d\d)(\d\d) /20$1-$2-$3 /;
   return $val;
}

sub _d {
   my ( $line ) = (caller(0))[2];
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; } @_;
   print "# QueryReview:$line $PID ", @_, "\n";
}

1;
# ###########################################################################
# End QueryReview package
# ###########################################################################
