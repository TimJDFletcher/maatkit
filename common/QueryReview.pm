# This program is copyright 2008-@CURRENTYEAR@ Percona Inc.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.
# ###########################################################################
# QueryReview package $Revision$
# ###########################################################################
package QueryReview;

# qv is short for "query review" throughout this module.

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);

use Digest::MD5 qw(md5_hex);
use Data::Dumper;

use constant MKDEBUG => $ENV{MKDEBUG};

# Required args:
# key_attrib    See SQLMetrics::new().
# fingerprint   See SQLMetrics::new().
# dbh           A dbh to the server with the query review table.
# qv_tbl        Full db.tbl name of the query review table.
#               Make sure the table exists! It's not checked here;
#               check it before instantiating an object.
# tbl_struct    Return val from TableParser::parse() for qv_tbl.
#               This is used to discover what columns qv_tbl has.
#
# Optional args:
# preload       SQL clause to limit pre-loaded fingerprints that
#               comes after 'FROM qv_tbl' so it can be a WHERE clause
#               or just LIMIT.
sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(dbh qv_tbl tbl_struct key_attrib fingerprint) ) {
      die "I need a $arg argument" unless $args{$arg};
   }

   # Pre-load the fingerprints that are in the query review table
   # (qv_tbl) to avoid unnecessary lookups in store_events().
   my $sql = "SELECT fingerprint, checksum, sample, last_seen "
           . "FROM $args{qv_tbl} "
           . ($args{preload} ? $args{preload} : '');
   my %fingerprints
      = map {
           $_->[0] => {
              checksum  => $_->[1],
              sample    => $_->[2],
              last_seen => $_->[3],
           }
        }
        @{ $args{dbh}->selectall_arrayref($sql) };

   my $store_new_sth = $args{dbh}->prepare(
         'INSERT IGNORE INTO ' . $args{qv_tbl}
         . '(checksum, fingerprint, sample, first_seen, last_seen) VALUES( '
         . '?, ?, ?, COALESCE(?, NOW()), COALESCE(?, NOW()))');

   my $self = {
      dbh           => $args{dbh},
      qv_tbl        => $args{qv_tbl},
      fingerprints  => \%fingerprints,
      store_new_sth => $store_new_sth,
      key_attrib    => $args{key_attrib},
      fingerprint   => $args{fingerprint}
                       || sub { $_[0]->{$args{key_attrib}} },

   };
   return bless $self, $class;
}

# Save or update the given event in the query review table (qv_tbl).
sub store_event {
   my ( $self, $event ) = @_;

   # Skip events which do not have the key_attrib attribute.
   my $key_attrib_val = $event->{ $self->{key_attrib} };
   return unless defined $key_attrib_val;

   # Get the fingerprint for this event.
   my $fingerprint = $self->{fingerprint}->($key_attrib_val);

   # If we've seen this fingerprint already, update the qv_tbl.
   # Else, add the event to the qv_tbl.
   if ( exists $self->{fingerprints}->{$fingerprint} ) {
      my $fp = $self->{fingerprints}->{$fingerprint};
      my @sets;

      # Update event count.
      push @sets, 'cnt=cnt+1';

      # Update last_seen.
      my $ts = _parse_timestamp($event->{ts});
      if ( $ts && $ts ge $fp->{last_seen} ) {
         push @sets, "last_seen='$ts'";
         $fp->{last_seen} = $ts;
      }

      # TODO: update other columsn as need (i.e. optional metric columns)

      my $set_clause = join(',', @sets);
      my $sql        = "UPDATE $self->{qv_tbl} "
                     . "SET $set_clause "
                     . "WHERE checksum=$fp->{checksum}";
      $self->{dbh}->do($sql);
   }
   else {
      # The primary key value (checksum column) is generated by checksumming
      # the query and then converting part of the checksum into a bigint.
      my $ts       = _parse_timestamp($event->{ts});
      my $checksum = fingerprint_checksum($fingerprint);

      # fingerprint_checksum() above returns a hex string which is
      # stored as a bigint (64-bit) in MySQL. So we need to convert
      # the hex string (base 16) to a number (base 10). Perl's
      # built-in hex function does this, but it complains that it's
      # not portable. So we'll just use MySQL to do the converstion.
      # TODO: Can't this be done w/ unpack('Q', $checksum)?
      my $conv = $self->{dbh}->selectall_arrayref(
         "SELECT CONV('$checksum', 16, 10)");
      $checksum = $conv->[0]->[0];

      $self->{store_new_sth}->execute(
         $checksum,
         $fingerprint,
         $event->{arg},
         $ts,
         $ts);
      MKDEBUG && _d("Added event to query review table: "
                    . "$checksum $fingerprint $ts");

      # Save the event's fingerprint and its checksum in our
      # local "fingerprint cache."
      $self->{fingerprints}->{$fingerprint} = {
         checksum  => $checksum,
         sample    => $event->{sample} || '',
         last_seen => $ts || '', # TODO: is this correct or do we need now()?
      };
   }
   return;
}

# Takes the rightmost 64 bits of an MD5 checksum of the argument.
sub fingerprint_checksum {
   my ( $fingerprint ) = @_;
   return substr(md5_hex($fingerprint), -16);
}

# Turns 071015 21:43:52 into a proper datetime format.
# TODO: this should probably go in Transformers
sub _parse_timestamp {
   my ( $val ) = @_;
   return $val unless defined $val;
   $val =~ s/^(\d\d)(\d\d)(\d\d) /20$1-$2-$3 /;
   return $val;
}

sub _d {
   my ( $line ) = (caller(0))[2];
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; } @_;
   print "# QueryReview:$line $PID ", @_, "\n";
}

1;
# ###########################################################################
# End QueryReview package
# ###########################################################################
