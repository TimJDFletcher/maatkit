The following items are unimplemented at this time:

   General:
      * add a --sudo option.  If commands such as dmidecode don't work, this
        option makes them retry with sudo.
   Operating System:
      * Are we inside a Virtual Machine like VMWare or VirtualBox?
      * Some Linux-specific parameters that we commonly check/tweak:
        - (others?)
      * use ethtool, ip, etc to discover nics, IP addresses and network speed
      * Show the IO scheduler in use.
        cat /sys/block/sda/queue/scheduler
      * Show /proc/partitions.
      * Show /proc/scsi/scsi in a digested format
   Hardware
      * raid status: (is this working? other info to capture?)
         - parse multiple adapters
         - /usr/StorMan/arcconf GETCONFIG 1 LD 1 is something to test
           sample on issue 2398, email 9
         - check issue 1445, the first attached file has some dmesg stuff that
           is parseable.
      * check where MySQL data is stored, and make sure that filesystem is
        mounted with noatime.
      * Check that filesystems are as big as the partitions they live on.
      * Check fragmentation (with filefrag) of ibdata1 and/or the biggest table
        files.
   Operating System
      * vmstat samples
      * iostat usage if possible
      * Snapshot of interesting things from ps -- the top few memory and CPU
        time users.  Omit common kernel stuff, etc.
   Memcached
      * Notify if there is a memcached instance on the box.  Try to grab stats
        and show the more interesting ones.  See
        http://dev.mysql.com/doc/refman/5.0/en/ha-memcached-stats-general.html
        Sample ps line fro ps -eaf | grep memc:
        memcached -d -p 11211 -u nobody -m 384 -c 1024 -P
        /var/run/memcached/memcached.pid -l 10.0.0.7
   MySQL
      * for each instance, do:
         * run mysqld --help --verbose and make sure config file is valid
         * --log-warnings being defined is cause for an alert
         * old-style replication options -- show an alert
         * alert if non-standard my.cnf location
         * show size of slow log
         * look for incorrectly rotated slow / error logs with lsof
         * show read/write percentage (number of queries, and number of rows
           from Handler)
         * Alert if the version is really old, or end-of-life.  3.x and 4.x are
           EOL now, and 4.1 should at least be >= 4.1.20 (the EOL and really-old
           warnings should be separate).  5.0.37 is the minimum useful 5.0
           version.
      * Data and schema
         * Support percona extensions to show most active users/tables and if
           they are not available, just say something about it.
         * filefrag on data files?
         * note if a storage engine is enabled but not in use -- but check for
           permissions to see everything before warning about this, otherwise
           can have false pos.
         * fragmentation from SHOW TABLE STATUS (as reported by innodb free
           space, depending on file-per-table; or for single-file, amount of
           space used/free in ibdata1) or for myisam, Data_free field; show
           worst 5 fragmented in tabular format as usual
             * true fragmentation -- if our patched innodb buffer pool contents
               is installed
         * verbose option: 
            produce a detailed per-db, per-tbl schema report showing size, index
            size, engine, number of indexes, number of columns etc for each
            table.  Maybe also mention unusual data types in the table, or a
            summary of the data types.  Also show triggers.
            * for datetime columns, check a naming convention and guess whether
              they can be timestamp instead.  'ts', 'created_at', 'last_updated'
            * Try to find ip adress columns that are stored as varchar (again,
              naming convention).  Names I've seen: ip
            * Alert if there are columns in different tables with the same name
              and different data types.  See email 25020 on Percona issue id
              1881 for an example, but don't do an information_schema query to
              find this out.
            * For each table with an auto-inc PK and a timestamp, try to guess
               how many rows/day it grows, both overall and more recently, by
               splitting up and getting the timestamps at various points in th
               table.
            * Draw a histogram of these values.
      * Indexes:
         * Top N tables with the most/least indexes
         * Compute indexes that are not very selective
      * Storage engines
         * views
         * merge tables (how many are broken)
            * check if MERGE tables sum up the size of their contained tables in
              SHOW TABLE STATUS
            * look for this error in SHOW TABLE STATUS: Unable to open
              underlying table
         * partitioned tables
            * count of partitioned tables; this can be seen in Create_options in
              show table status, or from i_s tables, or create table
            * look for partitioned tables that don't have many future partitions:
              ) ENGINE=InnoDB DEFAULT CHARSET=latin1 /*!50100 PARTITION BY RANGE
              (YEAR(day)) (PARTITION p_2006 VALUES LESS THAN (2007) ENGINE = InnoDB,
              PARTITION p_2007 VALUES LESS THAN (2008) ENGINE = InnoDB, PARTITION p_2008
              VALUES LESS THAN (2009) ENGINE = InnoDB, PARTITION p_catchall VALUES LESS
              THAN MAXVALUE ENGINE = InnoDB) */
      * Status
         * small innodb log files, large innodb_additional_mem_pool
         * on a slave, innodb_flush_log_at_trx_commit doesn't need to be 1
         * innodb has a lot more allocated memory than buffer pool + add'l pool
           example: Total memory allocated 16835145778; in additional pool
           allocated 536870912 Buffer pool size   262144
         * Issue 1908 has an excellent example of lots of mutex crap
         * Watch prepared statements and compare to max
         * Set some limits how big things can be, so we don't do like SELECT
           FROM INFORMATION_SCHEMA.TABLES on a server with a billion tables and
           100GB buffer pool -- limits should include the buffer pool size and
           key buffer size and mysql vsize
         * Watch for "bad query patterns" such as RAND() or storing IP addresses
           as varchar or using TO_DAYS(column) < TO_DAYS(NOW()) - 5
         * Actually, DATE_FORMAT(), or TO_DAYS() are just red flags
         * SELECT * is a bad habit, flag it.
         * SELECT tbl.* is bad, too.
      * Connections and users
         * report anonymous users
           * Complain loudly if connected as anonymous user -- print out what
             current_user() shows?  Useful for debugging etc
         * report obsolete privileges (privs that refer to dbs or tables that
           don't exist)
         * report root users, root can login remotely, default test database,
           accounts without passwords, old password authentication, users with
           old passwords, users with super privileges, users with all privileges
           globally, and think about some other privileges (reload?) that
           shouldn't be given to users who are logged in.
         * aggregate SHOW INNODB STATUS the same way.  A note on issue 1028 is a
         good example.
         * report master/slave status, how many slaves are attached and from
            where
      * After all the above, look at the error log and see if there are any
        errors caused by (for example) running SHOW STATUS.  Here is one
        possible error:
        080816  7:53:17080816  7:53:17 [ERROR] Cannot find table
        exampledb/exampletable from the internal data dictionary
        of InnoDB though the .frm file for the table exists. Maybe you
        have deleted and recreated InnoDB data files but have forgotten
        to delete the corresponding .frm files of InnoDB tables, or you
        have moved .frm files to another database?
        See http://dev.mysql.com/doc/refman/5.0/en/innodb-troubleshooting.html
        how you can resolve the problem.


   * Look at SHOW MASTER LOGS.  If there are any with 0 size, the user is
     deleting binlogs manually and that will screw up MySQL, warn about that.
      * For servers that have binlogging turned on, look for expire_logs_days or
        similar -- if there is no limit, disk space can fill up.  Note this.
   * Look for authenticating connections, extract the hostname, try to reverse
     lookup the DNS
   * what is the "thread recycle rate"?  e.g. if there are 100 connections, and
     one connection per second, then avg connection lives 100 secs.
   * Advise to use skip-name-resolve regardless...
   * If there are host-based grants, then advise about them, since they will
     break if skip-name-resolve is set.  (Must check my.cnf since it is not
     visible as an online variable).
   * tmp_table_size larger than max_heap_table_size is probably a mistake
   * look for innoDB free space vs. real space on disk to figure out how much is
     used.  Compare this to config file setting for buffer pool.
   * add mysqladmin -ext -i60 and put several samples side by side
   * add timestamps to all snapshots
   * Look for variables that look wrong: http://bugs.mysql.com/?id=39868
   * check if if key_buffer and innodb_buffer_pool too big (big % of available
     memory or a lot of unused buffers).
   * check if the InnoDB plugin is being used.  Report some stats about number
     of tables using compression, etc.
   * If our build with table stats, index stats, user stats is available --
     figure out what to do with that.
   * If our build with InnoDB buffer pool contents is available, show what's in
     the buffer pool.
   * check redundant indexes
   * alerts on COUNT(*) .. queries. 
   * flag GROUP_CONCAT() queries for checking whether they are vulnerable to
     group_concat_max_len
   * guess from column names how they are related to other tables.  account_id
     can mean this column is a FK to an account table.  If so, check for
     NULL-ability vs. presence of NULL in the table
   * Look for tables that have silly schema, like a lot of varchar(255) Other
     common auto-generated length is varchar(50).  If many varchar have the same
     length, raise an alarm.  In fact, a schema-wide summary of data types and
     lengths, and the number of each, would be very useful.
   * Look for non-recommended data types, like float(M,N) and BIT.  Also any
     type that has a non-default display width: int([^11]) is a warning sign
     that they don't understand the display widths
   * If a table has two potential FK columns, like post_id and author_id, and at
     the same time has an autoinc PK, raise a notice that maybe the PK should be
     post_id,author_id.
   * if a table has one autoinc PK and another int UNIQUE, raise a notice that
     maybe it should drop the autoinc and promote the UNIQUE to PK.
   * for InnoDB tables, a key that has the PK appended is redundant.
   * pack_keys=1 is probably a mistake
   * tables that have only primary, unique, and one other key with many values
     are probably a mistake: the user probably thinks a key on (a,b,c) is enough
     for queries on any of those columns.
   * look for columns named UUID or GUID or session_id which may contain hex
     data stored as strings, which would be better stored unhexed in binary
      * Check LIMIT 1 from all columns and look for UUID/GUID-looking values.
   * Look for nullable columns that contain no NULLs, especially indexed columns
   * Automatically run PROCEDURE ANALYSE on tables that look bad.
   * For each indexed int, check whether it's getting close to the limit of the
     values it can hold with SELECT MAX(...).
   * Determine the thoroughness of the search by how large the DB/table is.
   * watch how much data InnoDB writes to the log files per second, recommend
     log buffer size.
   * report master/slave info: how many slaves are connected, what the master is
   * ondisk temp tables are min(temp_table_size, heap_table_size)
   * Figure out whether key_buffer is as big as it can be already, and alert
     that multiple buffers will have to be used.
   * Replication:
      * Look for temporary tables and warn about this (tmp table variable on a
        slave, or tmp table queries in the processlist).
      * Look for unsafe settings: binlog_do_db or binlog_ignore_db
      * Check for expire_logs_days policy
      * Check that the binlog.index file matches what's on disk
      * if our patch is installed, warn if slave may be close to capacity (see
        http://www.mysqlperformanceblog.com/2008/10/08/three-ways-to-know-when-a-mysql-slave-is-about-to-start-lagging/
   * Parse db.tbl names out of statements in the processlist and make a list of
   the most popular dbs and tbls, in the format of a table, with the columns
   being ins/upd/del/sel/rep/other
   * processlist advisor: if commit appears a lot, it might be too-small innodb
     log file size.
   * deconstruct sprocs and explain them -- convert vars into @variables
   * Look for derived tables that have no aggregation inside them
   * Look for explain plans that have a bad ref type or not-full key usage or
   high number of rows or no 'ref'
   * Look for auto-increment locking in Innodb:
      *** (2) WAITING FOR THIS LOCK TO BE GRANTED:
      TABLE LOCK table `foo/bar` trx id 0 1313586251 lock mode AUTO-INC waiting
      TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH
   * List of crashed tables
