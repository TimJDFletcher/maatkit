#!/usr/bin/env perl

=pod

=head1 NAME

memc - memcached client.

=head1 SYNOPSIS

  memc [server:port]
  > set foo 1
  stored
  > get foo
  1
  > incr foo
  2
  > \q

=head1 DESCRIPTION

memc is an interactive memcached client.  It accepts basic memcached commands;
not all are implemented yet.

=head1 AUTHOR

Daniel Nichter

=head1 LICENSE

This software is released to the public domain, with no guarantees whatsoever.

=cut

#use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Cache::Memcached;

use constant MKDEBUG => $ENV{MKDEBUG};

my $memc_server = (shift @ARGV) || 'localhost:11211';
print "# Using memcached server $memc_server\n";

my $memc = new Cache::Memcached(
   servers => [ $memc_server ],
);

$OUTPUT_AUTOFLUSH=1;

while ( 1 ) {
   print "> ";
   my $input = <STDIN>;
   chomp $input;
   next unless $input;
   my ($cmd, @args) = $input =~ m/(\S+)\b/g;
   MKDEBUG && _d('cmd:', $cmd, 'args:', @args);
   last if $cmd eq '\q' || $cmd eq 'quit' || $cmd eq 'exit';
   my $retval;
   eval {
      $retval = $cmd->(@args);
   };
   if ( $EVAL_ERROR ) {
      if ( $EVAL_ERROR =~ m/Undefined subroutine/ ) {
         print "# Sorry, I don't know how to '$cmd'";
      }
      else {
         chomp $EVAL_ERROR;
         print "# $EVAL_ERROR";
      }
   }
   $retval = '' unless defined $retval;
   print "$retval\n";
}

exit;

sub set {
   my ( $key, $val, $exptime ) = @_;
   die "Missing arugment: set key value [exptime]\n"
      unless $key and defined $val;
   MKDEBUG && _d('set', $key, $val, $exptime);
   return $memc->set($key, $val, $exptime) ? 'stored' : 'error';
}

sub get {
   my ( $key ) = @_;
   die "Missing argument: get key\n" unless $key;
   MKDEBUG && _d('get', $key);
   return $memc->get($key) || 'error';
}

sub delete {
   my ( $key, $time ) = @_;
   die "Missing arugment: delete key [time]\n" unless $key;
   MKDEBUG && _d('delete', $key, $time);
   return $memc->delete($key, $time) ? 'deleted' : 'error';
}

sub incr {
   my ( $key, $val ) = @_;
   die "Missing arugment: incr key [value]\n" unless $key;
   MKDEBUG && _d('incr', $key, $val);
   my $new_val = $memc->incr($key, $val);
   return defined $new_val ? $new_val : 'error';
}

sub decr {
   my ( $key, $val ) = @_;
   die "Missing arugment: decr key [value]\n" unless $key;
   MKDEBUG && _d('decr', $key, $val);
   my $new_val = $memc->decr($key, $val);
   return defined $new_val ? $new_val : 'error';
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
}
