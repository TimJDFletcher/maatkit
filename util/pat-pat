#!/usr/bin/env perl

=pod

=head1 NAME

pat-pat - Find repeating string patterns.

=head1 SYNOPSIS

  pat-pat /path/to/file.txt

=head1 AUTHOR

Daniel Nichter

=head1 LICENSE

This software is released to the public domain, with no guarantees whatsoever.

=cut

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG};

my $file = shift @ARGV || '-';
my $fh;
if ( $file eq '-' ) {
   $fh = *STDIN;
}
else {
   open $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
}

while ( my $line = <$fh> ) {
   chomp $line;
   find_patterns($line);
}

close $fh or warn "Cannot close $file: $OS_ERROR";

# ###########################################################################
# Subroutines
# ###########################################################################

sub find_patterns {
   my ( $line ) = @_;
   return unless $line;

   my %cnt;  # word count
   my %pos;  # word position in pattern
   my @stmt;
   my $in_pattern = 0;
   my $pos        = 0;
   my $i          = 0;
   $line =~ s/\s+=\s+/=/g;
   while ( $line =~ m/(\S+)(?:\s+|\Z)/g ) {
      $pos = pos($line);
      my $word = $1;
      my $original_word = $word;
      $word =~ s/\d+/N/g;
      $word =~ s/,$//;
      # Remove leading/trailing () from first/last word in lists.
      substr($word, 0, 1, '')  if $word =~ m/^\(/ && $word !~ m/\)$/;
      substr($word, -1, 1, '') if $word =~ m/\)$/ && $word !~ m/^\(/;

      if ( ++$cnt{$word} == 1 ) {
         # First appearance of a word; save its position.
         $pos{$word} = $i++;
         # Save the word before we potentially end this pattern.
         push @{$stmt[ $pos{$word} ]}, $original_word;
         if ( $in_pattern ) {
            # This word ends the current pattern.
            $in_pattern = 0;
            %cnt = ();
            %pos = ();
         }
      }
      else {
         # This word has been seen before; save it with the first/other
         # occurrences of itself.
         $in_pattern = 1;
         push @{$stmt[ $pos{$word} ]}, $original_word;
      }
   }

   print join(' ', map {
         if ( scalar @$_ > 1 ) {
            my $words = "[\n  ".join("\n  ", @$_)."\n]";
            $words;
         }
         else {
            my $words = "[".join(' ', @$_)."]";
            $words;
         }
      } @stmt),
      "\n";

   return;
}
