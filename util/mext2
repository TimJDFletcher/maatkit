#!/bin/bash

usage() {
   echo "Usage: $0 c=N i=N [r=true] [ma=/path/to/mysqladmin and options]"
   echo "   c=N                    Count: number of iterations to make."
   echo "   i=N                    Sleep between iterations."
   echo "   ma=[\"command\"]         mysqladmin command and parameters."
   echo "   r=[true|false]         Relative: subtract each column from the previous column."
   echo " "
   echo "mext columnizes repeated output from mysqladmin extended."
   echo "Example: 'mext c=3 i=5 r=true ma=\"/usr/bin/mysql50/bin/mysqladmin ext -S /var/sock/mysql.sock\"'"
   exit 1
}

if [ -z "$1" ]; then
   usage;
fi

FILE=/tmp/mext_temp_file;
NUM=0;
REL=0;
STOP=0;
SLEEP=0;
rm -f $FILE*;

# Command-line parsing.
if [ "$?" = "1" ]; then
   usage;
fi


#exporting definied arguments
#maybe looks a bit messy, but works on all platform with super-limited resoures
IS_DEF=`echo $* | grep -ic mysqladmin`
ALL_ARG=$#
if [[ IS_DEF -ge 1 ]];then 
	STOP_ARG_PARS=`expr $# - 1`
else
	STOP_ARG_PARS=$ALL_ARG
fi

CNT=0
ARG_ARR=( $* )
while [[ $CNT -lt $STOP_ARG_PARS ]];do
	export "${ARG_ARR[$CNT]}"
	let CNT=CNT+1
done

#lets start from the back to find mysqladmin...
# all argument could be 4 and we nead at least 2 right ?
ALL_MAX_ARG=4
SEE_IF_4_IS_MADM=`echo $4 | cut -d'=' -f2 | cut -d' ' -f1 | grep -ic mysql`
if [[ $SEE_IF_4_IS_MADM -ne 1 ]]; then
	export "$3"
else
	export "$4"
fi

SLEEP=$i
STOP=$c

# Precond checks

# if sleep time not given or >5min, exit
if [[ $SLEEP -eq 0 ]] || [[ $SLEEP -gt 360 ]];then
        echo "Invalid sleep time given: $SLEEP"
        echo "Setting to: 1"
        SLEEP=1
fi

if [[ $STOP -lt 1 ]]; then
        echo "You don't want me to run no times?.. Weird.."
        exit 1
fi

if [ "$r" == "true" ]; then
	REL="1"
else
	REL="0"
fi

## MAX RUNTIME = STOPS * SLEEP +2seconds safedelay
MAXT=0
let MAXT=STOP*SLEEP+1

if [ -z "$1" ]; then
   usage;
fi

#re-architecturing
find_mysqladmin() {
	if [[ $IS_DEF -lt 1 ]];then
		ma=`which mysqladmin`
	fi
}
 
proceed_output() {
        # Split the output on empty lines and put each into a different file; eliminate
        # lines that don't have "real" content.
        $1 ext -c$2 -i$3 | grep -v '+' | grep -v Variable_name | sed 's/|//g' >${FILE}large &
}

organize_output() {
cat ${FILE}large  | while read line; do
        if [ "$line" = "" ]; then
                NUM=`expr $NUM + 1`;
                echo "" > $FILE$NUM;
        fi
        echo "$line" >> $FILE$NUM;
        done

}

find_mysqladmin

START_PROCEED=`date +%s`

proceed_output "$ma" "$STOP" "$SLEEP"

JOBS=`jobs -r |grep -c .`

while [[ $JOBS -gt 0 ]]; do
        CURR_DATE=`date +%s`
        let CURR_DATE=CURR_DATE-START_PROCEED
        if [[ $CURR_DATE -lt $MAXT ]];then
                sleep 1
                JOBS=`jobs -r | grep -c .`;
        else
                echo -en "\nForce quitting of mysqladmin..."
                killall -9 mysqladmin 1>/dev/null 2>/dev/null
                echo -en "done\n"
                break;
        fi
done
organize_output 

# Count how many files there are and prepare to format the output
SPEC="%-33s %13d"
AWKS=""
NUM=`ls $FILE* |grep -v large| wc -l`;
# The last file will be empty...
NUM=`expr $NUM - 3`;

# Join each file with the next file, joining on the first field. Build a printf
# spec and awk spec at the same time.
for i in `eval echo {0..$NUM}`; do
   NEXTFILE=`expr $i + 1`;
   join $FILE$i $FILE${NEXTFILE} | grep . > $FILE;
   # Find the max length of the [numeric only] values in the file so we know how
   # wide to make the columns
   MAXLEN=`awk '{print $2}' $FILE${NEXTFILE} | grep -v '[^0-9]' | awk '{print length($1)}' | sort -rn | head -n1`
   mv $FILE $FILE${NEXTFILE};
   SPEC="$SPEC %${MAXLEN}d";
   if [ "$REL" = "1" ]; then
      AWKS="$AWKS, \$`expr $i + 3` - \$`expr $i + 2`";
   else
      AWKS="$AWKS, \$`expr $i + 3`";
   fi
done

# Print output
AWKCMD="printf(\"$SPEC\n\", \$1, \$2$AWKS);";
awk "{$AWKCMD}" $FILE`expr $NUM + 1`;

# Remove all temporary files.
rm -f $FILE*;
