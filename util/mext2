#!/bin/sh

usage() {
   echo "Usage: $0 -c -i [-r] -- commandline"
   echo "   -c     Count: number of iterations to make."
   echo "   -r     Relative: subtract each column from the previous column."
   echo "   -i     Sleep between iterations."
   echo "   --     Option separator; after this, all arguments are passed"
   echo "          to the program whose output mext will columnize."
   echo "mext columnizes repeated output from a program like mysqladmin extended."
   echo "Example: 'mext -c 3 -i5 -r -- mysqladmin ext'"
   exit 1
}

if [ -z "$1" ]; then
   usage;
fi


FILE=/tmp/mext_temp_file;
NUM=0;
REL=0;
STOP=0;
SLEEP=0;
rm -f $FILE*;

# Command-line parsing.
args=`getopt -u -n mext c:ri: "$@"`;
if [ "$?" = "1" ]; then
   usage;
fi
set -- $args
for o; do
   case "$o" in
      -r)   REL="1"; shift;;
      -c)   STOP=$2; shift 2;;
      -i)   SLEEP=$2; shift 2;;
      --)   shift;   break;;
   esac
done


# Precond checks

# if sleep time not given or >5min, exit
if [[ $SLEEP -eq 0 ]] || [[ $SLEEP -gt 360 ]];then
        echo "Invalid sleep time given: $SLEEP"
        echo "Setting to: 1"
        SLEEP=1
fi

if [[ $STOP -lt 1 ]]; then
        echo "You don't want me to run no times?.. Weird.."
        exit 1
fi

# is mysqladmin?
MYADM=`echo $* | grep -c -i mysqladmin`

## MAX RUNTIME = STOPS * SLEEP +2seconds safedelay
MAXT=2
let MAXT=STOP*SLEEP

if [ -z "$1" ]; then
   usage;
fi

#re-architecturing 
proceed_output() {
        COMMAND=$1
        if [[ $MYADM -ge 1 ]];then
                STOPS="-c$2"
                TIMEDIFF="-i$3"
        fi
        # Split the output on empty lines and put each into a different file; eliminate
        # lines that don't have "real" content.
        $1 $STOPS $TIMEDIFF | grep -v '+' | grep -v Variable_name | sed 's/|//g' >${FILE}large &
}

organize_output() {
cat ${FILE}large  | while read line; do
        if [ "$line" = "" ]; then
                NUM=`expr $NUM + 1`;
                echo "" > $FILE$NUM;
        fi
        echo "$line" >> $FILE$NUM;
        done

}


START_PROCEED=`date +%s`
proceed_output "$*" "$STOP" "$SLEEP"
JOBS=`jobs -r |grep -c .`
#echo -en "Proceeding.. "
while [[ $JOBS -gt 0 ]]; do
        CURR_DATE=`date +%s`
        let CURR_DATE=CURR_DATE-START_PROCEED
        if [[ $CURR_DATE -lt $MAXT ]];then
#                echo -en " ."
                sleep 1
                JOBS=`jobs -r | grep -c .`;
        else
                echo -en "\nForce quitting of mysqladmin..."
                killall -9 mysqladmin 1>/dev/null 2>/dev/null
                echo -en "done\n"
                break;
        fi
done
organize_output 
#echo -en "\n"
# Count how many files there are and prepare to format the output
SPEC="%-33s %13d"
AWKS=""
NUM=`ls $FILE* |grep -v large| wc -l`;
# The last file will be empty...
NUM=`expr $NUM - 3`;

# Join each file with the next file, joining on the first field. Build a printf
# spec and awk spec at the same time.
for i in `seq 0 $NUM`; do
   NEXTFILE=`expr $i + 1`;
   join $FILE$i $FILE${NEXTFILE} | grep . > $FILE;
   # Find the max length of the [numeric only] values in the file so we know how
   # wide to make the columns
   MAXLEN=`awk '{print $2}' $FILE${NEXTFILE} | grep -v '[^0-9]' | awk '{print length($1)}' | sort -rn | head -n1`
   mv $FILE $FILE${NEXTFILE};
   SPEC="$SPEC %${MAXLEN}d";
   if [ "$REL" = "1" ]; then
      AWKS="$AWKS, \$`expr $i + 3` - \$`expr $i + 2`";
   else
      AWKS="$AWKS, \$`expr $i + 3`";
   fi
done

# Print output
AWKCMD="printf(\"$SPEC\n\", \$1, \$2$AWKS);";
awk "{$AWKCMD}" $FILE`expr $NUM + 1`;

# Remove all temporary files.
rm -f $FILE*;