---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...kit/mk-loadavg/mk-loadavg   15.8    2.4    7.5   33.1    n/a  100.0   12.5
Total                          15.8    2.4    7.5   33.1    n/a  100.0   12.5
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:23:19 2010
Finish:       Thu Jan 28 22:23:19 2010

Run:          ./001_parse_watch.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:23:20 2010
Finish:       Thu Jan 28 22:23:20 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:23:23 2010
Finish:       Thu Jan 28 22:23:29 2010

Run:          ./102_execute_command.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:23:31 2010
Finish:       Thu Jan 28 22:23:33 2010

Run:          ./103_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:23:35 2010
Finish:       Thu Jan 28 22:23:36 2010

Run:          ./104_reconnect.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:23:38 2010
Finish:       Thu Jan 28 22:23:49 2010

Run:          ./105_watch_processlist.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:23:51 2010
Finish:       Thu Jan 28 22:23:56 2010

/home/daniel/dev/maatkit/mk-loadavg/mk-loadavg

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-loadavg, a program to measure the load on a MySQL server and take
4                                                     # action when it exceeds boundaries.
5                                                     #
6                                                     # This program is copyright 2008-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             6                    6            35   use strict;
               6                                 15   
               6                                 44   
24             6                    6            41   use warnings FATAL => 'all';
               6                                 14   
               6                                 45   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5460 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 5266
32                                                    # ###########################################################################
33                                                    package OptionParser;
34                                                    
35             6                    6            40   use strict;
               6                                 15   
               6                                 27   
36             6                    6            36   use warnings FATAL => 'all';
               6                                 18   
               6                                 29   
37                                                    
38             6                    6            56   use Getopt::Long;
               6                                 20   
               6                                 38   
39             6                    6            41   use List::Util qw(max);
               6                                 17   
               6                                 69   
40             6                    6            37   use English qw(-no_match_vars);
               6                                 16   
               6                                 39   
41                                                    
42    ***      6            50      6            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 32   
               6                                 94   
43                                                    
44                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
45                                                    
46                                                    my %attributes = (
47                                                       'type'       => 1,
48                                                       'short form' => 1,
49                                                       'group'      => 1,
50                                                       'default'    => 1,
51                                                       'cumulative' => 1,
52                                                       'negatable'  => 1,
53                                                    );
54                                                    
55                                                    sub new {
56    ***      0                    0             0      my ( $class, %args ) = @_;
57    ***      0                                  0      foreach my $arg ( qw(description) ) {
58    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
59                                                       }
60    ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
61    ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
62    ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
63                                                    
64    ***      0      0      0                    0      my $self = {
      ***                    0                        
65                                                          description    => $args{description},
66                                                          prompt         => $args{prompt} || '<options>',
67                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
68                                                          dp             => $args{dp}     || undef,
69                                                          program_name   => $program_name,
70                                                          opts           => {},
71                                                          got_opts       => 0,
72                                                          short_opts     => {},
73                                                          defaults       => {},
74                                                          groups         => {},
75                                                          allowed_groups => {},
76                                                          errors         => [],
77                                                          rules          => [],  # desc of rules for --help
78                                                          mutex          => [],  # rule: opts are mutually exclusive
79                                                          atleast1       => [],  # rule: at least one opt is required
80                                                          disables       => {},  # rule: opt disables other opts 
81                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
82                                                          default_files  => [
83                                                             "/etc/maatkit/maatkit.conf",
84                                                             "/etc/maatkit/$program_name.conf",
85                                                             "$home/.maatkit.conf",
86                                                             "$home/.$program_name.conf",
87                                                          ],
88                                                       };
89    ***      0                                  0      return bless $self, $class;
90                                                    }
91                                                    
92                                                    sub get_specs {
93    ***      0                    0             0      my ( $self, $file ) = @_;
94    ***      0                                  0      my @specs = $self->_pod_to_specs($file);
95    ***      0                                  0      $self->_parse_specs(@specs);
96    ***      0                                  0      return;
97                                                    }
98                                                    
99                                                    sub get_defaults_files {
100   ***      0                    0             0      my ( $self ) = @_;
101   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
102                                                   }
103                                                   
104                                                   sub _pod_to_specs {
105   ***      0                    0             0      my ( $self, $file ) = @_;
106   ***      0             0                    0      $file ||= __FILE__;
107   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
108                                                   
109   ***      0                                  0      my %types = (
110                                                         string => 's', # standard Getopt type
111                                                         'int'  => 'i', # standard Getopt type
112                                                         float  => 'f', # standard Getopt type
113                                                         Hash   => 'H', # hash, formed from a comma-separated list
114                                                         hash   => 'h', # hash as above, but only if a value is given
115                                                         Array  => 'A', # array, similar to Hash
116                                                         array  => 'a', # array, similar to hash
117                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
118                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
119                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
120                                                      );
121   ***      0                                  0      my @specs = ();
122   ***      0                                  0      my @rules = ();
123   ***      0                                  0      my $para;
124                                                   
125   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
126   ***      0                                  0      while ( $para = <$fh> ) {
127   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
128   ***      0                                  0         last;
129                                                      }
130                                                   
131   ***      0                                  0      while ( $para = <$fh> ) {
132   ***      0      0                           0         last if $para =~ m/^=over/;
133   ***      0                                  0         chomp $para;
134   ***      0                                  0         $para =~ s/\s+/ /g;
135   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
136   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
137   ***      0                                  0         push @rules, $para;
138                                                      }
139                                                   
140   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
141                                                   
142   ***      0                                  0      do {
143   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
144   ***      0                                  0            chomp $para;
145   ***      0                                  0            MKDEBUG && _d($para);
146   ***      0                                  0            my %attribs;
147                                                   
148   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
149                                                   
150   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
151   ***      0                                  0               $para =~ s/\s+\Z//g;
152   ***      0                                  0               %attribs = map {
153   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
154   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
155                                                                        unless $attributes{$attrib};
156   ***      0                                  0                     ($attrib, $val);
157                                                                  } split(/; /, $para);
158   ***      0      0                           0               if ( $attribs{'short form'} ) {
159   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
160                                                               }
161   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
162                                                            }
163                                                            else {
164   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
165                                                            }
166                                                   
167   ***      0                                  0            $para =~ s/\s+\Z//g;
168   ***      0                                  0            $para =~ s/\s+/ /g;
169   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
170                                                   
171   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
172   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
173                                                   
174   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
175                                                   
176   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
177   ***      0                                  0               $option = $base_option;
178   ***      0                                  0               $attribs{'negatable'} = 1;
179                                                            }
180                                                   
181   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
182                                                               spec  => $option
183                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
184                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
185                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
186                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
187                                                               desc  => $para
188                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
189                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
190                                                            };
191                                                         }
192   ***      0                                  0         while ( $para = <$fh> ) {
193   ***      0      0                           0            last unless $para;
194                                                   
195                                                   
196   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
197   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
198   ***      0                                  0               last;
199                                                            }
200   ***      0      0                           0            last if $para =~ m/^=item --/;
201                                                         }
202                                                      } while ( $para );
203                                                   
204   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
205                                                   
206   ***      0                                  0      close $fh;
207   ***      0                                  0      return @specs, @rules;
208                                                   }
209                                                   
210                                                   sub _parse_specs {
211   ***      0                    0             0      my ( $self, @specs ) = @_;
212   ***      0                                  0      my %disables; # special rule that requires deferred checking
213                                                   
214   ***      0                                  0      foreach my $opt ( @specs ) {
215   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
216                                                            MKDEBUG && _d('Parsing opt spec:',
217   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
218                                                   
219   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
220   ***      0      0                           0            if ( !$long ) {
221   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
222                                                            }
223   ***      0                                  0            $opt->{long} = $long;
224                                                   
225   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
226   ***      0                                  0            $self->{opts}->{$long} = $opt;
227                                                   
228   ***      0      0                           0            if ( length $long == 1 ) {
229   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
230   ***      0                                  0               $self->{short_opts}->{$long} = $long;
231                                                            }
232                                                   
233   ***      0      0                           0            if ( $short ) {
234   ***      0      0                           0               die "Duplicate short option -$short"
235                                                                  if exists $self->{short_opts}->{$short};
236   ***      0                                  0               $self->{short_opts}->{$short} = $long;
237   ***      0                                  0               $opt->{short} = $short;
238                                                            }
239                                                            else {
240   ***      0                                  0               $opt->{short} = undef;
241                                                            }
242                                                   
243   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
244   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
245   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
246                                                   
247   ***      0             0                    0            $opt->{group} ||= 'default';
248   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
249                                                   
250   ***      0                                  0            $opt->{value} = undef;
251   ***      0                                  0            $opt->{got}   = 0;
252                                                   
253   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
254   ***      0                                  0            $opt->{type} = $type;
255   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
256                                                   
257   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
258   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
259                                                                  . "was given when this OptionParser object was created";
260                                                            }
261                                                   
262   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
263                                                   
264   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
265   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
266   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
267                                                            }
268                                                   
269   ***      0      0                           0            if ( $long eq 'config' ) {
270   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
271                                                            }
272                                                   
273   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
274   ***      0                                  0               $disables{$long} = $dis;
275   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
276                                                            }
277                                                   
278   ***      0                                  0            $self->{opts}->{$long} = $opt;
279                                                         }
280                                                         else { # It's an option rule, not a spec.
281   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
282   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
283   ***      0                                  0            my @participants = $self->_get_participants($opt);
284   ***      0                                  0            my $rule_ok = 0;
285                                                   
286   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
287   ***      0                                  0               $rule_ok = 1;
288   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
289   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
290                                                            }
291   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
292   ***      0                                  0               $rule_ok = 1;
293   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
294   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
295                                                            }
296   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
297   ***      0                                  0               $rule_ok = 1;
298   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
299   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
300                                                            }
301   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
302   ***      0                                  0               $rule_ok = 1;
303   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
304   ***      0                                  0               my @groups = split(',', $groups);
305   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
306   ***      0                                  0                  s/\s+//;
307   ***      0                                  0                  $_ => 1;
308                                                               } @groups;
309                                                            }
310                                                   
311   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
312                                                         }
313                                                      }
314                                                   
315   ***      0                                  0      foreach my $long ( keys %disables ) {
316   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
317   ***      0                                  0         $self->{disables}->{$long} = \@participants;
318   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
319                                                      }
320                                                   
321   ***      0                                  0      return; 
322                                                   }
323                                                   
324                                                   sub _get_participants {
325   ***      0                    0             0      my ( $self, $str ) = @_;
326   ***      0                                  0      my @participants;
327   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
328   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
329                                                            unless exists $self->{opts}->{$long};
330   ***      0                                  0         push @participants, $long;
331                                                      }
332   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
333   ***      0                                  0      return @participants;
334                                                   }
335                                                   
336                                                   sub opts {
337   ***      0                    0             0      my ( $self ) = @_;
338   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
339   ***      0                                  0      return %opts;
340                                                   }
341                                                   
342                                                   sub short_opts {
343   ***      0                    0             0      my ( $self ) = @_;
344   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
345   ***      0                                  0      return %short_opts;
346                                                   }
347                                                   
348                                                   sub set_defaults {
349   ***      0                    0             0      my ( $self, %defaults ) = @_;
350   ***      0                                  0      $self->{defaults} = {};
351   ***      0                                  0      foreach my $long ( keys %defaults ) {
352   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
353                                                            unless exists $self->{opts}->{$long};
354   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
355   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
356                                                      }
357   ***      0                                  0      return;
358                                                   }
359                                                   
360                                                   sub get_defaults {
361   ***      0                    0             0      my ( $self ) = @_;
362   ***      0                                  0      return $self->{defaults};
363                                                   }
364                                                   
365                                                   sub get_groups {
366   ***      0                    0             0      my ( $self ) = @_;
367   ***      0                                  0      return $self->{groups};
368                                                   }
369                                                   
370                                                   sub _set_option {
371   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
372   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
373                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
374                                                               : die "Getopt::Long gave a nonexistent option: $opt";
375                                                   
376   ***      0                                  0      $opt = $self->{opts}->{$long};
377   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
378   ***      0                                  0         $opt->{value}++;
379                                                      }
380                                                      else {
381   ***      0                                  0         $opt->{value} = $val;
382                                                      }
383   ***      0                                  0      $opt->{got} = 1;
384   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
385                                                   }
386                                                   
387                                                   sub get_opts {
388   ***      0                    0             0      my ( $self ) = @_; 
389                                                   
390   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
391   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
392   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
393                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
394                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
395                                                            : undef;
396                                                      }
397   ***      0                                  0      $self->{got_opts} = 0;
398                                                   
399   ***      0                                  0      $self->{errors} = [];
400                                                   
401   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
402   ***      0                                  0         shift @ARGV;
403   ***      0                                  0         $self->_set_option('config', shift @ARGV);
404                                                      }
405   ***      0      0                           0      if ( $self->has('config') ) {
406   ***      0                                  0         my @extra_args;
407   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
408   ***      0                                  0            eval {
409   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
410                                                            };
411   ***      0      0                           0            if ( $EVAL_ERROR ) {
412   ***      0      0                           0               if ( $self->got('config') ) {
413   ***      0                                  0                  die $EVAL_ERROR;
414                                                               }
415                                                               elsif ( MKDEBUG ) {
416                                                                  _d($EVAL_ERROR);
417                                                               }
418                                                            }
419                                                         }
420   ***      0                                  0         unshift @ARGV, @extra_args;
421                                                      }
422                                                   
423   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
424                                                      GetOptions(
425   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
426   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
427   ***      0      0                           0         values %{$self->{opts}}
428                                                      ) or $self->save_error('Error parsing options');
429                                                   
430   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
431   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
432                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
433                                                               or die "Cannot print: $OS_ERROR";
434   ***      0                                  0         exit 0;
435                                                      }
436                                                   
437   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
438   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
439                                                      }
440                                                   
441   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
442   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
443   ***      0      0                           0         if ( @set > 1 ) {
444   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
445   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
446                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
447                                                                    . ' are mutually exclusive.';
448   ***      0                                  0            $self->save_error($err);
449                                                         }
450                                                      }
451                                                   
452   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
453   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
454   ***      0      0                           0         if ( @set == 0 ) {
455   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
456   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
457                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
458   ***      0                                  0            $self->save_error("Specify at least one of $err");
459                                                         }
460                                                      }
461                                                   
462   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
463   ***      0                                  0         my $opt = $self->{opts}->{$long};
464   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
465   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
466   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
467   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
468   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
469                                                                  'because', $long,'disables them');
470                                                            }
471                                                   
472   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
473                                                   
474   ***      0                                  0               my @restricted_groups = grep {
475   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
476   ***      0                                  0               } keys %{$self->{groups}};
477                                                   
478   ***      0                                  0               my @restricted_opts;
479   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
480   ***      0                                  0                  RESTRICTED_OPT:
481   ***      0                                  0                  foreach my $restricted_opt (
482                                                                     keys %{$self->{groups}->{$restricted_group}} )
483                                                                  {
484   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
485   ***      0      0                           0                     push @restricted_opts, $restricted_opt
486                                                                        if $self->{opts}->{$restricted_opt}->{got};
487                                                                  }
488                                                               }
489                                                   
490   ***      0      0                           0               if ( @restricted_opts ) {
491   ***      0                                  0                  my $err;
492   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
493   ***      0                                  0                     $err = "--$restricted_opts[0]";
494                                                                  }
495                                                                  else {
496   ***      0                                  0                     $err = join(', ',
497   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
498   ***      0                                  0                               grep { $_ } 
499                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
500                                                                            )
501                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
502                                                                  }
503   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
504                                                               }
505                                                            }
506                                                   
507                                                         }
508                                                         elsif ( $opt->{is_required} ) { 
509   ***      0                                  0            $self->save_error("Required option --$long must be specified");
510                                                         }
511                                                   
512   ***      0                                  0         $self->_validate_type($opt);
513                                                      }
514                                                   
515   ***      0                                  0      $self->{got_opts} = 1;
516   ***      0                                  0      return;
517                                                   }
518                                                   
519                                                   sub _validate_type {
520   ***      0                    0             0      my ( $self, $opt ) = @_;
521   ***      0      0      0                    0      return unless $opt && $opt->{type};
522   ***      0                                  0      my $val = $opt->{value};
523                                                   
524   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
525   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
526   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
527   ***      0      0                           0         if ( !$suffix ) {
528   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
529   ***      0             0                    0            $suffix = $s || 's';
530   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
531                                                               $opt->{long}, '(value:', $val, ')');
532                                                         }
533   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
534   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
535                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
536                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
537                                                                 :                  $num * 86400;   # Days
538   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
539   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
540                                                         }
541                                                         else {
542   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
543                                                         }
544                                                      }
545                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
546   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
547   ***      0                                  0         my $prev = {};
548   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
549   ***      0      0                           0         if ( $from_key ) {
550   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
551   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
552                                                         }
553   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
554   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
555                                                      }
556                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
557   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
558   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
559   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
560   ***      0      0                           0         if ( defined $num ) {
561   ***      0      0                           0            if ( $factor ) {
562   ***      0                                  0               $num *= $factor_for{$factor};
563   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
564                                                                  'to num', $num, '* factor', $factor);
565                                                            }
566   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
567                                                         }
568                                                         else {
569   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
570                                                         }
571                                                      }
572                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
573   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
574                                                      }
575                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
576   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
577                                                      }
578                                                      else {
579   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
580                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
581                                                      }
582                                                   
583   ***      0                                  0      return;
584                                                   }
585                                                   
586                                                   sub get {
587   ***      0                    0             0      my ( $self, $opt ) = @_;
588   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
589   ***      0      0      0                    0      die "Option $opt does not exist"
590                                                         unless $long && exists $self->{opts}->{$long};
591   ***      0                                  0      return $self->{opts}->{$long}->{value};
592                                                   }
593                                                   
594                                                   sub got {
595   ***      0                    0             0      my ( $self, $opt ) = @_;
596   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
597   ***      0      0      0                    0      die "Option $opt does not exist"
598                                                         unless $long && exists $self->{opts}->{$long};
599   ***      0                                  0      return $self->{opts}->{$long}->{got};
600                                                   }
601                                                   
602                                                   sub has {
603   ***      0                    0             0      my ( $self, $opt ) = @_;
604   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
605   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
606                                                   }
607                                                   
608                                                   sub set {
609   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
610   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
611   ***      0      0      0                    0      die "Option $opt does not exist"
612                                                         unless $long && exists $self->{opts}->{$long};
613   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
614   ***      0                                  0      return;
615                                                   }
616                                                   
617                                                   sub save_error {
618   ***      0                    0             0      my ( $self, $error ) = @_;
619   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
620                                                   }
621                                                   
622                                                   sub errors {
623   ***      0                    0             0      my ( $self ) = @_;
624   ***      0                                  0      return $self->{errors};
625                                                   }
626                                                   
627                                                   sub prompt {
628   ***      0                    0             0      my ( $self ) = @_;
629   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
630                                                   }
631                                                   
632                                                   sub descr {
633   ***      0                    0             0      my ( $self ) = @_;
634   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
635                                                                 . "  For more details, please use the --help option, "
636                                                                 . "or try 'perldoc $PROGRAM_NAME' "
637                                                                 . "for complete documentation.";
638   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
639   ***      0                                  0      $descr =~ s/ +$//mg;
640   ***      0                                  0      return $descr;
641                                                   }
642                                                   
643                                                   sub usage_or_errors {
644   ***      0                    0             0      my ( $self ) = @_;
645   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
646   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
647   ***      0                                  0         exit 0;
648                                                      }
649                                                      elsif ( scalar @{$self->{errors}} ) {
650   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
651   ***      0                                  0         exit 0;
652                                                      }
653   ***      0                                  0      return;
654                                                   }
655                                                   
656                                                   sub print_errors {
657   ***      0                    0             0      my ( $self ) = @_;
658   ***      0                                  0      my $usage = $self->prompt() . "\n";
659   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
660   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
661                                                                 . "\n";
662                                                      }
663   ***      0                                  0      return $usage . "\n" . $self->descr();
664                                                   }
665                                                   
666                                                   sub print_usage {
667   ***      0                    0             0      my ( $self ) = @_;
668   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
669   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
670                                                   
671   ***      0      0                           0      my $maxl = max(
672   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
673                                                         @opts);
674                                                   
675   ***      0      0                           0      my $maxs = max(0,
676   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
677   ***      0                                  0         values %{$self->{short_opts}});
678                                                   
679   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
680   ***      0                                  0      my $rcol = 80 - $lcol - 6;
681   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
682                                                   
683   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
684                                                   
685   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
686                                                   
687   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
688   ***      0                                  0      push @groups, 'default';
689                                                   
690   ***      0                                  0      foreach my $group ( reverse @groups ) {
691   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
692   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
693   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
694                                                            grep { $_->{group} eq $group }
695                                                            @opts )
696                                                         {
697   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
698   ***      0                                  0            my $short = $opt->{short};
699   ***      0                                  0            my $desc  = $opt->{desc};
700   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
701   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
702   ***      0             0                    0               $s    ||= 's';
703   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
704   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
705                                                                      . "d=days; if no suffix, $s is used.";
706                                                            }
707   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
708   ***      0                                  0            $desc =~ s/ +$//mg;
709   ***      0      0                           0            if ( $short ) {
710   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
711                                                            }
712                                                            else {
713   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
714                                                            }
715                                                         }
716                                                      }
717                                                   
718   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
719   ***      0                                  0         $usage .= "\nRules:\n\n";
720   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
721                                                      }
722   ***      0      0                           0      if ( $self->{dp} ) {
723   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
724                                                      }
725   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
726   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
727   ***      0                                  0         my $val   = $opt->{value};
728   ***      0             0                    0         my $type  = $opt->{type} || '';
729   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
730   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
731                                                                   : !defined $val             ? '(No value)'
732                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
733                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
734                                                                   : $type =~ m/A|a/           ? join(',', @$val)
735                                                                   :                             $val;
736   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
737                                                      }
738   ***      0                                  0      return $usage;
739                                                   }
740                                                   
741                                                   sub prompt_noecho {
742   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
743   ***      0                                  0      my ( $prompt ) = @_;
744   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
745   ***      0      0                           0      print $prompt
746                                                         or die "Cannot print: $OS_ERROR";
747   ***      0                                  0      my $response;
748   ***      0                                  0      eval {
749   ***      0                                  0         require Term::ReadKey;
750   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
751   ***      0                                  0         chomp($response = <STDIN>);
752   ***      0                                  0         Term::ReadKey::ReadMode('normal');
753   ***      0      0                           0         print "\n"
754                                                            or die "Cannot print: $OS_ERROR";
755                                                      };
756   ***      0      0                           0      if ( $EVAL_ERROR ) {
757   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
758                                                      }
759   ***      0                                  0      return $response;
760                                                   }
761                                                   
762                                                   if ( MKDEBUG ) {
763                                                      print '# ', $^X, ' ', $], "\n";
764                                                      my $uname = `uname -a`;
765                                                      if ( $uname ) {
766                                                         $uname =~ s/\s+/ /g;
767                                                         print "# $uname\n";
768                                                      }
769                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
770                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
771                                                         ($main::SVN_REV || ''), __LINE__);
772                                                      print('# Arguments: ',
773                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
774                                                   }
775                                                   
776                                                   sub _read_config_file {
777   ***      0                    0             0      my ( $self, $filename ) = @_;
778   ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
779   ***      0                                  0      my @args;
780   ***      0                                  0      my $prefix = '--';
781   ***      0                                  0      my $parse  = 1;
782                                                   
783                                                      LINE:
784   ***      0                                  0      while ( my $line = <$fh> ) {
785   ***      0                                  0         chomp $line;
786   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
787   ***      0                                  0         $line =~ s/\s+#.*$//g;
788   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
789   ***      0      0                           0         if ( $line eq '--' ) {
790   ***      0                                  0            $prefix = '';
791   ***      0                                  0            $parse  = 0;
792   ***      0                                  0            next LINE;
793                                                         }
794   ***      0      0      0                    0         if ( $parse
      ***             0                               
795                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
796                                                         ) {
797   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
798                                                         }
799                                                         elsif ( $line =~ m/./ ) {
800   ***      0                                  0            push @args, $line;
801                                                         }
802                                                         else {
803   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
804                                                         }
805                                                      }
806   ***      0                                  0      close $fh;
807   ***      0                                  0      return @args;
808                                                   }
809                                                   
810                                                   sub read_para_after {
811   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
812   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
813   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
814   ***      0                                  0      my $para;
815   ***      0                                  0      while ( $para = <$fh> ) {
816   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
817   ***      0                                  0         last;
818                                                      }
819   ***      0                                  0      while ( $para = <$fh> ) {
820   ***      0      0                           0         next unless $para =~ m/$regex/;
821   ***      0                                  0         last;
822                                                      }
823   ***      0                                  0      $para = <$fh>;
824   ***      0                                  0      chomp($para);
825   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
826   ***      0                                  0      return $para;
827                                                   }
828                                                   
829                                                   sub clone {
830   ***      0                    0             0      my ( $self ) = @_;
831                                                   
832   ***      0                                  0      my %clone = map {
833   ***      0                                  0         my $hashref  = $self->{$_};
834   ***      0                                  0         my $val_copy = {};
835   ***      0                                  0         foreach my $key ( keys %$hashref ) {
836   ***      0                                  0            my $ref = ref $hashref->{$key};
837   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
838   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
839   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
840                                                                              : $hashref->{$key};
841                                                         }
842   ***      0                                  0         $_ => $val_copy;
843                                                      } qw(opts short_opts defaults);
844                                                   
845   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
846   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
847                                                      }
848                                                   
849   ***      0                                  0      return bless \%clone;     
850                                                   }
851                                                   
852                                                   sub _d {
853   ***      0                    0             0      my ($package, undef, $line) = caller 0;
854   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
855   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
856                                                           @_;
857   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
858                                                   }
859                                                   
860                                                   1;
861                                                   
862                                                   # ###########################################################################
863                                                   # End OptionParser package
864                                                   # ###########################################################################
865                                                   
866                                                   # ###########################################################################
867                                                   # VersionParser package 5266
868                                                   # ###########################################################################
869                                                   package VersionParser;
870                                                   
871            6                    6            57   use strict;
               6                                 26   
               6                                 54   
872            6                    6            39   use warnings FATAL => 'all';
               6                                 15   
               6                                 41   
873                                                   
874            6                    6            41   use English qw(-no_match_vars);
               6                                 15   
               6                                 36   
875                                                   
876   ***      6            50      6            40   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 22   
               6                                120   
877                                                   
878                                                   sub new {
879   ***      0                    0             0      my ( $class ) = @_;
880   ***      0                                  0      bless {}, $class;
881                                                   }
882                                                   
883                                                   sub parse {
884   ***      0                    0             0      my ( $self, $str ) = @_;
885   ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
886   ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
887   ***      0                                  0      return $result;
888                                                   }
889                                                   
890                                                   sub version_ge {
891   ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
892   ***      0      0                           0      if ( !$self->{$dbh} ) {
893   ***      0                                  0         $self->{$dbh} = $self->parse(
894                                                            $dbh->selectrow_array('SELECT VERSION()'));
895                                                      }
896   ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
897   ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
898   ***      0                                  0      return $result;
899                                                   }
900                                                   
901                                                   sub _d {
902   ***      0                    0             0      my ($package, undef, $line) = caller 0;
903   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
904   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
905                                                           @_;
906   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
907                                                   }
908                                                   
909                                                   1;
910                                                   
911                                                   # ###########################################################################
912                                                   # End VersionParser package
913                                                   # ###########################################################################
914                                                   
915                                                   # ###########################################################################
916                                                   # DSNParser package 5266
917                                                   # ###########################################################################
918                                                   package DSNParser;
919                                                   
920            6                    6            46   use strict;
               6                                 22   
               6                                 36   
921            6                    6            39   use warnings FATAL => 'all';
               6                                 17   
               6                                 28   
922            6                    6            34   use English qw(-no_match_vars);
               6                                 15   
               6                                 33   
923            6                    6            44   use Data::Dumper;
               6                                 14   
               6                                 60   
924                                                   $Data::Dumper::Indent    = 0;
925                                                   $Data::Dumper::Quotekeys = 0;
926                                                   
927                                                   eval {
928                                                      require DBI;
929                                                   };
930                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
931                                                   
932   ***      6            50      6            41   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 87   
933                                                   
934                                                   sub new {
935            4                    4            24      my ( $class, @opts ) = @_;
936            4                                 97      my $self = {
937                                                         opts => {
938                                                            A => {
939                                                               desc => 'Default character set',
940                                                               dsn  => 'charset',
941                                                               copy => 1,
942                                                            },
943                                                            D => {
944                                                               desc => 'Database to use',
945                                                               dsn  => 'database',
946                                                               copy => 1,
947                                                            },
948                                                            F => {
949                                                               desc => 'Only read default options from the given file',
950                                                               dsn  => 'mysql_read_default_file',
951                                                               copy => 1,
952                                                            },
953                                                            h => {
954                                                               desc => 'Connect to host',
955                                                               dsn  => 'host',
956                                                               copy => 1,
957                                                            },
958                                                            p => {
959                                                               desc => 'Password to use when connecting',
960                                                               dsn  => 'password',
961                                                               copy => 1,
962                                                            },
963                                                            P => {
964                                                               desc => 'Port number to use for connection',
965                                                               dsn  => 'port',
966                                                               copy => 1,
967                                                            },
968                                                            S => {
969                                                               desc => 'Socket file to use for connection',
970                                                               dsn  => 'mysql_socket',
971                                                               copy => 1,
972                                                            },
973                                                            u => {
974                                                               desc => 'User for login if not current user',
975                                                               dsn  => 'user',
976                                                               copy => 1,
977                                                            },
978                                                         },
979                                                      };
980            4                                 19      foreach my $opt ( @opts ) {
981   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
982   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
983                                                      }
984            4                                 58      return bless $self, $class;
985                                                   }
986                                                   
987                                                   sub prop {
988           15                   15            86      my ( $self, $prop, $value ) = @_;
989   ***     15     50                          83      if ( @_ > 2 ) {
990   ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
991   ***      0                                  0         $self->{$prop} = $value;
992                                                      }
993           15                                141      return $self->{$prop};
994                                                   }
995                                                   
996                                                   sub parse {
997            5                    5           297      my ( $self, $dsn, $prev, $defaults ) = @_;
998   ***      5     50                         125      if ( !$dsn ) {
999   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1000  ***      0                                  0         return;
1001                                                     }
1002           5                                 16      MKDEBUG && _d('Parsing', $dsn);
1003  ***      5            50                   37      $prev     ||= {};
1004  ***      5            50                   34      $defaults ||= {};
1005           5                                 21      my %given_props;
1006           5                                 25      my %final_props;
1007           5                                 21      my %opts = %{$self->{opts}};
               5                                 97   
1008                                                  
1009           5                                 64      foreach my $dsn_part ( split(/,/, $dsn) ) {
1010  ***     20     50                         215         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1011          20                                114            $given_props{$prop_key} = $prop_val;
1012                                                        }
1013                                                        else {
1014  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1015  ***      0                                  0            $given_props{h} = $dsn_part;
1016                                                        }
1017                                                     }
1018                                                  
1019           5                                 41      foreach my $key ( keys %opts ) {
1020          40                                 92         MKDEBUG && _d('Finding value for', $key);
1021          40                                164         $final_props{$key} = $given_props{$key};
1022  ***     40     50     66                  376         if (   !defined $final_props{$key}
      ***                   33                        
1023                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1024                                                        {
1025  ***      0                                  0            $final_props{$key} = $prev->{$key};
1026  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1027                                                        }
1028          40    100                         196         if ( !defined $final_props{$key} ) {
1029          20                                 72            $final_props{$key} = $defaults->{$key};
1030          20                                 65            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1031                                                        }
1032                                                     }
1033                                                  
1034           5                                 32      foreach my $key ( keys %given_props ) {
1035  ***     20     50                         102         die "Unrecognized DSN part '$key' in '$dsn'\n"
1036                                                           unless exists $opts{$key};
1037                                                     }
1038  ***      5     50                          37      if ( (my $required = $self->prop('required')) ) {
1039  ***      0                                  0         foreach my $key ( keys %$required ) {
1040  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1041                                                        }
1042                                                     }
1043                                                  
1044           5                                 45      return \%final_props;
1045                                                  }
1046                                                  
1047                                                  sub parse_options {
1048  ***      0                    0             0      my ( $self, $o ) = @_;
1049  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1050  ***      0                                  0      my $dsn_string
1051                                                        = join(',',
1052  ***      0      0                           0             map  { "$_=".$o->get($_); }
1053  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1054  ***      0                                  0             keys %{$self->{opts}}
1055                                                          );
1056  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1057  ***      0                                  0      return $self->parse($dsn_string);
1058                                                  }
1059                                                  
1060                                                  sub as_string {
1061  ***      0                    0             0      my ( $self, $dsn ) = @_;
1062  ***      0      0                           0      return $dsn unless ref $dsn;
1063  ***      0      0                           0      return join(',',
1064  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1065  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1066                                                        sort keys %$dsn );
1067                                                  }
1068                                                  
1069                                                  sub usage {
1070  ***      0                    0             0      my ( $self ) = @_;
1071  ***      0                                  0      my $usage
1072                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1073                                                        . "  KEY  COPY  MEANING\n"
1074                                                        . "  ===  ====  =============================================\n";
1075  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1076  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1077  ***      0      0      0                    0         $usage .= "  $key    "
1078                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1079                                                               .  ($opts{$key}->{desc} || '[No description]')
1080                                                               . "\n";
1081                                                     }
1082  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1083  ***      0                                  0      return $usage;
1084                                                  }
1085                                                  
1086                                                  sub get_cxn_params {
1087           5                    5            92      my ( $self, $info ) = @_;
1088           5                                 16      my $dsn;
1089           5                                 19      my %opts = %{$self->{opts}};
               5                                 52   
1090  ***      5            50                   35      my $driver = $self->prop('dbidriver') || '';
1091  ***      5     50                          33      if ( $driver eq 'Pg' ) {
1092  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1093  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1094  ***      0             0                    0                        grep { defined $info->{$_} }
1095                                                                       qw(h P));
1096                                                     }
1097                                                     else {
1098          10                                 85         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1099          25                                108            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1100  ***      5            50                   82                        grep { defined $info->{$_} }
1101                                                                       qw(F h P S A))
1102                                                           . ';mysql_read_default_group=client';
1103                                                     }
1104           5                                 18      MKDEBUG && _d($dsn);
1105           5                                 54      return ($dsn, $info->{u}, $info->{p});
1106                                                  }
1107                                                  
1108                                                  sub fill_in_dsn {
1109  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1110  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1111  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1112  ***      0                                  0      $user =~ s/@.*//;
1113  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1114  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1115  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1116  ***      0             0                    0      $dsn->{u} ||= $user;
1117  ***      0             0                    0      $dsn->{D} ||= $db;
1118                                                  }
1119                                                  
1120                                                  sub get_dbh {
1121           5                    5            41      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1122  ***      5            50                   34      $opts ||= {};
1123  ***      5     50                          72      my $defaults = {
1124                                                        AutoCommit         => 0,
1125                                                        RaiseError         => 1,
1126                                                        PrintError         => 0,
1127                                                        ShowErrorStatement => 1,
1128                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1129                                                     };
1130           5                                 34      @{$defaults}{ keys %$opts } = values %$opts;
               5                                 29   
1131                                                  
1132  ***      5     50                          29      if ( !$have_dbi ) {
1133  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1134                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1135                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1136                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1137                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1138                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1139                                                  
1140                                                     }
1141                                                  
1142           5                                 16      my $dbh;
1143           5                                 20      my $tries = 2;
1144  ***      5            66                   86      while ( !$dbh && $tries-- ) {
1145                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1146           5                                 12            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1147                                                  
1148           5                                 22         eval {
1149           5                                 57            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1150                                                  
1151  ***      5     50                          63            if ( $cxn_string =~ m/mysql/i ) {
1152           5                                 15               my $sql;
1153                                                  
1154           5                                 23               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1155                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1156           5                                 14               MKDEBUG && _d($dbh, ':', $sql);
1157           5                                652               $dbh->do($sql);
1158                                                  
1159  ***      5     50                          52               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1160  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1161  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1162  ***      0                                  0                  $dbh->do($sql);
1163  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1164  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1165  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1166                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1167                                                                 }
1168                                                                 else {
1169  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1170                                                                 }
1171                                                              }
1172                                                  
1173  ***      5     50                          36               if ( $self->prop('set-vars') ) {
1174  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1175  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1176  ***      0                                  0                  $dbh->do($sql);
1177                                                              }
1178                                                           }
1179                                                        };
1180  ***      5     50     33                   61         if ( !$dbh && $EVAL_ERROR ) {
1181  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1182  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1183  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1184  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1185                                                           }
1186                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1187  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1188                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1189                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1190                                                                 . "DBD::mysql is not installed, try:\n"
1191                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1192                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1193                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1194                                                           }
1195  ***      0      0                           0            if ( !$tries ) {
1196  ***      0                                  0               die $EVAL_ERROR;
1197                                                           }
1198                                                        }
1199                                                     }
1200                                                  
1201           5                                 13      MKDEBUG && _d('DBH info: ',
1202                                                        $dbh,
1203                                                        Dumper($dbh->selectrow_hashref(
1204                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1205                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1206                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1207                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1208                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1209                                                        '$DBI::VERSION:',        $DBI::VERSION,
1210                                                     );
1211                                                  
1212           5                                 38      return $dbh;
1213                                                  }
1214                                                  
1215                                                  sub get_hostname {
1216  ***      0                    0             0      my ( $self, $dbh ) = @_;
1217  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1218  ***      0                                  0         return $host;
1219                                                     }
1220  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1221                                                        'SELECT /*!50038 @@hostname, */ 1');
1222  ***      0                                  0      return $hostname;
1223                                                  }
1224                                                  
1225                                                  sub disconnect {
1226  ***      0                    0             0      my ( $self, $dbh ) = @_;
1227  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1228  ***      0                                  0      $dbh->disconnect;
1229                                                  }
1230                                                  
1231                                                  sub print_active_handles {
1232  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1233  ***      0             0                    0      $level ||= 0;
1234  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1235                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1236                                                        or die "Cannot print: $OS_ERROR";
1237  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1238  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1239                                                     }
1240                                                  }
1241                                                  
1242                                                  sub copy {
1243  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1244  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1245  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1246  ***      0                                  0      my %new_dsn = map {
1247  ***      0                                  0         my $key = $_;
1248  ***      0                                  0         my $val;
1249  ***      0      0                           0         if ( $args{overwrite} ) {
1250  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1251                                                        }
1252                                                        else {
1253  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1254                                                        }
1255  ***      0                                  0         $key => $val;
1256  ***      0                                  0      } keys %{$self->{opts}};
1257  ***      0                                  0      return \%new_dsn;
1258                                                  }
1259                                                  
1260                                                  sub _d {
1261  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1262  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1263  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1264                                                          @_;
1265  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1266                                                  }
1267                                                  
1268                                                  1;
1269                                                  
1270                                                  # ###########################################################################
1271                                                  # End DSNParser package
1272                                                  # ###########################################################################
1273                                                  
1274                                                  # ###########################################################################
1275                                                  # Daemon package 5266
1276                                                  # ###########################################################################
1277                                                  
1278                                                  package Daemon;
1279                                                  
1280           6                    6            50   use strict;
               6                                 17   
               6                                 37   
1281           6                    6            40   use warnings FATAL => 'all';
               6                                 15   
               6                                 34   
1282                                                  
1283           6                    6            39   use POSIX qw(setsid);
               6                                 25   
               6                                 38   
1284           6                    6            53   use English qw(-no_match_vars);
               6                                 16   
               6                                 32   
1285                                                  
1286  ***      6            50      6            37   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 17   
               6                                 85   
1287                                                  
1288                                                  sub new {
1289  ***      0                    0             0      my ( $class, %args ) = @_;
1290  ***      0                                  0      foreach my $arg ( qw(o) ) {
1291  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1292                                                     }
1293  ***      0                                  0      my $o = $args{o};
1294  ***      0      0                           0      my $self = {
      ***             0                               
1295                                                        o        => $o,
1296                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1297                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1298                                                     };
1299                                                  
1300  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1301                                                  
1302  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1303  ***      0                                  0      return bless $self, $class;
1304                                                  }
1305                                                  
1306                                                  sub daemonize {
1307  ***      0                    0             0      my ( $self ) = @_;
1308                                                  
1309  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1310  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1311  ***      0      0                           0      if ( $pid ) {
1312  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1313  ***      0                                  0         exit;
1314                                                     }
1315                                                  
1316  ***      0                                  0      $self->{child} = 1;
1317                                                  
1318  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1319  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1320                                                  
1321  ***      0                                  0      $self->_make_PID_file();
1322                                                  
1323  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
1324                                                  
1325  ***      0      0                           0      if ( -t STDIN ) {
1326  ***      0                                  0         close STDIN;
1327  ***      0      0                           0         open  STDIN, '/dev/null'
1328                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1329                                                     }
1330                                                  
1331  ***      0      0                           0      if ( $self->{log_file} ) {
1332  ***      0                                  0         close STDOUT;
1333  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1334                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1335                                                  
1336  ***      0                                  0         close STDERR;
1337  ***      0      0                           0         open  STDERR, ">&STDOUT"
1338                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1339                                                     }
1340                                                     else {
1341  ***      0      0                           0         if ( -t STDOUT ) {
1342  ***      0                                  0            close STDOUT;
1343  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
1344                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1345                                                        }
1346  ***      0      0                           0         if ( -t STDERR ) {
1347  ***      0                                  0            close STDERR;
1348  ***      0      0                           0            open  STDERR, '>', '/dev/null'
1349                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1350                                                        }
1351                                                     }
1352                                                  
1353  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1354  ***      0                                  0      return;
1355                                                  }
1356                                                  
1357                                                  sub check_PID_file {
1358  ***      0                    0             0      my ( $self, $file ) = @_;
1359  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1360  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1361  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1362  ***      0                                  0         my $pid;
1363  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1364  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1365  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1366  ***      0      0                           0         if ( $pid ) {
1367  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1368  ***      0      0                           0            if ( $pid_is_alive ) {
1369  ***      0                                  0               die "The PID file $PID_file already exists "
1370                                                                 . " and the PID that it contains, $pid, is running";
1371                                                           }
1372                                                           else {
1373  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1374                                                                 . "contains, $pid, is not running";
1375                                                           }
1376                                                        }
1377                                                        else {
1378  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1379                                                              . "contain a PID";
1380                                                        }
1381                                                     }
1382                                                     else {
1383  ***      0                                  0         MKDEBUG && _d('No PID file');
1384                                                     }
1385  ***      0                                  0      return;
1386                                                  }
1387                                                  
1388                                                  sub make_PID_file {
1389  ***      0                    0             0      my ( $self ) = @_;
1390  ***      0      0                           0      if ( exists $self->{child} ) {
1391  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1392                                                     }
1393  ***      0                                  0      $self->_make_PID_file();
1394  ***      0                                  0      $self->{rm_PID_file} = 1;
1395  ***      0                                  0      return;
1396                                                  }
1397                                                  
1398                                                  sub _make_PID_file {
1399  ***      0                    0             0      my ( $self ) = @_;
1400                                                  
1401  ***      0                                  0      my $PID_file = $self->{PID_file};
1402  ***      0      0                           0      if ( !$PID_file ) {
1403  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1404  ***      0                                  0         return;
1405                                                     }
1406                                                  
1407  ***      0                                  0      $self->check_PID_file();
1408                                                  
1409  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1410                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1411  ***      0      0                           0      print $PID_FH $PID
1412                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1413  ***      0      0                           0      close $PID_FH
1414                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1415                                                  
1416  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1417  ***      0                                  0      return;
1418                                                  }
1419                                                  
1420                                                  sub _remove_PID_file {
1421  ***      0                    0             0      my ( $self ) = @_;
1422  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1423  ***      0      0                           0         unlink $self->{PID_file}
1424                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1425  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1426                                                     }
1427                                                     else {
1428  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1429                                                     }
1430  ***      0                                  0      return;
1431                                                  }
1432                                                  
1433                                                  sub DESTROY {
1434  ***      0                    0             0      my ( $self ) = @_;
1435  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1436  ***      0                                  0      return;
1437                                                  }
1438                                                  
1439                                                  sub _d {
1440  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1441  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1442  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1443                                                          @_;
1444  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1445                                                  }
1446                                                  
1447                                                  1;
1448                                                  
1449                                                  # ###########################################################################
1450                                                  # End Daemon package
1451                                                  # ###########################################################################
1452                                                  
1453                                                  # ###########################################################################
1454                                                  # InnoDBStatusParser package 5266
1455                                                  # ###########################################################################
1456                                                  package InnoDBStatusParser;
1457                                                  
1458                                                  
1459           6                    6            43   use strict;
               6                                 15   
               6                                 36   
1460           6                    6            35   use warnings FATAL => 'all';
               6                                 21   
               6                                 30   
1461                                                  
1462           6                    6            44   use English qw(-no_match_vars);
               6                                 20   
               6                                 28   
1463                                                  
1464  ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                 80   
1465                                                  
1466                                                  
1467                                                  my $d  = qr/(\d+)/;                    # Digit
1468                                                  my $f  = qr/(\d+\.\d+)/;               # Float
1469                                                  my $t  = qr/(\d+ \d+)/;                # Transaction ID
1470                                                  my $i  = qr/((?:\d{1,3}\.){3}\d+)/;    # IP address
1471                                                  my $n  = qr/([^`\s]+)/;                # MySQL object name
1472                                                  my $w  = qr/(\w+)/;                    # Words
1473                                                  my $fl = qr/([\w\.\/]+) line $d/;      # Filename and line number
1474                                                  my $h  = qr/((?:0x)?[0-9a-f]*)/;       # Hex
1475                                                  my $s  = qr/(\d{6} .\d:\d\d:\d\d)/;    # InnoDB timestamp
1476                                                  
1477                                                  sub ts_to_time {
1478  ***      0                    0             0      my ( $ts ) = @_;
1479  ***      0                                  0      sprintf('200%d-%02d-%02d %02d:%02d:%02d',
1480                                                        $ts =~ m/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)/);
1481                                                  }
1482                                                  
1483                                                  my %is_proc_info = (
1484                                                     'After create'                 => 1,
1485                                                     'Execution of init_command'    => 1,
1486                                                     'FULLTEXT initialization'      => 1,
1487                                                     'Reopen tables'                => 1,
1488                                                     'Repair done'                  => 1,
1489                                                     'Repair with keycache'         => 1,
1490                                                     'System lock'                  => 1,
1491                                                     'Table lock'                   => 1,
1492                                                     'Thread initialized'           => 1,
1493                                                     'User lock'                    => 1,
1494                                                     'copy to tmp table'            => 1,
1495                                                     'discard_or_import_tablespace' => 1,
1496                                                     'end'                          => 1,
1497                                                     'got handler lock'             => 1,
1498                                                     'got old table'                => 1,
1499                                                     'init'                         => 1,
1500                                                     'key cache'                    => 1,
1501                                                     'locks'                        => 1,
1502                                                     'malloc'                       => 1,
1503                                                     'query end'                    => 1,
1504                                                     'rename result table'          => 1,
1505                                                     'rename'                       => 1,
1506                                                     'setup'                        => 1,
1507                                                     'statistics'                   => 1,
1508                                                     'status'                       => 1,
1509                                                     'table cache'                  => 1,
1510                                                     'update'                       => 1,
1511                                                  );
1512                                                  
1513                                                  my ( $COLS, $PATTERN ) = (0, 1);
1514                                                  my %parse_rules_for = (
1515                                                  
1516                                                     "BACKGROUND THREAD" => {
1517                                                        rules => [
1518                                                           [
1519                                                              [qw(
1520                                                                 Innodb_srv_main_1_second_loops
1521                                                                 Innodb_srv_main_sleeps
1522                                                                 Innodb_srv_main_10_second_loops
1523                                                                 Innodb_srv_main_background_loops
1524                                                                 Innodb_srv_main_flush_loops
1525                                                              )],
1526                                                              qr/^srv_master_thread loops: $d 1_second, $d sleeps, $d 10_second, $d background, $d flush$/m,
1527                                                           ],
1528                                                           [
1529                                                              [qw(
1530                                                                 Innodb_srv_sync_flush
1531                                                                 Innodb_srv_async_flush
1532                                                              )],
1533                                                              qr/^srv_master_thread log flush: $d sync, $d async$/m,
1534                                                           ],
1535                                                           [
1536                                                              [qw(
1537                                                                 Innodb_flush_from_dirty_buffer
1538                                                                 Innodb_flush_from_other
1539                                                                 Innodb_flush_from_checkpoint
1540                                                                 Innodb_flush_from_log_io_complete
1541                                                                 Innodb_flush_from_log_write_up_to
1542                                                                 Innodb_flush_from_archive
1543                                                              )],
1544                                                              qr/^fsync callers: $d buffer pool, $d other, $d checkpoint, $d log aio, $d log sync, $d archive$/m,
1545                                                           ],
1546                                                        ],
1547                                                        customcode => sub{},
1548                                                     },
1549                                                  
1550                                                     "SEMAPHORES" => {
1551                                                        rules => [
1552                                                           [
1553                                                              [qw(
1554                                                                 Innodb_lock_wait_timeouts
1555                                                              )],
1556                                                              qr/^Lock wait timeouts $d$/m,
1557                                                           ],
1558                                                           [
1559                                                              [qw(
1560                                                                 Innodb_wait_array_reservation_count
1561                                                                 Innodb_wait_array_signal_count
1562                                                              )],
1563                                                              qr/^OS WAIT ARRAY INFO: reservation count $d, signal count $d$/m,
1564                                                           ],
1565                                                           [
1566                                                              [qw(
1567                                                                 Innodb_mutex_spin_waits
1568                                                                 Innodb_mutex_spin_rounds
1569                                                                 Innodb_mutex_os_waits
1570                                                              )],
1571                                                              qr/^Mutex spin waits $d, rounds $d, OS waits $d$/m,
1572                                                           ],
1573                                                           [
1574                                                              [qw(
1575                                                                 Innodb_mutex_rw_shared_spins
1576                                                                 Innodb_mutex_rw_shared_os_waits
1577                                                                 Innodb_mutex_rw_excl_spins
1578                                                                 Innodb_mutex_rw_excl_os_waits
1579                                                              )],
1580                                                              qr/^RW-shared spins $d, OS waits $d; RW-excl spins $d, OS waits $d$/m,
1581                                                           ],
1582                                                        ],
1583                                                        customcode => sub {},
1584                                                     },
1585                                                  
1586                                                     'LATEST FOREIGN KEY ERROR' => {
1587                                                        rules => [
1588                                                           [
1589                                                              [qw(
1590                                                                 Innodb_fk_time
1591                                                              )],
1592                                                              qr/^$s/m,
1593                                                           ],
1594                                                           [
1595                                                              [qw(
1596                                                                 Innodb_fk_child_db
1597                                                                 Innodb_fk_child_table
1598                                                              )],
1599                                                              qr{oreign key constraint (?:fails for|of) table `?(.*?)`?/`?(.*?)`?:$}m,
1600                                                           ],
1601                                                           [
1602                                                              [qw(
1603                                                                 Innodb_fk_name
1604                                                                 Innodb_fk_child_cols
1605                                                                 Innodb_fk_parent_db
1606                                                                 Innodb_fk_parent_table
1607                                                                 Innodb_fk_parent_cols
1608                                                              )],
1609                                                              qr/CONSTRAINT `?$n`? FOREIGN KEY \((.+?)\) REFERENCES (?:`?$n`?\.)?`?$n`? \((.+?)\)/m,
1610                                                           ],
1611                                                           [
1612                                                              [qw(
1613                                                                 Innodb_fk_child_index
1614                                                              )],
1615                                                              qr/(?:in child table, in index|foreign key in table is) `?$n`?/m,
1616                                                           ],
1617                                                           [
1618                                                              [qw(
1619                                                                 Innodb_fk_parent_index
1620                                                              )],
1621                                                              qr/in parent table \S+ in index `$n`/m,
1622                                                           ],
1623                                                        ],
1624                                                        customcode => sub {
1625                                                           my ( $status, $text ) = @_;
1626                                                           if ( $status->{Innodb_fk_time} ) {
1627                                                              $status->{Innodb_fk_time} = ts_to_time($status->{Innodb_fk_time});
1628                                                           }
1629                                                           $status->{Innodb_fk_parent_db} ||= $status->{Innodb_fk_child_db};
1630                                                           if ( $text =~ m/^there is no index/m ) {
1631                                                              $status->{Innodb_fk_reason} = 'No index or type mismatch';
1632                                                           }
1633                                                           elsif ( $text =~ m/closest match we can find/ ) {
1634                                                              $status->{Innodb_fk_reason} = 'No matching row';
1635                                                           }
1636                                                           elsif ( $text =~ m/, there is a record/ ) {
1637                                                              $status->{Innodb_fk_reason} = 'Orphan row';
1638                                                           }
1639                                                           elsif ( $text =~ m/Cannot resolve table name|nor its .ibd file/ ) {
1640                                                              $status->{Innodb_fk_reason} = 'No such parent table';
1641                                                           }
1642                                                           elsif ( $text =~ m/Cannot (?:DISCARD|drop)/ ) {
1643                                                              $status->{Innodb_fk_reason} = 'Table is referenced';
1644                                                              @{$status}{qw(
1645                                                                 Innodb_fk_parent_db Innodb_fk_parent_table
1646                                                                 Innodb_fk_child_db Innodb_fk_child_table
1647                                                              )}
1648                                                              = $text =~ m{table `$n/$n`\nbecause it is referenced by `$n/$n`};
1649                                                           }
1650                                                        },
1651                                                     },
1652                                                  
1653                                                     'LATEST DETECTED DEADLOCK' => {
1654                                                        rules => [
1655                                                           [
1656                                                              [qw(
1657                                                                 Innodb_deadlock_time
1658                                                              )],
1659                                                              qr/^$s$/m,
1660                                                           ],
1661                                                        ],
1662                                                        customcode => sub {
1663                                                           my ( $status, $text ) = @_;
1664                                                           if ( $status->{Innodb_deadlock_time} ) {
1665                                                              $status->{Innodb_deadlock_time}
1666                                                                 = ts_to_time($status->{Innodb_deadlock_time});
1667                                                           }
1668                                                        },
1669                                                     },
1670                                                  
1671                                                     'TRANSACTIONS' => {
1672                                                        rules => [
1673                                                           [
1674                                                              [qw(Innodb_transaction_counter)],
1675                                                              qr/^Trx id counter $t$/m,
1676                                                           ],
1677                                                           [
1678                                                              [qw(
1679                                                                 Innodb_purged_to
1680                                                                 Innodb_undo_log_record
1681                                                              )],
1682                                                              qr/^Purge done for trx's n:o < $t undo n:o < $t$/m,
1683                                                           ],
1684                                                           [
1685                                                              [qw(Innodb_history_list_length)],
1686                                                              qr/^History list length $d$/m,
1687                                                           ],
1688                                                           [
1689                                                              [qw(Innodb_lock_struct_count)],
1690                                                              qr/^Total number of lock structs in row lock hash table $d$/m,
1691                                                           ],
1692                                                        ],
1693                                                        customcode => sub {
1694                                                           my ( $status, $text ) = @_;
1695                                                           $status->{Innodb_transactions_truncated}
1696                                                              = $text =~ m/^\.\.\. truncated\.\.\.$/m ? 1 : 0;
1697                                                           my @txns = $text =~ m/(^---TRANSACTION)/mg;
1698                                                           $status->{Innodb_transactions} = scalar(@txns);
1699                                                        },
1700                                                     },
1701                                                  
1702                                                     'FILE I/O' => {
1703                                                        rules => [
1704                                                           [
1705                                                              [qw(
1706                                                                 Innodb_pending_aio_reads
1707                                                                 Innodb_pending_aio_writes
1708                                                              )],
1709                                                              qr/^Pending normal aio reads: $d, aio writes: $d,$/m,
1710                                                           ],
1711                                                           [
1712                                                              [qw(
1713                                                                 Innodb_insert_buffer_pending_reads
1714                                                                 Innodb_log_pending_io
1715                                                                 Innodb_pending_sync_io
1716                                                              )],
1717                                                              qr{^ ibuf aio reads: $d, log i/o's: $d, sync i/o's: $d$}m,
1718                                                           ],
1719                                                           [
1720                                                              [qw(
1721                                                                 Innodb_os_log_pending_fsyncs
1722                                                                 Innodb_buffer_pool_pending_fsyncs
1723                                                              )],
1724                                                              qr/^Pending flushes \(fsync\) log: $d; buffer pool: $d$/m,
1725                                                           ],
1726                                                           [
1727                                                              [qw(
1728                                                                 Innodb_data_reads
1729                                                                 Innodb_data_writes
1730                                                                 Innodb_data_fsyncs
1731                                                              )],
1732                                                              qr/^$d OS file reads, $d OS file writes, $d OS fsyncs$/m,
1733                                                           ],
1734                                                           [
1735                                                              [qw(
1736                                                                 Innodb_data_reads_sec
1737                                                                 Innodb_data_bytes_per_read
1738                                                                 Innodb_data_writes_sec
1739                                                                 Innodb_data_fsyncs_sec
1740                                                              )],
1741                                                              qr{^$f reads/s, $d avg bytes/read, $f writes/s, $f fsyncs/s$}m,
1742                                                           ],
1743                                                           [
1744                                                              [qw(
1745                                                                 Innodb_data_pending_preads
1746                                                                 Innodb_data_pending_pwrites
1747                                                              )],
1748                                                              qr/$d pending preads, $d pending pwrites$/m,
1749                                                           ],
1750                                                        ],
1751                                                        customcode => sub {
1752                                                           my ( $status, $text ) = @_;
1753                                                           my @thds = $text =~ m/^I.O thread $d state:/gm;
1754                                                           $status->{Innodb_num_io_threads} = scalar(@thds);
1755                                                           $status->{Innodb_data_pending_fsyncs}
1756                                                              = $status->{Innodb_os_log_pending_fsyncs}
1757                                                              + $status->{Innodb_buffer_pool_pending_fsyncs};
1758                                                        },
1759                                                     },
1760                                                  
1761                                                     'INSERT BUFFER AND ADAPTIVE HASH INDEX' => {
1762                                                        rules => [
1763                                                           [
1764                                                              [qw(
1765                                                                 Innodb_insert_buffer_size
1766                                                                 Innodb_insert_buffer_free_list_length
1767                                                                 Innodb_insert_buffer_segment_size
1768                                                              )],
1769                                                              qr/^Ibuf(?: for space 0)?: size $d, free list len $d, seg size $d,$/m,
1770                                                           ],
1771                                                           [
1772                                                              [qw(
1773                                                                 Innodb_insert_buffer_inserts
1774                                                                 Innodb_insert_buffer_merged_records
1775                                                                 Innodb_insert_buffer_merges
1776                                                              )],
1777                                                              qr/^$d inserts, $d merged recs, $d merges$/m,
1778                                                           ],
1779                                                           [
1780                                                              [qw(
1781                                                                 Innodb_hash_table_size
1782                                                                 Innodb_hash_table_used_cells
1783                                                                 Innodb_hash_table_buf_frames_reserved
1784                                                              )],
1785                                                              qr/^Hash table size $d, used cells $d, node heap has $d buffer\(s\)$/m,
1786                                                           ],
1787                                                           [
1788                                                              [qw(
1789                                                                 Innodb_hash_searches_sec
1790                                                                 Innodb_nonhash_searches_sec
1791                                                              )],
1792                                                              qr{^$f hash searches/s, $f non-hash searches/s$}m,
1793                                                           ],
1794                                                        ],
1795                                                        customcode => sub {},
1796                                                     },
1797                                                  
1798                                                     'LOG' => {
1799                                                        rules => [
1800                                                           [
1801                                                              [qw(
1802                                                                 Innodb_log_sequence_no
1803                                                              )],
1804                                                              qr/Log sequence number \s*(\d.*)$/m,
1805                                                           ],
1806                                                           [
1807                                                              [qw(
1808                                                                 Innodb_log_flushed_to
1809                                                              )],
1810                                                              qr/Log flushed up to \s*(\d.*)$/m,
1811                                                           ],
1812                                                           [
1813                                                              [qw(
1814                                                                 Innodb_log_last_checkpoint
1815                                                              )],
1816                                                              qr/Last checkpoint at \s*(\d.*)$/m,
1817                                                           ],
1818                                                           [
1819                                                              [qw(
1820                                                                 Innodb_log_pending_writes
1821                                                                 Innodb_log_pending_chkp_writes
1822                                                              )],
1823                                                              qr/$d pending log writes, $d pending chkp writes/m,
1824                                                           ],
1825                                                           [
1826                                                              [qw(
1827                                                                 Innodb_log_ios
1828                                                                 Innodb_log_ios_sec
1829                                                              )],
1830                                                              qr{$d log i/o's done, $f log i/o's/second}m,
1831                                                           ],
1832                                                           [
1833                                                              [qw(
1834                                                                 Innodb_log_caller_write_buffer_pool
1835                                                                 Innodb_log_caller_write_background_sync
1836                                                                 Innodb_log_caller_write_background_async
1837                                                                 Innodb_log_caller_write_internal
1838                                                                 Innodb_log_caller_write_checkpoint_sync
1839                                                                 Innodb_log_caller_write_checkpoint_async
1840                                                                 Innodb_log_caller_write_log_archive
1841                                                                 Innodb_log_caller_write_commit_sync
1842                                                                 Innodb_log_caller_write_commit_async
1843                                                              )],
1844                                                              qr/^log sync callers: $d buffer pool, background $d sync and $d async, $d internal, checkpoint $d sync and $d async, $d archive, commit $d sync and $d async$/m,
1845                                                           ],
1846                                                           [
1847                                                              [qw(
1848                                                                 Innodb_log_syncer_write_buffer_pool
1849                                                                 Innodb_log_syncer_write_background_sync
1850                                                                 Innodb_log_syncer_write_background_async
1851                                                                 Innodb_log_syncer_write_internal
1852                                                                 Innodb_log_syncer_write_checkpoint_sync
1853                                                                 Innodb_log_syncer_write_checkpoint_async
1854                                                                 Innodb_log_syncer_write_log_archive
1855                                                                 Innodb_log_syncer_write_commit_sync
1856                                                                 Innodb_log_syncer_write_commit_async
1857                                                              )],
1858                                                              qr/^log sync syncers: $d buffer pool, background $d sync and $d async, $d internal, checkpoint $d sync and $d async, $d archive, commit $d sync and $d async$/m,
1859                                                           ],
1860                                                        ],
1861                                                        customcode => sub {},
1862                                                     },
1863                                                  
1864                                                     'BUFFER POOL AND MEMORY' => {
1865                                                        rules => [
1866                                                           [
1867                                                              [qw(
1868                                                                 Innodb_total_memory_allocated
1869                                                                 Innodb_common_memory_allocated
1870                                                              )],
1871                                                              qr/^Total memory allocated $d; in additional pool allocated $d$/m,
1872                                                           ],
1873                                                           [
1874                                                              [qw(
1875                                                                 Innodb_dictionary_memory_allocated
1876                                                              )],
1877                                                              qr/Dictionary memory allocated $d/m,
1878                                                           ],
1879                                                           [
1880                                                              [qw(
1881                                                                 Innodb_awe_memory_allocated
1882                                                              )],
1883                                                              qr/$d MB of AWE memory/m,
1884                                                           ],
1885                                                           [
1886                                                              [qw(
1887                                                                 Innodb_buffer_pool_awe_memory_frames
1888                                                              )],
1889                                                              qr/AWE: Buffer pool memory frames\s+$d/m,
1890                                                           ],
1891                                                           [
1892                                                              [qw(
1893                                                                 Innodb_buffer_pool_awe_mapped
1894                                                              )],
1895                                                              qr/AWE: Database pages and free buffers mapped in frames\s+$d/m,
1896                                                           ],
1897                                                           [
1898                                                              [qw(
1899                                                                 Innodb_buffer_pool_pages_total
1900                                                              )],
1901                                                              qr/^Buffer pool size\s*$d$/m,
1902                                                           ],
1903                                                           [
1904                                                              [qw(
1905                                                                 Innodb_buffer_pool_pages_free
1906                                                              )],
1907                                                              qr/^Free buffers\s*$d$/m,
1908                                                           ],
1909                                                           [
1910                                                              [qw(
1911                                                                 Innodb_buffer_pool_pages_data
1912                                                              )],
1913                                                              qr/^Database pages\s*$d$/m,
1914                                                           ],
1915                                                           [
1916                                                              [qw(
1917                                                                 Innodb_buffer_pool_pages_dirty
1918                                                              )],
1919                                                              qr/^Modified db pages\s*$d$/m,
1920                                                           ],
1921                                                           [
1922                                                              [qw(
1923                                                                 Innodb_buffer_pool_pending_reads
1924                                                              )],
1925                                                              qr/^Pending reads $d$/m,
1926                                                           ],
1927                                                           [
1928                                                              [qw(
1929                                                                 Innodb_buffer_pool_pending_data_writes
1930                                                                 Innodb_buffer_pool_pending_dirty_writes
1931                                                                 Innodb_buffer_pool_pending_single_writes
1932                                                              )],
1933                                                              qr/Pending writes: LRU $d, flush list $d, single page $d/m,
1934                                                           ],
1935                                                           [
1936                                                              [qw(
1937                                                                 Innodb_buffer_pool_pages_read
1938                                                                 Innodb_buffer_pool_pages_created
1939                                                                 Innodb_buffer_pool_pages_written
1940                                                              )],
1941                                                              qr/^Pages read $d, created $d, written $d$/m,
1942                                                           ],
1943                                                           [
1944                                                              [qw(
1945                                                                 Innodb_buffer_pool_pages_read_sec
1946                                                                 Innodb_buffer_pool_pages_created_sec
1947                                                                 Innodb_buffer_pool_pages_written_sec
1948                                                              )],
1949                                                              qr{^$f reads/s, $f creates/s, $f writes/s$}m,
1950                                                           ],
1951                                                           [
1952                                                              [qw(
1953                                                                 Innodb_buffer_pool_awe_pages_remapped_sec
1954                                                              )],
1955                                                              qr{^AWE: $f page remaps/s$}m,
1956                                                           ],
1957                                                           [
1958                                                              [qw(
1959                                                                 Innodb_buffer_pool_hit_rate
1960                                                              )],
1961                                                              qr/^Buffer pool hit rate $d/m,
1962                                                           ],
1963                                                        ],
1964                                                        customcode => sub {
1965                                                           my ( $status, $text ) = @_;
1966                                                           if ( defined $status->{Innodb_buffer_pool_hit_rate} ) {
1967                                                              $status->{Innodb_buffer_pool_hit_rate} /= 1000;
1968                                                           }
1969                                                           else {
1970                                                              $status->{Innodb_buffer_pool_hit_rate} = 1;
1971                                                           }
1972                                                        },
1973                                                     },
1974                                                  
1975                                                     'ROW OPERATIONS' => {
1976                                                        rules => [
1977                                                           [
1978                                                              [qw(
1979                                                                 Innodb_threads_inside_kernel
1980                                                                 Innodb_threads_queued
1981                                                              )],
1982                                                              qr/^$d queries inside InnoDB, $d queries in queue$/m,
1983                                                           ],
1984                                                           [
1985                                                              [qw(
1986                                                                 Innodb_read_views_open
1987                                                              )],
1988                                                              qr/^$d read views open inside InnoDB$/m,
1989                                                           ],
1990                                                           [
1991                                                              [qw(
1992                                                                 Innodb_reserved_extent_count
1993                                                              )],
1994                                                              qr/^$d tablespace extents now reserved for B-tree/m,
1995                                                           ],
1996                                                           [
1997                                                              [qw(
1998                                                                 Innodb_main_thread_proc_no
1999                                                                 Innodb_main_thread_id
2000                                                                 Innodb_main_thread_state
2001                                                              )],
2002                                                              qr/^Main thread (?:process no. $d, )?id $d, state: (.*)$/m,
2003                                                           ],
2004                                                           [
2005                                                              [qw(
2006                                                                 Innodb_rows_inserted
2007                                                                 Innodb_rows_updated
2008                                                                 Innodb_rows_deleted
2009                                                                 Innodb_rows_read
2010                                                              )],
2011                                                              qr/^Number of rows inserted $d, updated $d, deleted $d, read $d$/m,
2012                                                           ],
2013                                                           [
2014                                                              [qw(
2015                                                                 Innodb_rows_inserted_sec
2016                                                                 Innodb_rows_updated_sec
2017                                                                 Innodb_rows_deleted_sec
2018                                                                 Innodb_rows_read_sec
2019                                                              )],
2020                                                              qr{^$f inserts/s, $f updates/s, $f deletes/s, $f reads/s$}m,
2021                                                           ],
2022                                                        ],
2023                                                        customcode => sub {},
2024                                                     },
2025                                                  
2026                                                     top_level => {
2027                                                        rules => [
2028                                                           [
2029                                                              [qw(
2030                                                                 Innodb_status_time
2031                                                              )],
2032                                                              qr/^$s INNODB MONITOR OUTPUT$/m,
2033                                                           ],
2034                                                           [
2035                                                              [qw(
2036                                                                 Innodb_status_interval
2037                                                              )],
2038                                                              qr/Per second averages calculated from the last $d seconds/m,
2039                                                           ],
2040                                                        ],
2041                                                        customcode => sub {
2042                                                           my ( $status, $text ) = @_;
2043                                                           $status->{Innodb_status_time}
2044                                                              = ts_to_time($status->{Innodb_status_time});
2045                                                           $status->{Innodb_status_truncated}
2046                                                              = $text =~ m/END OF INNODB MONITOR OUTPUT/ ? 0 : 1;
2047                                                        },
2048                                                     },
2049                                                  
2050                                                     transaction => {
2051                                                        rules => [
2052                                                           [
2053                                                              [qw(
2054                                                                 txn_id
2055                                                                 txn_status
2056                                                                 active_secs
2057                                                                 proc_no
2058                                                                 os_thread_id
2059                                                              )],
2060                                                              qr/^(?:---)?TRANSACTION $t, (\D*?)(?: $d sec)?, (?:process no $d, )?OS thread id $d/m,
2061                                                           ],
2062                                                           [
2063                                                              [qw(
2064                                                                 thread_status
2065                                                                 tickets
2066                                                              )],
2067                                                              qr/OS thread id \d+(?: ([^,]+?))?(?:, thread declared inside InnoDB $d)?$/m,
2068                                                           ],
2069                                                           [
2070                                                              [qw(
2071                                                                 txn_query_status
2072                                                                 lock_structs
2073                                                                 heap_size
2074                                                                 row_locks
2075                                                                 undo_log_entries
2076                                                              )],
2077                                                              qr/^(?:(\D*) )?$d lock struct\(s\), heap size $d(?:, $d row lock\(s\))?(?:, undo log entries $d)?$/m,
2078                                                           ],
2079                                                           [
2080                                                              [qw(
2081                                                                 lock_wait_time
2082                                                              )],
2083                                                              qr/^------- TRX HAS BEEN WAITING $d SEC/m,
2084                                                           ],
2085                                                           [
2086                                                              [qw(
2087                                                                 mysql_tables_used
2088                                                                 mysql_tables_locked
2089                                                              )],
2090                                                              qr/^mysql tables in use $d, locked $d$/m,
2091                                                           ],
2092                                                           [
2093                                                              [qw(
2094                                                                 read_view_lower_limit
2095                                                                 read_view_upper_limit
2096                                                              )],
2097                                                              qr/^Trx read view will not see trx with id >= $t, sees < $t$/m,
2098                                                           ],
2099                                                           [
2100                                                              [qw(
2101                                                                 query_text
2102                                                              )],
2103                                                              qr{
2104                                                                 ^MySQL\sthread\sid\s[^\n]+\n           # This comes before the query text
2105                                                                 (.*?)                                  # The query text
2106                                                                 (?=                                    # Followed by any of...
2107                                                                    ^Trx\sread\sview
2108                                                                    |^-------\sTRX\sHAS\sBEEN\sWAITING
2109                                                                    |^TABLE\sLOCK
2110                                                                    |^RECORD\sLOCKS\sspace\sid
2111                                                                    |^(?:---)?TRANSACTION
2112                                                                    |^\*\*\*\s\(\d\)
2113                                                                    |\Z
2114                                                                 )
2115                                                              }xms,
2116                                                           ],
2117                                                        ],
2118                                                        customcode => sub {
2119                                                           my ( $status, $text ) = @_;
2120                                                           if ( $status->{query_text} ) {
2121                                                              $status->{query_text} =~ s/\n*$//;
2122                                                           }
2123                                                        },
2124                                                     },
2125                                                  
2126                                                     lock => {
2127                                                        rules => [
2128                                                           [
2129                                                              [qw(
2130                                                                 type space_id page_no num_bits index database table txn_id mode
2131                                                              )],
2132                                                              qr{^(RECORD|TABLE) LOCKS? (?:space id $d page no $d n bits $d index `?$n`? of )?table `$n(?:/|`\.`)$n` trx id $t lock.mode (\S+)}m,
2133                                                           ],
2134                                                           [
2135                                                              [qw(
2136                                                                 gap
2137                                                              )],
2138                                                              qr/^(?:RECORD|TABLE) .*? locks (rec but not gap|gap before rec)/m,
2139                                                           ],
2140                                                           [
2141                                                              [qw(
2142                                                                 insert_intent
2143                                                              )],
2144                                                              qr/^(?:RECORD|TABLE) .*? (insert intention)/m,
2145                                                           ],
2146                                                           [
2147                                                              [qw(
2148                                                                 waiting
2149                                                              )],
2150                                                              qr/^(?:RECORD|TABLE) .*? (waiting)/m,
2151                                                           ],
2152                                                        ],
2153                                                        customcode => sub {
2154                                                           my ( $status, $text ) = @_;
2155                                                        },
2156                                                     },
2157                                                  
2158                                                     io_thread => {
2159                                                        rules => [
2160                                                           [
2161                                                              [qw(
2162                                                                 id
2163                                                                 state
2164                                                                 purpose
2165                                                  
2166                                                                 event_set
2167                                                              )],
2168                                                              qr{^I/O thread $d state: (.+?) \((.*)\)}m,
2169                                                           ],
2170                                                           [
2171                                                              [qw(
2172                                                                 io_reads
2173                                                                 io_writes
2174                                                                 io_requests
2175                                                                 io_wait
2176                                                                 io_avg_wait
2177                                                                 max_io_wait
2178                                                              )],
2179                                                              qr{reads $d writes $d requests $d io secs $f io msecs/request $f max_io_wait $f}m,
2180                                                           ],
2181                                                           [
2182                                                              [qw(
2183                                                                 event_set
2184                                                              )],
2185                                                              qr/ ev (set)/m,
2186                                                           ],
2187                                                        ],
2188                                                        customcode => sub {
2189                                                           my ( $status, $text ) = @_;
2190                                                        },
2191                                                     },
2192                                                  
2193                                                     mutex_wait => {
2194                                                        rules => [
2195                                                           [
2196                                                              [qw(
2197                                                                 thread_id
2198                                                                 mutex_file
2199                                                                 mutex_line
2200                                                                 wait_secs
2201                                                              )],
2202                                                              qr/^--Thread $d has waited at $fl for $f seconds/m,
2203                                                           ],
2204                                                           [
2205                                                              [qw(
2206                                                                 wait_has_ended
2207                                                              )],
2208                                                              qr/^wait has ended$/m,
2209                                                           ],
2210                                                           [
2211                                                              [qw(
2212                                                                 cell_event_set
2213                                                              )],
2214                                                              qr/^wait is ending$/m,
2215                                                           ],
2216                                                        ],
2217                                                        customcode => sub {
2218                                                           my ( $status, $text ) = @_;
2219                                                           if ( $text =~ m/^Mutex at/m ) {
2220                                                              InnoDBParser::apply_rules(undef, $status, $text, 'sync_mutex');
2221                                                           }
2222                                                           else {
2223                                                              InnoDBParser::apply_rules(undef, $status, $text, 'rw_lock');
2224                                                           }
2225                                                        },
2226                                                     },
2227                                                  
2228                                                     sync_mutex => {
2229                                                        rules => [
2230                                                           [
2231                                                              [qw(
2232                                                                 type 
2233                                                                 lock_mem_addr
2234                                                                 lock_cfile_name
2235                                                                 lock_cline
2236                                                                 lock_word
2237                                                              )],
2238                                                              qr/^(M)utex at $h created file $fl, lock var $d$/m,
2239                                                           ],
2240                                                           [
2241                                                              [qw(
2242                                                                 lock_file_name
2243                                                                 lock_file_line
2244                                                                 num_waiters
2245                                                              )],
2246                                                              qr/^(?:Last time reserved in file $fl, )?waiters flag $d$/m,
2247                                                           ],
2248                                                        ],
2249                                                        customcode => sub {
2250                                                           my ( $status, $text ) = @_;
2251                                                        },
2252                                                     },
2253                                                  
2254                                                     rw_lock => {
2255                                                        rules => [
2256                                                           [
2257                                                              [qw(
2258                                                                 type 
2259                                                                 lock_cfile_name
2260                                                                 lock_cline
2261                                                              )],
2262                                                              qr/^(.)-lock on RW-latch at $h created in file $fl$/m,
2263                                                           ],
2264                                                           [
2265                                                              [qw(
2266                                                                 writer_thread
2267                                                                 writer_lock_mode
2268                                                              )],
2269                                                              qr/^a writer \(thread id $d\) has reserved it in mode  (.*)$/m,
2270                                                           ],
2271                                                           [
2272                                                              [qw(
2273                                                                 num_readers
2274                                                                 num_waiters
2275                                                              )],
2276                                                              qr/^number of readers $d, waiters flag $d$/m,
2277                                                           ],
2278                                                           [
2279                                                              [qw(
2280                                                                 last_s_file_name
2281                                                                 last_s_line
2282                                                              )],
2283                                                              qr/^Last time read locked in file $fl$/m,
2284                                                           ],
2285                                                           [
2286                                                              [qw(
2287                                                                 last_x_file_name
2288                                                                 last_x_line
2289                                                              )],
2290                                                              qr/^Last time write locked in file $fl$/m,
2291                                                           ],
2292                                                        ],
2293                                                        customcode => sub {
2294                                                           my ( $status, $text ) = @_;
2295                                                        },
2296                                                     },
2297                                                  
2298                                                  );
2299                                                  
2300                                                  sub new {
2301  ***      0                    0             0      my ( $class, %args ) = @_;
2302  ***      0                                  0      return bless {}, $class;
2303                                                  }
2304                                                  
2305                                                  sub parse {
2306  ***      0                    0             0      my ( $self, $text ) = @_;
2307                                                  
2308  ***      0                                  0      my %result = (
2309                                                        status                => [{}], # Non-repeating data
2310                                                        deadlock_transactions => [],   # The transactions only
2311                                                        deadlock_locks        => [],   # Both held and waited-for
2312                                                        transactions          => [],
2313                                                        transaction_locks     => [],   # Both held and waited-for
2314                                                        io_threads            => [],
2315                                                        mutex_waits           => [],
2316                                                        insert_buffer_pages   => [],   # Only if InnoDB built with UNIV_IBUF_DEBUG
2317                                                     );
2318  ***      0                                  0      my $status = $result{status}[0];
2319                                                  
2320  ***      0                                  0      my %innodb_sections;
2321  ***      0                                  0      my @matches = $text
2322                                                        =~ m#\n(---+)\n([A-Z /]+)\n\1\n(.*?)(?=\n(---+)\n[A-Z /]+\n\4\n|$)#gs;
2323  ***      0                                  0      while ( my ($start, $name, $section_text, $end) = splice(@matches, 0, 4) ) {
2324  ***      0                                  0         $innodb_sections{$name} = $section_text;
2325                                                     }
2326                                                  
2327  ***      0                                  0      $self->apply_rules($status, $text, 'top_level');
2328                                                  
2329  ***      0                                  0      foreach my $section ( keys %innodb_sections ) {
2330  ***      0                                  0         my $section_text = $innodb_sections{$section};
2331  ***      0      0                           0         next unless defined $section_text; # No point in trying to parse further.
2332  ***      0                                  0         $self->apply_rules($status, $section_text, $section);
2333                                                     }
2334                                                  
2335  ***      0      0                           0      if ( $innodb_sections{'LATEST DETECTED DEADLOCK'} ) {
2336  ***      0                                  0         @result{qw(deadlock_transactions deadlock_locks)}
2337                                                           = $self->parse_deadlocks($innodb_sections{'LATEST DETECTED DEADLOCK'});
2338                                                     }
2339  ***      0      0                           0      if ( $innodb_sections{'INSERT BUFFER AND ADAPTIVE HASH INDEX'} ) {
2340  ***      0                                  0         $result{insert_buffer_pages} = [
2341                                                           map {
2342  ***      0                                  0               my %page;
2343  ***      0                                  0               @page{qw(page buffer_count)}
2344                                                                 = $_ =~ m/Ibuf count for page $d is $d$/;
2345  ***      0                                  0               \%page;
2346                                                           } $innodb_sections{'INSERT BUFFER AND ADAPTIVE HASH INDEX'}
2347                                                              =~ m/(^Ibuf count for page.*$)/gs
2348                                                        ];
2349                                                     }
2350  ***      0      0                           0      if ( $innodb_sections{'TRANSACTIONS'} ) {
2351  ***      0                                  0         $result{transactions} = [
2352  ***      0                                  0            map { $self->parse_txn($_) }
2353                                                              $innodb_sections{'TRANSACTIONS'}
2354                                                              =~ m/(---TRANSACTION \d.*?)(?=\n---TRANSACTION|$)/gs
2355                                                        ];
2356  ***      0                                  0         $result{transaction_locks} = [
2357                                                           map {
2358  ***      0                                  0               my $lock = {};
2359  ***      0                                  0               $self->apply_rules($lock, $_, 'lock');
2360  ***      0                                  0               $lock;
2361                                                           }
2362                                                           $innodb_sections{'TRANSACTIONS'} =~ m/(^(?:RECORD|TABLE) LOCKS?.*$)/gm
2363                                                        ];
2364                                                     }
2365  ***      0      0                           0      if ( $innodb_sections{'FILE I/O'} ) {
2366  ***      0                                  0         $result{io_threads} = [
2367                                                           map {
2368  ***      0                                  0               my $thread = {};
2369  ***      0                                  0               $self->apply_rules($thread, $_, 'io_thread');
2370  ***      0                                  0               $thread;
2371                                                           }
2372                                                           $innodb_sections{'FILE I/O'} =~ m{^(I/O thread \d+ .*)$}gm
2373                                                        ];
2374                                                     }
2375  ***      0      0                           0      if ( $innodb_sections{SEMAPHORES} ) {
2376  ***      0                                  0         $result{mutex_waits} = [
2377                                                           map {
2378  ***      0                                  0               my $cell = {};
2379  ***      0                                  0               $self->apply_rules($cell, $_, 'mutex_wait');
2380  ***      0                                  0               $cell;
2381                                                           }
2382                                                           $innodb_sections{SEMAPHORES} =~ m/^(--Thread.*?)^(?=Mutex spin|--Thread)/gms
2383                                                        ];
2384                                                     }
2385                                                  
2386  ***      0                                  0      return \%result;
2387                                                  }
2388                                                  
2389                                                  sub apply_rules {
2390  ***      0                    0             0      my ($self, $hashref, $text, $rulename) = @_;
2391  ***      0      0                           0      my $rules = $parse_rules_for{$rulename}
2392                                                        or die "There are no parse rules for '$rulename'";
2393  ***      0                                  0      foreach my $rule ( @{$rules->{rules}} ) {
      ***      0                                  0   
2394  ***      0                                  0         @{$hashref}{ @{$rule->[$COLS]} } = $text =~ m/$rule->[$PATTERN]/m;
      ***      0                                  0   
      ***      0                                  0   
2395                                                     }
2396  ***      0                                  0      $rules->{customcode}->($hashref, $text);
2397                                                  }
2398                                                  
2399                                                  sub parse_deadlocks {
2400  ***      0                    0             0      my ($self, $text) = @_;
2401  ***      0                                  0      my (@txns, @locks);
2402                                                  
2403  ***      0                                  0      my @sections = $text
2404                                                        =~ m{
2405                                                           ^\*{3}\s([^\n]*)  # *** (1) WAITING FOR THIS...
2406                                                           (.*?)             # Followed by anything, non-greedy
2407                                                           (?=(?:^\*{3})|\z) # Followed by another three stars or EOF
2408                                                        }gmsx;
2409                                                  
2410  ***      0                                  0      while ( my ($header, $body) = splice(@sections, 0, 2) ) {
2411  ***      0      0                           0         my ( $num, $what ) = $header =~ m/^\($d\) (.*):$/
2412                                                           or next; # For the WE ROLL BACK case
2413                                                  
2414  ***      0      0                           0         if ( $what eq 'TRANSACTION' ) {
2415  ***      0                                  0            push @txns, $self->parse_txn($body);
2416                                                        }
2417                                                        else {
2418  ***      0                                  0            my $lock = {};
2419  ***      0                                  0            $self->apply_rules($lock, $body, 'lock');
2420  ***      0                                  0            push @locks, $lock;
2421                                                        }
2422                                                     }
2423                                                  
2424  ***      0                                  0      my ( $rolled_back ) = $text =~ m/^\*\*\* WE ROLL BACK TRANSACTION \($d\)$/m;
2425  ***      0      0                           0      if ( $rolled_back ) {
2426  ***      0                                  0         $txns[ $rolled_back - 1 ]->{victim} = 1;
2427                                                     }
2428                                                  
2429  ***      0                                  0      return (\@txns, \@locks);
2430                                                  }
2431                                                  
2432                                                  sub parse_txn {
2433  ***      0                    0             0      my ($self, $text) = @_;
2434                                                  
2435  ***      0                                  0      my $txn = {};
2436  ***      0                                  0      $self->apply_rules($txn, $text, 'transaction');
2437                                                  
2438  ***      0                                  0      my ( $thread_line ) = $text =~ m/^(MySQL thread id .*)$/m;
2439  ***      0                                  0      my ( $mysql_thread_id, $query_id, $hostname, $ip, $user, $query_status );
2440                                                  
2441  ***      0      0                           0      if ( $thread_line ) {
2442  ***      0                                  0         ( $mysql_thread_id, $query_id )
2443                                                           = $thread_line =~ m/^MySQL thread id $d, query id $d/m;
2444                                                  
2445  ***      0                                  0         ( $query_status ) = $thread_line =~ m/(Has (?:read|sent) all .*$)/m;
2446  ***      0      0                           0         if ( defined($query_status) ) {
      ***             0                               
2447  ***      0                                  0            $user = 'system user';
2448                                                        }
2449                                                  
2450                                                        elsif ( $thread_line =~ m/query id \d+ / ) {
2451  ***      0                                  0            ( $hostname, $ip ) = $thread_line =~ m/query id \d+(?: ([A-Za-z]\S+))? $i/m;
2452  ***      0      0                           0            if ( defined $ip ) {
2453  ***      0                                  0               ( $user, $query_status ) = $thread_line =~ m/$ip $w(?: (.*))?$/;
2454                                                           }
2455                                                           else { # OK, there wasn't an IP address.
2456  ***      0                                  0               ( $query_status ) = $thread_line =~ m/query id \d+ (.*)$/;
2457  ***      0      0      0                    0               if ( $query_status !~ m/^\w+ing/ && !exists($is_proc_info{$query_status}) ) {
2458  ***      0                                  0                  ( $hostname, $user, $query_status ) = $thread_line
2459                                                                    =~ m/query id \d+(?: ([A-Za-z]\S+))?(?: $w(?: (.*))?)?$/m;
2460                                                              }
2461                                                              else {
2462  ***      0                                  0                  $user = 'system user';
2463                                                              }
2464                                                           }
2465                                                        }
2466                                                     }
2467                                                  
2468  ***      0                                  0      @{$txn}{qw(mysql_thread_id query_id hostname ip user query_status)}
      ***      0                                  0   
2469                                                        = ( $mysql_thread_id, $query_id, $hostname, $ip, $user, $query_status);
2470                                                  
2471  ***      0                                  0      return $txn;
2472                                                  }
2473                                                  
2474                                                  sub _d {
2475  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2476  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2477  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2478                                                          @_;
2479  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2480                                                  }
2481                                                  
2482                                                  1;
2483                                                  
2484                                                  # ###########################################################################
2485                                                  # End InnoDBStatusParser package
2486                                                  # ###########################################################################
2487                                                  
2488                                                  # ###########################################################################
2489                                                  # Transformers package 5266
2490                                                  # ###########################################################################
2491                                                  
2492                                                  package Transformers;
2493                                                  
2494           6                    6            52   use strict;
               6                                269   
               6                                 44   
2495           6                    6           282   use warnings FATAL => 'all';
               6                                 16   
               6                                 35   
2496           6                    6            36   use English qw(-no_match_vars);
               6                                 15   
               6                                 40   
2497           6                    6            78   use Time::Local qw(timegm timelocal);
               6                                 20   
               6                                 67   
2498           6                    6            41   use Digest::MD5 qw(md5_hex);
               6                                 14   
               6                                 41   
2499                                                  
2500  ***      6            50      6            36   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 13   
               6                                 78   
2501                                                  
2502                                                  require Exporter;
2503                                                  our @ISA         = qw(Exporter);
2504                                                  our %EXPORT_TAGS = ();
2505                                                  our @EXPORT      = ();
2506                                                  our @EXPORT_OK   = qw(
2507                                                     micro_t
2508                                                     percentage_of
2509                                                     secs_to_time
2510                                                     shorten
2511                                                     ts
2512                                                     parse_timestamp
2513                                                     unix_timestamp
2514                                                     any_unix_timestamp
2515                                                     make_checksum
2516                                                  );
2517                                                  
2518                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
2519                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
2520                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
2521                                                  
2522                                                  sub micro_t {
2523  ***      0                    0             0      my ( $t, %args ) = @_;
2524  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
2525  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
2526  ***      0                                  0      my $f;
2527                                                  
2528  ***      0      0                           0      $t = 0 if $t < 0;
2529                                                  
2530  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
2531                                                  
2532  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
2533                                                  
2534  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
2535  ***      0                                  0         $f = ($t * 1000000) . 'us';
2536                                                     }
2537                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
2538  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
2539  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
2540                                                     }
2541                                                     elsif ($t >= 1) {
2542  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
2543  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
2544                                                     }
2545                                                     else {
2546  ***      0                                  0         $f = 0;  # $t should = 0 at this point
2547                                                     }
2548                                                  
2549  ***      0                                  0      return $f;
2550                                                  }
2551                                                  
2552                                                  sub percentage_of {
2553  ***      0                    0             0      my ( $is, $of, %args ) = @_;
2554  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
2555  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
2556  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
2557                                                  }
2558                                                  
2559                                                  sub secs_to_time {
2560  ***      0                    0             0      my ( $secs, $fmt ) = @_;
2561  ***      0             0                    0      $secs ||= 0;
2562  ***      0      0                           0      return '00:00' unless $secs;
2563                                                  
2564  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
2565                                                            : $secs >= 3_600  ? 'h'
2566                                                            :                   'm';
2567                                                  
2568                                                     return
2569  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
2570                                                           "%d+%02d:%02d:%02d",
2571                                                           int($secs / 86_400),
2572                                                           int(($secs % 86_400) / 3_600),
2573                                                           int(($secs % 3_600) / 60),
2574                                                           $secs % 60)
2575                                                        : $fmt eq 'h' ? sprintf(
2576                                                           "%02d:%02d:%02d",
2577                                                           int(($secs % 86_400) / 3_600),
2578                                                           int(($secs % 3_600) / 60),
2579                                                           $secs % 60)
2580                                                        : sprintf(
2581                                                           "%02d:%02d",
2582                                                           int(($secs % 3_600) / 60),
2583                                                           $secs % 60);
2584                                                  }
2585                                                  
2586                                                  sub shorten {
2587  ***      0                    0             0      my ( $num, %args ) = @_;
2588  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
2589  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
2590  ***      0                                  0      my $n = 0;
2591  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
2592  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
2593  ***      0                                  0         $num /= $d;
2594  ***      0                                  0         ++$n;
2595                                                     }
2596  ***      0      0      0                    0      return sprintf(
2597                                                        $num =~ m/\./ || $n
2598                                                           ? "%.${p}f%s"
2599                                                           : '%d',
2600                                                        $num, $units[$n]);
2601                                                  }
2602                                                  
2603                                                  sub ts {
2604  ***      0                    0             0      my ( $time, $gmt ) = @_;
2605  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
2606                                                        = $gmt ? gmtime($time) : localtime($time);
2607  ***      0                                  0      $mon  += 1;
2608  ***      0                                  0      $year += 1900;
2609  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
2610                                                        $year, $mon, $mday, $hour, $min, $sec);
2611  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
2612  ***      0                                  0         $us = sprintf("%.6f", $us);
2613  ***      0                                  0         $us =~ s/^0\././;
2614  ***      0                                  0         $val .= $us;
2615                                                     }
2616  ***      0                                  0      return $val;
2617                                                  }
2618                                                  
2619                                                  sub parse_timestamp {
2620  ***      0                    0             0      my ( $val ) = @_;
2621  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
2622                                                           = $val =~ m/^$mysql_ts$/ )
2623                                                     {
2624  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
2625                                                                       . (defined $f ? '%02.6f' : '%02d'),
2626                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
2627                                                     }
2628  ***      0                                  0      return $val;
2629                                                  }
2630                                                  
2631                                                  sub unix_timestamp {
2632  ***      0                    0             0      my ( $val, $gmt ) = @_;
2633  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
2634  ***      0      0                           0         $val = $gmt
2635                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
2636                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
2637  ***      0      0                           0         if ( defined $us ) {
2638  ***      0                                  0            $us = sprintf('%.6f', $us);
2639  ***      0                                  0            $us =~ s/^0\././;
2640  ***      0                                  0            $val .= $us;
2641                                                        }
2642                                                     }
2643  ***      0                                  0      return $val;
2644                                                  }
2645                                                  
2646                                                  sub any_unix_timestamp {
2647  ***      0                    0             0      my ( $val, $callback ) = @_;
2648                                                  
2649  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
2650  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
2651                                                           : $suffix eq 'm' ? $n * 60       # Minutes
2652                                                           : $suffix eq 'h' ? $n * 3600     # Hours
2653                                                           : $suffix eq 'd' ? $n * 86400    # Days
2654                                                           :                  $n;           # default: Seconds
2655  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
2656  ***      0                                  0         return time - $n;
2657                                                     }
2658                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
2659  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
2660  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2661  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
2662                                                     }
2663                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
2664  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
2665  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2666  ***      0                                  0         return unix_timestamp($val);
2667                                                     }
2668                                                     else {
2669  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
2670  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
2671                                                     }
2672                                                  
2673  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
2674  ***      0                                  0      return;
2675                                                  }
2676                                                  
2677                                                  sub make_checksum {
2678  ***      0                    0             0      my ( $val ) = @_;
2679  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
2680  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
2681  ***      0                                  0      return $checksum;
2682                                                  }
2683                                                  
2684                                                  sub _d {
2685  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2686  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2687  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2688                                                          @_;
2689  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2690                                                  }
2691                                                  
2692                                                  1;
2693                                                  
2694                                                  # ###########################################################################
2695                                                  # End Transformers package
2696                                                  # ###########################################################################
2697                                                  
2698                                                  # ###########################################################################
2699                                                  # ProcesslistAggregator package 5266
2700                                                  # ###########################################################################
2701                                                  package ProcesslistAggregator;
2702                                                  
2703           6                    6            44   use strict;
               6                                 15   
               6                                 33   
2704           6                    6            37   use warnings FATAL => 'all';
               6                                 15   
               6                                 39   
2705           6                    6            44   use English qw(-no_match_vars);
               6                                 17   
               6                                 40   
2706                                                  
2707  ***      6            50      6            44   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 14   
               6                                 86   
2708                                                  
2709                                                  sub new {
2710  ***      0                    0             0      my ( $class, %args ) = @_;
2711  ***      0             0                    0      my $self = {
2712                                                        undef_val => $args{undef_val} || 'NULL',
2713                                                     };
2714  ***      0                                  0      return bless $self, $class;
2715                                                  }
2716                                                  
2717                                                  sub aggregate {
2718  ***      0                    0             0      my ( $self, $proclist ) = @_;
2719  ***      0                                  0      my $aggregate = {};
2720  ***      0                                  0      foreach my $proc ( @{$proclist} ) {
      ***      0                                  0   
2721  ***      0                                  0         foreach my $field ( keys %{ $proc } ) {
      ***      0                                  0   
2722  ***      0      0                           0            next if $field eq 'Id';
2723  ***      0      0                           0            next if $field eq 'Info';
2724  ***      0      0                           0            next if $field eq 'Time';
2725                                                  
2726  ***      0                                  0            my $val  = $proc->{ $field };
2727  ***      0      0                           0               $val  = $self->{undef_val} if !defined $val;
2728  ***      0      0      0                    0               $val  = lc $val if ( $field eq 'Command' || $field eq 'State' );
2729  ***      0      0                           0               $val  =~ s/:.*// if $field eq 'Host';
2730                                                  
2731  ***      0                                  0            my $time = $proc->{Time};
2732  ***      0      0                           0               $time = 0 if $time eq 'NULL';
2733                                                  
2734  ***      0                                  0            $field = lc $field;
2735                                                  
2736  ***      0                                  0            $aggregate->{ $field }->{ $val }->{time}  += $time;
2737  ***      0                                  0            $aggregate->{ $field }->{ $val }->{count} += 1;
2738                                                        }
2739                                                     }
2740  ***      0                                  0      return $aggregate;
2741                                                  }
2742                                                  
2743                                                  sub _d {
2744  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2745  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2746  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2747                                                          @_;
2748  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2749                                                  }
2750                                                  
2751                                                  1;
2752                                                  
2753                                                  # ###########################################################################
2754                                                  # End ProcesslistAggregator package
2755                                                  # ###########################################################################
2756                                                  
2757                                                  # ###########################################################################
2758                                                  # WatchStatus package 5401
2759                                                  # ###########################################################################
2760                                                  package WatchStatus;
2761                                                  
2762           6                    6            41   use strict;
               6                                 15   
               6                                 33   
2763           6                    6            35   use warnings FATAL => 'all';
               6                                 14   
               6                                 36   
2764                                                  
2765           6                    6            43   use English qw(-no_match_vars);
               6                                 12   
               6                                 37   
2766                                                  
2767  ***      6            50      6            36   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 75   
2768                                                  
2769                                                  sub new {
2770  ***      0                    0             0      my ( $class, %args ) = @_;
2771  ***      0                                  0      foreach my $arg ( qw(params) ) {
2772  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2773                                                     }
2774                                                  
2775  ***      0                                  0      my $check_sub;
2776  ***      0                                  0      my %extra_args;
2777  ***      0                                  0      eval {
2778  ***      0                                  0         ($check_sub, %extra_args) = parse_params($args{params});
2779                                                     };
2780  ***      0      0                           0      die "Error parsing parameters $args{params}: $EVAL_ERROR" if $EVAL_ERROR;
2781                                                  
2782  ***      0                                  0      my $self = {
2783                                                        %extra_args,
2784                                                        %args,
2785                                                        check_sub => $check_sub,
2786                                                        callbacks => {
2787                                                           show_status        => \&_show_status,
2788                                                           show_innodb_status => \&_show_innodb_status,
2789                                                           show_slave_status  => \&_show_slave_status,
2790                                                        },
2791                                                     };
2792  ***      0                                  0      return bless $self, $class;
2793                                                  }
2794                                                  
2795                                                  sub parse_params {
2796  ***      0                    0             0      my ( $params ) = @_;
2797  ***      0                                  0      my ( $stats, $var, $cmp, $thresh ) = split(':', $params);
2798  ***      0                                  0      $stats = lc $stats;
2799  ***      0                                  0      MKDEBUG && _d('Parsed', $params, 'as', $stats, $var, $cmp, $thresh);
2800  ***      0      0                           0      die "No stats parameter; expected status, innodb or slave" unless $stats;
2801  ***      0      0      0                    0      die "Invalid stats: $stats; expected status, innodb or slave"
      ***                    0                        
2802                                                        unless $stats eq 'status' || $stats eq 'innodb' || $stats eq 'slave';
2803  ***      0      0                           0      die "No var parameter" unless $var;
2804  ***      0      0                           0      die "No comparison parameter; expected >, < or =" unless $cmp;
2805  ***      0      0      0                    0      die "Invalid comparison: $cmp; expected >, < or ="
      ***                    0                        
2806                                                        unless $cmp eq '<' || $cmp eq '>' || $cmp eq '=';
2807  ***      0      0                           0      die "No threshold value (N)" unless defined $thresh;
2808                                                  
2809  ***      0      0                           0      $cmp = '==' if $cmp eq '=';
2810                                                  
2811  ***      0                                  0      my @lines = (
2812                                                        'sub {',
2813                                                        '   my ( $self, %args ) = @_;',
2814                                                        "   my \$val = \$self->_get_val_from_$stats('$var', %args);",
2815                                                        "   MKDEBUG && _d('Current $stats:$var =', \$val);",
2816                                                        "   \$self->_save_last_check(\$val, '$cmp', '$thresh');",
2817                                                        "   return \$val $cmp $thresh ? 1 : 0;",
2818                                                        '}',
2819                                                     );
2820                                                  
2821  ***      0                                  0      my $code = join("\n", @lines);
2822  ***      0                                  0      MKDEBUG && _d('OK sub:', @lines);
2823  ***      0      0                           0      my $check_sub = eval $code
2824                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
2825                                                  
2826  ***      0                                  0      my %args;
2827  ***      0                                  0      my $innodb_status_parser;
2828  ***      0      0                           0      if ( $stats eq 'innodb' ) {
2829  ***      0                                  0         eval {
2830  ***      0                                  0            $innodb_status_parser = new InnoDBStatusParser();
2831                                                        };
2832  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d('Cannot create an InnoDBStatusParser object:', $EVAL_ERROR);
2833  ***      0                                  0         $args{InnoDBStatusParser} = $innodb_status_parser;
2834                                                     }
2835                                                  
2836  ***      0                                  0      return $check_sub, %args;
2837                                                  }
2838                                                  
2839                                                  sub uses_dbh {
2840  ***      0                    0             0      return 1;
2841                                                  }
2842                                                  
2843                                                  sub set_dbh {
2844  ***      0                    0             0      my ( $self, $dbh ) = @_;
2845  ***      0                                  0      $self->{dbh} = $dbh;
2846                                                  }
2847                                                  
2848                                                  sub set_callbacks {
2849  ***      0                    0             0      my ( $self, %callbacks ) = @_;
2850  ***      0                                  0      foreach my $func ( keys %callbacks ) {
2851  ***      0      0                           0         die "Callback $func does not exist"
2852                                                           unless exists $self->{callbacks}->{$func};
2853  ***      0                                  0         $self->{callbacks}->{$func} = $callbacks{$func};
2854  ***      0                                  0         MKDEBUG && _d('Set new callback for', $func);
2855                                                     }
2856  ***      0                                  0      return;
2857                                                  }
2858                                                  
2859                                                  sub check {
2860  ***      0                    0             0      my ( $self, %args ) = @_;
2861  ***      0                                  0      return $self->{check_sub}->(@_);
2862                                                  }
2863                                                  
2864                                                  sub _show_status {
2865  ***      0                    0             0      my ( $dbh, $var, %args ) = @_;
2866  ***      0      0                           0      if ( $var ) {
2867  ***      0                                  0         my (undef, $val)
2868                                                           = $dbh->selectrow_array("SHOW /*!50002 GLOBAL*/ STATUS LIKE '$var'");
2869  ***      0                                  0         return $val;
2870                                                     }
2871                                                     else {
2872  ***      0                                  0         return $dbh->selectall_hashref("SHOW /*!50002 GLOBAL*/ STATUS", 'Variable_name');
2873                                                     }
2874                                                  }
2875                                                  
2876                                                  sub _get_val_from_status {
2877  ***      0                    0             0      my ( $self, $var, %args ) = @_;
2878  ***      0      0                           0      die "I need a var argument" unless $var;
2879  ***      0                                  0      return $self->{callbacks}->{show_status}->($self->{dbh}, $var, %args);
2880                                                  
2881                                                  
2882                                                  }
2883                                                  
2884                                                  sub _show_innodb_status {
2885  ***      0                    0             0      my ( $dbh, %args ) = @_;
2886  ***      0                                  0      my @text = $dbh->selectrow_array("SHOW INNODB STATUS");
2887  ***      0             0                    0      return $text[2] || $text[0];
2888                                                  }
2889                                                  
2890                                                  sub _get_val_from_innodb {
2891  ***      0                    0             0      my ( $self, $var, %args ) = @_;
2892  ***      0      0                           0      die "I need a var argument" unless $var;
2893  ***      0                                  0      my $is = $self->{InnoDBStatusParser};
2894  ***      0      0                           0      die "No InnoDBStatusParser object" unless $is;
2895                                                  
2896  ***      0                                  0      my $status_text = $self->{callbacks}->{show_innodb_status}->($self->{dbh}, %args);
2897  ***      0                                  0      my $idb_stats   = $is->parse($status_text);
2898                                                  
2899  ***      0                                  0      my $val = 0;
2900                                                     SECTION:
2901  ***      0                                  0      foreach my $section ( keys %$idb_stats ) {
2902  ***      0      0                           0         next SECTION unless exists $idb_stats->{$section}->[0]->{$var};
2903  ***      0                                  0         MKDEBUG && _d('Found', $var, 'in section', $section);
2904                                                  
2905  ***      0                                  0         foreach my $vars ( @{$idb_stats->{$section}} ) {
      ***      0                                  0   
2906  ***      0                                  0            MKDEBUG && _d($var, '=', $vars->{$var});
2907  ***      0      0      0                    0            $val = $vars->{$var} && $vars->{$var} > $val ? $vars->{$var} : $val;
2908                                                        }
2909  ***      0                                  0         MKDEBUG && _d('Highest', $var, '=', $val);
2910  ***      0                                  0         last SECTION;
2911                                                     }
2912  ***      0                                  0      return $val;
2913                                                  }
2914                                                  
2915                                                  sub _show_slave_status {
2916  ***      0                    0             0      my ( $dbh, $var, %args ) = @_;
2917  ***      0                                  0      return $dbh->selectrow_hashref("SHOW SLAVE STATUS")->{$var};
2918                                                  }
2919                                                  
2920                                                  sub _get_val_from_slave {
2921  ***      0                    0             0      my ( $self, $var, %args ) = @_;
2922  ***      0      0                           0      die "I need a var argument" unless $var;
2923  ***      0                                  0      return $self->{callbacks}->{show_slave_status}->($self->{dbh}, $var, %args);
2924                                                  }
2925                                                  
2926                                                  sub trevorprice {
2927  ***      0                    0             0      my ( $self, $dbh, %args ) = @_;
2928  ***      0      0                           0      die "I need a dbh argument" unless $dbh;
2929  ***      0             0                    0      my $num_samples = $args{samples} || 100;
2930  ***      0                                  0      my $num_running = 0;
2931  ***      0                                  0      my $start = time();
2932  ***      0                                  0      my (undef, $status1)
2933                                                        = $dbh->selectrow_array('SHOW /*!50002 GLOBAL*/ STATUS LIKE "Questions"');
2934  ***      0                                  0      for ( 1 .. $num_samples ) {
2935  ***      0                                  0         my $pl = $dbh->selectall_arrayref('SHOW PROCESSLIST', { Slice => {} });
2936  ***      0             0                    0         my $running = grep { ($_->{Command} || '') eq 'Query' } @$pl;
      ***      0                                  0   
2937  ***      0                                  0         $num_running += $running - 1;
2938                                                     }
2939  ***      0                                  0      my $time = time() - $start;
2940  ***      0      0                           0      return 0 unless $time;
2941  ***      0                                  0      my (undef, $status2)
2942                                                        = $dbh->selectrow_array('SHOW /*!50002 GLOBAL*/ STATUS LIKE "Questions"');
2943  ***      0                                  0      my $qps = ($status2 - $status1) / $time;
2944  ***      0      0                           0      return 0 unless $qps;
2945  ***      0                                  0      return ($num_running / $num_samples) / $qps;
2946                                                  }
2947                                                  
2948                                                  sub _save_last_check {
2949  ***      0                    0             0      my ( $self, @args ) = @_;
2950  ***      0                                  0      $self->{last_check} = [ @args ];
2951  ***      0                                  0      return;
2952                                                  }
2953                                                  
2954                                                  sub get_last_check {
2955  ***      0                    0             0      my ( $self ) = @_;
2956  ***      0                                  0      return @{ $self->{last_check} };
      ***      0                                  0   
2957                                                  }
2958                                                  
2959                                                  sub _d {
2960  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2961  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2962  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2963                                                          @_;
2964  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2965                                                  }
2966                                                  
2967                                                  1;
2968                                                  
2969                                                  # ###########################################################################
2970                                                  # End WatchStatus package
2971                                                  # ###########################################################################
2972                                                  
2973                                                  # ###########################################################################
2974                                                  # WatchProcesslist package 5266
2975                                                  # ###########################################################################
2976                                                  package WatchProcesslist;
2977                                                  
2978           6                    6            44   use strict;
               6                                 18   
               6                                 31   
2979           6                    6            34   use warnings FATAL => 'all';
               6                                 20   
               6                                 45   
2980                                                  
2981           6                    6            38   use English qw(-no_match_vars);
               6                                 14   
               6                                 29   
2982                                                  
2983  ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                 90   
2984                                                  
2985                                                  sub new {
2986  ***      0                    0             0      my ( $class, %args ) = @_;
2987  ***      0                                  0      foreach my $arg ( qw(params) ) {
2988  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2989                                                     }
2990                                                  
2991  ***      0                                  0      my $check_sub;
2992  ***      0                                  0      my %extra_args;
2993  ***      0                                  0      eval {
2994  ***      0                                  0         ($check_sub, %extra_args) = parse_params($args{params});
2995                                                     };
2996  ***      0      0                           0      die "Error parsing parameters $args{params}: $EVAL_ERROR" if $EVAL_ERROR;
2997                                                  
2998  ***      0                                  0      my $self = {
2999                                                        %extra_args,
3000                                                        %args,
3001                                                        check_sub => $check_sub,
3002                                                        callbacks => {
3003                                                           show_processlist => \&_show_processlist,
3004                                                        },
3005                                                     };
3006  ***      0                                  0      return bless $self, $class;
3007                                                  }
3008                                                  
3009                                                  sub parse_params {
3010  ***      0                    0             0      my ( $params ) = @_;
3011  ***      0                                  0      my ( $col, $val, $agg, $cmp, $thresh ) = split(':', $params);
3012  ***      0                                  0      $col = lc $col;
3013  ***      0                                  0      $val = lc $val;
3014  ***      0                                  0      $agg = lc $agg;
3015  ***      0                                  0      MKDEBUG && _d('Parsed', $params, 'as', $col, $val, $agg, $cmp, $thresh);
3016  ***      0      0                           0      die "No column parameter; expected db, user, host, state or command"
3017                                                        unless $col;
3018  ***      0      0      0                    0      die "Invalid column: $col; expected db, user, host, state or command"
      ***                    0                        
      ***                    0                        
      ***                    0                        
3019                                                        unless $col eq 'db' || $col eq 'user' || $col eq 'host' 
3020                                                            || $col eq 'state' || $col eq 'command';
3021  ***      0      0                           0      die "No value parameter" unless $val;
3022  ***      0      0                           0      die "No aggregate; expected count or time" unless $agg;
3023  ***      0      0      0                    0      die "Invalid aggregate: $agg; expected count or time"
3024                                                        unless $agg eq 'count' || $agg eq 'time';
3025  ***      0      0                           0      die "No comparison parameter; expected >, < or =" unless $cmp;
3026  ***      0      0      0                    0      die "Invalid comparison: $cmp; expected >, < or ="
      ***                    0                        
3027                                                        unless $cmp eq '<' || $cmp eq '>' || $cmp eq '=';
3028  ***      0      0                           0      die "No threshold value (N)" unless defined $thresh;
3029                                                  
3030  ***      0      0                           0      $cmp = '==' if $cmp eq '=';
3031                                                  
3032  ***      0                                  0      my @lines = (
3033                                                        'sub {',
3034                                                        '   my ( $self, %args ) = @_;',
3035                                                        '   my $proc = $self->{callbacks}->{show_processlist}->($self->{dbh});',
3036                                                        '   if ( !$proc ) {',
3037                                                        "      \$self->_save_last_check('processlist was empty');",
3038                                                        '      return 0;',
3039                                                        '   }',
3040                                                        '   my $apl  = $self->{ProcesslistAggregator}->aggregate($proc);',
3041                                                        "   my \$val = \$apl->{$col}->{'$val'}->{$agg} || 0;",
3042                                                        "   MKDEBUG && _d('Current $col $val $agg =', \$val);",
3043                                                        "   \$self->_save_last_check(\$val, '$cmp', '$thresh');",
3044                                                        "   return \$val $cmp $thresh ? 1 : 0;",
3045                                                        '}',
3046                                                     );
3047                                                  
3048  ***      0                                  0      my $code = join("\n", @lines);
3049  ***      0                                  0      MKDEBUG && _d('OK sub:', @lines);
3050  ***      0      0                           0      my $check_sub = eval $code
3051                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
3052                                                  
3053  ***      0                                  0      my %args;
3054  ***      0                                  0      my $pla;
3055  ***      0                                  0      eval {
3056  ***      0                                  0         $pla = new ProcesslistAggregator();
3057                                                     };
3058  ***      0                                  0      MKDEBUG && $EVAL_ERROR && _d('Cannot create a ProcesslistAggregator object:',
3059                                                        $EVAL_ERROR);
3060  ***      0                                  0      $args{ProcesslistAggregator} = $pla;
3061                                                  
3062  ***      0                                  0      return $check_sub, %args;
3063                                                  }
3064                                                  
3065                                                  sub uses_dbh {
3066  ***      0                    0             0      return 1;
3067                                                  }
3068                                                  
3069                                                  sub set_dbh {
3070  ***      0                    0             0      my ( $self, $dbh ) = @_;
3071  ***      0                                  0      $self->{dbh} = $dbh;
3072                                                  }
3073                                                  
3074                                                  sub set_callbacks {
3075  ***      0                    0             0      my ( $self, %callbacks ) = @_;
3076  ***      0                                  0      foreach my $func ( keys %callbacks ) {
3077  ***      0      0                           0         die "Callback $func does not exist"
3078                                                           unless exists $self->{callbacks}->{$func};
3079  ***      0                                  0         $self->{callbacks}->{$func} = $callbacks{$func};
3080  ***      0                                  0         MKDEBUG && _d('Set new callback for', $func);
3081                                                     }
3082  ***      0                                  0      return;
3083                                                  }
3084                                                  
3085                                                  sub check {
3086  ***      0                    0             0      my ( $self, %args ) = @_;
3087  ***      0                                  0      return $self->{check_sub}->(@_);
3088                                                  }
3089                                                  
3090                                                  sub _show_processlist {
3091  ***      0                    0             0      my ( $dbh, %args ) = @_;
3092  ***      0                                  0      return $dbh->selectall_arrayref('SHOW PROCESSLIST', { Slice => {} } );
3093                                                  }
3094                                                  
3095                                                  sub _save_last_check {
3096  ***      0                    0             0      my ( $self, @args ) = @_;
3097  ***      0                                  0      $self->{last_check} = [ @args ];
3098  ***      0                                  0      return;
3099                                                  }
3100                                                  
3101                                                  sub get_last_check {
3102  ***      0                    0             0      my ( $self ) = @_;
3103  ***      0                                  0      return @{ $self->{last_check} };
      ***      0                                  0   
3104                                                  }
3105                                                  
3106                                                  sub _d {
3107  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3108  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3109  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3110                                                          @_;
3111  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3112                                                  }
3113                                                  
3114                                                  1;
3115                                                  
3116                                                  # ###########################################################################
3117                                                  # End WatchProcesslist package
3118                                                  # ###########################################################################
3119                                                  
3120                                                  # ###########################################################################
3121                                                  # WatchServer package 5266
3122                                                  # ###########################################################################
3123                                                  package WatchServer;
3124                                                  
3125           6                    6            80   use strict;
               6                                 16   
               6                                 35   
3126           6                    6            35   use warnings FATAL => 'all';
               6                                 14   
               6                                 28   
3127                                                  
3128           6                    6            35   use English qw(-no_match_vars);
               6                                 17   
               6                                 30   
3129                                                  
3130  ***      6            50      6            37   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 14   
               6                                 81   
3131                                                  
3132                                                  sub new {
3133  ***      0                    0             0      my ( $class, %args ) = @_;
3134  ***      0                                  0      foreach my $arg ( qw(params) ) {
3135  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3136                                                     }
3137                                                  
3138  ***      0                                  0      my $check_sub;
3139  ***      0                                  0      my %extra_args;
3140  ***      0                                  0      eval {
3141  ***      0                                  0         ($check_sub, %extra_args) = parse_params($args{params});
3142                                                     };
3143  ***      0      0                           0      die "Error parsing parameters $args{params}: $EVAL_ERROR" if $EVAL_ERROR;
3144                                                  
3145  ***      0                                  0      my $self = {
3146                                                        %extra_args,
3147                                                        %args,
3148                                                        check_sub => $check_sub,
3149                                                        callbacks => {
3150                                                           uptime => \&_uptime,
3151                                                           vmstat => \&_vmstat,
3152                                                        },
3153                                                     };
3154  ***      0                                  0      return bless $self, $class;
3155                                                  }
3156                                                  
3157                                                  sub parse_params {
3158  ***      0                    0             0      my ( $params ) = @_;
3159  ***      0                                  0      my ( $cmd, $cmd_arg, $cmp, $thresh ) = split(':', $params);
3160  ***      0                                  0      MKDEBUG && _d('Parsed', $params, 'as', $cmd, $cmd_arg, $cmp, $thresh);
3161  ***      0      0                           0      die "No command parameter" unless $cmd;
3162  ***      0      0      0                    0      die "Invalid command: $cmd; expected loadavg or uptime"
3163                                                        unless $cmd eq 'loadavg' || $cmd eq 'vmstat';
3164  ***      0      0                           0      if ( $cmd eq 'loadavg' ) {
      ***             0                               
3165  ***      0      0      0                    0         die "Invalid $cmd argument: $cmd_arg; expected 1, 5 or 15"
      ***                    0                        
3166                                                           unless $cmd_arg eq '1' || $cmd_arg eq '5' || $cmd_arg eq '15';
3167                                                     }
3168                                                     elsif ( $cmd eq 'vmstat' ) {
3169  ***      0                                  0         my @vmstat_args = qw(r b swpd free buff cache si so bi bo in cs us sy id wa);
3170  ***      0                                  0         die "Invalid $cmd argument: $cmd_arg; expected one of "
3171                                                           . join(',', @vmstat_args)
3172  ***      0      0                           0            unless grep { $cmd_arg eq $_ } @vmstat_args;
3173                                                     }
3174  ***      0      0                           0      die "No comparison parameter; expected >, < or =" unless $cmp;
3175  ***      0      0      0                    0      die "Invalid comparison parameter: $cmp; expected >, < or ="
      ***                    0                        
3176                                                        unless $cmp eq '<' || $cmp eq '>' || $cmp eq '=';
3177  ***      0      0                           0      die "No threshold value (N)" unless defined $thresh;
3178                                                  
3179  ***      0      0                           0      $cmp = '==' if $cmp eq '=';
3180                                                  
3181  ***      0                                  0      my @lines = (
3182                                                        'sub {',
3183                                                        '   my ( $self, %args ) = @_;',
3184                                                        "   my \$val = \$self->_get_val_from_$cmd('$cmd_arg', %args);",
3185                                                        "   MKDEBUG && _d('Current $cmd $cmd_arg =', \$val);",
3186                                                        "   \$self->_save_last_check(\$val, '$cmp', '$thresh');",
3187                                                        "   return \$val $cmp $thresh ? 1 : 0;",
3188                                                        '}',
3189                                                     );
3190                                                  
3191  ***      0                                  0      my $code = join("\n", @lines);
3192  ***      0                                  0      MKDEBUG && _d('OK sub:', @lines);
3193  ***      0      0                           0      my $check_sub = eval $code
3194                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
3195                                                  
3196  ***      0                                  0      return $check_sub;
3197                                                  }
3198                                                  
3199                                                  sub uses_dbh {
3200  ***      0                    0             0      return 0;
3201                                                  }
3202                                                  
3203                                                  sub set_dbh {
3204  ***      0                    0             0      return;
3205                                                  }
3206                                                  
3207                                                  sub set_callbacks {
3208  ***      0                    0             0      my ( $self, %callbacks ) = @_;
3209  ***      0                                  0      foreach my $func ( keys %callbacks ) {
3210  ***      0      0                           0         die "Callback $func does not exist"
3211                                                           unless exists $self->{callbacks}->{$func};
3212  ***      0                                  0         $self->{callbacks}->{$func} = $callbacks{$func};
3213  ***      0                                  0         MKDEBUG && _d('Set new callback for', $func);
3214                                                     }
3215  ***      0                                  0      return;
3216                                                  }
3217                                                  
3218                                                  sub check {
3219  ***      0                    0             0      my ( $self, %args ) = @_;
3220  ***      0                                  0      return $self->{check_sub}->(@_);
3221                                                  }
3222                                                  
3223                                                  sub _uptime {
3224  ***      0                    0             0      return `uptime`;
3225                                                  }
3226                                                  
3227                                                  sub _get_val_from_loadavg {
3228  ***      0                    0             0      my ( $self, $cmd_arg, %args ) = @_;
3229  ***      0                                  0      my $uptime = $self->{callbacks}->{uptime}->();
3230  ***      0                                  0      chomp $uptime;
3231  ***      0      0                           0      return 0 unless $uptime;
3232  ***      0                                  0      my @loadavgs = $uptime =~ m/load average:\s+(\S+),\s+(\S+),\s+(\S+)/;
3233  ***      0                                  0      MKDEBUG && _d('Load averages:', @loadavgs);
3234  ***      0      0                           0      my $i = $cmd_arg == 1 ? 0
      ***             0                               
3235                                                           : $cmd_arg == 5 ? 1
3236                                                           :                 2;
3237  ***      0             0                    0      return $loadavgs[$i] || 0;
3238                                                  }
3239                                                  
3240                                                  sub _vmstat {
3241  ***      0                    0             0      return `vmstat`;
3242                                                  }
3243                                                  
3244                                                  sub _parse_vmstat {
3245  ***      0                    0             0      my ( $vmstat_output ) = @_;
3246  ***      0                                  0      MKDEBUG && _d('vmstat output:', $vmstat_output);
3247  ***      0                                  0      my @lines =
3248                                                        map {
3249  ***      0                                  0            my $line = $_;
3250  ***      0                                  0            my @vals = split(/\s+/, $line);
3251  ***      0                                  0            \@vals;
3252                                                        } split(/\n/, $vmstat_output);
3253  ***      0                                  0      my %vmstat;
3254  ***      0                                  0      my $n_vals = scalar @{$lines[1]};
      ***      0                                  0   
3255  ***      0                                  0      for my $i ( 0..$n_vals-1 ) {
3256  ***      0      0                           0         next unless $lines[1]->[$i];
3257  ***      0                                  0         $vmstat{$lines[1]->[$i]} = $lines[-1]->[$i];
3258                                                     }
3259  ***      0                                  0      return \%vmstat;
3260                                                  }
3261                                                  
3262                                                  sub _get_val_from_vmstat {
3263  ***      0                    0             0      my ( $self, $cmd_arg, %args ) = @_;
3264  ***      0                                  0      my $vmstat_output = $self->{callbacks}->{vmstat}->();
3265  ***      0             0                    0      return _parse_vmstat($vmstat_output)->{$cmd_arg} || 0;
3266                                                  }
3267                                                  
3268                                                  sub _save_last_check {
3269  ***      0                    0             0      my ( $self, @args ) = @_;
3270  ***      0                                  0      $self->{last_check} = [ @args ];
3271  ***      0                                  0      return;
3272                                                  }
3273                                                  
3274                                                  sub get_last_check {
3275  ***      0                    0             0      my ( $self ) = @_;
3276  ***      0                                  0      return @{ $self->{last_check} };
      ***      0                                  0   
3277                                                  }
3278                                                  
3279                                                  sub _d {
3280  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3281  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3282  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3283                                                          @_;
3284  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3285                                                  }
3286                                                  
3287                                                  1;
3288                                                  
3289                                                  # ###########################################################################
3290                                                  # End WatchServer package
3291                                                  # ###########################################################################
3292                                                  
3293                                                  # ###########################################################################
3294                                                  # This is a combination of modules and programs in one -- a runnable module.
3295                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
3296                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
3297                                                  #
3298                                                  # Check at the end of this package for the call to main() which actually runs
3299                                                  # the program.
3300                                                  # ###########################################################################
3301                                                  package mk_loadavg;
3302                                                  
3303           6                    6            53   use English qw(-no_match_vars);
               6                                 14   
               6                                 31   
3304           6                    6            42   use IO::File;
               6                                 14   
               6                                 83   
3305           6                    6            39   use POSIX qw(setsid);
               6                                 20   
               6                                 42   
3306           6                    6            83   use sigtrap qw(handler finish untrapped normal-signals);
               6                                 17   
               6                                 46   
3307                                                  
3308                                                  Transformers->import qw(ts);
3309                                                  
3310  ***      6            50      6            41   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 12   
               6                                 94   
3311                                                  
3312                                                  $OUTPUT_AUTOFLUSH = 1;
3313                                                  
3314                                                  my $oktorun = 1;
3315                                                  
3316                                                  $SIG{CHLD} = 'IGNORE';
3317                                                  
3318                                                  sub main {
3319  ***      0                    0             0      @ARGV = @_;  # set global ARGV for this package
3320                                                  
3321                                                     # ########################################################################
3322                                                     # Get configuration information.
3323                                                     # ########################################################################
3324  ***      0                                  0      my $dp = new DSNParser();
3325  ***      0                                  0      my $vp = new VersionParser();
3326  ***      0                                  0      my $o  = new OptionParser(
3327                                                        description => 'watches the load on a MySQL server and takes action '
3328                                                                     . 'if it is too high.',
3329                                                     );
3330  ***      0                                  0      $o->get_specs();
3331  ***      0                                  0      $o->get_opts();
3332                                                  
3333  ***      0                                  0      $dp->prop('set-vars', $o->get('set-vars'));
3334                                                  
3335  ***      0                                  0      $o->usage_or_errors();
3336                                                  
3337                                                     # ########################################################################
3338                                                     # First things first: if --stop was given, create the sentinel file.
3339                                                     # ########################################################################
3340  ***      0      0                           0      if ( $o->get('stop') ) {
3341  ***      0                                  0         my $sentinel = $o->get('sentinel');
3342  ***      0                                  0         MKDEBUG && _d('Creating sentinel file', $sentinel);
3343  ***      0      0                           0         my $file = IO::File->new($sentinel, ">>")
3344                                                           or die "Cannot open $sentinel: $OS_ERROR\n";
3345  ***      0      0                           0         print $file "Remove this file to permit mk-loadavg to run\n"
3346                                                           or die "Cannot write to $sentinel: $OS_ERROR\n";
3347  ***      0      0                           0         close $file
3348                                                           or die "Cannot close $sentinel: $OS_ERROR\n";
3349  ***      0                                  0         print "Successfully created file $sentinel\n";
3350  ***      0                                  0         return 0;
3351                                                     }
3352                                                  
3353                                                     # ########################################################################
3354                                                     # Parse --watch and load the Watch* modules.
3355                                                     # ########################################################################
3356  ***      0                                  0      my @plugins = parse_watch($o->get('watch'));
3357  ***      0                                  0      my @watches;
3358  ***      0                                  0      my $dsn;
3359  ***      0                                  0      my $dbh;
3360  ***      0                                  0      foreach my $plugin ( @plugins ) {
3361  ***      0             0                    0         my $module = "Watch" . ($plugin->[0] || '');
3362  ***      0                                  0         my $params = $plugin->[1];
3363  ***      0                                  0         MKDEBUG && _d('Loading', $module, 'with params', $params);
3364  ***      0                                  0         my $watch;
3365  ***      0                                  0         eval {
3366  ***      0                                  0            $watch = $module->new(
3367                                                              params => $params,
3368                                                           );
3369                                                        };
3370  ***      0      0                           0         die "Failed to load --watch $module: $EVAL_ERROR" if $EVAL_ERROR;
3371                                                  
3372  ***      0      0                           0         if ( $watch->uses_dbh() ) {
3373  ***      0      0                           0            if ( !$dbh ) {
3374  ***      0      0                           0               if ( $o->get('ask-pass') ) {
3375  ***      0                                  0                  $o->set('password', OptionParser::prompt_noecho("Enter password: "));
3376                                                              }
3377  ***      0                                  0               $dsn = $dp->parse_options($o);
3378  ***      0                                  0               $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => 1});
3379  ***      0                                  0               $dbh->{InactiveDestroy}  = 1;         # Don't die on fork().
3380                                                           }
3381  ***      0                                  0            $watch->set_dbh($dbh);
3382                                                        }
3383                                                  
3384                                                        # Set any callbacks.
3385  ***      0      0      0                    0         if ( (my $vmstat = $o->get('vmstat')) && $module eq 'WatchServer' ) {
3386  ***      0                    0             0            $watch->set_callbacks( vmstat => sub { return `$vmstat`; } );
      ***      0                                  0   
3387                                                        }
3388                                                  
3389  ***      0                                  0         push @watches, { name => "$plugin->[0]:$plugin->[1]", module => $watch, };
3390                                                     }
3391                                                  
3392                                                     # In case no watch module used a dbh, set this manually.
3393  ***      0             0                    0      $dsn ||= { h => 'localhost' };
3394                                                  
3395                                                     # Daemonize only after connecting and doing --ask-pass.
3396  ***      0                                  0      my $daemon;
3397  ***      0      0                           0      if ( $o->get('daemonize') ) {
      ***             0                               
3398  ***      0                                  0         $daemon = new Daemon(o=>$o);
3399  ***      0                                  0         $daemon->daemonize();
3400  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
3401                                                     }
3402                                                     elsif ( $o->get('pid') ) {
3403                                                        # We're not daemoninzing, it just handles PID stuff.
3404  ***      0                                  0         $daemon = new Daemon(o=>$o);
3405  ***      0                                  0         $daemon->make_PID_file();
3406                                                     }
3407                                                  
3408  ***      0      0                           0      _log($o, "mk-loadavg started with:\n"
      ***             0                               
3409                                                        . '#  --watch ' . $o->get('watch') . "\n"
3410                                                        . ($o->get('execute-command')
3411                                                              ? '#  --execute-command ' . $o->get('execute-command') . "\n" : '')
3412                                                        . ($o->get('and')
3413                                                              ? '#  --and' . "\n" : '')
3414                                                        . '#  --interval ' . $o->get('interval')
3415                                                     );
3416  ***      0                                  0      watch_server(
3417                                                        dsn => $dsn,
3418                                                        dbh => $dbh,
3419                                                        o   => $o,
3420                                                        dp  => $dp,
3421                                                        vp  => $vp,
3422                                                        watches => \@watches,
3423                                                     );
3424                                                  
3425  ***      0      0                           0      $dp->disconnect($dbh) if $dbh;
3426  ***      0                                  0      return 0;
3427                                                  }
3428                                                  
3429                                                  # ############################################################################
3430                                                  # Subroutines.
3431                                                  # ############################################################################
3432                                                  
3433                                                  sub parse_watch {
3434           1                    1             5      my ( $watch ) = @_;
3435  ***      1     50                           5      return unless $watch;
3436           1                                  8      my @watch_defs = split(/,/, $watch);
3437           3                                 10      my @watches = map {
3438           1                                  4         my $def = $_;
3439           3                                 25         my ($module, $args) = $def =~ m/(\w+):(.+)/;
3440           3                                 14         [ $module, $args ];
3441                                                     } @watch_defs;
3442           1                                 13      return @watches;
3443                                                  }
3444                                                  
3445                                                  sub watch_server {
3446  ***      0                    0                    my ( %args ) = @_;
3447  ***      0                                         foreach my $arg ( qw(dsn o dp vp) ) {
3448  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
3449                                                     }
3450  ***      0                                         my $dbh     = $args{dbh};
3451  ***      0                                         my $dsn     = $args{dsn};
3452  ***      0                                         my $o       = $args{o};
3453  ***      0                                         my $dp      = $args{dp};
3454  ***      0                                         my $vp      = $args{vp};
3455  ***      0                                         my $watches = $args{watches};
3456                                                  
3457  ***      0                                         _log($o, 'Watching server ' . $dp->as_string($dsn));
3458                                                  
3459  ***      0             0                           my $exit_time = time() + ($o->get('run-time') || 0);
3460  ***      0             0                           while ( (!$o->get('run-time') || time() < $exit_time)
      ***                    0                        
      ***                    0                        
3461                                                             && !-f $o->get('sentinel')
3462                                                             && $oktorun ) {
3463                                                  
3464                                                        # If there's a dbh then we're connect to MySQL.  Make sure its
3465                                                        # responding, wait and retry forever it's not.
3466  ***      0      0                                     if ( $dbh ) {
3467  ***      0                                               while ( !$dbh->ping ) {
3468  ***      0                                                  my $wait = $o->get('wait');
3469  ***      0                                                  _log($o, "MySQL not responding; waiting ${wait}s to reconnect");
3470  ***      0                                                  sleep $wait;
3471  ***      0                                                  eval {
3472  ***      0                                                     $dbh = $dp->get_dbh(
3473                                                                    $dp->get_cxn_params($dsn), { AutoCommit => 1 });
3474                                                              };
3475  ***      0      0                                           if ( $EVAL_ERROR ) {
3476  ***      0                                                     _log($o, 'Could not reconnect to MySQL server:', $EVAL_ERROR);
3477                                                              }
3478                                                              else {
3479  ***      0                                                     _log($o, 'Reconnected to MySQL');
3480  ***      0                                                     $dbh->{InactiveDestroy} = 1;  # Don't die on fork().
3481  ***      0                                                     next;  # Redo the oktorun checks after waiting.
3482                                                              }
3483                                                           }
3484                                                        }
3485                                                  
3486  ***      0                                            my $n_failed = 0;
3487  ***      0                                            foreach my $watch ( @$watches ) {
3488  ***      0                                               my $watch_name = $watch->{name};
3489  ***      0                                               _log($o, "Checking $watch_name");
3490                                                  
3491  ***      0                                               $watch->{module}->set_dbh($dbh);  # Reset this in case we reconnected.
3492                                                  
3493  ***      0                                               my $check_status = $watch->{module}->check();  # Check it!
3494  ***      0      0                                        my @last_test    = map {
3495  ***      0                                                  defined $_ ? $_ : 'undef'  # Shouldn't happen, but just in case.
3496                                                           } $watch->{module}->get_last_check();
3497  ***      0      0                                        if ( $check_status == 0 ) {
3498                                                              # The check is not triggered.
3499  ***      0                                                  _log($o, "PASS: @last_test");
3500                                                           }
3501                                                           else {
3502                                                              # The check is triggered.
3503  ***      0                                                  $n_failed++;
3504  ***      0                                                  _log($o, "FAIL: @last_test");
3505  ***      0      0                                           if ( !$o->get('and') ) {
3506  ***      0      0                                              if ( my $cmd = $o->get('execute-command') ) {
3507  ***      0                                                        _log($o, "Executing $cmd");
3508  ***      0                                                        exec_cmd($cmd);
3509                                                                 }
3510                                                              }
3511                                                           }
3512                                                        }
3513                                                  
3514  ***      0      0      0                              if ( $o->get('and') && $n_failed == scalar @$watches ) {
3515  ***      0                                               _log($o, 'All watches failed');
3516  ***      0      0                                        if ( my $cmd = $o->get('execute-command') ) {
3517  ***      0                                                  _d("Executing $cmd");
3518  ***      0                                                  exec_cmd($cmd);
3519                                                           }
3520                                                        }
3521                                                  
3522  ***      0                                            _log($o, 'Sleeping ' . $o->get('interval'));
3523  ***      0                                            sleep $o->get('interval');
3524                                                     }
3525                                                  
3526  ***      0                                         _log($o, 'Done watching server ' . $dp->as_string($dsn));
3527                                                  
3528  ***      0                                         return;
3529                                                  }
3530                                                  
3531                                                  # Forks and detaches from parent to execute the given command;
3532                                                  # does not block parent.
3533                                                  sub exec_cmd {
3534  ***      0                    0                    my ( $cmd ) = @_;
3535  ***      0                                         MKDEBUG && _d('exec cmd:', $cmd);
3536  ***      0      0                                  return unless $cmd;
3537                                                  
3538  ***      0                                         my $pid = fork();
3539  ***      0      0                                  if ( $pid ) {
3540                                                        # parent
3541  ***      0                                            MKDEBUG && _d('child pid:', $pid);
3542  ***      0                                            return $pid;
3543                                                     }
3544                                                  
3545                                                     # child
3546  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
3547  ***      0                                         open STDOUT, '>/dev/null';
3548  ***      0                                         open STDERR, '>&STDOUT';
3549  ***      0                                         open STDIN,  '/dev/null';
3550  ***      0                                         exec $cmd;
3551  ***      0                                         exit;
3552                                                  }
3553                                                  
3554                                                  # Catches signals for exiting gracefully.
3555                                                  sub finish {
3556  ***      0                    0                    my ($signal) = @_;
3557  ***      0                                         my $msg = "Exiting on SIG$signal.";
3558  ***      0                                         print STDERR "$msg\n";
3559  ***      0                                         _log(undef, $msg); 
3560  ***      0                                         $oktorun = 0;
3561  ***      0                                         return 1;
3562                                                  }
3563                                                  
3564                                                  sub _log {
3565  ***      0                    0                    my ( $o, $msg ) = @_;
3566                                                     # If called by finish(), we won't have an $o.
3567  ***      0      0      0                           print '# ', ts(time), " $msg\n" if !$o || ($o && $o->get('verbose'));
      ***                    0                        
3568  ***      0                                         MKDEBUG && _d($msg);
3569  ***      0                                         return;
3570                                                  }
3571                                                  
3572                                                  sub _d {
3573  ***      0                    0                    my ($package, undef, $line) = caller 0;
3574  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3575  ***      0                                              map { defined $_ ? $_ : 'undef' }
3576                                                          @_;
3577  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3578                                                  }
3579                                                  
3580                                                  # ############################################################################
3581                                                  # Run the program.
3582                                                  # ############################################################################
3583                                                  if ( !caller ) { exit main(@ARGV); }
3584                                                  
3585                                                  1; # Because this is a module as well as a script.
3586                                                  
3587                                                  # ############################################################################
3588                                                  # Documentation.
3589                                                  # ############################################################################
3590                                                  
3591                                                  =pod
3592                                                  
3593                                                  =head1 NAME
3594                                                  
3595                                                  mk-loadavg - Watch MySQL load and take action when it gets too high.
3596                                                  
3597                                                  =head1 SYNOPSIS
3598                                                  
3599                                                  Execute my_script.sh when Threads_running exceeds 10:
3600                                                  
3601                                                    mk-loadavg --watch "Status:status:Threads_running:>:10" \
3602                                                      --execute-command my_script.sh
3603                                                  
3604                                                  =head1 RISKS
3605                                                  
3606                                                  The following section is included to inform users about the potential risks,
3607                                                  whether known or unknown, of using this tool.  The two main categories of risks
3608                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
3609                                                  tools) and those created by bugs.
3610                                                  
3611                                                  mk-loadavg merely reads and prints information by default, and is very low-risk.
3612                                                  The L<"--execute-command"> option can execute user-specified commands.
3613                                                  
3614                                                  At the time of this release, we know of no bugs that could cause serious harm to
3615                                                  users.
3616                                                  
3617                                                  The authoritative source for updated information is always the online issue
3618                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
3619                                                  see a list of such issues at the following URL:
3620                                                  L<http://www.maatkit.org/bugs/mk-loadavg>.
3621                                                  
3622                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
3623                                                  
3624                                                  =head1 DESCRIPTION
3625                                                  
3626                                                  mk-loadavg watches a MySQL server and takes action when a defined threshold
3627                                                  is exceeded.  One or more items can be watched including MySQL status values
3628                                                  from SHOW STATUS, SHOW INNODB STATUS and SHOW SLAVE STATUS, the three system
3629                                                  load averages from C<uptime>, and values from C<vmstat>.  Watched items and
3630                                                  their threshold values are specified by L<"--watch">.  Every item is checked
3631                                                  at intervals (see L<"--interval">).  By default, if any one item's check returns
3632                                                  true (i.e. its threshold is exceeded), then L<"--execute-command"> is executed.
3633                                                  Specifying L<"--and"> requires that every item has exceeded its threshold before
3634                                                  L<"--execute-command"> is executed.
3635                                                  
3636                                                  =head1 OUTPUT
3637                                                  
3638                                                  If you specify L<"--verbose">, mk-loadavg prints information to STDOUT
3639                                                  about each check for each watched item.  Else, it prints nothing and
3640                                                  L<"--execute-command"> (if specified) is responsible for logging any
3641                                                  information you want.
3642                                                  
3643                                                  =head1 EXIT STATUS
3644                                                  
3645                                                  Successful exit status is 0.  Any other value represents the exit status of
3646                                                  the Perl process itself, or of the last forked process that exited if there
3647                                                  were multiple servers to monitor.
3648                                                  
3649                                                  =head1 OPTIONS
3650                                                  
3651                                                  =over
3652                                                  
3653                                                  =item --and
3654                                                  
3655                                                  group: Action
3656                                                  
3657                                                  Trigger the actions only when all L<"--watch"> items exceed their thresholds.
3658                                                  
3659                                                  The default is to trigger the actions when any one of the watched items
3660                                                  exceeds its threshold.  This option requires that all watched items exceed
3661                                                  their thresholds before any action is triggered.
3662                                                  
3663                                                  =item --ask-pass
3664                                                  
3665                                                  Prompt for a password when connecting to MySQL.
3666                                                  
3667                                                  =item --charset
3668                                                  
3669                                                  short form: -A; type: string
3670                                                  
3671                                                  Default character set.  If the value is utf8, sets Perl's binmode on
3672                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
3673                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
3674                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
3675                                                  
3676                                                  =item --config
3677                                                  
3678                                                  type: Array
3679                                                  
3680                                                  Read this comma-separated list of config files; if specified, this must be the
3681                                                  first option on the command line.
3682                                                  
3683                                                  =item --daemonize
3684                                                  
3685                                                  Fork to the background and detach from the shell.  POSIX
3686                                                  operating systems only.
3687                                                  
3688                                                  =item --database
3689                                                  
3690                                                  short form: -D; type: string
3691                                                  
3692                                                  Database to use.
3693                                                  
3694                                                  =item --defaults-file
3695                                                  
3696                                                  short form: -F; type: string
3697                                                  
3698                                                  Only read mysql options from the given file.  You must give an absolute
3699                                                  pathname.
3700                                                  
3701                                                  =item --execute-command
3702                                                  
3703                                                  type: string; group: Action
3704                                                  
3705                                                  Execute this command when watched items exceed their threshold values
3706                                                  
3707                                                  This command will be executed every time a L<"--watch"> item (or all items if
3708                                                  L<"--and"> is specified) exceeds its threshold.  For example, if you specify
3709                                                  C<--watch "Server:vmstat:swpd:>:0">, then this command will be executed
3710                                                  when the server begins to swap and it will be executed again at each
3711                                                  L<"--interval"> so long as the server is still swapping.
3712                                                  
3713                                                  After the command is executed, mk-loadavg has no control over it, so it is
3714                                                  responsible for its own info gathering, logging, interval, etc.  Since the
3715                                                  command is spawned from mk-loadavg, its STDOUT, STDERR and STDIN are closed
3716                                                  so it doesn't interfere with mk-loadavg.  Therefore, the command must redirect
3717                                                  its output to files or some other destination.  For example, if you
3718                                                  specify C<--execute-command 'echo Hello'>, you will not see "Hello" printed
3719                                                  anywhere (neither to screen nor L<"--log">) because STDOUT is closed for
3720                                                  the command.
3721                                                  
3722                                                  No information from mk-loadavg is passed to the command.
3723                                                  
3724                                                  See also L<"--and">.
3725                                                  
3726                                                  =item --help
3727                                                  
3728                                                  Show help and exit.
3729                                                  
3730                                                  =item --host
3731                                                  
3732                                                  short form: -h; type: string
3733                                                  
3734                                                  Connect to host.
3735                                                  
3736                                                  =item --interval
3737                                                  
3738                                                  type: time; default: 60s; group: Watch
3739                                                  
3740                                                  How long to sleep between each check.
3741                                                  
3742                                                  =item --log
3743                                                  
3744                                                  type: string
3745                                                  
3746                                                  Print all output to this file when daemonized.
3747                                                  
3748                                                  Output from L<"--execute-command"> is not printed to this file.
3749                                                  
3750                                                  =item --password
3751                                                  
3752                                                  short form: -p; type: string
3753                                                  
3754                                                  Password to use when connecting.
3755                                                  
3756                                                  =item --pid
3757                                                  
3758                                                  type: string
3759                                                  
3760                                                  Create the given PID file when daemonized.  The file contains the process
3761                                                  ID of the daemonized instance.  The PID file is removed when the
3762                                                  daemonized instance exits.  The program checks for the existence of the
3763                                                  PID file when starting; if it exists and the process with the matching PID
3764                                                  exists, the program exits.
3765                                                  
3766                                                  =item --port
3767                                                  
3768                                                  short form: -P; type: int
3769                                                  
3770                                                  Port number to use for connection.
3771                                                  
3772                                                  =item --run-time
3773                                                  
3774                                                  type: time
3775                                                  
3776                                                  Time to run before exiting.
3777                                                  
3778                                                  Causes C<mk-loadavg> to stop after the specified time has elapsed.
3779                                                  Optional suffix: s=seconds, m=minutes, h=hours, d=days; if no suffix, s is used.
3780                                                  
3781                                                  =item --sentinel
3782                                                  
3783                                                  type: string; default: /tmp/mk-loadavg-sentinel
3784                                                  
3785                                                  Exit if this file exists.
3786                                                  
3787                                                  =item --set-vars
3788                                                  
3789                                                  type: string; default: wait_timeout=10000
3790                                                  
3791                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
3792                                                  will be appended to SET and executed.
3793                                                  
3794                                                  =item --socket
3795                                                  
3796                                                  short form: -S; type: string
3797                                                  
3798                                                  Socket file to use for connection.
3799                                                  
3800                                                  =item --stop
3801                                                  
3802                                                  Stop running instances by creating the L<"--sentinel"> file.
3803                                                  
3804                                                  =item --user
3805                                                  
3806                                                  short form: -u; type: string
3807                                                  
3808                                                  User for login if not current user.
3809                                                  
3810                                                  =item --verbose
3811                                                  
3812                                                  short form: -v
3813                                                  
3814                                                  Print information to STDOUT about what is being done.
3815                                                  
3816                                                  This can be used as a heartbeat to see that mk-loadavg is still
3817                                                  properly watching all its values.  If L<"--log"> is specified, this information
3818                                                  will be printed to that file instead.
3819                                                  
3820                                                  =item --version
3821                                                  
3822                                                  Show version and exit.
3823                                                  
3824                                                  =item --vmstat
3825                                                  
3826                                                  type: string; default: vmstat 1 2; group: Watch
3827                                                  
3828                                                  vmstat command for L<"--watch"> Server:vmstat:...
3829                                                  
3830                                                  The vmstat output should look like:
3831                                                  
3832                                                   procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
3833                                                   r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
3834                                                   0  0      0 590380 143756 571852    0    0     6     9  228  340  4  1 94  1
3835                                                   0  0      0 590400 143764 571852    0    0     0    28  751  818  4  2 90  3
3836                                                  
3837                                                  The second line from the top needs to be column headers for subsequent lines.
3838                                                  Values are taken from the last line.
3839                                                  
3840                                                  The default, C<vmstat 1 2>,  gets current values.  Running just C<vmstat>
3841                                                  would get average values since last reboot.
3842                                                  
3843                                                  =item --wait
3844                                                  
3845                                                  type: time; default: 60s
3846                                                  
3847                                                  Wait this long to reconnect to MySQL.
3848                                                  
3849                                                  If the MySQL server goes away between L<"--interval"> checks, mk-loadavg
3850                                                  will attempt to reconnect to MySQL forever, sleeping this amount of time
3851                                                  in between attempts.
3852                                                  
3853                                                  =item --watch
3854                                                  
3855                                                  type: string; group: Watch
3856                                                  
3857                                                  A comma-separated list of watched items and their thresholds (required).
3858                                                  
3859                                                  Each watched item is string of arguments separated by colons (like arg:arg).
3860                                                  Each argument defines the watch item: what particular value is watched and how
3861                                                  to compare the current value to a threshold value (N).  Multiple watched
3862                                                  items can be given by separating them with a comma, and the same watched
3863                                                  item can be given multiple times (but, of course, it only makes sense to
3864                                                  do this if the comparison and/or threshold values are differnt).
3865                                                  
3866                                                  The first argument is the most important and is case-sensitive.  It
3867                                                  defines the module responsible for watching the value.  For example,
3868                                                  
3869                                                    --watch Status:...
3870                                                  
3871                                                  causes the WatchStatus module to be loaded.  The second and subsequent
3872                                                  arguments are passed to the WatchStatus module which parses them.  Each
3873                                                  watch module requires different arguments.  The watch modules included
3874                                                  in mk-loadavg and what arguments they require are listed below.
3875                                                  
3876                                                  This is a common error when specifying L<"--watch"> on the commnad line:
3877                                                  
3878                                                     mk-loadavg --watch Server:vmstat:swpd:>:0
3879                                                  
3880                                                     Failed to load --watch WatchServer: Error parsing parameters vmstat:swpd:: No comparison parameter; expected >, < or = at ./mk-loadavg line 3100.
3881                                                  
3882                                                  The L<"--watch"> values need to be quoted:
3883                                                  
3884                                                     mk-loadavg --watch "Server:vmstat:swpd:>:0"
3885                                                  
3886                                                  =over
3887                                                  
3888                                                  =item Status
3889                                                  
3890                                                  Watch SHOW STATUS, SHOW INNODB STATUS, and SHOW SLAVE STATUS values.
3891                                                  The value argument is case-sensitive.
3892                                                  
3893                                                    --watch Status:[status|innodb|slave]:value:[><=]:N
3894                                                  
3895                                                  Examples:
3896                                                  
3897                                                    --watch "Status:status:Threads_connected:>:16"
3898                                                    --watch "Status:innodb:Innodb_buffer_pool_hit_rate:<:0.98"
3899                                                    --watch "Status:slave:Seconds_behind_master:>:300"
3900                                                  
3901                                                  You can easily see what values are available for SHOW STATUS and SHOW SLAVE
3902                                                  STATUS, but the values for SHOW INNODB STATUS are not apparent.  Some common
3903                                                  values are:
3904                                                  
3905                                                    Innodb_buffer_pool_hit_rate
3906                                                    Innodb_buffer_pool_pages_created_sec
3907                                                    Innodb_buffer_pool_pages_dirty
3908                                                    Innodb_buffer_pool_pages_read_sec
3909                                                    Innodb_buffer_pool_pages_written_sec
3910                                                    Innodb_buffer_pool_pending_data_writes
3911                                                    Innodb_buffer_pool_pending_dirty_writes
3912                                                    Innodb_buffer_pool_pending_fsyncs
3913                                                    Innodb_buffer_pool_pending_reads
3914                                                    Innodb_buffer_pool_pending_single_writes
3915                                                    Innodb_common_memory_allocated
3916                                                    Innodb_data_fsyncs_sec
3917                                                    Innodb_data_pending_fsyncs
3918                                                    Innodb_data_pending_preads
3919                                                    Innodb_data_pending_pwrites
3920                                                    Innodb_data_reads_sec
3921                                                    Innodb_data_writes_sec
3922                                                    Innodb_insert_buffer_pending_reads
3923                                                    Innodb_rows_read_sec
3924                                                    Innodb_rows_updated_sec
3925                                                    lock_wait_time
3926                                                    mysql_tables_locked
3927                                                    mysql_tables_used
3928                                                    row_locks
3929                                                    io_avg_wait
3930                                                    io_wait
3931                                                    max_io_wait
3932                                                  
3933                                                  Several of those values can appear multiple times in the SHOW INNODB STATUS
3934                                                  output.  The value used for comparison is always the higest value.  So the
3935                                                  value for io_wait is the highest io_wait value for all the IO threads.
3936                                                  
3937                                                  =item Processlist
3938                                                  
3939                                                  Watch aggregated SHOW PROCESSLIST values.
3940                                                  
3941                                                     --watch Processlist:[db|user|host|state|command]:value:[count|time]:[><=]:N
3942                                                  
3943                                                  Examples:
3944                                                  
3945                                                    --watch "Processlist:state:Locked:count:>:5"
3946                                                    --watch "Processlist:command:Query:time:<:1"
3947                                                  
3948                                                  =item Server
3949                                                  
3950                                                  Watch server values.
3951                                                  
3952                                                     --watch Server:loadavg:[1|5|15]:[><=]:N
3953                                                     --watch Server:vmstat:[r|b|swpd|free|buff|cache|si|so|bi|bo|in|cs|us|sy|id|wa]:[><=]:N
3954                                                  
3955                                                  Examples:
3956                                                  
3957                                                    --watch "Server:loadavg:5:>:4.00"
3958                                                    --watch "Server:vmstat:swpd:>:0"
3959                                                    --watch "Server:vmstat:free:=:0"
3960                                                  
3961                                                  See L<"--vmstat">.
3962                                                  
3963                                                  =back
3964                                                  
3965                                                  =back
3966                                                  
3967                                                  =head1 DOWNLOADING
3968                                                  
3969                                                  You can download Maatkit from Google Code at
3970                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
3971                                                  easily with a command like the following:
3972                                                  
3973                                                     wget http://www.maatkit.org/get/toolname
3974                                                     or
3975                                                     wget http://www.maatkit.org/trunk/toolname
3976                                                  
3977                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
3978                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
3979                                                  needed.  The first URL gets the latest released version of the tool, and the
3980                                                  second gets the latest trunk code from Subversion.
3981                                                  
3982                                                  =head1 ENVIRONMENT
3983                                                  
3984                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
3985                                                  the Maatkit tools:
3986                                                  
3987                                                     MKDEBUG=1 mk-....
3988                                                  
3989                                                  =head1 SYSTEM REQUIREMENTS
3990                                                  
3991                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
3992                                                  installed in any reasonably new version of Perl.
3993                                                  
3994                                                  =head1 BUGS
3995                                                  
3996                                                  For a list of known bugs see L<http://www.maatkit.org/bugs/mk-loadavg>.
3997                                                  
3998                                                  Please use Google Code Issues and Groups to report bugs or request support:
3999                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
4000                                                  discuss Maatkit.
4001                                                  
4002                                                  Please include the complete command-line used to reproduce the problem you are
4003                                                  seeing, the version of all MySQL servers involved, the complete output of the
4004                                                  tool when run with L<"--version">, and if possible, debugging output produced by
4005                                                  running with the C<MKDEBUG=1> environment variable.
4006                                                  
4007                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
4008                                                  
4009                                                  This program is copyright 2008-@CURRENTYEAR@ Baron Schwartz.
4010                                                  Feedback and improvements are welcome.
4011                                                  
4012                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
4013                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
4014                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
4015                                                  
4016                                                  This program is free software; you can redistribute it and/or modify it under
4017                                                  the terms of the GNU General Public License as published by the Free Software
4018                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
4019                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
4020                                                  licenses.
4021                                                  
4022                                                  You should have received a copy of the GNU General Public License along with
4023                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
4024                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
4025                                                  
4026                                                  =head1 AUTHOR
4027                                                  
4028                                                  Baron Schwartz, Daniel Nichter
4029                                                  
4030                                                  =head1 ABOUT MAATKIT
4031                                                  
4032                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
4033                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
4034                                                  code contributors.  Both are employed by Percona.  Financial support for
4035                                                  Maatkit development is primarily provided by Percona and its clients. 
4036                                                  
4037                                                  =head1 VERSION
4038                                                  
4039                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5460 $.
4040                                                  
4041                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
58    ***      0      0      0   unless $args{$arg}
64    ***      0      0      0   exists $args{'strict'} ? :
107   ***      0      0      0   unless open my $fh, '<', $file
127   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
132   ***      0      0      0   if $para =~ /^=over/
140   ***      0      0      0   unless $para
143   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
150   ***      0      0      0   if ($para =~ /: /) { }
154   ***      0      0      0   unless $attributes{$attrib}
158   ***      0      0      0   if ($attribs{'short form'})
174   ***      0      0      0   if $para =~ /^=item/
176   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
181   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
193   ***      0      0      0   unless $para
196   ***      0      0      0   if ($para =~ /^=head1/)
200   ***      0      0      0   if $para =~ /^=item --/
204   ***      0      0      0   unless @specs
215   ***      0      0      0   if (ref $opt) { }
220   ***      0      0      0   if (not $long)
225   ***      0      0      0   if exists $$self{'opts'}{$long}
228   ***      0      0      0   if (length $long == 1)
233   ***      0      0      0   if ($short) { }
234   ***      0      0      0   if exists $$self{'short_opts'}{$short}
243   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
244   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
245   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
257   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
262   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
264   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
265   ***      0      0      0   defined $def ? :
269   ***      0      0      0   if ($long eq 'config')
273   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
286   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
291   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
296   ***      0      0      0   if ($opt =~ /default to/)
301   ***      0      0      0   if ($opt =~ /restricted to option groups/)
311   ***      0      0      0   unless $rule_ok
328   ***      0      0      0   unless exists $$self{'opts'}{$long}
352   ***      0      0      0   unless exists $$self{'opts'}{$long}
372   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
377   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
392   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
401   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
405   ***      0      0      0   if ($self->has('config'))
411   ***      0      0      0   if ($EVAL_ERROR)
412   ***      0      0      0   $self->got('config') ? :
427   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
430   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
431   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
437   ***      0      0      0   if (@ARGV and $$self{'strict'})
443   ***      0      0      0   if (@set > 1)
454   ***      0      0      0   if (@set == 0)
464   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
465   ***      0      0      0   if (exists $$self{'disables'}{$long})
472   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
484   ***      0      0      0   if $restricted_opt eq $long
485   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
490   ***      0      0      0   if (@restricted_opts)
492   ***      0      0      0   if (@restricted_opts == 1) { }
521   ***      0      0      0   unless $opt and $$opt{'type'}
524   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
527   ***      0      0      0   if (not $suffix)
533   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
534   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
549   ***      0      0      0   if ($from_key)
560   ***      0      0      0   if (defined $num) { }
561   ***      0      0      0   if ($factor)
588   ***      0      0      0   length $opt == 1 ? :
589   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
596   ***      0      0      0   length $opt == 1 ? :
597   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
604   ***      0      0      0   length $opt == 1 ? :
605   ***      0      0      0   defined $long ? :
610   ***      0      0      0   length $opt == 1 ? :
611   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
645   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
646   ***      0      0      0   unless print $self->print_usage
650   ***      0      0      0   unless print $self->print_errors
659   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
668   ***      0      0      0   unless $$self{'got_opts'}
671   ***      0      0      0   $$_{'is_negatable'} ? :
675   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
691   ***      0      0      0   $group eq 'default' ? :
697   ***      0      0      0   $$opt{'is_negatable'} ? :
700   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
709   ***      0      0      0   if ($short) { }
718   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
722   ***      0      0      0   if ($$self{'dp'})
730   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
742   ***      0      0      0   if ref $_[0] eq 'OptionParser'
745   ***      0      0      0   unless print $prompt
753   ***      0      0      0   unless print "\n"
756   ***      0      0      0   if ($EVAL_ERROR)
778   ***      0      0      0   unless open my $fh, '<', $filename
786   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
789   ***      0      0      0   if ($line eq '--')
794   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
812   ***      0      0      0   unless open my $fh, '<', $file
816   ***      0      0      0   unless $para =~ /^=pod$/m
820   ***      0      0      0   unless $para =~ /$regex/
825   ***      0      0      0   unless close $fh
839   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
854   ***      0      0      0   defined $_ ? :
892   ***      0      0      0   if (not $$self{$dbh})
896   ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
903   ***      0      0      0   defined $_ ? :
989   ***     50      0     15   if (@_ > 2)
998   ***     50      0      5   if (not $dsn)
1010  ***     50     20      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1022  ***     50      0     40   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1028         100     20     20   if (not defined $final_props{$key})
1035  ***     50      0     20   unless exists $opts{$key}
1038  ***     50      0      5   if (my $required = $self->prop('required'))
1040  ***      0      0      0   unless $final_props{$key}
1049  ***      0      0      0   unless ref $o eq 'OptionParser'
1052  ***      0      0      0   if $o->has($_)
1062  ***      0      0      0   unless ref $dsn
1063  ***      0      0      0   $_ eq 'p' ? :
1064  ***      0      0      0   if defined $$dsn{$_}
1077  ***      0      0      0   $opts{$key}{'copy'} ? :
1091  ***     50      0      5   if ($driver eq 'Pg') { }
1123  ***     50      0      5   $cxn_string =~ /charset=utf8/ ? :
1132  ***     50      0      5   if (not $have_dbi)
1151  ***     50      5      0   if ($cxn_string =~ /mysql/i)
1159  ***     50      0      5   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1164  ***      0      0      0   if ($charset eq 'utf8') { }
1165  ***      0      0      0   unless binmode STDOUT, ':utf8'
1169  ***      0      0      0   unless binmode STDOUT
1173  ***     50      0      5   if ($self->prop('set-vars'))
1180  ***     50      0      5   if (not $dbh and $EVAL_ERROR)
1182  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1195  ***      0      0      0   if (not $tries)
1217  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1234  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1244  ***      0      0      0   unless $dsn_1
1245  ***      0      0      0   unless $dsn_2
1249  ***      0      0      0   if ($args{'overwrite'}) { }
1250  ***      0      0      0   defined $$dsn_1{$key} ? :
1253  ***      0      0      0   defined $$dsn_2{$key} ? :
1262  ***      0      0      0   defined $_ ? :
1291  ***      0      0      0   unless $args{$arg}
1294  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1310  ***      0      0      0   unless defined(my $pid = fork)
1311  ***      0      0      0   if ($pid)
1318  ***      0      0      0   unless POSIX::setsid()
1319  ***      0      0      0   unless chdir '/'
1325  ***      0      0      0   if (-t STDIN)
1327  ***      0      0      0   unless open STDIN, '/dev/null'
1331  ***      0      0      0   if ($$self{'log_file'}) { }
1333  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1337  ***      0      0      0   unless open STDERR, '>&STDOUT'
1341  ***      0      0      0   if (-t STDOUT)
1343  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1346  ***      0      0      0   if (-t STDERR)
1348  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1359  ***      0      0      0   $self ? :
1361  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1364  ***      0      0      0   if $EVAL_ERROR
1366  ***      0      0      0   if ($pid) { }
1368  ***      0      0      0   if ($pid_is_alive) { }
1390  ***      0      0      0   if (exists $$self{'child'})
1402  ***      0      0      0   if (not $PID_file)
1409  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1411  ***      0      0      0   unless print $PID_FH $PID
1413  ***      0      0      0   unless close $PID_FH
1422  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1423  ***      0      0      0   unless unlink $$self{'PID_file'}
1435  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1441  ***      0      0      0   defined $_ ? :
2331  ***      0      0      0   unless defined $section_text
2335  ***      0      0      0   if ($innodb_sections{'LATEST DETECTED DEADLOCK'})
2339  ***      0      0      0   if ($innodb_sections{'INSERT BUFFER AND ADAPTIVE HASH INDEX'})
2350  ***      0      0      0   if ($innodb_sections{'TRANSACTIONS'})
2365  ***      0      0      0   if ($innodb_sections{'FILE I/O'})
2375  ***      0      0      0   if ($innodb_sections{'SEMAPHORES'})
2391  ***      0      0      0   unless my $rules = $parse_rules_for{$rulename}
2411  ***      0      0      0   unless my($num, $what) = $header =~ /^\($d\) (.*):$/
2414  ***      0      0      0   if ($what eq 'TRANSACTION') { }
2425  ***      0      0      0   if ($rolled_back)
2441  ***      0      0      0   if ($thread_line)
2446  ***      0      0      0   if (defined $query_status) { }
      ***      0      0      0   elsif ($thread_line =~ /query id \d+ /) { }
2452  ***      0      0      0   if (defined $ip) { }
2457  ***      0      0      0   if (not $query_status =~ /^\w+ing/ and not exists $is_proc_info{$query_status}) { }
2476  ***      0      0      0   defined $_ ? :
2524  ***      0      0      0   defined $args{'p_ms'} ? :
2525  ***      0      0      0   defined $args{'p_s'} ? :
2528  ***      0      0      0   if $t < 0
2530  ***      0      0      0   if $t =~ /e/
2534  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
2555  ***      0      0      0   $p ? :
2562  ***      0      0      0   unless $secs
2564  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
2569  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
2588  ***      0      0      0   defined $args{'p'} ? :
2589  ***      0      0      0   defined $args{'d'} ? :
2596  ***      0      0      0   $num =~ /\./ || $n ? :
2605  ***      0      0      0   $gmt ? :
2611  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
2621  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
2624  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
2633  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
2634  ***      0      0      0   $gmt ? :
2637  ***      0      0      0   if (defined $us)
2649  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
2650  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
2660  ***      0      0      0   unless $hms
2665  ***      0      0      0   unless $hms
2670  ***      0      0      0   if $callback and ref $callback eq 'CODE'
2686  ***      0      0      0   defined $_ ? :
2722  ***      0      0      0   if $field eq 'Id'
2723  ***      0      0      0   if $field eq 'Info'
2724  ***      0      0      0   if $field eq 'Time'
2727  ***      0      0      0   if not defined $val
2728  ***      0      0      0   if $field eq 'Command' or $field eq 'State'
2729  ***      0      0      0   if $field eq 'Host'
2732  ***      0      0      0   if $time eq 'NULL'
2745  ***      0      0      0   defined $_ ? :
2772  ***      0      0      0   unless $args{$arg}
2780  ***      0      0      0   if $EVAL_ERROR
2800  ***      0      0      0   unless $stats
2801  ***      0      0      0   unless $stats eq 'status' or $stats eq 'innodb' or $stats eq 'slave'
2803  ***      0      0      0   unless $var
2804  ***      0      0      0   unless $cmp
2805  ***      0      0      0   unless $cmp eq '<' or $cmp eq '>' or $cmp eq '='
2807  ***      0      0      0   unless defined $thresh
2809  ***      0      0      0   if $cmp eq '='
2823  ***      0      0      0   unless my $check_sub = eval $code
2828  ***      0      0      0   if ($stats eq 'innodb')
2851  ***      0      0      0   unless exists $$self{'callbacks'}{$func}
2866  ***      0      0      0   if ($var) { }
2878  ***      0      0      0   unless $var
2892  ***      0      0      0   unless $var
2894  ***      0      0      0   unless $is
2902  ***      0      0      0   unless exists $$idb_stats{$section}[0]{$var}
2907  ***      0      0      0   $$vars{$var} && $$vars{$var} > $val ? :
2922  ***      0      0      0   unless $var
2928  ***      0      0      0   unless $dbh
2940  ***      0      0      0   unless $time
2944  ***      0      0      0   unless $qps
2961  ***      0      0      0   defined $_ ? :
2988  ***      0      0      0   unless $args{$arg}
2996  ***      0      0      0   if $EVAL_ERROR
3016  ***      0      0      0   unless $col
3018  ***      0      0      0   unless $col eq 'db' or $col eq 'user' or $col eq 'host' or $col eq 'state' or $col eq 'command'
3021  ***      0      0      0   unless $val
3022  ***      0      0      0   unless $agg
3023  ***      0      0      0   unless $agg eq 'count' or $agg eq 'time'
3025  ***      0      0      0   unless $cmp
3026  ***      0      0      0   unless $cmp eq '<' or $cmp eq '>' or $cmp eq '='
3028  ***      0      0      0   unless defined $thresh
3030  ***      0      0      0   if $cmp eq '='
3050  ***      0      0      0   unless my $check_sub = eval $code
3077  ***      0      0      0   unless exists $$self{'callbacks'}{$func}
3108  ***      0      0      0   defined $_ ? :
3135  ***      0      0      0   unless $args{$arg}
3143  ***      0      0      0   if $EVAL_ERROR
3161  ***      0      0      0   unless $cmd
3162  ***      0      0      0   unless $cmd eq 'loadavg' or $cmd eq 'vmstat'
3164  ***      0      0      0   if ($cmd eq 'loadavg') { }
      ***      0      0      0   elsif ($cmd eq 'vmstat') { }
3165  ***      0      0      0   unless $cmd_arg eq '1' or $cmd_arg eq '5' or $cmd_arg eq '15'
3172  ***      0      0      0   unless grep {$cmd_arg eq $_;} @vmstat_args
3174  ***      0      0      0   unless $cmp
3175  ***      0      0      0   unless $cmp eq '<' or $cmp eq '>' or $cmp eq '='
3177  ***      0      0      0   unless defined $thresh
3179  ***      0      0      0   if $cmp eq '='
3193  ***      0      0      0   unless my $check_sub = eval $code
3210  ***      0      0      0   unless exists $$self{'callbacks'}{$func}
3231  ***      0      0      0   unless $uptime
3234  ***      0      0      0   $cmd_arg == 5 ? :
      ***      0      0      0   $cmd_arg == 1 ? :
3256  ***      0      0      0   unless $lines[1][$i]
3281  ***      0      0      0   defined $_ ? :
3340  ***      0      0      0   if ($o->get('stop'))
3343  ***      0      0      0   unless my $file = 'IO::File'->new($sentinel, '>>')
3345  ***      0      0      0   unless print $file "Remove this file to permit mk-loadavg to run\n"
3347  ***      0      0      0   unless close $file
3370  ***      0      0      0   if $EVAL_ERROR
3372  ***      0      0      0   if ($watch->uses_dbh)
3373  ***      0      0      0   if (not $dbh)
3374  ***      0      0      0   if ($o->get('ask-pass'))
3385  ***      0      0      0   if (my $vmstat = $o->get('vmstat') and $module eq 'WatchServer')
3397  ***      0      0      0   if ($o->get('daemonize')) { }
      ***      0      0      0   elsif ($o->get('pid')) { }
3408  ***      0      0      0   $o->get('execute-command') ? :
      ***      0      0      0   $o->get('and') ? :
3425  ***      0      0      0   if $dbh
3435  ***     50      0      1   unless $watch
3448  ***      0      0      0   unless $args{$arg}
3466  ***      0      0      0   if ($dbh)
3475  ***      0      0      0   if ($EVAL_ERROR) { }
3494  ***      0      0      0   defined $_ ? :
3497  ***      0      0      0   if ($check_status == 0) { }
3505  ***      0      0      0   if (not $o->get('and'))
3506  ***      0      0      0   if (my $cmd = $o->get('execute-command'))
3514  ***      0      0      0   if ($o->get('and') and $n_failed == scalar @$watches)
3516  ***      0      0      0   if (my $cmd = $o->get('execute-command'))
3536  ***      0      0      0   unless $cmd
3539  ***      0      0      0   if ($pid)
3546  ***      0      0      0   unless POSIX::setsid()
3567  ***      0      0      0   if not $o or $o and $o->get('verbose')
3574  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
257   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
262   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
401   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
430   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
437   ***      0      0      0      0   @ARGV and $$self{'strict'}
521   ***      0      0      0      0   $opt and $$opt{'type'}
524   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
589   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
597   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
611   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
700   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
794   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1022  ***     66     20     20      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     40      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1144  ***     66      5      0      5   not $dbh and $tries--
1180  ***     33      5      0      0   not $dbh and $EVAL_ERROR
1361  ***      0      0      0      0   $PID_file and -f $PID_file
1422  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2457  ***      0      0      0      0   not $query_status =~ /^\w+ing/ and not exists $is_proc_info{$query_status}
2534  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
2592  ***      0      0      0      0   $num >= $d and $n < @units - 1
2670  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
2907  ***      0      0      0      0   $$vars{$var} && $$vars{$var} > $val
3385  ***      0      0      0      0   my $vmstat = $o->get('vmstat') and $module eq 'WatchServer'
3460  ***      0      0      0      0   !$o->get('run-time') || time < $exit_time and not -f $o->get('sentinel')
      ***      0      0      0      0   !$o->get('run-time') || time < $exit_time and not -f $o->get('sentinel') and $oktorun
3514  ***      0      0      0      0   $o->get('and') and $n_failed == scalar @$watches
3567  ***      0      0      0      0   $o and $o->get('verbose')

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0      6   $ENV{'MKDEBUG'} || 0
62    ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
64    ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
106   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-loadavg/mk-loadavg'
247   ***      0      0      0   $$opt{'group'} ||= 'default'
529   ***      0      0      0   $s || 's'
538   ***      0      0      0   $prefix || ''
566   ***      0      0      0   $pre || ''
573   ***      0      0      0   $val || ''
576   ***      0      0      0   $val || ''
634   ***      0      0      0   $$self{'description'} || ''
702   ***      0      0      0   $s ||= 's'
728   ***      0      0      0   $$opt{'type'} || ''
876   ***     50      0      6   $ENV{'MKDEBUG'} || 0
932   ***     50      0      6   $ENV{'MKDEBUG'} || 0
1003  ***     50      0      5   $prev ||= {}
1004  ***     50      0      5   $defaults ||= {}
1077  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1090  ***     50      0      5   $self->prop('dbidriver') || ''
1094  ***      0      0      0   $$info{'D'} || ''
1100  ***     50      0      5   $$info{'D'} || ''
1122  ***     50      5      0   $opts ||= {}
1217  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1233  ***      0      0      0   $level ||= 0
1234  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1286  ***     50      0      6   $ENV{'MKDEBUG'} || 0
1464  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2500  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2554  ***      0      0      0   $args{'p'} || 0
2556  ***      0      0      0   $of ||= 1
2561  ***      0      0      0   $secs ||= 0
2707  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2711  ***      0      0      0   $args{'undef_val'} || 'NULL'
2767  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2929  ***      0      0      0   $args{'samples'} || 100
2936  ***      0      0      0   $$_{'Command'} || ''
2983  ***     50      0      6   $ENV{'MKDEBUG'} || 0
3130  ***     50      0      6   $ENV{'MKDEBUG'} || 0
3237  ***      0      0      0   $loadavgs[$i] || 0
3265  ***      0      0      0   _parse_vmstat($vmstat_output)->{$cmd_arg} || 0
3310  ***     50      0      6   $ENV{'MKDEBUG'} || 0
3361  ***      0      0      0   $$plugin[0] || ''
3393  ***      0      0      0   $dsn ||= {'h', 'localhost'}
3459  ***      0      0      0   $o->get('run-time') || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
61    ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
62    ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
524   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1113  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1114  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1115  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1116  ***      0      0      0      0   $$dsn{'u'} ||= $user
1117  ***      0      0      0      0   $$dsn{'D'} ||= $db
1435  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2564  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
2596  ***      0      0      0      0   $num =~ /\./ || $n
2728  ***      0      0      0      0   $field eq 'Command' or $field eq 'State'
2801  ***      0      0      0      0   $stats eq 'status' or $stats eq 'innodb'
      ***      0      0      0      0   $stats eq 'status' or $stats eq 'innodb' or $stats eq 'slave'
2805  ***      0      0      0      0   $cmp eq '<' or $cmp eq '>'
      ***      0      0      0      0   $cmp eq '<' or $cmp eq '>' or $cmp eq '='
2887  ***      0      0      0      0   $text[2] || $text[0]
3018  ***      0      0      0      0   $col eq 'db' or $col eq 'user'
      ***      0      0      0      0   $col eq 'db' or $col eq 'user' or $col eq 'host'
      ***      0      0      0      0   $col eq 'db' or $col eq 'user' or $col eq 'host' or $col eq 'state'
      ***      0      0      0      0   $col eq 'db' or $col eq 'user' or $col eq 'host' or $col eq 'state' or $col eq 'command'
3023  ***      0      0      0      0   $agg eq 'count' or $agg eq 'time'
3026  ***      0      0      0      0   $cmp eq '<' or $cmp eq '>'
      ***      0      0      0      0   $cmp eq '<' or $cmp eq '>' or $cmp eq '='
3162  ***      0      0      0      0   $cmd eq 'loadavg' or $cmd eq 'vmstat'
3165  ***      0      0      0      0   $cmd_arg eq '1' or $cmd_arg eq '5'
      ***      0      0      0      0   $cmd_arg eq '1' or $cmd_arg eq '5' or $cmd_arg eq '15'
3175  ***      0      0      0      0   $cmp eq '<' or $cmp eq '>'
      ***      0      0      0      0   $cmp eq '<' or $cmp eq '>' or $cmp eq '='
3460  ***      0      0      0      0   !$o->get('run-time') || time < $exit_time
3567  ***      0      0      0      0   not $o or $o and $o->get('verbose')


Covered Subroutines
-------------------

Subroutine            Count Location                                           
--------------------- ----- ---------------------------------------------------
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1280
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1281
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1283
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1284
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1286
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1459
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1460
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1462
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1464
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:23  
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:24  
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2494
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2495
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2496
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2497
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2498
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2500
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2703
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2704
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2705
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2707
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2762
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2763
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2765
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2767
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2978
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2979
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2981
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2983
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3125
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3126
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3128
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3130
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3303
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3304
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3305
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3306
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3310
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:35  
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:36  
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:38  
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:39  
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:40  
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:42  
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:871 
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:872 
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:874 
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:876 
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:920 
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:921 
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:922 
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:923 
BEGIN                     6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:932 
get_cxn_params            5 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1087
get_dbh                   5 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1121
new                       4 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:935 
parse                     5 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:997 
parse_watch               1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3434
prop                     15 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:988 

Uncovered Subroutines
---------------------

Subroutine            Count Location                                           
--------------------- ----- ---------------------------------------------------
DESTROY                   0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1434
__ANON__                  0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3386
__ANON__                  0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:425 
_d                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1261
_d                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1440
_d                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2475
_d                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2685
_d                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2744
_d                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2960
_d                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3107
_d                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3280
_d                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3573
_d                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:853 
_d                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:902 
_get_participants         0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:325 
_get_val_from_innodb      0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2891
_get_val_from_loadavg     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3228
_get_val_from_slave       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2921
_get_val_from_status      0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2877
_get_val_from_vmstat      0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3263
_log                      0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3565
_make_PID_file            0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1399
_parse_specs              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:211 
_parse_vmstat             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3245
_pod_to_specs             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:105 
_read_config_file         0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:777 
_remove_PID_file          0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1421
_save_last_check          0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2949
_save_last_check          0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3096
_save_last_check          0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3269
_set_option               0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:371 
_show_innodb_status       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2885
_show_processlist         0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3091
_show_slave_status        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2916
_show_status              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2865
_uptime                   0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3224
_validate_type            0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:520 
_vmstat                   0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3241
aggregate                 0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2718
any_unix_timestamp        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2647
apply_rules               0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2390
as_string                 0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1061
check                     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2860
check                     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3086
check                     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3219
check_PID_file            0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1358
clone                     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:830 
copy                      0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1243
daemonize                 0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1307
descr                     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:633 
disconnect                0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1226
errors                    0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:623 
exec_cmd                  0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3534
fill_in_dsn               0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1109
finish                    0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3556
get                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:587 
get_defaults              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:361 
get_defaults_files        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:100 
get_groups                0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:366 
get_hostname              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1216
get_last_check            0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2955
get_last_check            0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3102
get_last_check            0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3275
get_opts                  0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:388 
get_specs                 0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:93  
got                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:595 
has                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:603 
main                      0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3319
make_PID_file             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1389
make_checksum             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2678
micro_t                   0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2523
new                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1289
new                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2301
new                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2710
new                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2770
new                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2986
new                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3133
new                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:56  
new                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:879 
opts                      0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:337 
parse                     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2306
parse                     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:884 
parse_deadlocks           0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2400
parse_options             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1048
parse_params              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2796
parse_params              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3010
parse_params              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3158
parse_timestamp           0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2620
parse_txn                 0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2433
percentage_of             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2553
print_active_handles      0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1232
print_errors              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:657 
print_usage               0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:667 
prompt                    0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:628 
prompt_noecho             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:742 
read_para_after           0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:811 
save_error                0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:618 
secs_to_time              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2560
set                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:609 
set_callbacks             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2849
set_callbacks             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3075
set_callbacks             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3208
set_dbh                   0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2844
set_dbh                   0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3070
set_dbh                   0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3204
set_defaults              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:349 
short_opts                0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:343 
shorten                   0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2587
trevorprice               0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2927
ts                        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2604
ts_to_time                0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1478
unix_timestamp            0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2632
usage                     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1070
usage_or_errors           0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:644 
uses_dbh                  0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:2840
uses_dbh                  0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3066
uses_dbh                  0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3200
version_ge                0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:891 
watch_server              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:3446


