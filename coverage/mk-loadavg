---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...kit/mk-loadavg/mk-loadavg   44.0   27.5   31.7   58.1    n/a  100.0   39.3
Total                          44.0   27.5   31.7   58.1    n/a  100.0   39.3
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          mk-loadavg.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jul  7 16:34:25 2009
Finish:       Tue Jul  7 16:34:28 2009

/home/daniel/dev/maatkit/mk-loadavg/mk-loadavg

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-loadavg, a program to measure the load on a MySQL server and take
4                                                     # action when it exceeds boundaries.
5                                                     #
6                                                     # This program is copyright 2008-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             1                    1             5   use strict;
               1                                  2   
               1                                135   
24             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  8   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 4071 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # Loadavg package 4088
32                                                    # ###########################################################################
33                                                    package Loadavg;
34                                                    
35             1                    1             6   use strict;
               1                                  3   
               1                                  4   
36             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  4   
37                                                    
38             1                    1             5   use List::Util qw(sum);
               1                                  3   
               1                                 12   
39             1                    1            11   use Time::HiRes qw(time);
               1                                  3   
               1                                  5   
40             1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  9   
41                                                    
42             1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                 10   
43                                                    
44                                                    sub new {
45             1                    1             7      my ( $class ) = @_;
46             1                                 35      return bless {}, $class;
47                                                    }
48                                                    
49                                                    sub trevorprice {
50    ***      0                    0             0      my ( $self, $dbh, %args ) = @_;
51    ***      0      0                           0      die "I need a dbh argument" unless $dbh;
52    ***      0             0                    0      my $num_samples = $args{samples} || 100;
53    ***      0                                  0      my $num_running = 0;
54    ***      0                                  0      my $start = time();
55    ***      0                                  0      my (undef, $status1)
56                                                          = $dbh->selectrow_array('SHOW /*!50002 GLOBAL*/ STATUS LIKE "Questions"');
57    ***      0                                  0      for ( 1 .. $num_samples ) {
58    ***      0                                  0         my $pl = $dbh->selectall_arrayref('SHOW PROCESSLIST', { Slice => {} });
59    ***      0             0                    0         my $running = grep { ($_->{Command} || '') eq 'Query' } @$pl;
      ***      0                                  0   
60    ***      0                                  0         $num_running += $running - 1;
61                                                       }
62    ***      0                                  0      my $time = time() - $start;
63    ***      0      0                           0      return 0 unless $time;
64    ***      0                                  0      my (undef, $status2)
65                                                          = $dbh->selectrow_array('SHOW /*!50002 GLOBAL*/ STATUS LIKE "Questions"');
66    ***      0                                  0      my $qps = ($status2 - $status1) / $time;
67    ***      0      0                           0      return 0 unless $qps;
68    ***      0                                  0      return ($num_running / $num_samples) / $qps;
69                                                    }
70                                                    
71                                                    sub num_locked {
72    ***      0                    0             0      my ( $self, $dbh ) = @_;
73    ***      0      0                           0      die "I need a dbh argument" unless $dbh;
74    ***      0                                  0      my $pl = $dbh->selectall_arrayref('SHOW PROCESSLIST', { Slice => {} });
75    ***      0             0                    0      my $locked = grep { ($_->{State} || '') eq 'Locked' } @$pl;
      ***      0                                  0   
76    ***      0             0                    0      return $locked || 0;
77                                                    }
78                                                    
79                                                    sub loadavg {
80    ***      0                    0             0      my ( $self ) = @_;
81    ***      0                                  0      my $str = `uptime`;
82    ***      0                                  0      chomp $str;
83    ***      0      0                           0      return 0 unless $str;
84    ***      0                                  0      my ( $one ) = $str =~ m/load average:\s+(\S[^,]*),/;
85    ***      0             0                    0      return $one || 0;
86                                                    }
87                                                    
88                                                    sub slave_lag {
89    ***      0                    0             0      my ( $self, $dbh ) = @_;
90    ***      0      0                           0      die "I need a dbh argument" unless $dbh;
91    ***      0                                  0      my $sl = $dbh->selectall_arrayref('SHOW SLAVE STATUS', { Slice => {} });
92    ***      0      0                           0      if ( $sl ) {
93    ***      0                                  0         $sl = $sl->[0];
94    ***      0                                  0         my ( $key ) = grep { m/behind_master/i } keys %$sl;
      ***      0                                  0   
95    ***      0      0      0                    0         return $key ? $sl->{$key} || 0 : 0;
96                                                       }
97    ***      0                                  0      return 0;
98                                                    }
99                                                    
100                                                   sub status {
101            1                    1            12      my ( $self, $dbh, %args ) = @_;
102   ***      1     50                          10      die "I need a dbh argument" unless $dbh;
103            1                                  5      my (undef, $status1)
104                                                         = $dbh->selectrow_array("SHOW /*!50002 GLOBAL*/ STATUS LIKE '$args{metric}'");
105   ***      1     50                         412      if ( $args{incstatus} ) {
106            1                             1000215         sleep(1);
107            1                                  8         my (undef, $status2)
108                                                            = $dbh->selectrow_array("SHOW /*!50002 GLOBAL*/ STATUS LIKE '$args{metric}'");
109            1                                538         return $status2 - $status1;
110                                                      }
111                                                      else {
112   ***      0                                  0         return $status1;
113                                                      }
114                                                   }
115                                                   
116                                                   sub _d {
117   ***      0                    0             0      my ($package, undef, $line) = caller 0;
118   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
119   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
120                                                           @_;
121   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
122                                                   }
123                                                   
124                                                   1;
125                                                   
126                                                   # ###########################################################################
127                                                   # End Loadavg package
128                                                   # ###########################################################################
129                                                   
130                                                   # ###########################################################################
131                                                   # OptionParser package 3945
132                                                   # ###########################################################################
133                                                   package OptionParser;
134                                                   
135            1                    1             6   use strict;
               1                                  3   
               1                                  5   
136            1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
137                                                   
138            1                    1            10   use Getopt::Long;
               1                                  2   
               1                                  8   
139            1                    1             7   use List::Util qw(max);
               1                                  3   
               1                                  8   
140            1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
141                                                   
142            1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
143                                                   
144                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
145                                                   
146                                                   my %attributes = (
147                                                      'type'       => 1,
148                                                      'short form' => 1,
149                                                      'group'      => 1,
150                                                      'default'    => 1,
151                                                      'cumulative' => 1,
152                                                      'negatable'  => 1,
153                                                   );
154                                                   
155                                                   sub new {
156            1                    1            15      my ( $class, %args ) = @_;
157            1                                 10      foreach my $arg ( qw(description) ) {
158   ***      1     50                          19         die "I need a $arg argument" unless $args{$arg};
159                                                      }
160            1                                 42      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
161   ***      1            50                   10      $program_name ||= $PROGRAM_NAME;
162                                                   
163   ***      1     50     50                  188      my $self = {
      ***                   50                        
164                                                         description    => $args{description},
165                                                         prompt         => $args{prompt} || '<options>',
166                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
167                                                         dp             => $args{dp}     || undef,
168                                                         program_name   => $program_name,
169                                                         opts           => {},
170                                                         got_opts       => 0,
171                                                         short_opts     => {},
172                                                         defaults       => {},
173                                                         groups         => {},
174                                                         allowed_groups => {},
175                                                         errors         => [],
176                                                         rules          => [],  # desc of rules for --help
177                                                         mutex          => [],  # rule: opts are mutually exclusive
178                                                         atleast1       => [],  # rule: at least one opt is required
179                                                         disables       => {},  # rule: opt disables other opts 
180                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
181                                                         default_files  => [
182                                                            "/etc/maatkit/maatkit.conf",
183                                                            "/etc/maatkit/$program_name.conf",
184                                                            "$ENV{HOME}/.maatkit.conf",
185                                                            "$ENV{HOME}/.$program_name.conf",
186                                                         ],
187                                                      };
188            1                                 41      return bless $self, $class;
189                                                   }
190                                                   
191                                                   sub get_specs {
192            1                    1             7      my ( $self, $file ) = @_;
193            1                                 11      my @specs = $self->_pod_to_specs($file);
194            1                                 42      $self->_parse_specs(@specs);
195            1                                  7      return;
196                                                   }
197                                                   
198                                                   sub get_defaults_files {
199            1                    1             8      my ( $self ) = @_;
200            1                                  4      return @{$self->{default_files}};
               1                                 19   
201                                                   }
202                                                   
203                                                   sub _pod_to_specs {
204            1                    1            12      my ( $self, $file ) = @_;
205   ***      1            50                   10      $file ||= __FILE__;
206   ***      1     50                         192      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
207                                                   
208            1                                 46      my %types = (
209                                                         string => 's', # standard Getopt type
210                                                         'int'  => 'i', # standard Getopt type
211                                                         float  => 'f', # standard Getopt type
212                                                         Hash   => 'H', # hash, formed from a comma-separated list
213                                                         hash   => 'h', # hash as above, but only if a value is given
214                                                         Array  => 'A', # array, similar to Hash
215                                                         array  => 'a', # array, similar to hash
216                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
217                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
218                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
219                                                      );
220            1                                  5      my @specs = ();
221            1                                  5      my @rules = ();
222            1                                  7      my $para;
223                                                   
224            1                                 16      local $INPUT_RECORD_SEPARATOR = '';
225            1                                 44      while ( $para = <$fh> ) {
226          239    100                        2831         next unless $para =~ m/^=head1 OPTIONS/;
227            1                                 12         last;
228                                                      }
229                                                   
230            1                                 12      while ( $para = <$fh> ) {
231   ***      1     50                          13         last if $para =~ m/^=over/;
232   ***      0                                  0         chomp $para;
233   ***      0                                  0         $para =~ s/\s+/ /g;
234   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
235   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
236   ***      0                                  0         push @rules, $para;
237                                                      }
238                                                   
239   ***      1     50                         106      die 'POD has no OPTIONS section' unless $para;
240                                                   
241            1                                  6      do {
242           28    100                         322         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
243           27                                116            chomp $para;
244           27                                 82            MKDEBUG && _d($para);
245           27                                 90            my %attribs;
246                                                   
247           27                                189            $para = <$fh>; # read next paragraph, possibly attributes
248                                                   
249           27    100                         175            if ( $para =~ m/: / ) { # attributes
250           21                                203               $para =~ s/\s+\Z//g;
251           33                                253               %attribs = map {
252           21                                159                     my ( $attrib, $val) = split(/: /, $_);
253   ***     33     50                         245                     die "Unrecognized attribute for --$option: $attrib"
254                                                                        unless $attributes{$attrib};
255           33                                270                     ($attrib, $val);
256                                                                  } split(/; /, $para);
257           21    100                         160               if ( $attribs{'short form'} ) {
258            8                                 62                  $attribs{'short form'} =~ s/-//;
259                                                               }
260           21                                173               $para = <$fh>; # read next paragraph, probably short help desc
261                                                            }
262                                                            else {
263            6                                 19               MKDEBUG && _d('Option has no attributes');
264                                                            }
265                                                   
266           27                                296            $para =~ s/\s+\Z//g;
267           27                                303            $para =~ s/\s+/ /g;
268           27                                258            $para =~ s/$POD_link_re/$1/go;
269                                                   
270           27                                172            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
271           27                                 85            MKDEBUG && _d('Short help:', $para);
272                                                   
273   ***     27     50                         424            die "No description after option spec $option" if $para =~ m/^=item/;
274                                                   
275   ***     27     50                         203            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
276   ***      0                                  0               $option = $base_option;
277   ***      0                                  0               $attribs{'negatable'} = 1;
278                                                            }
279                                                   
280           27    100                         797            push @specs, {
      ***            50                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
281                                                               spec  => $option
282                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
283                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
284                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
285                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
286                                                               desc  => $para
287                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
288                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
289                                                            };
290                                                         }
291           28                                293         while ( $para = <$fh> ) {
292   ***     40     50                         213            last unless $para;
293                                                   
294                                                   
295           40    100                         253            if ( $para =~ m/^=head1/ ) {
296            1                                  5               $para = undef; # Can't 'last' out of a do {} block.
297            1                                  9               last;
298                                                            }
299           39    100                         426            last if $para =~ m/^=item --/;
300                                                         }
301                                                      } while ( $para );
302                                                   
303   ***      1     50                           8      die 'No valid specs in POD OPTIONS' unless @specs;
304                                                   
305            1                                 28      close $fh;
306            1                                  5      return @specs, @rules;
307                                                   }
308                                                   
309                                                   sub _parse_specs {
310            1                    1            13      my ( $self, @specs ) = @_;
311            1                                  6      my %disables; # special rule that requires deferred checking
312                                                   
313            1                                 10      foreach my $opt ( @specs ) {
314   ***     27     50                         147         if ( ref $opt ) { # It's an option spec, not a rule.
315                                                            MKDEBUG && _d('Parsing opt spec:',
316           27                                 85               map { ($_, '=>', $opt->{$_}) } keys %$opt);
317                                                   
318           27                                338            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
319   ***     27     50                         179            if ( !$long ) {
320   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
321                                                            }
322           27                                153            $opt->{long} = $long;
323                                                   
324   ***     27     50                         228            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
325           27                                228            $self->{opts}->{$long} = $opt;
326                                                   
327   ***     27     50                         175            if ( length $long == 1 ) {
328   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
329   ***      0                                  0               $self->{short_opts}->{$long} = $long;
330                                                            }
331                                                   
332           27    100                         138            if ( $short ) {
333   ***      8     50                          57               die "Duplicate short option -$short"
334                                                                  if exists $self->{short_opts}->{$short};
335            8                                 54               $self->{short_opts}->{$short} = $long;
336            8                                 44               $opt->{short} = $short;
337                                                            }
338                                                            else {
339           19                                104               $opt->{short} = undef;
340                                                            }
341                                                   
342   ***     27     50                         234            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
343   ***     27     50                         213            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
344   ***     27     50                         251            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
345                                                   
346   ***     27            50                  172            $opt->{group} ||= 'default';
347           27                                214            $self->{groups}->{ $opt->{group} }->{$long} = 1;
348                                                   
349           27                                407            $opt->{value} = undef;
350           27                                132            $opt->{got}   = 0;
351                                                   
352           27                                253            my ( $type ) = $opt->{spec} =~ m/=(.)/;
353           27                                157            $opt->{type} = $type;
354           27                                 82            MKDEBUG && _d($long, 'type:', $type);
355                                                   
356   ***     27     50     66                  401            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
357   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
358                                                                  . "was given when this OptionParser object was created";
359                                                            }
360                                                   
361           27    100    100                  357            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
362                                                   
363           27    100                         264            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
364   ***      4     50                          27               if ( $opt->{is_negatable} ) {
365   ***      0      0                           0                  $def = $def eq 'yes' ? 1
      ***             0                               
366                                                                       : $def eq 'no'  ? 0
367                                                                       : $def;
368                                                               }
369   ***      4     50                          50               $self->{defaults}->{$long} = defined $def ? $def : 1;
370            4                                 14               MKDEBUG && _d($long, 'default:', $def);
371                                                            }
372                                                   
373           27    100                         164            if ( $long eq 'config' ) {
374            1                                121               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
375                                                            }
376                                                   
377   ***     27     50                         226            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
378   ***      0                                  0               $disables{$long} = $dis;
379   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
380                                                            }
381                                                   
382           27                                213            $self->{opts}->{$long} = $opt;
383                                                         }
384                                                         else { # It's an option rule, not a spec.
385   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
386   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
387   ***      0                                  0            my @participants = $self->_get_participants($opt);
388   ***      0                                  0            my $rule_ok = 0;
389                                                   
390   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
391   ***      0                                  0               $rule_ok = 1;
392   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
393   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
394                                                            }
395   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
396   ***      0                                  0               $rule_ok = 1;
397   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
398   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
399                                                            }
400   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
401   ***      0                                  0               $rule_ok = 1;
402   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
403   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
404                                                            }
405   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
406   ***      0                                  0               $rule_ok = 1;
407   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
408   ***      0                                  0               my @groups = split(',', $groups);
409   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
410   ***      0                                  0                  s/\s+//;
411   ***      0                                  0                  $_ => 1;
412                                                               } @groups;
413                                                            }
414                                                   
415   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
416                                                         }
417                                                      }
418                                                   
419            1                                  9      foreach my $long ( keys %disables ) {
420   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
421   ***      0                                  0         $self->{disables}->{$long} = \@participants;
422   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
423                                                      }
424                                                   
425            1                                  9      return; 
426                                                   }
427                                                   
428                                                   sub _get_participants {
429   ***      0                    0             0      my ( $self, $str ) = @_;
430   ***      0                                  0      my @participants;
431   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
432   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
433                                                            unless exists $self->{opts}->{$long};
434   ***      0                                  0         push @participants, $long;
435                                                      }
436   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
437   ***      0                                  0      return @participants;
438                                                   }
439                                                   
440                                                   sub opts {
441   ***      0                    0             0      my ( $self ) = @_;
442   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
443   ***      0                                  0      return %opts;
444                                                   }
445                                                   
446                                                   sub opt_values {
447   ***      0                    0             0      my ( $self ) = @_;
448   ***      0      0                           0      my %opts = map {
449   ***      0                                  0         my $opt = $self->{opts}->{$_}->{short} ? $self->{opts}->{$_}->{short}
450                                                                 : $_;
451   ***      0                                  0         $opt => $self->{opts}->{$_}->{value}
452   ***      0                                  0      } keys %{$self->{opts}};
453   ***      0                                  0      return %opts;
454                                                   }
455                                                   
456                                                   sub short_opts {
457   ***      0                    0             0      my ( $self ) = @_;
458   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
459   ***      0                                  0      return %short_opts;
460                                                   }
461                                                   
462                                                   sub set_defaults {
463   ***      0                    0             0      my ( $self, %defaults ) = @_;
464   ***      0                                  0      $self->{defaults} = {};
465   ***      0                                  0      foreach my $long ( keys %defaults ) {
466   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
467                                                            unless exists $self->{opts}->{$long};
468   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
469   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
470                                                      }
471   ***      0                                  0      return;
472                                                   }
473                                                   
474                                                   sub get_defaults {
475   ***      0                    0             0      my ( $self ) = @_;
476   ***      0                                  0      return $self->{defaults};
477                                                   }
478                                                   
479                                                   sub get_groups {
480   ***      0                    0             0      my ( $self ) = @_;
481   ***      0                                  0      return $self->{groups};
482                                                   }
483                                                   
484                                                   sub _set_option {
485            6                    6            44      my ( $self, $opt, $val ) = @_;
486   ***      6      0                          19      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
487                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
488                                                               : die "Getopt::Long gave a nonexistent option: $opt";
489                                                   
490            6                                 18      $opt = $self->{opts}->{$long};
491   ***      6     50                          53      if ( $opt->{is_cumulative} ) {
492   ***      0                                  0         $opt->{value}++;
493                                                      }
494                                                      else {
495            6                                 36         $opt->{value} = $val;
496                                                      }
497            6                                 28      $opt->{got} = 1;
498            6                                 34      MKDEBUG && _d('Got option', $long, '=', $val);
499                                                   }
500                                                   
501                                                   sub get_opts {
502            1                    1             7      my ( $self ) = @_; 
503                                                   
504            1                                  5      foreach my $long ( keys %{$self->{opts}} ) {
               1                                 23   
505           27                                168         $self->{opts}->{$long}->{got} = 0;
506   ***     27     50                         378         $self->{opts}->{$long}->{value}
                    100                               
507                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
508                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
509                                                            : undef;
510                                                      }
511            1                                  9      $self->{got_opts} = 0;
512                                                   
513            1                                  7      $self->{errors} = [];
514                                                   
515   ***      1     50     33                   31      if ( @ARGV && $ARGV[0] eq "--config" ) {
516   ***      0                                  0         shift @ARGV;
517   ***      0                                  0         $self->_set_option('config', shift @ARGV);
518                                                      }
519   ***      1     50                          19      if ( $self->has('config') ) {
520            1                                  5         my @extra_args;
521            1                                 12         foreach my $filename ( split(',', $self->get('config')) ) {
522            4                                 25            eval {
523            4                                 44               push @ARGV, $self->_read_config_file($filename);
524                                                            };
525   ***      4     50                          34            if ( $EVAL_ERROR ) {
526   ***      4     50                          28               if ( $self->got('config') ) {
527   ***      0                                  0                  die $EVAL_ERROR;
528                                                               }
529                                                               elsif ( MKDEBUG ) {
530                                                                  _d($EVAL_ERROR);
531                                                               }
532                                                            }
533                                                         }
534            1                                  8         unshift @ARGV, @extra_args;
535                                                      }
536                                                   
537            1                                 20      Getopt::Long::Configure('no_ignore_case', 'bundling');
538                                                      GetOptions(
539           26                    6           348         map    { $_->{spec} => sub { $self->_set_option(@_); } }
               6                                 59   
              27                                188   
540            1                                 12         grep   { $_->{long} ne 'config' } # --config is handled specially above.
541   ***      1     50                           6         values %{$self->{opts}}
542                                                      ) or $self->save_error('Error parsing options');
543                                                   
544   ***      1     50     33                   85      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
545   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
546                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
547                                                               or die "Cannot print: $OS_ERROR";
548   ***      0                                  0         exit 0;
549                                                      }
550                                                   
551   ***      1     50     33                   14      if ( @ARGV && $self->{strict} ) {
552   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
553                                                      }
554                                                   
555            1                                  5      foreach my $mutex ( @{$self->{mutex}} ) {
               1                                 11   
556   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
557   ***      0      0                           0         if ( @set > 1 ) {
558   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
559   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
560                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
561                                                                    . ' are mutually exclusive.';
562   ***      0                                  0            $self->save_error($err);
563                                                         }
564                                                      }
565                                                   
566            1                                  4      foreach my $required ( @{$self->{atleast1}} ) {
               1                                  8   
567   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
568   ***      0      0                           0         if ( @set == 0 ) {
569   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
570   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
571                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
572   ***      0                                  0            $self->save_error("Specify at least one of $err");
573                                                         }
574                                                      }
575                                                   
576            1                                  5      foreach my $long ( keys %{$self->{opts}} ) {
               1                                 15   
577           27                                165         my $opt = $self->{opts}->{$long};
578           27    100                         228         if ( $opt->{got} ) {
      ***            50                               
579   ***      6     50                          46            if ( exists $self->{disables}->{$long} ) {
580   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
581   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
582   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
583                                                                  'because', $long,'disables them');
584                                                            }
585                                                   
586   ***      6     50                          46            if ( exists $self->{allowed_groups}->{$long} ) {
587                                                   
588   ***      0                                  0               my @restricted_groups = grep {
589   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
590   ***      0                                  0               } keys %{$self->{groups}};
591                                                   
592   ***      0                                  0               my @restricted_opts;
593   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
594   ***      0                                  0                  RESTRICTED_OPT:
595   ***      0                                  0                  foreach my $restricted_opt (
596                                                                     keys %{$self->{groups}->{$restricted_group}} )
597                                                                  {
598   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
599   ***      0      0                           0                     push @restricted_opts, $restricted_opt
600                                                                        if $self->{opts}->{$restricted_opt}->{got};
601                                                                  }
602                                                               }
603                                                   
604   ***      0      0                           0               if ( @restricted_opts ) {
605   ***      0                                  0                  my $err;
606   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
607   ***      0                                  0                     $err = "--$restricted_opts[0]";
608                                                                  }
609                                                                  else {
610   ***      0                                  0                     $err = join(', ',
611   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
612   ***      0                                  0                               grep { $_ } 
613                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
614                                                                            )
615                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
616                                                                  }
617   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
618                                                               }
619                                                            }
620                                                   
621                                                         }
622                                                         elsif ( $opt->{is_required} ) { 
623   ***      0                                  0            $self->save_error("Required option --$long must be specified");
624                                                         }
625                                                   
626           27                                163         $self->_validate_type($opt);
627                                                      }
628                                                   
629            1                                 10      $self->{got_opts} = 1;
630            1                                  4      return;
631                                                   }
632                                                   
633                                                   sub _validate_type {
634           27                   27           150      my ( $self, $opt ) = @_;
635   ***     27    100     66                  408      return unless $opt && $opt->{type};
636           21                                111      my $val = $opt->{value};
637                                                   
638           21    100    100                  995      if ( $val && $opt->{type} eq 'm' ) {
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
639            2                                  7         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
640            2                                 34         my ( $num, $suffix ) = $val =~ m/(\d+)([a-z])?$/;
641            2    100                          17         if ( !$suffix ) {
642            1                                  8            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
643   ***      1            50                   15            $suffix = $s || 's';
644            1                                  4            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
645                                                               $opt->{long}, '(value:', $val, ')');
646                                                         }
647   ***      2     50                          30         if ( $suffix =~ m/[smhd]/ ) {
648   ***      2      0                          14            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***            50                               
649                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
650                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
651                                                                 :                  $num * 86400;   # Days
652            2                                 10            $opt->{value} = $val;
653            2                                  9            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
654                                                         }
655                                                         else {
656   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
657                                                         }
658                                                      }
659                                                      elsif ( $val && $opt->{type} eq 'd' ) {
660   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
661   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
662   ***      0                                  0         my $default = {};
663   ***      0      0                           0         if ( $from_key ) {
664   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
665   ***      0                                  0            $default = $self->{dp}->parse(
666                                                               $self->{dp}->as_string($self->{opts}->{$from_key}->{value}) );
667                                                         }
668   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $default);
669                                                      }
670                                                      elsif ( $val && $opt->{type} eq 'z' ) {
671   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
672   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
673   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
674   ***      0      0                           0         if ( defined $num ) {
675   ***      0      0                           0            if ( $factor ) {
676   ***      0                                  0               $num *= $factor_for{$factor};
677   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
678                                                                  'to num', $num, '* factor', $factor);
679                                                            }
680   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
681                                                         }
682                                                         else {
683   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
684                                                         }
685                                                      }
686                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
687   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
688                                                      }
689                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
690            3           100                   58         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
691                                                      }
692                                                      else {
693           16                                 52         MKDEBUG && _d('Nothing to validate for option',
694                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
695                                                      }
696                                                   
697           21                                115      return;
698                                                   }
699                                                   
700                                                   sub get {
701           27                   27           211      my ( $self, $opt ) = @_;
702           27    100                         232      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
703   ***     27     50     33                  444      die "Option $opt does not exist"
704                                                         unless $long && exists $self->{opts}->{$long};
705           27                                484      return $self->{opts}->{$long}->{value};
706                                                   }
707                                                   
708                                                   sub got {
709            4                    4            28      my ( $self, $opt ) = @_;
710   ***      4     50                          30      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
711   ***      4     50     33                   68      die "Option $opt does not exist"
712                                                         unless $long && exists $self->{opts}->{$long};
713            4                                 45      return $self->{opts}->{$long}->{got};
714                                                   }
715                                                   
716                                                   sub has {
717            9                    9            59      my ( $self, $opt ) = @_;
718            9    100                          78      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
719   ***      9     50                         158      return defined $long ? exists $self->{opts}->{$long} : 0;
720                                                   }
721                                                   
722                                                   sub set {
723   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
724   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
725   ***      0      0      0                    0      die "Option $opt does not exist"
726                                                         unless $long && exists $self->{opts}->{$long};
727   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
728   ***      0                                  0      return;
729                                                   }
730                                                   
731                                                   sub save_error {
732   ***      0                    0             0      my ( $self, $error ) = @_;
733   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
734                                                   }
735                                                   
736                                                   sub errors {
737   ***      0                    0             0      my ( $self ) = @_;
738   ***      0                                  0      return $self->{errors};
739                                                   }
740                                                   
741                                                   sub prompt {
742   ***      0                    0             0      my ( $self ) = @_;
743   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
744                                                   }
745                                                   
746                                                   sub descr {
747   ***      0                    0             0      my ( $self ) = @_;
748   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
749                                                                 . "  For more details, please use the --help option, "
750                                                                 . "or try 'perldoc $PROGRAM_NAME' "
751                                                                 . "for complete documentation.";
752   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
753   ***      0                                  0      $descr =~ s/ +$//mg;
754   ***      0                                  0      return $descr;
755                                                   }
756                                                   
757                                                   sub usage_or_errors {
758            1                    1             7      my ( $self ) = @_;
759   ***      1     50                          11      if ( $self->{opts}->{help}->{got} ) {
      ***      1     50                          11   
760   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
761   ***      0                                  0         exit 0;
762                                                      }
763                                                      elsif ( scalar @{$self->{errors}} ) {
764   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
765   ***      0                                  0         exit 0;
766                                                      }
767            1                                  5      return;
768                                                   }
769                                                   
770                                                   sub print_errors {
771   ***      0                    0             0      my ( $self ) = @_;
772   ***      0                                  0      my $usage = $self->prompt() . "\n";
773   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
774   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
775                                                                 . "\n";
776                                                      }
777   ***      0                                  0      return $usage . "\n" . $self->descr();
778                                                   }
779                                                   
780                                                   sub print_usage {
781   ***      0                    0             0      my ( $self ) = @_;
782   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
783   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
784                                                   
785   ***      0      0                           0      my $maxl = max(
786   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
787                                                         @opts);
788                                                   
789   ***      0      0                           0      my $maxs = max(0,
790   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
791   ***      0                                  0         values %{$self->{short_opts}});
792                                                   
793   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
794   ***      0                                  0      my $rcol = 80 - $lcol - 6;
795   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
796                                                   
797   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
798                                                   
799   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
800                                                   
801   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
802   ***      0                                  0      push @groups, 'default';
803                                                   
804   ***      0                                  0      foreach my $group ( reverse @groups ) {
805   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
806   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
807   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
808                                                            grep { $_->{group} eq $group }
809                                                            @opts )
810                                                         {
811   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
812   ***      0                                  0            my $short = $opt->{short};
813   ***      0                                  0            my $desc  = $opt->{desc};
814   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
815   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
816   ***      0             0                    0               $s    ||= 's';
817   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
818   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
819                                                                      . "d=days; if no suffix, $s is used.";
820                                                            }
821   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
822   ***      0                                  0            $desc =~ s/ +$//mg;
823   ***      0      0                           0            if ( $short ) {
824   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
825                                                            }
826                                                            else {
827   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
828                                                            }
829                                                         }
830                                                      }
831                                                   
832   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
833   ***      0                                  0         $usage .= "\nRules:\n\n";
834   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
835                                                      }
836   ***      0      0                           0      if ( $self->{dp} ) {
837   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
838                                                      }
839   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
840   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
841   ***      0                                  0         my $val   = $opt->{value};
842   ***      0             0                    0         my $type  = $opt->{type} || '';
843   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
844   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
845                                                                   : !defined $val             ? '(No value)'
846                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
847                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
848                                                                   : $type =~ m/A|a/           ? join(',', @$val)
849                                                                   :                             $val;
850   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
851                                                      }
852   ***      0                                  0      return $usage;
853                                                   }
854                                                   
855                                                   sub prompt_noecho {
856   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
857   ***      0                                  0      my ( $prompt ) = @_;
858   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
859   ***      0      0                           0      print $prompt
860                                                         or die "Cannot print: $OS_ERROR";
861   ***      0                                  0      my $response;
862   ***      0                                  0      eval {
863   ***      0                                  0         require Term::ReadKey;
864   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
865   ***      0                                  0         chomp($response = <STDIN>);
866   ***      0                                  0         Term::ReadKey::ReadMode('normal');
867   ***      0      0                           0         print "\n"
868                                                            or die "Cannot print: $OS_ERROR";
869                                                      };
870   ***      0      0                           0      if ( $EVAL_ERROR ) {
871   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
872                                                      }
873   ***      0                                  0      return $response;
874                                                   }
875                                                   
876                                                   if ( MKDEBUG ) {
877                                                      print '# ', $^X, ' ', $], "\n";
878                                                      my $uname = `uname -a`;
879                                                      if ( $uname ) {
880                                                         $uname =~ s/\s+/ /g;
881                                                         print "# $uname\n";
882                                                      }
883                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
884                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
885                                                         ($main::SVN_REV || ''), __LINE__);
886                                                      print('# Arguments: ',
887                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
888                                                   }
889                                                   
890                                                   sub _read_config_file {
891            4                    4            30      my ( $self, $filename ) = @_;
892   ***      4     50                          16      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
893   ***      0                                  0      my @args;
894   ***      0                                  0      my $prefix = '--';
895   ***      0                                  0      my $parse  = 1;
896                                                   
897                                                      LINE:
898   ***      0                                  0      while ( my $line = <$fh> ) {
899   ***      0                                  0         chomp $line;
900   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
901   ***      0                                  0         $line =~ s/\s+#.*$//g;
902   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
903   ***      0      0                           0         if ( $line eq '--' ) {
904   ***      0                                  0            $prefix = '';
905   ***      0                                  0            $parse  = 0;
906   ***      0                                  0            next LINE;
907                                                         }
908   ***      0      0      0                    0         if ( $parse
      ***             0                               
909                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
910                                                         ) {
911   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
912                                                         }
913                                                         elsif ( $line =~ m/./ ) {
914   ***      0                                  0            push @args, $line;
915                                                         }
916                                                         else {
917   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
918                                                         }
919                                                      }
920   ***      0                                  0      close $fh;
921   ***      0                                  0      return @args;
922                                                   }
923                                                   
924                                                   sub read_para_after {
925   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
926   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
927   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
928   ***      0                                  0      my $para;
929   ***      0                                  0      while ( $para = <$fh> ) {
930   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
931   ***      0                                  0         last;
932                                                      }
933   ***      0                                  0      while ( $para = <$fh> ) {
934   ***      0      0                           0         next unless $para =~ m/$regex/;
935   ***      0                                  0         last;
936                                                      }
937   ***      0                                  0      $para = <$fh>;
938   ***      0                                  0      chomp($para);
939   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
940   ***      0                                  0      return $para;
941                                                   }
942                                                   
943                                                   sub clone {
944   ***      0                    0             0      my ( $self ) = @_;
945                                                   
946   ***      0                                  0      my %clone = map {
947   ***      0                                  0         my $hashref  = $self->{$_};
948   ***      0                                  0         my $val_copy = {};
949   ***      0                                  0         foreach my $key ( keys %$hashref ) {
950   ***      0                                  0            my $ref = ref $hashref->{$key};
951   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
952   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
953   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
954                                                                              : $hashref->{$key};
955                                                         }
956   ***      0                                  0         $_ => $val_copy;
957                                                      } qw(opts short_opts defaults);
958                                                   
959   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
960   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
961                                                      }
962                                                   
963   ***      0                                  0      return bless \%clone;     
964                                                   }
965                                                   
966                                                   sub _d {
967   ***      0                    0             0      my ($package, undef, $line) = caller 0;
968   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
969   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
970                                                           @_;
971   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
972                                                   }
973                                                   
974                                                   1;
975                                                   
976                                                   # ###########################################################################
977                                                   # End OptionParser package
978                                                   # ###########################################################################
979                                                   
980                                                   # ###########################################################################
981                                                   # VersionParser package 3186
982                                                   # ###########################################################################
983                                                   package VersionParser;
984                                                   
985            1                    1            15   use strict;
               1                                  4   
               1                                 10   
986            1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
987                                                   
988            1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
989                                                   
990            1                    1            12   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                 10   
991                                                   
992                                                   sub new {
993            1                    1             7      my ( $class ) = @_;
994            1                                 69      bless {}, $class;
995                                                   }
996                                                   
997                                                   sub parse {
998   ***      0                    0             0      my ( $self, $str ) = @_;
999   ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1000  ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
1001  ***      0                                  0      return $result;
1002                                                  }
1003                                                  
1004                                                  sub version_ge {
1005  ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
1006  ***      0      0                           0      if ( !$self->{$dbh} ) {
1007  ***      0                                  0         $self->{$dbh} = $self->parse(
1008                                                           $dbh->selectrow_array('SELECT VERSION()'));
1009                                                     }
1010  ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1011  ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
1012  ***      0                                  0      return $result;
1013                                                  }
1014                                                  
1015                                                  sub _d {
1016  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1017  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1018  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1019                                                          @_;
1020  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1021                                                  }
1022                                                  
1023                                                  1;
1024                                                  
1025                                                  # ###########################################################################
1026                                                  # End VersionParser package
1027                                                  # ###########################################################################
1028                                                  
1029                                                  # ###########################################################################
1030                                                  # DSNParser package 3963
1031                                                  # ###########################################################################
1032           1                    1             7   use strict;
               1                                  2   
               1                                  5   
1033           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
1034                                                  
1035                                                  package DSNParser;
1036                                                  
1037           1                    1            12   use DBI;
               1                                  4   
               1                                 10   
1038           1                    1             7   use Data::Dumper;
               1                                  2   
               1                                 10   
1039                                                  $Data::Dumper::Indent    = 0;
1040                                                  $Data::Dumper::Quotekeys = 0;
1041           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
1042                                                  
1043           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                 44   
1044                                                  
1045                                                  sub new {
1046           2                    2            27      my ( $class, @opts ) = @_;
1047           2                                123      my $self = {
1048                                                        opts => {
1049                                                           A => {
1050                                                              desc => 'Default character set',
1051                                                              dsn  => 'charset',
1052                                                              copy => 1,
1053                                                           },
1054                                                           D => {
1055                                                              desc => 'Database to use',
1056                                                              dsn  => 'database',
1057                                                              copy => 1,
1058                                                           },
1059                                                           F => {
1060                                                              desc => 'Only read default options from the given file',
1061                                                              dsn  => 'mysql_read_default_file',
1062                                                              copy => 1,
1063                                                           },
1064                                                           h => {
1065                                                              desc => 'Connect to host',
1066                                                              dsn  => 'host',
1067                                                              copy => 1,
1068                                                           },
1069                                                           p => {
1070                                                              desc => 'Password to use when connecting',
1071                                                              dsn  => 'password',
1072                                                              copy => 1,
1073                                                           },
1074                                                           P => {
1075                                                              desc => 'Port number to use for connection',
1076                                                              dsn  => 'port',
1077                                                              copy => 1,
1078                                                           },
1079                                                           S => {
1080                                                              desc => 'Socket file to use for connection',
1081                                                              dsn  => 'mysql_socket',
1082                                                              copy => 1,
1083                                                           },
1084                                                           u => {
1085                                                              desc => 'User for login if not current user',
1086                                                              dsn  => 'user',
1087                                                              copy => 1,
1088                                                           },
1089                                                        },
1090                                                     };
1091           2                                 21      foreach my $opt ( @opts ) {
1092  ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
1093  ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1094                                                     }
1095           2                                 40      return bless $self, $class;
1096                                                  }
1097                                                  
1098                                                  sub prop {
1099           8                    8            63      my ( $self, $prop, $value ) = @_;
1100           8    100                          52      if ( @_ > 2 ) {
1101           1                                  4         MKDEBUG && _d('Setting', $prop, 'property');
1102           1                                  7         $self->{$prop} = $value;
1103                                                     }
1104           8                                 80      return $self->{$prop};
1105                                                  }
1106                                                  
1107                                                  sub parse {
1108           2                    2            17      my ( $self, $dsn, $prev, $defaults ) = @_;
1109  ***      2     50                          12      if ( !$dsn ) {
1110  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1111  ***      0                                  0         return;
1112                                                     }
1113           2                                  6      MKDEBUG && _d('Parsing', $dsn);
1114  ***      2            50                   12      $prev     ||= {};
1115  ***      2            50                   12      $defaults ||= {};
1116           2                                  7      my %given_props;
1117           2                                  6      my %final_props;
1118           2                                  7      my %opts = %{$self->{opts}};
               2                                 25   
1119                                                  
1120           2                                 22      foreach my $dsn_part ( split(/,/, $dsn) ) {
1121  ***      3     50                          53         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1122           3                                 19            $given_props{$prop_key} = $prop_val;
1123                                                        }
1124                                                        else {
1125  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1126  ***      0                                  0            $given_props{h} = $dsn_part;
1127                                                        }
1128                                                     }
1129                                                  
1130           2                                 14      foreach my $key ( keys %opts ) {
1131          16                                 42         MKDEBUG && _d('Finding value for', $key);
1132          16                                 70         $final_props{$key} = $given_props{$key};
1133  ***     16     50     66                  198         if (   !defined $final_props{$key}
      ***                   33                        
1134                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1135                                                        {
1136  ***      0                                  0            $final_props{$key} = $prev->{$key};
1137  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1138                                                        }
1139          16    100                          86         if ( !defined $final_props{$key} ) {
1140          13                                 56            $final_props{$key} = $defaults->{$key};
1141          13                                 46            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1142                                                        }
1143                                                     }
1144                                                  
1145           2                                 27      foreach my $key ( keys %given_props ) {
1146  ***      3     50                          19         die "Unrecognized DSN part '$key' in '$dsn'\n"
1147                                                           unless exists $opts{$key};
1148                                                     }
1149  ***      2     50                          13      if ( (my $required = $self->prop('required')) ) {
1150  ***      0                                  0         foreach my $key ( keys %$required ) {
1151  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1152                                                        }
1153                                                     }
1154                                                  
1155           2                                 18      return \%final_props;
1156                                                  }
1157                                                  
1158                                                  sub parse_options {
1159           1                    1             7      my ( $self, $o ) = @_;
1160  ***      1     50                          11      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1161           1                                 16      my $dsn_string
1162                                                        = join(',',
1163  ***      8     50                          47             map  { "$_=".$o->get($_); }
1164           1                                 11             grep { $o->has($_) && $o->get($_) }
1165           1                                  5             keys %{$self->{opts}}
1166                                                          );
1167           1                                  6      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1168           1                                 12      return $self->parse($dsn_string);
1169                                                  }
1170                                                  
1171                                                  sub as_string {
1172  ***      0                    0             0      my ( $self, $dsn ) = @_;
1173  ***      0      0                           0      return $dsn unless ref $dsn;
1174  ***      0      0                           0      return join(',',
1175  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1176  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1177                                                        sort keys %$dsn );
1178                                                  }
1179                                                  
1180                                                  sub usage {
1181  ***      0                    0             0      my ( $self ) = @_;
1182  ***      0                                  0      my $usage
1183                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1184                                                        . "  KEY  COPY  MEANING\n"
1185                                                        . "  ===  ====  =============================================\n";
1186  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1187  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1188  ***      0      0      0                    0         $usage .= "  $key    "
1189                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1190                                                               .  ($opts{$key}->{desc} || '[No description]')
1191                                                               . "\n";
1192                                                     }
1193  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1194  ***      0                                  0      return $usage;
1195                                                  }
1196                                                  
1197                                                  sub get_cxn_params {
1198           2                    2            12      my ( $self, $info ) = @_;
1199           2                                  7      my $dsn;
1200           2                                  6      my %opts = %{$self->{opts}};
               2                                 23   
1201  ***      2            50                   14      my $driver = $self->prop('dbidriver') || '';
1202  ***      2     50                          11      if ( $driver eq 'Pg' ) {
1203  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1204  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1205  ***      0             0                    0                        grep { defined $info->{$_} }
1206                                                                       qw(h P));
1207                                                     }
1208                                                     else {
1209           3                                 29         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1210          10                                 47            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1211  ***      2            50                   33                        grep { defined $info->{$_} }
1212                                                                       qw(F h P S A))
1213                                                           . ';mysql_read_default_group=client';
1214                                                     }
1215           2                                  7      MKDEBUG && _d($dsn);
1216           2                                 29      return ($dsn, $info->{u}, $info->{p});
1217                                                  }
1218                                                  
1219                                                  sub fill_in_dsn {
1220  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1221  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1222  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1223  ***      0                                  0      $user =~ s/@.*//;
1224  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1225  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1226  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1227  ***      0             0                    0      $dsn->{u} ||= $user;
1228  ***      0             0                    0      $dsn->{D} ||= $db;
1229                                                  }
1230                                                  
1231                                                  sub get_dbh {
1232           2                    2            16      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1233  ***      2            50                   12      $opts ||= {};
1234  ***      2     50                          31      my $defaults = {
1235                                                        AutoCommit        => 0,
1236                                                        RaiseError        => 1,
1237                                                        PrintError        => 0,
1238                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1239                                                     };
1240           2                                 16      @{$defaults}{ keys %$opts } = values %$opts;
               2                                 13   
1241                                                  
1242           2                                  8      my $dbh;
1243           2                                  7      my $tries = 2;
1244  ***      2            66                   30      while ( !$dbh && $tries-- ) {
1245                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1246           2                                  5            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1247                                                  
1248           2                                  6         eval {
1249           2                                 37            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1250                                                  
1251  ***      2     50                          26            if ( $cxn_string =~ m/mysql/i ) {
1252           2                                  9               my $sql;
1253                                                  
1254           2                                  9               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1255                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1256           2                                  6               MKDEBUG && _d($dbh, ':', $sql);
1257           2                                278               $dbh->do($sql);
1258                                                  
1259  ***      2     50                          22               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1260  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1261  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1262  ***      0                                  0                  $dbh->do($sql);
1263  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1264  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1265  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1266                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1267                                                                 }
1268                                                                 else {
1269  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1270                                                                 }
1271                                                              }
1272                                                  
1273           2    100                          20               if ( $self->prop('setvars') ) {
1274           1                                  7                  $sql = "SET " . $self->prop('setvars');
1275           1                                  5                  MKDEBUG && _d($dbh, ':', $sql);
1276           1                                114                  $dbh->do($sql);
1277                                                              }
1278                                                           }
1279                                                        };
1280  ***      2     50     33                   30         if ( !$dbh && $EVAL_ERROR ) {
1281  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1282  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
1283  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1284  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1285                                                           }
1286  ***      0      0                           0            if ( !$tries ) {
1287  ***      0                                  0               die $EVAL_ERROR;
1288                                                           }
1289                                                        }
1290                                                     }
1291                                                  
1292           2                                  6      MKDEBUG && _d('DBH info: ',
1293                                                        $dbh,
1294                                                        Dumper($dbh->selectrow_hashref(
1295                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1296                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1297                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1298                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1299                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1300                                                        '$DBI::VERSION:',        $DBI::VERSION,
1301                                                     );
1302                                                  
1303           2                                 16      return $dbh;
1304                                                  }
1305                                                  
1306                                                  sub get_hostname {
1307  ***      0                    0             0      my ( $self, $dbh ) = @_;
1308  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1309  ***      0                                  0         return $host;
1310                                                     }
1311  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1312                                                        'SELECT /*!50038 @@hostname, */ 1');
1313  ***      0                                  0      return $hostname;
1314                                                  }
1315                                                  
1316                                                  sub disconnect {
1317           1                    1             7      my ( $self, $dbh ) = @_;
1318           1                                  4      MKDEBUG && $self->print_active_handles($dbh);
1319           1                                185      $dbh->disconnect;
1320                                                  }
1321                                                  
1322                                                  sub print_active_handles {
1323  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1324  ***      0             0                    0      $level ||= 0;
1325  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1326                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1327                                                        or die "Cannot print: $OS_ERROR";
1328  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1329  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1330                                                     }
1331                                                  }
1332                                                  
1333                                                  sub copy {
1334  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1335  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1336  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1337  ***      0                                  0      my %new_dsn = map {
1338  ***      0                                  0         my $key = $_;
1339  ***      0                                  0         my $val;
1340  ***      0      0                           0         if ( $args{overwrite} ) {
1341  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1342                                                        }
1343                                                        else {
1344  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1345                                                        }
1346  ***      0                                  0         $key => $val;
1347  ***      0                                  0      } keys %{$self->{opts}};
1348  ***      0                                  0      return \%new_dsn;
1349                                                  }
1350                                                  
1351                                                  sub _d {
1352  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1353  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1354  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1355                                                          @_;
1356  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1357                                                  }
1358                                                  
1359                                                  1;
1360                                                  
1361                                                  # ###########################################################################
1362                                                  # End DSNParser package
1363                                                  # ###########################################################################
1364                                                  
1365                                                  # ###########################################################################
1366                                                  # Daemon package 3976
1367                                                  # ###########################################################################
1368                                                  
1369                                                  package Daemon;
1370                                                  
1371           1                    1             8   use strict;
               1                                  2   
               1                                  8   
1372           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
1373                                                  
1374           1                    1            13   use POSIX qw(setsid);
               1                                  4   
               1                                 13   
1375           1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                 13   
1376                                                  
1377           1                    1            11   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                 10   
1378                                                  
1379                                                  sub new {
1380  ***      0                    0             0      my ( $class, %args ) = @_;
1381  ***      0                                  0      foreach my $arg ( qw(o) ) {
1382  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1383                                                     }
1384  ***      0                                  0      my $o = $args{o};
1385  ***      0      0                           0      my $self = {
      ***             0                               
1386                                                        o        => $o,
1387                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1388                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1389                                                     };
1390                                                  
1391  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1392                                                  
1393  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1394  ***      0                                  0      return bless $self, $class;
1395                                                  }
1396                                                  
1397                                                  sub daemonize {
1398  ***      0                    0             0      my ( $self ) = @_;
1399                                                  
1400  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1401  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1402  ***      0      0                           0      if ( $pid ) {
1403  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1404  ***      0                                  0         exit;
1405                                                     }
1406                                                  
1407  ***      0                                  0      $self->{child} = 1;
1408                                                  
1409  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1410  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1411                                                  
1412  ***      0                                  0      $self->_make_PID_file();
1413                                                  
1414  ***      0      0                           0      if ( -t STDIN ) {
1415  ***      0                                  0         close STDIN;
1416  ***      0      0                           0         open  STDIN, '/dev/null'
1417                                                           or die "Cannot reopen STDIN to /dev/null";
1418                                                     }
1419                                                  
1420  ***      0      0                           0      if ( $self->{log_file} ) {
1421  ***      0                                  0         close STDOUT;
1422  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1423                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1424                                                  
1425  ***      0                                  0         close STDERR;
1426  ***      0      0                           0         open  STDERR, ">&STDOUT"
1427                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR";
1428                                                     }
1429                                                  
1430  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1431  ***      0                                  0      return;
1432                                                  }
1433                                                  
1434                                                  sub check_PID_file {
1435  ***      0                    0             0      my ( $self, $file ) = @_;
1436  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1437  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1438  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1439  ***      0                                  0         my $pid;
1440  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1441  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1442  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1443  ***      0      0                           0         if ( $pid ) {
1444  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1445  ***      0      0                           0            if ( $pid_is_alive ) {
1446  ***      0                                  0               die "The PID file $PID_file already exists "
1447                                                                 . " and the PID that it contains, $pid, is running";
1448                                                           }
1449                                                           else {
1450  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1451                                                                 . "contains, $pid, is not running";
1452                                                           }
1453                                                        }
1454                                                        else {
1455  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1456                                                              . "contain a PID";
1457                                                        }
1458                                                     }
1459                                                     else {
1460  ***      0                                  0         MKDEBUG && _d('No PID file');
1461                                                     }
1462  ***      0                                  0      return;
1463                                                  }
1464                                                  
1465                                                  sub make_PID_file {
1466  ***      0                    0             0      my ( $self ) = @_;
1467  ***      0      0                           0      if ( exists $self->{child} ) {
1468  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1469                                                     }
1470  ***      0                                  0      $self->_make_PID_file();
1471  ***      0                                  0      $self->{rm_PID_file} = 1;
1472  ***      0                                  0      return;
1473                                                  }
1474                                                  
1475                                                  sub _make_PID_file {
1476  ***      0                    0             0      my ( $self ) = @_;
1477                                                  
1478  ***      0                                  0      my $PID_file = $self->{PID_file};
1479  ***      0      0                           0      if ( !$PID_file ) {
1480  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1481  ***      0                                  0         return;
1482                                                     }
1483                                                  
1484  ***      0                                  0      $self->check_PID_file();
1485                                                  
1486  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1487                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1488  ***      0      0                           0      print $PID_FH $PID
1489                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1490  ***      0      0                           0      close $PID_FH
1491                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1492                                                  
1493  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1494  ***      0                                  0      return;
1495                                                  }
1496                                                  
1497                                                  sub _remove_PID_file {
1498  ***      0                    0             0      my ( $self ) = @_;
1499  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1500  ***      0      0                           0         unlink $self->{PID_file}
1501                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1502  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1503                                                     }
1504                                                     else {
1505  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1506                                                     }
1507  ***      0                                  0      return;
1508                                                  }
1509                                                  
1510                                                  sub DESTROY {
1511  ***      0                    0             0      my ( $self ) = @_;
1512  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1513  ***      0                                  0      return;
1514                                                  }
1515                                                  
1516                                                  sub _d {
1517  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1518  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1519  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1520                                                          @_;
1521  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1522                                                  }
1523                                                  
1524                                                  1;
1525                                                  
1526                                                  # ###########################################################################
1527                                                  # End Daemon package
1528                                                  # ###########################################################################
1529                                                  
1530                                                  # ###########################################################################
1531                                                  # This is a combination of modules and programs in one -- a runnable module.
1532                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1533                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1534                                                  #
1535                                                  # Check at the end of this package for the call to main() which actually runs
1536                                                  # the program.
1537                                                  # ###########################################################################
1538                                                  package mk_loadavg;
1539                                                  
1540           1                    1            10   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
1541           1                    1             6   use IO::File;
               1                                  3   
               1                                 11   
1542           1                    1             6   use POSIX qw(setsid);
               1                                  2   
               1                                  6   
1543           1                    1            13   use sigtrap qw(handler finish untrapped normal-signals);
               1                                  2   
               1                                  7   
1544                                                  
1545           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
1546                                                  
1547                                                  $OUTPUT_AUTOFLUSH = 1;
1548                                                  
1549                                                  # Types of info that can be gathered.
1550                                                  my %info_subroutines = (
1551                                                     status => sub {
1552                                                        my ( $dbh ) = @_;
1553                                                        my $sth = $dbh->prepare('SHOW /*!50002 GLOBAL*/ STATUS');
1554                                                        $sth->execute();
1555                                                        pretty_print($sth);
1556                                                        $sth->finish();
1557                                                        $sth->execute();
1558                                                        pretty_print($sth);
1559                                                        $sth->finish();
1560                                                     },
1561                                                  
1562                                                     processlist => sub {
1563                                                        my ( $dbh ) = @_;
1564                                                        my $sth = $dbh->prepare('SHOW FULL PROCESSLIST');
1565                                                        $sth->execute();
1566                                                        pretty_print($sth);
1567                                                     },
1568                                                  
1569                                                     innodbstatus => sub {
1570                                                        my ( $dbh ) = @_;
1571                                                        my $st = $dbh->selectall_arrayref('SHOW INNODB STATUS', { Slice => {} } );
1572                                                        print $st->[0]->{Status}, "\n";
1573                                                     },
1574                                                  
1575                                                     uptime => sub {
1576                                                        my ( $dbh ) = @_;
1577                                                        print `uptime`;
1578                                                     },
1579                                                  );
1580                                                  
1581                                                  sub main {
1582           1                    1            34      @ARGV = @_;  # set global ARGV for this package
1583                                                  
1584                                                     # ########################################################################
1585                                                     # Get configuration information.
1586                                                     # ########################################################################
1587           1                                 30      my $dp = new DSNParser();
1588           1                                 45      my $vp = new VersionParser();
1589           1                                 31      my $o  = new OptionParser(
1590                                                        description => 'watches the load on a MySQL server and takes action '
1591                                                                     . 'if it is too high.',
1592                                                     );
1593           1                                 12      $o->get_specs();
1594           1                                 18      $o->get_opts();
1595                                                  
1596           1                                  9      $dp->prop('setvars', $o->get('set-vars'));
1597                                                  
1598           1                                 12      $o->usage_or_errors();
1599                                                  
1600                                                     # ########################################################################
1601                                                     # First things first: if --stop was given, create the sentinel file.
1602                                                     # ########################################################################
1603  ***      1     50                           6      if ( $o->get('stop') ) {
1604  ***      0                                  0         my $sentinel = $o->get('sentinel');
1605  ***      0                                  0         MKDEBUG && _d('Creating sentinel file', $sentinel);
1606  ***      0      0                           0         my $file = IO::File->new($sentinel, ">>")
1607                                                           or die "Cannot open $sentinel: $OS_ERROR\n";
1608  ***      0      0                           0         print $file "Remove this file to permit mk-loadavg to run\n"
1609                                                           or die "Cannot write to $sentinel: $OS_ERROR\n";
1610  ***      0      0                           0         close $file
1611                                                           or die "Cannot close $sentinel: $OS_ERROR\n";
1612  ***      0                                  0         print "Successfully created file $sentinel\n";
1613  ***      0                                  0         return 0;
1614                                                     }
1615                                                  
1616                                                     # ########################################################################
1617                                                     # Connect and go to work.
1618                                                     # ########################################################################
1619  ***      1     50                           7      if ( $o->get('ask-pass') ) {
1620  ***      0                                  0         $o->set('passowrd', OptionParser::prompt_noecho("Enter password: "));
1621                                                     }
1622           1                                 15      my $dsn = $dp->parse_options($o);
1623           1                                 15      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1, });
1624           1                                 13      $dbh->{InactiveDestroy}  = 1;         # Don't die on fork().
1625                                                  
1626                                                     # Daemonize only after connecting and doing --ask-pass.
1627           1                                  7      my $daemon;
1628  ***      1     50                          12      if ( $o->get('daemonize') ) {
1629  ***      0                                  0         $daemon = new Daemon(o=>$o);
1630  ***      0                                  0         $daemon->daemonize();
1631  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
1632                                                     }
1633                                                  
1634                                                     watch_server(
1635           1                                 18         dsn => $dsn,
1636                                                        dbh => $dbh,
1637                                                        o   => $o,
1638                                                        dp  => $dp,
1639                                                        vp  => $vp,
1640                                                     );
1641                                                  
1642           1                                 55      $dp->disconnect($dbh);
1643           1                               1189      return 0;
1644                                                  }
1645                                                  
1646                                                  # ############################################################################
1647                                                  # Subroutines.
1648                                                  # ############################################################################
1649                                                  
1650                                                  sub watch_server {
1651           1                    1            14      my ( %args ) = @_;
1652           1                                  9      foreach my $arg ( qw(dsn dbh o dp vp) ) {
1653  ***      5     50                          39         die "I need a $arg argument" unless $args{$arg};
1654                                                     }
1655           1                                  6      my $dsn = $args{dsn};
1656           1                                  5      my $dbh = $args{dbh};
1657           1                                 12      my $o   = $args{o};
1658           1                                  5      my $dp  = $args{dp};
1659           1                                  5      my $vp  = $args{vp};
1660                                                  
1661           1                                  3      MKDEBUG && _d('Watching server', $dp->as_string($dsn));
1662                                                  
1663           1                                 25      my $la = new Loadavg();
1664           1                                 12      my %metrics;
1665           1                                  5      foreach my $item ( @{$o->get('metrics')} ) {
               1                                  6   
1666           1                                 15         my ($key, $val) = split(/:/, $item);
1667           1                                  3         MKDEBUG && _d('metric key:', $key, 'val:', $val);
1668           1                                  9         $metrics{$key} = $val; # $val can be undef.
1669                                                     }
1670           1                                  9      my %la_args = (
1671                                                        samples   => $o->get('samples'),
1672                                                        metric    => $o->get('status'),     # Can be undef
1673                                                        incstatus => $o->get('interval'),   # Can be undef
1674                                                     );
1675                                                  
1676  ***      1            50                   15      my $exit_time = time() + ($o->get('run-time') || 0);
1677  ***      1            66                   14      while ( (!$o->get('run-time') || time() < $exit_time)
      ***                   66                        
1678                                                             && !-f $o->get('sentinel') ) {
1679                                                        METRIC:
1680           1                                  9         foreach my $metric ( keys %metrics ) {
1681           1                                 15            my $val = $la->$metric($dbh, %la_args);
1682           1                                  6            MKDEBUG && _d($metric, '=', $val);
1683  ***      1     50                          11            if ( $o->get('print-load-avg') ) {
1684  ***      0                                  0               printf("%15s %.5f\n", $metric, $val);
1685                                                           }
1686  ***      1     50     33                   27            if ( defined $metrics{$metric} && $val >= $metrics{$metric} ) {
1687           1                                  4               foreach my $info ( @{$o->get('info')} ) {
               1                                  8   
1688  ***      0      0                           0                  if ( $info_subroutines{$info} ) {
1689  ***      0                                  0                     $info_subroutines{$info}->($dbh);
1690                                                                 }
1691                                                              }
1692  ***      1     50                           7               exec_cmd($o->get('execute-command')) if $o->get('execute-command');
1693           1                                 61               last METRIC;
1694                                                           }
1695                                                        }
1696           1                                 57         sleep($o->get('sleep'));
1697                                                     }
1698                                                  
1699           1                                 13      MKDEBUG && _d('All done with server', $dp->as_string($dsn));
1700                                                  
1701           1                                159      return;
1702                                                  }
1703                                                  
1704                                                  sub pretty_print {
1705  ***      0                    0             0      my ( $sth ) = @_;
1706  ***      0                                  0      my @headers = @{$sth->{NAME}};
      ***      0                                  0   
1707  ***      0                                  0      my $max_len = 0;
1708  ***      0      0                           0      map { $max_len = length($_) if length($_) > $max_len } @headers;
      ***      0                                  0   
1709  ***      0                                  0      while ( my @row = $sth->fetchrow_array() ) {
1710  ***      0                                  0         foreach my $col ( 0 .. $#headers ) {
1711  ***      0                                  0            printf("%${max_len}s: ", $headers[$col]);
1712  ***      0                                  0            print($row[$col], "\n");
1713                                                        }
1714                                                     }
1715                                                  }
1716                                                  
1717                                                  # Forks and detaches from parent to execute the given command;
1718                                                  # does not block parent.
1719                                                  sub exec_cmd {
1720           1                    1             7      my ( $cmd ) = @_;
1721           1                                  5      MKDEBUG && _d('exec cmd:', $cmd);
1722  ***      1     50                           8      return unless $cmd;
1723                                                  
1724           1                               1512      my $pid = fork();
1725  ***      1     50                          87      if ( $pid ) {
1726                                                        # parent
1727           1                                  5         MKDEBUG && _d('child pid:', $pid);
1728           1                                 57         return $pid;
1729                                                     }
1730                                                  
1731                                                     # child
1732  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1733  ***      0                                         my $retval = system($cmd);
1734  ***      0                                         $retval = $retval >> 8;
1735  ***      0                                         MKDEBUG && _d('child exit status:', $retval);
1736  ***      0                                         exit $retval;
1737                                                  }
1738                                                  
1739                                                  # Catches signals for exiting gracefully.
1740                                                  sub finish {
1741  ***      0                    0                    my ($signal) = @_;
1742  ***      0                                         print STDERR "Exiting on SIG$signal.\n";
1743  ***      0                                         return 1;
1744                                                  }
1745                                                  
1746                                                  sub _d {
1747  ***      0                    0                    my ($package, undef, $line) = caller 0;
1748  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1749  ***      0                                              map { defined $_ ? $_ : 'undef' }
1750                                                          @_;
1751  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1752                                                  }
1753                                                  
1754                                                  # ############################################################################
1755                                                  # Run the program.
1756                                                  # ############################################################################
1757                                                  if ( !caller ) { exit main(@ARGV); }
1758                                                  
1759                                                  1; # Because this is a module as well as a script.
1760                                                  
1761                                                  # ############################################################################
1762                                                  # Documentation.
1763                                                  # ############################################################################
1764                                                  
1765                                                  =pod
1766                                                  
1767                                                  =head1 NAME
1768                                                  
1769                                                  mk-loadavg - Watch MySQL load and take action when it gets too high.
1770                                                  
1771                                                  =head1 SYNOPSIS
1772                                                  
1773                                                    mk-loadavg --metrics num_locked:5 --info status,processlist
1774                                                  
1775                                                  =head1 DESCRIPTION
1776                                                  
1777                                                  mk-loadavg watches MySQL servers and gathers information when the load gets
1778                                                  high.  It can then send email.
1779                                                  
1780                                                  =head1 OUTPUT
1781                                                  
1782                                                  If you specify L<"--print-load-avg">, mk-loadavg prints the load average it
1783                                                  calculates for each metric even if the metric does not exceed its limit.
1784                                                  
1785                                                  =head1 EXIT STATUS
1786                                                  
1787                                                  Successful exit status is 0.  Any other value represents the exit status of
1788                                                  the Perl process itself, or of the last forked process that exited if there
1789                                                  were multiple servers to monitor.
1790                                                  
1791                                                  =head1 OPTIONS
1792                                                  
1793                                                  =over
1794                                                  
1795                                                  =item --ask-pass
1796                                                  
1797                                                  Prompt for a password when connecting to MySQL.
1798                                                  
1799                                                  =item --charset
1800                                                  
1801                                                  short form: -A; type: string
1802                                                  
1803                                                  Default character set.  If the value is utf8, sets Perl's binmode on
1804                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
1805                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
1806                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
1807                                                  
1808                                                  =item --config
1809                                                  
1810                                                  type: Array
1811                                                  
1812                                                  Read this comma-separated list of config files; if specified, this must be the
1813                                                  first option on the command line.
1814                                                  
1815                                                  =item --daemonize
1816                                                  
1817                                                  Fork to the background and detach from the shell.  POSIX
1818                                                  operating systems only.
1819                                                  
1820                                                  =item --database
1821                                                  
1822                                                  short form: -D; type: string
1823                                                  
1824                                                  Database to use.
1825                                                  
1826                                                  =item --defaults-file
1827                                                  
1828                                                  short form: -F; type: string
1829                                                  
1830                                                  Only read mysql options from the given file.  You must give an absolute
1831                                                  pathname.
1832                                                  
1833                                                  =item --execute-command
1834                                                  
1835                                                  type: string
1836                                                  
1837                                                  Execute this command when L<"--metrics"> are exceeded.
1838                                                  
1839                                                  In addition to L<"--info">, this command will be executed when L<"--metrics">
1840                                                  are exceeded.  After the command is executed, mk-loadavg has no control over
1841                                                  it, so the command is responsible for its own info gathering, logging,
1842                                                  interval, etc.  The command is excuted each time the metrics are exceeded,
1843                                                  so be careful that the command behaves well when multiple instances are ran.
1844                                                  No information from mk-loadavg is passed to the command.
1845                                                  
1846                                                  =item --help
1847                                                  
1848                                                  Show help and exit.
1849                                                  
1850                                                  =item --host
1851                                                  
1852                                                  short form: -h; type: string
1853                                                  
1854                                                  Connect to host.
1855                                                  
1856                                                  =item --interval
1857                                                  
1858                                                  type: time; default: 1s
1859                                                  
1860                                                  Time interval over which to calculate the L<"--status"> metric.
1861                                                  
1862                                                  =item --info
1863                                                  
1864                                                  type: Array
1865                                                  
1866                                                  A list of info to print when L<"--metrics"> are exceeded.
1867                                                  
1868                                                  This comma-separated list can include status, processlist, innodbstatus, uptime.
1869                                                  
1870                                                  =item --log
1871                                                  
1872                                                  type: string
1873                                                  
1874                                                  Print all output to this file when daemonized.
1875                                                  
1876                                                  =item --metrics
1877                                                  
1878                                                  type: Array
1879                                                  
1880                                                  A comma-separated list of metric:val pairs to calculate.
1881                                                  
1882                                                  The list is of the form metric:value.  The value is optional; if given, it
1883                                                  specifies an upper limit of acceptable values for the metric.  If it isn't
1884                                                  given, then the value will be calculated and printed (if L<"--print-load-avg">
1885                                                  is given) but it won't be checked to see if it's too high.
1886                                                  
1887                                                  The possible metrics are trevorprice, num_locked, loadavg, slavelag, and status.
1888                                                  For example you can say
1889                                                  
1890                                                    --metrics trevorprice:1,num_locked:5
1891                                                  
1892                                                  In this example, if either trevorprice exceeds 1 or num_locked exceeds 5, the
1893                                                  L<"--info"> information will be printed out.  The possible metrics mean the
1894                                                  following:
1895                                                  
1896                                                    METRIC       MEANING
1897                                                    ===========  ================================================
1898                                                    trevorprice  A calculation of average query response time
1899                                                    num_locked   Number of locked processes in PROCESSLIST
1900                                                    loadavg      The server's load average as reported by 'uptime'
1901                                                    slavelag     The server's slave lag from Seconds_behind_master
1902                                                    status       Any value from SHOW GLOBAL STATUS (see L<"--status">)
1903                                                  
1904                                                  The status metric is special.  You have to give L<"--status"> to say which value
1905                                                  from SHOW GLOBAL STATUS you want to measure against.  The loadavg metric works
1906                                                  only on the machine on which mk-loadavg is running.
1907                                                  
1908                                                  =item --password
1909                                                  
1910                                                  short form: -p; type: string
1911                                                  
1912                                                  Password to use when connecting.
1913                                                  
1914                                                  =item --pid
1915                                                  
1916                                                  type: string
1917                                                  
1918                                                  Create the given PID file when daemonized.  The file contains the process
1919                                                  ID of the daemonized instance.  The PID file is removed when the
1920                                                  daemonized instance exits.  The program checks for the existence of the
1921                                                  PID file when starting; if it exists and the process with the matching PID
1922                                                  exists, the program exits.
1923                                                  
1924                                                  =item --port
1925                                                  
1926                                                  short form: -P; type: int
1927                                                  
1928                                                  Port number to use for connection.
1929                                                  
1930                                                  =item --print-load-avg
1931                                                  
1932                                                  Print metrics' load average even if they don't exceed limits.
1933                                                  
1934                                                  =item --run-time
1935                                                  
1936                                                  type: time
1937                                                  
1938                                                  Time to run before exiting.
1939                                                  
1940                                                  Causes C<mk-loadavg> to stop after the specified time has elapsed.
1941                                                  Optional suffix: s=seconds, m=minutes, h=hours, d=days; if no suffix, s is used.
1942                                                  
1943                                                  =item --samples
1944                                                  
1945                                                  type: int
1946                                                  
1947                                                  How many samples to use for calculating the trevorprice L<"--metrics">.
1948                                                  
1949                                                  =item --sentinel
1950                                                  
1951                                                  type: string; default: /tmp/mk-loadavg-sentinel
1952                                                  
1953                                                  Exit if this file exists.
1954                                                  
1955                                                  =item --set-vars
1956                                                  
1957                                                  type: string; default: wait_timeout=10000
1958                                                  
1959                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
1960                                                  will be appended to SET and executed.
1961                                                  
1962                                                  =item --sleep
1963                                                  
1964                                                  type: time; default: 60s
1965                                                  
1966                                                  How long to sleep between each check.
1967                                                  
1968                                                  =item --socket
1969                                                  
1970                                                  short form: -S; type: string
1971                                                  
1972                                                  Socket file to use for connection.
1973                                                  
1974                                                  =item --status
1975                                                  
1976                                                  type: string
1977                                                  
1978                                                  Value from SHOW GLOBAL STATUS to measure.
1979                                                  
1980                                                  This affects the 'status' value for L<"--metrics">.
1981                                                  
1982                                                  See also L<"--interval">.
1983                                                  
1984                                                  =item --stop
1985                                                  
1986                                                  Stop running instances by creating the L<"--sentinel"> file.
1987                                                  
1988                                                  =item --user
1989                                                  
1990                                                  short form: -u; type: string
1991                                                  
1992                                                  User for login if not current user.
1993                                                  
1994                                                  =item --version
1995                                                  
1996                                                  Show version and exit.
1997                                                  
1998                                                  =back
1999                                                  
2000                                                  =head1 DOWNLOADING
2001                                                  
2002                                                  You can download Maatkit from Google Code at
2003                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2004                                                  easily with a command like the following:
2005                                                  
2006                                                     wget http://www.maatkit.org/get/toolname
2007                                                     or
2008                                                     wget http://www.maatkit.org/trunk/toolname
2009                                                  
2010                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2011                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2012                                                  needed.  The first URL gets the latest released version of the tool, and the
2013                                                  second gets the latest trunk code from Subversion.
2014                                                  
2015                                                  =head1 ENVIRONMENT
2016                                                  
2017                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2018                                                  the Maatkit tools:
2019                                                  
2020                                                     MKDEBUG=1 mk-....
2021                                                  
2022                                                  =head1 SYSTEM REQUIREMENTS
2023                                                  
2024                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2025                                                  installed in any reasonably new version of Perl.
2026                                                  
2027                                                  =head1 BUGS
2028                                                  
2029                                                  Please use Google Code Issues and Groups to report bugs or request support:
2030                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2031                                                  discuss Maatkit.
2032                                                  
2033                                                  Please include the complete command-line used to reproduce the problem you are
2034                                                  seeing, the version of all MySQL servers involved, the complete output of the
2035                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2036                                                  running with the C<MKDEBUG=1> environment variable.
2037                                                  
2038                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2039                                                  
2040                                                  This program is copyright 2008-@CURRENTYEAR@ Baron Schwartz.
2041                                                  Feedback and improvements are welcome.
2042                                                  
2043                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2044                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2045                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2046                                                  
2047                                                  This program is free software; you can redistribute it and/or modify it under
2048                                                  the terms of the GNU General Public License as published by the Free Software
2049                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2050                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2051                                                  licenses.
2052                                                  
2053                                                  You should have received a copy of the GNU General Public License along with
2054                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2055                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2056                                                  
2057                                                  =head1 AUTHOR
2058                                                  
2059                                                  Baron Schwartz
2060                                                  
2061                                                  =head1 VERSION
2062                                                  
2063                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 4071 $.
2064                                                  
2065                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
51    ***      0      0      0   unless $dbh
63    ***      0      0      0   unless $time
67    ***      0      0      0   unless $qps
73    ***      0      0      0   unless $dbh
83    ***      0      0      0   unless $str
90    ***      0      0      0   unless $dbh
92    ***      0      0      0   if ($sl)
95    ***      0      0      0   $key ? :
102   ***     50      0      1   unless $dbh
105   ***     50      1      0   if ($args{'incstatus'}) { }
118   ***      0      0      0   defined $_ ? :
158   ***     50      0      1   unless $args{$arg}
163   ***     50      0      1   exists $args{'strict'} ? :
206   ***     50      0      1   unless open my $fh, '<', $file
226          100    238      1   unless $para =~ /^=head1 OPTIONS/
231   ***     50      1      0   if $para =~ /^=over/
239   ***     50      0      1   unless $para
242          100     27      1   if (my($option) = $para =~ /^=item --(.*)/)
249          100     21      6   if ($para =~ /: /) { }
253   ***     50      0     33   unless $attributes{$attrib}
257          100      8     13   if ($attribs{'short form'})
273   ***     50      0     27   if $para =~ /^=item/
275   ***     50      0     27   if (my($base_option) = $option =~ /^\[no\](.*)/)
280          100      8     19   $attribs{'short form'} ? :
      ***     50      0     27   $attribs{'negatable'} ? :
      ***     50      0     27   $attribs{'cumulative'} ? :
             100     21      6   $attribs{'type'} ? :
             100      4     23   $attribs{'default'} ? :
      ***     50      0     27   $attribs{'group'} ? :
292   ***     50      0     40   unless $para
295          100      1     39   if ($para =~ /^=head1/)
299          100     27     12   if $para =~ /^=item --/
303   ***     50      0      1   unless @specs
314   ***     50     27      0   if (ref $opt) { }
319   ***     50      0     27   if (not $long)
324   ***     50      0     27   if exists $$self{'opts'}{$long}
327   ***     50      0     27   if (length $long == 1)
332          100      8     19   if ($short) { }
333   ***     50      0      8   if exists $$self{'short_opts'}{$short}
342   ***     50      0     27   $$opt{'spec'} =~ /!/ ? :
343   ***     50      0     27   $$opt{'spec'} =~ /\+/ ? :
344   ***     50      0     27   $$opt{'desc'} =~ /required/ ? :
356   ***     50      0     27   if ($type and $type eq 'd' and not $$self{'dp'})
361          100      6     21   if $type and $type =~ /[HhAadzm]/
363          100      4     23   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
364   ***     50      0      4   if ($$opt{'is_negatable'})
365   ***      0      0      0   $def eq 'no' ? :
      ***      0      0      0   $def eq 'yes' ? :
369   ***     50      4      0   defined $def ? :
373          100      1     26   if ($long eq 'config')
377   ***     50      0     27   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
390   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
395   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
400   ***      0      0      0   if ($opt =~ /default to/)
405   ***      0      0      0   if ($opt =~ /restricted to option groups/)
415   ***      0      0      0   unless $rule_ok
432   ***      0      0      0   unless exists $$self{'opts'}{$long}
448   ***      0      0      0   $$self{'opts'}{$_}{'short'} ? :
466   ***      0      0      0   unless exists $$self{'opts'}{$long}
486   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50      6      0   exists $$self{'opts'}{$opt} ? :
491   ***     50      0      6   if ($$opt{'is_cumulative'}) { }
506   ***     50      0     22   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100      5     22   exists $$self{'defaults'}{$long} ? :
515   ***     50      0      1   if (@ARGV and $ARGV[0] eq '--config')
519   ***     50      1      0   if ($self->has('config'))
525   ***     50      4      0   if ($EVAL_ERROR)
526   ***     50      0      4   $self->got('config') ? :
541   ***     50      0      1   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
544   ***     50      0      1   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
545   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
551   ***     50      0      1   if (@ARGV and $$self{'strict'})
557   ***      0      0      0   if (@set > 1)
568   ***      0      0      0   if (@set == 0)
578          100      6     21   if ($$opt{'got'}) { }
      ***     50      0     21   elsif ($$opt{'is_required'}) { }
579   ***     50      0      6   if (exists $$self{'disables'}{$long})
586   ***     50      0      6   if (exists $$self{'allowed_groups'}{$long})
598   ***      0      0      0   if $restricted_opt eq $long
599   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
604   ***      0      0      0   if (@restricted_opts)
606   ***      0      0      0   if (@restricted_opts == 1) { }
635          100      6     21   unless $opt and $$opt{'type'}
638          100      2     19   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0     19   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     19   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0     19   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      3     16   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
641          100      1      1   if (not $suffix)
647   ***     50      2      0   if ($suffix =~ /[smhd]/) { }
648   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***     50      2      0   $suffix eq 's' ? :
663   ***      0      0      0   if ($from_key)
674   ***      0      0      0   if (defined $num) { }
675   ***      0      0      0   if ($factor)
702          100      9     18   length $opt == 1 ? :
703   ***     50      0     27   unless $long and exists $$self{'opts'}{$long}
710   ***     50      0      4   length $opt == 1 ? :
711   ***     50      0      4   unless $long and exists $$self{'opts'}{$long}
718          100      8      1   length $opt == 1 ? :
719   ***     50      9      0   defined $long ? :
724   ***      0      0      0   length $opt == 1 ? :
725   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
759   ***     50      0      1   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      1   elsif (scalar @{$$self{'errors'};}) { }
760   ***      0      0      0   unless print $self->print_usage
764   ***      0      0      0   unless print $self->print_errors
773   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
782   ***      0      0      0   unless $$self{'got_opts'}
785   ***      0      0      0   $$_{'is_negatable'} ? :
789   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
805   ***      0      0      0   $group eq 'default' ? :
811   ***      0      0      0   $$opt{'is_negatable'} ? :
814   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
823   ***      0      0      0   if ($short) { }
832   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
836   ***      0      0      0   if ($$self{'dp'})
844   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
856   ***      0      0      0   if ref $_[0] eq 'OptionParser'
859   ***      0      0      0   unless print $prompt
867   ***      0      0      0   unless print "\n"
870   ***      0      0      0   if ($EVAL_ERROR)
892   ***     50      4      0   unless open my $fh, '<', $filename
900   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
903   ***      0      0      0   if ($line eq '--')
908   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
926   ***      0      0      0   unless open my $fh, '<', $file
930   ***      0      0      0   unless $para =~ /^=pod$/m
934   ***      0      0      0   unless $para =~ /$regex/
939   ***      0      0      0   unless close $fh
953   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
968   ***      0      0      0   defined $_ ? :
1006  ***      0      0      0   if (not $$self{$dbh})
1010  ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
1017  ***      0      0      0   defined $_ ? :
1100         100      1      7   if (@_ > 2)
1109  ***     50      0      2   if (not $dsn)
1121  ***     50      3      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1133  ***     50      0     16   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1139         100     13      3   if (not defined $final_props{$key})
1146  ***     50      0      3   unless exists $opts{$key}
1149  ***     50      0      2   if (my $required = $self->prop('required'))
1151  ***      0      0      0   unless $final_props{$key}
1160  ***     50      0      1   unless ref $o eq 'OptionParser'
1163  ***     50      8      0   if $o->has($_)
1173  ***      0      0      0   unless ref $dsn
1174  ***      0      0      0   $_ eq 'p' ? :
1175  ***      0      0      0   if defined $$dsn{$_}
1188  ***      0      0      0   $opts{$key}{'copy'} ? :
1202  ***     50      0      2   if ($driver eq 'Pg') { }
1234  ***     50      0      2   $cxn_string =~ /charset=utf8/ ? :
1251  ***     50      2      0   if ($cxn_string =~ /mysql/i)
1259  ***     50      0      2   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1264  ***      0      0      0   if ($charset eq 'utf8') { }
1265  ***      0      0      0   unless binmode STDOUT, ':utf8'
1269  ***      0      0      0   unless binmode STDOUT
1273         100      1      1   if ($self->prop('setvars'))
1280  ***     50      0      2   if (not $dbh and $EVAL_ERROR)
1282  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/)
1286  ***      0      0      0   if (not $tries)
1308  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1325  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1335  ***      0      0      0   unless $dsn_1
1336  ***      0      0      0   unless $dsn_2
1340  ***      0      0      0   if ($args{'overwrite'}) { }
1341  ***      0      0      0   defined $$dsn_1{$key} ? :
1344  ***      0      0      0   defined $$dsn_2{$key} ? :
1353  ***      0      0      0   defined $_ ? :
1382  ***      0      0      0   unless $args{$arg}
1385  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1401  ***      0      0      0   unless defined(my $pid = fork)
1402  ***      0      0      0   if ($pid)
1409  ***      0      0      0   unless POSIX::setsid()
1410  ***      0      0      0   unless chdir '/'
1414  ***      0      0      0   if (-t STDIN)
1416  ***      0      0      0   unless open STDIN, '/dev/null'
1420  ***      0      0      0   if ($$self{'log_file'})
1422  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1426  ***      0      0      0   unless open STDERR, '>&STDOUT'
1436  ***      0      0      0   $self ? :
1438  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1441  ***      0      0      0   if $EVAL_ERROR
1443  ***      0      0      0   if ($pid) { }
1445  ***      0      0      0   if ($pid_is_alive) { }
1467  ***      0      0      0   if (exists $$self{'child'})
1479  ***      0      0      0   if (not $PID_file)
1486  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1488  ***      0      0      0   unless print $PID_FH $PID
1490  ***      0      0      0   unless close $PID_FH
1499  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1500  ***      0      0      0   unless unlink $$self{'PID_file'}
1512  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1518  ***      0      0      0   defined $_ ? :
1603  ***     50      0      1   if ($o->get('stop'))
1606  ***      0      0      0   unless my $file = 'IO::File'->new($sentinel, '>>')
1608  ***      0      0      0   unless print $file "Remove this file to permit mk-loadavg to run\n"
1610  ***      0      0      0   unless close $file
1619  ***     50      0      1   if ($o->get('ask-pass'))
1628  ***     50      0      1   if ($o->get('daemonize'))
1653  ***     50      0      5   unless $args{$arg}
1683  ***     50      0      1   if ($o->get('print-load-avg'))
1686  ***     50      1      0   if (defined $metrics{$metric} and $val >= $metrics{$metric})
1688  ***      0      0      0   if ($info_subroutines{$info})
1692  ***     50      1      0   if $o->get('execute-command')
1708  ***      0      0      0   if length $_ > $max_len
1722  ***     50      0      1   unless $cmd
1725  ***     50      1      0   if ($pid)
1732  ***      0      0      0   unless POSIX::setsid()
1748  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
356   ***     66      6     21      0   $type and $type eq 'd'
      ***     33     27      0      0   $type and $type eq 'd' and not $$self{'dp'}
361          100      6     15      6   $type and $type =~ /[HhAadzm]/
515   ***     33      0      1      0   @ARGV and $ARGV[0] eq '--config'
544   ***     33      0      1      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
551   ***     33      1      0      0   @ARGV and $$self{'strict'}
635   ***     66      0      6     21   $opt and $$opt{'type'}
638          100     12      7      2   $val and $$opt{'type'} eq 'm'
      ***     66     12      7      0   $val and $$opt{'type'} eq 'd'
      ***     66     12      7      0   $val and $$opt{'type'} eq 'z'
      ***     66     11      8      0   defined $val and $$opt{'type'} eq 'h'
      ***     66     10      6      0   defined $val and $$opt{'type'} eq 'a'
703   ***     33      0      0     27   $long and exists $$self{'opts'}{$long}
711   ***     33      0      0      4   $long and exists $$self{'opts'}{$long}
725   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
814   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
908   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1133  ***     66      3     13      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     16      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1244  ***     66      2      0      2   not $dbh and $tries--
1280  ***     33      2      0      0   not $dbh and $EVAL_ERROR
1438  ***      0      0      0      0   $PID_file and -f $PID_file
1499  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1677  ***     66      1      0      1   !$o->get('run-time') || time < $exit_time and not -f $o->get('sentinel')
1686  ***     33      0      0      1   defined $metrics{$metric} and $val >= $metrics{$metric}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
52    ***      0      0      0   $args{'samples'} || 100
59    ***      0      0      0   $$_{'Command'} || ''
75    ***      0      0      0   $$_{'State'} || ''
76    ***      0      0      0   $locked || 0
85    ***      0      0      0   $one || 0
95    ***      0      0      0   $$sl{$key} || 0
161   ***     50      1      0   $program_name ||= $PROGRAM_NAME
163   ***     50      0      1   $args{'prompt'} || '<options>'
      ***     50      0      1   $args{'dp'} || undef
205   ***     50      0      1   $file ||= '../mk-loadavg'
346   ***     50     27      0   $$opt{'group'} ||= 'default'
643   ***     50      0      1   $s || 's'
680   ***      0      0      0   $pre || ''
687   ***      0      0      0   $val || ''
690          100      2      1   $val || ''
748   ***      0      0      0   $$self{'description'} || ''
816   ***      0      0      0   $s ||= 's'
842   ***      0      0      0   $$opt{'type'} || ''
1114  ***     50      0      2   $prev ||= {}
1115  ***     50      0      2   $defaults ||= {}
1188  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1201  ***     50      0      2   $self->prop('dbidriver') || ''
1205  ***      0      0      0   $$info{'D'} || ''
1211  ***     50      0      2   $$info{'D'} || ''
1233  ***     50      2      0   $opts ||= {}
1308  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1324  ***      0      0      0   $level ||= 0
1325  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1676  ***     50      1      0   $o->get('run-time') || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
638   ***     33      0      0     19   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      3      0     16   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1224  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1225  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1226  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1227  ***      0      0      0      0   $$dsn{'u'} ||= $user
1228  ***      0      0      0      0   $$dsn{'D'} ||= $db
1512  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1677  ***     66      0      1      1   !$o->get('run-time') || time < $exit_time


Covered Subroutines
-------------------

Subroutine           Count Location                                           
-------------------- ----- ---------------------------------------------------
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1032
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1033
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1037
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1038
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1041
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1043
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:135 
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:136 
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1371
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1372
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1374
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1375
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1377
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:138 
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:139 
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:140 
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:142 
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1540
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1541
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1542
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1543
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1545
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:23  
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:24  
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:35  
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:36  
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:38  
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:39  
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:40  
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:42  
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:985 
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:986 
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:988 
BEGIN                    1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:990 
__ANON__                 6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:539 
_parse_specs             1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:310 
_pod_to_specs            1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:204 
_read_config_file        4 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:891 
_set_option              6 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:485 
_validate_type          27 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:634 
disconnect               1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1317
exec_cmd                 1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1720
get                     27 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:701 
get_cxn_params           2 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1198
get_dbh                  2 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1232
get_defaults_files       1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:199 
get_opts                 1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:502 
get_specs                1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:192 
got                      4 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:709 
has                      9 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:717 
main                     1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1582
new                      2 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1046
new                      1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:156 
new                      1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:45  
new                      1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:993 
parse                    2 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1108
parse_options            1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1159
prop                     8 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1099
status                   1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:101 
usage_or_errors          1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:758 
watch_server             1 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1651

Uncovered Subroutines
---------------------

Subroutine           Count Location                                           
-------------------- ----- ---------------------------------------------------
DESTROY                  0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1511
_d                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1016
_d                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:117 
_d                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1352
_d                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1517
_d                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1747
_d                       0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:967 
_get_participants        0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:429 
_make_PID_file           0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1476
_remove_PID_file         0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1498
as_string                0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1172
check_PID_file           0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1435
clone                    0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:944 
copy                     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1334
daemonize                0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1398
descr                    0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:747 
errors                   0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:737 
fill_in_dsn              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1220
finish                   0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1741
get_defaults             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:475 
get_groups               0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:480 
get_hostname             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1307
loadavg                  0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:80  
make_PID_file            0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1466
new                      0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1380
num_locked               0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:72  
opt_values               0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:447 
opts                     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:441 
parse                    0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:998 
pretty_print             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1705
print_active_handles     0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1323
print_errors             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:771 
print_usage              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:781 
prompt                   0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:742 
prompt_noecho            0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:856 
read_para_after          0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:925 
save_error               0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:732 
set                      0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:723 
set_defaults             0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:463 
short_opts               0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:457 
slave_lag                0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:89  
trevorprice              0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:50  
usage                    0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1181
version_ge               0 /home/daniel/dev/maatkit/mk-loadavg/mk-loadavg:1005


