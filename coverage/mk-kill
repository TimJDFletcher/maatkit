---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...v/maatkit/mk-kill/mk-kill   50.0   33.5   31.5   62.5    n/a  100.0   44.1
Total                          50.0   33.5   31.5   62.5    n/a  100.0   44.1
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          mk-kill.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat Jul 18 16:40:28 2009
Finish:       Sat Jul 18 16:41:00 2009

Run:          mk-kill.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat Jul 18 16:40:28 2009
Finish:       Sat Jul 18 16:41:01 2009

/home/daniel/dev/maatkit/mk-kill/mk-kill

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-kill, a program that kills queries in MySQL.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22             2                    2            18   use strict;
               2                                  6   
               2                                 14   
23             2                    2            10   use warnings FATAL => 'all';
               2                                206   
               2                                 20   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 4191 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # OptionParser package 3945
31                                                    # ###########################################################################
32                                                    package OptionParser;
33                                                    
34             2                    2            12   use strict;
               2                                  4   
               2                                  8   
35             2                    2            10   use warnings FATAL => 'all';
               2                                  6   
               2                                  8   
36                                                    
37             2                    2            24   use Getopt::Long;
               2                                  6   
               2                                 14   
38             2                    2            14   use List::Util qw(max);
               2                                  4   
               2                                 22   
39             2                    2            12   use English qw(-no_match_vars);
               2                                  4   
               2                                 18   
40                                                    
41             2                    2            12   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  6   
               2                                 16   
42                                                    
43                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
44                                                    
45                                                    my %attributes = (
46                                                       'type'       => 1,
47                                                       'short form' => 1,
48                                                       'group'      => 1,
49                                                       'default'    => 1,
50                                                       'cumulative' => 1,
51                                                       'negatable'  => 1,
52                                                    );
53                                                    
54                                                    sub new {
55            14                   14           235      my ( $class, %args ) = @_;
56            14                                746      foreach my $arg ( qw(description) ) {
57    ***     14     50                         148         die "I need a $arg argument" unless $args{$arg};
58                                                       }
59            14                               5398      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
60    ***     14            50                   82      $program_name ||= $PROGRAM_NAME;
61                                                    
62    ***     14     50     50                  924      my $self = {
      ***                   50                        
63                                                          description    => $args{description},
64                                                          prompt         => $args{prompt} || '<options>',
65                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
66                                                          dp             => $args{dp}     || undef,
67                                                          program_name   => $program_name,
68                                                          opts           => {},
69                                                          got_opts       => 0,
70                                                          short_opts     => {},
71                                                          defaults       => {},
72                                                          groups         => {},
73                                                          allowed_groups => {},
74                                                          errors         => [],
75                                                          rules          => [],  # desc of rules for --help
76                                                          mutex          => [],  # rule: opts are mutually exclusive
77                                                          atleast1       => [],  # rule: at least one opt is required
78                                                          disables       => {},  # rule: opt disables other opts 
79                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
80                                                          default_files  => [
81                                                             "/etc/maatkit/maatkit.conf",
82                                                             "/etc/maatkit/$program_name.conf",
83                                                             "$ENV{HOME}/.maatkit.conf",
84                                                             "$ENV{HOME}/.$program_name.conf",
85                                                          ],
86                                                       };
87            14                                163      return bless $self, $class;
88                                                    }
89                                                    
90                                                    sub get_specs {
91            14                   14            83      my ( $self, $file ) = @_;
92            14                                129      my @specs = $self->_pod_to_specs($file);
93            14                                408      $self->_parse_specs(@specs);
94            14                                 99      return;
95                                                    }
96                                                    
97                                                    sub get_defaults_files {
98            14                   14            63      my ( $self ) = @_;
99            14                                 51      return @{$self->{default_files}};
              14                                187   
100                                                   }
101                                                   
102                                                   sub _pod_to_specs {
103           14                   14            69      my ( $self, $file ) = @_;
104   ***     14            50                   86      $file ||= __FILE__;
105   ***     14     50                         633      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
106                                                   
107           14                                332      my %types = (
108                                                         string => 's', # standard Getopt type
109                                                         'int'  => 'i', # standard Getopt type
110                                                         float  => 'f', # standard Getopt type
111                                                         Hash   => 'H', # hash, formed from a comma-separated list
112                                                         hash   => 'h', # hash as above, but only if a value is given
113                                                         Array  => 'A', # array, similar to Hash
114                                                         array  => 'a', # array, similar to hash
115                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
116                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
117                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
118                                                      );
119           14                                 80      my @specs = ();
120           14                                 54      my @rules = ();
121           14                                 51      my $para;
122                                                   
123           14                                128      local $INPUT_RECORD_SEPARATOR = '';
124           14                                512      while ( $para = <$fh> ) {
125         4186    100                       35521         next unless $para =~ m/^=head1 OPTIONS/;
126           14                                 76         last;
127                                                      }
128                                                   
129           14                                102      while ( $para = <$fh> ) {
130           28    100                         202         last if $para =~ m/^=over/;
131           14                                 75         chomp $para;
132           14                                160         $para =~ s/\s+/ /g;
133           14                              10511         $para =~ s/$POD_link_re/$1/go;
134           14                                 46         MKDEBUG && _d('Option rule:', $para);
135           14                                181         push @rules, $para;
136                                                      }
137                                                   
138   ***     14     50                          89      die 'POD has no OPTIONS section' unless $para;
139                                                   
140           14                                 56      do {
141          462    100                        3736         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
142          448                               1477            chomp $para;
143          448                               1076            MKDEBUG && _d($para);
144          448                               1187            my %attribs;
145                                                   
146          448                               2891            $para = <$fh>; # read next paragraph, possibly attributes
147                                                   
148          448    100                        2065            if ( $para =~ m/: / ) { # attributes
149          392                               2226               $para =~ s/\s+\Z//g;
150          686                               4521               %attribs = map {
151          392                               2766                     my ( $attrib, $val) = split(/: /, $_);
152   ***    686     50                        4228                     die "Unrecognized attribute for --$option: $attrib"
153                                                                        unless $attributes{$attrib};
154          686                               4830                     ($attrib, $val);
155                                                                  } split(/; /, $para);
156          392    100                        2165               if ( $attribs{'short form'} ) {
157           98                                597                  $attribs{'short form'} =~ s/-//;
158                                                               }
159          392                               2245               $para = <$fh>; # read next paragraph, probably short help desc
160                                                            }
161                                                            else {
162           56                                178               MKDEBUG && _d('Option has no attributes');
163                                                            }
164                                                   
165          448                               4180            $para =~ s/\s+\Z//g;
166          448                               4595            $para =~ s/\s+/ /g;
167          448                               2318            $para =~ s/$POD_link_re/$1/go;
168                                                   
169          448                               2222            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
170          448                               1143            MKDEBUG && _d('Short help:', $para);
171                                                   
172   ***    448     50                        2677            die "No description after option spec $option" if $para =~ m/^=item/;
173                                                   
174          448    100                        2817            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
175           28                                100               $option = $base_option;
176           28                                130               $attribs{'negatable'} = 1;
177                                                            }
178                                                   
179          448    100                       15279            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
                    100                               
180                                                               spec  => $option
181                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
182                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
183                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
184                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
185                                                               desc  => $para
186                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
187                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
188                                                            };
189                                                         }
190          462                               3374         while ( $para = <$fh> ) {
191   ***    658     50                        2723            last unless $para;
192                                                   
193                                                   
194          658    100                        2998            if ( $para =~ m/^=head1/ ) {
195           14                                 62               $para = undef; # Can't 'last' out of a do {} block.
196           14                                 85               last;
197                                                            }
198          644    100                        4954            last if $para =~ m/^=item --/;
199                                                         }
200                                                      } while ( $para );
201                                                   
202   ***     14     50                          72      die 'No valid specs in POD OPTIONS' unless @specs;
203                                                   
204           14                                241      close $fh;
205           14                                 60      return @specs, @rules;
206                                                   }
207                                                   
208                                                   sub _parse_specs {
209           14                   14           146      my ( $self, @specs ) = @_;
210           14                                 63      my %disables; # special rule that requires deferred checking
211                                                   
212           14                                 94      foreach my $opt ( @specs ) {
213          462    100                        1872         if ( ref $opt ) { # It's an option spec, not a rule.
214                                                            MKDEBUG && _d('Parsing opt spec:',
215          448                               1052               map { ($_, '=>', $opt->{$_}) } keys %$opt);
216                                                   
217          448                               4677            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
218   ***    448     50                        2424            if ( !$long ) {
219   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
220                                                            }
221          448                               1944            $opt->{long} = $long;
222                                                   
223   ***    448     50                        2468            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
224          448                               2445            $self->{opts}->{$long} = $opt;
225                                                   
226   ***    448     50                        2236            if ( length $long == 1 ) {
227   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
228   ***      0                                  0               $self->{short_opts}->{$long} = $long;
229                                                            }
230                                                   
231          448    100                        1813            if ( $short ) {
232   ***     98     50                         519               die "Duplicate short option -$short"
233                                                                  if exists $self->{short_opts}->{$short};
234           98                                476               $self->{short_opts}->{$short} = $long;
235           98                                395               $opt->{short} = $short;
236                                                            }
237                                                            else {
238          350                               2847               $opt->{short} = undef;
239                                                            }
240                                                   
241          448    100                        3544            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
242   ***    448     50                        3635            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
243   ***    448     50                        3541            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
244                                                   
245   ***    448            50                 2297            $opt->{group} ||= 'default';
246          448                               2586            $self->{groups}->{ $opt->{group} }->{$long} = 1;
247                                                   
248          448                               1909            $opt->{value} = undef;
249          448                               1632            $opt->{got}   = 0;
250                                                   
251          448                               2761            my ( $type ) = $opt->{spec} =~ m/=(.)/;
252          448                               1874            $opt->{type} = $type;
253          448                               1081            MKDEBUG && _d($long, 'type:', $type);
254                                                   
255   ***    448     50     66                 4566            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
256   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
257                                                                  . "was given when this OptionParser object was created";
258                                                            }
259                                                   
260          448    100    100                 4337            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
261                                                   
262          448    100                        3790            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
263           98    100                         480               if ( $opt->{is_negatable} ) {
264   ***     28      0                         149                  $def = $def eq 'yes' ? 1
      ***            50                               
265                                                                       : $def eq 'no'  ? 0
266                                                                       : $def;
267                                                               }
268   ***     98     50                         625               $self->{defaults}->{$long} = defined $def ? $def : 1;
269           98                                255               MKDEBUG && _d($long, 'default:', $def);
270                                                            }
271                                                   
272          448    100                        2325            if ( $long eq 'config' ) {
273           14                                101               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
274                                                            }
275                                                   
276   ***    448     50                        3404            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
277   ***      0                                  0               $disables{$long} = $dis;
278   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
279                                                            }
280                                                   
281          448                               3127            $self->{opts}->{$long} = $opt;
282                                                         }
283                                                         else { # It's an option rule, not a spec.
284           14                                 42            MKDEBUG && _d('Parsing rule:', $opt); 
285           14                                 49            push @{$self->{rules}}, $opt;
              14                                 96   
286           14                                136            my @participants = $self->_get_participants($opt);
287           14                                 57            my $rule_ok = 0;
288                                                   
289   ***     14     50                         168            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
290   ***      0                                  0               $rule_ok = 1;
291   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
292   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
293                                                            }
294   ***     14     50                         183            if ( $opt =~ m/at least one|one and only one/ ) {
295           14                                 50               $rule_ok = 1;
296           14                                 39               push @{$self->{atleast1}}, \@participants;
              14                                238   
297           14                                454               MKDEBUG && _d(@participants, 'require at least one');
298                                                            }
299   ***     14     50                         269            if ( $opt =~ m/default to/ ) {
300   ***      0                                  0               $rule_ok = 1;
301   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
302   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
303                                                            }
304   ***     14     50                         873            if ( $opt =~ m/restricted to option groups/ ) {
305   ***      0                                  0               $rule_ok = 1;
306   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
307   ***      0                                  0               my @groups = split(',', $groups);
308   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
309   ***      0                                  0                  s/\s+//;
310   ***      0                                  0                  $_ => 1;
311                                                               } @groups;
312                                                            }
313                                                   
314   ***     14     50                        1525            die "Unrecognized option rule: $opt" unless $rule_ok;
315                                                         }
316                                                      }
317                                                   
318           14                                269      foreach my $long ( keys %disables ) {
319   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
320   ***      0                                  0         $self->{disables}->{$long} = \@participants;
321   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
322                                                      }
323                                                   
324           14                                114      return; 
325                                                   }
326                                                   
327                                                   sub _get_participants {
328           14                   14            86      my ( $self, $str ) = @_;
329           14                                 51      my @participants;
330           14                                517      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
331   ***     42     50                        2119         die "Option --$long does not exist while processing rule $str"
332                                                            unless exists $self->{opts}->{$long};
333           42                               3605         push @participants, $long;
334                                                      }
335           14                                473      MKDEBUG && _d('Participants for', $str, ':', @participants);
336           14                                126      return @participants;
337                                                   }
338                                                   
339                                                   sub opts {
340   ***      0                    0             0      my ( $self ) = @_;
341   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
342   ***      0                                  0      return %opts;
343                                                   }
344                                                   
345                                                   sub opt_values {
346   ***      0                    0             0      my ( $self ) = @_;
347   ***      0      0                           0      my %opts = map {
348   ***      0                                  0         my $opt = $self->{opts}->{$_}->{short} ? $self->{opts}->{$_}->{short}
349                                                                 : $_;
350   ***      0                                  0         $opt => $self->{opts}->{$_}->{value}
351   ***      0                                  0      } keys %{$self->{opts}};
352   ***      0                                  0      return %opts;
353                                                   }
354                                                   
355                                                   sub short_opts {
356   ***      0                    0             0      my ( $self ) = @_;
357   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
358   ***      0                                  0      return %short_opts;
359                                                   }
360                                                   
361                                                   sub set_defaults {
362   ***      0                    0             0      my ( $self, %defaults ) = @_;
363   ***      0                                  0      $self->{defaults} = {};
364   ***      0                                  0      foreach my $long ( keys %defaults ) {
365   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
366                                                            unless exists $self->{opts}->{$long};
367   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
368   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
369                                                      }
370   ***      0                                  0      return;
371                                                   }
372                                                   
373                                                   sub get_defaults {
374   ***      0                    0             0      my ( $self ) = @_;
375   ***      0                                  0      return $self->{defaults};
376                                                   }
377                                                   
378                                                   sub get_groups {
379   ***      0                    0             0      my ( $self ) = @_;
380   ***      0                                  0      return $self->{groups};
381                                                   }
382                                                   
383                                                   sub _set_option {
384           45                   45           245      my ( $self, $opt, $val ) = @_;
385   ***     45      0                         128      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
386                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
387                                                               : die "Getopt::Long gave a nonexistent option: $opt";
388                                                   
389           45                                108      $opt = $self->{opts}->{$long};
390   ***     45     50                         311      if ( $opt->{is_cumulative} ) {
391   ***      0                                  0         $opt->{value}++;
392                                                      }
393                                                      else {
394           45                                208         $opt->{value} = $val;
395                                                      }
396           45                                178      $opt->{got} = 1;
397           45                                203      MKDEBUG && _d('Got option', $long, '=', $val);
398                                                   }
399                                                   
400                                                   sub get_opts {
401           14                   14            66      my ( $self ) = @_; 
402                                                   
403           14                                 52      foreach my $long ( keys %{$self->{opts}} ) {
              14                                218   
404          448                               2250         $self->{opts}->{$long}->{got} = 0;
405   ***    448     50                        4188         $self->{opts}->{$long}->{value}
                    100                               
406                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
407                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
408                                                            : undef;
409                                                      }
410           14                                 94      $self->{got_opts} = 0;
411                                                   
412           14                                 77      $self->{errors} = [];
413                                                   
414   ***     14     50     33                  232      if ( @ARGV && $ARGV[0] eq "--config" ) {
415   ***      0                                  0         shift @ARGV;
416   ***      0                                  0         $self->_set_option('config', shift @ARGV);
417                                                      }
418   ***     14     50                         167      if ( $self->has('config') ) {
419           14                                 47         my @extra_args;
420           14                                113         foreach my $filename ( split(',', $self->get('config')) ) {
421           56                                174            eval {
422           56                                397               push @ARGV, $self->_read_config_file($filename);
423                                                            };
424   ***     56     50                         355            if ( $EVAL_ERROR ) {
425   ***     56     50                         816               if ( $self->got('config') ) {
426   ***      0                                  0                  die $EVAL_ERROR;
427                                                               }
428                                                               elsif ( MKDEBUG ) {
429                                                                  _d($EVAL_ERROR);
430                                                               }
431                                                            }
432                                                         }
433           14                                110         unshift @ARGV, @extra_args;
434                                                      }
435                                                   
436           14                                190      Getopt::Long::Configure('no_ignore_case', 'bundling');
437                                                      GetOptions(
438          434                   45          3480         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              45                                302   
             448                               2101   
439           14                                125         grep   { $_->{long} ne 'config' } # --config is handled specially above.
440   ***     14     50                          59         values %{$self->{opts}}
441                                                      ) or $self->save_error('Error parsing options');
442                                                   
443   ***     14     50     33                 1025      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
444   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
445                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
446                                                               or die "Cannot print: $OS_ERROR";
447   ***      0                                  0         exit 0;
448                                                      }
449                                                   
450   ***     14     50     66                  179      if ( @ARGV && $self->{strict} ) {
451   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
452                                                      }
453                                                   
454           14                                 49      foreach my $mutex ( @{$self->{mutex}} ) {
              14                                105   
455   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
456   ***      0      0                           0         if ( @set > 1 ) {
457   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
458   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
459                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
460                                                                    . ' are mutually exclusive.';
461   ***      0                                  0            $self->save_error($err);
462                                                         }
463                                                      }
464                                                   
465           14                                 45      foreach my $required ( @{$self->{atleast1}} ) {
              14                                 99   
466           14                                 74         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
              42                                285   
467   ***     14     50                          96         if ( @set == 0 ) {
468   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
469   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
470                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
471   ***      0                                  0            $self->save_error("Specify at least one of $err");
472                                                         }
473                                                      }
474                                                   
475           14                                 51      foreach my $long ( keys %{$self->{opts}} ) {
              14                                176   
476          448                               2464         my $opt = $self->{opts}->{$long};
477          448    100                        7766         if ( $opt->{got} ) {
      ***            50                               
478   ***     45     50                         246            if ( exists $self->{disables}->{$long} ) {
479   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
480   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
481   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
482                                                                  'because', $long,'disables them');
483                                                            }
484                                                   
485   ***     45     50                         277            if ( exists $self->{allowed_groups}->{$long} ) {
486                                                   
487   ***      0                                  0               my @restricted_groups = grep {
488   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
489   ***      0                                  0               } keys %{$self->{groups}};
490                                                   
491   ***      0                                  0               my @restricted_opts;
492   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
493   ***      0                                  0                  RESTRICTED_OPT:
494   ***      0                                  0                  foreach my $restricted_opt (
495                                                                     keys %{$self->{groups}->{$restricted_group}} )
496                                                                  {
497   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
498   ***      0      0                           0                     push @restricted_opts, $restricted_opt
499                                                                        if $self->{opts}->{$restricted_opt}->{got};
500                                                                  }
501                                                               }
502                                                   
503   ***      0      0                           0               if ( @restricted_opts ) {
504   ***      0                                  0                  my $err;
505   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
506   ***      0                                  0                     $err = "--$restricted_opts[0]";
507                                                                  }
508                                                                  else {
509   ***      0                                  0                     $err = join(', ',
510   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
511   ***      0                                  0                               grep { $_ } 
512                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
513                                                                            )
514                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
515                                                                  }
516   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
517                                                               }
518                                                            }
519                                                   
520                                                         }
521                                                         elsif ( $opt->{is_required} ) { 
522   ***      0                                  0            $self->save_error("Required option --$long must be specified");
523                                                         }
524                                                   
525          448                               1942         $self->_validate_type($opt);
526                                                      }
527                                                   
528           14                                113      $self->{got_opts} = 1;
529           14                                 53      return;
530                                                   }
531                                                   
532                                                   sub _validate_type {
533          448                  448          1779      my ( $self, $opt ) = @_;
534   ***    448    100     66                 5821      return unless $opt && $opt->{type};
535          336                               1311      my $val = $opt->{value};
536                                                   
537          336    100    100                10286      if ( $val && $opt->{type} eq 'm' ) {
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
538            8                                 22         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
539            8                                131         my ( $num, $suffix ) = $val =~ m/(\d+)([a-z])?$/;
540            8    100                          61         if ( !$suffix ) {
541            2                                 15            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
542   ***      2            50                   20            $suffix = $s || 's';
543            2                                  6            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
544                                                               $opt->{long}, '(value:', $val, ')');
545                                                         }
546   ***      8     50                         114         if ( $suffix =~ m/[smhd]/ ) {
547   ***      8      0                          45            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***            50                               
548                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
549                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
550                                                                 :                  $num * 86400;   # Days
551            8                                 34            $opt->{value} = $val;
552            8                                 29            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
553                                                         }
554                                                         else {
555   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
556                                                         }
557                                                      }
558                                                      elsif ( $val && $opt->{type} eq 'd' ) {
559   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
560   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
561   ***      0                                  0         my $default = {};
562   ***      0      0                           0         if ( $from_key ) {
563   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
564   ***      0                                  0            $default = $self->{dp}->parse(
565                                                               $self->{dp}->as_string($self->{opts}->{$from_key}->{value}) );
566                                                         }
567   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $default);
568                                                      }
569                                                      elsif ( $val && $opt->{type} eq 'z' ) {
570   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
571   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
572   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
573   ***      0      0                           0         if ( defined $num ) {
574   ***      0      0                           0            if ( $factor ) {
575   ***      0                                  0               $num *= $factor_for{$factor};
576   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
577                                                                  'to num', $num, '* factor', $factor);
578                                                            }
579   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
580                                                         }
581                                                         else {
582   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
583                                                         }
584                                                      }
585                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
586   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
587                                                      }
588                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
589   ***     14            50                  276         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
590                                                      }
591                                                      else {
592          314                                817         MKDEBUG && _d('Nothing to validate for option',
593                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
594                                                      }
595                                                   
596          336                               1319      return;
597                                                   }
598                                                   
599                                                   sub get {
600          460                  460          2718      my ( $self, $opt ) = @_;
601          460    100                        2822      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
602   ***    460     50     33                 7744      die "Option $opt does not exist"
603                                                         unless $long && exists $self->{opts}->{$long};
604          460                             60015218      return $self->{opts}->{$long}->{value};
605                                                   }
606                                                   
607                                                   sub got {
608           84                   84           440      my ( $self, $opt ) = @_;
609   ***     84     50                         454      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
610   ***     84     50     33                  986      die "Option $opt does not exist"
611                                                         unless $long && exists $self->{opts}->{$long};
612           84                                706      return $self->{opts}->{$long}->{got};
613                                                   }
614                                                   
615                                                   sub has {
616           46                   46           252      my ( $self, $opt ) = @_;
617           46    100                         321      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
618           46    100                         535      return defined $long ? exists $self->{opts}->{$long} : 0;
619                                                   }
620                                                   
621                                                   sub set {
622           24                   24           136      my ( $self, $opt, $val ) = @_;
623   ***     24     50                         123      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
624   ***     24     50     33                  287      die "Option $opt does not exist"
625                                                         unless $long && exists $self->{opts}->{$long};
626           24                                120      $self->{opts}->{$long}->{value} = $val;
627           24                                 80      return;
628                                                   }
629                                                   
630                                                   sub save_error {
631   ***      0                    0             0      my ( $self, $error ) = @_;
632   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
633                                                   }
634                                                   
635                                                   sub errors {
636   ***      0                    0             0      my ( $self ) = @_;
637   ***      0                                  0      return $self->{errors};
638                                                   }
639                                                   
640                                                   sub prompt {
641   ***      0                    0             0      my ( $self ) = @_;
642   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
643                                                   }
644                                                   
645                                                   sub descr {
646   ***      0                    0             0      my ( $self ) = @_;
647   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
648                                                                 . "  For more details, please use the --help option, "
649                                                                 . "or try 'perldoc $PROGRAM_NAME' "
650                                                                 . "for complete documentation.";
651   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
652   ***      0                                  0      $descr =~ s/ +$//mg;
653   ***      0                                  0      return $descr;
654                                                   }
655                                                   
656                                                   sub usage_or_errors {
657           14                   14            64      my ( $self ) = @_;
658   ***     14     50                          97      if ( $self->{opts}->{help}->{got} ) {
      ***     14     50                          91   
659   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
660   ***      0                                  0         exit 0;
661                                                      }
662                                                      elsif ( scalar @{$self->{errors}} ) {
663   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
664   ***      0                                  0         exit 0;
665                                                      }
666           14                                 40      return;
667                                                   }
668                                                   
669                                                   sub print_errors {
670   ***      0                    0             0      my ( $self ) = @_;
671   ***      0                                  0      my $usage = $self->prompt() . "\n";
672   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
673   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
674                                                                 . "\n";
675                                                      }
676   ***      0                                  0      return $usage . "\n" . $self->descr();
677                                                   }
678                                                   
679                                                   sub print_usage {
680   ***      0                    0             0      my ( $self ) = @_;
681   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
682   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
683                                                   
684   ***      0      0                           0      my $maxl = max(
685   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
686                                                         @opts);
687                                                   
688   ***      0      0                           0      my $maxs = max(0,
689   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
690   ***      0                                  0         values %{$self->{short_opts}});
691                                                   
692   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
693   ***      0                                  0      my $rcol = 80 - $lcol - 6;
694   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
695                                                   
696   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
697                                                   
698   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
699                                                   
700   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
701   ***      0                                  0      push @groups, 'default';
702                                                   
703   ***      0                                  0      foreach my $group ( reverse @groups ) {
704   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
705   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
706   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
707                                                            grep { $_->{group} eq $group }
708                                                            @opts )
709                                                         {
710   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
711   ***      0                                  0            my $short = $opt->{short};
712   ***      0                                  0            my $desc  = $opt->{desc};
713   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
714   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
715   ***      0             0                    0               $s    ||= 's';
716   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
717   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
718                                                                      . "d=days; if no suffix, $s is used.";
719                                                            }
720   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
721   ***      0                                  0            $desc =~ s/ +$//mg;
722   ***      0      0                           0            if ( $short ) {
723   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
724                                                            }
725                                                            else {
726   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
727                                                            }
728                                                         }
729                                                      }
730                                                   
731   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
732   ***      0                                  0         $usage .= "\nRules:\n\n";
733   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
734                                                      }
735   ***      0      0                           0      if ( $self->{dp} ) {
736   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
737                                                      }
738   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
739   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
740   ***      0                                  0         my $val   = $opt->{value};
741   ***      0             0                    0         my $type  = $opt->{type} || '';
742   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
743   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
744                                                                   : !defined $val             ? '(No value)'
745                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
746                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
747                                                                   : $type =~ m/A|a/           ? join(',', @$val)
748                                                                   :                             $val;
749   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
750                                                      }
751   ***      0                                  0      return $usage;
752                                                   }
753                                                   
754                                                   sub prompt_noecho {
755   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
756   ***      0                                  0      my ( $prompt ) = @_;
757   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
758   ***      0      0                           0      print $prompt
759                                                         or die "Cannot print: $OS_ERROR";
760   ***      0                                  0      my $response;
761   ***      0                                  0      eval {
762   ***      0                                  0         require Term::ReadKey;
763   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
764   ***      0                                  0         chomp($response = <STDIN>);
765   ***      0                                  0         Term::ReadKey::ReadMode('normal');
766   ***      0      0                           0         print "\n"
767                                                            or die "Cannot print: $OS_ERROR";
768                                                      };
769   ***      0      0                           0      if ( $EVAL_ERROR ) {
770   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
771                                                      }
772   ***      0                                  0      return $response;
773                                                   }
774                                                   
775                                                   if ( MKDEBUG ) {
776                                                      print '# ', $^X, ' ', $], "\n";
777                                                      my $uname = `uname -a`;
778                                                      if ( $uname ) {
779                                                         $uname =~ s/\s+/ /g;
780                                                         print "# $uname\n";
781                                                      }
782                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
783                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
784                                                         ($main::SVN_REV || ''), __LINE__);
785                                                      print('# Arguments: ',
786                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
787                                                   }
788                                                   
789                                                   sub _read_config_file {
790           56                   56           286      my ( $self, $filename ) = @_;
791   ***     56     50                         169      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
792   ***      0                                  0      my @args;
793   ***      0                                  0      my $prefix = '--';
794   ***      0                                  0      my $parse  = 1;
795                                                   
796                                                      LINE:
797   ***      0                                  0      while ( my $line = <$fh> ) {
798   ***      0                                  0         chomp $line;
799   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
800   ***      0                                  0         $line =~ s/\s+#.*$//g;
801   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
802   ***      0      0                           0         if ( $line eq '--' ) {
803   ***      0                                  0            $prefix = '';
804   ***      0                                  0            $parse  = 0;
805   ***      0                                  0            next LINE;
806                                                         }
807   ***      0      0      0                    0         if ( $parse
      ***             0                               
808                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
809                                                         ) {
810   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
811                                                         }
812                                                         elsif ( $line =~ m/./ ) {
813   ***      0                                  0            push @args, $line;
814                                                         }
815                                                         else {
816   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
817                                                         }
818                                                      }
819   ***      0                                  0      close $fh;
820   ***      0                                  0      return @args;
821                                                   }
822                                                   
823                                                   sub read_para_after {
824   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
825   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
826   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
827   ***      0                                  0      my $para;
828   ***      0                                  0      while ( $para = <$fh> ) {
829   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
830   ***      0                                  0         last;
831                                                      }
832   ***      0                                  0      while ( $para = <$fh> ) {
833   ***      0      0                           0         next unless $para =~ m/$regex/;
834   ***      0                                  0         last;
835                                                      }
836   ***      0                                  0      $para = <$fh>;
837   ***      0                                  0      chomp($para);
838   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
839   ***      0                                  0      return $para;
840                                                   }
841                                                   
842                                                   sub clone {
843   ***      0                    0             0      my ( $self ) = @_;
844                                                   
845   ***      0                                  0      my %clone = map {
846   ***      0                                  0         my $hashref  = $self->{$_};
847   ***      0                                  0         my $val_copy = {};
848   ***      0                                  0         foreach my $key ( keys %$hashref ) {
849   ***      0                                  0            my $ref = ref $hashref->{$key};
850   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
851   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
852   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
853                                                                              : $hashref->{$key};
854                                                         }
855   ***      0                                  0         $_ => $val_copy;
856                                                      } qw(opts short_opts defaults);
857                                                   
858   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
859   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
860                                                      }
861                                                   
862   ***      0                                  0      return bless \%clone;     
863                                                   }
864                                                   
865                                                   sub _d {
866   ***      0                    0             0      my ($package, undef, $line) = caller 0;
867   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
868   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
869                                                           @_;
870   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
871                                                   }
872                                                   
873                                                   1;
874                                                   
875                                                   # ###########################################################################
876                                                   # End OptionParser package
877                                                   # ###########################################################################
878                                                   
879                                                   # ###########################################################################
880                                                   # VersionParser package 3186
881                                                   # ###########################################################################
882                                                   package VersionParser;
883                                                   
884            2                    2            22   use strict;
               2                                 12   
               2                                 18   
885            2                    2            12   use warnings FATAL => 'all';
               2                                  6   
               2                                 22   
886                                                   
887            2                    2            12   use English qw(-no_match_vars);
               2                                  4   
               2                                 12   
888                                                   
889            2                    2            12   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  4   
               2                                 18   
890                                                   
891                                                   sub new {
892           14                   14            97      my ( $class ) = @_;
893           14                                121      bless {}, $class;
894                                                   }
895                                                   
896                                                   sub parse {
897   ***      0                    0             0      my ( $self, $str ) = @_;
898   ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
899   ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
900   ***      0                                  0      return $result;
901                                                   }
902                                                   
903                                                   sub version_ge {
904   ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
905   ***      0      0                           0      if ( !$self->{$dbh} ) {
906   ***      0                                  0         $self->{$dbh} = $self->parse(
907                                                            $dbh->selectrow_array('SELECT VERSION()'));
908                                                      }
909   ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
910   ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
911   ***      0                                  0      return $result;
912                                                   }
913                                                   
914                                                   sub _d {
915   ***      0                    0             0      my ($package, undef, $line) = caller 0;
916   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
917   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
918                                                           @_;
919   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
920                                                   }
921                                                   
922                                                   1;
923                                                   
924                                                   # ###########################################################################
925                                                   # End VersionParser package
926                                                   # ###########################################################################
927                                                   
928                                                   # ###########################################################################
929                                                   # DSNParser package 4103
930                                                   # ###########################################################################
931            2                    2            12   use strict;
               2                                  6   
               2                                  8   
932            2                    2            12   use warnings FATAL => 'all';
               2                                  4   
               2                                 10   
933                                                   
934                                                   package DSNParser;
935                                                   
936            2                    2            28   use DBI;
               2                                  8   
               2                                 22   
937            2                    2            16   use Data::Dumper;
               2                                  4   
               2                                 20   
938                                                   $Data::Dumper::Indent    = 0;
939                                                   $Data::Dumper::Quotekeys = 0;
940            2                    2            12   use English qw(-no_match_vars);
               2                                  4   
               2                                 18   
941                                                   
942            2                    2            14   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  6   
               2                                 26   
943                                                   
944                                                   sub new {
945           14                   14            98      my ( $class, @opts ) = @_;
946           14                                934      my $self = {
947                                                         opts => {
948                                                            A => {
949                                                               desc => 'Default character set',
950                                                               dsn  => 'charset',
951                                                               copy => 1,
952                                                            },
953                                                            D => {
954                                                               desc => 'Database to use',
955                                                               dsn  => 'database',
956                                                               copy => 1,
957                                                            },
958                                                            F => {
959                                                               desc => 'Only read default options from the given file',
960                                                               dsn  => 'mysql_read_default_file',
961                                                               copy => 1,
962                                                            },
963                                                            h => {
964                                                               desc => 'Connect to host',
965                                                               dsn  => 'host',
966                                                               copy => 1,
967                                                            },
968                                                            p => {
969                                                               desc => 'Password to use when connecting',
970                                                               dsn  => 'password',
971                                                               copy => 1,
972                                                            },
973                                                            P => {
974                                                               desc => 'Port number to use for connection',
975                                                               dsn  => 'port',
976                                                               copy => 1,
977                                                            },
978                                                            S => {
979                                                               desc => 'Socket file to use for connection',
980                                                               dsn  => 'mysql_socket',
981                                                               copy => 1,
982                                                            },
983                                                            u => {
984                                                               desc => 'User for login if not current user',
985                                                               dsn  => 'user',
986                                                               copy => 1,
987                                                            },
988                                                         },
989                                                      };
990           14                                 93      foreach my $opt ( @opts ) {
991   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
992   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
993                                                      }
994           14                                139      return bless $self, $class;
995                                                   }
996                                                   
997                                                   sub prop {
998           12                   12            94      my ( $self, $prop, $value ) = @_;
999   ***     12     50                          80      if ( @_ > 2 ) {
1000  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1001  ***      0                                  0         $self->{$prop} = $value;
1002                                                     }
1003          12                                120      return $self->{$prop};
1004                                                  }
1005                                                  
1006                                                  sub parse {
1007           4                    4            28      my ( $self, $dsn, $prev, $defaults ) = @_;
1008  ***      4     50                          28      if ( !$dsn ) {
1009  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1010  ***      0                                  0         return;
1011                                                     }
1012           4                                 12      MKDEBUG && _d('Parsing', $dsn);
1013  ***      4            50                   28      $prev     ||= {};
1014  ***      4            50                   22      $defaults ||= {};
1015           4                                 16      my %given_props;
1016           4                                 14      my %final_props;
1017           4                                 14      my %opts = %{$self->{opts}};
               4                                 78   
1018                                                  
1019           4                                 66      foreach my $dsn_part ( split(/,/, $dsn) ) {
1020  ***      8     50                         120         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1021           8                                 54            $given_props{$prop_key} = $prop_val;
1022                                                        }
1023                                                        else {
1024  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1025  ***      0                                  0            $given_props{h} = $dsn_part;
1026                                                        }
1027                                                     }
1028                                                  
1029           4                                 30      foreach my $key ( keys %opts ) {
1030          32                                 88         MKDEBUG && _d('Finding value for', $key);
1031          32                                140         $final_props{$key} = $given_props{$key};
1032  ***     32     50     66                  390         if (   !defined $final_props{$key}
      ***                   33                        
1033                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1034                                                        {
1035  ***      0                                  0            $final_props{$key} = $prev->{$key};
1036  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1037                                                        }
1038          32    100                         186         if ( !defined $final_props{$key} ) {
1039          24                                 98            $final_props{$key} = $defaults->{$key};
1040          24                                 92            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1041                                                        }
1042                                                     }
1043                                                  
1044           4                                 26      foreach my $key ( keys %given_props ) {
1045  ***      8     50                          50         die "Unrecognized DSN part '$key' in '$dsn'\n"
1046                                                           unless exists $opts{$key};
1047                                                     }
1048  ***      4     50                         158      if ( (my $required = $self->prop('required')) ) {
1049  ***      0                                  0         foreach my $key ( keys %$required ) {
1050  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1051                                                        }
1052                                                     }
1053                                                  
1054           4                                 42      return \%final_props;
1055                                                  }
1056                                                  
1057                                                  sub parse_options {
1058           4                    4            22      my ( $self, $o ) = @_;
1059  ***      4     50                          28      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1060           8                                 54      my $dsn_string
1061                                                        = join(',',
1062          32    100                         166             map  { "$_=".$o->get($_); }
1063           4                                 40             grep { $o->has($_) && $o->get($_) }
1064           4                                 18             keys %{$self->{opts}}
1065                                                          );
1066           4                                 26      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1067           4                                 68      return $self->parse($dsn_string);
1068                                                  }
1069                                                  
1070                                                  sub as_string {
1071  ***      0                    0             0      my ( $self, $dsn ) = @_;
1072  ***      0      0                           0      return $dsn unless ref $dsn;
1073  ***      0      0                           0      return join(',',
1074  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1075  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1076                                                        sort keys %$dsn );
1077                                                  }
1078                                                  
1079                                                  sub usage {
1080  ***      0                    0             0      my ( $self ) = @_;
1081  ***      0                                  0      my $usage
1082                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1083                                                        . "  KEY  COPY  MEANING\n"
1084                                                        . "  ===  ====  =============================================\n";
1085  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1086  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1087  ***      0      0      0                    0         $usage .= "  $key    "
1088                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1089                                                               .  ($opts{$key}->{desc} || '[No description]')
1090                                                               . "\n";
1091                                                     }
1092  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1093  ***      0                                  0      return $usage;
1094                                                  }
1095                                                  
1096                                                  sub get_cxn_params {
1097           4                    4            22      my ( $self, $info ) = @_;
1098           4                                 12      my $dsn;
1099           4                                 14      my %opts = %{$self->{opts}};
               4                                 48   
1100  ***      4            50                   30      my $driver = $self->prop('dbidriver') || '';
1101  ***      4     50                          26      if ( $driver eq 'Pg' ) {
1102  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1103  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1104  ***      0             0                    0                        grep { defined $info->{$_} }
1105                                                                       qw(h P));
1106                                                     }
1107                                                     else {
1108           8                                 72         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1109          20                                 98            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1110  ***      4            50                   68                        grep { defined $info->{$_} }
1111                                                                       qw(F h P S A))
1112                                                           . ';mysql_read_default_group=client';
1113                                                     }
1114           4                                 14      MKDEBUG && _d($dsn);
1115           4                                 80      return ($dsn, $info->{u}, $info->{p});
1116                                                  }
1117                                                  
1118                                                  sub fill_in_dsn {
1119  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1120  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1121  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1122  ***      0                                  0      $user =~ s/@.*//;
1123  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1124  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1125  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1126  ***      0             0                    0      $dsn->{u} ||= $user;
1127  ***      0             0                    0      $dsn->{D} ||= $db;
1128                                                  }
1129                                                  
1130                                                  sub get_dbh {
1131           4                    4            36      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1132  ***      4            50                   28      $opts ||= {};
1133  ***      4     50                          62      my $defaults = {
1134                                                        AutoCommit         => 0,
1135                                                        RaiseError         => 1,
1136                                                        PrintError         => 0,
1137                                                        ShowErrorStatement => 1,
1138                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1139                                                     };
1140           4                                 26      @{$defaults}{ keys %$opts } = values %$opts;
               4                                 22   
1141                                                  
1142           4                                 14      my $dbh;
1143           4                                 12      my $tries = 2;
1144  ***      4            66                   60      while ( !$dbh && $tries-- ) {
1145                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1146           4                                 12            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1147                                                  
1148           4                                 18         eval {
1149           4                                 86            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1150                                                  
1151  ***      4     50                          66            if ( $cxn_string =~ m/mysql/i ) {
1152           4                                 20               my $sql;
1153                                                  
1154           4                                 22               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1155                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1156           4                                 10               MKDEBUG && _d($dbh, ':', $sql);
1157           4                                732               $dbh->do($sql);
1158                                                  
1159  ***      4     50                          64               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1160  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1161  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1162  ***      0                                  0                  $dbh->do($sql);
1163  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1164  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1165  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1166                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1167                                                                 }
1168                                                                 else {
1169  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1170                                                                 }
1171                                                              }
1172                                                  
1173  ***      4     50                          36               if ( $self->prop('setvars') ) {
1174  ***      0                                  0                  $sql = "SET " . $self->prop('setvars');
1175  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1176  ***      0                                  0                  $dbh->do($sql);
1177                                                              }
1178                                                           }
1179                                                        };
1180  ***      4     50     33                   56         if ( !$dbh && $EVAL_ERROR ) {
1181  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1182  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
1183  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1184  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1185                                                           }
1186  ***      0      0                           0            if ( !$tries ) {
1187  ***      0                                  0               die $EVAL_ERROR;
1188                                                           }
1189                                                        }
1190                                                     }
1191                                                  
1192           4                                 12      MKDEBUG && _d('DBH info: ',
1193                                                        $dbh,
1194                                                        Dumper($dbh->selectrow_hashref(
1195                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1196                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1197                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1198                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1199                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1200                                                        '$DBI::VERSION:',        $DBI::VERSION,
1201                                                     );
1202                                                  
1203           4                                 36      return $dbh;
1204                                                  }
1205                                                  
1206                                                  sub get_hostname {
1207  ***      0                    0             0      my ( $self, $dbh ) = @_;
1208  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1209  ***      0                                  0         return $host;
1210                                                     }
1211  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1212                                                        'SELECT /*!50038 @@hostname, */ 1');
1213  ***      0                                  0      return $hostname;
1214                                                  }
1215                                                  
1216                                                  sub disconnect {
1217  ***      0                    0             0      my ( $self, $dbh ) = @_;
1218  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1219  ***      0                                  0      $dbh->disconnect;
1220                                                  }
1221                                                  
1222                                                  sub print_active_handles {
1223  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1224  ***      0             0                    0      $level ||= 0;
1225  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1226                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1227                                                        or die "Cannot print: $OS_ERROR";
1228  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1229  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1230                                                     }
1231                                                  }
1232                                                  
1233                                                  sub copy {
1234  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1235  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1236  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1237  ***      0                                  0      my %new_dsn = map {
1238  ***      0                                  0         my $key = $_;
1239  ***      0                                  0         my $val;
1240  ***      0      0                           0         if ( $args{overwrite} ) {
1241  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1242                                                        }
1243                                                        else {
1244  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1245                                                        }
1246  ***      0                                  0         $key => $val;
1247  ***      0                                  0      } keys %{$self->{opts}};
1248  ***      0                                  0      return \%new_dsn;
1249                                                  }
1250                                                  
1251                                                  sub _d {
1252  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1253  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1254  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1255                                                          @_;
1256  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1257                                                  }
1258                                                  
1259                                                  1;
1260                                                  
1261                                                  # ###########################################################################
1262                                                  # End DSNParser package
1263                                                  # ###########################################################################
1264                                                  
1265                                                  # ###########################################################################
1266                                                  # Daemon package 3976
1267                                                  # ###########################################################################
1268                                                  
1269                                                  package Daemon;
1270                                                  
1271           2                    2            18   use strict;
               2                                  6   
               2                                 14   
1272           2                    2            12   use warnings FATAL => 'all';
               2                                  6   
               2                                 24   
1273                                                  
1274           2                    2            26   use POSIX qw(setsid);
               2                                  6   
               2                                 16   
1275           2                    2            12   use English qw(-no_match_vars);
               2                                  6   
               2                                 14   
1276                                                  
1277           2                    2            14   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  6   
               2                                 22   
1278                                                  
1279                                                  sub new {
1280  ***      0                    0             0      my ( $class, %args ) = @_;
1281  ***      0                                  0      foreach my $arg ( qw(o) ) {
1282  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1283                                                     }
1284  ***      0                                  0      my $o = $args{o};
1285  ***      0      0                           0      my $self = {
      ***             0                               
1286                                                        o        => $o,
1287                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1288                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1289                                                     };
1290                                                  
1291  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1292                                                  
1293  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1294  ***      0                                  0      return bless $self, $class;
1295                                                  }
1296                                                  
1297                                                  sub daemonize {
1298  ***      0                    0             0      my ( $self ) = @_;
1299                                                  
1300  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1301  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1302  ***      0      0                           0      if ( $pid ) {
1303  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1304  ***      0                                  0         exit;
1305                                                     }
1306                                                  
1307  ***      0                                  0      $self->{child} = 1;
1308                                                  
1309  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1310  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1311                                                  
1312  ***      0                                  0      $self->_make_PID_file();
1313                                                  
1314  ***      0      0                           0      if ( -t STDIN ) {
1315  ***      0                                  0         close STDIN;
1316  ***      0      0                           0         open  STDIN, '/dev/null'
1317                                                           or die "Cannot reopen STDIN to /dev/null";
1318                                                     }
1319                                                  
1320  ***      0      0                           0      if ( $self->{log_file} ) {
1321  ***      0                                  0         close STDOUT;
1322  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1323                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1324                                                  
1325  ***      0                                  0         close STDERR;
1326  ***      0      0                           0         open  STDERR, ">&STDOUT"
1327                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR";
1328                                                     }
1329                                                  
1330  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1331  ***      0                                  0      return;
1332                                                  }
1333                                                  
1334                                                  sub check_PID_file {
1335  ***      0                    0             0      my ( $self, $file ) = @_;
1336  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1337  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1338  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1339  ***      0                                  0         my $pid;
1340  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1341  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1342  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1343  ***      0      0                           0         if ( $pid ) {
1344  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1345  ***      0      0                           0            if ( $pid_is_alive ) {
1346  ***      0                                  0               die "The PID file $PID_file already exists "
1347                                                                 . " and the PID that it contains, $pid, is running";
1348                                                           }
1349                                                           else {
1350  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1351                                                                 . "contains, $pid, is not running";
1352                                                           }
1353                                                        }
1354                                                        else {
1355  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1356                                                              . "contain a PID";
1357                                                        }
1358                                                     }
1359                                                     else {
1360  ***      0                                  0         MKDEBUG && _d('No PID file');
1361                                                     }
1362  ***      0                                  0      return;
1363                                                  }
1364                                                  
1365                                                  sub make_PID_file {
1366  ***      0                    0             0      my ( $self ) = @_;
1367  ***      0      0                           0      if ( exists $self->{child} ) {
1368  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1369                                                     }
1370  ***      0                                  0      $self->_make_PID_file();
1371  ***      0                                  0      $self->{rm_PID_file} = 1;
1372  ***      0                                  0      return;
1373                                                  }
1374                                                  
1375                                                  sub _make_PID_file {
1376  ***      0                    0             0      my ( $self ) = @_;
1377                                                  
1378  ***      0                                  0      my $PID_file = $self->{PID_file};
1379  ***      0      0                           0      if ( !$PID_file ) {
1380  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1381  ***      0                                  0         return;
1382                                                     }
1383                                                  
1384  ***      0                                  0      $self->check_PID_file();
1385                                                  
1386  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1387                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1388  ***      0      0                           0      print $PID_FH $PID
1389                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1390  ***      0      0                           0      close $PID_FH
1391                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1392                                                  
1393  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1394  ***      0                                  0      return;
1395                                                  }
1396                                                  
1397                                                  sub _remove_PID_file {
1398  ***      0                    0             0      my ( $self ) = @_;
1399  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1400  ***      0      0                           0         unlink $self->{PID_file}
1401                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1402  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1403                                                     }
1404                                                     else {
1405  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1406                                                     }
1407  ***      0                                  0      return;
1408                                                  }
1409                                                  
1410                                                  sub DESTROY {
1411  ***      0                    0             0      my ( $self ) = @_;
1412  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1413  ***      0                                  0      return;
1414                                                  }
1415                                                  
1416                                                  sub _d {
1417  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1418  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1419  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1420                                                          @_;
1421  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1422                                                  }
1423                                                  
1424                                                  1;
1425                                                  
1426                                                  # ###########################################################################
1427                                                  # End Daemon package
1428                                                  # ###########################################################################
1429                                                  
1430                                                  # ###########################################################################
1431                                                  # Transformers package 3972
1432                                                  # ###########################################################################
1433                                                  
1434                                                  package Transformers;
1435                                                  
1436           2                    2            16   use strict;
               2                                  4   
               2                                 14   
1437           2                    2            12   use warnings FATAL => 'all';
               2                                  4   
               2                                 14   
1438           2                    2            10   use English qw(-no_match_vars);
               2                                  4   
               2                                 10   
1439           2                    2            30   use Time::Local qw(timelocal);
               2                                  8   
               2                                 20   
1440           2                    2            12   use Digest::MD5 qw(md5_hex);
               2                                  6   
               2                                 14   
1441                                                  
1442           2                    2            14   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  4   
               2                                 14   
1443                                                  
1444                                                  require Exporter;
1445                                                  our @ISA         = qw(Exporter);
1446                                                  our %EXPORT_TAGS = ();
1447                                                  our @EXPORT      = ();
1448                                                  our @EXPORT_OK   = qw(
1449                                                     micro_t
1450                                                     percentage_of
1451                                                     secs_to_time
1452                                                     shorten
1453                                                     ts
1454                                                     parse_timestamp
1455                                                     unix_timestamp
1456                                                     make_checksum
1457                                                  );
1458                                                  
1459                                                  sub micro_t {
1460  ***      0                    0             0      my ( $t, %args ) = @_;
1461  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1462  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1463  ***      0                                  0      my $f;
1464                                                  
1465  ***      0      0                           0      $t = 0 if $t < 0;
1466                                                  
1467  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1468                                                  
1469  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1470                                                  
1471  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1472  ***      0                                  0         $f = ($t * 1000000) . 'us';
1473                                                     }
1474                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1475  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1476  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1477                                                     }
1478                                                     elsif ($t >= 1) {
1479  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1480  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1481                                                     }
1482                                                     else {
1483  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1484                                                     }
1485                                                  
1486  ***      0                                  0      return $f;
1487                                                  }
1488                                                  
1489                                                  sub percentage_of {
1490  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1491  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1492  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1493  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1494                                                  }
1495                                                  
1496                                                  sub secs_to_time {
1497  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1498  ***      0             0                    0      $secs ||= 0;
1499  ***      0      0                           0      return '00:00' unless $secs;
1500                                                  
1501  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1502                                                            : $secs >= 3_600  ? 'h'
1503                                                            :                   'm';
1504                                                  
1505                                                     return
1506  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1507                                                           "%d+%02d:%02d:%02d",
1508                                                           int($secs / 86_400),
1509                                                           int(($secs % 86_400) / 3_600),
1510                                                           int(($secs % 3_600) / 60),
1511                                                           $secs % 60)
1512                                                        : $fmt eq 'h' ? sprintf(
1513                                                           "%02d:%02d:%02d",
1514                                                           int(($secs % 86_400) / 3_600),
1515                                                           int(($secs % 3_600) / 60),
1516                                                           $secs % 60)
1517                                                        : sprintf(
1518                                                           "%02d:%02d",
1519                                                           int(($secs % 3_600) / 60),
1520                                                           $secs % 60);
1521                                                  }
1522                                                  
1523                                                  sub shorten {
1524  ***      0                    0             0      my ( $num, %args ) = @_;
1525  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1526  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1527  ***      0                                  0      my $n = 0;
1528  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1529  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1530  ***      0                                  0         $num /= $d;
1531  ***      0                                  0         ++$n;
1532                                                     }
1533  ***      0      0      0                    0      return sprintf(
1534                                                        $num =~ m/\./ || $n
1535                                                           ? "%.${p}f%s"
1536                                                           : '%d',
1537                                                        $num, $units[$n]);
1538                                                  }
1539                                                  
1540                                                  sub ts {
1541          43                   43           240      my ( $time ) = @_;
1542          43                               1268      my ( $sec, $min, $hour, $mday, $mon, $year )
1543                                                        = localtime($time);
1544          43                                230      $mon  += 1;
1545          43                                162      $year += 1900;
1546          43                               1540      return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1547                                                        $year, $mon, $mday, $hour, $min, $sec);
1548                                                  }
1549                                                  
1550                                                  sub parse_timestamp {
1551  ***      0                    0             0      my ( $val ) = @_;
1552  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
1553                                                           = $val =~ m/^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?$/ )
1554                                                     {
1555  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1556                                                                       . (defined $f ? '%02.6f' : '%02d'),
1557                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1558                                                     }
1559  ***      0                                  0      return $val;
1560                                                  }
1561                                                  
1562                                                  sub unix_timestamp {
1563  ***      0                    0             0      my ( $val ) = @_;
1564  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s)
1565                                                       = $val =~ m/^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.\d+)?$/ )
1566                                                     {
1567  ***      0                                  0         return timelocal($s, $i, $h, $d, $m - 1, $y);
1568                                                     }
1569  ***      0                                  0      return $val;
1570                                                  }
1571                                                  
1572                                                  sub make_checksum {
1573  ***      0                    0             0      my ( $val ) = @_;
1574  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1575  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1576  ***      0                                  0      return $checksum;
1577                                                  }
1578                                                  
1579                                                  sub _d {
1580  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1581  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1582  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1583                                                          @_;
1584  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1585                                                  }
1586                                                  
1587                                                  1;
1588                                                  
1589                                                  # ###########################################################################
1590                                                  # End Transformers package
1591                                                  # ###########################################################################
1592                                                  
1593                                                  # ###########################################################################
1594                                                  # Processlist package 4172
1595                                                  # ###########################################################################
1596                                                  package Processlist;
1597                                                  
1598           2                    2            12   use strict;
               2                                  6   
               2                                 12   
1599           2                    2            12   use warnings FATAL => 'all';
               2                                  4   
               2                                 12   
1600           2                    2            12   use English qw(-no_match_vars);
               2                                  6   
               2                                 12   
1601                                                  
1602           2                    2            12   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  6   
               2                                 14   
1603                                                  use constant {
1604           2                                 38      ID      => 0,
1605                                                     USER    => 1,
1606                                                     HOST    => 2,
1607                                                     DB      => 3,
1608                                                     COMMAND => 4,
1609                                                     TIME    => 5,
1610                                                     STATE   => 6,
1611                                                     INFO    => 7,
1612                                                     START   => 8, # Calculated start time of statement
1613                                                     ETIME   => 9, # Exec time of SHOW PROCESSLIST (margin of error in START)
1614                                                     FSEEN   => 10, # First time ever seen
1615           2                    2            10   };
               2                                  6   
1616                                                  
1617                                                  sub new {
1618          14                   14           113      my ( $class ) = @_;
1619          14                                166      bless {}, $class;
1620                                                  }
1621                                                  
1622                                                  sub parse_event {
1623  ***      0                    0             0      my ( $self, $code, $misc, @callbacks ) = @_;
1624  ***      0                                  0      my $num_events = 0;
1625                                                  
1626  ***      0                                  0      my @curr = sort { $a->[ID] <=> $b->[ID] } @{$code->()};
      ***      0                                  0   
      ***      0                                  0   
1627  ***      0             0                    0      my @prev = @{$misc->{prev} ||= []};
      ***      0                                  0   
1628  ***      0                                  0      my @new; # Will become next invocation's @prev
1629  ***      0                                  0      my ($curr, $prev); # Rows from each source
1630                                                  
1631  ***      0             0                    0      do {
      ***                    0                        
      ***                    0                        
1632  ***      0      0      0                    0         if ( !$curr && @curr ) {
1633  ***      0                                  0            MKDEBUG && _d('Fetching row from curr');
1634  ***      0                                  0            $curr = shift @curr;
1635                                                        }
1636  ***      0      0      0                    0         if ( !$prev && @prev ) {
1637  ***      0                                  0            MKDEBUG && _d('Fetching row from prev');
1638  ***      0                                  0            $prev = shift @prev;
1639                                                        }
1640  ***      0      0      0                    0         if ( $curr || $prev ) {
1641  ***      0      0      0                    0            if ( $curr && $prev && $curr->[ID] == $prev->[ID] ) {
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
1642  ***      0                                  0               MKDEBUG && _d('$curr and $prev are the same cxn');
1643  ***      0      0                           0               my $fudge = $curr->[TIME] =~ m/\D/ ? 0.001 : 1; # Micro-precision?
1644  ***      0                                  0               my $is_new = 0;
1645  ***      0      0                           0               if ( $prev->[INFO] ) {
1646  ***      0      0      0                    0                  if (!$curr->[INFO] || $prev->[INFO] ne $curr->[INFO]) {
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
1647  ***      0                                  0                     MKDEBUG && _d('$curr has a new query');
1648  ***      0                                  0                     $is_new = 1;
1649                                                                 }
1650                                                                 elsif (defined $curr->[TIME] && $curr->[TIME] < $prev->[TIME]) {
1651  ***      0                                  0                     MKDEBUG && _d('$curr time is less than $prev time');
1652  ***      0                                  0                     $is_new = 1;
1653                                                                 }
1654                                                                 elsif ( $curr->[INFO] && defined $curr->[TIME]
1655                                                                    && $misc->{time} - $curr->[TIME] - $prev->[START]
1656                                                                       - $prev->[ETIME] - $misc->{etime} > $fudge
1657                                                                 ) {
1658  ***      0                                  0                     MKDEBUG && _d('$curr has same query that restarted');
1659  ***      0                                  0                     $is_new = 1;
1660                                                                 }
1661  ***      0      0                           0                  if ( $is_new ) {
1662  ***      0                                  0                     fire_event( $prev, $misc->{time}, @callbacks );
1663                                                                 }
1664                                                              }
1665  ***      0      0                           0               if ( $curr->[INFO] ) {
1666  ***      0      0      0                    0                  if ( $prev->[INFO] && !$is_new ) {
1667  ***      0                                  0                     MKDEBUG && _d('Pushing old history item back onto $prev');
1668  ***      0                                  0                     push @new, [ @$prev ];
1669                                                                 }
1670                                                                 else {
1671  ***      0                                  0                     MKDEBUG && _d('Pushing new history item onto $prev');
1672  ***      0                                  0                     push @new,
1673                                                                       [ @$curr, int($misc->{time} - $curr->[TIME]),
1674                                                                          $misc->{etime}, $misc->{time} ];
1675                                                                 }
1676                                                              }
1677  ***      0                                  0               $curr = $prev = undef; # Fetch another from each.
1678                                                           }
1679                                                           elsif ( !$curr
1680                                                                 || ( $curr && $prev && $curr->[ID] > $prev->[ID] )) {
1681  ***      0                                  0               MKDEBUG && _d('$curr is not in $prev');
1682  ***      0                                  0               fire_event( $prev, $misc->{time}, @callbacks );
1683  ***      0                                  0               $prev = undef;
1684                                                           }
1685                                                           else { # This else must be entered, to prevent infinite loops.
1686  ***      0                                  0               MKDEBUG && _d('$prev is not in $curr');
1687  ***      0      0      0                    0               if ( $curr->[INFO] && defined $curr->[TIME] ) {
1688  ***      0                                  0                  MKDEBUG && _d('Pushing new history item onto $prev');
1689  ***      0                                  0                  push @new,
1690                                                                    [ @$curr, int($misc->{time} - $curr->[TIME]),
1691                                                                       $misc->{etime}, $misc->{time} ];
1692                                                              }
1693  ***      0                                  0               $curr = undef; # No infinite loops.
1694                                                           }
1695                                                        }
1696                                                     } while ( @curr || @prev || $curr || $prev );
1697                                                  
1698  ***      0                                  0      @{$misc->{prev}} = @new;
      ***      0                                  0   
1699                                                  
1700  ***      0                                  0      return $num_events;
1701                                                  }
1702                                                  
1703                                                  sub fire_event {
1704  ***      0                    0             0      my ( $row, $time, @callbacks ) = @_;
1705  ***      0                                  0      my $Query_time = $row->[TIME];
1706  ***      0      0                           0      if ( $row->[TIME] < $time - $row->[FSEEN] ) {
1707  ***      0                                  0         $Query_time = $time - $row->[FSEEN];
1708                                                     }
1709  ***      0                                  0      my $event = {
1710                                                        id         => $row->[ID],
1711                                                        db         => $row->[DB],
1712                                                        user       => $row->[USER],
1713                                                        host       => $row->[HOST],
1714                                                        arg        => $row->[INFO],
1715                                                        bytes      => length($row->[INFO]),
1716                                                        ts         => $row->[START] + $row->[TIME], # Query END time
1717                                                        Query_time => $Query_time,
1718                                                        Lock_time  => 0,               # TODO
1719                                                     };
1720  ***      0                                  0      foreach my $callback ( @callbacks ) {
1721  ***      0      0                           0         last unless $event = $callback->($event);
1722                                                     }
1723                                                  }
1724                                                  
1725                                                  sub find {
1726          72                   72          1024      my ( $self, $proclist, %find_spec ) = @_;
1727          72                                360      my @matches;
1728                                                     QUERY:
1729          72                                546      foreach my $query ( @$proclist ) {
1730         634                               1874         my $matched = 0;
1731  ***    634    100     50                 6151         if ( $find_spec{busy_time} && ($query->{Command} || '') eq 'Query' ) {
                           100                        
1732         204    100                        1341            if ( $query->{Time} < $find_spec{busy_time} ) {
1733         156                                420               MKDEBUG && _d("Query isn't running long enough");
1734         156                                657               next QUERY;
1735                                                           }
1736          48                                191            $matched++;
1737                                                        }
1738                                                        PROPERTY:
1739         478                               2120         foreach my $property ( qw(Id User Host db State Command Info) ) {
1740        2322                               8251            my $filter = "_find_match_$property";
1741        2322    100    100                19351            if ( defined $find_spec{ignore}->{$property}
1742                                                              && $self->$filter($query, $find_spec{ignore}->{$property})
1743                                                           ) {
1744         176                                433               MKDEBUG && _d("Query matches 'ignore' filter on $property, skipping");
1745         176                                813               next QUERY;
1746                                                           }
1747        2146    100                       12951            if ( defined $find_spec{match}->{$property} ) {
1748         232    100                        1118               if ( !$self->$filter($query, $find_spec{match}->{$property}) ) {
1749         199                                425                  MKDEBUG && _d("Query doesn't match 'match' filter on $property, skipping");
1750         199                                679                  next QUERY;
1751                                                              }
1752          33                                116               $matched++;
1753                                                           }
1754                                                        }
1755         103    100                         592         if ( $matched ) {
1756          81                                225            MKDEBUG && _d("Query passed all defined filters, adding");
1757          81                                386            push @matches, $query;
1758                                                        }
1759                                                     }
1760          72    100    100                  983      if ( @matches && $find_spec{only_oldest} ) {
1761          43                                389         my ( $oldest ) = reverse sort { $a->{Time} <=> $b->{Time} } @matches;
              66                                247   
1762          43                                280         @matches = $oldest;
1763                                                     }
1764          72                                597      return @matches;
1765                                                  }
1766                                                  
1767                                                  sub _find_match_Id {
1768         120                  120           832      my ( $self, $query, $property ) = @_;
1769  ***    120            33                 3666      return defined $property && defined $query->{Id} && $query->{Id} == $property;
      ***                   33                        
1770                                                  }
1771                                                  
1772                                                  sub _find_match_User {
1773         478                  478          2327      my ( $self, $query, $property ) = @_;
1774  ***    478            33                 9479      return defined $property && defined $query->{User}
      ***                   66                        
1775                                                        && $query->{User} =~ m/$property/;
1776                                                  }
1777                                                  
1778                                                  sub _find_match_Host {
1779  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1780  ***      0             0                    0      return defined $property && defined $query->{Host}
      ***                    0                        
1781                                                        && $query->{Host} =~ m/$property/;
1782                                                  }
1783                                                  
1784                                                  sub _find_match_db {
1785  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1786  ***      0             0                    0      return defined $property && defined $query->{db}
      ***                    0                        
1787                                                        && $query->{db} =~ m/$property/;
1788                                                  }
1789                                                  
1790                                                  sub _find_match_State {
1791         592                  592          2722      my ( $self, $query, $property ) = @_;
1792  ***    592            66                12648      return defined $property && defined $query->{State}
                           100                        
1793                                                        && $query->{State} =~ m/$property/;
1794                                                  }
1795                                                  
1796                                                  sub _find_match_Command {
1797         170                  170          1088      my ( $self, $query, $property ) = @_;
1798  ***    170            33                 5060      return defined $property && defined $query->{Command}
      ***                   66                        
1799                                                        && $query->{Command} =~ m/$property/;
1800                                                  }
1801                                                  
1802                                                  sub _find_match_Info {
1803           1                    1            10      my ( $self, $query, $property ) = @_;
1804  ***      1            33                   37      return defined $property && defined $query->{Info}
      ***                   33                        
1805                                                        && $query->{Info} =~ m/$property/;
1806                                                  }
1807                                                  
1808                                                  sub _d {
1809  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1810  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1811  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1812                                                          @_;
1813  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1814                                                  }
1815                                                  
1816                                                  1;
1817                                                  
1818                                                  # ###########################################################################
1819                                                  # End Processlist package
1820                                                  # ###########################################################################
1821                                                  
1822                                                  # ###########################################################################
1823                                                  # TextResultSetParser package 4176
1824                                                  # ###########################################################################
1825                                                  package TextResultSetParser;
1826                                                  
1827                                                  
1828           2                    2            14   use strict;
               2                                  4   
               2                                 10   
1829           2                    2            12   use warnings FATAL => 'all';
               2                                  4   
               2                                 10   
1830           2                    2            12   use English qw(-no_match_vars);
               2                                  4   
               2                                 10   
1831                                                  
1832           2                    2            14   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  6   
               2                                 16   
1833                                                  
1834                                                  sub new {
1835          10                   10            65      my ( $class, %args ) = @_;
1836          10                                 56      my $self = { %args };
1837          10                                156      return bless $self, $class;
1838                                                  }
1839                                                  
1840                                                  sub parse_tabular {
1841           6                    6            47      my ( $text, @cols ) = @_;
1842           6                                 32      my %row;
1843           6                                201      my @vals = $text =~ m/\| +([^\|]*?)(?= +\|)/msg;
1844           6    100                          63      return (undef, \@vals) unless @cols;
1845           3                                 52      @row{@cols} = @vals;
1846           3                                 26      return (\%row, undef);
1847                                                  }
1848                                                  
1849                                                  sub parse_tab_sep {
1850  ***      0                    0             0      my ( $text, @cols ) = @_;
1851  ***      0                                  0      my %row;
1852  ***      0                                  0      my @vals = split(/\t/, $text);
1853  ***      0      0                           0      return (undef, \@vals) unless @cols;
1854  ***      0                                  0      @row{@cols} = @vals;
1855  ***      0                                  0      return (\%row, undef);
1856                                                  }
1857                                                  
1858                                                  sub parse_vertical {
1859         445                  445          1472      my ( $text ) = @_;
1860         445                               9255      my %row = $text =~ m/^\s*(\w+): ([^\n]*)/msg;
1861         445                               2801      return \%row;
1862                                                  }
1863                                                  
1864                                                  sub parse {
1865         455                  455          3810      my ( $self, $text ) = @_;
1866         455                               1144      my $result_set;
1867                                                  
1868         455    100                        3784      if ( $text =~ m/^\+---/m ) { # standard "tabular" output
      ***            50                               
      ***            50                               
1869           3                                 10         MKDEBUG && _d('text type: standard tabular');
1870           3                                 31         my $line_pattern  = qr/^(\| .*)[\r\n]+/m;
1871           3                                 37         $result_set
1872                                                           = _parse_horizontal_result_set($text, $line_pattern, \&parse_tabular);
1873                                                     }
1874                                                     elsif ( $text =~ m/^id\tselect_type\t/m ) { # tab-separated
1875  ***      0                                  0         MKDEBUG && _d('text type: tab-separated');
1876  ***      0                                  0         my $line_pattern  = qr/^(.*?\t.*)[\r\n]+/m;
1877  ***      0                                  0         $result_set
1878                                                           = _parse_horizontal_result_set($text, $line_pattern, \&parse_tab_sep);
1879                                                     }
1880                                                     elsif ( $text =~ m/\*\*\* \d+\. row/ ) { # "vertical" output
1881         452                               1023         my $n_recs;
1882         452                               9316         $n_recs++ while $text =~ m/ \d+\. row /g;
1883         452                               1578         MKDEBUG && _d('text-type: vertical,', $n_recs, 'n_recs');
1884         452    100                        1609         if ( $n_recs > 1 ) {
1885           7                                 19            MKDEBUG && _d('Multiple result sets');
1886           7                                 21            my @v_result_sets;
1887           7                                721            my $v_result_set = _split_vertical_result_sets($text);
1888           7                                 44            foreach my $v_result_set ( @$v_result_set ) {
1889         445                               1708               push @v_result_sets, $self->parse($v_result_set);
1890                                                           }
1891           7                                137            return \@v_result_sets;
1892                                                        }
1893         445                               1855         $result_set = _parse_vertical_result_set($text, \&parse_vertical);
1894                                                     }
1895                                                     else {
1896  ***      0                                  0         die "Cannot determine if text is tabular, tab-separated or veritcal:\n"
1897                                                           . $text;
1898                                                     }
1899                                                  
1900  ***    448     50                        1917      if ( $self->{value_for} ) {
1901  ***      0                                  0         foreach my $result_set ( @$result_set ) {
1902  ***      0                                  0            foreach my $key ( keys %$result_set ) {
1903  ***      0      0                           0               $result_set->{$key} = $self->{value_for}->{ $result_set->{$key} }
1904                                                                 if exists $self->{value_for}->{ $result_set->{$key} };
1905                                                           }
1906                                                        }
1907                                                     }
1908                                                  
1909         448                               1699      return $result_set;
1910                                                  }
1911                                                  
1912                                                  sub _parse_horizontal_result_set {
1913           3                    3            35      my ( $text, $line_pattern, $sub ) = @_;
1914           3                                 18      my @result_sets = ();
1915           3                                 11      my @cols        = ();
1916           3                                 50      foreach my $line ( $text =~ m/$line_pattern/g ) {
1917           6                                 45         my ( $row, $cols ) = $sub->($line, @cols);
1918           6    100                          33         if ( $row ) {
1919           3                                 21            push @result_sets, $row;
1920                                                        }
1921                                                        else {
1922           3                                 38            @cols = @$cols;
1923                                                        }
1924                                                     }
1925           3                                 38      return \@result_sets;
1926                                                  }
1927                                                  
1928                                                  sub _parse_vertical_result_set {
1929         445                  445          1864      my ( $text, $sub ) = @_;
1930         445                               1583      return $sub->($text);
1931                                                  }
1932                                                  
1933                                                  sub _split_vertical_result_sets {
1934           7                    7           179      my ( $text ) = @_;
1935           7                                 27      my $ROW_HEADER = '\*{3,} \d+\. row \*{3,}';
1936           7                              24322      my @result_sets = $text =~ m/($ROW_HEADER.*?)(?=$ROW_HEADER|\z)/omgs;
1937           7                                114      return \@result_sets;
1938                                                  }
1939                                                  
1940                                                  sub _d {
1941  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1942  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1943  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1944                                                          @_;
1945  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1946                                                  }
1947                                                  
1948                                                  1;
1949                                                  
1950                                                  # ###########################################################################
1951                                                  # End TextResultSetParser package
1952                                                  # ###########################################################################
1953                                                  
1954                                                  # ###########################################################################
1955                                                  # This is a combination of modules and programs in one -- a runnable module.
1956                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1957                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1958                                                  #
1959                                                  # Check at the end of this package for the call to main() which actually runs
1960                                                  # the program.
1961                                                  # ###########################################################################
1962                                                  package mk_kill;
1963                                                  
1964           2                    2            26   use English qw(-no_match_vars);
               2                                  6   
               2                                 14   
1965           2                    2            14   use POSIX qw(setsid);
               2                                  4   
               2                                 12   
1966           2                    2            12   use List::Util qw(max);
               2                                  8   
               2                                 20   
1967                                                  
1968                                                  Transformers->import qw(ts);
1969                                                  
1970           2                    2            26   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  6   
               2                                 18   
1971                                                  
1972                                                  my $o;
1973                                                  my $dp;
1974                                                  
1975                                                  # ########################################################################
1976                                                  # Configuration info.
1977                                                  # ########################################################################
1978                                                  
1979                                                  sub main {
1980          14                   14         58538      @ARGV = @_;  # set global ARGV for this package
1981                                                  
1982          14                                340      my $pl = new Processlist();
1983          14                                258      my $vp = new VersionParser();
1984          14                                216      $dp    = new DSNParser();
1985                                                  
1986                                                     # ########################################################################
1987                                                     # Get configuration information.
1988                                                     # ########################################################################
1989          14                                727      $o = new OptionParser(
1990                                                        description => q{kills, prints or executes another script for queries }
1991                                                                     . q{in MySQL that match certain criteria.  }
1992                                                                     . q{If FILE is not given, mk-kill executes SHOW PROCESSLIST }
1993                                                                     . q{on MySQL to get queries.  Else, mk-kill will get }
1994                                                                     . q{queries from FILE which should contain the output of }
1995                                                                     . q{SHOW PROCESSLIST.  If FILE is -, mk-kill reads from }
1996                                                                     . q{STDIN.},
1997                                                        prompt      => '[OPTION]... [FILE...]',
1998                                                        strict      => 0,
1999                                                     );
2000          14                               2900      $o->get_specs();
2001          14                                170      $o->get_opts();
2002                                                  
2003          14    100                          95      if ( !$o->got('busy-time') ) {
2004  ***      8     50                          71         $o->set('interval', 30) unless $o->got('interval');
2005                                                     }
2006                                                     else {
2007  ***      6     50                          45         $o->set('interval', max(1, $o->get('busy-time') / 2))
2008                                                           unless $o->got('interval');
2009                                                     }
2010                                                  
2011                                                     # If parsing files, then don't wait.
2012          14    100                          73      if ( @ARGV ) {
2013          10                                 47         $o->set('interval', 0);
2014                                                     }
2015                                                  
2016          14                                100      $o->usage_or_errors();
2017                                                  
2018                                                     # ########################################################################
2019                                                     # Connect to MySQL if not reading files.
2020                                                     # ########################################################################
2021          14                                 47      my $dsn;
2022          14                                 38      my $dbh;
2023          14                                 41      my $kill_sth;
2024          14    100                         203      if ( !@ARGV ) {
2025           4                                 48         $dsn      = $dp->parse_options($o);
2026           4                                 42         $dbh      = get_cxn($dsn, 1); 
2027           4                                 16         $kill_sth = $dbh->prepare('KILL ?');
2028                                                     }
2029                                                  
2030                                                     # ########################################################################
2031                                                     # Make input sub that will either get processlist from MySQL or a file.
2032                                                     # ########################################################################
2033          14                                 58      my $get_proclist;
2034          14    100                          71      if ( @ARGV ) {
2035          10                                 27         MKDEBUG && _d('Getting processlist from files:', @ARGV);
2036          10                                184         my $trp = new TextResultSetParser();
2037          10                                 35         my $fh;
2038                                                        $get_proclist = sub {
2039  ***     10     50            10            58            if ( !$fh ) {
2040          10                                 43               my $file = shift @ARGV;
2041  ***     10     50                          50               die 'No more files' unless $file;
2042  ***     10     50                          53               if ( $file eq '-' ) {
2043  ***      0                                  0                  $fh = *STDIN;
2044                                                              }
2045                                                              else {
2046  ***     10     50                         557                  if ( !open $fh, '<', $file ) {
2047  ***      0                                  0                     warn "Cannot open $file: $OS_ERROR";
2048  ***      0                                  0                     $fh = undef;
2049  ***      0                                  0                     return;
2050                                                                 }
2051                                                              }
2052                                                           }
2053                                                  
2054  ***     10     50                          58            if ( $fh ) {
2055          10                                 83               local $INPUT_RECORD_SEPARATOR = '';
2056          10                               2377               my $proclist_text = <$fh>;
2057  ***     10     50                         449               if ( $proclist_text ) {
2058          10                                819                  return $trp->parse($proclist_text);
2059                                                              }
2060                                                              else {
2061                                                                 # No more proclists in this file.
2062  ***      0                                  0                  $fh = undef;
2063                                                              }
2064                                                           }
2065                                                  
2066  ***      0                                  0            return;
2067          10                                146         };
2068                                                     }
2069                                                     else {
2070           4                                 10         MKDEBUG && _d('Getting processlist from MySQL');
2071           4                                 10         my $proc_sth = $dbh->prepare('SHOW FULL PROCESSLIST');
2072                                                        $get_proclist = sub {
2073          62                   62         24960            $proc_sth->execute();
2074          62                                958            return $proc_sth->fetchall_arrayref({});
2075           4                                 74         };
2076                                                     }
2077                                                  
2078                                                     # ########################################################################
2079                                                     # Daemonize only after (potentially) asking for passwords for --ask-pass.
2080                                                     # ########################################################################
2081          14                                 56      my $daemon;
2082  ***     14     50                          91      if ( $o->get('daemonize') ) {
2083  ***      0                                  0         $daemon = new Daemon(o=>$o);
2084  ***      0                                  0         $daemon->daemonize();
2085  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
2086                                                     }
2087                                                  
2088                                                     # ########################################################################
2089                                                     # Start working.
2090                                                     # ########################################################################
2091          14                                 71      my $start    = time();
2092          14           100                   82      my $end      = $start + ($o->get('run-time') || 0); # When we should exit
2093          14                                 48      my $now      = $start;
2094                                                  
2095  ***     14     50                          71      my %find_spec = (
2096                                                        only_oldest  => $o->get('only-oldest'),
2097                                                        busy_time    => $o->get('busy-time'),
2098                                                        ignore => {
2099                                                           Id       => $o->get('ignore-self') ? $dbh->{mysql_thread_id} : undef,
2100                                                           User     => $o->get('ignore-user'),
2101                                                           Command  => $o->get('ignore-command'),
2102                                                           State    => $o->get('ignore-state'),
2103                                                        },
2104                                                        match => {
2105                                                           Command  => $o->get('match-command'),
2106                                                           Info     => $o->get('match-info'),
2107                                                           State    => $o->get('match-state'),
2108                                                        },
2109                                                     );
2110                                                  
2111          14                                 72      my $iters_done = 0;
2112          14                                 64      my $iters_todo = $o->get('iterations');
2113          14           100                  289      while (                                              # Quit if:
                           100                        
                           100                        
2114                                                        ($start == $end || $now < $end)                   # time is exceeded
2115                                                        && (!$iters_todo || $iters_done++ < $iters_todo ) # or iterations exceeded
2116                                                     ) {
2117          72                                306         my $proclist;
2118          72                                426         eval { $proclist = $get_proclist->(); };
              72                                581   
2119  ***     72     50                         957         if ( $EVAL_ERROR ) {
2120  ***      0      0                           0            last if $EVAL_ERROR =~ m/No more files/;
2121  ***      0                                  0            die "Error getting SHOW PROCESSLIST: $EVAL_ERROR";
2122                                                        }
2123                                                  
2124          72                                289         my @queries;
2125  ***     72     50                         391         if ( $proclist ) {
2126          72                                962            @queries = $pl->find($proclist, %find_spec);
2127                                                           MATCHING_QUERY:
2128          72                                463            foreach my $query ( @queries ) {
2129          45    100                         430               if ( $o->get('print') ) {
2130  ***     43            50                  449                  printf "# %s KILL %d (%s %d sec) %s\n",
      ***                   50                        
2131                                                                    ts(time), $query->{Id}, ($query->{Command} || 'NULL'),
2132                                                                    $query->{Time}, ($query->{Info} || 'NULL');
2133                                                              }
2134          45    100                         313               if ( $o->get('execute-command') ) {
2135           2                                 14                  exec_cmd($o->get('execute-command'));
2136                                                              }
2137  ***     44     50                         343               if ( $o->get('kill') ) {
2138  ***      0      0                           0                  sleep $o->get('wait-before-kill') if $o->get('wait-before-kill');
2139  ***      0                                  0                  $kill_sth->execute($query->{Id});
2140                                                              }
2141                                                           }
2142                                                        }
2143                                                        else {
2144  ***      0                                  0            MKDEBUG && _d('No proclist returned');
2145                                                        }
2146                                                  
2147                                                        # Don't sleep if we're going to exit after waking up.  If $iters_todo is
2148                                                        # 0 (infinity), always sleep.  And only sleep if we're live (i.e. not
2149                                                        # reading from files).
2150          71    100    100                 1461         if ( (!$iters_todo || $iters_done < $iters_todo)
      ***                   66                        
2151                                                              && $dbh ) {
2152  ***     60     50     66                  564            if ( @queries && $o->get('wait-after-kill') ) {
2153  ***      0                                  0               MKDEBUG && _d("Sleeping after killing queries");
2154  ***      0                                  0               sleep $o->get('wait-after-kill');
2155                                                           }
2156                                                           else {
2157          60                                192               MKDEBUG && _d("Sleeping normal interval");
2158          60                                442               sleep $o->get('interval');
2159                                                           }
2160                                                        }
2161          71                               5037         $now = time();
2162                                                     }
2163                                                  
2164          13                                788      return 0;
2165                                                  }
2166                                                  
2167                                                  
2168                                                  # ############################################################################
2169                                                  # Subroutines.
2170                                                  # ############################################################################
2171                                                  
2172                                                  sub get_cxn {
2173           4                    4            22      my ( $dsn, $ac ) = @_;
2174  ***      4     50                          24      if ( $o->get('ask-pass') ) {
2175  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password: "); 
2176                                                     }
2177           4                                 48      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => $ac});
2178           4                                 44      $dbh->{InactiveDestroy} = 1; # Because of forking.
2179           4                                 32      return $dbh;
2180                                                  }
2181                                                  
2182                                                  # Forks and detaches from parent to execute the given command;
2183                                                  # does not block parent.
2184                                                  sub exec_cmd {
2185           2                    2            30      my ( $cmd ) = @_;
2186           2                                  8      MKDEBUG && _d('exec cmd:', $cmd);
2187  ***      2     50                          14      return unless $cmd;
2188                                                  
2189           2                               3014      my $pid = fork();
2190           2    100                         148      if ( $pid ) {
2191                                                        # parent
2192           1                                 20         MKDEBUG && _d('child pid:', $pid);
2193           1                                 51         return $pid;
2194                                                     }
2195                                                  
2196                                                     # child
2197  ***      1     50                         219      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2198           1                               4506      my $retval = system($cmd);
2199           1                                 26      $retval = $retval >> 8;
2200           1                                 27      MKDEBUG && _d('child exit status:', $retval);
2201           1                                 22      exit $retval;
2202                                                  }
2203                                                  
2204                                                  sub _d {
2205  ***      0                    0                    my ($package, undef, $line) = caller 0;
2206  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2207  ***      0                                              map { defined $_ ? $_ : 'undef' }
2208                                                          @_;
2209  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2210                                                  }
2211                                                  
2212                                                  # ############################################################################
2213                                                  # Run the program.
2214                                                  # ############################################################################
2215                                                  if ( !caller ) { exit main(@ARGV); }
2216                                                  
2217                                                  1; # Because this is a module as well as a script.
2218                                                  
2219                                                  # ############################################################################
2220                                                  # Documentation
2221                                                  # ############################################################################
2222                                                  =pod
2223                                                  
2224                                                  =head1 NAME
2225                                                  
2226                                                  mk-kill - Kill MySQL queries that match certain criteria.
2227                                                  
2228                                                  =head1 SYNOPSIS
2229                                                  
2230                                                  Kill queries running longer than 60s:
2231                                                  
2232                                                    mk-kill --busy-time 60 --kill
2233                                                  
2234                                                  Print, do not kill, queries running longer than 60s:
2235                                                  
2236                                                    mk-kill --busy-time 60 --print
2237                                                  
2238                                                  Check for sleeping processes and kill them all every 10s:
2239                                                  
2240                                                    mk-kill --match-command Sleep --kill --no-only-oldest --interval 10
2241                                                  
2242                                                  Print all login processes:
2243                                                  
2244                                                    mk-kill --match-state login --print --no-only-oldest
2245                                                  
2246                                                  =head1 DESCRIPTION
2247                                                  
2248                                                  mk-kill captures queries from SHOW PROCESSLIST, filters them, and then either
2249                                                  kills or prints them.  This is also known as a "slow query sniper" in some
2250                                                  circles.  The idea is to watch for queries that might be consuming too many
2251                                                  resources, and kill them.
2252                                                  
2253                                                  For brevity, we talk about killing queries, but they may just be printed
2254                                                  (or some other future action) depending on what options are given.
2255                                                  
2256                                                  Normally mk-kill connects to MySQL to get queries from SHOW PROCESSLIST.
2257                                                  Alternatively, it can read SHOW PROCESSLIST output from files.  In this case,
2258                                                  mk-kill does not connect to MySQL and L<"--kill"> has no effect.  You should
2259                                                  use L<"--print"> instead when reading files.  The ability to read a file (or
2260                                                  - for STDIN) allows you to capture SHOW PROCESSLIST and test it later with
2261                                                  mk-kill to make sure that your matches kill the proper queries.  There are a
2262                                                  lot of special rules to follow, such as "don't kill replication threads,"
2263                                                  so be careful to not kill something important!
2264                                                  
2265                                                  Two important options to know are L<"--busy-time"> and L<"--[no]only-oldest">.
2266                                                  First, whereas most match/filter options match their corresponding value from
2267                                                  SHOW PROCESSLIST (e.g. L<"--match-command"> matches a query's Command value),
2268                                                  the Time value is matched by L<"--busy-time">.  See also L<"--interval">.
2269                                                  
2270                                                  Secondly, L<"--[no]only-oldest"> affects which matching query is killed.
2271                                                  By default, the matching query with the highest Time value is killed.  So
2272                                                  if you want to match and kill ALL queries for a certain criteria regardless
2273                                                  of which is the "oldest", you must specify C<--no-only-oldest>.
2274                                                  
2275                                                  mk-kill is a work in progress, and there is much more it could do.
2276                                                  
2277                                                  =head1 OUTPUT
2278                                                  
2279                                                  If only L<"--kill"> then there is no output.  If only L<"--print"> then a
2280                                                  timestamped KILL statement if printed for every query that would have
2281                                                  been killed, like:
2282                                                  
2283                                                    # 2009-07-15T15:04:01 KILL 8 (Query 42 sec) SELECT * FROM huge_table
2284                                                  
2285                                                  The line shows a timestamp, the query's Id (8), its Time (42 sec) and its
2286                                                  Info (usually the query SQL).
2287                                                  
2288                                                  If both L<"--kill"> and L<"--print"> are given, then matching queries are
2289                                                  killed and a line for each like the one above is printed.
2290                                                  
2291                                                  Any command executed by L<"--execute-command"> is responsible for its own
2292                                                  output and logging.  After being executed, mk-kill has no control or interaction
2293                                                  with the command.
2294                                                  
2295                                                  =head1 OPTIONS
2296                                                  
2297                                                  Specify at least one of L<"--kill">, L<"--print"> or L<"--execute-command">.
2298                                                  
2299                                                  =over
2300                                                  
2301                                                  =item --ask-pass
2302                                                  
2303                                                  Prompt for a password when connecting to MySQL.
2304                                                  
2305                                                  =item --charset
2306                                                  
2307                                                  short form: -A; type: string
2308                                                  
2309                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2310                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
2311                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
2312                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
2313                                                  
2314                                                  =item --config
2315                                                  
2316                                                  type: Array
2317                                                  
2318                                                  Read this comma-separated list of config files; if specified, this must be the
2319                                                  first option on the command line.
2320                                                  
2321                                                  =item --daemonize
2322                                                  
2323                                                  Fork to the background and detach from the shell.  POSIX operating systems
2324                                                  only.
2325                                                  
2326                                                  =item --defaults-file
2327                                                  
2328                                                  short form: -F; type: string
2329                                                  
2330                                                  Only read mysql options from the given file.  You must give an absolute
2331                                                  pathname.
2332                                                  
2333                                                  =item --help
2334                                                  
2335                                                  Show help and exit.
2336                                                  
2337                                                  =item --host
2338                                                  
2339                                                  short form: -h; type: string
2340                                                  
2341                                                  Connect to host.
2342                                                  
2343                                                  =item --interval
2344                                                  
2345                                                  type: time
2346                                                  
2347                                                  How often to check for queries to kill.  If L<"--busy-time"> is not given,
2348                                                  then the default interval is 30 seconds.  Else , the default is half as often
2349                                                  as L<"--busy-time">.  If both L<"--interval"> and L<"--busy-time"> are given,
2350                                                  then the explicit L<"--interval"> value is used.
2351                                                  
2352                                                  =item --iterations
2353                                                  
2354                                                  type: int; default: 1
2355                                                  
2356                                                  How many times to iterate through the find-and-kill cycle.  If 0, iterate
2357                                                  to infinity.  See also L<"--run-time">.
2358                                                  
2359                                                  =item --log
2360                                                  
2361                                                  type: string
2362                                                  
2363                                                  Print all output to this file when daemonized.
2364                                                  
2365                                                  =item --password
2366                                                  
2367                                                  short form: -p; type: string
2368                                                  
2369                                                  Password to use when connecting.
2370                                                  
2371                                                  =item --pid
2372                                                  
2373                                                  type: string
2374                                                  
2375                                                  Create the given PID file when daemonized.  The file contains the process ID of
2376                                                  the daemonized instance.  The PID file is removed when the daemonized instance
2377                                                  exits.  The program checks for the existence of the PID file when starting; if
2378                                                  it exists and the process with the matching PID exists, the program exits.
2379                                                  
2380                                                  =item --port
2381                                                  
2382                                                  short form: -P; type: int
2383                                                  
2384                                                  Port number to use for connection.
2385                                                  
2386                                                  =item --run-time
2387                                                  
2388                                                  type: time
2389                                                  
2390                                                  How long to run before exiting.
2391                                                  
2392                                                  =item --set-vars
2393                                                  
2394                                                  type: string; default: wait_timeout=10000
2395                                                  
2396                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2397                                                  will be appended to SET and executed.
2398                                                  
2399                                                  =item --socket
2400                                                  
2401                                                  short form: -S; type: string
2402                                                  
2403                                                  Socket file to use for connection.
2404                                                  
2405                                                  =item --user
2406                                                  
2407                                                  short form: -u; type: string
2408                                                  
2409                                                  User for login if not current user.
2410                                                  
2411                                                  =item --version
2412                                                  
2413                                                  Show version and exit.
2414                                                  
2415                                                  =item --wait-after-kill
2416                                                  
2417                                                  type: time
2418                                                  
2419                                                  Wait after killing a query, before looking for more to kill.  The purpose of
2420                                                  this is to give blocked queries a chance to execute, so we don't kill a query
2421                                                  that's blocking a bunch of others, and then kill the others immediately
2422                                                  afterwards.
2423                                                  
2424                                                  =item --wait-before-kill
2425                                                  
2426                                                  type: time
2427                                                  
2428                                                  Wait before killing a query.  The purpose of this is to give
2429                                                  L<"--execute-command"> a chance to see the matching query and gather other
2430                                                  MySQL or system information before it's killed.
2431                                                  
2432                                                  =back
2433                                                  
2434                                                  =head2 MATCHES
2435                                                  
2436                                                  These options specify what criteria a query must match for C<mk-kill>
2437                                                  to either L<"--kill">, L<"--print"> or L<"--execute-command"> for it.
2438                                                  
2439                                                  =over
2440                                                  
2441                                                  =item --busy-time
2442                                                  
2443                                                  type: time
2444                                                  
2445                                                  Kill connections that have been running for longer than this time.  The queries
2446                                                  must be in Command=Query status.  This matches a query's Time value as
2447                                                  reported by SHOW PROCESSLIST.
2448                                                  
2449                                                  =item --ignore-command
2450                                                  
2451                                                  type: string; group: Matches; default: Binlog.Dump
2452                                                  
2453                                                  Ignore queries whose Command matches this Perl regex.  The default is to keep
2454                                                  the slave threads from being killed on the master.
2455                                                  
2456                                                  =item --[no]ignore-self
2457                                                  
2458                                                  default: yes; group: Matches
2459                                                  
2460                                                  Don't kill mk-kill's own connection.
2461                                                  
2462                                                  =item --ignore-state
2463                                                  
2464                                                  type: string; group: Matches; default: Locked
2465                                                  
2466                                                  Ignore queries whose State matches this Perl regex.  The default is to keep
2467                                                  threads from being killed if they are locked waiting for another thread.
2468                                                  
2469                                                  =item --ignore-user
2470                                                  
2471                                                  type: string; group: Matches; default: system.user
2472                                                  
2473                                                  Ignore queries whose user matches this Perl regex.  The default is to keep the
2474                                                  replication threads from being killed on the slave.
2475                                                  
2476                                                  =item --match-command
2477                                                  
2478                                                  type: string; group: Matches
2479                                                  
2480                                                  Kill only queries whose Command matches this Perl regex.
2481                                                  
2482                                                  =item --match-info
2483                                                  
2484                                                  type: string; group: Matches
2485                                                  
2486                                                  Kill only queries whose Info (query) matches this Perl regex.
2487                                                  
2488                                                  =item --match-state
2489                                                  
2490                                                  type: string; group: Matches
2491                                                  
2492                                                  Kill only queries whose State matches this Perl regex.
2493                                                  
2494                                                  =item --[no]only-oldest
2495                                                  
2496                                                  default: yes; group: Matches
2497                                                  
2498                                                  Only kill the single oldest query.  This is to prevent killing queries that
2499                                                  aren't really long-running, they're just long-waiting.  This sorts matching
2500                                                  queries by Time and kills the one with the highest Time value.
2501                                                  
2502                                                  =back
2503                                                  
2504                                                  =head2 ACTIONS
2505                                                  
2506                                                  When a query matches, one or more of these actions is taken.  The actions are
2507                                                  taken in this order: L<"--print">, L<"--execute-command">, L<"--kill">.
2508                                                  If given, mk-kill sleeps for L<"--wait-before-kill"> before L<"--kill"> (if
2509                                                  L<"--kill"> is given).  This order allows L<"--execute-command"> to see the 
2510                                                  output of L<"--print"> and the query before L<"--kill">.  This may be helpful
2511                                                  because mk-kill does not pass any information to L<"--execute-command">.
2512                                                  
2513                                                  =over
2514                                                  
2515                                                  =item --execute-command
2516                                                  
2517                                                  type: string; group: Actions
2518                                                  
2519                                                  Execute this command when a query matches.
2520                                                  
2521                                                  After the command is executed, mk-kill has no control over it, so the command
2522                                                  is responsible for its own info gathering, logging, interval, etc.  The
2523                                                  command is excuted each time a query matches, so be careful that the command
2524                                                  behaves well when multiple instances are ran.  No information from mk-kill is
2525                                                  passed to the command.
2526                                                  
2527                                                  See also L<"--wait-before-kill">.
2528                                                  
2529                                                  =item --kill
2530                                                  
2531                                                  group: Actions
2532                                                  
2533                                                  Actually kill matching queries.
2534                                                  
2535                                                  This option makes mk-kill kill matching queries in MySQL.  Unless L<"--print">
2536                                                  is also given, no other information is printed that shows that mk-kill
2537                                                  matched and killed a query.
2538                                                  
2539                                                  See also L<"--wait-before-kill"> and L<"--wait-after-kill">.
2540                                                  
2541                                                  =item --print
2542                                                  
2543                                                  group: Actions
2544                                                  
2545                                                  Print a KILL statement for matching queries; does not actually kill queries.
2546                                                  
2547                                                  If you just want to see which queries match and would be killed without
2548                                                  actually killing them, specify L<"--print">.  To both kill and print
2549                                                  matching queries, specify both L<"--kill"> and L<"--print">.
2550                                                  
2551                                                  =back
2552                                                  
2553                                                  =head1 DOWNLOADING
2554                                                  
2555                                                  You can download Maatkit from Google Code at
2556                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2557                                                  easily with a command like the following:
2558                                                  
2559                                                     wget http://www.maatkit.org/get/toolname
2560                                                     or
2561                                                     wget http://www.maatkit.org/trunk/toolname
2562                                                  
2563                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2564                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2565                                                  needed.  The first URL gets the latest released version of the tool, and the
2566                                                  second gets the latest trunk code from Subversion.
2567                                                  
2568                                                  =head1 ENVIRONMENT
2569                                                  
2570                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2571                                                  the Maatkit tools:
2572                                                  
2573                                                     MKDEBUG=1 mk-....
2574                                                  
2575                                                  =head1 SYSTEM REQUIREMENTS
2576                                                  
2577                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2578                                                  installed in any reasonably new version of Perl.
2579                                                  
2580                                                  =head1 BUGS
2581                                                  
2582                                                  Please use Google Code Issues and Groups to report bugs or request support:
2583                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2584                                                  discuss Maatkit.
2585                                                  
2586                                                  Please include the complete command-line used to reproduce the problem you are
2587                                                  seeing, the version of all MySQL servers involved, the complete output of the
2588                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2589                                                  running with the C<MKDEBUG=1> environment variable.
2590                                                  
2591                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2592                                                  
2593                                                  This program is copyright 2009-@CURRENTYEAR@ Baron Schwartz.
2594                                                  Feedback and improvements are welcome.
2595                                                  
2596                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2597                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2598                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2599                                                  
2600                                                  This program is free software; you can redistribute it and/or modify it under
2601                                                  the terms of the GNU General Public License as published by the Free Software
2602                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2603                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2604                                                  licenses.
2605                                                  
2606                                                  You should have received a copy of the GNU General Public License along with
2607                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2608                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2609                                                  
2610                                                  =head1 AUTHOR
2611                                                  
2612                                                  Baron Schwartz.
2613                                                  
2614                                                  =head1 VERSION
2615                                                  
2616                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 4191 $.
2617                                                  
2618                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
57    ***     50      0     14   unless $args{$arg}
62    ***     50     14      0   exists $args{'strict'} ? :
105   ***     50      0     14   unless open my $fh, '<', $file
125          100   4172     14   unless $para =~ /^=head1 OPTIONS/
130          100     14     14   if $para =~ /^=over/
138   ***     50      0     14   unless $para
141          100    448     14   if (my($option) = $para =~ /^=item --(.*)/)
148          100    392     56   if ($para =~ /: /) { }
152   ***     50      0    686   unless $attributes{$attrib}
156          100     98    294   if ($attribs{'short form'})
172   ***     50      0    448   if $para =~ /^=item/
174          100     28    420   if (my($base_option) = $option =~ /^\[no\](.*)/)
179          100     98    350   $attribs{'short form'} ? :
             100     28    420   $attribs{'negatable'} ? :
      ***     50      0    448   $attribs{'cumulative'} ? :
             100    336    112   $attribs{'type'} ? :
             100     98    350   $attribs{'default'} ? :
             100    154    294   $attribs{'group'} ? :
191   ***     50      0    658   unless $para
194          100     14    644   if ($para =~ /^=head1/)
198          100    448    196   if $para =~ /^=item --/
202   ***     50      0     14   unless @specs
213          100    448     14   if (ref $opt) { }
218   ***     50      0    448   if (not $long)
223   ***     50      0    448   if exists $$self{'opts'}{$long}
226   ***     50      0    448   if (length $long == 1)
231          100     98    350   if ($short) { }
232   ***     50      0     98   if exists $$self{'short_opts'}{$short}
241          100     28    420   $$opt{'spec'} =~ /!/ ? :
242   ***     50      0    448   $$opt{'spec'} =~ /\+/ ? :
243   ***     50      0    448   $$opt{'desc'} =~ /required/ ? :
255   ***     50      0    448   if ($type and $type eq 'd' and not $$self{'dp'})
260          100     84    364   if $type and $type =~ /[HhAadzm]/
262          100     98    350   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
263          100     28     70   if ($$opt{'is_negatable'})
264   ***      0      0      0   $def eq 'no' ? :
      ***     50     28      0   $def eq 'yes' ? :
268   ***     50     98      0   defined $def ? :
272          100     14    434   if ($long eq 'config')
276   ***     50      0    448   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
289   ***     50      0     14   if ($opt =~ /mutually exclusive|one and only one/)
294   ***     50     14      0   if ($opt =~ /at least one|one and only one/)
299   ***     50      0     14   if ($opt =~ /default to/)
304   ***     50      0     14   if ($opt =~ /restricted to option groups/)
314   ***     50      0     14   unless $rule_ok
331   ***     50      0     42   unless exists $$self{'opts'}{$long}
347   ***      0      0      0   $$self{'opts'}{$_}{'short'} ? :
365   ***      0      0      0   unless exists $$self{'opts'}{$long}
385   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     45      0   exists $$self{'opts'}{$opt} ? :
390   ***     50      0     45   if ($$opt{'is_cumulative'}) { }
405   ***     50      0    336   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100    112    336   exists $$self{'defaults'}{$long} ? :
414   ***     50      0     14   if (@ARGV and $ARGV[0] eq '--config')
418   ***     50     14      0   if ($self->has('config'))
424   ***     50     56      0   if ($EVAL_ERROR)
425   ***     50      0     56   $self->got('config') ? :
440   ***     50      0     14   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
443   ***     50      0     14   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
444   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
450   ***     50      0     14   if (@ARGV and $$self{'strict'})
456   ***      0      0      0   if (@set > 1)
467   ***     50      0     14   if (@set == 0)
477          100     45    403   if ($$opt{'got'}) { }
      ***     50      0    403   elsif ($$opt{'is_required'}) { }
478   ***     50      0     45   if (exists $$self{'disables'}{$long})
485   ***     50      0     45   if (exists $$self{'allowed_groups'}{$long})
497   ***      0      0      0   if $restricted_opt eq $long
498   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
503   ***      0      0      0   if (@restricted_opts)
505   ***      0      0      0   if (@restricted_opts == 1) { }
534          100    112    336   unless $opt and $$opt{'type'}
537          100      8    328   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    328   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    328   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0    328   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     14    314   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
540          100      2      6   if (not $suffix)
546   ***     50      8      0   if ($suffix =~ /[smhd]/) { }
547   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***     50      8      0   $suffix eq 's' ? :
562   ***      0      0      0   if ($from_key)
573   ***      0      0      0   if (defined $num) { }
574   ***      0      0      0   if ($factor)
601          100     36    424   length $opt == 1 ? :
602   ***     50      0    460   unless $long and exists $$self{'opts'}{$long}
609   ***     50      0     84   length $opt == 1 ? :
610   ***     50      0     84   unless $long and exists $$self{'opts'}{$long}
617          100     32     14   length $opt == 1 ? :
618          100     42      4   defined $long ? :
623   ***     50      0     24   length $opt == 1 ? :
624   ***     50      0     24   unless $long and exists $$self{'opts'}{$long}
658   ***     50      0     14   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0     14   elsif (scalar @{$$self{'errors'};}) { }
659   ***      0      0      0   unless print $self->print_usage
663   ***      0      0      0   unless print $self->print_errors
672   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
681   ***      0      0      0   unless $$self{'got_opts'}
684   ***      0      0      0   $$_{'is_negatable'} ? :
688   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
704   ***      0      0      0   $group eq 'default' ? :
710   ***      0      0      0   $$opt{'is_negatable'} ? :
713   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
722   ***      0      0      0   if ($short) { }
731   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
735   ***      0      0      0   if ($$self{'dp'})
743   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
755   ***      0      0      0   if ref $_[0] eq 'OptionParser'
758   ***      0      0      0   unless print $prompt
766   ***      0      0      0   unless print "\n"
769   ***      0      0      0   if ($EVAL_ERROR)
791   ***     50     56      0   unless open my $fh, '<', $filename
799   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
802   ***      0      0      0   if ($line eq '--')
807   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
825   ***      0      0      0   unless open my $fh, '<', $file
829   ***      0      0      0   unless $para =~ /^=pod$/m
833   ***      0      0      0   unless $para =~ /$regex/
838   ***      0      0      0   unless close $fh
852   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
867   ***      0      0      0   defined $_ ? :
905   ***      0      0      0   if (not $$self{$dbh})
909   ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
916   ***      0      0      0   defined $_ ? :
999   ***     50      0     12   if (@_ > 2)
1008  ***     50      0      4   if (not $dsn)
1020  ***     50      8      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1032  ***     50      0     32   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1038         100     24      8   if (not defined $final_props{$key})
1045  ***     50      0      8   unless exists $opts{$key}
1048  ***     50      0      4   if (my $required = $self->prop('required'))
1050  ***      0      0      0   unless $final_props{$key}
1059  ***     50      0      4   unless ref $o eq 'OptionParser'
1062         100     28      4   if $o->has($_)
1072  ***      0      0      0   unless ref $dsn
1073  ***      0      0      0   $_ eq 'p' ? :
1074  ***      0      0      0   if defined $$dsn{$_}
1087  ***      0      0      0   $opts{$key}{'copy'} ? :
1101  ***     50      0      4   if ($driver eq 'Pg') { }
1133  ***     50      0      4   $cxn_string =~ /charset=utf8/ ? :
1151  ***     50      4      0   if ($cxn_string =~ /mysql/i)
1159  ***     50      0      4   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1164  ***      0      0      0   if ($charset eq 'utf8') { }
1165  ***      0      0      0   unless binmode STDOUT, ':utf8'
1169  ***      0      0      0   unless binmode STDOUT
1173  ***     50      0      4   if ($self->prop('setvars'))
1180  ***     50      0      4   if (not $dbh and $EVAL_ERROR)
1182  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/)
1186  ***      0      0      0   if (not $tries)
1208  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1225  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1235  ***      0      0      0   unless $dsn_1
1236  ***      0      0      0   unless $dsn_2
1240  ***      0      0      0   if ($args{'overwrite'}) { }
1241  ***      0      0      0   defined $$dsn_1{$key} ? :
1244  ***      0      0      0   defined $$dsn_2{$key} ? :
1253  ***      0      0      0   defined $_ ? :
1282  ***      0      0      0   unless $args{$arg}
1285  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1301  ***      0      0      0   unless defined(my $pid = fork)
1302  ***      0      0      0   if ($pid)
1309  ***      0      0      0   unless POSIX::setsid()
1310  ***      0      0      0   unless chdir '/'
1314  ***      0      0      0   if (-t STDIN)
1316  ***      0      0      0   unless open STDIN, '/dev/null'
1320  ***      0      0      0   if ($$self{'log_file'})
1322  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1326  ***      0      0      0   unless open STDERR, '>&STDOUT'
1336  ***      0      0      0   $self ? :
1338  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1341  ***      0      0      0   if $EVAL_ERROR
1343  ***      0      0      0   if ($pid) { }
1345  ***      0      0      0   if ($pid_is_alive) { }
1367  ***      0      0      0   if (exists $$self{'child'})
1379  ***      0      0      0   if (not $PID_file)
1386  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1388  ***      0      0      0   unless print $PID_FH $PID
1390  ***      0      0      0   unless close $PID_FH
1399  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1400  ***      0      0      0   unless unlink $$self{'PID_file'}
1412  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1418  ***      0      0      0   defined $_ ? :
1461  ***      0      0      0   defined $args{'p_ms'} ? :
1462  ***      0      0      0   defined $args{'p_s'} ? :
1465  ***      0      0      0   if $t < 0
1467  ***      0      0      0   if $t =~ /e/
1471  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1492  ***      0      0      0   $p ? :
1499  ***      0      0      0   unless $secs
1501  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1506  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1525  ***      0      0      0   defined $args{'p'} ? :
1526  ***      0      0      0   defined $args{'d'} ? :
1533  ***      0      0      0   $num =~ /\./ || $n ? :
1552  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?$/)
1555  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
1564  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s) = $val =~ /^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.\d+)?$/)
1581  ***      0      0      0   defined $_ ? :
1632  ***      0      0      0   if (not $curr and @curr)
1636  ***      0      0      0   if (not $prev and @prev)
1640  ***      0      0      0   if ($curr or $prev)
1641  ***      0      0      0   if ($curr and $prev and $$curr[0] == $$prev[0]) { }
      ***      0      0      0   elsif (not $curr or $curr and $prev and $$curr[0] > $$prev[0]) { }
1643  ***      0      0      0   $$curr[5] =~ /\D/ ? :
1645  ***      0      0      0   if ($$prev[7])
1646  ***      0      0      0   if (not $$curr[7] or $$prev[7] ne $$curr[7]) { }
      ***      0      0      0   elsif (defined $$curr[5] and $$curr[5] < $$prev[5]) { }
      ***      0      0      0   elsif ($$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge) { }
1661  ***      0      0      0   if ($is_new)
1665  ***      0      0      0   if ($$curr[7])
1666  ***      0      0      0   if ($$prev[7] and not $is_new) { }
1687  ***      0      0      0   if ($$curr[7] and defined $$curr[5])
1706  ***      0      0      0   if ($$row[5] < $time - $$row[10])
1721  ***      0      0      0   unless $event = &$callback($event)
1731         100    204    430   if ($find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query')
1732         100    156     48   if ($$query{'Time'} < $find_spec{'busy_time'})
1741         100    176   2146   if (defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property}))
1747         100    232   1914   if (defined $find_spec{'match'}{$property})
1748         100    199     33   if (not $self->$filter($query, $find_spec{'match'}{$property}))
1755         100     81     22   if ($matched)
1760         100     43     29   if (@matches and $find_spec{'only_oldest'})
1810  ***      0      0      0   defined $_ ? :
1844         100      3      3   unless @cols
1853  ***      0      0      0   unless @cols
1868         100      3    452   if ($text =~ /^\+---/m) { }
      ***     50      0    452   elsif ($text =~ /^id\tselect_type\t/m) { }
      ***     50    452      0   elsif ($text =~ /\*\*\* \d+\. row/) { }
1884         100      7    445   if ($n_recs > 1)
1900  ***     50      0    448   if ($$self{'value_for'})
1903  ***      0      0      0   if exists $$self{'value_for'}{$$result_set{$key}}
1918         100      3      3   if ($row) { }
1942  ***      0      0      0   defined $_ ? :
2003         100      8      6   if (not $o->got('busy-time')) { }
2004  ***     50      8      0   unless $o->got('interval')
2007  ***     50      6      0   unless $o->got('interval')
2012         100     10      4   if (@ARGV)
2024         100      4     10   if (not @ARGV)
2034         100     10      4   if (@ARGV) { }
2039  ***     50     10      0   if (not $fh)
2041  ***     50      0     10   unless $file
2042  ***     50      0     10   if ($file eq '-') { }
2046  ***     50      0     10   if (not open $fh, '<', $file)
2054  ***     50     10      0   if ($fh)
2057  ***     50     10      0   if ($proclist_text) { }
2082  ***     50      0     14   if ($o->get('daemonize'))
2095  ***     50     14      0   $o->get('ignore-self') ? :
2119  ***     50      0     72   if ($EVAL_ERROR)
2120  ***      0      0      0   if $EVAL_ERROR =~ /No more files/
2125  ***     50     72      0   if ($proclist) { }
2129         100     43      2   if ($o->get('print'))
2134         100      2     43   if ($o->get('execute-command'))
2137  ***     50      0     44   if ($o->get('kill'))
2138  ***      0      0      0   if $o->get('wait-before-kill')
2150         100     60     11   if (!$iters_todo || $iters_done < $iters_todo and $dbh)
2152  ***     50      0     60   if (@queries and $o->get('wait-after-kill')) { }
2174  ***     50      0      4   if ($o->get('ask-pass'))
2187  ***     50      0      2   unless $cmd
2190         100      1      1   if ($pid)
2197  ***     50      0      1   unless POSIX::setsid()
2206  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
255   ***     66    112    336      0   $type and $type eq 'd'
      ***     33    448      0      0   $type and $type eq 'd' and not $$self{'dp'}
260          100    112    252     84   $type and $type =~ /[HhAadzm]/
414   ***     33      0     14      0   @ARGV and $ARGV[0] eq '--config'
443   ***     33      0     14      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
450   ***     66      4     10      0   @ARGV and $$self{'strict'}
534   ***     66      0    112    336   $opt and $$opt{'type'}
537          100    228    100      8   $val and $$opt{'type'} eq 'm'
      ***     66    228    100      0   $val and $$opt{'type'} eq 'd'
      ***     66    228    100      0   $val and $$opt{'type'} eq 'z'
      ***     66    226    102      0   defined $val and $$opt{'type'} eq 'h'
      ***     66    226     88      0   defined $val and $$opt{'type'} eq 'a'
602   ***     33      0      0    460   $long and exists $$self{'opts'}{$long}
610   ***     33      0      0     84   $long and exists $$self{'opts'}{$long}
624   ***     33      0      0     24   $long and exists $$self{'opts'}{$long}
713   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
807   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1032  ***     66      8     24      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     32      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1144  ***     66      4      0      4   not $dbh and $tries--
1180  ***     33      4      0      0   not $dbh and $EVAL_ERROR
1338  ***      0      0      0      0   $PID_file and -f $PID_file
1399  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1471  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1529  ***      0      0      0      0   $num >= $d and $n < @units - 1
1632  ***      0      0      0      0   not $curr and @curr
1636  ***      0      0      0      0   not $prev and @prev
1641  ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] == $$prev[0]
      ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] > $$prev[0]
1646  ***      0      0      0      0   defined $$curr[5] and $$curr[5] < $$prev[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge
1666  ***      0      0      0      0   $$prev[7] and not $is_new
1687  ***      0      0      0      0   $$curr[7] and defined $$curr[5]
1731         100    346     84    204   $find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query'
1741         100   1193    953    176   defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property})
1760         100     28      1     43   @matches and $find_spec{'only_oldest'}
1769  ***     33      0      0    120   defined $property && defined $$query{'Id'}
      ***     33      0    120      0   defined $property && defined $$query{'Id'} && $$query{'Id'} == $property
1774  ***     33      0      0    478   defined $property && defined $$query{'User'}
      ***     66      0    366    112   defined $property && defined $$query{'User'} && $$query{'User'} =~ /$property/
1780  ***      0      0      0      0   defined $property && defined $$query{'Host'}
      ***      0      0      0      0   defined $property && defined $$query{'Host'} && $$query{'Host'} =~ /$property/
1786  ***      0      0      0      0   defined $property && defined $$query{'db'}
      ***      0      0      0      0   defined $property && defined $$query{'db'} && $$query{'db'} =~ /$property/
1792  ***     66      0     92    500   defined $property && defined $$query{'State'}
             100     92    471     29   defined $property && defined $$query{'State'} && $$query{'State'} =~ /$property/
1798  ***     33      0      0    170   defined $property && defined $$query{'Command'}
      ***     66      0    103     67   defined $property && defined $$query{'Command'} && $$query{'Command'} =~ /$property/
1804  ***     33      0      0      1   defined $property && defined $$query{'Info'}
      ***     33      0      0      1   defined $property && defined $$query{'Info'} && $$query{'Info'} =~ /$property/
2113         100      2     11     72   $start == $end || $now < $end and !$iters_todo || $iters_done++ < $iters_todo
2150  ***     66     11      0     60   !$iters_todo || $iters_done < $iters_todo and $dbh
2152  ***     66     24     36      0   @queries and $o->get('wait-after-kill')

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
60    ***     50     14      0   $program_name ||= $PROGRAM_NAME
62    ***     50     14      0   $args{'prompt'} || '<options>'
      ***     50      0     14   $args{'dp'} || undef
104   ***     50      0     14   $file ||= '../mk-kill'
245   ***     50    448      0   $$opt{'group'} ||= 'default'
542   ***     50      0      2   $s || 's'
579   ***      0      0      0   $pre || ''
586   ***      0      0      0   $val || ''
589   ***     50     14      0   $val || ''
647   ***      0      0      0   $$self{'description'} || ''
715   ***      0      0      0   $s ||= 's'
741   ***      0      0      0   $$opt{'type'} || ''
1013  ***     50      0      4   $prev ||= {}
1014  ***     50      0      4   $defaults ||= {}
1087  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1100  ***     50      0      4   $self->prop('dbidriver') || ''
1104  ***      0      0      0   $$info{'D'} || ''
1110  ***     50      0      4   $$info{'D'} || ''
1132  ***     50      4      0   $opts ||= {}
1208  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1224  ***      0      0      0   $level ||= 0
1225  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1491  ***      0      0      0   $args{'p'} || 0
1493  ***      0      0      0   $of ||= 1
1498  ***      0      0      0   $secs ||= 0
1627  ***      0      0      0   $$misc{'prev'} ||= []
1731  ***     50    288      0   $$query{'Command'} || ''
2092         100      2     12   $o->get('run-time') || 0
2130  ***     50     43      0   $$query{'Command'} || 'NULL'
      ***     50     43      0   $$query{'Info'} || 'NULL'

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
537   ***     33      0      0    328   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66     14      0    314   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1123  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1124  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1125  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1126  ***      0      0      0      0   $$dsn{'u'} ||= $user
1127  ***      0      0      0      0   $$dsn{'D'} ||= $db
1412  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1501  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1533  ***      0      0      0      0   $num =~ /\./ || $n
1631  ***      0      0      0      0   @curr or @prev
      ***      0      0      0      0   @curr or @prev or $curr
      ***      0      0      0      0   @curr or @prev or $curr or $prev
1640  ***      0      0      0      0   $curr or $prev
1641  ***      0      0      0      0   not $curr or $curr and $prev and $$curr[0] > $$prev[0]
1646  ***      0      0      0      0   not $$curr[7] or $$prev[7] ne $$curr[7]
2113         100     61     22      2   $start == $end || $now < $end
             100     22     50     11   !$iters_todo || $iters_done++ < $iters_todo
2150         100     22     38     11   !$iters_todo || $iters_done < $iters_todo


Covered Subroutines
-------------------

Subroutine                   Count Location                                     
---------------------------- ----- ---------------------------------------------
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1271
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1272
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1274
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1275
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1277
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1436
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1437
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1438
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1439
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1440
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1442
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1598
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1599
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1600
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1602
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1615
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1828
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1829
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1830
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1832
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1964
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1965
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1966
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1970
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:22  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:23  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:34  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:35  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:37  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:38  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:39  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:41  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:884 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:885 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:887 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:889 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:931 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:932 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:936 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:937 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:940 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:942 
__ANON__                        10 /home/daniel/dev/maatkit/mk-kill/mk-kill:2039
__ANON__                        62 /home/daniel/dev/maatkit/mk-kill/mk-kill:2073
__ANON__                        45 /home/daniel/dev/maatkit/mk-kill/mk-kill:438 
_find_match_Command            170 /home/daniel/dev/maatkit/mk-kill/mk-kill:1797
_find_match_Id                 120 /home/daniel/dev/maatkit/mk-kill/mk-kill:1768
_find_match_Info                 1 /home/daniel/dev/maatkit/mk-kill/mk-kill:1803
_find_match_State              592 /home/daniel/dev/maatkit/mk-kill/mk-kill:1791
_find_match_User               478 /home/daniel/dev/maatkit/mk-kill/mk-kill:1773
_get_participants               14 /home/daniel/dev/maatkit/mk-kill/mk-kill:328 
_parse_horizontal_result_set     3 /home/daniel/dev/maatkit/mk-kill/mk-kill:1913
_parse_specs                    14 /home/daniel/dev/maatkit/mk-kill/mk-kill:209 
_parse_vertical_result_set     445 /home/daniel/dev/maatkit/mk-kill/mk-kill:1929
_pod_to_specs                   14 /home/daniel/dev/maatkit/mk-kill/mk-kill:103 
_read_config_file               56 /home/daniel/dev/maatkit/mk-kill/mk-kill:790 
_set_option                     45 /home/daniel/dev/maatkit/mk-kill/mk-kill:384 
_split_vertical_result_sets      7 /home/daniel/dev/maatkit/mk-kill/mk-kill:1934
_validate_type                 448 /home/daniel/dev/maatkit/mk-kill/mk-kill:533 
exec_cmd                         2 /home/daniel/dev/maatkit/mk-kill/mk-kill:2185
find                            72 /home/daniel/dev/maatkit/mk-kill/mk-kill:1726
get                            460 /home/daniel/dev/maatkit/mk-kill/mk-kill:600 
get_cxn                          4 /home/daniel/dev/maatkit/mk-kill/mk-kill:2173
get_cxn_params                   4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1097
get_dbh                          4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1131
get_defaults_files              14 /home/daniel/dev/maatkit/mk-kill/mk-kill:98  
get_opts                        14 /home/daniel/dev/maatkit/mk-kill/mk-kill:401 
get_specs                       14 /home/daniel/dev/maatkit/mk-kill/mk-kill:91  
got                             84 /home/daniel/dev/maatkit/mk-kill/mk-kill:608 
has                             46 /home/daniel/dev/maatkit/mk-kill/mk-kill:616 
main                            14 /home/daniel/dev/maatkit/mk-kill/mk-kill:1980
new                             14 /home/daniel/dev/maatkit/mk-kill/mk-kill:1618
new                             10 /home/daniel/dev/maatkit/mk-kill/mk-kill:1835
new                             14 /home/daniel/dev/maatkit/mk-kill/mk-kill:55  
new                             14 /home/daniel/dev/maatkit/mk-kill/mk-kill:892 
new                             14 /home/daniel/dev/maatkit/mk-kill/mk-kill:945 
parse                            4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1007
parse                          455 /home/daniel/dev/maatkit/mk-kill/mk-kill:1865
parse_options                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1058
parse_tabular                    6 /home/daniel/dev/maatkit/mk-kill/mk-kill:1841
parse_vertical                 445 /home/daniel/dev/maatkit/mk-kill/mk-kill:1859
prop                            12 /home/daniel/dev/maatkit/mk-kill/mk-kill:998 
set                             24 /home/daniel/dev/maatkit/mk-kill/mk-kill:622 
ts                              43 /home/daniel/dev/maatkit/mk-kill/mk-kill:1541
usage_or_errors                 14 /home/daniel/dev/maatkit/mk-kill/mk-kill:657 

Uncovered Subroutines
---------------------

Subroutine                   Count Location                                     
---------------------------- ----- ---------------------------------------------
DESTROY                          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1411
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1252
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1417
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1580
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1809
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1941
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2205
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:866 
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:915 
_find_match_Host                 0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1779
_find_match_db                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1785
_make_PID_file                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1376
_remove_PID_file                 0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1398
as_string                        0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1071
check_PID_file                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1335
clone                            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:843 
copy                             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1234
daemonize                        0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1298
descr                            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:646 
disconnect                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1217
errors                           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:636 
fill_in_dsn                      0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1119
fire_event                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1704
get_defaults                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:374 
get_groups                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:379 
get_hostname                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1207
make_PID_file                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1366
make_checksum                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1573
micro_t                          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1460
new                              0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1280
opt_values                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:346 
opts                             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:340 
parse                            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:897 
parse_event                      0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1623
parse_tab_sep                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1850
parse_timestamp                  0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1551
percentage_of                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1490
print_active_handles             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1223
print_errors                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:670 
print_usage                      0 /home/daniel/dev/maatkit/mk-kill/mk-kill:680 
prompt                           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:641 
prompt_noecho                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:755 
read_para_after                  0 /home/daniel/dev/maatkit/mk-kill/mk-kill:824 
save_error                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:631 
secs_to_time                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1497
set_defaults                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:362 
short_opts                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:356 
shorten                          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1524
unix_timestamp                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1563
usage                            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1080
version_ge                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:904 


