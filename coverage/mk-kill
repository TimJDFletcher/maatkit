---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...v/maatkit/mk-kill/mk-kill   45.2   28.1   28.9   58.7    n/a  100.0   39.3
Total                          45.2   28.1   28.9   58.7    n/a  100.0   39.3
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:46 2010
Finish:       Thu Jan 28 22:22:46 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:47 2010
Finish:       Thu Jan 28 22:23:04 2010

Run:          ./102_match.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:23:07 2010
Finish:       Thu Jan 28 22:23:07 2010

Run:          ./103_execute_command.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:23:10 2010
Finish:       Thu Jan 28 22:23:11 2010

Run:          ./104_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:23:14 2010
Finish:       Thu Jan 28 22:23:16 2010

/home/daniel/dev/maatkit/mk-kill/mk-kill

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-kill, a program that kills queries in MySQL.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22             4                    4            30   use strict;
               4                                 12   
               4                                 33   
23             4                    4            32   use warnings FATAL => 'all';
               4                                 14   
               4                                 25   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5455 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # OptionParser package 5266
31                                                    # ###########################################################################
32                                                    package OptionParser;
33                                                    
34             4                    4            26   use strict;
               4                                 12   
               4                                 22   
35             4                    4            24   use warnings FATAL => 'all';
               4                                  9   
               4                                 21   
36                                                    
37             4                    4            38   use Getopt::Long;
               4                                 14   
               4                                 28   
38             4                    4            29   use List::Util qw(max);
               4                                 11   
               4                                 43   
39             4                    4            24   use English qw(-no_match_vars);
               4                                 12   
               4                                 25   
40                                                    
41    ***      4            50      4            26   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 10   
               4                                 71   
42                                                    
43                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
44                                                    
45                                                    my %attributes = (
46                                                       'type'       => 1,
47                                                       'short form' => 1,
48                                                       'group'      => 1,
49                                                       'default'    => 1,
50                                                       'cumulative' => 1,
51                                                       'negatable'  => 1,
52                                                    );
53                                                    
54                                                    sub new {
55            10                   10            90      my ( $class, %args ) = @_;
56            10                                 45      foreach my $arg ( qw(description) ) {
57    ***     10     50                          64         die "I need a $arg argument" unless $args{$arg};
58                                                       }
59            10                                 93      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
60    ***     10            33                   45      $program_name ||= $PROGRAM_NAME;
61    ***     10            33                   88      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
62                                                    
63    ***     10     50     50                  329      my $self = {
      ***                   50                        
64                                                          description    => $args{description},
65                                                          prompt         => $args{prompt} || '<options>',
66                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
67                                                          dp             => $args{dp}     || undef,
68                                                          program_name   => $program_name,
69                                                          opts           => {},
70                                                          got_opts       => 0,
71                                                          short_opts     => {},
72                                                          defaults       => {},
73                                                          groups         => {},
74                                                          allowed_groups => {},
75                                                          errors         => [],
76                                                          rules          => [],  # desc of rules for --help
77                                                          mutex          => [],  # rule: opts are mutually exclusive
78                                                          atleast1       => [],  # rule: at least one opt is required
79                                                          disables       => {},  # rule: opt disables other opts 
80                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
81                                                          default_files  => [
82                                                             "/etc/maatkit/maatkit.conf",
83                                                             "/etc/maatkit/$program_name.conf",
84                                                             "$home/.maatkit.conf",
85                                                             "$home/.$program_name.conf",
86                                                          ],
87                                                       };
88            10                                 72      return bless $self, $class;
89                                                    }
90                                                    
91                                                    sub get_specs {
92            10                   10            42      my ( $self, $file ) = @_;
93            10                                 53      my @specs = $self->_pod_to_specs($file);
94            10                                194      $self->_parse_specs(@specs);
95            10                                 57      return;
96                                                    }
97                                                    
98                                                    sub get_defaults_files {
99            10                   10            36      my ( $self ) = @_;
100           10                                 28      return @{$self->{default_files}};
              10                                 93   
101                                                   }
102                                                   
103                                                   sub _pod_to_specs {
104           10                   10            55      my ( $self, $file ) = @_;
105   ***     10            50                   49      $file ||= __FILE__;
106   ***     10     50                         322      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
107                                                   
108           10                                629      my %types = (
109                                                         string => 's', # standard Getopt type
110                                                         'int'  => 'i', # standard Getopt type
111                                                         float  => 'f', # standard Getopt type
112                                                         Hash   => 'H', # hash, formed from a comma-separated list
113                                                         hash   => 'h', # hash as above, but only if a value is given
114                                                         Array  => 'A', # array, similar to Hash
115                                                         array  => 'a', # array, similar to hash
116                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
117                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
118                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
119                                                      );
120           10                                 32      my @specs = ();
121           10                                 30      my @rules = ();
122           10                                 24      my $para;
123                                                   
124           10                                 62      local $INPUT_RECORD_SEPARATOR = '';
125           10                                256      while ( $para = <$fh> ) {
126         3240    100                       20576         next unless $para =~ m/^=head1 OPTIONS/;
127           10                                 34         last;
128                                                      }
129                                                   
130           10                                 52      while ( $para = <$fh> ) {
131           20    100                          96         last if $para =~ m/^=over/;
132           10                                 39         chomp $para;
133           10                                 80         $para =~ s/\s+/ /g;
134           10                                242         $para =~ s/$POD_link_re/$1/go;
135           10                                 29         MKDEBUG && _d('Option rule:', $para);
136           10                                 70         push @rules, $para;
137                                                      }
138                                                   
139   ***     10     50                          39      die 'POD has no OPTIONS section' unless $para;
140                                                   
141           10                                 28      do {
142          410    100                        2537         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
143          400                               1081            chomp $para;
144          400                                902            MKDEBUG && _d($para);
145          400                                899            my %attribs;
146                                                   
147          400                               1349            $para = <$fh>; # read next paragraph, possibly attributes
148                                                   
149          400    100                        1426            if ( $para =~ m/: / ) { # attributes
150          350                               1585               $para =~ s/\s+\Z//g;
151          640                               2709               %attribs = map {
152          350                               1496                     my ( $attrib, $val) = split(/: /, $_);
153   ***    640     50                        2644                     die "Unrecognized attribute for --$option: $attrib"
154                                                                        unless $attributes{$attrib};
155          640                               2826                     ($attrib, $val);
156                                                                  } split(/; /, $para);
157          350    100                        1627               if ( $attribs{'short form'} ) {
158           70                                318                  $attribs{'short form'} =~ s/-//;
159                                                               }
160          350                               1493               $para = <$fh>; # read next paragraph, probably short help desc
161                                                            }
162                                                            else {
163           50                                110               MKDEBUG && _d('Option has no attributes');
164                                                            }
165                                                   
166          400                               2710            $para =~ s/\s+\Z//g;
167          400                               2873            $para =~ s/\s+/ /g;
168          400                               1568            $para =~ s/$POD_link_re/$1/go;
169                                                   
170          400                               1583            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
171          400                                896            MKDEBUG && _d('Short help:', $para);
172                                                   
173   ***    400     50                        1548            die "No description after option spec $option" if $para =~ m/^=item/;
174                                                   
175          400    100                        1743            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
176           20                                 49               $option = $base_option;
177           20                                 70               $attribs{'negatable'} = 1;
178                                                            }
179                                                   
180          400    100                        6197            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
                    100                               
181                                                               spec  => $option
182                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
183                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
184                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
185                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
186                                                               desc  => $para
187                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
188                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
189                                                            };
190                                                         }
191          410                               2384         while ( $para = <$fh> ) {
192   ***    690     50                        2335            last unless $para;
193                                                   
194                                                   
195          690    100                        2404            if ( $para =~ m/^=head1/ ) {
196           10                                 31               $para = undef; # Can't 'last' out of a do {} block.
197           10                                 43               last;
198                                                            }
199          680    100                        4039            last if $para =~ m/^=item --/;
200                                                         }
201                                                      } while ( $para );
202                                                   
203   ***     10     50                          38      die 'No valid specs in POD OPTIONS' unless @specs;
204                                                   
205           10                                101      close $fh;
206           10                                 28      return @specs, @rules;
207                                                   }
208                                                   
209                                                   sub _parse_specs {
210           10                   10            87      my ( $self, @specs ) = @_;
211           10                                 39      my %disables; # special rule that requires deferred checking
212                                                   
213           10                                 39      foreach my $opt ( @specs ) {
214          410    100                        1401         if ( ref $opt ) { # It's an option spec, not a rule.
215                                                            MKDEBUG && _d('Parsing opt spec:',
216          400                                863               map { ($_, '=>', $opt->{$_}) } keys %$opt);
217                                                   
218          400                               2464            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
219   ***    400     50                        1546            if ( !$long ) {
220   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
221                                                            }
222          400                               1318            $opt->{long} = $long;
223                                                   
224   ***    400     50                        1674            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
225          400                               1536            $self->{opts}->{$long} = $opt;
226                                                   
227   ***    400     50                        1555            if ( length $long == 1 ) {
228   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
229   ***      0                                  0               $self->{short_opts}->{$long} = $long;
230                                                            }
231                                                   
232          400    100                        1251            if ( $short ) {
233   ***     70     50                         295               die "Duplicate short option -$short"
234                                                                  if exists $self->{short_opts}->{$short};
235           70                                259               $self->{short_opts}->{$short} = $long;
236           70                                233               $opt->{short} = $short;
237                                                            }
238                                                            else {
239          330                               1077               $opt->{short} = undef;
240                                                            }
241                                                   
242          400    100                        1880            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
243   ***    400     50                        1787            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
244   ***    400     50                        1989            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
245                                                   
246   ***    400            50                 1602            $opt->{group} ||= 'default';
247          400                               1857            $self->{groups}->{ $opt->{group} }->{$long} = 1;
248                                                   
249          400                               1178            $opt->{value} = undef;
250          400                               1226            $opt->{got}   = 0;
251                                                   
252          400                               1923            my ( $type ) = $opt->{spec} =~ m/=(.)/;
253          400                               1364            $opt->{type} = $type;
254          400                                945            MKDEBUG && _d($long, 'type:', $type);
255                                                   
256   ***    400     50     66                 3214            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
257   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
258                                                                  . "was given when this OptionParser object was created";
259                                                            }
260                                                   
261          400    100    100                 2770            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
262                                                   
263          400    100                        2151            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
264   ***     70     50                         347               $self->{defaults}->{$long} = defined $def ? $def : 1;
265           70                                161               MKDEBUG && _d($long, 'default:', $def);
266                                                            }
267                                                   
268          400    100                        1433            if ( $long eq 'config' ) {
269           10                                 53               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
270                                                            }
271                                                   
272   ***    400     50                        1839            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
273   ***      0                                  0               $disables{$long} = $dis;
274   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
275                                                            }
276                                                   
277          400                               1818            $self->{opts}->{$long} = $opt;
278                                                         }
279                                                         else { # It's an option rule, not a spec.
280           10                                 26            MKDEBUG && _d('Parsing rule:', $opt); 
281           10                                 25            push @{$self->{rules}}, $opt;
              10                                 48   
282           10                                 52            my @participants = $self->_get_participants($opt);
283           10                                 31            my $rule_ok = 0;
284                                                   
285   ***     10     50                          80            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
286   ***      0                                  0               $rule_ok = 1;
287   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
288   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
289                                                            }
290   ***     10     50                          72            if ( $opt =~ m/at least one|one and only one/ ) {
291           10                                 30               $rule_ok = 1;
292           10                                 23               push @{$self->{atleast1}}, \@participants;
              10                                 47   
293           10                                 29               MKDEBUG && _d(@participants, 'require at least one');
294                                                            }
295   ***     10     50                          45            if ( $opt =~ m/default to/ ) {
296   ***      0                                  0               $rule_ok = 1;
297   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
298   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
299                                                            }
300   ***     10     50                          41            if ( $opt =~ m/restricted to option groups/ ) {
301   ***      0                                  0               $rule_ok = 1;
302   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
303   ***      0                                  0               my @groups = split(',', $groups);
304   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
305   ***      0                                  0                  s/\s+//;
306   ***      0                                  0                  $_ => 1;
307                                                               } @groups;
308                                                            }
309                                                   
310   ***     10     50                          55            die "Unrecognized option rule: $opt" unless $rule_ok;
311                                                         }
312                                                      }
313                                                   
314           10                                 54      foreach my $long ( keys %disables ) {
315   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
316   ***      0                                  0         $self->{disables}->{$long} = \@participants;
317   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
318                                                      }
319                                                   
320           10                                 50      return; 
321                                                   }
322                                                   
323                                                   sub _get_participants {
324           10                   10            40      my ( $self, $str ) = @_;
325           10                                 31      my @participants;
326           10                                 93      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
327   ***     30     50                         143         die "Option --$long does not exist while processing rule $str"
328                                                            unless exists $self->{opts}->{$long};
329           30                                111         push @participants, $long;
330                                                      }
331           10                                 28      MKDEBUG && _d('Participants for', $str, ':', @participants);
332           10                                 63      return @participants;
333                                                   }
334                                                   
335                                                   sub opts {
336   ***      0                    0             0      my ( $self ) = @_;
337   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
338   ***      0                                  0      return %opts;
339                                                   }
340                                                   
341                                                   sub short_opts {
342   ***      0                    0             0      my ( $self ) = @_;
343   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
344   ***      0                                  0      return %short_opts;
345                                                   }
346                                                   
347                                                   sub set_defaults {
348   ***      0                    0             0      my ( $self, %defaults ) = @_;
349   ***      0                                  0      $self->{defaults} = {};
350   ***      0                                  0      foreach my $long ( keys %defaults ) {
351   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
352                                                            unless exists $self->{opts}->{$long};
353   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
354   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
355                                                      }
356   ***      0                                  0      return;
357                                                   }
358                                                   
359                                                   sub get_defaults {
360   ***      0                    0             0      my ( $self ) = @_;
361   ***      0                                  0      return $self->{defaults};
362                                                   }
363                                                   
364                                                   sub get_groups {
365   ***      0                    0             0      my ( $self ) = @_;
366   ***      0                                  0      return $self->{groups};
367                                                   }
368                                                   
369                                                   sub _set_option {
370           25                   25           108      my ( $self, $opt, $val ) = @_;
371   ***     25      0                          53      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
372                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
373                                                               : die "Getopt::Long gave a nonexistent option: $opt";
374                                                   
375           25                                 47      $opt = $self->{opts}->{$long};
376   ***     25     50                         127      if ( $opt->{is_cumulative} ) {
377   ***      0                                  0         $opt->{value}++;
378                                                      }
379                                                      else {
380           25                                 96         $opt->{value} = $val;
381                                                      }
382           25                                 74      $opt->{got} = 1;
383           25                                 89      MKDEBUG && _d('Got option', $long, '=', $val);
384                                                   }
385                                                   
386                                                   sub get_opts {
387           10                   10            41      my ( $self ) = @_; 
388                                                   
389           10                                 29      foreach my $long ( keys %{$self->{opts}} ) {
              10                                106   
390          400                               1508         $self->{opts}->{$long}->{got} = 0;
391   ***    400     50                        2981         $self->{opts}->{$long}->{value}
                    100                               
392                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
393                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
394                                                            : undef;
395                                                      }
396           10                                 58      $self->{got_opts} = 0;
397                                                   
398           10                                 41      $self->{errors} = [];
399                                                   
400   ***     10     50     33                  106      if ( @ARGV && $ARGV[0] eq "--config" ) {
401   ***      0                                  0         shift @ARGV;
402   ***      0                                  0         $self->_set_option('config', shift @ARGV);
403                                                      }
404   ***     10     50                          49      if ( $self->has('config') ) {
405           10                                 29         my @extra_args;
406           10                                 51         foreach my $filename ( split(',', $self->get('config')) ) {
407           40                                101            eval {
408           40                                164               push @extra_args, $self->_read_config_file($filename);
409                                                            };
410   ***     40     50                         227            if ( $EVAL_ERROR ) {
411   ***     40     50                         158               if ( $self->got('config') ) {
412   ***      0                                  0                  die $EVAL_ERROR;
413                                                               }
414                                                               elsif ( MKDEBUG ) {
415                                                                  _d($EVAL_ERROR);
416                                                               }
417                                                            }
418                                                         }
419           10                                 53         unshift @ARGV, @extra_args;
420                                                      }
421                                                   
422           10                                 62      Getopt::Long::Configure('no_ignore_case', 'bundling');
423                                                      GetOptions(
424          390                   25          2360         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              25                                116   
             400                               1425   
425           10                                 67         grep   { $_->{long} ne 'config' } # --config is handled specially above.
426   ***     10     50                          34         values %{$self->{opts}}
427                                                      ) or $self->save_error('Error parsing options');
428                                                   
429   ***     10     50     33                  563      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
430   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
431                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
432                                                               or die "Cannot print: $OS_ERROR";
433   ***      0                                  0         exit 0;
434                                                      }
435                                                   
436   ***     10     50     33                   87      if ( @ARGV && $self->{strict} ) {
437   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
438                                                      }
439                                                   
440           10                                 26      foreach my $mutex ( @{$self->{mutex}} ) {
              10                                 58   
441   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
442   ***      0      0                           0         if ( @set > 1 ) {
443   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
444   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
445                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
446                                                                    . ' are mutually exclusive.';
447   ***      0                                  0            $self->save_error($err);
448                                                         }
449                                                      }
450                                                   
451           10                                 32      foreach my $required ( @{$self->{atleast1}} ) {
              10                                 47   
452           10                                 38         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
              30                                143   
453   ***     10     50                          60         if ( @set == 0 ) {
454   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
455   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
456                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
457   ***      0                                  0            $self->save_error("Specify at least one of $err");
458                                                         }
459                                                      }
460                                                   
461           10                                 31      foreach my $long ( keys %{$self->{opts}} ) {
              10                                 95   
462          400                               1431         my $opt = $self->{opts}->{$long};
463          400    100                        2012         if ( $opt->{got} ) {
      ***            50                               
464   ***     25     50                         111            if ( exists $self->{disables}->{$long} ) {
465   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
466   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
467   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
468                                                                  'because', $long,'disables them');
469                                                            }
470                                                   
471   ***     25     50                         116            if ( exists $self->{allowed_groups}->{$long} ) {
472                                                   
473   ***      0                                  0               my @restricted_groups = grep {
474   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
475   ***      0                                  0               } keys %{$self->{groups}};
476                                                   
477   ***      0                                  0               my @restricted_opts;
478   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
479   ***      0                                  0                  RESTRICTED_OPT:
480   ***      0                                  0                  foreach my $restricted_opt (
481                                                                     keys %{$self->{groups}->{$restricted_group}} )
482                                                                  {
483   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
484   ***      0      0                           0                     push @restricted_opts, $restricted_opt
485                                                                        if $self->{opts}->{$restricted_opt}->{got};
486                                                                  }
487                                                               }
488                                                   
489   ***      0      0                           0               if ( @restricted_opts ) {
490   ***      0                                  0                  my $err;
491   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
492   ***      0                                  0                     $err = "--$restricted_opts[0]";
493                                                                  }
494                                                                  else {
495   ***      0                                  0                     $err = join(', ',
496   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
497   ***      0                                  0                               grep { $_ } 
498                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
499                                                                            )
500                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
501                                                                  }
502   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
503                                                               }
504                                                            }
505                                                   
506                                                         }
507                                                         elsif ( $opt->{is_required} ) { 
508   ***      0                                  0            $self->save_error("Required option --$long must be specified");
509                                                         }
510                                                   
511          400                               1375         $self->_validate_type($opt);
512                                                      }
513                                                   
514           10                                 64      $self->{got_opts} = 1;
515           10                                 30      return;
516                                                   }
517                                                   
518                                                   sub _validate_type {
519          400                  400          1322      my ( $self, $opt ) = @_;
520   ***    400    100     66                 3162      return unless $opt && $opt->{type};
521          310                                935      my $val = $opt->{value};
522                                                   
523          310    100    100                 6938      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
524            4                                 10         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
525            4                                 36         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
526   ***      4     50                          22         if ( !$suffix ) {
527            4                                 19            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
528   ***      4            50                   36            $suffix = $s || 's';
529            4                                  9            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
530                                                               $opt->{long}, '(value:', $val, ')');
531                                                         }
532   ***      4     50                          20         if ( $suffix =~ m/[smhd]/ ) {
533   ***      4      0                          17            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***            50                               
534                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
535                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
536                                                                 :                  $num * 86400;   # Days
537   ***      4            50                   43            $opt->{value} = ($prefix || '') . $val;
538            4                                 12            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
539                                                         }
540                                                         else {
541   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
542                                                         }
543                                                      }
544                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
545   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
546   ***      0                                  0         my $prev = {};
547   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
548   ***      0      0                           0         if ( $from_key ) {
549   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
550   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
551                                                         }
552   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
553   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
554                                                      }
555                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
556   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
557   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
558   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
559   ***      0      0                           0         if ( defined $num ) {
560   ***      0      0                           0            if ( $factor ) {
561   ***      0                                  0               $num *= $factor_for{$factor};
562   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
563                                                                  'to num', $num, '* factor', $factor);
564                                                            }
565   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
566                                                         }
567                                                         else {
568   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
569                                                         }
570                                                      }
571                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
572   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
573                                                      }
574                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
575   ***     10            50                  128         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
576                                                      }
577                                                      else {
578          296                                657         MKDEBUG && _d('Nothing to validate for option',
579                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
580                                                      }
581                                                   
582          310                                995      return;
583                                                   }
584                                                   
585                                                   sub get {
586          270                  270           978      my ( $self, $opt ) = @_;
587   ***    270     50                        1067      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
588   ***    270     50     33                 2121      die "Option $opt does not exist"
589                                                         unless $long && exists $self->{opts}->{$long};
590          270                               1834      return $self->{opts}->{$long}->{value};
591                                                   }
592                                                   
593                                                   sub got {
594           60                   60           245      my ( $self, $opt ) = @_;
595   ***     60     50                         244      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
596   ***     60     50     33                  511      die "Option $opt does not exist"
597                                                         unless $long && exists $self->{opts}->{$long};
598           60                                382      return $self->{opts}->{$long}->{got};
599                                                   }
600                                                   
601                                                   sub has {
602           10                   10            45      my ( $self, $opt ) = @_;
603   ***     10     50                          47      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
604   ***     10     50                          71      return defined $long ? exists $self->{opts}->{$long} : 0;
605                                                   }
606                                                   
607                                                   sub set {
608           20                   20            89      my ( $self, $opt, $val ) = @_;
609   ***     20     50                          85      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
610   ***     20     50     33                  177      die "Option $opt does not exist"
611                                                         unless $long && exists $self->{opts}->{$long};
612           20                                 83      $self->{opts}->{$long}->{value} = $val;
613           20                                101      return;
614                                                   }
615                                                   
616                                                   sub save_error {
617   ***      0                    0             0      my ( $self, $error ) = @_;
618   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
619                                                   }
620                                                   
621                                                   sub errors {
622   ***      0                    0             0      my ( $self ) = @_;
623   ***      0                                  0      return $self->{errors};
624                                                   }
625                                                   
626                                                   sub prompt {
627   ***      0                    0             0      my ( $self ) = @_;
628   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
629                                                   }
630                                                   
631                                                   sub descr {
632   ***      0                    0             0      my ( $self ) = @_;
633   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
634                                                                 . "  For more details, please use the --help option, "
635                                                                 . "or try 'perldoc $PROGRAM_NAME' "
636                                                                 . "for complete documentation.";
637   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
638   ***      0                                  0      $descr =~ s/ +$//mg;
639   ***      0                                  0      return $descr;
640                                                   }
641                                                   
642                                                   sub usage_or_errors {
643           10                   10            34      my ( $self ) = @_;
644   ***     10     50                          57      if ( $self->{opts}->{help}->{got} ) {
      ***     10     50                          53   
645   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
646   ***      0                                  0         exit 0;
647                                                      }
648                                                      elsif ( scalar @{$self->{errors}} ) {
649   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
650   ***      0                                  0         exit 0;
651                                                      }
652           10                                 33      return;
653                                                   }
654                                                   
655                                                   sub print_errors {
656   ***      0                    0             0      my ( $self ) = @_;
657   ***      0                                  0      my $usage = $self->prompt() . "\n";
658   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
659   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
660                                                                 . "\n";
661                                                      }
662   ***      0                                  0      return $usage . "\n" . $self->descr();
663                                                   }
664                                                   
665                                                   sub print_usage {
666   ***      0                    0             0      my ( $self ) = @_;
667   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
668   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
669                                                   
670   ***      0      0                           0      my $maxl = max(
671   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
672                                                         @opts);
673                                                   
674   ***      0      0                           0      my $maxs = max(0,
675   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
676   ***      0                                  0         values %{$self->{short_opts}});
677                                                   
678   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
679   ***      0                                  0      my $rcol = 80 - $lcol - 6;
680   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
681                                                   
682   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
683                                                   
684   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
685                                                   
686   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
687   ***      0                                  0      push @groups, 'default';
688                                                   
689   ***      0                                  0      foreach my $group ( reverse @groups ) {
690   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
691   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
692   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
693                                                            grep { $_->{group} eq $group }
694                                                            @opts )
695                                                         {
696   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
697   ***      0                                  0            my $short = $opt->{short};
698   ***      0                                  0            my $desc  = $opt->{desc};
699   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
700   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
701   ***      0             0                    0               $s    ||= 's';
702   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
703   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
704                                                                      . "d=days; if no suffix, $s is used.";
705                                                            }
706   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
707   ***      0                                  0            $desc =~ s/ +$//mg;
708   ***      0      0                           0            if ( $short ) {
709   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
710                                                            }
711                                                            else {
712   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
713                                                            }
714                                                         }
715                                                      }
716                                                   
717   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
718   ***      0                                  0         $usage .= "\nRules:\n\n";
719   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
720                                                      }
721   ***      0      0                           0      if ( $self->{dp} ) {
722   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
723                                                      }
724   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
725   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
726   ***      0                                  0         my $val   = $opt->{value};
727   ***      0             0                    0         my $type  = $opt->{type} || '';
728   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
729   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
730                                                                   : !defined $val             ? '(No value)'
731                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
732                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
733                                                                   : $type =~ m/A|a/           ? join(',', @$val)
734                                                                   :                             $val;
735   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
736                                                      }
737   ***      0                                  0      return $usage;
738                                                   }
739                                                   
740                                                   sub prompt_noecho {
741   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
742   ***      0                                  0      my ( $prompt ) = @_;
743   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
744   ***      0      0                           0      print $prompt
745                                                         or die "Cannot print: $OS_ERROR";
746   ***      0                                  0      my $response;
747   ***      0                                  0      eval {
748   ***      0                                  0         require Term::ReadKey;
749   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
750   ***      0                                  0         chomp($response = <STDIN>);
751   ***      0                                  0         Term::ReadKey::ReadMode('normal');
752   ***      0      0                           0         print "\n"
753                                                            or die "Cannot print: $OS_ERROR";
754                                                      };
755   ***      0      0                           0      if ( $EVAL_ERROR ) {
756   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
757                                                      }
758   ***      0                                  0      return $response;
759                                                   }
760                                                   
761                                                   if ( MKDEBUG ) {
762                                                      print '# ', $^X, ' ', $], "\n";
763                                                      my $uname = `uname -a`;
764                                                      if ( $uname ) {
765                                                         $uname =~ s/\s+/ /g;
766                                                         print "# $uname\n";
767                                                      }
768                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
769                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
770                                                         ($main::SVN_REV || ''), __LINE__);
771                                                      print('# Arguments: ',
772                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
773                                                   }
774                                                   
775                                                   sub _read_config_file {
776           40                   40           163      my ( $self, $filename ) = @_;
777   ***     40     50                          98      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
778   ***      0                                  0      my @args;
779   ***      0                                  0      my $prefix = '--';
780   ***      0                                  0      my $parse  = 1;
781                                                   
782                                                      LINE:
783   ***      0                                  0      while ( my $line = <$fh> ) {
784   ***      0                                  0         chomp $line;
785   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
786   ***      0                                  0         $line =~ s/\s+#.*$//g;
787   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
788   ***      0      0                           0         if ( $line eq '--' ) {
789   ***      0                                  0            $prefix = '';
790   ***      0                                  0            $parse  = 0;
791   ***      0                                  0            next LINE;
792                                                         }
793   ***      0      0      0                    0         if ( $parse
      ***             0                               
794                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
795                                                         ) {
796   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
797                                                         }
798                                                         elsif ( $line =~ m/./ ) {
799   ***      0                                  0            push @args, $line;
800                                                         }
801                                                         else {
802   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
803                                                         }
804                                                      }
805   ***      0                                  0      close $fh;
806   ***      0                                  0      return @args;
807                                                   }
808                                                   
809                                                   sub read_para_after {
810   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
811   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
812   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
813   ***      0                                  0      my $para;
814   ***      0                                  0      while ( $para = <$fh> ) {
815   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
816   ***      0                                  0         last;
817                                                      }
818   ***      0                                  0      while ( $para = <$fh> ) {
819   ***      0      0                           0         next unless $para =~ m/$regex/;
820   ***      0                                  0         last;
821                                                      }
822   ***      0                                  0      $para = <$fh>;
823   ***      0                                  0      chomp($para);
824   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
825   ***      0                                  0      return $para;
826                                                   }
827                                                   
828                                                   sub clone {
829   ***      0                    0             0      my ( $self ) = @_;
830                                                   
831   ***      0                                  0      my %clone = map {
832   ***      0                                  0         my $hashref  = $self->{$_};
833   ***      0                                  0         my $val_copy = {};
834   ***      0                                  0         foreach my $key ( keys %$hashref ) {
835   ***      0                                  0            my $ref = ref $hashref->{$key};
836   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
837   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
838   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
839                                                                              : $hashref->{$key};
840                                                         }
841   ***      0                                  0         $_ => $val_copy;
842                                                      } qw(opts short_opts defaults);
843                                                   
844   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
845   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
846                                                      }
847                                                   
848   ***      0                                  0      return bless \%clone;     
849                                                   }
850                                                   
851                                                   sub _d {
852   ***      0                    0             0      my ($package, undef, $line) = caller 0;
853   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
854   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
855                                                           @_;
856   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
857                                                   }
858                                                   
859                                                   1;
860                                                   
861                                                   # ###########################################################################
862                                                   # End OptionParser package
863                                                   # ###########################################################################
864                                                   
865                                                   # ###########################################################################
866                                                   # VersionParser package 5266
867                                                   # ###########################################################################
868                                                   package VersionParser;
869                                                   
870            4                    4            38   use strict;
               4                                  9   
               4                                 30   
871            4                    4            25   use warnings FATAL => 'all';
               4                                  9   
               4                                 43   
872                                                   
873            4                    4            24   use English qw(-no_match_vars);
               4                                  9   
               4                                 23   
874                                                   
875   ***      4            50      4            25   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                  9   
               4                                 70   
876                                                   
877                                                   sub new {
878           10                   10            44      my ( $class ) = @_;
879           10                                 50      bless {}, $class;
880                                                   }
881                                                   
882                                                   sub parse {
883   ***      0                    0             0      my ( $self, $str ) = @_;
884   ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
885   ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
886   ***      0                                  0      return $result;
887                                                   }
888                                                   
889                                                   sub version_ge {
890   ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
891   ***      0      0                           0      if ( !$self->{$dbh} ) {
892   ***      0                                  0         $self->{$dbh} = $self->parse(
893                                                            $dbh->selectrow_array('SELECT VERSION()'));
894                                                      }
895   ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
896   ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
897   ***      0                                  0      return $result;
898                                                   }
899                                                   
900                                                   sub _d {
901   ***      0                    0             0      my ($package, undef, $line) = caller 0;
902   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
903   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
904                                                           @_;
905   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
906                                                   }
907                                                   
908                                                   1;
909                                                   
910                                                   # ###########################################################################
911                                                   # End VersionParser package
912                                                   # ###########################################################################
913                                                   
914                                                   # ###########################################################################
915                                                   # DSNParser package 5266
916                                                   # ###########################################################################
917                                                   package DSNParser;
918                                                   
919            4                    4            28   use strict;
               4                                 14   
               4                                 20   
920            4                    4            25   use warnings FATAL => 'all';
               4                                  9   
               4                                 19   
921            4                    4            23   use English qw(-no_match_vars);
               4                                  9   
               4                                 20   
922            4                    4            26   use Data::Dumper;
               4                                 11   
               4                                 35   
923                                                   $Data::Dumper::Indent    = 0;
924                                                   $Data::Dumper::Quotekeys = 0;
925                                                   
926                                                   eval {
927                                                      require DBI;
928                                                   };
929                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
930                                                   
931   ***      4            50      4            28   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                  9   
               4                                 52   
932                                                   
933                                                   sub new {
934           13                   13            65      my ( $class, @opts ) = @_;
935           13                                351      my $self = {
936                                                         opts => {
937                                                            A => {
938                                                               desc => 'Default character set',
939                                                               dsn  => 'charset',
940                                                               copy => 1,
941                                                            },
942                                                            D => {
943                                                               desc => 'Database to use',
944                                                               dsn  => 'database',
945                                                               copy => 1,
946                                                            },
947                                                            F => {
948                                                               desc => 'Only read default options from the given file',
949                                                               dsn  => 'mysql_read_default_file',
950                                                               copy => 1,
951                                                            },
952                                                            h => {
953                                                               desc => 'Connect to host',
954                                                               dsn  => 'host',
955                                                               copy => 1,
956                                                            },
957                                                            p => {
958                                                               desc => 'Password to use when connecting',
959                                                               dsn  => 'password',
960                                                               copy => 1,
961                                                            },
962                                                            P => {
963                                                               desc => 'Port number to use for connection',
964                                                               dsn  => 'port',
965                                                               copy => 1,
966                                                            },
967                                                            S => {
968                                                               desc => 'Socket file to use for connection',
969                                                               dsn  => 'mysql_socket',
970                                                               copy => 1,
971                                                            },
972                                                            u => {
973                                                               desc => 'User for login if not current user',
974                                                               dsn  => 'user',
975                                                               copy => 1,
976                                                            },
977                                                         },
978                                                      };
979           13                                 63      foreach my $opt ( @opts ) {
980   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
981   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
982                                                      }
983           13                                 92      return bless $self, $class;
984                                                   }
985                                                   
986                                                   sub prop {
987            9                    9            44      my ( $self, $prop, $value ) = @_;
988   ***      9     50                          46      if ( @_ > 2 ) {
989   ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
990   ***      0                                  0         $self->{$prop} = $value;
991                                                      }
992            9                                 70      return $self->{$prop};
993                                                   }
994                                                   
995                                                   sub parse {
996            3                    3           121      my ( $self, $dsn, $prev, $defaults ) = @_;
997   ***      3     50                          14      if ( !$dsn ) {
998   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
999   ***      0                                  0         return;
1000                                                     }
1001           3                                  8      MKDEBUG && _d('Parsing', $dsn);
1002  ***      3            50                   14      $prev     ||= {};
1003  ***      3            50                   14      $defaults ||= {};
1004           3                                  9      my %given_props;
1005           3                                  7      my %final_props;
1006           3                                 11      my %opts = %{$self->{opts}};
               3                                 24   
1007                                                  
1008           3                                 27      foreach my $dsn_part ( split(/,/, $dsn) ) {
1009  ***     12     50                         115         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1010          12                                 54            $given_props{$prop_key} = $prop_val;
1011                                                        }
1012                                                        else {
1013  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1014  ***      0                                  0            $given_props{h} = $dsn_part;
1015                                                        }
1016                                                     }
1017                                                  
1018           3                                 19      foreach my $key ( keys %opts ) {
1019          24                                 50         MKDEBUG && _d('Finding value for', $key);
1020          24                                 99         $final_props{$key} = $given_props{$key};
1021  ***     24     50     66                  186         if (   !defined $final_props{$key}
      ***                   33                        
1022                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1023                                                        {
1024  ***      0                                  0            $final_props{$key} = $prev->{$key};
1025  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1026                                                        }
1027          24    100                          99         if ( !defined $final_props{$key} ) {
1028          12                                 41            $final_props{$key} = $defaults->{$key};
1029          12                                 31            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1030                                                        }
1031                                                     }
1032                                                  
1033           3                                 16      foreach my $key ( keys %given_props ) {
1034  ***     12     50                          52         die "Unrecognized DSN part '$key' in '$dsn'\n"
1035                                                           unless exists $opts{$key};
1036                                                     }
1037  ***      3     50                          36      if ( (my $required = $self->prop('required')) ) {
1038  ***      0                                  0         foreach my $key ( keys %$required ) {
1039  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1040                                                        }
1041                                                     }
1042                                                  
1043           3                                 21      return \%final_props;
1044                                                  }
1045                                                  
1046                                                  sub parse_options {
1047  ***      0                    0             0      my ( $self, $o ) = @_;
1048  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1049  ***      0                                  0      my $dsn_string
1050                                                        = join(',',
1051  ***      0      0                           0             map  { "$_=".$o->get($_); }
1052  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1053  ***      0                                  0             keys %{$self->{opts}}
1054                                                          );
1055  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1056  ***      0                                  0      return $self->parse($dsn_string);
1057                                                  }
1058                                                  
1059                                                  sub as_string {
1060  ***      0                    0             0      my ( $self, $dsn ) = @_;
1061  ***      0      0                           0      return $dsn unless ref $dsn;
1062  ***      0      0                           0      return join(',',
1063  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1064  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1065                                                        sort keys %$dsn );
1066                                                  }
1067                                                  
1068                                                  sub usage {
1069  ***      0                    0             0      my ( $self ) = @_;
1070  ***      0                                  0      my $usage
1071                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1072                                                        . "  KEY  COPY  MEANING\n"
1073                                                        . "  ===  ====  =============================================\n";
1074  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1075  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1076  ***      0      0      0                    0         $usage .= "  $key    "
1077                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1078                                                               .  ($opts{$key}->{desc} || '[No description]')
1079                                                               . "\n";
1080                                                     }
1081  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1082  ***      0                                  0      return $usage;
1083                                                  }
1084                                                  
1085                                                  sub get_cxn_params {
1086           3                    3            35      my ( $self, $info ) = @_;
1087           3                                  8      my $dsn;
1088           3                                  8      my %opts = %{$self->{opts}};
               3                                 25   
1089  ***      3            50                   18      my $driver = $self->prop('dbidriver') || '';
1090  ***      3     50                          14      if ( $driver eq 'Pg' ) {
1091  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1092  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1093  ***      0             0                    0                        grep { defined $info->{$_} }
1094                                                                       qw(h P));
1095                                                     }
1096                                                     else {
1097           6                                 45         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1098          15                                 54            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1099  ***      3            50                   37                        grep { defined $info->{$_} }
1100                                                                       qw(F h P S A))
1101                                                           . ';mysql_read_default_group=client';
1102                                                     }
1103           3                                  9      MKDEBUG && _d($dsn);
1104           3                                 25      return ($dsn, $info->{u}, $info->{p});
1105                                                  }
1106                                                  
1107                                                  sub fill_in_dsn {
1108  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1109  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1110  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1111  ***      0                                  0      $user =~ s/@.*//;
1112  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1113  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1114  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1115  ***      0             0                    0      $dsn->{u} ||= $user;
1116  ***      0             0                    0      $dsn->{D} ||= $db;
1117                                                  }
1118                                                  
1119                                                  sub get_dbh {
1120           3                    3            17      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1121  ***      3            50                   15      $opts ||= {};
1122  ***      3     50                          30      my $defaults = {
1123                                                        AutoCommit         => 0,
1124                                                        RaiseError         => 1,
1125                                                        PrintError         => 0,
1126                                                        ShowErrorStatement => 1,
1127                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1128                                                     };
1129           3                                 16      @{$defaults}{ keys %$opts } = values %$opts;
               3                                 12   
1130                                                  
1131  ***      3     50                          14      if ( !$have_dbi ) {
1132  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1133                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1134                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1135                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1136                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1137                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1138                                                  
1139                                                     }
1140                                                  
1141           3                                  8      my $dbh;
1142           3                                  9      my $tries = 2;
1143  ***      3            66                   31      while ( !$dbh && $tries-- ) {
1144                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1145           3                                  6            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1146                                                  
1147           3                                  9         eval {
1148           3                                 19            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1149                                                  
1150  ***      3     50                          36            if ( $cxn_string =~ m/mysql/i ) {
1151           3                                  9               my $sql;
1152                                                  
1153           3                                 12               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1154                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1155           3                                  7               MKDEBUG && _d($dbh, ':', $sql);
1156           3                                396               $dbh->do($sql);
1157                                                  
1158  ***      3     50                          29               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1159  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1160  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1161  ***      0                                  0                  $dbh->do($sql);
1162  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1163  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1164  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1165                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1166                                                                 }
1167                                                                 else {
1168  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1169                                                                 }
1170                                                              }
1171                                                  
1172  ***      3     50                          18               if ( $self->prop('set-vars') ) {
1173  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1174  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1175  ***      0                                  0                  $dbh->do($sql);
1176                                                              }
1177                                                           }
1178                                                        };
1179  ***      3     50     33                   34         if ( !$dbh && $EVAL_ERROR ) {
1180  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1181  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1182  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1183  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1184                                                           }
1185                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1186  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1187                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1188                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1189                                                                 . "DBD::mysql is not installed, try:\n"
1190                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1191                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1192                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1193                                                           }
1194  ***      0      0                           0            if ( !$tries ) {
1195  ***      0                                  0               die $EVAL_ERROR;
1196                                                           }
1197                                                        }
1198                                                     }
1199                                                  
1200           3                                  9      MKDEBUG && _d('DBH info: ',
1201                                                        $dbh,
1202                                                        Dumper($dbh->selectrow_hashref(
1203                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1204                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1205                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1206                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1207                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1208                                                        '$DBI::VERSION:',        $DBI::VERSION,
1209                                                     );
1210                                                  
1211           3                                 21      return $dbh;
1212                                                  }
1213                                                  
1214                                                  sub get_hostname {
1215  ***      0                    0             0      my ( $self, $dbh ) = @_;
1216  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1217  ***      0                                  0         return $host;
1218                                                     }
1219  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1220                                                        'SELECT /*!50038 @@hostname, */ 1');
1221  ***      0                                  0      return $hostname;
1222                                                  }
1223                                                  
1224                                                  sub disconnect {
1225  ***      0                    0             0      my ( $self, $dbh ) = @_;
1226  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1227  ***      0                                  0      $dbh->disconnect;
1228                                                  }
1229                                                  
1230                                                  sub print_active_handles {
1231  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1232  ***      0             0                    0      $level ||= 0;
1233  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1234                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1235                                                        or die "Cannot print: $OS_ERROR";
1236  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1237  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1238                                                     }
1239                                                  }
1240                                                  
1241                                                  sub copy {
1242  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1243  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1244  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1245  ***      0                                  0      my %new_dsn = map {
1246  ***      0                                  0         my $key = $_;
1247  ***      0                                  0         my $val;
1248  ***      0      0                           0         if ( $args{overwrite} ) {
1249  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1250                                                        }
1251                                                        else {
1252  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1253                                                        }
1254  ***      0                                  0         $key => $val;
1255  ***      0                                  0      } keys %{$self->{opts}};
1256  ***      0                                  0      return \%new_dsn;
1257                                                  }
1258                                                  
1259                                                  sub _d {
1260  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1261  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1262  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1263                                                          @_;
1264  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1265                                                  }
1266                                                  
1267                                                  1;
1268                                                  
1269                                                  # ###########################################################################
1270                                                  # End DSNParser package
1271                                                  # ###########################################################################
1272                                                  
1273                                                  # ###########################################################################
1274                                                  # Daemon package 5266
1275                                                  # ###########################################################################
1276                                                  
1277                                                  package Daemon;
1278                                                  
1279           4                    4            36   use strict;
               4                                 10   
               4                                 22   
1280           4                    4            24   use warnings FATAL => 'all';
               4                                  9   
               4                                 21   
1281                                                  
1282           4                    4            24   use POSIX qw(setsid);
               4                                 10   
               4                                486   
1283           4                    4            27   use English qw(-no_match_vars);
               4                                 10   
               4                                 21   
1284                                                  
1285  ***      4            50      4            24   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 10   
               4                                 57   
1286                                                  
1287                                                  sub new {
1288  ***      0                    0             0      my ( $class, %args ) = @_;
1289  ***      0                                  0      foreach my $arg ( qw(o) ) {
1290  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1291                                                     }
1292  ***      0                                  0      my $o = $args{o};
1293  ***      0      0                           0      my $self = {
      ***             0                               
1294                                                        o        => $o,
1295                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1296                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1297                                                     };
1298                                                  
1299  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1300                                                  
1301  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1302  ***      0                                  0      return bless $self, $class;
1303                                                  }
1304                                                  
1305                                                  sub daemonize {
1306  ***      0                    0             0      my ( $self ) = @_;
1307                                                  
1308  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1309  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1310  ***      0      0                           0      if ( $pid ) {
1311  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1312  ***      0                                  0         exit;
1313                                                     }
1314                                                  
1315  ***      0                                  0      $self->{child} = 1;
1316                                                  
1317  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1318  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1319                                                  
1320  ***      0                                  0      $self->_make_PID_file();
1321                                                  
1322  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
1323                                                  
1324  ***      0      0                           0      if ( -t STDIN ) {
1325  ***      0                                  0         close STDIN;
1326  ***      0      0                           0         open  STDIN, '/dev/null'
1327                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1328                                                     }
1329                                                  
1330  ***      0      0                           0      if ( $self->{log_file} ) {
1331  ***      0                                  0         close STDOUT;
1332  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1333                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1334                                                  
1335  ***      0                                  0         close STDERR;
1336  ***      0      0                           0         open  STDERR, ">&STDOUT"
1337                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1338                                                     }
1339                                                     else {
1340  ***      0      0                           0         if ( -t STDOUT ) {
1341  ***      0                                  0            close STDOUT;
1342  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
1343                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1344                                                        }
1345  ***      0      0                           0         if ( -t STDERR ) {
1346  ***      0                                  0            close STDERR;
1347  ***      0      0                           0            open  STDERR, '>', '/dev/null'
1348                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1349                                                        }
1350                                                     }
1351                                                  
1352  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1353  ***      0                                  0      return;
1354                                                  }
1355                                                  
1356                                                  sub check_PID_file {
1357  ***      0                    0             0      my ( $self, $file ) = @_;
1358  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1359  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1360  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1361  ***      0                                  0         my $pid;
1362  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1363  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1364  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1365  ***      0      0                           0         if ( $pid ) {
1366  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1367  ***      0      0                           0            if ( $pid_is_alive ) {
1368  ***      0                                  0               die "The PID file $PID_file already exists "
1369                                                                 . " and the PID that it contains, $pid, is running";
1370                                                           }
1371                                                           else {
1372  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1373                                                                 . "contains, $pid, is not running";
1374                                                           }
1375                                                        }
1376                                                        else {
1377  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1378                                                              . "contain a PID";
1379                                                        }
1380                                                     }
1381                                                     else {
1382  ***      0                                  0         MKDEBUG && _d('No PID file');
1383                                                     }
1384  ***      0                                  0      return;
1385                                                  }
1386                                                  
1387                                                  sub make_PID_file {
1388  ***      0                    0             0      my ( $self ) = @_;
1389  ***      0      0                           0      if ( exists $self->{child} ) {
1390  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1391                                                     }
1392  ***      0                                  0      $self->_make_PID_file();
1393  ***      0                                  0      $self->{rm_PID_file} = 1;
1394  ***      0                                  0      return;
1395                                                  }
1396                                                  
1397                                                  sub _make_PID_file {
1398  ***      0                    0             0      my ( $self ) = @_;
1399                                                  
1400  ***      0                                  0      my $PID_file = $self->{PID_file};
1401  ***      0      0                           0      if ( !$PID_file ) {
1402  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1403  ***      0                                  0         return;
1404                                                     }
1405                                                  
1406  ***      0                                  0      $self->check_PID_file();
1407                                                  
1408  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1409                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1410  ***      0      0                           0      print $PID_FH $PID
1411                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1412  ***      0      0                           0      close $PID_FH
1413                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1414                                                  
1415  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1416  ***      0                                  0      return;
1417                                                  }
1418                                                  
1419                                                  sub _remove_PID_file {
1420  ***      0                    0             0      my ( $self ) = @_;
1421  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1422  ***      0      0                           0         unlink $self->{PID_file}
1423                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1424  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1425                                                     }
1426                                                     else {
1427  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1428                                                     }
1429  ***      0                                  0      return;
1430                                                  }
1431                                                  
1432                                                  sub DESTROY {
1433  ***      0                    0             0      my ( $self ) = @_;
1434  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1435  ***      0                                  0      return;
1436                                                  }
1437                                                  
1438                                                  sub _d {
1439  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1440  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1441  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1442                                                          @_;
1443  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1444                                                  }
1445                                                  
1446                                                  1;
1447                                                  
1448                                                  # ###########################################################################
1449                                                  # End Daemon package
1450                                                  # ###########################################################################
1451                                                  
1452                                                  # ###########################################################################
1453                                                  # Transformers package 5266
1454                                                  # ###########################################################################
1455                                                  
1456                                                  package Transformers;
1457                                                  
1458           4                    4            27   use strict;
               4                                 11   
               4                                 21   
1459           4                    4            24   use warnings FATAL => 'all';
               4                                  9   
               4                                 21   
1460           4                    4            24   use English qw(-no_match_vars);
               4                                  9   
               4                                 18   
1461           4                    4            52   use Time::Local qw(timegm timelocal);
               4                                 13   
               4                                 39   
1462           4                    4            25   use Digest::MD5 qw(md5_hex);
               4                                  8   
               4                                 28   
1463                                                  
1464  ***      4            50      4            24   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 10   
               4                                 47   
1465                                                  
1466                                                  require Exporter;
1467                                                  our @ISA         = qw(Exporter);
1468                                                  our %EXPORT_TAGS = ();
1469                                                  our @EXPORT      = ();
1470                                                  our @EXPORT_OK   = qw(
1471                                                     micro_t
1472                                                     percentage_of
1473                                                     secs_to_time
1474                                                     shorten
1475                                                     ts
1476                                                     parse_timestamp
1477                                                     unix_timestamp
1478                                                     any_unix_timestamp
1479                                                     make_checksum
1480                                                  );
1481                                                  
1482                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1483                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
1484                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1485                                                  
1486                                                  sub micro_t {
1487  ***      0                    0             0      my ( $t, %args ) = @_;
1488  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1489  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1490  ***      0                                  0      my $f;
1491                                                  
1492  ***      0      0                           0      $t = 0 if $t < 0;
1493                                                  
1494  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1495                                                  
1496  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1497                                                  
1498  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1499  ***      0                                  0         $f = ($t * 1000000) . 'us';
1500                                                     }
1501                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1502  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1503  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1504                                                     }
1505                                                     elsif ($t >= 1) {
1506  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1507  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1508                                                     }
1509                                                     else {
1510  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1511                                                     }
1512                                                  
1513  ***      0                                  0      return $f;
1514                                                  }
1515                                                  
1516                                                  sub percentage_of {
1517  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1518  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1519  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1520  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1521                                                  }
1522                                                  
1523                                                  sub secs_to_time {
1524  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1525  ***      0             0                    0      $secs ||= 0;
1526  ***      0      0                           0      return '00:00' unless $secs;
1527                                                  
1528  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1529                                                            : $secs >= 3_600  ? 'h'
1530                                                            :                   'm';
1531                                                  
1532                                                     return
1533  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1534                                                           "%d+%02d:%02d:%02d",
1535                                                           int($secs / 86_400),
1536                                                           int(($secs % 86_400) / 3_600),
1537                                                           int(($secs % 3_600) / 60),
1538                                                           $secs % 60)
1539                                                        : $fmt eq 'h' ? sprintf(
1540                                                           "%02d:%02d:%02d",
1541                                                           int(($secs % 86_400) / 3_600),
1542                                                           int(($secs % 3_600) / 60),
1543                                                           $secs % 60)
1544                                                        : sprintf(
1545                                                           "%02d:%02d",
1546                                                           int(($secs % 3_600) / 60),
1547                                                           $secs % 60);
1548                                                  }
1549                                                  
1550                                                  sub shorten {
1551  ***      0                    0             0      my ( $num, %args ) = @_;
1552  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1553  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1554  ***      0                                  0      my $n = 0;
1555  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1556  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1557  ***      0                                  0         $num /= $d;
1558  ***      0                                  0         ++$n;
1559                                                     }
1560  ***      0      0      0                    0      return sprintf(
1561                                                        $num =~ m/\./ || $n
1562                                                           ? "%.${p}f%s"
1563                                                           : '%d',
1564                                                        $num, $units[$n]);
1565                                                  }
1566                                                  
1567                                                  sub ts {
1568           9                    9            36      my ( $time, $gmt ) = @_;
1569  ***      9     50                         162      my ( $sec, $min, $hour, $mday, $mon, $year )
1570                                                        = $gmt ? gmtime($time) : localtime($time);
1571           9                                 33      $mon  += 1;
1572           9                                 24      $year += 1900;
1573           9                                 72      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1574                                                        $year, $mon, $mday, $hour, $min, $sec);
1575  ***      9     50                          52      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
1576  ***      0                                  0         $us = sprintf("%.6f", $us);
1577  ***      0                                  0         $us =~ s/^0\././;
1578  ***      0                                  0         $val .= $us;
1579                                                     }
1580           9                                159      return $val;
1581                                                  }
1582                                                  
1583                                                  sub parse_timestamp {
1584  ***      0                    0             0      my ( $val ) = @_;
1585  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
1586                                                           = $val =~ m/^$mysql_ts$/ )
1587                                                     {
1588  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1589                                                                       . (defined $f ? '%02.6f' : '%02d'),
1590                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1591                                                     }
1592  ***      0                                  0      return $val;
1593                                                  }
1594                                                  
1595                                                  sub unix_timestamp {
1596  ***      0                    0             0      my ( $val, $gmt ) = @_;
1597  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
1598  ***      0      0                           0         $val = $gmt
1599                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
1600                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
1601  ***      0      0                           0         if ( defined $us ) {
1602  ***      0                                  0            $us = sprintf('%.6f', $us);
1603  ***      0                                  0            $us =~ s/^0\././;
1604  ***      0                                  0            $val .= $us;
1605                                                        }
1606                                                     }
1607  ***      0                                  0      return $val;
1608                                                  }
1609                                                  
1610                                                  sub any_unix_timestamp {
1611  ***      0                    0             0      my ( $val, $callback ) = @_;
1612                                                  
1613  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
1614  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1615                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1616                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1617                                                           : $suffix eq 'd' ? $n * 86400    # Days
1618                                                           :                  $n;           # default: Seconds
1619  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
1620  ***      0                                  0         return time - $n;
1621                                                     }
1622                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
1623  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
1624  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1625  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
1626                                                     }
1627                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
1628  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
1629  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1630  ***      0                                  0         return unix_timestamp($val);
1631                                                     }
1632                                                     else {
1633  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
1634  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
1635                                                     }
1636                                                  
1637  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
1638  ***      0                                  0      return;
1639                                                  }
1640                                                  
1641                                                  sub make_checksum {
1642  ***      0                    0             0      my ( $val ) = @_;
1643  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1644  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1645  ***      0                                  0      return $checksum;
1646                                                  }
1647                                                  
1648                                                  sub _d {
1649  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1650  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1651  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1652                                                          @_;
1653  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1654                                                  }
1655                                                  
1656                                                  1;
1657                                                  
1658                                                  # ###########################################################################
1659                                                  # End Transformers package
1660                                                  # ###########################################################################
1661                                                  
1662                                                  # ###########################################################################
1663                                                  # Processlist package 5266
1664                                                  # ###########################################################################
1665                                                  package Processlist;
1666                                                  
1667           4                    4            36   use strict;
               4                                  9   
               4                                 24   
1668           4                    4            29   use warnings FATAL => 'all';
               4                                  8   
               4                                 27   
1669           4                    4            23   use English qw(-no_match_vars);
               4                                 10   
               4                                 24   
1670                                                  
1671           4                    4            25   use Data::Dumper;
               4                                 10   
               4                                 26   
1672                                                  $Data::Dumper::Indent    = 1;
1673                                                  $Data::Dumper::Sortkeys  = 1;
1674                                                  $Data::Dumper::Quotekeys = 0;
1675                                                  
1676  ***      4            50      4            24   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 10   
               4                                 63   
1677                                                  use constant {
1678           4                                 51      ID      => 0,
1679                                                     USER    => 1,
1680                                                     HOST    => 2,
1681                                                     DB      => 3,
1682                                                     COMMAND => 4,
1683                                                     TIME    => 5,
1684                                                     STATE   => 6,
1685                                                     INFO    => 7,
1686                                                     START   => 8, # Calculated start time of statement
1687                                                     ETIME   => 9, # Exec time of SHOW PROCESSLIST (margin of error in START)
1688                                                     FSEEN   => 10, # First time ever seen
1689           4                    4            24   };
               4                                  9   
1690                                                  
1691                                                  sub new {
1692          10                   10            52      my ( $class, %args ) = @_;
1693          10                                 69      my $self = {
1694                                                        prev_rows => [],
1695                                                        new_rows  => [],
1696                                                        curr_row  => undef,
1697                                                        prev_row  => undef,
1698                                                     };
1699          10                                 61      return bless $self, $class;
1700                                                  }
1701                                                  
1702                                                  sub parse_event {
1703  ***      0                    0             0      my ( $self, %args ) = @_;
1704  ***      0                                  0      my @required_args = qw(misc);
1705  ***      0                                  0      foreach my $arg ( @required_args ) {
1706  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1707                                                     }
1708  ***      0                                  0      my ($misc) = @args{@required_args};
1709                                                  
1710  ***      0                                  0      my $code = $misc->{code};
1711  ***      0      0                           0      die "I need a code arg to misc" unless $code;
1712                                                  
1713  ***      0                                  0      my @curr;
1714  ***      0      0                           0      if ( $self->{curr_rows} ) {
1715  ***      0                                  0         MKDEBUG && _d('Current rows from last call');
1716  ***      0                                  0         @curr = @{$self->{curr_rows}};
      ***      0                                  0   
1717                                                     }
1718                                                     else {
1719  ***      0                                  0         my $rows = $code->();
1720  ***      0      0      0                    0         if ( $rows && scalar @$rows ) {
1721  ***      0                                  0            MKDEBUG && _d('Got new current rows');
1722  ***      0                                  0            @curr = sort { $a->[ID] <=> $b->[ID] } @$rows;
      ***      0                                  0   
1723                                                        }
1724                                                        else {
1725  ***      0                                  0            MKDEBUG && _d('No current rows');
1726                                                        }
1727                                                     }
1728                                                  
1729  ***      0             0                    0      my @prev = @{$self->{prev_rows} ||= []};
      ***      0                                  0   
1730  ***      0             0                    0      my @new  = @{$self->{new_rows}  ||= []};; # Becomes next invocation's @prev
      ***      0                                  0   
1731  ***      0                                  0      my $curr = $self->{curr_row}; # Rows from each source
1732  ***      0                                  0      my $prev = $self->{prev_row};
1733  ***      0                                  0      my $event;
1734                                                  
1735  ***      0                                  0      MKDEBUG && _d('Rows:', scalar @prev, 'prev,', scalar @curr, 'current');
1736                                                  
1737  ***      0      0      0                    0      if ( !$curr && @curr ) {
1738  ***      0                                  0         MKDEBUG && _d('Fetching row from curr');
1739  ***      0                                  0         $curr = shift @curr;
1740                                                     }
1741  ***      0      0      0                    0      if ( !$prev && @prev ) {
1742  ***      0                                  0         MKDEBUG && _d('Fetching row from prev');
1743  ***      0                                  0         $prev = shift @prev;
1744                                                     }
1745  ***      0      0      0                    0      if ( $curr || $prev ) {
1746  ***      0      0      0                    0         if ( $curr && $prev && $curr->[ID] == $prev->[ID] ) {
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
1747  ***      0                                  0            MKDEBUG && _d('$curr and $prev are the same cxn');
1748  ***      0      0                           0            my $fudge = $curr->[TIME] =~ m/\D/ ? 0.001 : 1; # Micro-precision?
1749  ***      0                                  0            my $is_new = 0;
1750  ***      0      0                           0            if ( $prev->[INFO] ) {
1751  ***      0      0      0                    0               if (!$curr->[INFO] || $prev->[INFO] ne $curr->[INFO]) {
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
1752  ***      0                                  0                  MKDEBUG && _d('$curr has a new query');
1753  ***      0                                  0                  $is_new = 1;
1754                                                              }
1755                                                              elsif (defined $curr->[TIME] && $curr->[TIME] < $prev->[TIME]) {
1756  ***      0                                  0                  MKDEBUG && _d('$curr time is less than $prev time');
1757  ***      0                                  0                  $is_new = 1;
1758                                                              }
1759                                                              elsif ( $curr->[INFO] && defined $curr->[TIME]
1760                                                                      && $misc->{time} - $curr->[TIME] - $prev->[START]
1761                                                                         - $prev->[ETIME] - $misc->{etime} > $fudge
1762                                                              ) {
1763  ***      0                                  0                  MKDEBUG && _d('$curr has same query that restarted');
1764  ***      0                                  0                  $is_new = 1;
1765                                                              }
1766  ***      0      0                           0               if ( $is_new ) {
1767  ***      0                                  0                  $event = $self->make_event($prev, $misc->{time});
1768                                                              }
1769                                                           }
1770  ***      0      0                           0            if ( $curr->[INFO] ) {
1771  ***      0      0      0                    0               if ( $prev->[INFO] && !$is_new ) {
1772  ***      0                                  0                  MKDEBUG && _d('Pushing old history item back onto $prev');
1773  ***      0                                  0                  push @new, [ @$prev ];
1774                                                              }
1775                                                              else {
1776  ***      0                                  0                  MKDEBUG && _d('Pushing new history item onto $prev');
1777  ***      0                                  0                  push @new,
1778                                                                    [ @$curr, int($misc->{time} - $curr->[TIME]),
1779                                                                       $misc->{etime}, $misc->{time} ];
1780                                                              }
1781                                                           }
1782  ***      0                                  0            $curr = $prev = undef; # Fetch another from each.
1783                                                        }
1784                                                        elsif ( !$curr
1785                                                                || ($curr && $prev && $curr->[ID] > $prev->[ID]) ) {
1786  ***      0                                  0            MKDEBUG && _d('$curr is not in $prev');
1787  ***      0                                  0            $event = $self->make_event($prev, $misc->{time});
1788  ***      0                                  0            $prev = undef;
1789                                                        }
1790                                                        else { # This else must be entered, to prevent infinite loops.
1791  ***      0                                  0            MKDEBUG && _d('$prev is not in $curr');
1792  ***      0      0      0                    0            if ( $curr->[INFO] && defined $curr->[TIME] ) {
1793  ***      0                                  0               MKDEBUG && _d('Pushing new history item onto $prev');
1794  ***      0                                  0               push @new,
1795                                                                 [ @$curr, int($misc->{time} - $curr->[TIME]),
1796                                                                    $misc->{etime}, $misc->{time} ];
1797                                                           }
1798  ***      0                                  0            $curr = undef; # No infinite loops.
1799                                                        }
1800                                                     }
1801                                                  
1802  ***      0                                  0      $self->{prev_rows} = \@new;
1803  ***      0                                  0      $self->{prev_row}  = $prev;
1804  ***      0      0                           0      $self->{curr_rows} = scalar @curr ? \@curr : undef;
1805  ***      0                                  0      $self->{curr_row}  = $curr;
1806                                                  
1807  ***      0                                  0      return $event;
1808                                                  }
1809                                                  
1810                                                  sub make_event {
1811  ***      0                    0             0      my ( $self, $row, $time ) = @_;
1812  ***      0                                  0      my $Query_time = $row->[TIME];
1813  ***      0      0                           0      if ( $row->[TIME] < $time - $row->[FSEEN] ) {
1814  ***      0                                  0         $Query_time = $time - $row->[FSEEN];
1815                                                     }
1816  ***      0                                  0      my $event = {
1817                                                        id         => $row->[ID],
1818                                                        db         => $row->[DB],
1819                                                        user       => $row->[USER],
1820                                                        host       => $row->[HOST],
1821                                                        arg        => $row->[INFO],
1822                                                        bytes      => length($row->[INFO]),
1823                                                        ts         => Transformers::ts($row->[START] + $row->[TIME]), # Query END time
1824                                                        Query_time => $Query_time,
1825                                                        Lock_time  => 0,               # TODO
1826                                                     };
1827  ***      0                                  0      MKDEBUG && _d('Properties of event:', Dumper($event));
1828  ***      0                                  0      return $event;
1829                                                  }
1830                                                  
1831                                                  sub _get_rows {
1832  ***      0                    0             0      my ( $self ) = @_;
1833  ***      0                                  0      my %rows = map { $_ => $self->{$_} }
      ***      0                                  0   
1834                                                        qw(prev_rows new_rows curr_row prev_row);
1835  ***      0                                  0      return \%rows;
1836                                                  }
1837                                                  
1838                                                  sub find {
1839          10                   10            77      my ( $self, $proclist, %find_spec ) = @_;
1840          10                                 30      MKDEBUG && _d('find specs:', Dumper(\%find_spec));
1841          10                                 27      my @matches;
1842                                                     QUERY:
1843          10                                 38      foreach my $query ( @$proclist ) {
1844         449                                941         MKDEBUG && _d('Checking query', Dumper($query));
1845         449                               1142         my $matched = 0;
1846                                                  
1847  ***    449    100     50                 2585         if ( $find_spec{busy_time} && ($query->{Command} || '') eq 'Query' ) {
      ***                   66                        
1848         104    100                         466            if ( $query->{Time} < $find_spec{busy_time} ) {
1849          91                                191               MKDEBUG && _d("Query isn't running long enough");
1850          91                                249               next QUERY;
1851                                                           }
1852          13                                 28            MKDEBUG && _d('Exceeds busy time');
1853          13                                 34            $matched++;
1854                                                        }
1855                                                  
1856  ***    358    100     50                 1673         if ( $find_spec{idle_time} && ($query->{Command} || '') eq 'Sleep' ) {
      ***                   66                        
1857  ***      1     50                           6            if ( $query->{Time} < $find_spec{idle_time} ) {
1858  ***      0                                  0               MKDEBUG && _d("Query isn't idle long enough");
1859  ***      0                                  0               next QUERY;
1860                                                           }
1861           1                                  3            MKDEBUG && _d('Exceeds idle time');
1862           1                                  3            $matched++;
1863                                                        }
1864                                                  
1865                                                        PROPERTY:
1866         358                               1263         foreach my $property ( qw(Id User Host db State Command Info) ) {
1867        1544                               4478            my $filter = "_find_match_$property";
1868        1544    100    100                 9502            if ( defined $find_spec{ignore}->{$property}
1869                                                                && $self->$filter($query, $find_spec{ignore}->{$property}) ) {
1870         114                                244               MKDEBUG && _d('Query matches ignore', $property, 'spec');
1871         114                                362               next QUERY;
1872                                                           }
1873        1430    100                        6653            if ( defined $find_spec{match}->{$property} ) {
1874         231    100                        1118               if ( !$self->$filter($query, $find_spec{match}->{$property}) ) {
1875         199                                431                  MKDEBUG && _d('Query does not match', $property, 'spec');
1876         199                                642                  next QUERY;
1877                                                              }
1878          32                                 80               MKDEBUG && _d('Query matches', $property, 'spec');
1879          32                                102               $matched++;
1880                                                           }
1881                                                        }
1882  ***     45     50                         174         if ( $matched ) {
1883          45                                 96            MKDEBUG && _d("Query matched one or more specs, adding");
1884          45                                130            push @matches, $query;
1885          45                                137            next QUERY;
1886                                                        }
1887  ***      0                                  0         MKDEBUG && _d('Query does not match any specs, ignoring');
1888                                                     } # QUERY
1889                                                  
1890          10    100    100                   91      if ( @matches && $find_spec{only_oldest} ) {
1891           7                                 30         my ( $oldest ) = reverse sort { $a->{Time} <=> $b->{Time} } @matches;
              66                                243   
1892           7                                 26         MKDEBUG && _d('Oldest query:', Dumper($oldest));
1893           7                                 28         @matches = $oldest;
1894                                                     }
1895                                                  
1896          10                                 52      return @matches;
1897                                                  }
1898                                                  
1899                                                  sub _find_match_Id {
1900  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1901  ***      0             0                    0      return defined $property && defined $query->{Id} && $query->{Id} == $property;
      ***                    0                        
1902                                                  }
1903                                                  
1904                                                  sub _find_match_User {
1905         358                  358          1428      my ( $self, $query, $property ) = @_;
1906  ***    358            33                 5529      return defined $property && defined $query->{User}
      ***                   66                        
1907                                                        && $query->{User} =~ m/$property/;
1908                                                  }
1909                                                  
1910                                                  sub _find_match_Host {
1911  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1912  ***      0             0                    0      return defined $property && defined $query->{Host}
      ***                    0                        
1913                                                        && $query->{Host} =~ m/$property/;
1914                                                  }
1915                                                  
1916                                                  sub _find_match_db {
1917  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1918  ***      0             0                    0      return defined $property && defined $query->{db}
      ***                    0                        
1919                                                        && $query->{db} =~ m/$property/;
1920                                                  }
1921                                                  
1922                                                  sub _find_match_State {
1923         473                  473          1895      my ( $self, $query, $property ) = @_;
1924  ***    473            66                 8685      return defined $property && defined $query->{State}
                           100                        
1925                                                        && $query->{State} =~ m/$property/;
1926                                                  }
1927                                                  
1928                                                  sub _find_match_Command {
1929          48                   48           193      my ( $self, $query, $property ) = @_;
1930  ***     48            33                  763      return defined $property && defined $query->{Command}
      ***                   66                        
1931                                                        && $query->{Command} =~ m/$property/;
1932                                                  }
1933                                                  
1934                                                  sub _find_match_Info {
1935           1                    1             5      my ( $self, $query, $property ) = @_;
1936  ***      1            33                   27      return defined $property && defined $query->{Info}
      ***                   33                        
1937                                                        && $query->{Info} =~ m/$property/;
1938                                                  }
1939                                                  
1940                                                  sub _d {
1941  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1942  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1943  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1944                                                          @_;
1945  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1946                                                  }
1947                                                  
1948                                                  1;
1949                                                  
1950                                                  # ###########################################################################
1951                                                  # End Processlist package
1952                                                  # ###########################################################################
1953                                                  
1954                                                  # ###########################################################################
1955                                                  # TextResultSetParser package 5266
1956                                                  # ###########################################################################
1957                                                  package TextResultSetParser;
1958                                                  
1959                                                  
1960           4                    4            29   use strict;
               4                                 11   
               4                                 24   
1961           4                    4            29   use warnings FATAL => 'all';
               4                                 10   
               4                                 21   
1962           4                    4            22   use English qw(-no_match_vars);
               4                                 12   
               4                                 25   
1963                                                  
1964           4                    4            40   use Data::Dumper;
               4                                  9   
               4                                 27   
1965                                                  $Data::Dumper::Indent    = 1;
1966                                                  $Data::Dumper::Sortkeys  = 1;
1967                                                  $Data::Dumper::Quotekeys = 0;
1968                                                  
1969  ***      4            50      4            30   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 15   
               4                                 56   
1970                                                  
1971                                                  sub new {
1972          10                   10            50      my ( $class, %args ) = @_;
1973          10                                 39      my $self = { %args };
1974          10                                 60      return bless $self, $class;
1975                                                  }
1976                                                  
1977                                                  sub _parse_tabular {
1978           2                    2            11      my ( $text, @cols ) = @_;
1979           2                                  6      my %row;
1980           2                                 36      my @vals = $text =~ m/\| +([^\|]*?)(?= +\|)/msg;
1981           2    100                          14      return (undef, \@vals) unless @cols;
1982           1                                  8      @row{@cols} = @vals;
1983           1                                  5      return (\%row, undef);
1984                                                  }
1985                                                  
1986                                                  sub _parse_tab_sep {
1987  ***      0                    0             0      my ( $text, @cols ) = @_;
1988  ***      0                                  0      my %row;
1989  ***      0                                  0      my @vals = split(/\t/, $text);
1990  ***      0      0                           0      return (undef, \@vals) unless @cols;
1991  ***      0                                  0      @row{@cols} = @vals;
1992  ***      0                                  0      return (\%row, undef);
1993                                                  }
1994                                                  
1995                                                  sub parse_vertical_row {
1996         448                  448          1596      my ( $text ) = @_;
1997         448                               9974      my %row = $text =~ m/^\s*(\w+):(?: ([^\n]*))?/msg;
1998         448                               1796      MKDEBUG && _d('vertical row:', Dumper(\%row));
1999         448                               1850      return \%row;
2000                                                  }
2001                                                  
2002                                                  sub parse {
2003          10                   10           391      my ( $self, $text ) = @_;
2004          10                                 41      my $result_set;
2005                                                  
2006          10    100                         399      if ( $text =~ m/^\+---/m ) { # standard "tabular" output
      ***            50                               
      ***            50                               
2007           1                                  3         MKDEBUG && _d('Result set text is standard tabular');
2008           1                                  8         my $line_pattern  = qr/^(\| .*)[\r\n]+/m;
2009           1                                  7         $result_set
2010                                                           = parse_horizontal_row($text, $line_pattern, \&_parse_tabular);
2011                                                     }
2012                                                     elsif ( $text =~ m/^id\tselect_type\t/m ) { # tab-separated
2013  ***      0                                  0         MKDEBUG && _d('Result set text is tab-separated');
2014  ***      0                                  0         my $line_pattern  = qr/^(.*?\t.*)[\r\n]+/m;
2015  ***      0                                  0         $result_set
2016                                                           = parse_horizontal_row($text, $line_pattern, \&_parse_tab_sep);
2017                                                     }
2018                                                     elsif ( $text =~ m/\*\*\* \d+\. row/ ) { # "vertical" output
2019           9                                 25         MKDEBUG && _d('Result set text is vertical (\G)');
2020           9                                 44         foreach my $row ( split_vertical_rows($text) ) {
2021         448                               1592            push @$result_set, parse_vertical_row($row);
2022                                                        }
2023                                                     }
2024                                                     else {
2025  ***      0                                  0         die "Cannot determine if text is tabular, tab-separated or veritcal:\n"
2026                                                           . $text;
2027                                                     }
2028                                                  
2029  ***     10     50                          87      if ( $self->{value_for} ) {
2030  ***      0                                  0         foreach my $result_set ( @$result_set ) {
2031  ***      0                                  0            foreach my $key ( keys %$result_set ) {
2032  ***      0      0                           0               $result_set->{$key} = $self->{value_for}->{ $result_set->{$key} }
2033                                                                 if exists $self->{value_for}->{ $result_set->{$key} };
2034                                                           }
2035                                                        }
2036                                                     }
2037                                                  
2038          10                                 60      return $result_set;
2039                                                  }
2040                                                  
2041                                                  sub parse_horizontal_row {
2042           1                    1             5      my ( $text, $line_pattern, $sub ) = @_;
2043           1                                  4      my @result_sets = ();
2044           1                                  3      my @cols        = ();
2045           1                                 12      foreach my $line ( $text =~ m/$line_pattern/g ) {
2046           2                                  8         my ( $row, $cols ) = $sub->($line, @cols);
2047           2    100                           8         if ( $row ) {
2048           1                                  5            push @result_sets, $row;
2049                                                        }
2050                                                        else {
2051           1                                  9            @cols = @$cols;
2052                                                        }
2053                                                     }
2054           1                                 14      return \@result_sets;
2055                                                  }
2056                                                  
2057                                                  sub split_vertical_rows {
2058           9                    9           176      my ( $text ) = @_;
2059           9                                 33      my $ROW_HEADER = '\*{3,} \d+\. row \*{3,}';
2060           9                              24025      my @rows = $text =~ m/($ROW_HEADER.*?)(?=$ROW_HEADER|\z)/omgs;
2061           9                                239      return @rows;
2062                                                  }
2063                                                  
2064                                                  sub _d {
2065  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2066  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2067  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2068                                                          @_;
2069  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2070                                                  }
2071                                                  
2072                                                  1;
2073                                                  
2074                                                  # ###########################################################################
2075                                                  # End TextResultSetParser package
2076                                                  # ###########################################################################
2077                                                  
2078                                                  # ###########################################################################
2079                                                  # This is a combination of modules and programs in one -- a runnable module.
2080                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2081                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2082                                                  #
2083                                                  # Check at the end of this package for the call to main() which actually runs
2084                                                  # the program.
2085                                                  # ###########################################################################
2086                                                  package mk_kill;
2087                                                  
2088           4                    4            32   use English qw(-no_match_vars);
               4                                  8   
               4                                 21   
2089           4                    4            25   use POSIX qw(setsid);
               4                                 19   
               4                                 27   
2090           4                    4            26   use List::Util qw(max);
               4                                  9   
               4                                 22   
2091                                                  
2092                                                  Transformers->import qw(ts);
2093                                                  
2094  ***      4            50      4            26   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                  9   
               4                                 52   
2095                                                  
2096                                                  $OUTPUT_AUTOFLUSH = 1;
2097                                                  
2098                                                  my $o;
2099                                                  my $dp;
2100                                                  
2101                                                  # ########################################################################
2102                                                  # Configuration info.
2103                                                  # ########################################################################
2104                                                  
2105                                                  sub main {
2106          10                   10           580      @ARGV = @_;  # set global ARGV for this package
2107                                                  
2108          10                                 92      my $pl = new Processlist();
2109          10                                 95      my $vp = new VersionParser();
2110          10                                 78      $dp    = new DSNParser();
2111                                                  
2112                                                     # ########################################################################
2113                                                     # Get configuration information.
2114                                                     # ########################################################################
2115          10                                175      $o = new OptionParser(
2116                                                        description => q{kills, prints or executes another script for queries }
2117                                                                     . q{in MySQL that match certain criteria.  }
2118                                                                     . q{If FILE is not given, mk-kill executes SHOW PROCESSLIST }
2119                                                                     . q{on MySQL to get queries.  Else, mk-kill will get }
2120                                                                     . q{queries from FILE which should contain the output of }
2121                                                                     . q{SHOW PROCESSLIST.  If FILE is -, mk-kill reads from }
2122                                                                     . q{STDIN.},
2123                                                        prompt      => '[OPTION]... [FILE...]',
2124                                                        strict      => 0,
2125                                                     );
2126          10                               1058      $o->get_specs();
2127          10                                 51      $o->get_opts();
2128                                                  
2129          10    100                          58      if ( !$o->got('busy-time') ) {
2130  ***      7     50                          26         $o->set('interval', 30) unless $o->got('interval');
2131                                                     }
2132                                                     else {
2133  ***      3     50                          14         $o->set('interval', max(1, $o->get('busy-time') / 2))
2134                                                           unless $o->got('interval');
2135                                                     }
2136                                                  
2137                                                     # If parsing files, then don't wait.
2138  ***     10     50                          45      if ( @ARGV ) {
2139          10                                 38         $o->set('interval', 0);
2140                                                     }
2141                                                  
2142          10                                 49      $o->usage_or_errors();
2143                                                  
2144                                                     # ########################################################################
2145                                                     # Connect to MySQL if not reading files.
2146                                                     # ########################################################################
2147          10                                 27      my $dsn;
2148          10                                 25      my $dbh;
2149          10                                 25      my $kill_sth;
2150  ***     10     50                          43      if ( !@ARGV ) {
2151  ***      0                                  0         $dsn      = $dp->parse_options($o);
2152  ***      0                                  0         $dbh      = get_cxn($dsn, 1); 
2153  ***      0                                  0         $kill_sth = $dbh->prepare('KILL ?');
2154                                                     }
2155                                                  
2156                                                     # ########################################################################
2157                                                     # Make input sub that will either get processlist from MySQL or a file.
2158                                                     # ########################################################################
2159          10                                 30      my $get_proclist;
2160  ***     10     50                          35      if ( @ARGV ) {
2161          10                                 23         MKDEBUG && _d('Getting processlist from files:', @ARGV);
2162          10                                 99         my $trp = new TextResultSetParser();
2163          10                                 26         my $fh;
2164                                                        $get_proclist = sub {
2165  ***     10     50            10            42            if ( !$fh ) {
2166          10                                 36               my $file = shift @ARGV;
2167  ***     10     50                          37               die 'No more files' unless $file;
2168  ***     10     50                          38               if ( $file eq '-' ) {
2169  ***      0                                  0                  $fh = *STDIN;
2170                                                              }
2171                                                              else {
2172  ***     10     50                         416                  if ( !open $fh, '<', $file ) {
2173  ***      0                                  0                     warn "Cannot open $file: $OS_ERROR";
2174  ***      0                                  0                     $fh = undef;
2175  ***      0                                  0                     return;
2176                                                                 }
2177                                                              }
2178                                                           }
2179                                                  
2180  ***     10     50                          42            if ( $fh ) {
2181          10                                 70               local $INPUT_RECORD_SEPARATOR = '';
2182          10                              23869               my $proclist_text = <$fh>;
2183  ***     10     50                          40               if ( $proclist_text ) {
2184          10                                 65                  return $trp->parse($proclist_text);
2185                                                              }
2186                                                              else {
2187                                                                 # No more proclists in this file.
2188  ***      0                                  0                  $fh = undef;
2189                                                              }
2190                                                           }
2191                                                  
2192  ***      0                                  0            return;
2193          10                                 97         };
2194                                                     }
2195                                                     else {
2196  ***      0                                  0         MKDEBUG && _d('Getting processlist from MySQL');
2197  ***      0                                  0         my $proc_sth = $dbh->prepare('SHOW FULL PROCESSLIST');
2198                                                        $get_proclist = sub {
2199  ***      0                    0             0            $proc_sth->execute();
2200  ***      0                                  0            return $proc_sth->fetchall_arrayref({});
2201  ***      0                                  0         };
2202                                                     }
2203                                                  
2204                                                     # ########################################################################
2205                                                     # Daemonize only after (potentially) asking for passwords for --ask-pass.
2206                                                     # ########################################################################
2207          10                                 27      my $daemon;
2208  ***     10     50                          50      if ( $o->get('daemonize') ) {
      ***            50                               
2209  ***      0                                  0         $daemon = new Daemon(o=>$o);
2210  ***      0                                  0         $daemon->daemonize();
2211  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
2212                                                     }
2213                                                     elsif ( $o->get('pid') ) {
2214                                                        # We're not daemoninzing, it just handles PID stuff.
2215  ***      0                                  0         $daemon = new Daemon(o=>$o);
2216  ***      0                                  0         $daemon->make_PID_file();
2217                                                     }
2218                                                  
2219                                                     # ########################################################################
2220                                                     # Start working.
2221                                                     # ########################################################################
2222          10                                 44      my $start    = time();
2223  ***     10            50                   40      my $end      = $start + ($o->get('run-time') || 0); # When we should exit
2224          10                                 28      my $now      = $start;
2225                                                  
2226  ***     10     50                          41      my %find_spec = (
2227                                                        only_oldest => $o->get('only-oldest'),
2228                                                        busy_time   => $o->get('busy-time'),
2229                                                        idle_time   => $o->get('idle-time'),
2230                                                        ignore => {
2231                                                           Command  => $o->get('ignore-command'),
2232                                                           db       => $o->get('ignore-db'),
2233                                                           Host     => $o->get('ignore-host'),
2234                                                           Id       => $o->get('ignore-self') ? $dbh->{mysql_thread_id} : undef,
2235                                                           Info     => $o->get('ignore-info'),
2236                                                           State    => $o->get('ignore-state'),
2237                                                           User     => $o->get('ignore-user'),
2238                                                        },
2239                                                        match => {
2240                                                           Command  => $o->get('match-command'),
2241                                                           db       => $o->get('match-db'),
2242                                                           Host     => $o->get('match-host'),
2243                                                           Info     => $o->get('match-info'),
2244                                                           State    => $o->get('match-state'),
2245                                                           User     => $o->get('match-user'),
2246                                                        },
2247                                                     );
2248                                                  
2249          10                                 46      my $iters_done = 0;
2250          10                                 40      my $iters_todo = $o->get('iterations');
2251  ***     10            33                  144      while (                                              # Quit if:
      ***                   66                        
      ***                   66                        
2252                                                        ($start == $end || $now < $end)                   # time is exceeded
2253                                                        && (!$iters_todo || $iters_done++ < $iters_todo ) # or iterations exceeded
2254                                                     ) {
2255          10                                 54         heartbeat('Checking processlist, iteration '.$iters_done);
2256          10                                 36         my $proclist;
2257          10                                 29         eval { $proclist = $get_proclist->(); };
              10                                 36   
2258  ***     10     50                          41         if ( $EVAL_ERROR ) {
2259  ***      0      0                           0            last if $EVAL_ERROR =~ m/No more files/;
2260  ***      0                                  0            die "Error getting SHOW PROCESSLIST: $EVAL_ERROR";
2261                                                        }
2262                                                  
2263          10                                 27         my @queries;
2264  ***     10     50                          35         if ( $proclist ) {
2265          10                                 83            @queries = $pl->find($proclist, %find_spec);
2266          10                                 58            heartbeat('Matched ' . scalar @queries . ' queries');
2267                                                           MATCHING_QUERY:
2268          10                                 41            foreach my $query ( @queries ) {
2269  ***      9     50                          35               if ( $o->get('print') ) {
2270  ***      9            50                   53                  printf "# %s KILL %d (%s %d sec) %s\n",
      ***                   50                        
2271                                                                    ts(time), $query->{Id}, ($query->{Command} || 'NULL'),
2272                                                                    $query->{Time}, ($query->{Info} || 'NULL');
2273                                                              }
2274  ***      9     50                          37               if ( $o->get('execute-command') ) {
2275  ***      0                                  0                  exec_cmd($o->get('execute-command'));
2276  ***      0                                  0                  heartbeat('Executed ' . $o->get('execute-command'));
2277                                                              }
2278  ***      9     50                          35               if ( $o->get('kill') ) {
2279  ***      0      0                           0                  sleep $o->get('wait-before-kill') if $o->get('wait-before-kill');
2280  ***      0                                  0                  $kill_sth->execute($query->{Id});
2281  ***      0                                  0                  heartbeat("Killed $query->{Id}");
2282                                                  
2283                                                              }
2284                                                           }
2285                                                        }
2286                                                        else {
2287  ***      0                                  0            MKDEBUG && _d('No proclist returned');
2288  ***      0                                  0            heartbeat('Processlist returned no queries');
2289                                                        }
2290                                                  
2291                                                        # Don't sleep if we're going to exit after waking up.  If $iters_todo is
2292                                                        # 0 (infinity), always sleep.  And only sleep if we're live (i.e. not
2293                                                        # reading from files).
2294  ***     10     50     33                   93         if ( (!$iters_todo || $iters_done < $iters_todo)
      ***                   33                        
2295                                                              && $dbh ) {
2296  ***      0      0      0                    0            if ( @queries && $o->get('wait-after-kill') ) {
2297  ***      0                                  0               MKDEBUG && _d("Sleeping after killing queries");
2298  ***      0                                  0               sleep $o->get('wait-after-kill');
2299                                                           }
2300                                                           else {
2301  ***      0                                  0               MKDEBUG && _d("Sleeping normal interval");
2302  ***      0                                  0               sleep $o->get('interval');
2303                                                           }
2304                                                        }
2305          10                                528         $now = time();
2306                                                     }
2307                                                  
2308          10                                 37      heartbeat('Done checking processlist');
2309          10                                 35      return 0;
2310                                                  }
2311                                                  
2312                                                  
2313                                                  # ############################################################################
2314                                                  # Subroutines.
2315                                                  # ############################################################################
2316                                                  
2317                                                  sub get_cxn {
2318  ***      0                    0             0      my ( $dsn, $ac ) = @_;
2319  ***      0      0                           0      if ( $o->get('ask-pass') ) {
2320  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password: "); 
2321                                                     }
2322  ***      0                                  0      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => $ac});
2323  ***      0                                  0      $dbh->{InactiveDestroy} = 1; # Because of forking.
2324  ***      0                                  0      return $dbh;
2325                                                  }
2326                                                  
2327                                                  # Forks and detaches from parent to execute the given command;
2328                                                  # does not block parent.
2329                                                  sub exec_cmd {
2330  ***      0                    0             0      my ( $cmd ) = @_;
2331  ***      0                                  0      MKDEBUG && _d('exec cmd:', $cmd);
2332  ***      0      0                           0      return unless $cmd;
2333                                                  
2334  ***      0                                  0      my $pid = fork();
2335  ***      0      0                           0      if ( $pid ) {
2336                                                        # parent
2337  ***      0                                  0         MKDEBUG && _d('child pid:', $pid);
2338  ***      0                                  0         return $pid;
2339                                                     }
2340                                                  
2341                                                     # child
2342  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2343  ***      0                                  0      my $retval = system($cmd);
2344  ***      0                                  0      $retval = $retval >> 8;
2345  ***      0                                  0      MKDEBUG && _d('child exit status:', $retval);
2346  ***      0                                  0      exit $retval;
2347                                                  }
2348                                                  
2349                                                  sub heartbeat {
2350          30                   30           115      my ( $msg ) = @_;
2351  ***     30     50                         121      print '# ', ts(time), " $msg\n" if $o->get('heartbeat');
2352          30                                 69      MKDEBUG && _d($msg);
2353          30                                 72      return;
2354                                                  }
2355                                                  
2356                                                  sub _d {
2357  ***      0                    0                    my ($package, undef, $line) = caller 0;
2358  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2359  ***      0                                              map { defined $_ ? $_ : 'undef' }
2360                                                          @_;
2361  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2362                                                  }
2363                                                  
2364                                                  # ############################################################################
2365                                                  # Run the program.
2366                                                  # ############################################################################
2367                                                  if ( !caller ) { exit main(@ARGV); }
2368                                                  
2369                                                  1; # Because this is a module as well as a script.
2370                                                  
2371                                                  # ############################################################################
2372                                                  # Documentation
2373                                                  # ############################################################################
2374                                                  =pod
2375                                                  
2376                                                  =head1 NAME
2377                                                  
2378                                                  mk-kill - Kill MySQL queries that match certain criteria.
2379                                                  
2380                                                  =head1 SYNOPSIS
2381                                                  
2382                                                  Kill queries running longer than 60s:
2383                                                  
2384                                                    mk-kill --busy-time 60 --kill
2385                                                  
2386                                                  Print, do not kill, queries running longer than 60s:
2387                                                  
2388                                                    mk-kill --busy-time 60 --print
2389                                                  
2390                                                  Check for sleeping processes and kill them all every 10s:
2391                                                  
2392                                                    mk-kill --match-command Sleep --kill --no-only-oldest --interval 10
2393                                                  
2394                                                  Print all login processes:
2395                                                  
2396                                                    mk-kill --match-state login --print --no-only-oldest
2397                                                  
2398                                                  =head1 RISKS
2399                                                  
2400                                                  The following section is included to inform users about the potential risks,
2401                                                  whether known or unknown, of using this tool.  The two main categories of risks
2402                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2403                                                  tools) and those created by bugs.
2404                                                  
2405                                                  mk-kill is designed to kill queries if you use the L<"--kill"> option is given,
2406                                                  and that might disrupt your database's users, of course.  You should test with
2407                                                  the <"--print"> option, which is safe, if you're unsure what the tool will do.
2408                                                  
2409                                                  At the time of this release, we know of no bugs that could cause serious harm to
2410                                                  users.
2411                                                  
2412                                                  The authoritative source for updated information is always the online issue
2413                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2414                                                  see a list of such issues at the following URL:
2415                                                  L<http://www.maatkit.org/bugs/mk-kill>.
2416                                                  
2417                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2418                                                  
2419                                                  =head1 DESCRIPTION
2420                                                  
2421                                                  mk-kill captures queries from SHOW PROCESSLIST, filters them, and then either
2422                                                  kills or prints them.  This is also known as a "slow query sniper" in some
2423                                                  circles.  The idea is to watch for queries that might be consuming too many
2424                                                  resources, and kill them.
2425                                                  
2426                                                  For brevity, we talk about killing queries, but they may just be printed
2427                                                  (or some other future action) depending on what options are given.
2428                                                  
2429                                                  Normally mk-kill connects to MySQL to get queries from SHOW PROCESSLIST.
2430                                                  Alternatively, it can read SHOW PROCESSLIST output from files.  In this case,
2431                                                  mk-kill does not connect to MySQL and L<"--kill"> has no effect.  You should
2432                                                  use L<"--print"> instead when reading files.  The ability to read a file (or
2433                                                  - for STDIN) allows you to capture SHOW PROCESSLIST and test it later with
2434                                                  mk-kill to make sure that your matches kill the proper queries.  There are a
2435                                                  lot of special rules to follow, such as "don't kill replication threads,"
2436                                                  so be careful to not kill something important!
2437                                                  
2438                                                  Two important options to know are L<"--busy-time"> and L<"--[no]only-oldest">.
2439                                                  First, whereas most match/filter options match their corresponding value from
2440                                                  SHOW PROCESSLIST (e.g. L<"--match-command"> matches a query's Command value),
2441                                                  the Time value is matched by L<"--busy-time">.  See also L<"--interval">.
2442                                                  
2443                                                  Secondly, L<"--[no]only-oldest"> affects which matching query is killed.
2444                                                  By default, the matching query with the highest Time value is killed.  So
2445                                                  if you want to match and kill ALL queries for a certain criteria regardless
2446                                                  of which is the "oldest", you must specify C<--no-only-oldest>.
2447                                                  
2448                                                  mk-kill is a work in progress, and there is much more it could do.
2449                                                  
2450                                                  =head1 OUTPUT
2451                                                  
2452                                                  If only L<"--kill"> then there is no output.  If only L<"--print"> then a
2453                                                  timestamped KILL statement if printed for every query that would have
2454                                                  been killed, like:
2455                                                  
2456                                                    # 2009-07-15T15:04:01 KILL 8 (Query 42 sec) SELECT * FROM huge_table
2457                                                  
2458                                                  The line shows a timestamp, the query's Id (8), its Time (42 sec) and its
2459                                                  Info (usually the query SQL).
2460                                                  
2461                                                  If both L<"--kill"> and L<"--print"> are given, then matching queries are
2462                                                  killed and a line for each like the one above is printed.
2463                                                  
2464                                                  Any command executed by L<"--execute-command"> is responsible for its own
2465                                                  output and logging.  After being executed, mk-kill has no control or interaction
2466                                                  with the command.
2467                                                  
2468                                                  =head1 OPTIONS
2469                                                  
2470                                                  Specify at least one of L<"--kill">, L<"--print"> or L<"--execute-command">.
2471                                                  
2472                                                  =over
2473                                                  
2474                                                  =item --ask-pass
2475                                                  
2476                                                  Prompt for a password when connecting to MySQL.
2477                                                  
2478                                                  =item --charset
2479                                                  
2480                                                  short form: -A; type: string
2481                                                  
2482                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2483                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
2484                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
2485                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
2486                                                  
2487                                                  =item --config
2488                                                  
2489                                                  type: Array
2490                                                  
2491                                                  Read this comma-separated list of config files; if specified, this must be the
2492                                                  first option on the command line.
2493                                                  
2494                                                  =item --daemonize
2495                                                  
2496                                                  Fork to the background and detach from the shell.  POSIX operating systems
2497                                                  only.
2498                                                  
2499                                                  =item --defaults-file
2500                                                  
2501                                                  short form: -F; type: string
2502                                                  
2503                                                  Only read mysql options from the given file.  You must give an absolute
2504                                                  pathname.
2505                                                  
2506                                                  =item --heartbeat
2507                                                  
2508                                                  Print information to STDOUT about what is being done.
2509                                                  
2510                                                  =item --help
2511                                                  
2512                                                  Show help and exit.
2513                                                  
2514                                                  =item --host
2515                                                  
2516                                                  short form: -h; type: string
2517                                                  
2518                                                  Connect to host.
2519                                                  
2520                                                  =item --interval
2521                                                  
2522                                                  type: time
2523                                                  
2524                                                  How often to check for queries to kill.  If L<"--busy-time"> is not given,
2525                                                  then the default interval is 30 seconds.  Else the default is half as often
2526                                                  as L<"--busy-time">.  If both L<"--interval"> and L<"--busy-time"> are given,
2527                                                  then the explicit L<"--interval"> value is used.
2528                                                  
2529                                                  =item --iterations
2530                                                  
2531                                                  type: int; default: 1
2532                                                  
2533                                                  How many times to iterate through the find-and-kill cycle.  If 0, iterate
2534                                                  to infinity.  See also L<"--run-time">.
2535                                                  
2536                                                  =item --log
2537                                                  
2538                                                  type: string
2539                                                  
2540                                                  Print all output to this file when daemonized.
2541                                                  
2542                                                  =item --password
2543                                                  
2544                                                  short form: -p; type: string
2545                                                  
2546                                                  Password to use when connecting.
2547                                                  
2548                                                  =item --pid
2549                                                  
2550                                                  type: string
2551                                                  
2552                                                  Create the given PID file when daemonized.  The file contains the process ID of
2553                                                  the daemonized instance.  The PID file is removed when the daemonized instance
2554                                                  exits.  The program checks for the existence of the PID file when starting; if
2555                                                  it exists and the process with the matching PID exists, the program exits.
2556                                                  
2557                                                  =item --port
2558                                                  
2559                                                  short form: -P; type: int
2560                                                  
2561                                                  Port number to use for connection.
2562                                                  
2563                                                  =item --run-time
2564                                                  
2565                                                  type: time
2566                                                  
2567                                                  How long to run before exiting.
2568                                                  
2569                                                  =item --set-vars
2570                                                  
2571                                                  type: string; default: wait_timeout=10000
2572                                                  
2573                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2574                                                  will be appended to SET and executed.
2575                                                  
2576                                                  =item --socket
2577                                                  
2578                                                  short form: -S; type: string
2579                                                  
2580                                                  Socket file to use for connection.
2581                                                  
2582                                                  =item --user
2583                                                  
2584                                                  short form: -u; type: string
2585                                                  
2586                                                  User for login if not current user.
2587                                                  
2588                                                  =item --version
2589                                                  
2590                                                  Show version and exit.
2591                                                  
2592                                                  =item --wait-after-kill
2593                                                  
2594                                                  type: time
2595                                                  
2596                                                  Wait after killing a query, before looking for more to kill.  The purpose of
2597                                                  this is to give blocked queries a chance to execute, so we don't kill a query
2598                                                  that's blocking a bunch of others, and then kill the others immediately
2599                                                  afterwards.
2600                                                  
2601                                                  =item --wait-before-kill
2602                                                  
2603                                                  type: time
2604                                                  
2605                                                  Wait before killing a query.  The purpose of this is to give
2606                                                  L<"--execute-command"> a chance to see the matching query and gather other
2607                                                  MySQL or system information before it's killed.
2608                                                  
2609                                                  =back
2610                                                  
2611                                                  =head2 MATCHES
2612                                                  
2613                                                  These options specify what criteria a query must match for C<mk-kill>
2614                                                  to either L<"--kill">, L<"--print"> or L<"--execute-command"> for it.
2615                                                  The ignore commands take precedence.  The matches for command, db, host, etc.
2616                                                  correspond to the columns returned by SHOW PROCESSLIST: Command, db, Host, etc.
2617                                                  All pattern matches are case-senstive.
2618                                                  
2619                                                  =over
2620                                                  
2621                                                  =item --busy-time
2622                                                  
2623                                                  type: time; group: Matches
2624                                                  
2625                                                  Kill connections that have been running for longer than this time.  The queries
2626                                                  must be in Command=Query status.  This matches a query's Time value as
2627                                                  reported by SHOW PROCESSLIST.
2628                                                  
2629                                                  =item --idle-time
2630                                                  
2631                                                  type: time; group: Matches
2632                                                  
2633                                                  Kill connections that have been idle/sleeping for longer than this time.
2634                                                  The queries must be in Command=Sleep status.  This matches a query's Time
2635                                                  value as reported by SHOW PROCESSLIST.
2636                                                  
2637                                                  =item --ignore-command
2638                                                  
2639                                                  type: string; group: Matches; default: Binlog.Dump
2640                                                  
2641                                                  Ignore queries whose Command matches this Perl regex.  The default is to keep
2642                                                  the slave threads from being killed on the master.
2643                                                  
2644                                                  See L<"--match-command">.
2645                                                  
2646                                                  =item --ignore-db
2647                                                  
2648                                                  type: string; group: Matches
2649                                                  
2650                                                  Ignore queries whose db (database) matches this Perl regex.
2651                                                  
2652                                                  See L<"--match-db">.
2653                                                  
2654                                                  =item --ignore-host
2655                                                  
2656                                                  type: string; group: Matches
2657                                                  
2658                                                  Ignore queries whose Host matches this Perl regex.
2659                                                  
2660                                                  See L<"--match-host">.
2661                                                  
2662                                                  =item --ignore-info
2663                                                  
2664                                                  type: string; group: Matches
2665                                                  
2666                                                  Ignore queries whose Info (query) matches this Perl regex.
2667                                                  
2668                                                  See L<"--match-info">.
2669                                                  
2670                                                  =item --[no]ignore-self
2671                                                  
2672                                                  default: yes; group: Matches
2673                                                  
2674                                                  Don't kill mk-kill's own connection.
2675                                                  
2676                                                  =item --ignore-state
2677                                                  
2678                                                  type: string; group: Matches; default: Locked
2679                                                  
2680                                                  Ignore queries whose State matches this Perl regex.  The default is to keep
2681                                                  threads from being killed if they are locked waiting for another thread.
2682                                                  
2683                                                  See L<"--match-state">.
2684                                                  
2685                                                  =item --ignore-user
2686                                                  
2687                                                  type: string; group: Matches; default: system.user
2688                                                  
2689                                                  Ignore queries whose user matches this Perl regex.  The default is to keep the
2690                                                  replication threads from being killed on the slave.
2691                                                  
2692                                                  See L<"--match-user">.
2693                                                  
2694                                                  =item --match-command
2695                                                  
2696                                                  type: string; group: Matches
2697                                                  
2698                                                  Kill only queries whose Command matches this Perl regex.
2699                                                  
2700                                                  Common Command values are:
2701                                                  
2702                                                    Query
2703                                                    Sleep
2704                                                    Binlog Dump
2705                                                    Connect
2706                                                    Delayed insert
2707                                                    Execute
2708                                                    Fetch
2709                                                    Init DB
2710                                                    Kill
2711                                                    Prepare
2712                                                    Processlist
2713                                                    Quit
2714                                                    Reset stmt
2715                                                    Table Dump
2716                                                  
2717                                                  See L<http://dev.mysql.com/doc/refman/5.1/en/thread-commands.html> for a full
2718                                                  list and description of Command values.
2719                                                  
2720                                                  =item --match-db
2721                                                  
2722                                                  type: string; group: Matches
2723                                                  
2724                                                  Kill only queries whose db (database) matches this Perl regex.
2725                                                  
2726                                                  =item --match-host
2727                                                  
2728                                                  type: string; group: Matches
2729                                                  
2730                                                  Kill only queries whose Host matches this Perl regex.
2731                                                  
2732                                                  The Host value often time includes the port like "host:port".
2733                                                  
2734                                                  =item --match-info
2735                                                  
2736                                                  type: string; group: Matches
2737                                                  
2738                                                  Kill only queries whose Info (query) matches this Perl regex.
2739                                                  
2740                                                  The Info column of the processlist shows the query that is being executed
2741                                                  or NULL if no query is being executed.
2742                                                  
2743                                                  =item --match-state
2744                                                  
2745                                                  type: string; group: Matches
2746                                                  
2747                                                  Kill only queries whose State matches this Perl regex.
2748                                                  
2749                                                  Common State values are:
2750                                                  
2751                                                    Locked
2752                                                    login
2753                                                    copy to tmp table
2754                                                    Copying to tmp table
2755                                                    Copying to tmp table on disk
2756                                                    Creating tmp table
2757                                                    executing
2758                                                    Reading from net
2759                                                    Sending data
2760                                                    Sorting for order
2761                                                    Sorting result
2762                                                    Table lock
2763                                                    Updating
2764                                                  
2765                                                  See L<http://dev.mysql.com/doc/refman/5.1/en/general-thread-states.html> for
2766                                                  a full list and description of State values.
2767                                                  
2768                                                  =item --match-user
2769                                                  
2770                                                  type: string; group: Matches
2771                                                  
2772                                                  Kill only queries whose User matches this Perl regex.
2773                                                  
2774                                                  =item --[no]only-oldest
2775                                                  
2776                                                  default: yes; group: Matches
2777                                                  
2778                                                  Only kill the single oldest query.  This is to prevent killing queries that
2779                                                  aren't really long-running, they're just long-waiting.  This sorts matching
2780                                                  queries by Time and kills the one with the highest Time value.
2781                                                  
2782                                                  =back
2783                                                  
2784                                                  =head2 ACTIONS
2785                                                  
2786                                                  When a query matches, one or more of these actions is taken.  The actions are
2787                                                  taken in this order: L<"--print">, L<"--execute-command">, L<"--kill">.
2788                                                  If given, mk-kill sleeps for L<"--wait-before-kill"> before L<"--kill"> (if
2789                                                  L<"--kill"> is given).  This order allows L<"--execute-command"> to see the 
2790                                                  output of L<"--print"> and the query before L<"--kill">.  This may be helpful
2791                                                  because mk-kill does not pass any information to L<"--execute-command">.
2792                                                  
2793                                                  =over
2794                                                  
2795                                                  =item --execute-command
2796                                                  
2797                                                  type: string; group: Actions
2798                                                  
2799                                                  Execute this command when a query matches.
2800                                                  
2801                                                  After the command is executed, mk-kill has no control over it, so the command
2802                                                  is responsible for its own info gathering, logging, interval, etc.  The
2803                                                  command is excuted each time a query matches, so be careful that the command
2804                                                  behaves well when multiple instances are ran.  No information from mk-kill is
2805                                                  passed to the command.
2806                                                  
2807                                                  See also L<"--wait-before-kill">.
2808                                                  
2809                                                  =item --kill
2810                                                  
2811                                                  group: Actions
2812                                                  
2813                                                  Actually kill matching queries.
2814                                                  
2815                                                  This option makes mk-kill kill matching queries in MySQL.  Unless L<"--print">
2816                                                  is also given, no other information is printed that shows that mk-kill
2817                                                  matched and killed a query.
2818                                                  
2819                                                  See also L<"--wait-before-kill"> and L<"--wait-after-kill">.
2820                                                  
2821                                                  =item --print
2822                                                  
2823                                                  group: Actions
2824                                                  
2825                                                  Print a KILL statement for matching queries; does not actually kill queries.
2826                                                  
2827                                                  If you just want to see which queries match and would be killed without
2828                                                  actually killing them, specify L<"--print">.  To both kill and print
2829                                                  matching queries, specify both L<"--kill"> and L<"--print">.
2830                                                  
2831                                                  =back
2832                                                  
2833                                                  =head1 DOWNLOADING
2834                                                  
2835                                                  You can download Maatkit from Google Code at
2836                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2837                                                  easily with a command like the following:
2838                                                  
2839                                                     wget http://www.maatkit.org/get/toolname
2840                                                     or
2841                                                     wget http://www.maatkit.org/trunk/toolname
2842                                                  
2843                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2844                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2845                                                  needed.  The first URL gets the latest released version of the tool, and the
2846                                                  second gets the latest trunk code from Subversion.
2847                                                  
2848                                                  =head1 ENVIRONMENT
2849                                                  
2850                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2851                                                  the Maatkit tools:
2852                                                  
2853                                                     MKDEBUG=1 mk-....
2854                                                  
2855                                                  =head1 SYSTEM REQUIREMENTS
2856                                                  
2857                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2858                                                  installed in any reasonably new version of Perl.
2859                                                  
2860                                                  =head1 BUGS
2861                                                  
2862                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-kill>.
2863                                                  
2864                                                  Please use Google Code Issues and Groups to report bugs or request support:
2865                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2866                                                  discuss Maatkit.
2867                                                  
2868                                                  Please include the complete command-line used to reproduce the problem you are
2869                                                  seeing, the version of all MySQL servers involved, the complete output of the
2870                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2871                                                  running with the C<MKDEBUG=1> environment variable.
2872                                                  
2873                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2874                                                  
2875                                                  This program is copyright 2009-@CURRENTYEAR@ Baron Schwartz.
2876                                                  Feedback and improvements are welcome.
2877                                                  
2878                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2879                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2880                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2881                                                  
2882                                                  This program is free software; you can redistribute it and/or modify it under
2883                                                  the terms of the GNU General Public License as published by the Free Software
2884                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2885                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2886                                                  licenses.
2887                                                  
2888                                                  You should have received a copy of the GNU General Public License along with
2889                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2890                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2891                                                  
2892                                                  =head1 AUTHOR
2893                                                  
2894                                                  Baron Schwartz
2895                                                  
2896                                                  =head1 ABOUT MAATKIT
2897                                                  
2898                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2899                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2900                                                  code contributors.  Both are employed by Percona.  Financial support for
2901                                                  Maatkit development is primarily provided by Percona and its clients. 
2902                                                  
2903                                                  =head1 VERSION
2904                                                  
2905                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5455 $.
2906                                                  
2907                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
57    ***     50      0     10   unless $args{$arg}
63    ***     50     10      0   exists $args{'strict'} ? :
106   ***     50      0     10   unless open my $fh, '<', $file
126          100   3230     10   unless $para =~ /^=head1 OPTIONS/
131          100     10     10   if $para =~ /^=over/
139   ***     50      0     10   unless $para
142          100    400     10   if (my($option) = $para =~ /^=item --(.*)/)
149          100    350     50   if ($para =~ /: /) { }
153   ***     50      0    640   unless $attributes{$attrib}
157          100     70    280   if ($attribs{'short form'})
173   ***     50      0    400   if $para =~ /^=item/
175          100     20    380   if (my($base_option) = $option =~ /^\[no\](.*)/)
180          100     70    330   $attribs{'short form'} ? :
             100     20    380   $attribs{'negatable'} ? :
      ***     50      0    400   $attribs{'cumulative'} ? :
             100    310     90   $attribs{'type'} ? :
             100     70    330   $attribs{'default'} ? :
             100    190    210   $attribs{'group'} ? :
192   ***     50      0    690   unless $para
195          100     10    680   if ($para =~ /^=head1/)
199          100    400    280   if $para =~ /^=item --/
203   ***     50      0     10   unless @specs
214          100    400     10   if (ref $opt) { }
219   ***     50      0    400   if (not $long)
224   ***     50      0    400   if exists $$self{'opts'}{$long}
227   ***     50      0    400   if (length $long == 1)
232          100     70    330   if ($short) { }
233   ***     50      0     70   if exists $$self{'short_opts'}{$short}
242          100     20    380   $$opt{'spec'} =~ /!/ ? :
243   ***     50      0    400   $$opt{'spec'} =~ /\+/ ? :
244   ***     50      0    400   $$opt{'desc'} =~ /required/ ? :
256   ***     50      0    400   if ($type and $type eq 'd' and not $$self{'dp'})
261          100     70    330   if $type and $type =~ /[HhAadzm]/
263          100     70    330   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
264   ***     50     70      0   defined $def ? :
268          100     10    390   if ($long eq 'config')
272   ***     50      0    400   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
285   ***     50      0     10   if ($opt =~ /mutually exclusive|one and only one/)
290   ***     50     10      0   if ($opt =~ /at least one|one and only one/)
295   ***     50      0     10   if ($opt =~ /default to/)
300   ***     50      0     10   if ($opt =~ /restricted to option groups/)
310   ***     50      0     10   unless $rule_ok
327   ***     50      0     30   unless exists $$self{'opts'}{$long}
351   ***      0      0      0   unless exists $$self{'opts'}{$long}
371   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     25      0   exists $$self{'opts'}{$opt} ? :
376   ***     50      0     25   if ($$opt{'is_cumulative'}) { }
391   ***     50      0    320   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     80    320   exists $$self{'defaults'}{$long} ? :
400   ***     50      0     10   if (@ARGV and $ARGV[0] eq '--config')
404   ***     50     10      0   if ($self->has('config'))
410   ***     50     40      0   if ($EVAL_ERROR)
411   ***     50      0     40   $self->got('config') ? :
426   ***     50      0     10   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
429   ***     50      0     10   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
430   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
436   ***     50      0     10   if (@ARGV and $$self{'strict'})
442   ***      0      0      0   if (@set > 1)
453   ***     50      0     10   if (@set == 0)
463          100     25    375   if ($$opt{'got'}) { }
      ***     50      0    375   elsif ($$opt{'is_required'}) { }
464   ***     50      0     25   if (exists $$self{'disables'}{$long})
471   ***     50      0     25   if (exists $$self{'allowed_groups'}{$long})
483   ***      0      0      0   if $restricted_opt eq $long
484   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
489   ***      0      0      0   if (@restricted_opts)
491   ***      0      0      0   if (@restricted_opts == 1) { }
520          100     90    310   unless $opt and $$opt{'type'}
523          100      4    306   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    306   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    306   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0    306   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     10    296   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
526   ***     50      4      0   if (not $suffix)
532   ***     50      4      0   if ($suffix =~ /[smhd]/) { }
533   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***     50      4      0   $suffix eq 's' ? :
548   ***      0      0      0   if ($from_key)
559   ***      0      0      0   if (defined $num) { }
560   ***      0      0      0   if ($factor)
587   ***     50      0    270   length $opt == 1 ? :
588   ***     50      0    270   unless $long and exists $$self{'opts'}{$long}
595   ***     50      0     60   length $opt == 1 ? :
596   ***     50      0     60   unless $long and exists $$self{'opts'}{$long}
603   ***     50      0     10   length $opt == 1 ? :
604   ***     50     10      0   defined $long ? :
609   ***     50      0     20   length $opt == 1 ? :
610   ***     50      0     20   unless $long and exists $$self{'opts'}{$long}
644   ***     50      0     10   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0     10   elsif (scalar @{$$self{'errors'};}) { }
645   ***      0      0      0   unless print $self->print_usage
649   ***      0      0      0   unless print $self->print_errors
658   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
667   ***      0      0      0   unless $$self{'got_opts'}
670   ***      0      0      0   $$_{'is_negatable'} ? :
674   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
690   ***      0      0      0   $group eq 'default' ? :
696   ***      0      0      0   $$opt{'is_negatable'} ? :
699   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
708   ***      0      0      0   if ($short) { }
717   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
721   ***      0      0      0   if ($$self{'dp'})
729   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
741   ***      0      0      0   if ref $_[0] eq 'OptionParser'
744   ***      0      0      0   unless print $prompt
752   ***      0      0      0   unless print "\n"
755   ***      0      0      0   if ($EVAL_ERROR)
777   ***     50     40      0   unless open my $fh, '<', $filename
785   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
788   ***      0      0      0   if ($line eq '--')
793   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
811   ***      0      0      0   unless open my $fh, '<', $file
815   ***      0      0      0   unless $para =~ /^=pod$/m
819   ***      0      0      0   unless $para =~ /$regex/
824   ***      0      0      0   unless close $fh
838   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
853   ***      0      0      0   defined $_ ? :
891   ***      0      0      0   if (not $$self{$dbh})
895   ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
902   ***      0      0      0   defined $_ ? :
988   ***     50      0      9   if (@_ > 2)
997   ***     50      0      3   if (not $dsn)
1009  ***     50     12      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1021  ***     50      0     24   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1027         100     12     12   if (not defined $final_props{$key})
1034  ***     50      0     12   unless exists $opts{$key}
1037  ***     50      0      3   if (my $required = $self->prop('required'))
1039  ***      0      0      0   unless $final_props{$key}
1048  ***      0      0      0   unless ref $o eq 'OptionParser'
1051  ***      0      0      0   if $o->has($_)
1061  ***      0      0      0   unless ref $dsn
1062  ***      0      0      0   $_ eq 'p' ? :
1063  ***      0      0      0   if defined $$dsn{$_}
1076  ***      0      0      0   $opts{$key}{'copy'} ? :
1090  ***     50      0      3   if ($driver eq 'Pg') { }
1122  ***     50      0      3   $cxn_string =~ /charset=utf8/ ? :
1131  ***     50      0      3   if (not $have_dbi)
1150  ***     50      3      0   if ($cxn_string =~ /mysql/i)
1158  ***     50      0      3   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1163  ***      0      0      0   if ($charset eq 'utf8') { }
1164  ***      0      0      0   unless binmode STDOUT, ':utf8'
1168  ***      0      0      0   unless binmode STDOUT
1172  ***     50      0      3   if ($self->prop('set-vars'))
1179  ***     50      0      3   if (not $dbh and $EVAL_ERROR)
1181  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1194  ***      0      0      0   if (not $tries)
1216  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1233  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1243  ***      0      0      0   unless $dsn_1
1244  ***      0      0      0   unless $dsn_2
1248  ***      0      0      0   if ($args{'overwrite'}) { }
1249  ***      0      0      0   defined $$dsn_1{$key} ? :
1252  ***      0      0      0   defined $$dsn_2{$key} ? :
1261  ***      0      0      0   defined $_ ? :
1290  ***      0      0      0   unless $args{$arg}
1293  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1309  ***      0      0      0   unless defined(my $pid = fork)
1310  ***      0      0      0   if ($pid)
1317  ***      0      0      0   unless POSIX::setsid()
1318  ***      0      0      0   unless chdir '/'
1324  ***      0      0      0   if (-t STDIN)
1326  ***      0      0      0   unless open STDIN, '/dev/null'
1330  ***      0      0      0   if ($$self{'log_file'}) { }
1332  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1336  ***      0      0      0   unless open STDERR, '>&STDOUT'
1340  ***      0      0      0   if (-t STDOUT)
1342  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1345  ***      0      0      0   if (-t STDERR)
1347  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1358  ***      0      0      0   $self ? :
1360  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1363  ***      0      0      0   if $EVAL_ERROR
1365  ***      0      0      0   if ($pid) { }
1367  ***      0      0      0   if ($pid_is_alive) { }
1389  ***      0      0      0   if (exists $$self{'child'})
1401  ***      0      0      0   if (not $PID_file)
1408  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1410  ***      0      0      0   unless print $PID_FH $PID
1412  ***      0      0      0   unless close $PID_FH
1421  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1422  ***      0      0      0   unless unlink $$self{'PID_file'}
1434  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1440  ***      0      0      0   defined $_ ? :
1488  ***      0      0      0   defined $args{'p_ms'} ? :
1489  ***      0      0      0   defined $args{'p_s'} ? :
1492  ***      0      0      0   if $t < 0
1494  ***      0      0      0   if $t =~ /e/
1498  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1519  ***      0      0      0   $p ? :
1526  ***      0      0      0   unless $secs
1528  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1533  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1552  ***      0      0      0   defined $args{'p'} ? :
1553  ***      0      0      0   defined $args{'d'} ? :
1560  ***      0      0      0   $num =~ /\./ || $n ? :
1569  ***     50      0      9   $gmt ? :
1575  ***     50      0      9   if (my($us) = $time =~ /(\.\d+)$/)
1585  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1588  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
1597  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
1598  ***      0      0      0   $gmt ? :
1601  ***      0      0      0   if (defined $us)
1613  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
1614  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1624  ***      0      0      0   unless $hms
1629  ***      0      0      0   unless $hms
1634  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1650  ***      0      0      0   defined $_ ? :
1706  ***      0      0      0   unless $args{$arg}
1711  ***      0      0      0   unless $code
1714  ***      0      0      0   if ($$self{'curr_rows'}) { }
1720  ***      0      0      0   if ($rows and scalar @$rows) { }
1737  ***      0      0      0   if (not $curr and @curr)
1741  ***      0      0      0   if (not $prev and @prev)
1745  ***      0      0      0   if ($curr or $prev)
1746  ***      0      0      0   if ($curr and $prev and $$curr[0] == $$prev[0]) { }
      ***      0      0      0   elsif (not $curr or $curr and $prev and $$curr[0] > $$prev[0]) { }
1748  ***      0      0      0   $$curr[5] =~ /\D/ ? :
1750  ***      0      0      0   if ($$prev[7])
1751  ***      0      0      0   if (not $$curr[7] or $$prev[7] ne $$curr[7]) { }
      ***      0      0      0   elsif (defined $$curr[5] and $$curr[5] < $$prev[5]) { }
      ***      0      0      0   elsif ($$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge) { }
1766  ***      0      0      0   if ($is_new)
1770  ***      0      0      0   if ($$curr[7])
1771  ***      0      0      0   if ($$prev[7] and not $is_new) { }
1792  ***      0      0      0   if ($$curr[7] and defined $$curr[5])
1804  ***      0      0      0   scalar @curr ? :
1813  ***      0      0      0   if ($$row[5] < $time - $$row[10])
1847         100    104    345   if ($find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query')
1848         100     91     13   if ($$query{'Time'} < $find_spec{'busy_time'})
1856         100      1    357   if ($find_spec{'idle_time'} and ($$query{'Command'} || '') eq 'Sleep')
1857  ***     50      0      1   if ($$query{'Time'} < $find_spec{'idle_time'})
1868         100    114   1430   if (defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property}))
1873         100    231   1199   if (defined $find_spec{'match'}{$property})
1874         100    199     32   if (not $self->$filter($query, $find_spec{'match'}{$property}))
1882  ***     50     45      0   if ($matched)
1890         100      7      3   if (@matches and $find_spec{'only_oldest'})
1942  ***      0      0      0   defined $_ ? :
1981         100      1      1   unless @cols
1990  ***      0      0      0   unless @cols
2006         100      1      9   if ($text =~ /^\+---/m) { }
      ***     50      0      9   elsif ($text =~ /^id\tselect_type\t/m) { }
      ***     50      9      0   elsif ($text =~ /\*\*\* \d+\. row/) { }
2029  ***     50      0     10   if ($$self{'value_for'})
2032  ***      0      0      0   if exists $$self{'value_for'}{$$result_set{$key}}
2047         100      1      1   if ($row) { }
2066  ***      0      0      0   defined $_ ? :
2129         100      7      3   if (not $o->got('busy-time')) { }
2130  ***     50      7      0   unless $o->got('interval')
2133  ***     50      3      0   unless $o->got('interval')
2138  ***     50     10      0   if (@ARGV)
2150  ***     50      0     10   if (not @ARGV)
2160  ***     50     10      0   if (@ARGV) { }
2165  ***     50     10      0   if (not $fh)
2167  ***     50      0     10   unless $file
2168  ***     50      0     10   if ($file eq '-') { }
2172  ***     50      0     10   if (not open $fh, '<', $file)
2180  ***     50     10      0   if ($fh)
2183  ***     50     10      0   if ($proclist_text) { }
2208  ***     50      0     10   if ($o->get('daemonize')) { }
      ***     50      0     10   elsif ($o->get('pid')) { }
2226  ***     50     10      0   $o->get('ignore-self') ? :
2258  ***     50      0     10   if ($EVAL_ERROR)
2259  ***      0      0      0   if $EVAL_ERROR =~ /No more files/
2264  ***     50     10      0   if ($proclist) { }
2269  ***     50      9      0   if ($o->get('print'))
2274  ***     50      0      9   if ($o->get('execute-command'))
2278  ***     50      0      9   if ($o->get('kill'))
2279  ***      0      0      0   if $o->get('wait-before-kill')
2294  ***     50      0     10   if (!$iters_todo || $iters_done < $iters_todo and $dbh)
2296  ***      0      0      0   if (@queries and $o->get('wait-after-kill')) { }
2319  ***      0      0      0   if ($o->get('ask-pass'))
2332  ***      0      0      0   unless $cmd
2335  ***      0      0      0   if ($pid)
2342  ***      0      0      0   unless POSIX::setsid()
2351  ***     50      0     30   if $o->get('heartbeat')
2358  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
1720  ***      0      0      0   $rows and scalar @$rows

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
256   ***     66     90    310      0   $type and $type eq 'd'
      ***     33    400      0      0   $type and $type eq 'd' and not $$self{'dp'}
261          100     90    240     70   $type and $type =~ /[HhAadzm]/
400   ***     33      0     10      0   @ARGV and $ARGV[0] eq '--config'
429   ***     33      0     10      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
436   ***     33      0     10      0   @ARGV and $$self{'strict'}
520   ***     66      0     90    310   $opt and $$opt{'type'}
523          100    239     67      4   $val and $$opt{'type'} eq 'm'
      ***     66    239     67      0   $val and $$opt{'type'} eq 'd'
      ***     66    239     67      0   $val and $$opt{'type'} eq 'z'
      ***     66    239     67      0   defined $val and $$opt{'type'} eq 'h'
      ***     66    239     57      0   defined $val and $$opt{'type'} eq 'a'
588   ***     33      0      0    270   $long and exists $$self{'opts'}{$long}
596   ***     33      0      0     60   $long and exists $$self{'opts'}{$long}
610   ***     33      0      0     20   $long and exists $$self{'opts'}{$long}
699   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
793   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1021  ***     66     12     12      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     24      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1143  ***     66      3      0      3   not $dbh and $tries--
1179  ***     33      3      0      0   not $dbh and $EVAL_ERROR
1360  ***      0      0      0      0   $PID_file and -f $PID_file
1421  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1498  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1556  ***      0      0      0      0   $num >= $d and $n < @units - 1
1634  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
1737  ***      0      0      0      0   not $curr and @curr
1741  ***      0      0      0      0   not $prev and @prev
1746  ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] == $$prev[0]
      ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] > $$prev[0]
1751  ***      0      0      0      0   defined $$curr[5] and $$curr[5] < $$prev[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge
1771  ***      0      0      0      0   $$prev[7] and not $is_new
1792  ***      0      0      0      0   $$curr[7] and defined $$curr[5]
1847  ***     66    345      0    104   $find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query'
1856  ***     66    357      0      1   $find_spec{'idle_time'} and ($$query{'Command'} || '') eq 'Sleep'
1868         100    895    535    114   defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property})
1890         100      2      1      7   @matches and $find_spec{'only_oldest'}
1901  ***      0      0      0      0   defined $property && defined $$query{'Id'}
      ***      0      0      0      0   defined $property && defined $$query{'Id'} && $$query{'Id'} == $property
1906  ***     33      0      0    358   defined $property && defined $$query{'User'}
      ***     66      0    246    112   defined $property && defined $$query{'User'} && $$query{'User'} =~ /$property/
1912  ***      0      0      0      0   defined $property && defined $$query{'Host'}
      ***      0      0      0      0   defined $property && defined $$query{'Host'} && $$query{'Host'} =~ /$property/
1918  ***      0      0      0      0   defined $property && defined $$query{'db'}
      ***      0      0      0      0   defined $property && defined $$query{'db'} && $$query{'db'} =~ /$property/
1924  ***     66      0     93    380   defined $property && defined $$query{'State'}
             100     93    350     30   defined $property && defined $$query{'State'} && $$query{'State'} =~ /$property/
1930  ***     33      0      0     48   defined $property && defined $$query{'Command'}
      ***     66      0     45      3   defined $property && defined $$query{'Command'} && $$query{'Command'} =~ /$property/
1936  ***     33      0      0      1   defined $property && defined $$query{'Info'}
      ***     33      0      0      1   defined $property && defined $$query{'Info'} && $$query{'Info'} =~ /$property/
2251  ***     66      0     10     10   $start == $end || $now < $end and !$iters_todo || $iters_done++ < $iters_todo
2294  ***     33     10      0      0   !$iters_todo || $iters_done < $iters_todo and $dbh
2296  ***      0      0      0      0   @queries and $o->get('wait-after-kill')

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
41    ***     50      0      4   $ENV{'MKDEBUG'} || 0
61    ***     50     10      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
63    ***     50     10      0   $args{'prompt'} || '<options>'
      ***     50      0     10   $args{'dp'} || undef
105   ***     50      0     10   $file ||= '/home/daniel/dev/maatkit/mk-kill/mk-kill'
246   ***     50    400      0   $$opt{'group'} ||= 'default'
528   ***     50      0      4   $s || 's'
537   ***     50      0      4   $prefix || ''
565   ***      0      0      0   $pre || ''
572   ***      0      0      0   $val || ''
575   ***     50     10      0   $val || ''
633   ***      0      0      0   $$self{'description'} || ''
701   ***      0      0      0   $s ||= 's'
727   ***      0      0      0   $$opt{'type'} || ''
875   ***     50      0      4   $ENV{'MKDEBUG'} || 0
931   ***     50      0      4   $ENV{'MKDEBUG'} || 0
1002  ***     50      0      3   $prev ||= {}
1003  ***     50      0      3   $defaults ||= {}
1076  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1089  ***     50      0      3   $self->prop('dbidriver') || ''
1093  ***      0      0      0   $$info{'D'} || ''
1099  ***     50      0      3   $$info{'D'} || ''
1121  ***     50      3      0   $opts ||= {}
1216  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1232  ***      0      0      0   $level ||= 0
1233  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1285  ***     50      0      4   $ENV{'MKDEBUG'} || 0
1464  ***     50      0      4   $ENV{'MKDEBUG'} || 0
1518  ***      0      0      0   $args{'p'} || 0
1520  ***      0      0      0   $of ||= 1
1525  ***      0      0      0   $secs ||= 0
1676  ***     50      0      4   $ENV{'MKDEBUG'} || 0
1729  ***      0      0      0   $$self{'prev_rows'} ||= []
1730  ***      0      0      0   $$self{'new_rows'} ||= []
1847  ***     50    104      0   $$query{'Command'} || ''
1856  ***     50      1      0   $$query{'Command'} || ''
1969  ***     50      0      4   $ENV{'MKDEBUG'} || 0
2094  ***     50      0      4   $ENV{'MKDEBUG'} || 0
2223  ***     50      0     10   $o->get('run-time') || 0
2270  ***     50      9      0   $$query{'Command'} || 'NULL'
      ***     50      9      0   $$query{'Info'} || 'NULL'

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
60    ***     33     10      0      0   $program_name ||= $PROGRAM_NAME
61    ***     33     10      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     10      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
523   ***     33      0      0    306   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66     10      0    296   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1112  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1113  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1114  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1115  ***      0      0      0      0   $$dsn{'u'} ||= $user
1116  ***      0      0      0      0   $$dsn{'D'} ||= $db
1434  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1528  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1560  ***      0      0      0      0   $num =~ /\./ || $n
1745  ***      0      0      0      0   $curr or $prev
1746  ***      0      0      0      0   not $curr or $curr and $prev and $$curr[0] > $$prev[0]
1751  ***      0      0      0      0   not $$curr[7] or $$prev[7] ne $$curr[7]
2251  ***     33     20      0      0   $start == $end || $now < $end
      ***     66      0     10     10   !$iters_todo || $iters_done++ < $iters_todo
2294  ***     33      0      0     10   !$iters_todo || $iters_done < $iters_todo


Covered Subroutines
-------------------

Subroutine           Count Location                                     
-------------------- ----- ---------------------------------------------
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1279
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1280
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1282
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1283
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1285
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1458
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1459
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1460
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1461
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1462
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1464
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1667
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1668
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1669
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1671
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1676
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1689
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1960
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1961
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1962
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1964
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1969
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:2088
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:2089
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:2090
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:2094
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:22  
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:23  
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:34  
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:35  
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:37  
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:38  
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:39  
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:41  
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:870 
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:871 
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:873 
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:875 
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:919 
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:920 
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:921 
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:922 
BEGIN                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:931 
__ANON__                10 /home/daniel/dev/maatkit/mk-kill/mk-kill:2165
__ANON__                25 /home/daniel/dev/maatkit/mk-kill/mk-kill:424 
_find_match_Command     48 /home/daniel/dev/maatkit/mk-kill/mk-kill:1929
_find_match_Info         1 /home/daniel/dev/maatkit/mk-kill/mk-kill:1935
_find_match_State      473 /home/daniel/dev/maatkit/mk-kill/mk-kill:1923
_find_match_User       358 /home/daniel/dev/maatkit/mk-kill/mk-kill:1905
_get_participants       10 /home/daniel/dev/maatkit/mk-kill/mk-kill:324 
_parse_specs            10 /home/daniel/dev/maatkit/mk-kill/mk-kill:210 
_parse_tabular           2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1978
_pod_to_specs           10 /home/daniel/dev/maatkit/mk-kill/mk-kill:104 
_read_config_file       40 /home/daniel/dev/maatkit/mk-kill/mk-kill:776 
_set_option             25 /home/daniel/dev/maatkit/mk-kill/mk-kill:370 
_validate_type         400 /home/daniel/dev/maatkit/mk-kill/mk-kill:519 
find                    10 /home/daniel/dev/maatkit/mk-kill/mk-kill:1839
get                    270 /home/daniel/dev/maatkit/mk-kill/mk-kill:586 
get_cxn_params           3 /home/daniel/dev/maatkit/mk-kill/mk-kill:1086
get_dbh                  3 /home/daniel/dev/maatkit/mk-kill/mk-kill:1120
get_defaults_files      10 /home/daniel/dev/maatkit/mk-kill/mk-kill:99  
get_opts                10 /home/daniel/dev/maatkit/mk-kill/mk-kill:387 
get_specs               10 /home/daniel/dev/maatkit/mk-kill/mk-kill:92  
got                     60 /home/daniel/dev/maatkit/mk-kill/mk-kill:594 
has                     10 /home/daniel/dev/maatkit/mk-kill/mk-kill:602 
heartbeat               30 /home/daniel/dev/maatkit/mk-kill/mk-kill:2350
main                    10 /home/daniel/dev/maatkit/mk-kill/mk-kill:2106
new                     10 /home/daniel/dev/maatkit/mk-kill/mk-kill:1692
new                     10 /home/daniel/dev/maatkit/mk-kill/mk-kill:1972
new                     10 /home/daniel/dev/maatkit/mk-kill/mk-kill:55  
new                     10 /home/daniel/dev/maatkit/mk-kill/mk-kill:878 
new                     13 /home/daniel/dev/maatkit/mk-kill/mk-kill:934 
parse                   10 /home/daniel/dev/maatkit/mk-kill/mk-kill:2003
parse                    3 /home/daniel/dev/maatkit/mk-kill/mk-kill:996 
parse_horizontal_row     1 /home/daniel/dev/maatkit/mk-kill/mk-kill:2042
parse_vertical_row     448 /home/daniel/dev/maatkit/mk-kill/mk-kill:1996
prop                     9 /home/daniel/dev/maatkit/mk-kill/mk-kill:987 
set                     20 /home/daniel/dev/maatkit/mk-kill/mk-kill:608 
split_vertical_rows      9 /home/daniel/dev/maatkit/mk-kill/mk-kill:2058
ts                       9 /home/daniel/dev/maatkit/mk-kill/mk-kill:1568
usage_or_errors         10 /home/daniel/dev/maatkit/mk-kill/mk-kill:643 

Uncovered Subroutines
---------------------

Subroutine           Count Location                                     
-------------------- ----- ---------------------------------------------
DESTROY                  0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1433
__ANON__                 0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2199
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1260
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1439
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1649
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1941
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2065
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2357
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:852 
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:901 
_find_match_Host         0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1911
_find_match_Id           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1900
_find_match_db           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1917
_get_rows                0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1832
_make_PID_file           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1398
_parse_tab_sep           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1987
_remove_PID_file         0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1420
any_unix_timestamp       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1611
as_string                0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1060
check_PID_file           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1357
clone                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:829 
copy                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1242
daemonize                0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1306
descr                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:632 
disconnect               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1225
errors                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:622 
exec_cmd                 0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2330
fill_in_dsn              0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1108
get_cxn                  0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2318
get_defaults             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:360 
get_groups               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:365 
get_hostname             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1215
make_PID_file            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1388
make_checksum            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1642
make_event               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1811
micro_t                  0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1487
new                      0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1288
opts                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:336 
parse                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:883 
parse_event              0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1703
parse_options            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1047
parse_timestamp          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1584
percentage_of            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1517
print_active_handles     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1231
print_errors             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:656 
print_usage              0 /home/daniel/dev/maatkit/mk-kill/mk-kill:666 
prompt                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:627 
prompt_noecho            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:741 
read_para_after          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:810 
save_error               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:617 
secs_to_time             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1524
set_defaults             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:348 
short_opts               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:342 
shorten                  0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1551
unix_timestamp           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1596
usage                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1069
version_ge               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:890 


