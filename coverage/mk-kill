---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...v/maatkit/mk-kill/mk-kill   38.8   25.0   17.8   52.9    n/a  100.0   33.3
Total                          38.8   25.0   17.8   52.9    n/a  100.0   33.3
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          mk-kill.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat Jul 18 16:02:59 2009
Finish:       Sat Jul 18 16:03:31 2009

Run:          mk-kill.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat Jul 18 16:02:59 2009
Finish:       Sat Jul 18 16:03:31 2009

/home/daniel/dev/maatkit/mk-kill/mk-kill

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-kill, a program that kills queries in MySQL.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22             2                    2            14   use strict;
               2                                  6   
               2                                 12   
23             2                    2           208   use warnings FATAL => 'all';
               2                                  4   
               2                                 18   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 4191 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # OptionParser package 3945
31                                                    # ###########################################################################
32                                                    package OptionParser;
33                                                    
34             2                    2            12   use strict;
               2                                  4   
               2                                  8   
35             2                    2            10   use warnings FATAL => 'all';
               2                                  4   
               2                                 10   
36                                                    
37             2                    2            22   use Getopt::Long;
               2                                  8   
               2                                 14   
38             2                    2            14   use List::Util qw(max);
               2                                  4   
               2                                 22   
39             2                    2            14   use English qw(-no_match_vars);
               2                                  4   
               2                                 16   
40                                                    
41             2                    2            14   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  4   
               2                                 18   
42                                                    
43                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
44                                                    
45                                                    my %attributes = (
46                                                       'type'       => 1,
47                                                       'short form' => 1,
48                                                       'group'      => 1,
49                                                       'default'    => 1,
50                                                       'cumulative' => 1,
51                                                       'negatable'  => 1,
52                                                    );
53                                                    
54                                                    sub new {
55             2                    2            34      my ( $class, %args ) = @_;
56             2                                 24      foreach my $arg ( qw(description) ) {
57    ***      2     50                          32         die "I need a $arg argument" unless $args{$arg};
58                                                       }
59             2                                 52      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
60    ***      2            50                  146      $program_name ||= $PROGRAM_NAME;
61                                                    
62    ***      2     50     50                  162      my $self = {
      ***                   50                        
63                                                          description    => $args{description},
64                                                          prompt         => $args{prompt} || '<options>',
65                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
66                                                          dp             => $args{dp}     || undef,
67                                                          program_name   => $program_name,
68                                                          opts           => {},
69                                                          got_opts       => 0,
70                                                          short_opts     => {},
71                                                          defaults       => {},
72                                                          groups         => {},
73                                                          allowed_groups => {},
74                                                          errors         => [],
75                                                          rules          => [],  # desc of rules for --help
76                                                          mutex          => [],  # rule: opts are mutually exclusive
77                                                          atleast1       => [],  # rule: at least one opt is required
78                                                          disables       => {},  # rule: opt disables other opts 
79                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
80                                                          default_files  => [
81                                                             "/etc/maatkit/maatkit.conf",
82                                                             "/etc/maatkit/$program_name.conf",
83                                                             "$ENV{HOME}/.maatkit.conf",
84                                                             "$ENV{HOME}/.$program_name.conf",
85                                                          ],
86                                                       };
87             2                                 74      return bless $self, $class;
88                                                    }
89                                                    
90                                                    sub get_specs {
91             2                    2            14      my ( $self, $file ) = @_;
92             2                                 22      my @specs = $self->_pod_to_specs($file);
93             2                                 84      $self->_parse_specs(@specs);
94             2                                 14      return;
95                                                    }
96                                                    
97                                                    sub get_defaults_files {
98             2                    2            12      my ( $self ) = @_;
99             2                                 10      return @{$self->{default_files}};
               2                                 46   
100                                                   }
101                                                   
102                                                   sub _pod_to_specs {
103            2                    2            14      my ( $self, $file ) = @_;
104   ***      2            50                   18      $file ||= __FILE__;
105   ***      2     50                         100      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
106                                                   
107            2                                 92      my %types = (
108                                                         string => 's', # standard Getopt type
109                                                         'int'  => 'i', # standard Getopt type
110                                                         float  => 'f', # standard Getopt type
111                                                         Hash   => 'H', # hash, formed from a comma-separated list
112                                                         hash   => 'h', # hash as above, but only if a value is given
113                                                         Array  => 'A', # array, similar to Hash
114                                                         array  => 'a', # array, similar to hash
115                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
116                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
117                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
118                                                      );
119            2                                 14      my @specs = ();
120            2                                 14      my @rules = ();
121            2                                 16      my $para;
122                                                   
123            2                                 22      local $INPUT_RECORD_SEPARATOR = '';
124            2                                180      while ( $para = <$fh> ) {
125          598    100                        6940         next unless $para =~ m/^=head1 OPTIONS/;
126            2                                 14         last;
127                                                      }
128                                                   
129            2                                 38      while ( $para = <$fh> ) {
130            4    100                          38         last if $para =~ m/^=over/;
131            2                                 14         chomp $para;
132            2                                 34         $para =~ s/\s+/ /g;
133            2                                170         $para =~ s/$POD_link_re/$1/go;
134            2                                 10         MKDEBUG && _d('Option rule:', $para);
135            2                                 28         push @rules, $para;
136                                                      }
137                                                   
138   ***      2     50                          16      die 'POD has no OPTIONS section' unless $para;
139                                                   
140            2                                 10      do {
141           66    100                         740         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
142           64                                272            chomp $para;
143           64                                192            MKDEBUG && _d($para);
144           64                                216            my %attribs;
145                                                   
146           64                                356            $para = <$fh>; # read next paragraph, possibly attributes
147                                                   
148           64    100                         408            if ( $para =~ m/: / ) { # attributes
149           56                                444               $para =~ s/\s+\Z//g;
150           98                                788               %attribs = map {
151           56                                422                     my ( $attrib, $val) = split(/: /, $_);
152   ***     98     50                         696                     die "Unrecognized attribute for --$option: $attrib"
153                                                                        unless $attributes{$attrib};
154           98                                794                     ($attrib, $val);
155                                                                  } split(/; /, $para);
156           56    100                         420               if ( $attribs{'short form'} ) {
157           14                                110                  $attribs{'short form'} =~ s/-//;
158                                                               }
159           56                                458               $para = <$fh>; # read next paragraph, probably short help desc
160                                                            }
161                                                            else {
162            8                                 30               MKDEBUG && _d('Option has no attributes');
163                                                            }
164                                                   
165           64                                870            $para =~ s/\s+\Z//g;
166           64                                956            $para =~ s/\s+/ /g;
167           64                                478            $para =~ s/$POD_link_re/$1/go;
168                                                   
169           64                                422            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
170           64                                214            MKDEBUG && _d('Short help:', $para);
171                                                   
172   ***     64     50                         412            die "No description after option spec $option" if $para =~ m/^=item/;
173                                                   
174           64    100                         502            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
175            4                                 18               $option = $base_option;
176            4                                 24               $attribs{'negatable'} = 1;
177                                                            }
178                                                   
179           64    100                        1898            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
                    100                               
180                                                               spec  => $option
181                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
182                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
183                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
184                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
185                                                               desc  => $para
186                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
187                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
188                                                            };
189                                                         }
190           66                                682         while ( $para = <$fh> ) {
191   ***     94     50                         508            last unless $para;
192                                                   
193                                                   
194           94    100                         586            if ( $para =~ m/^=head1/ ) {
195            2                                 10               $para = undef; # Can't 'last' out of a do {} block.
196            2                                 18               last;
197                                                            }
198           92    100                         996            last if $para =~ m/^=item --/;
199                                                         }
200                                                      } while ( $para );
201                                                   
202   ***      2     50                          14      die 'No valid specs in POD OPTIONS' unless @specs;
203                                                   
204            2                                 62      close $fh;
205            2                                 12      return @specs, @rules;
206                                                   }
207                                                   
208                                                   sub _parse_specs {
209            2                    2            32      my ( $self, @specs ) = @_;
210            2                                 12      my %disables; # special rule that requires deferred checking
211                                                   
212            2                                 18      foreach my $opt ( @specs ) {
213           66    100                         380         if ( ref $opt ) { # It's an option spec, not a rule.
214                                                            MKDEBUG && _d('Parsing opt spec:',
215           64                                196               map { ($_, '=>', $opt->{$_}) } keys %$opt);
216                                                   
217           64                                740            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
218   ***     64     50                         418            if ( !$long ) {
219   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
220                                                            }
221           64                                354            $opt->{long} = $long;
222                                                   
223   ***     64     50                         504            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
224           64                                472            $self->{opts}->{$long} = $opt;
225                                                   
226   ***     64     50                         396            if ( length $long == 1 ) {
227   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
228   ***      0                                  0               $self->{short_opts}->{$long} = $long;
229                                                            }
230                                                   
231           64    100                         330            if ( $short ) {
232   ***     14     50                         104               die "Duplicate short option -$short"
233                                                                  if exists $self->{short_opts}->{$short};
234           14                                164               $self->{short_opts}->{$short} = $long;
235           14                                 78               $opt->{short} = $short;
236                                                            }
237                                                            else {
238           50                                268               $opt->{short} = undef;
239                                                            }
240                                                   
241           64    100                         552            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
242   ***     64     50                         502            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
243   ***     64     50                         590            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
244                                                   
245   ***     64            50                  416            $opt->{group} ||= 'default';
246           64                                500            $self->{groups}->{ $opt->{group} }->{$long} = 1;
247                                                   
248           64                                366            $opt->{value} = undef;
249           64                                310            $opt->{got}   = 0;
250                                                   
251           64                                580            my ( $type ) = $opt->{spec} =~ m/=(.)/;
252           64                                404            $opt->{type} = $type;
253           64                                198            MKDEBUG && _d($long, 'type:', $type);
254                                                   
255   ***     64     50     66                  934            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
256   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
257                                                                  . "was given when this OptionParser object was created";
258                                                            }
259                                                   
260           64    100    100                  822            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
261                                                   
262           64    100                         652            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
263           14    100                         102               if ( $opt->{is_negatable} ) {
264   ***      4      0                          30                  $def = $def eq 'yes' ? 1
      ***            50                               
265                                                                       : $def eq 'no'  ? 0
266                                                                       : $def;
267                                                               }
268   ***     14     50                         124               $self->{defaults}->{$long} = defined $def ? $def : 1;
269           14                                 50               MKDEBUG && _d($long, 'default:', $def);
270                                                            }
271                                                   
272           64    100                         388            if ( $long eq 'config' ) {
273            2                                 18               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
274                                                            }
275                                                   
276   ***     64     50                         528            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
277   ***      0                                  0               $disables{$long} = $dis;
278   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
279                                                            }
280                                                   
281           64                                522            $self->{opts}->{$long} = $opt;
282                                                         }
283                                                         else { # It's an option rule, not a spec.
284            2                                  6            MKDEBUG && _d('Parsing rule:', $opt); 
285            2                                  8            push @{$self->{rules}}, $opt;
               2                                 14   
286            2                                 28            my @participants = $self->_get_participants($opt);
287            2                                 10            my $rule_ok = 0;
288                                                   
289   ***      2     50                          34            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
290   ***      0                                  0               $rule_ok = 1;
291   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
292   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
293                                                            }
294   ***      2     50                          34            if ( $opt =~ m/at least one|one and only one/ ) {
295            2                                 10               $rule_ok = 1;
296            2                                 22               push @{$self->{atleast1}}, \@participants;
               2                                 20   
297            2                                 10               MKDEBUG && _d(@participants, 'require at least one');
298                                                            }
299   ***      2     50                          24            if ( $opt =~ m/default to/ ) {
300   ***      0                                  0               $rule_ok = 1;
301   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
302   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
303                                                            }
304   ***      2     50                          24            if ( $opt =~ m/restricted to option groups/ ) {
305   ***      0                                  0               $rule_ok = 1;
306   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
307   ***      0                                  0               my @groups = split(',', $groups);
308   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
309   ***      0                                  0                  s/\s+//;
310   ***      0                                  0                  $_ => 1;
311                                                               } @groups;
312                                                            }
313                                                   
314   ***      2     50                          20            die "Unrecognized option rule: $opt" unless $rule_ok;
315                                                         }
316                                                      }
317                                                   
318            2                                 18      foreach my $long ( keys %disables ) {
319   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
320   ***      0                                  0         $self->{disables}->{$long} = \@participants;
321   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
322                                                      }
323                                                   
324            2                                 18      return; 
325                                                   }
326                                                   
327                                                   sub _get_participants {
328            2                    2            16      my ( $self, $str ) = @_;
329            2                                 10      my @participants;
330            2                                 56      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
331   ***      6     50                          52         die "Option --$long does not exist while processing rule $str"
332                                                            unless exists $self->{opts}->{$long};
333            6                                 38         push @participants, $long;
334                                                      }
335            2                                  8      MKDEBUG && _d('Participants for', $str, ':', @participants);
336            2                                 24      return @participants;
337                                                   }
338                                                   
339                                                   sub opts {
340   ***      0                    0             0      my ( $self ) = @_;
341   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
342   ***      0                                  0      return %opts;
343                                                   }
344                                                   
345                                                   sub opt_values {
346   ***      0                    0             0      my ( $self ) = @_;
347   ***      0      0                           0      my %opts = map {
348   ***      0                                  0         my $opt = $self->{opts}->{$_}->{short} ? $self->{opts}->{$_}->{short}
349                                                                 : $_;
350   ***      0                                  0         $opt => $self->{opts}->{$_}->{value}
351   ***      0                                  0      } keys %{$self->{opts}};
352   ***      0                                  0      return %opts;
353                                                   }
354                                                   
355                                                   sub short_opts {
356   ***      0                    0             0      my ( $self ) = @_;
357   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
358   ***      0                                  0      return %short_opts;
359                                                   }
360                                                   
361                                                   sub set_defaults {
362   ***      0                    0             0      my ( $self, %defaults ) = @_;
363   ***      0                                  0      $self->{defaults} = {};
364   ***      0                                  0      foreach my $long ( keys %defaults ) {
365   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
366                                                            unless exists $self->{opts}->{$long};
367   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
368   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
369                                                      }
370   ***      0                                  0      return;
371                                                   }
372                                                   
373                                                   sub get_defaults {
374   ***      0                    0             0      my ( $self ) = @_;
375   ***      0                                  0      return $self->{defaults};
376                                                   }
377                                                   
378                                                   sub get_groups {
379   ***      0                    0             0      my ( $self ) = @_;
380   ***      0                                  0      return $self->{groups};
381                                                   }
382                                                   
383                                                   sub _set_option {
384            4                    4            32      my ( $self, $opt, $val ) = @_;
385   ***      4      0                          12      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
386                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
387                                                               : die "Getopt::Long gave a nonexistent option: $opt";
388                                                   
389            4                                 12      $opt = $self->{opts}->{$long};
390   ***      4     50                          38      if ( $opt->{is_cumulative} ) {
391   ***      0                                  0         $opt->{value}++;
392                                                      }
393                                                      else {
394            4                                 24         $opt->{value} = $val;
395                                                      }
396            4                                 20      $opt->{got} = 1;
397            4                                 26      MKDEBUG && _d('Got option', $long, '=', $val);
398                                                   }
399                                                   
400                                                   sub get_opts {
401            2                    2            26      my ( $self ) = @_; 
402                                                   
403            2                                  8      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 42   
404           64                                402         $self->{opts}->{$long}->{got} = 0;
405   ***     64     50                         874         $self->{opts}->{$long}->{value}
                    100                               
406                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
407                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
408                                                            : undef;
409                                                      }
410            2                                 20      $self->{got_opts} = 0;
411                                                   
412            2                                 14      $self->{errors} = [];
413                                                   
414   ***      2     50     33                   48      if ( @ARGV && $ARGV[0] eq "--config" ) {
415   ***      0                                  0         shift @ARGV;
416   ***      0                                  0         $self->_set_option('config', shift @ARGV);
417                                                      }
418   ***      2     50                          26      if ( $self->has('config') ) {
419            2                                  8         my @extra_args;
420            2                                 32         foreach my $filename ( split(',', $self->get('config')) ) {
421            8                                 32            eval {
422            8                                 76               push @ARGV, $self->_read_config_file($filename);
423                                                            };
424   ***      8     50                          70            if ( $EVAL_ERROR ) {
425   ***      8     50                          60               if ( $self->got('config') ) {
426   ***      0                                  0                  die $EVAL_ERROR;
427                                                               }
428                                                               elsif ( MKDEBUG ) {
429                                                                  _d($EVAL_ERROR);
430                                                               }
431                                                            }
432                                                         }
433            2                                 14         unshift @ARGV, @extra_args;
434                                                      }
435                                                   
436            2                                 48      Getopt::Long::Configure('no_ignore_case', 'bundling');
437                                                      GetOptions(
438           62                    4           730         map    { $_->{spec} => sub { $self->_set_option(@_); } }
               4                                 64   
              64                                404   
439            2                                 24         grep   { $_->{long} ne 'config' } # --config is handled specially above.
440   ***      2     50                          10         values %{$self->{opts}}
441                                                      ) or $self->save_error('Error parsing options');
442                                                   
443   ***      2     50     33                  184      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
444   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
445                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
446                                                               or die "Cannot print: $OS_ERROR";
447   ***      0                                  0         exit 0;
448                                                      }
449                                                   
450   ***      2     50     33                   50      if ( @ARGV && $self->{strict} ) {
451   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
452                                                      }
453                                                   
454            2                                 10      foreach my $mutex ( @{$self->{mutex}} ) {
               2                                 18   
455   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
456   ***      0      0                           0         if ( @set > 1 ) {
457   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
458   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
459                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
460                                                                    . ' are mutually exclusive.';
461   ***      0                                  0            $self->save_error($err);
462                                                         }
463                                                      }
464                                                   
465            2                                  8      foreach my $required ( @{$self->{atleast1}} ) {
               2                                 16   
466            2                                 14         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
               6                                 52   
467   ***      2     50                          22         if ( @set == 0 ) {
468   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
469   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
470                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
471   ***      0                                  0            $self->save_error("Specify at least one of $err");
472                                                         }
473                                                      }
474                                                   
475            2                                 10      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 34   
476           64                                392         my $opt = $self->{opts}->{$long};
477           64    100                         604         if ( $opt->{got} ) {
      ***            50                               
478   ***      4     50                          36            if ( exists $self->{disables}->{$long} ) {
479   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
480   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
481   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
482                                                                  'because', $long,'disables them');
483                                                            }
484                                                   
485   ***      4     50                          32            if ( exists $self->{allowed_groups}->{$long} ) {
486                                                   
487   ***      0                                  0               my @restricted_groups = grep {
488   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
489   ***      0                                  0               } keys %{$self->{groups}};
490                                                   
491   ***      0                                  0               my @restricted_opts;
492   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
493   ***      0                                  0                  RESTRICTED_OPT:
494   ***      0                                  0                  foreach my $restricted_opt (
495                                                                     keys %{$self->{groups}->{$restricted_group}} )
496                                                                  {
497   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
498   ***      0      0                           0                     push @restricted_opts, $restricted_opt
499                                                                        if $self->{opts}->{$restricted_opt}->{got};
500                                                                  }
501                                                               }
502                                                   
503   ***      0      0                           0               if ( @restricted_opts ) {
504   ***      0                                  0                  my $err;
505   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
506   ***      0                                  0                     $err = "--$restricted_opts[0]";
507                                                                  }
508                                                                  else {
509   ***      0                                  0                     $err = join(', ',
510   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
511   ***      0                                  0                               grep { $_ } 
512                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
513                                                                            )
514                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
515                                                                  }
516   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
517                                                               }
518                                                            }
519                                                   
520                                                         }
521                                                         elsif ( $opt->{is_required} ) { 
522   ***      0                                  0            $self->save_error("Required option --$long must be specified");
523                                                         }
524                                                   
525           64                                370         $self->_validate_type($opt);
526                                                      }
527                                                   
528            2                                 18      $self->{got_opts} = 1;
529            2                                  8      return;
530                                                   }
531                                                   
532                                                   sub _validate_type {
533           64                   64           352      my ( $self, $opt ) = @_;
534   ***     64    100     66                  920      return unless $opt && $opt->{type};
535           48                                238      my $val = $opt->{value};
536                                                   
537   ***     48     50     66                 2274      if ( $val && $opt->{type} eq 'm' ) {
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
538   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
539   ***      0                                  0         my ( $num, $suffix ) = $val =~ m/(\d+)([a-z])?$/;
540   ***      0      0                           0         if ( !$suffix ) {
541   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
542   ***      0             0                    0            $suffix = $s || 's';
543   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
544                                                               $opt->{long}, '(value:', $val, ')');
545                                                         }
546   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
547   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
548                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
549                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
550                                                                 :                  $num * 86400;   # Days
551   ***      0                                  0            $opt->{value} = $val;
552   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
553                                                         }
554                                                         else {
555   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
556                                                         }
557                                                      }
558                                                      elsif ( $val && $opt->{type} eq 'd' ) {
559   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
560   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
561   ***      0                                  0         my $default = {};
562   ***      0      0                           0         if ( $from_key ) {
563   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
564   ***      0                                  0            $default = $self->{dp}->parse(
565                                                               $self->{dp}->as_string($self->{opts}->{$from_key}->{value}) );
566                                                         }
567   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $default);
568                                                      }
569                                                      elsif ( $val && $opt->{type} eq 'z' ) {
570   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
571   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
572   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
573   ***      0      0                           0         if ( defined $num ) {
574   ***      0      0                           0            if ( $factor ) {
575   ***      0                                  0               $num *= $factor_for{$factor};
576   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
577                                                                  'to num', $num, '* factor', $factor);
578                                                            }
579   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
580                                                         }
581                                                         else {
582   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
583                                                         }
584                                                      }
585                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
586   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
587                                                      }
588                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
589   ***      2            50                   48         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
590                                                      }
591                                                      else {
592           46                                160         MKDEBUG && _d('Nothing to validate for option',
593                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
594                                                      }
595                                                   
596           48                                250      return;
597                                                   }
598                                                   
599                                                   sub get {
600           33                   33           272      my ( $self, $opt ) = @_;
601   ***     33     50                         238      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
602   ***     33     50     33                  526      die "Option $opt does not exist"
603                                                         unless $long && exists $self->{opts}->{$long};
604           33                                633      return $self->{opts}->{$long}->{value};
605                                                   }
606                                                   
607                                                   sub got {
608           12                   12            80      my ( $self, $opt ) = @_;
609   ***     12     50                          90      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
610   ***     12     50     33                  216      die "Option $opt does not exist"
611                                                         unless $long && exists $self->{opts}->{$long};
612           12                                152      return $self->{opts}->{$long}->{got};
613                                                   }
614                                                   
615                                                   sub has {
616            2                    2            16      my ( $self, $opt ) = @_;
617   ***      2     50                          68      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
618   ***      2     50                          44      return defined $long ? exists $self->{opts}->{$long} : 0;
619                                                   }
620                                                   
621                                                   sub set {
622            4                    4            30      my ( $self, $opt, $val ) = @_;
623   ***      4     50                          30      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
624   ***      4     50     33                   72      die "Option $opt does not exist"
625                                                         unless $long && exists $self->{opts}->{$long};
626            4                                 30      $self->{opts}->{$long}->{value} = $val;
627            4                                 18      return;
628                                                   }
629                                                   
630                                                   sub save_error {
631   ***      0                    0             0      my ( $self, $error ) = @_;
632   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
633                                                   }
634                                                   
635                                                   sub errors {
636   ***      0                    0             0      my ( $self ) = @_;
637   ***      0                                  0      return $self->{errors};
638                                                   }
639                                                   
640                                                   sub prompt {
641   ***      0                    0             0      my ( $self ) = @_;
642   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
643                                                   }
644                                                   
645                                                   sub descr {
646   ***      0                    0             0      my ( $self ) = @_;
647   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
648                                                                 . "  For more details, please use the --help option, "
649                                                                 . "or try 'perldoc $PROGRAM_NAME' "
650                                                                 . "for complete documentation.";
651   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
652   ***      0                                  0      $descr =~ s/ +$//mg;
653   ***      0                                  0      return $descr;
654                                                   }
655                                                   
656                                                   sub usage_or_errors {
657            2                    2            12      my ( $self ) = @_;
658   ***      2     50                          20      if ( $self->{opts}->{help}->{got} ) {
      ***      2     50                          20   
659   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
660   ***      0                                  0         exit 0;
661                                                      }
662                                                      elsif ( scalar @{$self->{errors}} ) {
663   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
664   ***      0                                  0         exit 0;
665                                                      }
666            2                                  8      return;
667                                                   }
668                                                   
669                                                   sub print_errors {
670   ***      0                    0             0      my ( $self ) = @_;
671   ***      0                                  0      my $usage = $self->prompt() . "\n";
672   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
673   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
674                                                                 . "\n";
675                                                      }
676   ***      0                                  0      return $usage . "\n" . $self->descr();
677                                                   }
678                                                   
679                                                   sub print_usage {
680   ***      0                    0             0      my ( $self ) = @_;
681   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
682   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
683                                                   
684   ***      0      0                           0      my $maxl = max(
685   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
686                                                         @opts);
687                                                   
688   ***      0      0                           0      my $maxs = max(0,
689   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
690   ***      0                                  0         values %{$self->{short_opts}});
691                                                   
692   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
693   ***      0                                  0      my $rcol = 80 - $lcol - 6;
694   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
695                                                   
696   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
697                                                   
698   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
699                                                   
700   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
701   ***      0                                  0      push @groups, 'default';
702                                                   
703   ***      0                                  0      foreach my $group ( reverse @groups ) {
704   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
705   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
706   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
707                                                            grep { $_->{group} eq $group }
708                                                            @opts )
709                                                         {
710   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
711   ***      0                                  0            my $short = $opt->{short};
712   ***      0                                  0            my $desc  = $opt->{desc};
713   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
714   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
715   ***      0             0                    0               $s    ||= 's';
716   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
717   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
718                                                                      . "d=days; if no suffix, $s is used.";
719                                                            }
720   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
721   ***      0                                  0            $desc =~ s/ +$//mg;
722   ***      0      0                           0            if ( $short ) {
723   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
724                                                            }
725                                                            else {
726   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
727                                                            }
728                                                         }
729                                                      }
730                                                   
731   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
732   ***      0                                  0         $usage .= "\nRules:\n\n";
733   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
734                                                      }
735   ***      0      0                           0      if ( $self->{dp} ) {
736   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
737                                                      }
738   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
739   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
740   ***      0                                  0         my $val   = $opt->{value};
741   ***      0             0                    0         my $type  = $opt->{type} || '';
742   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
743   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
744                                                                   : !defined $val             ? '(No value)'
745                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
746                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
747                                                                   : $type =~ m/A|a/           ? join(',', @$val)
748                                                                   :                             $val;
749   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
750                                                      }
751   ***      0                                  0      return $usage;
752                                                   }
753                                                   
754                                                   sub prompt_noecho {
755   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
756   ***      0                                  0      my ( $prompt ) = @_;
757   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
758   ***      0      0                           0      print $prompt
759                                                         or die "Cannot print: $OS_ERROR";
760   ***      0                                  0      my $response;
761   ***      0                                  0      eval {
762   ***      0                                  0         require Term::ReadKey;
763   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
764   ***      0                                  0         chomp($response = <STDIN>);
765   ***      0                                  0         Term::ReadKey::ReadMode('normal');
766   ***      0      0                           0         print "\n"
767                                                            or die "Cannot print: $OS_ERROR";
768                                                      };
769   ***      0      0                           0      if ( $EVAL_ERROR ) {
770   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
771                                                      }
772   ***      0                                  0      return $response;
773                                                   }
774                                                   
775                                                   if ( MKDEBUG ) {
776                                                      print '# ', $^X, ' ', $], "\n";
777                                                      my $uname = `uname -a`;
778                                                      if ( $uname ) {
779                                                         $uname =~ s/\s+/ /g;
780                                                         print "# $uname\n";
781                                                      }
782                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
783                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
784                                                         ($main::SVN_REV || ''), __LINE__);
785                                                      print('# Arguments: ',
786                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
787                                                   }
788                                                   
789                                                   sub _read_config_file {
790            8                    8            56      my ( $self, $filename ) = @_;
791   ***      8     50                          44      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
792   ***      0                                  0      my @args;
793   ***      0                                  0      my $prefix = '--';
794   ***      0                                  0      my $parse  = 1;
795                                                   
796                                                      LINE:
797   ***      0                                  0      while ( my $line = <$fh> ) {
798   ***      0                                  0         chomp $line;
799   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
800   ***      0                                  0         $line =~ s/\s+#.*$//g;
801   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
802   ***      0      0                           0         if ( $line eq '--' ) {
803   ***      0                                  0            $prefix = '';
804   ***      0                                  0            $parse  = 0;
805   ***      0                                  0            next LINE;
806                                                         }
807   ***      0      0      0                    0         if ( $parse
      ***             0                               
808                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
809                                                         ) {
810   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
811                                                         }
812                                                         elsif ( $line =~ m/./ ) {
813   ***      0                                  0            push @args, $line;
814                                                         }
815                                                         else {
816   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
817                                                         }
818                                                      }
819   ***      0                                  0      close $fh;
820   ***      0                                  0      return @args;
821                                                   }
822                                                   
823                                                   sub read_para_after {
824   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
825   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
826   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
827   ***      0                                  0      my $para;
828   ***      0                                  0      while ( $para = <$fh> ) {
829   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
830   ***      0                                  0         last;
831                                                      }
832   ***      0                                  0      while ( $para = <$fh> ) {
833   ***      0      0                           0         next unless $para =~ m/$regex/;
834   ***      0                                  0         last;
835                                                      }
836   ***      0                                  0      $para = <$fh>;
837   ***      0                                  0      chomp($para);
838   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
839   ***      0                                  0      return $para;
840                                                   }
841                                                   
842                                                   sub clone {
843   ***      0                    0             0      my ( $self ) = @_;
844                                                   
845   ***      0                                  0      my %clone = map {
846   ***      0                                  0         my $hashref  = $self->{$_};
847   ***      0                                  0         my $val_copy = {};
848   ***      0                                  0         foreach my $key ( keys %$hashref ) {
849   ***      0                                  0            my $ref = ref $hashref->{$key};
850   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
851   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
852   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
853                                                                              : $hashref->{$key};
854                                                         }
855   ***      0                                  0         $_ => $val_copy;
856                                                      } qw(opts short_opts defaults);
857                                                   
858   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
859   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
860                                                      }
861                                                   
862   ***      0                                  0      return bless \%clone;     
863                                                   }
864                                                   
865                                                   sub _d {
866   ***      0                    0             0      my ($package, undef, $line) = caller 0;
867   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
868   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
869                                                           @_;
870   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
871                                                   }
872                                                   
873                                                   1;
874                                                   
875                                                   # ###########################################################################
876                                                   # End OptionParser package
877                                                   # ###########################################################################
878                                                   
879                                                   # ###########################################################################
880                                                   # VersionParser package 3186
881                                                   # ###########################################################################
882                                                   package VersionParser;
883                                                   
884            2                    2            28   use strict;
               2                                  4   
               2                                 16   
885            2                    2            12   use warnings FATAL => 'all';
               2                                  4   
               2                                 30   
886                                                   
887            2                    2            12   use English qw(-no_match_vars);
               2                                  4   
               2                                 14   
888                                                   
889            2                    2            12   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  4   
               2                                 18   
890                                                   
891                                                   sub new {
892            2                    2            14      my ( $class ) = @_;
893            2                                 56      bless {}, $class;
894                                                   }
895                                                   
896                                                   sub parse {
897   ***      0                    0             0      my ( $self, $str ) = @_;
898   ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
899   ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
900   ***      0                                  0      return $result;
901                                                   }
902                                                   
903                                                   sub version_ge {
904   ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
905   ***      0      0                           0      if ( !$self->{$dbh} ) {
906   ***      0                                  0         $self->{$dbh} = $self->parse(
907                                                            $dbh->selectrow_array('SELECT VERSION()'));
908                                                      }
909   ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
910   ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
911   ***      0                                  0      return $result;
912                                                   }
913                                                   
914                                                   sub _d {
915   ***      0                    0             0      my ($package, undef, $line) = caller 0;
916   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
917   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
918                                                           @_;
919   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
920                                                   }
921                                                   
922                                                   1;
923                                                   
924                                                   # ###########################################################################
925                                                   # End VersionParser package
926                                                   # ###########################################################################
927                                                   
928                                                   # ###########################################################################
929                                                   # DSNParser package 4103
930                                                   # ###########################################################################
931            2                    2            20   use strict;
               2                                  4   
               2                                 14   
932            2                    2            20   use warnings FATAL => 'all';
               2                                  6   
               2                                 12   
933                                                   
934                                                   package DSNParser;
935                                                   
936            2                    2            30   use DBI;
               2                                 10   
               2                                 20   
937            2                    2            16   use Data::Dumper;
               2                                  4   
               2                                 18   
938                                                   $Data::Dumper::Indent    = 0;
939                                                   $Data::Dumper::Quotekeys = 0;
940            2                    2            12   use English qw(-no_match_vars);
               2                                  4   
               2                                 16   
941                                                   
942            2                    2            12   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  4   
               2                                 22   
943                                                   
944                                                   sub new {
945            2                    2            18      my ( $class, @opts ) = @_;
946            2                                174      my $self = {
947                                                         opts => {
948                                                            A => {
949                                                               desc => 'Default character set',
950                                                               dsn  => 'charset',
951                                                               copy => 1,
952                                                            },
953                                                            D => {
954                                                               desc => 'Database to use',
955                                                               dsn  => 'database',
956                                                               copy => 1,
957                                                            },
958                                                            F => {
959                                                               desc => 'Only read default options from the given file',
960                                                               dsn  => 'mysql_read_default_file',
961                                                               copy => 1,
962                                                            },
963                                                            h => {
964                                                               desc => 'Connect to host',
965                                                               dsn  => 'host',
966                                                               copy => 1,
967                                                            },
968                                                            p => {
969                                                               desc => 'Password to use when connecting',
970                                                               dsn  => 'password',
971                                                               copy => 1,
972                                                            },
973                                                            P => {
974                                                               desc => 'Port number to use for connection',
975                                                               dsn  => 'port',
976                                                               copy => 1,
977                                                            },
978                                                            S => {
979                                                               desc => 'Socket file to use for connection',
980                                                               dsn  => 'mysql_socket',
981                                                               copy => 1,
982                                                            },
983                                                            u => {
984                                                               desc => 'User for login if not current user',
985                                                               dsn  => 'user',
986                                                               copy => 1,
987                                                            },
988                                                         },
989                                                      };
990            2                                 18      foreach my $opt ( @opts ) {
991   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
992   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
993                                                      }
994            2                                 58      return bless $self, $class;
995                                                   }
996                                                   
997                                                   sub prop {
998   ***      0                    0             0      my ( $self, $prop, $value ) = @_;
999   ***      0      0                           0      if ( @_ > 2 ) {
1000  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1001  ***      0                                  0         $self->{$prop} = $value;
1002                                                     }
1003  ***      0                                  0      return $self->{$prop};
1004                                                  }
1005                                                  
1006                                                  sub parse {
1007  ***      0                    0             0      my ( $self, $dsn, $prev, $defaults ) = @_;
1008  ***      0      0                           0      if ( !$dsn ) {
1009  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1010  ***      0                                  0         return;
1011                                                     }
1012  ***      0                                  0      MKDEBUG && _d('Parsing', $dsn);
1013  ***      0             0                    0      $prev     ||= {};
1014  ***      0             0                    0      $defaults ||= {};
1015  ***      0                                  0      my %given_props;
1016  ***      0                                  0      my %final_props;
1017  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1018                                                  
1019  ***      0                                  0      foreach my $dsn_part ( split(/,/, $dsn) ) {
1020  ***      0      0                           0         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1021  ***      0                                  0            $given_props{$prop_key} = $prop_val;
1022                                                        }
1023                                                        else {
1024  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1025  ***      0                                  0            $given_props{h} = $dsn_part;
1026                                                        }
1027                                                     }
1028                                                  
1029  ***      0                                  0      foreach my $key ( keys %opts ) {
1030  ***      0                                  0         MKDEBUG && _d('Finding value for', $key);
1031  ***      0                                  0         $final_props{$key} = $given_props{$key};
1032  ***      0      0      0                    0         if (   !defined $final_props{$key}
      ***                    0                        
1033                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1034                                                        {
1035  ***      0                                  0            $final_props{$key} = $prev->{$key};
1036  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1037                                                        }
1038  ***      0      0                           0         if ( !defined $final_props{$key} ) {
1039  ***      0                                  0            $final_props{$key} = $defaults->{$key};
1040  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1041                                                        }
1042                                                     }
1043                                                  
1044  ***      0                                  0      foreach my $key ( keys %given_props ) {
1045  ***      0      0                           0         die "Unrecognized DSN part '$key' in '$dsn'\n"
1046                                                           unless exists $opts{$key};
1047                                                     }
1048  ***      0      0                           0      if ( (my $required = $self->prop('required')) ) {
1049  ***      0                                  0         foreach my $key ( keys %$required ) {
1050  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1051                                                        }
1052                                                     }
1053                                                  
1054  ***      0                                  0      return \%final_props;
1055                                                  }
1056                                                  
1057                                                  sub parse_options {
1058  ***      0                    0             0      my ( $self, $o ) = @_;
1059  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1060  ***      0                                  0      my $dsn_string
1061                                                        = join(',',
1062  ***      0      0                           0             map  { "$_=".$o->get($_); }
1063  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1064  ***      0                                  0             keys %{$self->{opts}}
1065                                                          );
1066  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1067  ***      0                                  0      return $self->parse($dsn_string);
1068                                                  }
1069                                                  
1070                                                  sub as_string {
1071  ***      0                    0             0      my ( $self, $dsn ) = @_;
1072  ***      0      0                           0      return $dsn unless ref $dsn;
1073  ***      0      0                           0      return join(',',
1074  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1075  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1076                                                        sort keys %$dsn );
1077                                                  }
1078                                                  
1079                                                  sub usage {
1080  ***      0                    0             0      my ( $self ) = @_;
1081  ***      0                                  0      my $usage
1082                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1083                                                        . "  KEY  COPY  MEANING\n"
1084                                                        . "  ===  ====  =============================================\n";
1085  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1086  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1087  ***      0      0      0                    0         $usage .= "  $key    "
1088                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1089                                                               .  ($opts{$key}->{desc} || '[No description]')
1090                                                               . "\n";
1091                                                     }
1092  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1093  ***      0                                  0      return $usage;
1094                                                  }
1095                                                  
1096                                                  sub get_cxn_params {
1097  ***      0                    0             0      my ( $self, $info ) = @_;
1098  ***      0                                  0      my $dsn;
1099  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1100  ***      0             0                    0      my $driver = $self->prop('dbidriver') || '';
1101  ***      0      0                           0      if ( $driver eq 'Pg' ) {
1102  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1103  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1104  ***      0             0                    0                        grep { defined $info->{$_} }
1105                                                                       qw(h P));
1106                                                     }
1107                                                     else {
1108  ***      0                                  0         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1109  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1110  ***      0             0                    0                        grep { defined $info->{$_} }
1111                                                                       qw(F h P S A))
1112                                                           . ';mysql_read_default_group=client';
1113                                                     }
1114  ***      0                                  0      MKDEBUG && _d($dsn);
1115  ***      0                                  0      return ($dsn, $info->{u}, $info->{p});
1116                                                  }
1117                                                  
1118                                                  sub fill_in_dsn {
1119  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1120  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1121  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1122  ***      0                                  0      $user =~ s/@.*//;
1123  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1124  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1125  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1126  ***      0             0                    0      $dsn->{u} ||= $user;
1127  ***      0             0                    0      $dsn->{D} ||= $db;
1128                                                  }
1129                                                  
1130                                                  sub get_dbh {
1131  ***      0                    0             0      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1132  ***      0             0                    0      $opts ||= {};
1133  ***      0      0                           0      my $defaults = {
1134                                                        AutoCommit         => 0,
1135                                                        RaiseError         => 1,
1136                                                        PrintError         => 0,
1137                                                        ShowErrorStatement => 1,
1138                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1139                                                     };
1140  ***      0                                  0      @{$defaults}{ keys %$opts } = values %$opts;
      ***      0                                  0   
1141                                                  
1142  ***      0                                  0      my $dbh;
1143  ***      0                                  0      my $tries = 2;
1144  ***      0             0                    0      while ( !$dbh && $tries-- ) {
1145                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1146  ***      0                                  0            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1147                                                  
1148  ***      0                                  0         eval {
1149  ***      0                                  0            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1150                                                  
1151  ***      0      0                           0            if ( $cxn_string =~ m/mysql/i ) {
1152  ***      0                                  0               my $sql;
1153                                                  
1154  ***      0                                  0               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1155                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1156  ***      0                                  0               MKDEBUG && _d($dbh, ':', $sql);
1157  ***      0                                  0               $dbh->do($sql);
1158                                                  
1159  ***      0      0                           0               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1160  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1161  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1162  ***      0                                  0                  $dbh->do($sql);
1163  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1164  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1165  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1166                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1167                                                                 }
1168                                                                 else {
1169  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1170                                                                 }
1171                                                              }
1172                                                  
1173  ***      0      0                           0               if ( $self->prop('setvars') ) {
1174  ***      0                                  0                  $sql = "SET " . $self->prop('setvars');
1175  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1176  ***      0                                  0                  $dbh->do($sql);
1177                                                              }
1178                                                           }
1179                                                        };
1180  ***      0      0      0                    0         if ( !$dbh && $EVAL_ERROR ) {
1181  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1182  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
1183  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1184  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1185                                                           }
1186  ***      0      0                           0            if ( !$tries ) {
1187  ***      0                                  0               die $EVAL_ERROR;
1188                                                           }
1189                                                        }
1190                                                     }
1191                                                  
1192  ***      0                                  0      MKDEBUG && _d('DBH info: ',
1193                                                        $dbh,
1194                                                        Dumper($dbh->selectrow_hashref(
1195                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1196                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1197                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1198                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1199                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1200                                                        '$DBI::VERSION:',        $DBI::VERSION,
1201                                                     );
1202                                                  
1203  ***      0                                  0      return $dbh;
1204                                                  }
1205                                                  
1206                                                  sub get_hostname {
1207  ***      0                    0             0      my ( $self, $dbh ) = @_;
1208  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1209  ***      0                                  0         return $host;
1210                                                     }
1211  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1212                                                        'SELECT /*!50038 @@hostname, */ 1');
1213  ***      0                                  0      return $hostname;
1214                                                  }
1215                                                  
1216                                                  sub disconnect {
1217  ***      0                    0             0      my ( $self, $dbh ) = @_;
1218  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1219  ***      0                                  0      $dbh->disconnect;
1220                                                  }
1221                                                  
1222                                                  sub print_active_handles {
1223  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1224  ***      0             0                    0      $level ||= 0;
1225  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1226                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1227                                                        or die "Cannot print: $OS_ERROR";
1228  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1229  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1230                                                     }
1231                                                  }
1232                                                  
1233                                                  sub copy {
1234  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1235  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1236  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1237  ***      0                                  0      my %new_dsn = map {
1238  ***      0                                  0         my $key = $_;
1239  ***      0                                  0         my $val;
1240  ***      0      0                           0         if ( $args{overwrite} ) {
1241  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1242                                                        }
1243                                                        else {
1244  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1245                                                        }
1246  ***      0                                  0         $key => $val;
1247  ***      0                                  0      } keys %{$self->{opts}};
1248  ***      0                                  0      return \%new_dsn;
1249                                                  }
1250                                                  
1251                                                  sub _d {
1252  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1253  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1254  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1255                                                          @_;
1256  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1257                                                  }
1258                                                  
1259                                                  1;
1260                                                  
1261                                                  # ###########################################################################
1262                                                  # End DSNParser package
1263                                                  # ###########################################################################
1264                                                  
1265                                                  # ###########################################################################
1266                                                  # Daemon package 3976
1267                                                  # ###########################################################################
1268                                                  
1269                                                  package Daemon;
1270                                                  
1271           2                    2            20   use strict;
               2                                  6   
               2                                 16   
1272           2                    2            12   use warnings FATAL => 'all';
               2                                  4   
               2                                 18   
1273                                                  
1274           2                    2            34   use POSIX qw(setsid);
               2                                  6   
               2                                 14   
1275           2                    2            14   use English qw(-no_match_vars);
               2                                  6   
               2                                 26   
1276                                                  
1277           2                    2            14   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  4   
               2                                 18   
1278                                                  
1279                                                  sub new {
1280  ***      0                    0             0      my ( $class, %args ) = @_;
1281  ***      0                                  0      foreach my $arg ( qw(o) ) {
1282  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1283                                                     }
1284  ***      0                                  0      my $o = $args{o};
1285  ***      0      0                           0      my $self = {
      ***             0                               
1286                                                        o        => $o,
1287                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1288                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1289                                                     };
1290                                                  
1291  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1292                                                  
1293  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1294  ***      0                                  0      return bless $self, $class;
1295                                                  }
1296                                                  
1297                                                  sub daemonize {
1298  ***      0                    0             0      my ( $self ) = @_;
1299                                                  
1300  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1301  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1302  ***      0      0                           0      if ( $pid ) {
1303  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1304  ***      0                                  0         exit;
1305                                                     }
1306                                                  
1307  ***      0                                  0      $self->{child} = 1;
1308                                                  
1309  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1310  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1311                                                  
1312  ***      0                                  0      $self->_make_PID_file();
1313                                                  
1314  ***      0      0                           0      if ( -t STDIN ) {
1315  ***      0                                  0         close STDIN;
1316  ***      0      0                           0         open  STDIN, '/dev/null'
1317                                                           or die "Cannot reopen STDIN to /dev/null";
1318                                                     }
1319                                                  
1320  ***      0      0                           0      if ( $self->{log_file} ) {
1321  ***      0                                  0         close STDOUT;
1322  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1323                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1324                                                  
1325  ***      0                                  0         close STDERR;
1326  ***      0      0                           0         open  STDERR, ">&STDOUT"
1327                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR";
1328                                                     }
1329                                                  
1330  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1331  ***      0                                  0      return;
1332                                                  }
1333                                                  
1334                                                  sub check_PID_file {
1335  ***      0                    0             0      my ( $self, $file ) = @_;
1336  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1337  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1338  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1339  ***      0                                  0         my $pid;
1340  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1341  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1342  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1343  ***      0      0                           0         if ( $pid ) {
1344  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1345  ***      0      0                           0            if ( $pid_is_alive ) {
1346  ***      0                                  0               die "The PID file $PID_file already exists "
1347                                                                 . " and the PID that it contains, $pid, is running";
1348                                                           }
1349                                                           else {
1350  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1351                                                                 . "contains, $pid, is not running";
1352                                                           }
1353                                                        }
1354                                                        else {
1355  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1356                                                              . "contain a PID";
1357                                                        }
1358                                                     }
1359                                                     else {
1360  ***      0                                  0         MKDEBUG && _d('No PID file');
1361                                                     }
1362  ***      0                                  0      return;
1363                                                  }
1364                                                  
1365                                                  sub make_PID_file {
1366  ***      0                    0             0      my ( $self ) = @_;
1367  ***      0      0                           0      if ( exists $self->{child} ) {
1368  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1369                                                     }
1370  ***      0                                  0      $self->_make_PID_file();
1371  ***      0                                  0      $self->{rm_PID_file} = 1;
1372  ***      0                                  0      return;
1373                                                  }
1374                                                  
1375                                                  sub _make_PID_file {
1376  ***      0                    0             0      my ( $self ) = @_;
1377                                                  
1378  ***      0                                  0      my $PID_file = $self->{PID_file};
1379  ***      0      0                           0      if ( !$PID_file ) {
1380  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1381  ***      0                                  0         return;
1382                                                     }
1383                                                  
1384  ***      0                                  0      $self->check_PID_file();
1385                                                  
1386  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1387                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1388  ***      0      0                           0      print $PID_FH $PID
1389                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1390  ***      0      0                           0      close $PID_FH
1391                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1392                                                  
1393  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1394  ***      0                                  0      return;
1395                                                  }
1396                                                  
1397                                                  sub _remove_PID_file {
1398  ***      0                    0             0      my ( $self ) = @_;
1399  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1400  ***      0      0                           0         unlink $self->{PID_file}
1401                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1402  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1403                                                     }
1404                                                     else {
1405  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1406                                                     }
1407  ***      0                                  0      return;
1408                                                  }
1409                                                  
1410                                                  sub DESTROY {
1411  ***      0                    0             0      my ( $self ) = @_;
1412  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1413  ***      0                                  0      return;
1414                                                  }
1415                                                  
1416                                                  sub _d {
1417  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1418  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1419  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1420                                                          @_;
1421  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1422                                                  }
1423                                                  
1424                                                  1;
1425                                                  
1426                                                  # ###########################################################################
1427                                                  # End Daemon package
1428                                                  # ###########################################################################
1429                                                  
1430                                                  # ###########################################################################
1431                                                  # Transformers package 3972
1432                                                  # ###########################################################################
1433                                                  
1434                                                  package Transformers;
1435                                                  
1436           2                    2            18   use strict;
               2                                  6   
               2                                 14   
1437           2                    2            12   use warnings FATAL => 'all';
               2                                  6   
               2                                 12   
1438           2                    2            12   use English qw(-no_match_vars);
               2                                  6   
               2                                 10   
1439           2                    2            36   use Time::Local qw(timelocal);
               2                                  8   
               2                                 24   
1440           2                    2            14   use Digest::MD5 qw(md5_hex);
               2                                  4   
               2                                 18   
1441                                                  
1442           2                    2            12   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  6   
               2                                 16   
1443                                                  
1444                                                  require Exporter;
1445                                                  our @ISA         = qw(Exporter);
1446                                                  our %EXPORT_TAGS = ();
1447                                                  our @EXPORT      = ();
1448                                                  our @EXPORT_OK   = qw(
1449                                                     micro_t
1450                                                     percentage_of
1451                                                     secs_to_time
1452                                                     shorten
1453                                                     ts
1454                                                     parse_timestamp
1455                                                     unix_timestamp
1456                                                     make_checksum
1457                                                  );
1458                                                  
1459                                                  sub micro_t {
1460  ***      0                    0             0      my ( $t, %args ) = @_;
1461  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1462  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1463  ***      0                                  0      my $f;
1464                                                  
1465  ***      0      0                           0      $t = 0 if $t < 0;
1466                                                  
1467  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1468                                                  
1469  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1470                                                  
1471  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1472  ***      0                                  0         $f = ($t * 1000000) . 'us';
1473                                                     }
1474                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1475  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1476  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1477                                                     }
1478                                                     elsif ($t >= 1) {
1479  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1480  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1481                                                     }
1482                                                     else {
1483  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1484                                                     }
1485                                                  
1486  ***      0                                  0      return $f;
1487                                                  }
1488                                                  
1489                                                  sub percentage_of {
1490  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1491  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1492  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1493  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1494                                                  }
1495                                                  
1496                                                  sub secs_to_time {
1497  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1498  ***      0             0                    0      $secs ||= 0;
1499  ***      0      0                           0      return '00:00' unless $secs;
1500                                                  
1501  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1502                                                            : $secs >= 3_600  ? 'h'
1503                                                            :                   'm';
1504                                                  
1505                                                     return
1506  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1507                                                           "%d+%02d:%02d:%02d",
1508                                                           int($secs / 86_400),
1509                                                           int(($secs % 86_400) / 3_600),
1510                                                           int(($secs % 3_600) / 60),
1511                                                           $secs % 60)
1512                                                        : $fmt eq 'h' ? sprintf(
1513                                                           "%02d:%02d:%02d",
1514                                                           int(($secs % 86_400) / 3_600),
1515                                                           int(($secs % 3_600) / 60),
1516                                                           $secs % 60)
1517                                                        : sprintf(
1518                                                           "%02d:%02d",
1519                                                           int(($secs % 3_600) / 60),
1520                                                           $secs % 60);
1521                                                  }
1522                                                  
1523                                                  sub shorten {
1524  ***      0                    0             0      my ( $num, %args ) = @_;
1525  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1526  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1527  ***      0                                  0      my $n = 0;
1528  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1529  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1530  ***      0                                  0         $num /= $d;
1531  ***      0                                  0         ++$n;
1532                                                     }
1533  ***      0      0      0                    0      return sprintf(
1534                                                        $num =~ m/\./ || $n
1535                                                           ? "%.${p}f%s"
1536                                                           : '%d',
1537                                                        $num, $units[$n]);
1538                                                  }
1539                                                  
1540                                                  sub ts {
1541  ***      0                    0             0      my ( $time ) = @_;
1542  ***      0                                  0      my ( $sec, $min, $hour, $mday, $mon, $year )
1543                                                        = localtime($time);
1544  ***      0                                  0      $mon  += 1;
1545  ***      0                                  0      $year += 1900;
1546  ***      0                                  0      return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1547                                                        $year, $mon, $mday, $hour, $min, $sec);
1548                                                  }
1549                                                  
1550                                                  sub parse_timestamp {
1551  ***      0                    0             0      my ( $val ) = @_;
1552  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
1553                                                           = $val =~ m/^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?$/ )
1554                                                     {
1555  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1556                                                                       . (defined $f ? '%02.6f' : '%02d'),
1557                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1558                                                     }
1559  ***      0                                  0      return $val;
1560                                                  }
1561                                                  
1562                                                  sub unix_timestamp {
1563  ***      0                    0             0      my ( $val ) = @_;
1564  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s)
1565                                                       = $val =~ m/^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.\d+)?$/ )
1566                                                     {
1567  ***      0                                  0         return timelocal($s, $i, $h, $d, $m - 1, $y);
1568                                                     }
1569  ***      0                                  0      return $val;
1570                                                  }
1571                                                  
1572                                                  sub make_checksum {
1573  ***      0                    0             0      my ( $val ) = @_;
1574  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1575  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1576  ***      0                                  0      return $checksum;
1577                                                  }
1578                                                  
1579                                                  sub _d {
1580  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1581  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1582  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1583                                                          @_;
1584  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1585                                                  }
1586                                                  
1587                                                  1;
1588                                                  
1589                                                  # ###########################################################################
1590                                                  # End Transformers package
1591                                                  # ###########################################################################
1592                                                  
1593                                                  # ###########################################################################
1594                                                  # Processlist package 4172
1595                                                  # ###########################################################################
1596                                                  package Processlist;
1597                                                  
1598           2                    2            14   use strict;
               2                                  4   
               2                                 14   
1599           2                    2            12   use warnings FATAL => 'all';
               2                                  4   
               2                                 12   
1600           2                    2            12   use English qw(-no_match_vars);
               2                                  4   
               2                                 12   
1601                                                  
1602           2                    2            14   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  6   
               2                                 14   
1603                                                  use constant {
1604           2                                 38      ID      => 0,
1605                                                     USER    => 1,
1606                                                     HOST    => 2,
1607                                                     DB      => 3,
1608                                                     COMMAND => 4,
1609                                                     TIME    => 5,
1610                                                     STATE   => 6,
1611                                                     INFO    => 7,
1612                                                     START   => 8, # Calculated start time of statement
1613                                                     ETIME   => 9, # Exec time of SHOW PROCESSLIST (margin of error in START)
1614                                                     FSEEN   => 10, # First time ever seen
1615           2                    2            12   };
               2                                  4   
1616                                                  
1617                                                  sub new {
1618           2                    2            14      my ( $class ) = @_;
1619           2                                 82      bless {}, $class;
1620                                                  }
1621                                                  
1622                                                  sub parse_event {
1623  ***      0                    0             0      my ( $self, $code, $misc, @callbacks ) = @_;
1624  ***      0                                  0      my $num_events = 0;
1625                                                  
1626  ***      0                                  0      my @curr = sort { $a->[ID] <=> $b->[ID] } @{$code->()};
      ***      0                                  0   
      ***      0                                  0   
1627  ***      0             0                    0      my @prev = @{$misc->{prev} ||= []};
      ***      0                                  0   
1628  ***      0                                  0      my @new; # Will become next invocation's @prev
1629  ***      0                                  0      my ($curr, $prev); # Rows from each source
1630                                                  
1631  ***      0             0                    0      do {
      ***                    0                        
      ***                    0                        
1632  ***      0      0      0                    0         if ( !$curr && @curr ) {
1633  ***      0                                  0            MKDEBUG && _d('Fetching row from curr');
1634  ***      0                                  0            $curr = shift @curr;
1635                                                        }
1636  ***      0      0      0                    0         if ( !$prev && @prev ) {
1637  ***      0                                  0            MKDEBUG && _d('Fetching row from prev');
1638  ***      0                                  0            $prev = shift @prev;
1639                                                        }
1640  ***      0      0      0                    0         if ( $curr || $prev ) {
1641  ***      0      0      0                    0            if ( $curr && $prev && $curr->[ID] == $prev->[ID] ) {
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
1642  ***      0                                  0               MKDEBUG && _d('$curr and $prev are the same cxn');
1643  ***      0      0                           0               my $fudge = $curr->[TIME] =~ m/\D/ ? 0.001 : 1; # Micro-precision?
1644  ***      0                                  0               my $is_new = 0;
1645  ***      0      0                           0               if ( $prev->[INFO] ) {
1646  ***      0      0      0                    0                  if (!$curr->[INFO] || $prev->[INFO] ne $curr->[INFO]) {
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
1647  ***      0                                  0                     MKDEBUG && _d('$curr has a new query');
1648  ***      0                                  0                     $is_new = 1;
1649                                                                 }
1650                                                                 elsif (defined $curr->[TIME] && $curr->[TIME] < $prev->[TIME]) {
1651  ***      0                                  0                     MKDEBUG && _d('$curr time is less than $prev time');
1652  ***      0                                  0                     $is_new = 1;
1653                                                                 }
1654                                                                 elsif ( $curr->[INFO] && defined $curr->[TIME]
1655                                                                    && $misc->{time} - $curr->[TIME] - $prev->[START]
1656                                                                       - $prev->[ETIME] - $misc->{etime} > $fudge
1657                                                                 ) {
1658  ***      0                                  0                     MKDEBUG && _d('$curr has same query that restarted');
1659  ***      0                                  0                     $is_new = 1;
1660                                                                 }
1661  ***      0      0                           0                  if ( $is_new ) {
1662  ***      0                                  0                     fire_event( $prev, $misc->{time}, @callbacks );
1663                                                                 }
1664                                                              }
1665  ***      0      0                           0               if ( $curr->[INFO] ) {
1666  ***      0      0      0                    0                  if ( $prev->[INFO] && !$is_new ) {
1667  ***      0                                  0                     MKDEBUG && _d('Pushing old history item back onto $prev');
1668  ***      0                                  0                     push @new, [ @$prev ];
1669                                                                 }
1670                                                                 else {
1671  ***      0                                  0                     MKDEBUG && _d('Pushing new history item onto $prev');
1672  ***      0                                  0                     push @new,
1673                                                                       [ @$curr, int($misc->{time} - $curr->[TIME]),
1674                                                                          $misc->{etime}, $misc->{time} ];
1675                                                                 }
1676                                                              }
1677  ***      0                                  0               $curr = $prev = undef; # Fetch another from each.
1678                                                           }
1679                                                           elsif ( !$curr
1680                                                                 || ( $curr && $prev && $curr->[ID] > $prev->[ID] )) {
1681  ***      0                                  0               MKDEBUG && _d('$curr is not in $prev');
1682  ***      0                                  0               fire_event( $prev, $misc->{time}, @callbacks );
1683  ***      0                                  0               $prev = undef;
1684                                                           }
1685                                                           else { # This else must be entered, to prevent infinite loops.
1686  ***      0                                  0               MKDEBUG && _d('$prev is not in $curr');
1687  ***      0      0      0                    0               if ( $curr->[INFO] && defined $curr->[TIME] ) {
1688  ***      0                                  0                  MKDEBUG && _d('Pushing new history item onto $prev');
1689  ***      0                                  0                  push @new,
1690                                                                    [ @$curr, int($misc->{time} - $curr->[TIME]),
1691                                                                       $misc->{etime}, $misc->{time} ];
1692                                                              }
1693  ***      0                                  0               $curr = undef; # No infinite loops.
1694                                                           }
1695                                                        }
1696                                                     } while ( @curr || @prev || $curr || $prev );
1697                                                  
1698  ***      0                                  0      @{$misc->{prev}} = @new;
      ***      0                                  0   
1699                                                  
1700  ***      0                                  0      return $num_events;
1701                                                  }
1702                                                  
1703                                                  sub fire_event {
1704  ***      0                    0             0      my ( $row, $time, @callbacks ) = @_;
1705  ***      0                                  0      my $Query_time = $row->[TIME];
1706  ***      0      0                           0      if ( $row->[TIME] < $time - $row->[FSEEN] ) {
1707  ***      0                                  0         $Query_time = $time - $row->[FSEEN];
1708                                                     }
1709  ***      0                                  0      my $event = {
1710                                                        id         => $row->[ID],
1711                                                        db         => $row->[DB],
1712                                                        user       => $row->[USER],
1713                                                        host       => $row->[HOST],
1714                                                        arg        => $row->[INFO],
1715                                                        bytes      => length($row->[INFO]),
1716                                                        ts         => $row->[START] + $row->[TIME], # Query END time
1717                                                        Query_time => $Query_time,
1718                                                        Lock_time  => 0,               # TODO
1719                                                     };
1720  ***      0                                  0      foreach my $callback ( @callbacks ) {
1721  ***      0      0                           0         last unless $event = $callback->($event);
1722                                                     }
1723                                                  }
1724                                                  
1725                                                  sub find {
1726           2                    2            22      my ( $self, $proclist, %find_spec ) = @_;
1727           2                                 12      my @matches;
1728                                                     QUERY:
1729           2                                 18      foreach my $query ( @$proclist ) {
1730           2                                 10         my $matched = 0;
1731  ***      2     50      0                   32         if ( $find_spec{busy_time} && ($query->{Command} || '') eq 'Query' ) {
      ***                   33                        
1732  ***      0      0                           0            if ( $query->{Time} < $find_spec{busy_time} ) {
1733  ***      0                                  0               MKDEBUG && _d("Query isn't running long enough");
1734  ***      0                                  0               next QUERY;
1735                                                           }
1736  ***      0                                  0            $matched++;
1737                                                        }
1738                                                        PROPERTY:
1739           2                                 16         foreach my $property ( qw(Id User Host db State Command Info) ) {
1740          14                                 72            my $filter = "_find_match_$property";
1741  ***     14     50     66                  202            if ( defined $find_spec{ignore}->{$property}
1742                                                              && $self->$filter($query, $find_spec{ignore}->{$property})
1743                                                           ) {
1744  ***      0                                  0               MKDEBUG && _d("Query matches 'ignore' filter on $property, skipping");
1745  ***      0                                  0               next QUERY;
1746                                                           }
1747          14    100                         126            if ( defined $find_spec{match}->{$property} ) {
1748  ***      2     50                          18               if ( !$self->$filter($query, $find_spec{match}->{$property}) ) {
1749  ***      0                                  0                  MKDEBUG && _d("Query doesn't match 'match' filter on $property, skipping");
1750  ***      0                                  0                  next QUERY;
1751                                                              }
1752           2                                 12               $matched++;
1753                                                           }
1754                                                        }
1755  ***      2     50                          14         if ( $matched ) {
1756           2                                  8            MKDEBUG && _d("Query passed all defined filters, adding");
1757           2                                 14            push @matches, $query;
1758                                                        }
1759                                                     }
1760  ***      2     50     33                   68      if ( @matches && $find_spec{only_oldest} ) {
1761           2                                 20         my ( $oldest ) = reverse sort { $a->{Time} <=> $b->{Time} } @matches;
      ***      0                                  0   
1762           2                                 26         @matches = $oldest;
1763                                                     }
1764           2                                 16      return @matches;
1765                                                  }
1766                                                  
1767                                                  sub _find_match_Id {
1768  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1769  ***      0             0                    0      return defined $property && defined $query->{Id} && $query->{Id} == $property;
      ***                    0                        
1770                                                  }
1771                                                  
1772                                                  sub _find_match_User {
1773           2                    2            16      my ( $self, $query, $property ) = @_;
1774  ***      2            33                  132      return defined $property && defined $query->{User}
      ***                   33                        
1775                                                        && $query->{User} =~ m/$property/;
1776                                                  }
1777                                                  
1778                                                  sub _find_match_Host {
1779  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1780  ***      0             0                    0      return defined $property && defined $query->{Host}
      ***                    0                        
1781                                                        && $query->{Host} =~ m/$property/;
1782                                                  }
1783                                                  
1784                                                  sub _find_match_db {
1785  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1786  ***      0             0                    0      return defined $property && defined $query->{db}
      ***                    0                        
1787                                                        && $query->{db} =~ m/$property/;
1788                                                  }
1789                                                  
1790                                                  sub _find_match_State {
1791           2                    2            16      my ( $self, $query, $property ) = @_;
1792  ***      2            33                  108      return defined $property && defined $query->{State}
      ***                   33                        
1793                                                        && $query->{State} =~ m/$property/;
1794                                                  }
1795                                                  
1796                                                  sub _find_match_Command {
1797           4                    4            30      my ( $self, $query, $property ) = @_;
1798  ***      4            33                  180      return defined $property && defined $query->{Command}
      ***                   66                        
1799                                                        && $query->{Command} =~ m/$property/;
1800                                                  }
1801                                                  
1802                                                  sub _find_match_Info {
1803  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1804  ***      0             0                    0      return defined $property && defined $query->{Info}
      ***                    0                        
1805                                                        && $query->{Info} =~ m/$property/;
1806                                                  }
1807                                                  
1808                                                  sub _d {
1809  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1810  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1811  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1812                                                          @_;
1813  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1814                                                  }
1815                                                  
1816                                                  1;
1817                                                  
1818                                                  # ###########################################################################
1819                                                  # End Processlist package
1820                                                  # ###########################################################################
1821                                                  
1822                                                  # ###########################################################################
1823                                                  # TextResultSetParser package 4176
1824                                                  # ###########################################################################
1825                                                  package TextResultSetParser;
1826                                                  
1827                                                  
1828           2                    2            14   use strict;
               2                                  4   
               2                                 12   
1829           2                    2            12   use warnings FATAL => 'all';
               2                                 10   
               2                                 12   
1830           2                    2            10   use English qw(-no_match_vars);
               2                                  6   
               2                                 10   
1831                                                  
1832           2                    2            14   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  6   
               2                                 16   
1833                                                  
1834                                                  sub new {
1835           2                    2            18      my ( $class, %args ) = @_;
1836           2                                 14      my $self = { %args };
1837           2                                 54      return bless $self, $class;
1838                                                  }
1839                                                  
1840                                                  sub parse_tabular {
1841           4                    4            38      my ( $text, @cols ) = @_;
1842           4                                 16      my %row;
1843           4                                126      my @vals = $text =~ m/\| +([^\|]*?)(?= +\|)/msg;
1844           4    100                          48      return (undef, \@vals) unless @cols;
1845           2                                 34      @row{@cols} = @vals;
1846           2                                 20      return (\%row, undef);
1847                                                  }
1848                                                  
1849                                                  sub parse_tab_sep {
1850  ***      0                    0             0      my ( $text, @cols ) = @_;
1851  ***      0                                  0      my %row;
1852  ***      0                                  0      my @vals = split(/\t/, $text);
1853  ***      0      0                           0      return (undef, \@vals) unless @cols;
1854  ***      0                                  0      @row{@cols} = @vals;
1855  ***      0                                  0      return (\%row, undef);
1856                                                  }
1857                                                  
1858                                                  sub parse_vertical {
1859  ***      0                    0             0      my ( $text ) = @_;
1860  ***      0                                  0      my %row = $text =~ m/^\s*(\w+): ([^\n]*)/msg;
1861  ***      0                                  0      return \%row;
1862                                                  }
1863                                                  
1864                                                  sub parse {
1865           2                    2            16      my ( $self, $text ) = @_;
1866           2                                 10      my $result_set;
1867                                                  
1868  ***      2     50                          36      if ( $text =~ m/^\+---/m ) { # standard "tabular" output
      ***             0                               
      ***             0                               
1869           2                                  8         MKDEBUG && _d('text type: standard tabular');
1870           2                                 24         my $line_pattern  = qr/^(\| .*)[\r\n]+/m;
1871           2                                 30         $result_set
1872                                                           = _parse_horizontal_result_set($text, $line_pattern, \&parse_tabular);
1873                                                     }
1874                                                     elsif ( $text =~ m/^id\tselect_type\t/m ) { # tab-separated
1875  ***      0                                  0         MKDEBUG && _d('text type: tab-separated');
1876  ***      0                                  0         my $line_pattern  = qr/^(.*?\t.*)[\r\n]+/m;
1877  ***      0                                  0         $result_set
1878                                                           = _parse_horizontal_result_set($text, $line_pattern, \&parse_tab_sep);
1879                                                     }
1880                                                     elsif ( $text =~ m/\*\*\* \d+\. row/ ) { # "vertical" output
1881  ***      0                                  0         my $n_recs;
1882  ***      0                                  0         $n_recs++ while $text =~ m/ \d+\. row /g;
1883  ***      0                                  0         MKDEBUG && _d('text-type: vertical,', $n_recs, 'n_recs');
1884  ***      0      0                           0         if ( $n_recs > 1 ) {
1885  ***      0                                  0            MKDEBUG && _d('Multiple result sets');
1886  ***      0                                  0            my @v_result_sets;
1887  ***      0                                  0            my $v_result_set = _split_vertical_result_sets($text);
1888  ***      0                                  0            foreach my $v_result_set ( @$v_result_set ) {
1889  ***      0                                  0               push @v_result_sets, $self->parse($v_result_set);
1890                                                           }
1891  ***      0                                  0            return \@v_result_sets;
1892                                                        }
1893  ***      0                                  0         $result_set = _parse_vertical_result_set($text, \&parse_vertical);
1894                                                     }
1895                                                     else {
1896  ***      0                                  0         die "Cannot determine if text is tabular, tab-separated or veritcal:\n"
1897                                                           . $text;
1898                                                     }
1899                                                  
1900  ***      2     50                          18      if ( $self->{value_for} ) {
1901  ***      0                                  0         foreach my $result_set ( @$result_set ) {
1902  ***      0                                  0            foreach my $key ( keys %$result_set ) {
1903  ***      0      0                           0               $result_set->{$key} = $self->{value_for}->{ $result_set->{$key} }
1904                                                                 if exists $self->{value_for}->{ $result_set->{$key} };
1905                                                           }
1906                                                        }
1907                                                     }
1908                                                  
1909           2                                 20      return $result_set;
1910                                                  }
1911                                                  
1912                                                  sub _parse_horizontal_result_set {
1913           2                    2            20      my ( $text, $line_pattern, $sub ) = @_;
1914           2                                 12      my @result_sets = ();
1915           2                                 10      my @cols        = ();
1916           2                                 46      foreach my $line ( $text =~ m/$line_pattern/g ) {
1917           4                                 32         my ( $row, $cols ) = $sub->($line, @cols);
1918           4    100                          24         if ( $row ) {
1919           2                                 16            push @result_sets, $row;
1920                                                        }
1921                                                        else {
1922           2                                 44            @cols = @$cols;
1923                                                        }
1924                                                     }
1925           2                                 28      return \@result_sets;
1926                                                  }
1927                                                  
1928                                                  sub _parse_vertical_result_set {
1929  ***      0                    0             0      my ( $text, $sub ) = @_;
1930  ***      0                                  0      return $sub->($text);
1931                                                  }
1932                                                  
1933                                                  sub _split_vertical_result_sets {
1934  ***      0                    0             0      my ( $text ) = @_;
1935  ***      0                                  0      my $ROW_HEADER = '\*{3,} \d+\. row \*{3,}';
1936  ***      0                                  0      my @result_sets = $text =~ m/($ROW_HEADER.*?)(?=$ROW_HEADER|\z)/omgs;
1937  ***      0                                  0      return \@result_sets;
1938                                                  }
1939                                                  
1940                                                  sub _d {
1941  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1942  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1943  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1944                                                          @_;
1945  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1946                                                  }
1947                                                  
1948                                                  1;
1949                                                  
1950                                                  # ###########################################################################
1951                                                  # End TextResultSetParser package
1952                                                  # ###########################################################################
1953                                                  
1954                                                  # ###########################################################################
1955                                                  # This is a combination of modules and programs in one -- a runnable module.
1956                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1957                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1958                                                  #
1959                                                  # Check at the end of this package for the call to main() which actually runs
1960                                                  # the program.
1961                                                  # ###########################################################################
1962                                                  package mk_kill;
1963                                                  
1964           2                    2            14   use English qw(-no_match_vars);
               2                                  4   
               2                                 10   
1965           2                    2            14   use POSIX qw(setsid);
               2                                  4   
               2                                 14   
1966           2                    2            12   use List::Util qw(max);
               2                                  6   
               2                                 22   
1967                                                  
1968                                                  Transformers->import qw(ts);
1969                                                  
1970           2                    2            12   use constant MKDEBUG => $ENV{MKDEBUG};
               2                                  4   
               2                                 12   
1971                                                  
1972                                                  my $o;
1973                                                  my $dp;
1974                                                  
1975                                                  # ########################################################################
1976                                                  # Configuration info.
1977                                                  # ########################################################################
1978                                                  
1979                                                  sub main {
1980           2                    2           126      @ARGV = @_;  # set global ARGV for this package
1981                                                  
1982           2                                 60      my $pl = new Processlist();
1983           2                                 56      my $vp = new VersionParser();
1984           2                                 48      $dp    = new DSNParser();
1985                                                  
1986                                                     # ########################################################################
1987                                                     # Get configuration information.
1988                                                     # ########################################################################
1989           2                                 60      $o = new OptionParser(
1990                                                        description => q{kills, prints or executes another script for queries }
1991                                                                     . q{in MySQL that match certain criteria.  }
1992                                                                     . q{If FILE is not given, mk-kill executes SHOW PROCESSLIST }
1993                                                                     . q{on MySQL to get queries.  Else, mk-kill will get }
1994                                                                     . q{queries from FILE which should contain the output of }
1995                                                                     . q{SHOW PROCESSLIST.  If FILE is -, mk-kill reads from }
1996                                                                     . q{STDIN.},
1997                                                        prompt      => '[OPTION]... [FILE...]',
1998                                                        strict      => 0,
1999                                                     );
2000           2                                 20      $o->get_specs();
2001           2                                 38      $o->get_opts();
2002                                                  
2003  ***      2     50                          16      if ( !$o->got('busy-time') ) {
2004  ***      2     50                          14         $o->set('interval', 30) unless $o->got('interval');
2005                                                     }
2006                                                     else {
2007  ***      0      0                           0         $o->set('interval', max(1, $o->get('busy-time') / 2))
2008                                                           unless $o->got('interval');
2009                                                     }
2010                                                  
2011                                                     # If parsing files, then don't wait.
2012  ***      2     50                          24      if ( @ARGV ) {
2013           2                                 12         $o->set('interval', 0);
2014                                                     }
2015                                                  
2016           2                                 32      $o->usage_or_errors();
2017                                                  
2018                                                     # ########################################################################
2019                                                     # Connect to MySQL if not reading files.
2020                                                     # ########################################################################
2021           2                                  6      my $dsn;
2022           2                                  8      my $dbh;
2023           2                                  6      my $kill_sth;
2024  ***      2     50                          26      if ( !@ARGV ) {
2025  ***      0                                  0         $dsn      = $dp->parse_options($o);
2026  ***      0                                  0         $dbh      = get_cxn($dsn, 1); 
2027  ***      0                                  0         $kill_sth = $dbh->prepare('KILL ?');
2028                                                     }
2029                                                  
2030                                                     # ########################################################################
2031                                                     # Make input sub that will either get processlist from MySQL or a file.
2032                                                     # ########################################################################
2033           2                                  8      my $get_proclist;
2034  ***      2     50                          12      if ( @ARGV ) {
2035           2                                  8         MKDEBUG && _d('Getting processlist from files:', @ARGV);
2036           2                                 54         my $trp = new TextResultSetParser();
2037           2                                  8         my $fh;
2038                                                        $get_proclist = sub {
2039  ***      2     50             2            28            if ( !$fh ) {
2040           2                                 10               my $file = shift @ARGV;
2041  ***      2     50                          34               die 'No more files' unless $file;
2042  ***      2     50                          16               if ( $file eq '-' ) {
2043  ***      0                                  0                  $fh = *STDIN;
2044                                                              }
2045                                                              else {
2046  ***      2     50                         138                  if ( !open $fh, '<', $file ) {
2047  ***      0                                  0                     warn "Cannot open $file: $OS_ERROR";
2048  ***      0                                  0                     $fh = undef;
2049  ***      0                                  0                     return;
2050                                                                 }
2051                                                              }
2052                                                           }
2053                                                  
2054  ***      2     50                          14            if ( $fh ) {
2055           2                                 22               local $INPUT_RECORD_SEPARATOR = '';
2056           2                                 70               my $proclist_text = <$fh>;
2057  ***      2     50                          54               if ( $proclist_text ) {
2058           2                                 24                  return $trp->parse($proclist_text);
2059                                                              }
2060                                                              else {
2061                                                                 # No more proclists in this file.
2062  ***      0                                  0                  $fh = undef;
2063                                                              }
2064                                                           }
2065                                                  
2066  ***      0                                  0            return;
2067           2                                 42         };
2068                                                     }
2069                                                     else {
2070  ***      0                                  0         MKDEBUG && _d('Getting processlist from MySQL');
2071  ***      0                                  0         my $proc_sth = $dbh->prepare('SHOW FULL PROCESSLIST');
2072                                                        $get_proclist = sub {
2073  ***      0                    0             0            $proc_sth->execute();
2074  ***      0                                  0            return $proc_sth->fetchall_arrayref({});
2075  ***      0                                  0         };
2076                                                     }
2077                                                  
2078                                                     # ########################################################################
2079                                                     # Daemonize only after (potentially) asking for passwords for --ask-pass.
2080                                                     # ########################################################################
2081           2                                 10      my $daemon;
2082  ***      2     50                          16      if ( $o->get('daemonize') ) {
2083  ***      0                                  0         $daemon = new Daemon(o=>$o);
2084  ***      0                                  0         $daemon->daemonize();
2085  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
2086                                                     }
2087                                                  
2088                                                     # ########################################################################
2089                                                     # Start working.
2090                                                     # ########################################################################
2091           2                                 16      my $start    = time();
2092  ***      2            50                   14      my $end      = $start + ($o->get('run-time') || 0); # When we should exit
2093           2                                 10      my $now      = $start;
2094                                                  
2095  ***      2     50                          14      my %find_spec = (
2096                                                        only_oldest  => $o->get('only-oldest'),
2097                                                        busy_time    => $o->get('busy-time'),
2098                                                        ignore => {
2099                                                           Id       => $o->get('ignore-self') ? $dbh->{mysql_thread_id} : undef,
2100                                                           User     => $o->get('ignore-user'),
2101                                                           Command  => $o->get('ignore-command'),
2102                                                           State    => $o->get('ignore-state'),
2103                                                        },
2104                                                        match => {
2105                                                           Command  => $o->get('match-command'),
2106                                                           Info     => $o->get('match-info'),
2107                                                           State    => $o->get('match-state'),
2108                                                        },
2109                                                     );
2110                                                  
2111           2                                 14      my $iters_done = 0;
2112           2                                 12      my $iters_todo = $o->get('iterations');
2113  ***      2            33                   86      while (                                              # Quit if:
      ***                   66                        
      ***                   66                        
2114                                                        ($start == $end || $now < $end)                   # time is exceeded
2115                                                        && (!$iters_todo || $iters_done++ < $iters_todo ) # or iterations exceeded
2116                                                     ) {
2117           2                                  6         my $proclist;
2118           2                                 10         eval { $proclist = $get_proclist->(); };
               2                                 12   
2119  ***      2     50                          14         if ( $EVAL_ERROR ) {
2120  ***      0      0                           0            last if $EVAL_ERROR =~ m/No more files/;
2121  ***      0                                  0            die "Error getting SHOW PROCESSLIST: $EVAL_ERROR";
2122                                                        }
2123                                                  
2124           2                                  8         my @queries;
2125  ***      2     50                          12         if ( $proclist ) {
2126           2                                 38            @queries = $pl->find($proclist, %find_spec);
2127                                                           MATCHING_QUERY:
2128           2                                 12            foreach my $query ( @queries ) {
2129  ***      2     50                          16               if ( $o->get('print') ) {
2130  ***      0             0                    0                  printf "# %s KILL %d (%s %d sec) %s\n",
      ***                    0                        
2131                                                                    ts(time), $query->{Id}, ($query->{Command} || 'NULL'),
2132                                                                    $query->{Time}, ($query->{Info} || 'NULL');
2133                                                              }
2134  ***      2     50                          22               if ( $o->get('execute-command') ) {
2135           2                                 14                  exec_cmd($o->get('execute-command'));
2136                                                              }
2137  ***      1     50                         100               if ( $o->get('kill') ) {
2138  ***      0      0                           0                  sleep $o->get('wait-before-kill') if $o->get('wait-before-kill');
2139  ***      0                                  0                  $kill_sth->execute($query->{Id});
2140                                                              }
2141                                                           }
2142                                                        }
2143                                                        else {
2144  ***      0                                  0            MKDEBUG && _d('No proclist returned');
2145                                                        }
2146                                                  
2147                                                        # Don't sleep if we're going to exit after waking up.  If $iters_todo is
2148                                                        # 0 (infinity), always sleep.  And only sleep if we're live (i.e. not
2149                                                        # reading from files).
2150  ***      1     50     33                   66         if ( (!$iters_todo || $iters_done < $iters_todo)
      ***                   33                        
2151                                                              && $dbh ) {
2152  ***      0      0      0                    0            if ( @queries && $o->get('wait-after-kill') ) {
2153  ***      0                                  0               MKDEBUG && _d("Sleeping after killing queries");
2154  ***      0                                  0               sleep $o->get('wait-after-kill');
2155                                                           }
2156                                                           else {
2157  ***      0                                  0               MKDEBUG && _d("Sleeping normal interval");
2158  ***      0                                  0               sleep $o->get('interval');
2159                                                           }
2160                                                        }
2161           1                                169         $now = time();
2162                                                     }
2163                                                  
2164           1                                 31      return 0;
2165                                                  }
2166                                                  
2167                                                  
2168                                                  # ############################################################################
2169                                                  # Subroutines.
2170                                                  # ############################################################################
2171                                                  
2172                                                  sub get_cxn {
2173  ***      0                    0             0      my ( $dsn, $ac ) = @_;
2174  ***      0      0                           0      if ( $o->get('ask-pass') ) {
2175  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password: "); 
2176                                                     }
2177  ***      0                                  0      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => $ac});
2178  ***      0                                  0      $dbh->{InactiveDestroy} = 1; # Because of forking.
2179  ***      0                                  0      return $dbh;
2180                                                  }
2181                                                  
2182                                                  # Forks and detaches from parent to execute the given command;
2183                                                  # does not block parent.
2184                                                  sub exec_cmd {
2185           2                    2            16      my ( $cmd ) = @_;
2186           2                                  8      MKDEBUG && _d('exec cmd:', $cmd);
2187  ***      2     50                          14      return unless $cmd;
2188                                                  
2189           2                               2615      my $pid = fork();
2190           2    100                         122      if ( $pid ) {
2191                                                        # parent
2192           1                                 21         MKDEBUG && _d('child pid:', $pid);
2193           1                                 37         return $pid;
2194                                                     }
2195                                                  
2196                                                     # child
2197  ***      1     50                         200      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2198           1                               4424      my $retval = system($cmd);
2199           1                                 23      $retval = $retval >> 8;
2200           1                                 10      MKDEBUG && _d('child exit status:', $retval);
2201           1                                 22      exit $retval;
2202                                                  }
2203                                                  
2204                                                  sub _d {
2205  ***      0                    0                    my ($package, undef, $line) = caller 0;
2206  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2207  ***      0                                              map { defined $_ ? $_ : 'undef' }
2208                                                          @_;
2209  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2210                                                  }
2211                                                  
2212                                                  # ############################################################################
2213                                                  # Run the program.
2214                                                  # ############################################################################
2215                                                  if ( !caller ) { exit main(@ARGV); }
2216                                                  
2217                                                  1; # Because this is a module as well as a script.
2218                                                  
2219                                                  # ############################################################################
2220                                                  # Documentation
2221                                                  # ############################################################################
2222                                                  =pod
2223                                                  
2224                                                  =head1 NAME
2225                                                  
2226                                                  mk-kill - Kill MySQL queries that match certain criteria.
2227                                                  
2228                                                  =head1 SYNOPSIS
2229                                                  
2230                                                  Kill queries running longer than 60s:
2231                                                  
2232                                                    mk-kill --busy-time 60 --kill
2233                                                  
2234                                                  Print, do not kill, queries running longer than 60s:
2235                                                  
2236                                                    mk-kill --busy-time 60 --print
2237                                                  
2238                                                  Check for sleeping processes and kill them all every 10s:
2239                                                  
2240                                                    mk-kill --match-command Sleep --kill --no-only-oldest --interval 10
2241                                                  
2242                                                  Print all login processes:
2243                                                  
2244                                                    mk-kill --match-state login --print --no-only-oldest
2245                                                  
2246                                                  =head1 DESCRIPTION
2247                                                  
2248                                                  mk-kill captures queries from SHOW PROCESSLIST, filters them, and then either
2249                                                  kills or prints them.  This is also known as a "slow query sniper" in some
2250                                                  circles.  The idea is to watch for queries that might be consuming too many
2251                                                  resources, and kill them.
2252                                                  
2253                                                  For brevity, we talk about killing queries, but they may just be printed
2254                                                  (or some other future action) depending on what options are given.
2255                                                  
2256                                                  Normally mk-kill connects to MySQL to get queries from SHOW PROCESSLIST.
2257                                                  Alternatively, it can read SHOW PROCESSLIST output from files.  In this case,
2258                                                  mk-kill does not connect to MySQL and L<"--kill"> has no effect.  You should
2259                                                  use L<"--print"> instead when reading files.  The ability to read a file (or
2260                                                  - for STDIN) allows you to capture SHOW PROCESSLIST and test it later with
2261                                                  mk-kill to make sure that your matches kill the proper queries.  There are a
2262                                                  lot of special rules to follow, such as "don't kill replication threads,"
2263                                                  so be careful to not kill something important!
2264                                                  
2265                                                  Two important options to know are L<"--busy-time"> and L<"--[no]only-oldest">.
2266                                                  First, whereas most match/filter options match their corresponding value from
2267                                                  SHOW PROCESSLIST (e.g. L<"--match-command"> matches a query's Command value),
2268                                                  the Time value is matched by L<"--busy-time">.  See also L<"--interval">.
2269                                                  
2270                                                  Secondly, L<"--[no]only-oldest"> affects which matching query is killed.
2271                                                  By default, the matching query with the highest Time value is killed.  So
2272                                                  if you want to match and kill ALL queries for a certain criteria regardless
2273                                                  of which is the "oldest", you must specify C<--no-only-oldest>.
2274                                                  
2275                                                  mk-kill is a work in progress, and there is much more it could do.
2276                                                  
2277                                                  =head1 OUTPUT
2278                                                  
2279                                                  If only L<"--kill"> then there is no output.  If only L<"--print"> then a
2280                                                  timestamped KILL statement if printed for every query that would have
2281                                                  been killed, like:
2282                                                  
2283                                                    # 2009-07-15T15:04:01 KILL 8 (Query 42 sec) SELECT * FROM huge_table
2284                                                  
2285                                                  The line shows a timestamp, the query's Id (8), its Time (42 sec) and its
2286                                                  Info (usually the query SQL).
2287                                                  
2288                                                  If both L<"--kill"> and L<"--print"> are given, then matching queries are
2289                                                  killed and a line for each like the one above is printed.
2290                                                  
2291                                                  Any command executed by L<"--execute-command"> is responsible for its own
2292                                                  output and logging.  After being executed, mk-kill has no control or interaction
2293                                                  with the command.
2294                                                  
2295                                                  =head1 OPTIONS
2296                                                  
2297                                                  Specify at least one of L<"--kill">, L<"--print"> or L<"--execute-command">.
2298                                                  
2299                                                  =over
2300                                                  
2301                                                  =item --ask-pass
2302                                                  
2303                                                  Prompt for a password when connecting to MySQL.
2304                                                  
2305                                                  =item --charset
2306                                                  
2307                                                  short form: -A; type: string
2308                                                  
2309                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2310                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
2311                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
2312                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
2313                                                  
2314                                                  =item --config
2315                                                  
2316                                                  type: Array
2317                                                  
2318                                                  Read this comma-separated list of config files; if specified, this must be the
2319                                                  first option on the command line.
2320                                                  
2321                                                  =item --daemonize
2322                                                  
2323                                                  Fork to the background and detach from the shell.  POSIX operating systems
2324                                                  only.
2325                                                  
2326                                                  =item --defaults-file
2327                                                  
2328                                                  short form: -F; type: string
2329                                                  
2330                                                  Only read mysql options from the given file.  You must give an absolute
2331                                                  pathname.
2332                                                  
2333                                                  =item --help
2334                                                  
2335                                                  Show help and exit.
2336                                                  
2337                                                  =item --host
2338                                                  
2339                                                  short form: -h; type: string
2340                                                  
2341                                                  Connect to host.
2342                                                  
2343                                                  =item --interval
2344                                                  
2345                                                  type: time
2346                                                  
2347                                                  How often to check for queries to kill.  If L<"--busy-time"> is not given,
2348                                                  then the default interval is 30 seconds.  Else , the default is half as often
2349                                                  as L<"--busy-time">.  If both L<"--interval"> and L<"--busy-time"> are given,
2350                                                  then the explicit L<"--interval"> value is used.
2351                                                  
2352                                                  =item --iterations
2353                                                  
2354                                                  type: int; default: 1
2355                                                  
2356                                                  How many times to iterate through the find-and-kill cycle.  If 0, iterate
2357                                                  to infinity.  See also L<"--run-time">.
2358                                                  
2359                                                  =item --log
2360                                                  
2361                                                  type: string
2362                                                  
2363                                                  Print all output to this file when daemonized.
2364                                                  
2365                                                  =item --password
2366                                                  
2367                                                  short form: -p; type: string
2368                                                  
2369                                                  Password to use when connecting.
2370                                                  
2371                                                  =item --pid
2372                                                  
2373                                                  type: string
2374                                                  
2375                                                  Create the given PID file when daemonized.  The file contains the process ID of
2376                                                  the daemonized instance.  The PID file is removed when the daemonized instance
2377                                                  exits.  The program checks for the existence of the PID file when starting; if
2378                                                  it exists and the process with the matching PID exists, the program exits.
2379                                                  
2380                                                  =item --port
2381                                                  
2382                                                  short form: -P; type: int
2383                                                  
2384                                                  Port number to use for connection.
2385                                                  
2386                                                  =item --run-time
2387                                                  
2388                                                  type: time
2389                                                  
2390                                                  How long to run before exiting.
2391                                                  
2392                                                  =item --set-vars
2393                                                  
2394                                                  type: string; default: wait_timeout=10000
2395                                                  
2396                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2397                                                  will be appended to SET and executed.
2398                                                  
2399                                                  =item --socket
2400                                                  
2401                                                  short form: -S; type: string
2402                                                  
2403                                                  Socket file to use for connection.
2404                                                  
2405                                                  =item --user
2406                                                  
2407                                                  short form: -u; type: string
2408                                                  
2409                                                  User for login if not current user.
2410                                                  
2411                                                  =item --version
2412                                                  
2413                                                  Show version and exit.
2414                                                  
2415                                                  =item --wait-after-kill
2416                                                  
2417                                                  type: time
2418                                                  
2419                                                  Wait after killing a query, before looking for more to kill.  The purpose of
2420                                                  this is to give blocked queries a chance to execute, so we don't kill a query
2421                                                  that's blocking a bunch of others, and then kill the others immediately
2422                                                  afterwards.
2423                                                  
2424                                                  =item --wait-before-kill
2425                                                  
2426                                                  type: time
2427                                                  
2428                                                  Wait before killing a query.  The purpose of this is to give
2429                                                  L<"--execute-command"> a chance to see the matching query and gather other
2430                                                  MySQL or system information before it's killed.
2431                                                  
2432                                                  =back
2433                                                  
2434                                                  =head2 MATCHES
2435                                                  
2436                                                  These options specify what criteria a query must match for C<mk-kill>
2437                                                  to either L<"--kill">, L<"--print"> or L<"--execute-command"> for it.
2438                                                  
2439                                                  =over
2440                                                  
2441                                                  =item --busy-time
2442                                                  
2443                                                  type: time
2444                                                  
2445                                                  Kill connections that have been running for longer than this time.  The queries
2446                                                  must be in Command=Query status.  This matches a query's Time value as
2447                                                  reported by SHOW PROCESSLIST.
2448                                                  
2449                                                  =item --ignore-command
2450                                                  
2451                                                  type: string; group: Matches; default: Binlog.Dump
2452                                                  
2453                                                  Ignore queries whose Command matches this Perl regex.  The default is to keep
2454                                                  the slave threads from being killed on the master.
2455                                                  
2456                                                  =item --[no]ignore-self
2457                                                  
2458                                                  default: yes; group: Matches
2459                                                  
2460                                                  Don't kill mk-kill's own connection.
2461                                                  
2462                                                  =item --ignore-state
2463                                                  
2464                                                  type: string; group: Matches; default: Locked
2465                                                  
2466                                                  Ignore queries whose State matches this Perl regex.  The default is to keep
2467                                                  threads from being killed if they are locked waiting for another thread.
2468                                                  
2469                                                  =item --ignore-user
2470                                                  
2471                                                  type: string; group: Matches; default: system.user
2472                                                  
2473                                                  Ignore queries whose user matches this Perl regex.  The default is to keep the
2474                                                  replication threads from being killed on the slave.
2475                                                  
2476                                                  =item --match-command
2477                                                  
2478                                                  type: string; group: Matches
2479                                                  
2480                                                  Kill only queries whose Command matches this Perl regex.
2481                                                  
2482                                                  =item --match-info
2483                                                  
2484                                                  type: string; group: Matches
2485                                                  
2486                                                  Kill only queries whose Info (query) matches this Perl regex.
2487                                                  
2488                                                  =item --match-state
2489                                                  
2490                                                  type: string; group: Matches
2491                                                  
2492                                                  Kill only queries whose State matches this Perl regex.
2493                                                  
2494                                                  =item --[no]only-oldest
2495                                                  
2496                                                  default: yes; group: Matches
2497                                                  
2498                                                  Only kill the single oldest query.  This is to prevent killing queries that
2499                                                  aren't really long-running, they're just long-waiting.  This sorts matching
2500                                                  queries by Time and kills the one with the highest Time value.
2501                                                  
2502                                                  =back
2503                                                  
2504                                                  =head2 ACTIONS
2505                                                  
2506                                                  When a query matches, one or more of these actions is taken.  The actions are
2507                                                  taken in this order: L<"--print">, L<"--execute-command">, L<"--kill">.
2508                                                  If given, mk-kill sleeps for L<"--wait-before-kill"> before L<"--kill"> (if
2509                                                  L<"--kill"> is given).  This order allows L<"--execute-command"> to see the 
2510                                                  output of L<"--print"> and the query before L<"--kill">.  This may be helpful
2511                                                  because mk-kill does not pass any information to L<"--execute-command">.
2512                                                  
2513                                                  =over
2514                                                  
2515                                                  =item --execute-command
2516                                                  
2517                                                  type: string; group: Actions
2518                                                  
2519                                                  Execute this command when a query matches.
2520                                                  
2521                                                  After the command is executed, mk-kill has no control over it, so the command
2522                                                  is responsible for its own info gathering, logging, interval, etc.  The
2523                                                  command is excuted each time a query matches, so be careful that the command
2524                                                  behaves well when multiple instances are ran.  No information from mk-kill is
2525                                                  passed to the command.
2526                                                  
2527                                                  See also L<"--wait-before-kill">.
2528                                                  
2529                                                  =item --kill
2530                                                  
2531                                                  group: Actions
2532                                                  
2533                                                  Actually kill matching queries.
2534                                                  
2535                                                  This option makes mk-kill kill matching queries in MySQL.  Unless L<"--print">
2536                                                  is also given, no other information is printed that shows that mk-kill
2537                                                  matched and killed a query.
2538                                                  
2539                                                  See also L<"--wait-before-kill"> and L<"--wait-after-kill">.
2540                                                  
2541                                                  =item --print
2542                                                  
2543                                                  group: Actions
2544                                                  
2545                                                  Print a KILL statement for matching queries; does not actually kill queries.
2546                                                  
2547                                                  If you just want to see which queries match and would be killed without
2548                                                  actually killing them, specify L<"--print">.  To both kill and print
2549                                                  matching queries, specify both L<"--kill"> and L<"--print">.
2550                                                  
2551                                                  =back
2552                                                  
2553                                                  =head1 DOWNLOADING
2554                                                  
2555                                                  You can download Maatkit from Google Code at
2556                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2557                                                  easily with a command like the following:
2558                                                  
2559                                                     wget http://www.maatkit.org/get/toolname
2560                                                     or
2561                                                     wget http://www.maatkit.org/trunk/toolname
2562                                                  
2563                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2564                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2565                                                  needed.  The first URL gets the latest released version of the tool, and the
2566                                                  second gets the latest trunk code from Subversion.
2567                                                  
2568                                                  =head1 ENVIRONMENT
2569                                                  
2570                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2571                                                  the Maatkit tools:
2572                                                  
2573                                                     MKDEBUG=1 mk-....
2574                                                  
2575                                                  =head1 SYSTEM REQUIREMENTS
2576                                                  
2577                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2578                                                  installed in any reasonably new version of Perl.
2579                                                  
2580                                                  =head1 BUGS
2581                                                  
2582                                                  Please use Google Code Issues and Groups to report bugs or request support:
2583                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2584                                                  discuss Maatkit.
2585                                                  
2586                                                  Please include the complete command-line used to reproduce the problem you are
2587                                                  seeing, the version of all MySQL servers involved, the complete output of the
2588                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2589                                                  running with the C<MKDEBUG=1> environment variable.
2590                                                  
2591                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2592                                                  
2593                                                  This program is copyright 2009-@CURRENTYEAR@ Baron Schwartz.
2594                                                  Feedback and improvements are welcome.
2595                                                  
2596                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2597                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2598                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2599                                                  
2600                                                  This program is free software; you can redistribute it and/or modify it under
2601                                                  the terms of the GNU General Public License as published by the Free Software
2602                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2603                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2604                                                  licenses.
2605                                                  
2606                                                  You should have received a copy of the GNU General Public License along with
2607                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2608                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2609                                                  
2610                                                  =head1 AUTHOR
2611                                                  
2612                                                  Baron Schwartz.
2613                                                  
2614                                                  =head1 VERSION
2615                                                  
2616                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 4191 $.
2617                                                  
2618                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
57    ***     50      0      2   unless $args{$arg}
62    ***     50      2      0   exists $args{'strict'} ? :
105   ***     50      0      2   unless open my $fh, '<', $file
125          100    596      2   unless $para =~ /^=head1 OPTIONS/
130          100      2      2   if $para =~ /^=over/
138   ***     50      0      2   unless $para
141          100     64      2   if (my($option) = $para =~ /^=item --(.*)/)
148          100     56      8   if ($para =~ /: /) { }
152   ***     50      0     98   unless $attributes{$attrib}
156          100     14     42   if ($attribs{'short form'})
172   ***     50      0     64   if $para =~ /^=item/
174          100      4     60   if (my($base_option) = $option =~ /^\[no\](.*)/)
179          100     14     50   $attribs{'short form'} ? :
             100      4     60   $attribs{'negatable'} ? :
      ***     50      0     64   $attribs{'cumulative'} ? :
             100     48     16   $attribs{'type'} ? :
             100     14     50   $attribs{'default'} ? :
             100     22     42   $attribs{'group'} ? :
191   ***     50      0     94   unless $para
194          100      2     92   if ($para =~ /^=head1/)
198          100     64     28   if $para =~ /^=item --/
202   ***     50      0      2   unless @specs
213          100     64      2   if (ref $opt) { }
218   ***     50      0     64   if (not $long)
223   ***     50      0     64   if exists $$self{'opts'}{$long}
226   ***     50      0     64   if (length $long == 1)
231          100     14     50   if ($short) { }
232   ***     50      0     14   if exists $$self{'short_opts'}{$short}
241          100      4     60   $$opt{'spec'} =~ /!/ ? :
242   ***     50      0     64   $$opt{'spec'} =~ /\+/ ? :
243   ***     50      0     64   $$opt{'desc'} =~ /required/ ? :
255   ***     50      0     64   if ($type and $type eq 'd' and not $$self{'dp'})
260          100     12     52   if $type and $type =~ /[HhAadzm]/
262          100     14     50   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
263          100      4     10   if ($$opt{'is_negatable'})
264   ***      0      0      0   $def eq 'no' ? :
      ***     50      4      0   $def eq 'yes' ? :
268   ***     50     14      0   defined $def ? :
272          100      2     62   if ($long eq 'config')
276   ***     50      0     64   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
289   ***     50      0      2   if ($opt =~ /mutually exclusive|one and only one/)
294   ***     50      2      0   if ($opt =~ /at least one|one and only one/)
299   ***     50      0      2   if ($opt =~ /default to/)
304   ***     50      0      2   if ($opt =~ /restricted to option groups/)
314   ***     50      0      2   unless $rule_ok
331   ***     50      0      6   unless exists $$self{'opts'}{$long}
347   ***      0      0      0   $$self{'opts'}{$_}{'short'} ? :
365   ***      0      0      0   unless exists $$self{'opts'}{$long}
385   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50      4      0   exists $$self{'opts'}{$opt} ? :
390   ***     50      0      4   if ($$opt{'is_cumulative'}) { }
405   ***     50      0     48   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     16     48   exists $$self{'defaults'}{$long} ? :
414   ***     50      0      2   if (@ARGV and $ARGV[0] eq '--config')
418   ***     50      2      0   if ($self->has('config'))
424   ***     50      8      0   if ($EVAL_ERROR)
425   ***     50      0      8   $self->got('config') ? :
440   ***     50      0      2   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
443   ***     50      0      2   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
444   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
450   ***     50      0      2   if (@ARGV and $$self{'strict'})
456   ***      0      0      0   if (@set > 1)
467   ***     50      0      2   if (@set == 0)
477          100      4     60   if ($$opt{'got'}) { }
      ***     50      0     60   elsif ($$opt{'is_required'}) { }
478   ***     50      0      4   if (exists $$self{'disables'}{$long})
485   ***     50      0      4   if (exists $$self{'allowed_groups'}{$long})
497   ***      0      0      0   if $restricted_opt eq $long
498   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
503   ***      0      0      0   if (@restricted_opts)
505   ***      0      0      0   if (@restricted_opts == 1) { }
534          100     16     48   unless $opt and $$opt{'type'}
537   ***     50      0     48   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0     48   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     48   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0     48   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      2     46   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
540   ***      0      0      0   if (not $suffix)
546   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
547   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
562   ***      0      0      0   if ($from_key)
573   ***      0      0      0   if (defined $num) { }
574   ***      0      0      0   if ($factor)
601   ***     50      0     33   length $opt == 1 ? :
602   ***     50      0     33   unless $long and exists $$self{'opts'}{$long}
609   ***     50      0     12   length $opt == 1 ? :
610   ***     50      0     12   unless $long and exists $$self{'opts'}{$long}
617   ***     50      0      2   length $opt == 1 ? :
618   ***     50      2      0   defined $long ? :
623   ***     50      0      4   length $opt == 1 ? :
624   ***     50      0      4   unless $long and exists $$self{'opts'}{$long}
658   ***     50      0      2   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      2   elsif (scalar @{$$self{'errors'};}) { }
659   ***      0      0      0   unless print $self->print_usage
663   ***      0      0      0   unless print $self->print_errors
672   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
681   ***      0      0      0   unless $$self{'got_opts'}
684   ***      0      0      0   $$_{'is_negatable'} ? :
688   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
704   ***      0      0      0   $group eq 'default' ? :
710   ***      0      0      0   $$opt{'is_negatable'} ? :
713   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
722   ***      0      0      0   if ($short) { }
731   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
735   ***      0      0      0   if ($$self{'dp'})
743   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
755   ***      0      0      0   if ref $_[0] eq 'OptionParser'
758   ***      0      0      0   unless print $prompt
766   ***      0      0      0   unless print "\n"
769   ***      0      0      0   if ($EVAL_ERROR)
791   ***     50      8      0   unless open my $fh, '<', $filename
799   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
802   ***      0      0      0   if ($line eq '--')
807   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
825   ***      0      0      0   unless open my $fh, '<', $file
829   ***      0      0      0   unless $para =~ /^=pod$/m
833   ***      0      0      0   unless $para =~ /$regex/
838   ***      0      0      0   unless close $fh
852   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
867   ***      0      0      0   defined $_ ? :
905   ***      0      0      0   if (not $$self{$dbh})
909   ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
916   ***      0      0      0   defined $_ ? :
999   ***      0      0      0   if (@_ > 2)
1008  ***      0      0      0   if (not $dsn)
1020  ***      0      0      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1032  ***      0      0      0   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1038  ***      0      0      0   if (not defined $final_props{$key})
1045  ***      0      0      0   unless exists $opts{$key}
1048  ***      0      0      0   if (my $required = $self->prop('required'))
1050  ***      0      0      0   unless $final_props{$key}
1059  ***      0      0      0   unless ref $o eq 'OptionParser'
1062  ***      0      0      0   if $o->has($_)
1072  ***      0      0      0   unless ref $dsn
1073  ***      0      0      0   $_ eq 'p' ? :
1074  ***      0      0      0   if defined $$dsn{$_}
1087  ***      0      0      0   $opts{$key}{'copy'} ? :
1101  ***      0      0      0   if ($driver eq 'Pg') { }
1133  ***      0      0      0   $cxn_string =~ /charset=utf8/ ? :
1151  ***      0      0      0   if ($cxn_string =~ /mysql/i)
1159  ***      0      0      0   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1164  ***      0      0      0   if ($charset eq 'utf8') { }
1165  ***      0      0      0   unless binmode STDOUT, ':utf8'
1169  ***      0      0      0   unless binmode STDOUT
1173  ***      0      0      0   if ($self->prop('setvars'))
1180  ***      0      0      0   if (not $dbh and $EVAL_ERROR)
1182  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/)
1186  ***      0      0      0   if (not $tries)
1208  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1225  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1235  ***      0      0      0   unless $dsn_1
1236  ***      0      0      0   unless $dsn_2
1240  ***      0      0      0   if ($args{'overwrite'}) { }
1241  ***      0      0      0   defined $$dsn_1{$key} ? :
1244  ***      0      0      0   defined $$dsn_2{$key} ? :
1253  ***      0      0      0   defined $_ ? :
1282  ***      0      0      0   unless $args{$arg}
1285  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1301  ***      0      0      0   unless defined(my $pid = fork)
1302  ***      0      0      0   if ($pid)
1309  ***      0      0      0   unless POSIX::setsid()
1310  ***      0      0      0   unless chdir '/'
1314  ***      0      0      0   if (-t STDIN)
1316  ***      0      0      0   unless open STDIN, '/dev/null'
1320  ***      0      0      0   if ($$self{'log_file'})
1322  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1326  ***      0      0      0   unless open STDERR, '>&STDOUT'
1336  ***      0      0      0   $self ? :
1338  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1341  ***      0      0      0   if $EVAL_ERROR
1343  ***      0      0      0   if ($pid) { }
1345  ***      0      0      0   if ($pid_is_alive) { }
1367  ***      0      0      0   if (exists $$self{'child'})
1379  ***      0      0      0   if (not $PID_file)
1386  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1388  ***      0      0      0   unless print $PID_FH $PID
1390  ***      0      0      0   unless close $PID_FH
1399  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1400  ***      0      0      0   unless unlink $$self{'PID_file'}
1412  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1418  ***      0      0      0   defined $_ ? :
1461  ***      0      0      0   defined $args{'p_ms'} ? :
1462  ***      0      0      0   defined $args{'p_s'} ? :
1465  ***      0      0      0   if $t < 0
1467  ***      0      0      0   if $t =~ /e/
1471  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1492  ***      0      0      0   $p ? :
1499  ***      0      0      0   unless $secs
1501  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1506  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1525  ***      0      0      0   defined $args{'p'} ? :
1526  ***      0      0      0   defined $args{'d'} ? :
1533  ***      0      0      0   $num =~ /\./ || $n ? :
1552  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?$/)
1555  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
1564  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s) = $val =~ /^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.\d+)?$/)
1581  ***      0      0      0   defined $_ ? :
1632  ***      0      0      0   if (not $curr and @curr)
1636  ***      0      0      0   if (not $prev and @prev)
1640  ***      0      0      0   if ($curr or $prev)
1641  ***      0      0      0   if ($curr and $prev and $$curr[0] == $$prev[0]) { }
      ***      0      0      0   elsif (not $curr or $curr and $prev and $$curr[0] > $$prev[0]) { }
1643  ***      0      0      0   $$curr[5] =~ /\D/ ? :
1645  ***      0      0      0   if ($$prev[7])
1646  ***      0      0      0   if (not $$curr[7] or $$prev[7] ne $$curr[7]) { }
      ***      0      0      0   elsif (defined $$curr[5] and $$curr[5] < $$prev[5]) { }
      ***      0      0      0   elsif ($$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge) { }
1661  ***      0      0      0   if ($is_new)
1665  ***      0      0      0   if ($$curr[7])
1666  ***      0      0      0   if ($$prev[7] and not $is_new) { }
1687  ***      0      0      0   if ($$curr[7] and defined $$curr[5])
1706  ***      0      0      0   if ($$row[5] < $time - $$row[10])
1721  ***      0      0      0   unless $event = &$callback($event)
1731  ***     50      0      2   if ($find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query')
1732  ***      0      0      0   if ($$query{'Time'} < $find_spec{'busy_time'})
1741  ***     50      0     14   if (defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property}))
1747         100      2     12   if (defined $find_spec{'match'}{$property})
1748  ***     50      0      2   if (not $self->$filter($query, $find_spec{'match'}{$property}))
1755  ***     50      2      0   if ($matched)
1760  ***     50      2      0   if (@matches and $find_spec{'only_oldest'})
1810  ***      0      0      0   defined $_ ? :
1844         100      2      2   unless @cols
1853  ***      0      0      0   unless @cols
1868  ***     50      2      0   if ($text =~ /^\+---/m) { }
      ***      0      0      0   elsif ($text =~ /^id\tselect_type\t/m) { }
      ***      0      0      0   elsif ($text =~ /\*\*\* \d+\. row/) { }
1884  ***      0      0      0   if ($n_recs > 1)
1900  ***     50      0      2   if ($$self{'value_for'})
1903  ***      0      0      0   if exists $$self{'value_for'}{$$result_set{$key}}
1918         100      2      2   if ($row) { }
1942  ***      0      0      0   defined $_ ? :
2003  ***     50      2      0   if (not $o->got('busy-time')) { }
2004  ***     50      2      0   unless $o->got('interval')
2007  ***      0      0      0   unless $o->got('interval')
2012  ***     50      2      0   if (@ARGV)
2024  ***     50      0      2   if (not @ARGV)
2034  ***     50      2      0   if (@ARGV) { }
2039  ***     50      2      0   if (not $fh)
2041  ***     50      0      2   unless $file
2042  ***     50      0      2   if ($file eq '-') { }
2046  ***     50      0      2   if (not open $fh, '<', $file)
2054  ***     50      2      0   if ($fh)
2057  ***     50      2      0   if ($proclist_text) { }
2082  ***     50      0      2   if ($o->get('daemonize'))
2095  ***     50      2      0   $o->get('ignore-self') ? :
2119  ***     50      0      2   if ($EVAL_ERROR)
2120  ***      0      0      0   if $EVAL_ERROR =~ /No more files/
2125  ***     50      2      0   if ($proclist) { }
2129  ***     50      0      2   if ($o->get('print'))
2134  ***     50      2      0   if ($o->get('execute-command'))
2137  ***     50      0      1   if ($o->get('kill'))
2138  ***      0      0      0   if $o->get('wait-before-kill')
2150  ***     50      0      1   if (!$iters_todo || $iters_done < $iters_todo and $dbh)
2152  ***      0      0      0   if (@queries and $o->get('wait-after-kill')) { }
2174  ***      0      0      0   if ($o->get('ask-pass'))
2187  ***     50      0      2   unless $cmd
2190         100      1      1   if ($pid)
2197  ***     50      0      1   unless POSIX::setsid()
2206  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
255   ***     66     16     48      0   $type and $type eq 'd'
      ***     33     64      0      0   $type and $type eq 'd' and not $$self{'dp'}
260          100     16     36     12   $type and $type =~ /[HhAadzm]/
414   ***     33      0      2      0   @ARGV and $ARGV[0] eq '--config'
443   ***     33      0      2      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
450   ***     33      0      2      0   @ARGV and $$self{'strict'}
534   ***     66      0     16     48   $opt and $$opt{'type'}
537   ***     66     32     16      0   $val and $$opt{'type'} eq 'm'
      ***     66     32     16      0   $val and $$opt{'type'} eq 'd'
      ***     66     32     16      0   $val and $$opt{'type'} eq 'z'
      ***     66     32     16      0   defined $val and $$opt{'type'} eq 'h'
      ***     66     32     14      0   defined $val and $$opt{'type'} eq 'a'
602   ***     33      0      0     33   $long and exists $$self{'opts'}{$long}
610   ***     33      0      0     12   $long and exists $$self{'opts'}{$long}
624   ***     33      0      0      4   $long and exists $$self{'opts'}{$long}
713   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
807   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1032  ***      0      0      0      0   not defined $final_props{$key} and defined $$prev{$key}
      ***      0      0      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1144  ***      0      0      0      0   not $dbh and $tries--
1180  ***      0      0      0      0   not $dbh and $EVAL_ERROR
1338  ***      0      0      0      0   $PID_file and -f $PID_file
1399  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1471  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1529  ***      0      0      0      0   $num >= $d and $n < @units - 1
1632  ***      0      0      0      0   not $curr and @curr
1636  ***      0      0      0      0   not $prev and @prev
1641  ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] == $$prev[0]
      ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] > $$prev[0]
1646  ***      0      0      0      0   defined $$curr[5] and $$curr[5] < $$prev[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge
1666  ***      0      0      0      0   $$prev[7] and not $is_new
1687  ***      0      0      0      0   $$curr[7] and defined $$curr[5]
1731  ***     33      2      0      0   $find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query'
1741  ***     66      8      6      0   defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property})
1760  ***     33      0      0      2   @matches and $find_spec{'only_oldest'}
1769  ***      0      0      0      0   defined $property && defined $$query{'Id'}
      ***      0      0      0      0   defined $property && defined $$query{'Id'} && $$query{'Id'} == $property
1774  ***     33      0      0      2   defined $property && defined $$query{'User'}
      ***     33      0      2      0   defined $property && defined $$query{'User'} && $$query{'User'} =~ /$property/
1780  ***      0      0      0      0   defined $property && defined $$query{'Host'}
      ***      0      0      0      0   defined $property && defined $$query{'Host'} && $$query{'Host'} =~ /$property/
1786  ***      0      0      0      0   defined $property && defined $$query{'db'}
      ***      0      0      0      0   defined $property && defined $$query{'db'} && $$query{'db'} =~ /$property/
1792  ***     33      0      0      2   defined $property && defined $$query{'State'}
      ***     33      0      2      0   defined $property && defined $$query{'State'} && $$query{'State'} =~ /$property/
1798  ***     33      0      0      4   defined $property && defined $$query{'Command'}
      ***     66      0      2      2   defined $property && defined $$query{'Command'} && $$query{'Command'} =~ /$property/
1804  ***      0      0      0      0   defined $property && defined $$query{'Info'}
      ***      0      0      0      0   defined $property && defined $$query{'Info'} && $$query{'Info'} =~ /$property/
2113  ***     66      0      1      2   $start == $end || $now < $end and !$iters_todo || $iters_done++ < $iters_todo
2150  ***     33      1      0      0   !$iters_todo || $iters_done < $iters_todo and $dbh
2152  ***      0      0      0      0   @queries and $o->get('wait-after-kill')

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
60    ***     50      2      0   $program_name ||= $PROGRAM_NAME
62    ***     50      2      0   $args{'prompt'} || '<options>'
      ***     50      0      2   $args{'dp'} || undef
104   ***     50      0      2   $file ||= '../mk-kill'
245   ***     50     64      0   $$opt{'group'} ||= 'default'
542   ***      0      0      0   $s || 's'
579   ***      0      0      0   $pre || ''
586   ***      0      0      0   $val || ''
589   ***     50      2      0   $val || ''
647   ***      0      0      0   $$self{'description'} || ''
715   ***      0      0      0   $s ||= 's'
741   ***      0      0      0   $$opt{'type'} || ''
1013  ***      0      0      0   $prev ||= {}
1014  ***      0      0      0   $defaults ||= {}
1087  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1100  ***      0      0      0   $self->prop('dbidriver') || ''
1104  ***      0      0      0   $$info{'D'} || ''
1110  ***      0      0      0   $$info{'D'} || ''
1132  ***      0      0      0   $opts ||= {}
1208  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1224  ***      0      0      0   $level ||= 0
1225  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1491  ***      0      0      0   $args{'p'} || 0
1493  ***      0      0      0   $of ||= 1
1498  ***      0      0      0   $secs ||= 0
1627  ***      0      0      0   $$misc{'prev'} ||= []
1731  ***      0      0      0   $$query{'Command'} || ''
2092  ***     50      0      2   $o->get('run-time') || 0
2130  ***      0      0      0   $$query{'Command'} || 'NULL'
      ***      0      0      0   $$query{'Info'} || 'NULL'

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
537   ***     33      0      0     48   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      2      0     46   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1123  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1124  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1125  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1126  ***      0      0      0      0   $$dsn{'u'} ||= $user
1127  ***      0      0      0      0   $$dsn{'D'} ||= $db
1412  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1501  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1533  ***      0      0      0      0   $num =~ /\./ || $n
1631  ***      0      0      0      0   @curr or @prev
      ***      0      0      0      0   @curr or @prev or $curr
      ***      0      0      0      0   @curr or @prev or $curr or $prev
1640  ***      0      0      0      0   $curr or $prev
1641  ***      0      0      0      0   not $curr or $curr and $prev and $$curr[0] > $$prev[0]
1646  ***      0      0      0      0   not $$curr[7] or $$prev[7] ne $$curr[7]
2113  ***     33      3      0      0   $start == $end || $now < $end
      ***     66      0      2      1   !$iters_todo || $iters_done++ < $iters_todo
2150  ***     33      0      0      1   !$iters_todo || $iters_done < $iters_todo


Covered Subroutines
-------------------

Subroutine                   Count Location                                     
---------------------------- ----- ---------------------------------------------
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1271
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1272
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1274
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1275
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1277
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1436
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1437
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1438
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1439
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1440
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1442
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1598
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1599
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1600
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1602
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1615
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1828
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1829
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1830
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1832
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1964
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1965
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1966
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1970
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:22  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:23  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:34  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:35  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:37  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:38  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:39  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:41  
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:884 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:885 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:887 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:889 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:931 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:932 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:936 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:937 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:940 
BEGIN                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:942 
__ANON__                         2 /home/daniel/dev/maatkit/mk-kill/mk-kill:2039
__ANON__                         4 /home/daniel/dev/maatkit/mk-kill/mk-kill:438 
_find_match_Command              4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1797
_find_match_State                2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1791
_find_match_User                 2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1773
_get_participants                2 /home/daniel/dev/maatkit/mk-kill/mk-kill:328 
_parse_horizontal_result_set     2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1913
_parse_specs                     2 /home/daniel/dev/maatkit/mk-kill/mk-kill:209 
_pod_to_specs                    2 /home/daniel/dev/maatkit/mk-kill/mk-kill:103 
_read_config_file                8 /home/daniel/dev/maatkit/mk-kill/mk-kill:790 
_set_option                      4 /home/daniel/dev/maatkit/mk-kill/mk-kill:384 
_validate_type                  64 /home/daniel/dev/maatkit/mk-kill/mk-kill:533 
exec_cmd                         2 /home/daniel/dev/maatkit/mk-kill/mk-kill:2185
find                             2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1726
get                             33 /home/daniel/dev/maatkit/mk-kill/mk-kill:600 
get_defaults_files               2 /home/daniel/dev/maatkit/mk-kill/mk-kill:98  
get_opts                         2 /home/daniel/dev/maatkit/mk-kill/mk-kill:401 
get_specs                        2 /home/daniel/dev/maatkit/mk-kill/mk-kill:91  
got                             12 /home/daniel/dev/maatkit/mk-kill/mk-kill:608 
has                              2 /home/daniel/dev/maatkit/mk-kill/mk-kill:616 
main                             2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1980
new                              2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1618
new                              2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1835
new                              2 /home/daniel/dev/maatkit/mk-kill/mk-kill:55  
new                              2 /home/daniel/dev/maatkit/mk-kill/mk-kill:892 
new                              2 /home/daniel/dev/maatkit/mk-kill/mk-kill:945 
parse                            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1865
parse_tabular                    4 /home/daniel/dev/maatkit/mk-kill/mk-kill:1841
set                              4 /home/daniel/dev/maatkit/mk-kill/mk-kill:622 
usage_or_errors                  2 /home/daniel/dev/maatkit/mk-kill/mk-kill:657 

Uncovered Subroutines
---------------------

Subroutine                   Count Location                                     
---------------------------- ----- ---------------------------------------------
DESTROY                          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1411
__ANON__                         0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2073
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1252
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1417
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1580
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1809
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1941
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2205
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:866 
_d                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:915 
_find_match_Host                 0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1779
_find_match_Id                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1768
_find_match_Info                 0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1803
_find_match_db                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1785
_make_PID_file                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1376
_parse_vertical_result_set       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1929
_remove_PID_file                 0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1398
_split_vertical_result_sets      0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1934
as_string                        0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1071
check_PID_file                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1335
clone                            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:843 
copy                             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1234
daemonize                        0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1298
descr                            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:646 
disconnect                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1217
errors                           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:636 
fill_in_dsn                      0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1119
fire_event                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1704
get_cxn                          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2173
get_cxn_params                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1097
get_dbh                          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1131
get_defaults                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:374 
get_groups                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:379 
get_hostname                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1207
make_PID_file                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1366
make_checksum                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1573
micro_t                          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1460
new                              0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1280
opt_values                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:346 
opts                             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:340 
parse                            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1007
parse                            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:897 
parse_event                      0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1623
parse_options                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1058
parse_tab_sep                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1850
parse_timestamp                  0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1551
parse_vertical                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1859
percentage_of                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1490
print_active_handles             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1223
print_errors                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:670 
print_usage                      0 /home/daniel/dev/maatkit/mk-kill/mk-kill:680 
prompt                           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:641 
prompt_noecho                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:755 
prop                             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:998 
read_para_after                  0 /home/daniel/dev/maatkit/mk-kill/mk-kill:824 
save_error                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:631 
secs_to_time                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1497
set_defaults                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:362 
short_opts                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:356 
shorten                          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1524
ts                               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1541
unix_timestamp                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1563
usage                            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1080
version_ge                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:904 


