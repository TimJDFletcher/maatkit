---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...v/maatkit/mk-kill/mk-kill   47.4   30.6   31.4   61.6    n/a  100.0   41.6
Total                          47.4   30.6   31.4   61.6    n/a  100.0   41.6
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb  1 18:38:03 2010
Finish:       Mon Feb  1 18:38:03 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb  1 18:38:04 2010
Finish:       Mon Feb  1 18:38:22 2010

Run:          ./102_match.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb  1 18:38:24 2010
Finish:       Mon Feb  1 18:38:25 2010

Run:          ./103_execute_command.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb  1 18:38:27 2010
Finish:       Mon Feb  1 18:38:28 2010

Run:          ./104_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb  1 18:38:31 2010
Finish:       Mon Feb  1 18:38:33 2010

Run:          ./105_kill.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb  1 18:38:36 2010
Finish:       Mon Feb  1 18:38:38 2010

/home/daniel/dev/maatkit/mk-kill/mk-kill

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-kill, a program that kills queries in MySQL.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22             5                    5            32   use strict;
               5                                 13   
               5                                 33   
23             5                    5            35   use warnings FATAL => 'all';
               5                                 12   
               5                                 33   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5455 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # OptionParser package 5266
31                                                    # ###########################################################################
32                                                    package OptionParser;
33                                                    
34             5                    5            42   use strict;
               5                                 15   
               5                                 21   
35             5                    5            28   use warnings FATAL => 'all';
               5                                 13   
               5                                 27   
36                                                    
37             5                    5            45   use Getopt::Long;
               5                                 15   
               5                                 36   
38             5                    5            38   use List::Util qw(max);
               5                                 13   
               5                                 96   
39             5                    5            31   use English qw(-no_match_vars);
               5                                 11   
               5                                 33   
40                                                    
41    ***      5            50      5            33   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 13   
               5                                 90   
42                                                    
43                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
44                                                    
45                                                    my %attributes = (
46                                                       'type'       => 1,
47                                                       'short form' => 1,
48                                                       'group'      => 1,
49                                                       'default'    => 1,
50                                                       'cumulative' => 1,
51                                                       'negatable'  => 1,
52                                                    );
53                                                    
54                                                    sub new {
55            12                   12           131      my ( $class, %args ) = @_;
56            12                                 65      foreach my $arg ( qw(description) ) {
57    ***     12     50                          84         die "I need a $arg argument" unless $args{$arg};
58                                                       }
59            12                                147      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
60    ***     12            33                   71      $program_name ||= $PROGRAM_NAME;
61    ***     12            33                  124      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
62                                                    
63    ***     12     50     50                  501      my $self = {
      ***                   50                        
64                                                          description    => $args{description},
65                                                          prompt         => $args{prompt} || '<options>',
66                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
67                                                          dp             => $args{dp}     || undef,
68                                                          program_name   => $program_name,
69                                                          opts           => {},
70                                                          got_opts       => 0,
71                                                          short_opts     => {},
72                                                          defaults       => {},
73                                                          groups         => {},
74                                                          allowed_groups => {},
75                                                          errors         => [],
76                                                          rules          => [],  # desc of rules for --help
77                                                          mutex          => [],  # rule: opts are mutually exclusive
78                                                          atleast1       => [],  # rule: at least one opt is required
79                                                          disables       => {},  # rule: opt disables other opts 
80                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
81                                                          default_files  => [
82                                                             "/etc/maatkit/maatkit.conf",
83                                                             "/etc/maatkit/$program_name.conf",
84                                                             "$home/.maatkit.conf",
85                                                             "$home/.$program_name.conf",
86                                                          ],
87                                                       };
88            12                                124      return bless $self, $class;
89                                                    }
90                                                    
91                                                    sub get_specs {
92            12                   12            53      my ( $self, $file ) = @_;
93            12                                100      my @specs = $self->_pod_to_specs($file);
94            12                                277      $self->_parse_specs(@specs);
95            12                                 59      return;
96                                                    }
97                                                    
98                                                    sub get_defaults_files {
99            12                   12            51      my ( $self ) = @_;
100           12                                 36      return @{$self->{default_files}};
              12                                132   
101                                                   }
102                                                   
103                                                   sub _pod_to_specs {
104           12                   12            54      my ( $self, $file ) = @_;
105   ***     12            50                   70      $file ||= __FILE__;
106   ***     12     50                         452      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
107                                                   
108           12                                700      my %types = (
109                                                         string => 's', # standard Getopt type
110                                                         'int'  => 'i', # standard Getopt type
111                                                         float  => 'f', # standard Getopt type
112                                                         Hash   => 'H', # hash, formed from a comma-separated list
113                                                         hash   => 'h', # hash as above, but only if a value is given
114                                                         Array  => 'A', # array, similar to Hash
115                                                         array  => 'a', # array, similar to hash
116                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
117                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
118                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
119                                                      );
120           12                                 46      my @specs = ();
121           12                                 40      my @rules = ();
122           12                                 38      my $para;
123                                                   
124           12                                 83      local $INPUT_RECORD_SEPARATOR = '';
125           12                                333      while ( $para = <$fh> ) {
126         3876    100                       28574         next unless $para =~ m/^=head1 OPTIONS/;
127           12                                 51         last;
128                                                      }
129                                                   
130           12                                 81      while ( $para = <$fh> ) {
131           24    100                         140         last if $para =~ m/^=over/;
132           12                                 49         chomp $para;
133           12                                109         $para =~ s/\s+/ /g;
134           12                                368         $para =~ s/$POD_link_re/$1/go;
135           12                                 40         MKDEBUG && _d('Option rule:', $para);
136           12                                106         push @rules, $para;
137                                                      }
138                                                   
139   ***     12     50                          55      die 'POD has no OPTIONS section' unless $para;
140                                                   
141           12                                 41      do {
142          504    100                        3702         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
143          492                               1488            chomp $para;
144          492                               1162            MKDEBUG && _d($para);
145          492                               1218            my %attribs;
146                                                   
147          492                               1865            $para = <$fh>; # read next paragraph, possibly attributes
148                                                   
149          492    100                        1958            if ( $para =~ m/: / ) { # attributes
150          432                               2197               $para =~ s/\s+\Z//g;
151          780                               3729               %attribs = map {
152          432                               2127                     my ( $attrib, $val) = split(/: /, $_);
153   ***    780     50                        3616                     die "Unrecognized attribute for --$option: $attrib"
154                                                                        unless $attributes{$attrib};
155          780                               3992                     ($attrib, $val);
156                                                                  } split(/; /, $para);
157          432    100                        2131               if ( $attribs{'short form'} ) {
158           84                                432                  $attribs{'short form'} =~ s/-//;
159                                                               }
160          432                               2187               $para = <$fh>; # read next paragraph, probably short help desc
161                                                            }
162                                                            else {
163           60                                154               MKDEBUG && _d('Option has no attributes');
164                                                            }
165                                                   
166          492                               3855            $para =~ s/\s+\Z//g;
167          492                               4081            $para =~ s/\s+/ /g;
168          492                               2132            $para =~ s/$POD_link_re/$1/go;
169                                                   
170          492                               2124            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
171          492                               1500            MKDEBUG && _d('Short help:', $para);
172                                                   
173   ***    492     50                        2160            die "No description after option spec $option" if $para =~ m/^=item/;
174                                                   
175          492    100                        2563            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
176           24                                 76               $option = $base_option;
177           24                                 99               $attribs{'negatable'} = 1;
178                                                            }
179                                                   
180          492    100                        8805            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
                    100                               
181                                                               spec  => $option
182                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
183                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
184                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
185                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
186                                                               desc  => $para
187                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
188                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
189                                                            };
190                                                         }
191          504                               3217         while ( $para = <$fh> ) {
192   ***    864     50                        3131            last unless $para;
193                                                   
194                                                   
195          864    100                        3514            if ( $para =~ m/^=head1/ ) {
196           12                                 39               $para = undef; # Can't 'last' out of a do {} block.
197           12                                 67               last;
198                                                            }
199          852    100                        6221            last if $para =~ m/^=item --/;
200                                                         }
201                                                      } while ( $para );
202                                                   
203   ***     12     50                          54      die 'No valid specs in POD OPTIONS' unless @specs;
204                                                   
205           12                                157      close $fh;
206           12                                 45      return @specs, @rules;
207                                                   }
208                                                   
209                                                   sub _parse_specs {
210           12                   12           136      my ( $self, @specs ) = @_;
211           12                                 59      my %disables; # special rule that requires deferred checking
212                                                   
213           12                                 59      foreach my $opt ( @specs ) {
214          504    100                        1889         if ( ref $opt ) { # It's an option spec, not a rule.
215                                                            MKDEBUG && _d('Parsing opt spec:',
216          492                               1165               map { ($_, '=>', $opt->{$_}) } keys %$opt);
217                                                   
218          492                               3487            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
219   ***    492     50                        2132            if ( !$long ) {
220   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
221                                                            }
222          492                               1833            $opt->{long} = $long;
223                                                   
224   ***    492     50                        2369            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
225          492                               2248            $self->{opts}->{$long} = $opt;
226                                                   
227   ***    492     50                        2040            if ( length $long == 1 ) {
228   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
229   ***      0                                  0               $self->{short_opts}->{$long} = $long;
230                                                            }
231                                                   
232          492    100                        1680            if ( $short ) {
233   ***     84     50                         409               die "Duplicate short option -$short"
234                                                                  if exists $self->{short_opts}->{$short};
235           84                                358               $self->{short_opts}->{$short} = $long;
236           84                                319               $opt->{short} = $short;
237                                                            }
238                                                            else {
239          408                               1524               $opt->{short} = undef;
240                                                            }
241                                                   
242          492    100                        2790            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
243   ***    492     50                        2526            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
244   ***    492     50                        2843            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
245                                                   
246   ***    492            50                 2165            $opt->{group} ||= 'default';
247          492                               2617            $self->{groups}->{ $opt->{group} }->{$long} = 1;
248                                                   
249          492                               1632            $opt->{value} = undef;
250          492                               1637            $opt->{got}   = 0;
251                                                   
252          492                               2725            my ( $type ) = $opt->{spec} =~ m/=(.)/;
253          492                               1845            $opt->{type} = $type;
254          492                               1148            MKDEBUG && _d($long, 'type:', $type);
255                                                   
256   ***    492     50     66                 4561            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
257   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
258                                                                  . "was given when this OptionParser object was created";
259                                                            }
260                                                   
261          492    100    100                 3791            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
262                                                   
263          492    100                        3010            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
264   ***     84     50                         495               $self->{defaults}->{$long} = defined $def ? $def : 1;
265           84                                207               MKDEBUG && _d($long, 'default:', $def);
266                                                            }
267                                                   
268          492    100                        2004            if ( $long eq 'config' ) {
269           12                                 69               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
270                                                            }
271                                                   
272   ***    492     50                        2616            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
273   ***      0                                  0               $disables{$long} = $dis;
274   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
275                                                            }
276                                                   
277          492                               2525            $self->{opts}->{$long} = $opt;
278                                                         }
279                                                         else { # It's an option rule, not a spec.
280           12                                 40            MKDEBUG && _d('Parsing rule:', $opt); 
281           12                                 35            push @{$self->{rules}}, $opt;
              12                                 64   
282           12                                 77            my @participants = $self->_get_participants($opt);
283           12                                 46            my $rule_ok = 0;
284                                                   
285   ***     12     50                         111            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
286   ***      0                                  0               $rule_ok = 1;
287   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
288   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
289                                                            }
290   ***     12     50                         114            if ( $opt =~ m/at least one|one and only one/ ) {
291           12                                 43               $rule_ok = 1;
292           12                                 35               push @{$self->{atleast1}}, \@participants;
              12                                 65   
293           12                                 38               MKDEBUG && _d(@participants, 'require at least one');
294                                                            }
295   ***     12     50                          69            if ( $opt =~ m/default to/ ) {
296   ***      0                                  0               $rule_ok = 1;
297   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
298   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
299                                                            }
300   ***     12     50                          63            if ( $opt =~ m/restricted to option groups/ ) {
301   ***      0                                  0               $rule_ok = 1;
302   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
303   ***      0                                  0               my @groups = split(',', $groups);
304   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
305   ***      0                                  0                  s/\s+//;
306   ***      0                                  0                  $_ => 1;
307                                                               } @groups;
308                                                            }
309                                                   
310   ***     12     50                          80            die "Unrecognized option rule: $opt" unless $rule_ok;
311                                                         }
312                                                      }
313                                                   
314           12                                 83      foreach my $long ( keys %disables ) {
315   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
316   ***      0                                  0         $self->{disables}->{$long} = \@participants;
317   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
318                                                      }
319                                                   
320           12                                 71      return; 
321                                                   }
322                                                   
323                                                   sub _get_participants {
324           12                   12            62      my ( $self, $str ) = @_;
325           12                                 41      my @participants;
326           12                                147      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
327   ***     48     50                         252         die "Option --$long does not exist while processing rule $str"
328                                                            unless exists $self->{opts}->{$long};
329           48                                195         push @participants, $long;
330                                                      }
331           12                                 38      MKDEBUG && _d('Participants for', $str, ':', @participants);
332           12                                 94      return @participants;
333                                                   }
334                                                   
335                                                   sub opts {
336   ***      0                    0             0      my ( $self ) = @_;
337   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
338   ***      0                                  0      return %opts;
339                                                   }
340                                                   
341                                                   sub short_opts {
342   ***      0                    0             0      my ( $self ) = @_;
343   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
344   ***      0                                  0      return %short_opts;
345                                                   }
346                                                   
347                                                   sub set_defaults {
348   ***      0                    0             0      my ( $self, %defaults ) = @_;
349   ***      0                                  0      $self->{defaults} = {};
350   ***      0                                  0      foreach my $long ( keys %defaults ) {
351   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
352                                                            unless exists $self->{opts}->{$long};
353   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
354   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
355                                                      }
356   ***      0                                  0      return;
357                                                   }
358                                                   
359                                                   sub get_defaults {
360   ***      0                    0             0      my ( $self ) = @_;
361   ***      0                                  0      return $self->{defaults};
362                                                   }
363                                                   
364                                                   sub get_groups {
365   ***      0                    0             0      my ( $self ) = @_;
366   ***      0                                  0      return $self->{groups};
367                                                   }
368                                                   
369                                                   sub _set_option {
370           33                   33           159      my ( $self, $opt, $val ) = @_;
371   ***     33      0                          79      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
372                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
373                                                               : die "Getopt::Long gave a nonexistent option: $opt";
374                                                   
375           33                                 71      $opt = $self->{opts}->{$long};
376   ***     33     50                         209      if ( $opt->{is_cumulative} ) {
377   ***      0                                  0         $opt->{value}++;
378                                                      }
379                                                      else {
380           33                                137         $opt->{value} = $val;
381                                                      }
382           33                                124      $opt->{got} = 1;
383           33                                137      MKDEBUG && _d('Got option', $long, '=', $val);
384                                                   }
385                                                   
386                                                   sub get_opts {
387           12                   12            59      my ( $self ) = @_; 
388                                                   
389           12                                 39      foreach my $long ( keys %{$self->{opts}} ) {
              12                                145   
390          492                               2118         $self->{opts}->{$long}->{got} = 0;
391   ***    492     50                        4322         $self->{opts}->{$long}->{value}
                    100                               
392                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
393                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
394                                                            : undef;
395                                                      }
396           12                                 80      $self->{got_opts} = 0;
397                                                   
398           12                                 52      $self->{errors} = [];
399                                                   
400   ***     12     50     33                  169      if ( @ARGV && $ARGV[0] eq "--config" ) {
401   ***      0                                  0         shift @ARGV;
402   ***      0                                  0         $self->_set_option('config', shift @ARGV);
403                                                      }
404   ***     12     50                          84      if ( $self->has('config') ) {
405           12                                 36         my @extra_args;
406           12                                 77         foreach my $filename ( split(',', $self->get('config')) ) {
407           48                                134            eval {
408           48                                236               push @extra_args, $self->_read_config_file($filename);
409                                                            };
410   ***     48     50                         314            if ( $EVAL_ERROR ) {
411   ***     48     50                         213               if ( $self->got('config') ) {
412   ***      0                                  0                  die $EVAL_ERROR;
413                                                               }
414                                                               elsif ( MKDEBUG ) {
415                                                                  _d($EVAL_ERROR);
416                                                               }
417                                                            }
418                                                         }
419           12                                 62         unshift @ARGV, @extra_args;
420                                                      }
421                                                   
422           12                                106      Getopt::Long::Configure('no_ignore_case', 'bundling');
423                                                      GetOptions(
424          480                   33          3340         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              33                                176   
             492                               2002   
425           12                                 99         grep   { $_->{long} ne 'config' } # --config is handled specially above.
426   ***     12     50                          48         values %{$self->{opts}}
427                                                      ) or $self->save_error('Error parsing options');
428                                                   
429   ***     12     50     33                  808      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
430   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
431                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
432                                                               or die "Cannot print: $OS_ERROR";
433   ***      0                                  0         exit 0;
434                                                      }
435                                                   
436   ***     12     50     66                  116      if ( @ARGV && $self->{strict} ) {
437   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
438                                                      }
439                                                   
440           12                                 39      foreach my $mutex ( @{$self->{mutex}} ) {
              12                                 76   
441   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
442   ***      0      0                           0         if ( @set > 1 ) {
443   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
444   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
445                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
446                                                                    . ' are mutually exclusive.';
447   ***      0                                  0            $self->save_error($err);
448                                                         }
449                                                      }
450                                                   
451           12                                 38      foreach my $required ( @{$self->{atleast1}} ) {
              12                                 61   
452           12                                 48         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
              48                                254   
453   ***     12     50                          82         if ( @set == 0 ) {
454   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
455   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
456                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
457   ***      0                                  0            $self->save_error("Specify at least one of $err");
458                                                         }
459                                                      }
460                                                   
461           12                                 38      foreach my $long ( keys %{$self->{opts}} ) {
              12                                128   
462          492                               1973         my $opt = $self->{opts}->{$long};
463          492    100                        2802         if ( $opt->{got} ) {
      ***            50                               
464   ***     33     50                         171            if ( exists $self->{disables}->{$long} ) {
465   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
466   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
467   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
468                                                                  'because', $long,'disables them');
469                                                            }
470                                                   
471   ***     33     50                         189            if ( exists $self->{allowed_groups}->{$long} ) {
472                                                   
473   ***      0                                  0               my @restricted_groups = grep {
474   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
475   ***      0                                  0               } keys %{$self->{groups}};
476                                                   
477   ***      0                                  0               my @restricted_opts;
478   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
479   ***      0                                  0                  RESTRICTED_OPT:
480   ***      0                                  0                  foreach my $restricted_opt (
481                                                                     keys %{$self->{groups}->{$restricted_group}} )
482                                                                  {
483   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
484   ***      0      0                           0                     push @restricted_opts, $restricted_opt
485                                                                        if $self->{opts}->{$restricted_opt}->{got};
486                                                                  }
487                                                               }
488                                                   
489   ***      0      0                           0               if ( @restricted_opts ) {
490   ***      0                                  0                  my $err;
491   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
492   ***      0                                  0                     $err = "--$restricted_opts[0]";
493                                                                  }
494                                                                  else {
495   ***      0                                  0                     $err = join(', ',
496   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
497   ***      0                                  0                               grep { $_ } 
498                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
499                                                                            )
500                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
501                                                                  }
502   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
503                                                               }
504                                                            }
505                                                   
506                                                         }
507                                                         elsif ( $opt->{is_required} ) { 
508   ***      0                                  0            $self->save_error("Required option --$long must be specified");
509                                                         }
510                                                   
511          492                               1847         $self->_validate_type($opt);
512                                                      }
513                                                   
514           12                                 82      $self->{got_opts} = 1;
515           12                                 38      return;
516                                                   }
517                                                   
518                                                   sub _validate_type {
519          492                  492          1826      my ( $self, $opt ) = @_;
520   ***    492    100     66                 4453      return unless $opt && $opt->{type};
521          372                               1270      my $val = $opt->{value};
522                                                   
523          372    100    100                 9774      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
524            4                                 11         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
525            4                                 39         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
526   ***      4     50                          21         if ( !$suffix ) {
527            4                                 20            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
528   ***      4            50                   32            $suffix = $s || 's';
529            4                                 11            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
530                                                               $opt->{long}, '(value:', $val, ')');
531                                                         }
532   ***      4     50                          21         if ( $suffix =~ m/[smhd]/ ) {
533   ***      4      0                          17            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***            50                               
534                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
535                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
536                                                                 :                  $num * 86400;   # Days
537   ***      4            50                   36            $opt->{value} = ($prefix || '') . $val;
538            4                                 12            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
539                                                         }
540                                                         else {
541   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
542                                                         }
543                                                      }
544                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
545   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
546   ***      0                                  0         my $prev = {};
547   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
548   ***      0      0                           0         if ( $from_key ) {
549   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
550   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
551                                                         }
552   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
553   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
554                                                      }
555                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
556   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
557   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
558   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
559   ***      0      0                           0         if ( defined $num ) {
560   ***      0      0                           0            if ( $factor ) {
561   ***      0                                  0               $num *= $factor_for{$factor};
562   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
563                                                                  'to num', $num, '* factor', $factor);
564                                                            }
565   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
566                                                         }
567                                                         else {
568   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
569                                                         }
570                                                      }
571                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
572   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
573                                                      }
574                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
575   ***     12            50                  192         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
576                                                      }
577                                                      else {
578          356                                900         MKDEBUG && _d('Nothing to validate for option',
579                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
580                                                      }
581                                                   
582          372                               1342      return;
583                                                   }
584                                                   
585                                                   sub get {
586          369                  369          1583      my ( $self, $opt ) = @_;
587          369    100                        1737      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
588   ***    369     50     33                 3581      die "Option $opt does not exist"
589                                                         unless $long && exists $self->{opts}->{$long};
590          369                               3200      return $self->{opts}->{$long}->{value};
591                                                   }
592                                                   
593                                                   sub got {
594           72                   72           337      my ( $self, $opt ) = @_;
595   ***     72     50                         371      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
596   ***     72     50     33                  719      die "Option $opt does not exist"
597                                                         unless $long && exists $self->{opts}->{$long};
598           72                                539      return $self->{opts}->{$long}->{got};
599                                                   }
600                                                   
601                                                   sub has {
602           28                   28           159      my ( $self, $opt ) = @_;
603           28    100                         205      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
604           28    100                         361      return defined $long ? exists $self->{opts}->{$long} : 0;
605                                                   }
606                                                   
607                                                   sub set {
608           22                   22           107      my ( $self, $opt, $val ) = @_;
609   ***     22     50                          98      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
610   ***     22     50     33                  217      die "Option $opt does not exist"
611                                                         unless $long && exists $self->{opts}->{$long};
612           22                                 95      $self->{opts}->{$long}->{value} = $val;
613           22                                 71      return;
614                                                   }
615                                                   
616                                                   sub save_error {
617   ***      0                    0             0      my ( $self, $error ) = @_;
618   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
619                                                   }
620                                                   
621                                                   sub errors {
622   ***      0                    0             0      my ( $self ) = @_;
623   ***      0                                  0      return $self->{errors};
624                                                   }
625                                                   
626                                                   sub prompt {
627   ***      0                    0             0      my ( $self ) = @_;
628   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
629                                                   }
630                                                   
631                                                   sub descr {
632   ***      0                    0             0      my ( $self ) = @_;
633   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
634                                                                 . "  For more details, please use the --help option, "
635                                                                 . "or try 'perldoc $PROGRAM_NAME' "
636                                                                 . "for complete documentation.";
637   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
638   ***      0                                  0      $descr =~ s/ +$//mg;
639   ***      0                                  0      return $descr;
640                                                   }
641                                                   
642                                                   sub usage_or_errors {
643           12                   12            47      my ( $self ) = @_;
644   ***     12     50                          74      if ( $self->{opts}->{help}->{got} ) {
      ***     12     50                          71   
645   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
646   ***      0                                  0         exit 0;
647                                                      }
648                                                      elsif ( scalar @{$self->{errors}} ) {
649   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
650   ***      0                                  0         exit 0;
651                                                      }
652           12                                 37      return;
653                                                   }
654                                                   
655                                                   sub print_errors {
656   ***      0                    0             0      my ( $self ) = @_;
657   ***      0                                  0      my $usage = $self->prompt() . "\n";
658   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
659   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
660                                                                 . "\n";
661                                                      }
662   ***      0                                  0      return $usage . "\n" . $self->descr();
663                                                   }
664                                                   
665                                                   sub print_usage {
666   ***      0                    0             0      my ( $self ) = @_;
667   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
668   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
669                                                   
670   ***      0      0                           0      my $maxl = max(
671   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
672                                                         @opts);
673                                                   
674   ***      0      0                           0      my $maxs = max(0,
675   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
676   ***      0                                  0         values %{$self->{short_opts}});
677                                                   
678   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
679   ***      0                                  0      my $rcol = 80 - $lcol - 6;
680   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
681                                                   
682   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
683                                                   
684   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
685                                                   
686   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
687   ***      0                                  0      push @groups, 'default';
688                                                   
689   ***      0                                  0      foreach my $group ( reverse @groups ) {
690   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
691   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
692   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
693                                                            grep { $_->{group} eq $group }
694                                                            @opts )
695                                                         {
696   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
697   ***      0                                  0            my $short = $opt->{short};
698   ***      0                                  0            my $desc  = $opt->{desc};
699   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
700   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
701   ***      0             0                    0               $s    ||= 's';
702   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
703   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
704                                                                      . "d=days; if no suffix, $s is used.";
705                                                            }
706   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
707   ***      0                                  0            $desc =~ s/ +$//mg;
708   ***      0      0                           0            if ( $short ) {
709   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
710                                                            }
711                                                            else {
712   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
713                                                            }
714                                                         }
715                                                      }
716                                                   
717   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
718   ***      0                                  0         $usage .= "\nRules:\n\n";
719   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
720                                                      }
721   ***      0      0                           0      if ( $self->{dp} ) {
722   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
723                                                      }
724   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
725   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
726   ***      0                                  0         my $val   = $opt->{value};
727   ***      0             0                    0         my $type  = $opt->{type} || '';
728   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
729   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
730                                                                   : !defined $val             ? '(No value)'
731                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
732                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
733                                                                   : $type =~ m/A|a/           ? join(',', @$val)
734                                                                   :                             $val;
735   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
736                                                      }
737   ***      0                                  0      return $usage;
738                                                   }
739                                                   
740                                                   sub prompt_noecho {
741   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
742   ***      0                                  0      my ( $prompt ) = @_;
743   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
744   ***      0      0                           0      print $prompt
745                                                         or die "Cannot print: $OS_ERROR";
746   ***      0                                  0      my $response;
747   ***      0                                  0      eval {
748   ***      0                                  0         require Term::ReadKey;
749   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
750   ***      0                                  0         chomp($response = <STDIN>);
751   ***      0                                  0         Term::ReadKey::ReadMode('normal');
752   ***      0      0                           0         print "\n"
753                                                            or die "Cannot print: $OS_ERROR";
754                                                      };
755   ***      0      0                           0      if ( $EVAL_ERROR ) {
756   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
757                                                      }
758   ***      0                                  0      return $response;
759                                                   }
760                                                   
761                                                   if ( MKDEBUG ) {
762                                                      print '# ', $^X, ' ', $], "\n";
763                                                      my $uname = `uname -a`;
764                                                      if ( $uname ) {
765                                                         $uname =~ s/\s+/ /g;
766                                                         print "# $uname\n";
767                                                      }
768                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
769                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
770                                                         ($main::SVN_REV || ''), __LINE__);
771                                                      print('# Arguments: ',
772                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
773                                                   }
774                                                   
775                                                   sub _read_config_file {
776           48                   48           215      my ( $self, $filename ) = @_;
777   ***     48     50                         128      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
778   ***      0                                  0      my @args;
779   ***      0                                  0      my $prefix = '--';
780   ***      0                                  0      my $parse  = 1;
781                                                   
782                                                      LINE:
783   ***      0                                  0      while ( my $line = <$fh> ) {
784   ***      0                                  0         chomp $line;
785   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
786   ***      0                                  0         $line =~ s/\s+#.*$//g;
787   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
788   ***      0      0                           0         if ( $line eq '--' ) {
789   ***      0                                  0            $prefix = '';
790   ***      0                                  0            $parse  = 0;
791   ***      0                                  0            next LINE;
792                                                         }
793   ***      0      0      0                    0         if ( $parse
      ***             0                               
794                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
795                                                         ) {
796   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
797                                                         }
798                                                         elsif ( $line =~ m/./ ) {
799   ***      0                                  0            push @args, $line;
800                                                         }
801                                                         else {
802   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
803                                                         }
804                                                      }
805   ***      0                                  0      close $fh;
806   ***      0                                  0      return @args;
807                                                   }
808                                                   
809                                                   sub read_para_after {
810   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
811   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
812   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
813   ***      0                                  0      my $para;
814   ***      0                                  0      while ( $para = <$fh> ) {
815   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
816   ***      0                                  0         last;
817                                                      }
818   ***      0                                  0      while ( $para = <$fh> ) {
819   ***      0      0                           0         next unless $para =~ m/$regex/;
820   ***      0                                  0         last;
821                                                      }
822   ***      0                                  0      $para = <$fh>;
823   ***      0                                  0      chomp($para);
824   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
825   ***      0                                  0      return $para;
826                                                   }
827                                                   
828                                                   sub clone {
829   ***      0                    0             0      my ( $self ) = @_;
830                                                   
831   ***      0                                  0      my %clone = map {
832   ***      0                                  0         my $hashref  = $self->{$_};
833   ***      0                                  0         my $val_copy = {};
834   ***      0                                  0         foreach my $key ( keys %$hashref ) {
835   ***      0                                  0            my $ref = ref $hashref->{$key};
836   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
837   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
838   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
839                                                                              : $hashref->{$key};
840                                                         }
841   ***      0                                  0         $_ => $val_copy;
842                                                      } qw(opts short_opts defaults);
843                                                   
844   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
845   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
846                                                      }
847                                                   
848   ***      0                                  0      return bless \%clone;     
849                                                   }
850                                                   
851                                                   sub _d {
852   ***      0                    0             0      my ($package, undef, $line) = caller 0;
853   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
854   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
855                                                           @_;
856   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
857                                                   }
858                                                   
859                                                   1;
860                                                   
861                                                   # ###########################################################################
862                                                   # End OptionParser package
863                                                   # ###########################################################################
864                                                   
865                                                   # ###########################################################################
866                                                   # VersionParser package 5266
867                                                   # ###########################################################################
868                                                   package VersionParser;
869                                                   
870            5                    5            51   use strict;
               5                                 14   
               5                                 42   
871            5                    5            31   use warnings FATAL => 'all';
               5                                 11   
               5                                 37   
872                                                   
873            5                    5            31   use English qw(-no_match_vars);
               5                                 12   
               5                                 31   
874                                                   
875   ***      5            50      5            32   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 12   
               5                                 82   
876                                                   
877                                                   sub new {
878           12                   12            62      my ( $class ) = @_;
879           12                                 91      bless {}, $class;
880                                                   }
881                                                   
882                                                   sub parse {
883   ***      0                    0             0      my ( $self, $str ) = @_;
884   ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
885   ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
886   ***      0                                  0      return $result;
887                                                   }
888                                                   
889                                                   sub version_ge {
890   ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
891   ***      0      0                           0      if ( !$self->{$dbh} ) {
892   ***      0                                  0         $self->{$dbh} = $self->parse(
893                                                            $dbh->selectrow_array('SELECT VERSION()'));
894                                                      }
895   ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
896   ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
897   ***      0                                  0      return $result;
898                                                   }
899                                                   
900                                                   sub _d {
901   ***      0                    0             0      my ($package, undef, $line) = caller 0;
902   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
903   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
904                                                           @_;
905   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
906                                                   }
907                                                   
908                                                   1;
909                                                   
910                                                   # ###########################################################################
911                                                   # End VersionParser package
912                                                   # ###########################################################################
913                                                   
914                                                   # ###########################################################################
915                                                   # DSNParser package 5266
916                                                   # ###########################################################################
917                                                   package DSNParser;
918                                                   
919            5                    5            39   use strict;
               5                                 17   
               5                                 28   
920            5                    5            30   use warnings FATAL => 'all';
               5                                 12   
               5                                 26   
921            5                    5            31   use English qw(-no_match_vars);
               5                                 12   
               5                                 24   
922            5                    5            34   use Data::Dumper;
               5                                 11   
               5                                 41   
923                                                   $Data::Dumper::Indent    = 0;
924                                                   $Data::Dumper::Quotekeys = 0;
925                                                   
926                                                   eval {
927                                                      require DBI;
928                                                   };
929                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
930                                                   
931   ***      5            50      5            35   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 12   
               5                                 63   
932                                                   
933                                                   sub new {
934           16                   16           124      my ( $class, @opts ) = @_;
935           16                                580      my $self = {
936                                                         opts => {
937                                                            A => {
938                                                               desc => 'Default character set',
939                                                               dsn  => 'charset',
940                                                               copy => 1,
941                                                            },
942                                                            D => {
943                                                               desc => 'Database to use',
944                                                               dsn  => 'database',
945                                                               copy => 1,
946                                                            },
947                                                            F => {
948                                                               desc => 'Only read default options from the given file',
949                                                               dsn  => 'mysql_read_default_file',
950                                                               copy => 1,
951                                                            },
952                                                            h => {
953                                                               desc => 'Connect to host',
954                                                               dsn  => 'host',
955                                                               copy => 1,
956                                                            },
957                                                            p => {
958                                                               desc => 'Password to use when connecting',
959                                                               dsn  => 'password',
960                                                               copy => 1,
961                                                            },
962                                                            P => {
963                                                               desc => 'Port number to use for connection',
964                                                               dsn  => 'port',
965                                                               copy => 1,
966                                                            },
967                                                            S => {
968                                                               desc => 'Socket file to use for connection',
969                                                               dsn  => 'mysql_socket',
970                                                               copy => 1,
971                                                            },
972                                                            u => {
973                                                               desc => 'User for login if not current user',
974                                                               dsn  => 'user',
975                                                               copy => 1,
976                                                            },
977                                                         },
978                                                      };
979           16                                100      foreach my $opt ( @opts ) {
980   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
981   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
982                                                      }
983           16                                144      return bless $self, $class;
984                                                   }
985                                                   
986                                                   sub prop {
987           18                   18           111      my ( $self, $prop, $value ) = @_;
988   ***     18     50                         110      if ( @_ > 2 ) {
989   ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
990   ***      0                                  0         $self->{$prop} = $value;
991                                                      }
992           18                                179      return $self->{$prop};
993                                                   }
994                                                   
995                                                   sub parse {
996            6                    6           249      my ( $self, $dsn, $prev, $defaults ) = @_;
997   ***      6     50                          42      if ( !$dsn ) {
998   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
999   ***      0                                  0         return;
1000                                                     }
1001           6                                 20      MKDEBUG && _d('Parsing', $dsn);
1002  ***      6            50                   34      $prev     ||= {};
1003  ***      6            50                   38      $defaults ||= {};
1004           6                                 16      my %given_props;
1005           6                                 22      my %final_props;
1006           6                                 37      my %opts = %{$self->{opts}};
               6                                 80   
1007                                                  
1008           6                                 66      foreach my $dsn_part ( split(/,/, $dsn) ) {
1009  ***     18     50                         177         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1010          18                                 95            $given_props{$prop_key} = $prop_val;
1011                                                        }
1012                                                        else {
1013  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1014  ***      0                                  0            $given_props{h} = $dsn_part;
1015                                                        }
1016                                                     }
1017                                                  
1018           6                                 43      foreach my $key ( keys %opts ) {
1019          48                                119         MKDEBUG && _d('Finding value for', $key);
1020          48                                224         $final_props{$key} = $given_props{$key};
1021  ***     48     50     66                  523         if (   !defined $final_props{$key}
      ***                   33                        
1022                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1023                                                        {
1024  ***      0                                  0            $final_props{$key} = $prev->{$key};
1025  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1026                                                        }
1027          48    100                         245         if ( !defined $final_props{$key} ) {
1028          30                                126            $final_props{$key} = $defaults->{$key};
1029          30                                106            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1030                                                        }
1031                                                     }
1032                                                  
1033           6                                 38      foreach my $key ( keys %given_props ) {
1034  ***     18     50                          89         die "Unrecognized DSN part '$key' in '$dsn'\n"
1035                                                           unless exists $opts{$key};
1036                                                     }
1037  ***      6     50                          42      if ( (my $required = $self->prop('required')) ) {
1038  ***      0                                  0         foreach my $key ( keys %$required ) {
1039  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1040                                                        }
1041                                                     }
1042                                                  
1043           6                                 50      return \%final_props;
1044                                                  }
1045                                                  
1046                                                  sub parse_options {
1047           2                    2            16      my ( $self, $o ) = @_;
1048  ***      2     50                          22      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1049           2                                 16      my $dsn_string
1050                                                        = join(',',
1051          16    100                          92             map  { "$_=".$o->get($_); }
1052           2                                 24             grep { $o->has($_) && $o->get($_) }
1053           2                                 10             keys %{$self->{opts}}
1054                                                          );
1055           2                                 14      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1056           2                                 23      return $self->parse($dsn_string);
1057                                                  }
1058                                                  
1059                                                  sub as_string {
1060  ***      0                    0             0      my ( $self, $dsn ) = @_;
1061  ***      0      0                           0      return $dsn unless ref $dsn;
1062  ***      0      0                           0      return join(',',
1063  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1064  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1065                                                        sort keys %$dsn );
1066                                                  }
1067                                                  
1068                                                  sub usage {
1069  ***      0                    0             0      my ( $self ) = @_;
1070  ***      0                                  0      my $usage
1071                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1072                                                        . "  KEY  COPY  MEANING\n"
1073                                                        . "  ===  ====  =============================================\n";
1074  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1075  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1076  ***      0      0      0                    0         $usage .= "  $key    "
1077                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1078                                                               .  ($opts{$key}->{desc} || '[No description]')
1079                                                               . "\n";
1080                                                     }
1081  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1082  ***      0                                  0      return $usage;
1083                                                  }
1084                                                  
1085                                                  sub get_cxn_params {
1086           6                    6            63      my ( $self, $info ) = @_;
1087           6                                 20      my $dsn;
1088           6                                 21      my %opts = %{$self->{opts}};
               6                                 68   
1089  ***      6            50                   39      my $driver = $self->prop('dbidriver') || '';
1090  ***      6     50                          34      if ( $driver eq 'Pg' ) {
1091  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1092  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1093  ***      0             0                    0                        grep { defined $info->{$_} }
1094                                                                       qw(h P));
1095                                                     }
1096                                                     else {
1097          10                                100         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1098          30                                135            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1099  ***      6            50                   95                        grep { defined $info->{$_} }
1100                                                                       qw(F h P S A))
1101                                                           . ';mysql_read_default_group=client';
1102                                                     }
1103           6                                 24      MKDEBUG && _d($dsn);
1104           6                                 80      return ($dsn, $info->{u}, $info->{p});
1105                                                  }
1106                                                  
1107                                                  sub fill_in_dsn {
1108  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1109  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1110  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1111  ***      0                                  0      $user =~ s/@.*//;
1112  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1113  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1114  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1115  ***      0             0                    0      $dsn->{u} ||= $user;
1116  ***      0             0                    0      $dsn->{D} ||= $db;
1117                                                  }
1118                                                  
1119                                                  sub get_dbh {
1120           6                    6            46      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1121  ***      6            50                   33      $opts ||= {};
1122  ***      6     50                          97      my $defaults = {
1123                                                        AutoCommit         => 0,
1124                                                        RaiseError         => 1,
1125                                                        PrintError         => 0,
1126                                                        ShowErrorStatement => 1,
1127                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1128                                                     };
1129           6                                 38      @{$defaults}{ keys %$opts } = values %$opts;
               6                                 29   
1130                                                  
1131  ***      6     50                          33      if ( !$have_dbi ) {
1132  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1133                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1134                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1135                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1136                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1137                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1138                                                  
1139                                                     }
1140                                                  
1141           6                                 23      my $dbh;
1142           6                                 20      my $tries = 2;
1143  ***      6            66                   86      while ( !$dbh && $tries-- ) {
1144                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1145           6                                 15            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1146                                                  
1147           6                                 23         eval {
1148           6                                 82            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1149                                                  
1150  ***      6     50                          81            if ( $cxn_string =~ m/mysql/i ) {
1151           6                                 20               my $sql;
1152                                                  
1153           6                                 26               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1154                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1155           6                                 18               MKDEBUG && _d($dbh, ':', $sql);
1156           6                                714               $dbh->do($sql);
1157                                                  
1158  ***      6     50                          67               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1159  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1160  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1161  ***      0                                  0                  $dbh->do($sql);
1162  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1163  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1164  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1165                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1166                                                                 }
1167                                                                 else {
1168  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1169                                                                 }
1170                                                              }
1171                                                  
1172  ***      6     50                          45               if ( $self->prop('set-vars') ) {
1173  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1174  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1175  ***      0                                  0                  $dbh->do($sql);
1176                                                              }
1177                                                           }
1178                                                        };
1179  ***      6     50     33                   75         if ( !$dbh && $EVAL_ERROR ) {
1180  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1181  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1182  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1183  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1184                                                           }
1185                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1186  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1187                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1188                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1189                                                                 . "DBD::mysql is not installed, try:\n"
1190                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1191                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1192                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1193                                                           }
1194  ***      0      0                           0            if ( !$tries ) {
1195  ***      0                                  0               die $EVAL_ERROR;
1196                                                           }
1197                                                        }
1198                                                     }
1199                                                  
1200           6                                 15      MKDEBUG && _d('DBH info: ',
1201                                                        $dbh,
1202                                                        Dumper($dbh->selectrow_hashref(
1203                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1204                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1205                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1206                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1207                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1208                                                        '$DBI::VERSION:',        $DBI::VERSION,
1209                                                     );
1210                                                  
1211           6                                 44      return $dbh;
1212                                                  }
1213                                                  
1214                                                  sub get_hostname {
1215  ***      0                    0             0      my ( $self, $dbh ) = @_;
1216  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1217  ***      0                                  0         return $host;
1218                                                     }
1219  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1220                                                        'SELECT /*!50038 @@hostname, */ 1');
1221  ***      0                                  0      return $hostname;
1222                                                  }
1223                                                  
1224                                                  sub disconnect {
1225  ***      0                    0             0      my ( $self, $dbh ) = @_;
1226  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1227  ***      0                                  0      $dbh->disconnect;
1228                                                  }
1229                                                  
1230                                                  sub print_active_handles {
1231  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1232  ***      0             0                    0      $level ||= 0;
1233  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1234                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1235                                                        or die "Cannot print: $OS_ERROR";
1236  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1237  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1238                                                     }
1239                                                  }
1240                                                  
1241                                                  sub copy {
1242  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1243  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1244  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1245  ***      0                                  0      my %new_dsn = map {
1246  ***      0                                  0         my $key = $_;
1247  ***      0                                  0         my $val;
1248  ***      0      0                           0         if ( $args{overwrite} ) {
1249  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1250                                                        }
1251                                                        else {
1252  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1253                                                        }
1254  ***      0                                  0         $key => $val;
1255  ***      0                                  0      } keys %{$self->{opts}};
1256  ***      0                                  0      return \%new_dsn;
1257                                                  }
1258                                                  
1259                                                  sub _d {
1260  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1261  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1262  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1263                                                          @_;
1264  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1265                                                  }
1266                                                  
1267                                                  1;
1268                                                  
1269                                                  # ###########################################################################
1270                                                  # End DSNParser package
1271                                                  # ###########################################################################
1272                                                  
1273                                                  # ###########################################################################
1274                                                  # Daemon package 5266
1275                                                  # ###########################################################################
1276                                                  
1277                                                  package Daemon;
1278                                                  
1279           5                    5            45   use strict;
               5                                 13   
               5                                 32   
1280           5                    5            30   use warnings FATAL => 'all';
               5                                 12   
               5                                 26   
1281                                                  
1282           5                    5            29   use POSIX qw(setsid);
               5                                 11   
               5                                483   
1283           5                    5            34   use English qw(-no_match_vars);
               5                                 11   
               5                                 26   
1284                                                  
1285  ***      5            50      5            30   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 12   
               5                                 66   
1286                                                  
1287                                                  sub new {
1288  ***      0                    0             0      my ( $class, %args ) = @_;
1289  ***      0                                  0      foreach my $arg ( qw(o) ) {
1290  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1291                                                     }
1292  ***      0                                  0      my $o = $args{o};
1293  ***      0      0                           0      my $self = {
      ***             0                               
1294                                                        o        => $o,
1295                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1296                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1297                                                     };
1298                                                  
1299  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1300                                                  
1301  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1302  ***      0                                  0      return bless $self, $class;
1303                                                  }
1304                                                  
1305                                                  sub daemonize {
1306  ***      0                    0             0      my ( $self ) = @_;
1307                                                  
1308  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1309  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1310  ***      0      0                           0      if ( $pid ) {
1311  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1312  ***      0                                  0         exit;
1313                                                     }
1314                                                  
1315  ***      0                                  0      $self->{child} = 1;
1316                                                  
1317  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1318  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1319                                                  
1320  ***      0                                  0      $self->_make_PID_file();
1321                                                  
1322  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
1323                                                  
1324  ***      0      0                           0      if ( -t STDIN ) {
1325  ***      0                                  0         close STDIN;
1326  ***      0      0                           0         open  STDIN, '/dev/null'
1327                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1328                                                     }
1329                                                  
1330  ***      0      0                           0      if ( $self->{log_file} ) {
1331  ***      0                                  0         close STDOUT;
1332  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1333                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1334                                                  
1335  ***      0                                  0         close STDERR;
1336  ***      0      0                           0         open  STDERR, ">&STDOUT"
1337                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1338                                                     }
1339                                                     else {
1340  ***      0      0                           0         if ( -t STDOUT ) {
1341  ***      0                                  0            close STDOUT;
1342  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
1343                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1344                                                        }
1345  ***      0      0                           0         if ( -t STDERR ) {
1346  ***      0                                  0            close STDERR;
1347  ***      0      0                           0            open  STDERR, '>', '/dev/null'
1348                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1349                                                        }
1350                                                     }
1351                                                  
1352  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1353  ***      0                                  0      return;
1354                                                  }
1355                                                  
1356                                                  sub check_PID_file {
1357  ***      0                    0             0      my ( $self, $file ) = @_;
1358  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1359  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1360  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1361  ***      0                                  0         my $pid;
1362  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1363  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1364  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1365  ***      0      0                           0         if ( $pid ) {
1366  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1367  ***      0      0                           0            if ( $pid_is_alive ) {
1368  ***      0                                  0               die "The PID file $PID_file already exists "
1369                                                                 . " and the PID that it contains, $pid, is running";
1370                                                           }
1371                                                           else {
1372  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1373                                                                 . "contains, $pid, is not running";
1374                                                           }
1375                                                        }
1376                                                        else {
1377  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1378                                                              . "contain a PID";
1379                                                        }
1380                                                     }
1381                                                     else {
1382  ***      0                                  0         MKDEBUG && _d('No PID file');
1383                                                     }
1384  ***      0                                  0      return;
1385                                                  }
1386                                                  
1387                                                  sub make_PID_file {
1388  ***      0                    0             0      my ( $self ) = @_;
1389  ***      0      0                           0      if ( exists $self->{child} ) {
1390  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1391                                                     }
1392  ***      0                                  0      $self->_make_PID_file();
1393  ***      0                                  0      $self->{rm_PID_file} = 1;
1394  ***      0                                  0      return;
1395                                                  }
1396                                                  
1397                                                  sub _make_PID_file {
1398  ***      0                    0             0      my ( $self ) = @_;
1399                                                  
1400  ***      0                                  0      my $PID_file = $self->{PID_file};
1401  ***      0      0                           0      if ( !$PID_file ) {
1402  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1403  ***      0                                  0         return;
1404                                                     }
1405                                                  
1406  ***      0                                  0      $self->check_PID_file();
1407                                                  
1408  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1409                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1410  ***      0      0                           0      print $PID_FH $PID
1411                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1412  ***      0      0                           0      close $PID_FH
1413                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1414                                                  
1415  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1416  ***      0                                  0      return;
1417                                                  }
1418                                                  
1419                                                  sub _remove_PID_file {
1420  ***      0                    0             0      my ( $self ) = @_;
1421  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1422  ***      0      0                           0         unlink $self->{PID_file}
1423                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1424  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1425                                                     }
1426                                                     else {
1427  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1428                                                     }
1429  ***      0                                  0      return;
1430                                                  }
1431                                                  
1432                                                  sub DESTROY {
1433  ***      0                    0             0      my ( $self ) = @_;
1434  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1435  ***      0                                  0      return;
1436                                                  }
1437                                                  
1438                                                  sub _d {
1439  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1440  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1441  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1442                                                          @_;
1443  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1444                                                  }
1445                                                  
1446                                                  1;
1447                                                  
1448                                                  # ###########################################################################
1449                                                  # End Daemon package
1450                                                  # ###########################################################################
1451                                                  
1452                                                  # ###########################################################################
1453                                                  # Transformers package 5266
1454                                                  # ###########################################################################
1455                                                  
1456                                                  package Transformers;
1457                                                  
1458           5                    5            34   use strict;
               5                                 14   
               5                                 24   
1459           5                    5            28   use warnings FATAL => 'all';
               5                                 11   
               5                                 25   
1460           5                    5            27   use English qw(-no_match_vars);
               5                                 16   
               5                                 23   
1461           5                    5            63   use Time::Local qw(timegm timelocal);
               5                                 17   
               5                                 57   
1462           5                    5            33   use Digest::MD5 qw(md5_hex);
               5                                 12   
               5                                 35   
1463                                                  
1464  ***      5            50      5            32   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 11   
               5                                 62   
1465                                                  
1466                                                  require Exporter;
1467                                                  our @ISA         = qw(Exporter);
1468                                                  our %EXPORT_TAGS = ();
1469                                                  our @EXPORT      = ();
1470                                                  our @EXPORT_OK   = qw(
1471                                                     micro_t
1472                                                     percentage_of
1473                                                     secs_to_time
1474                                                     shorten
1475                                                     ts
1476                                                     parse_timestamp
1477                                                     unix_timestamp
1478                                                     any_unix_timestamp
1479                                                     make_checksum
1480                                                  );
1481                                                  
1482                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1483                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
1484                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1485                                                  
1486                                                  sub micro_t {
1487  ***      0                    0             0      my ( $t, %args ) = @_;
1488  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1489  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1490  ***      0                                  0      my $f;
1491                                                  
1492  ***      0      0                           0      $t = 0 if $t < 0;
1493                                                  
1494  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1495                                                  
1496  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1497                                                  
1498  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1499  ***      0                                  0         $f = ($t * 1000000) . 'us';
1500                                                     }
1501                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1502  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1503  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1504                                                     }
1505                                                     elsif ($t >= 1) {
1506  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1507  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1508                                                     }
1509                                                     else {
1510  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1511                                                     }
1512                                                  
1513  ***      0                                  0      return $f;
1514                                                  }
1515                                                  
1516                                                  sub percentage_of {
1517  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1518  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1519  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1520  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1521                                                  }
1522                                                  
1523                                                  sub secs_to_time {
1524  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1525  ***      0             0                    0      $secs ||= 0;
1526  ***      0      0                           0      return '00:00' unless $secs;
1527                                                  
1528  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1529                                                            : $secs >= 3_600  ? 'h'
1530                                                            :                   'm';
1531                                                  
1532                                                     return
1533  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1534                                                           "%d+%02d:%02d:%02d",
1535                                                           int($secs / 86_400),
1536                                                           int(($secs % 86_400) / 3_600),
1537                                                           int(($secs % 3_600) / 60),
1538                                                           $secs % 60)
1539                                                        : $fmt eq 'h' ? sprintf(
1540                                                           "%02d:%02d:%02d",
1541                                                           int(($secs % 86_400) / 3_600),
1542                                                           int(($secs % 3_600) / 60),
1543                                                           $secs % 60)
1544                                                        : sprintf(
1545                                                           "%02d:%02d",
1546                                                           int(($secs % 3_600) / 60),
1547                                                           $secs % 60);
1548                                                  }
1549                                                  
1550                                                  sub shorten {
1551  ***      0                    0             0      my ( $num, %args ) = @_;
1552  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1553  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1554  ***      0                                  0      my $n = 0;
1555  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1556  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1557  ***      0                                  0         $num /= $d;
1558  ***      0                                  0         ++$n;
1559                                                     }
1560  ***      0      0      0                    0      return sprintf(
1561                                                        $num =~ m/\./ || $n
1562                                                           ? "%.${p}f%s"
1563                                                           : '%d',
1564                                                        $num, $units[$n]);
1565                                                  }
1566                                                  
1567                                                  sub ts {
1568          11                   11            50      my ( $time, $gmt ) = @_;
1569  ***     11     50                         258      my ( $sec, $min, $hour, $mday, $mon, $year )
1570                                                        = $gmt ? gmtime($time) : localtime($time);
1571          11                                 44      $mon  += 1;
1572          11                                 36      $year += 1900;
1573          11                                105      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1574                                                        $year, $mon, $mday, $hour, $min, $sec);
1575  ***     11     50                          87      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
1576  ***      0                                  0         $us = sprintf("%.6f", $us);
1577  ***      0                                  0         $us =~ s/^0\././;
1578  ***      0                                  0         $val .= $us;
1579                                                     }
1580          11                                 67      return $val;
1581                                                  }
1582                                                  
1583                                                  sub parse_timestamp {
1584  ***      0                    0             0      my ( $val ) = @_;
1585  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
1586                                                           = $val =~ m/^$mysql_ts$/ )
1587                                                     {
1588  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1589                                                                       . (defined $f ? '%02.6f' : '%02d'),
1590                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1591                                                     }
1592  ***      0                                  0      return $val;
1593                                                  }
1594                                                  
1595                                                  sub unix_timestamp {
1596  ***      0                    0             0      my ( $val, $gmt ) = @_;
1597  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
1598  ***      0      0                           0         $val = $gmt
1599                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
1600                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
1601  ***      0      0                           0         if ( defined $us ) {
1602  ***      0                                  0            $us = sprintf('%.6f', $us);
1603  ***      0                                  0            $us =~ s/^0\././;
1604  ***      0                                  0            $val .= $us;
1605                                                        }
1606                                                     }
1607  ***      0                                  0      return $val;
1608                                                  }
1609                                                  
1610                                                  sub any_unix_timestamp {
1611  ***      0                    0             0      my ( $val, $callback ) = @_;
1612                                                  
1613  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
1614  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1615                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1616                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1617                                                           : $suffix eq 'd' ? $n * 86400    # Days
1618                                                           :                  $n;           # default: Seconds
1619  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
1620  ***      0                                  0         return time - $n;
1621                                                     }
1622                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
1623  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
1624  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1625  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
1626                                                     }
1627                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
1628  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
1629  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1630  ***      0                                  0         return unix_timestamp($val);
1631                                                     }
1632                                                     else {
1633  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
1634  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
1635                                                     }
1636                                                  
1637  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
1638  ***      0                                  0      return;
1639                                                  }
1640                                                  
1641                                                  sub make_checksum {
1642  ***      0                    0             0      my ( $val ) = @_;
1643  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1644  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1645  ***      0                                  0      return $checksum;
1646                                                  }
1647                                                  
1648                                                  sub _d {
1649  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1650  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1651  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1652                                                          @_;
1653  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1654                                                  }
1655                                                  
1656                                                  1;
1657                                                  
1658                                                  # ###########################################################################
1659                                                  # End Transformers package
1660                                                  # ###########################################################################
1661                                                  
1662                                                  # ###########################################################################
1663                                                  # Processlist package 5266
1664                                                  # ###########################################################################
1665                                                  package Processlist;
1666                                                  
1667           5                    5            40   use strict;
               5                                 12   
               5                                 27   
1668           5                    5            32   use warnings FATAL => 'all';
               5                                 12   
               5                                 32   
1669           5                    5            30   use English qw(-no_match_vars);
               5                                 10   
               5                                 27   
1670                                                  
1671           5                    5            31   use Data::Dumper;
               5                                 10   
               5                                 36   
1672                                                  $Data::Dumper::Indent    = 1;
1673                                                  $Data::Dumper::Sortkeys  = 1;
1674                                                  $Data::Dumper::Quotekeys = 0;
1675                                                  
1676  ***      5            50      5            31   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 11   
               5                                 76   
1677                                                  use constant {
1678           5                                 59      ID      => 0,
1679                                                     USER    => 1,
1680                                                     HOST    => 2,
1681                                                     DB      => 3,
1682                                                     COMMAND => 4,
1683                                                     TIME    => 5,
1684                                                     STATE   => 6,
1685                                                     INFO    => 7,
1686                                                     START   => 8, # Calculated start time of statement
1687                                                     ETIME   => 9, # Exec time of SHOW PROCESSLIST (margin of error in START)
1688                                                     FSEEN   => 10, # First time ever seen
1689           5                    5            31   };
               5                                 13   
1690                                                  
1691                                                  sub new {
1692          12                   12            71      my ( $class, %args ) = @_;
1693          12                                113      my $self = {
1694                                                        prev_rows => [],
1695                                                        new_rows  => [],
1696                                                        curr_row  => undef,
1697                                                        prev_row  => undef,
1698                                                     };
1699          12                                111      return bless $self, $class;
1700                                                  }
1701                                                  
1702                                                  sub parse_event {
1703  ***      0                    0             0      my ( $self, %args ) = @_;
1704  ***      0                                  0      my @required_args = qw(misc);
1705  ***      0                                  0      foreach my $arg ( @required_args ) {
1706  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1707                                                     }
1708  ***      0                                  0      my ($misc) = @args{@required_args};
1709                                                  
1710  ***      0                                  0      my $code = $misc->{code};
1711  ***      0      0                           0      die "I need a code arg to misc" unless $code;
1712                                                  
1713  ***      0                                  0      my @curr;
1714  ***      0      0                           0      if ( $self->{curr_rows} ) {
1715  ***      0                                  0         MKDEBUG && _d('Current rows from last call');
1716  ***      0                                  0         @curr = @{$self->{curr_rows}};
      ***      0                                  0   
1717                                                     }
1718                                                     else {
1719  ***      0                                  0         my $rows = $code->();
1720  ***      0      0      0                    0         if ( $rows && scalar @$rows ) {
1721  ***      0                                  0            MKDEBUG && _d('Got new current rows');
1722  ***      0                                  0            @curr = sort { $a->[ID] <=> $b->[ID] } @$rows;
      ***      0                                  0   
1723                                                        }
1724                                                        else {
1725  ***      0                                  0            MKDEBUG && _d('No current rows');
1726                                                        }
1727                                                     }
1728                                                  
1729  ***      0             0                    0      my @prev = @{$self->{prev_rows} ||= []};
      ***      0                                  0   
1730  ***      0             0                    0      my @new  = @{$self->{new_rows}  ||= []};; # Becomes next invocation's @prev
      ***      0                                  0   
1731  ***      0                                  0      my $curr = $self->{curr_row}; # Rows from each source
1732  ***      0                                  0      my $prev = $self->{prev_row};
1733  ***      0                                  0      my $event;
1734                                                  
1735  ***      0                                  0      MKDEBUG && _d('Rows:', scalar @prev, 'prev,', scalar @curr, 'current');
1736                                                  
1737  ***      0      0      0                    0      if ( !$curr && @curr ) {
1738  ***      0                                  0         MKDEBUG && _d('Fetching row from curr');
1739  ***      0                                  0         $curr = shift @curr;
1740                                                     }
1741  ***      0      0      0                    0      if ( !$prev && @prev ) {
1742  ***      0                                  0         MKDEBUG && _d('Fetching row from prev');
1743  ***      0                                  0         $prev = shift @prev;
1744                                                     }
1745  ***      0      0      0                    0      if ( $curr || $prev ) {
1746  ***      0      0      0                    0         if ( $curr && $prev && $curr->[ID] == $prev->[ID] ) {
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
1747  ***      0                                  0            MKDEBUG && _d('$curr and $prev are the same cxn');
1748  ***      0      0                           0            my $fudge = $curr->[TIME] =~ m/\D/ ? 0.001 : 1; # Micro-precision?
1749  ***      0                                  0            my $is_new = 0;
1750  ***      0      0                           0            if ( $prev->[INFO] ) {
1751  ***      0      0      0                    0               if (!$curr->[INFO] || $prev->[INFO] ne $curr->[INFO]) {
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
1752  ***      0                                  0                  MKDEBUG && _d('$curr has a new query');
1753  ***      0                                  0                  $is_new = 1;
1754                                                              }
1755                                                              elsif (defined $curr->[TIME] && $curr->[TIME] < $prev->[TIME]) {
1756  ***      0                                  0                  MKDEBUG && _d('$curr time is less than $prev time');
1757  ***      0                                  0                  $is_new = 1;
1758                                                              }
1759                                                              elsif ( $curr->[INFO] && defined $curr->[TIME]
1760                                                                      && $misc->{time} - $curr->[TIME] - $prev->[START]
1761                                                                         - $prev->[ETIME] - $misc->{etime} > $fudge
1762                                                              ) {
1763  ***      0                                  0                  MKDEBUG && _d('$curr has same query that restarted');
1764  ***      0                                  0                  $is_new = 1;
1765                                                              }
1766  ***      0      0                           0               if ( $is_new ) {
1767  ***      0                                  0                  $event = $self->make_event($prev, $misc->{time});
1768                                                              }
1769                                                           }
1770  ***      0      0                           0            if ( $curr->[INFO] ) {
1771  ***      0      0      0                    0               if ( $prev->[INFO] && !$is_new ) {
1772  ***      0                                  0                  MKDEBUG && _d('Pushing old history item back onto $prev');
1773  ***      0                                  0                  push @new, [ @$prev ];
1774                                                              }
1775                                                              else {
1776  ***      0                                  0                  MKDEBUG && _d('Pushing new history item onto $prev');
1777  ***      0                                  0                  push @new,
1778                                                                    [ @$curr, int($misc->{time} - $curr->[TIME]),
1779                                                                       $misc->{etime}, $misc->{time} ];
1780                                                              }
1781                                                           }
1782  ***      0                                  0            $curr = $prev = undef; # Fetch another from each.
1783                                                        }
1784                                                        elsif ( !$curr
1785                                                                || ($curr && $prev && $curr->[ID] > $prev->[ID]) ) {
1786  ***      0                                  0            MKDEBUG && _d('$curr is not in $prev');
1787  ***      0                                  0            $event = $self->make_event($prev, $misc->{time});
1788  ***      0                                  0            $prev = undef;
1789                                                        }
1790                                                        else { # This else must be entered, to prevent infinite loops.
1791  ***      0                                  0            MKDEBUG && _d('$prev is not in $curr');
1792  ***      0      0      0                    0            if ( $curr->[INFO] && defined $curr->[TIME] ) {
1793  ***      0                                  0               MKDEBUG && _d('Pushing new history item onto $prev');
1794  ***      0                                  0               push @new,
1795                                                                 [ @$curr, int($misc->{time} - $curr->[TIME]),
1796                                                                    $misc->{etime}, $misc->{time} ];
1797                                                           }
1798  ***      0                                  0            $curr = undef; # No infinite loops.
1799                                                        }
1800                                                     }
1801                                                  
1802  ***      0                                  0      $self->{prev_rows} = \@new;
1803  ***      0                                  0      $self->{prev_row}  = $prev;
1804  ***      0      0                           0      $self->{curr_rows} = scalar @curr ? \@curr : undef;
1805  ***      0                                  0      $self->{curr_row}  = $curr;
1806                                                  
1807  ***      0                                  0      return $event;
1808                                                  }
1809                                                  
1810                                                  sub make_event {
1811  ***      0                    0             0      my ( $self, $row, $time ) = @_;
1812  ***      0                                  0      my $Query_time = $row->[TIME];
1813  ***      0      0                           0      if ( $row->[TIME] < $time - $row->[FSEEN] ) {
1814  ***      0                                  0         $Query_time = $time - $row->[FSEEN];
1815                                                     }
1816  ***      0                                  0      my $event = {
1817                                                        id         => $row->[ID],
1818                                                        db         => $row->[DB],
1819                                                        user       => $row->[USER],
1820                                                        host       => $row->[HOST],
1821                                                        arg        => $row->[INFO],
1822                                                        bytes      => length($row->[INFO]),
1823                                                        ts         => Transformers::ts($row->[START] + $row->[TIME]), # Query END time
1824                                                        Query_time => $Query_time,
1825                                                        Lock_time  => 0,               # TODO
1826                                                     };
1827  ***      0                                  0      MKDEBUG && _d('Properties of event:', Dumper($event));
1828  ***      0                                  0      return $event;
1829                                                  }
1830                                                  
1831                                                  sub _get_rows {
1832  ***      0                    0             0      my ( $self ) = @_;
1833  ***      0                                  0      my %rows = map { $_ => $self->{$_} }
      ***      0                                  0   
1834                                                        qw(prev_rows new_rows curr_row prev_row);
1835  ***      0                                  0      return \%rows;
1836                                                  }
1837                                                  
1838                                                  sub find {
1839          12                   12            94      my ( $self, $proclist, %find_spec ) = @_;
1840          12                                 42      MKDEBUG && _d('find specs:', Dumper(\%find_spec));
1841          12                                 41      my @matches;
1842                                                     QUERY:
1843          12                                 66      foreach my $query ( @$proclist ) {
1844         458                                985         MKDEBUG && _d('Checking query', Dumper($query));
1845         458                               1196         my $matched = 0;
1846                                                  
1847  ***    458    100     50                 2685         if ( $find_spec{busy_time} && ($query->{Command} || '') eq 'Query' ) {
      ***                   66                        
1848         104    100                         470            if ( $query->{Time} < $find_spec{busy_time} ) {
1849          91                                186               MKDEBUG && _d("Query isn't running long enough");
1850          91                                260               next QUERY;
1851                                                           }
1852          13                                 28            MKDEBUG && _d('Exceeds busy time');
1853          13                                 34            $matched++;
1854                                                        }
1855                                                  
1856  ***    367    100     50                 1720         if ( $find_spec{idle_time} && ($query->{Command} || '') eq 'Sleep' ) {
      ***                   66                        
1857  ***      1     50                           7            if ( $query->{Time} < $find_spec{idle_time} ) {
1858  ***      0                                  0               MKDEBUG && _d("Query isn't idle long enough");
1859  ***      0                                  0               next QUERY;
1860                                                           }
1861           1                                  2            MKDEBUG && _d('Exceeds idle time');
1862           1                                  4            $matched++;
1863                                                        }
1864                                                  
1865                                                        PROPERTY:
1866         367                               1347         foreach my $property ( qw(Id User Host db State Command Info) ) {
1867        1593                               4783            my $filter = "_find_match_$property";
1868        1593    100    100                10227            if ( defined $find_spec{ignore}->{$property}
1869                                                                && $self->$filter($query, $find_spec{ignore}->{$property}) ) {
1870         118                                258               MKDEBUG && _d('Query matches ignore', $property, 'spec');
1871         118                                390               next QUERY;
1872                                                           }
1873        1475    100                        7083            if ( defined $find_spec{match}->{$property} ) {
1874         236    100                        1173               if ( !$self->$filter($query, $find_spec{match}->{$property}) ) {
1875         202                                433                  MKDEBUG && _d('Query does not match', $property, 'spec');
1876         202                                665                  next QUERY;
1877                                                              }
1878          34                                 93               MKDEBUG && _d('Query matches', $property, 'spec');
1879          34                                136               $matched++;
1880                                                           }
1881                                                        }
1882  ***     47     50                         182         if ( $matched ) {
1883          47                                105            MKDEBUG && _d("Query matched one or more specs, adding");
1884          47                                140            push @matches, $query;
1885          47                                156            next QUERY;
1886                                                        }
1887  ***      0                                  0         MKDEBUG && _d('Query does not match any specs, ignoring');
1888                                                     } # QUERY
1889                                                  
1890          12    100    100                  132      if ( @matches && $find_spec{only_oldest} ) {
1891           9                                 49         my ( $oldest ) = reverse sort { $a->{Time} <=> $b->{Time} } @matches;
              66                                238   
1892           9                                 33         MKDEBUG && _d('Oldest query:', Dumper($oldest));
1893           9                                 38         @matches = $oldest;
1894                                                     }
1895                                                  
1896          12                                 72      return @matches;
1897                                                  }
1898                                                  
1899                                                  sub _find_match_Id {
1900           9                    9            66      my ( $self, $query, $property ) = @_;
1901  ***      9            33                  273      return defined $property && defined $query->{Id} && $query->{Id} == $property;
      ***                   66                        
1902                                                  }
1903                                                  
1904                                                  sub _find_match_User {
1905         365                  365          1503      my ( $self, $query, $property ) = @_;
1906  ***    365            33                 5925      return defined $property && defined $query->{User}
      ***                   66                        
1907                                                        && $query->{User} =~ m/$property/;
1908                                                  }
1909                                                  
1910                                                  sub _find_match_Host {
1911  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1912  ***      0             0                    0      return defined $property && defined $query->{Host}
      ***                    0                        
1913                                                        && $query->{Host} =~ m/$property/;
1914                                                  }
1915                                                  
1916                                                  sub _find_match_db {
1917  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1918  ***      0             0                    0      return defined $property && defined $query->{db}
      ***                    0                        
1919                                                        && $query->{db} =~ m/$property/;
1920                                                  }
1921                                                  
1922                                                  sub _find_match_State {
1923         480                  480          1989      my ( $self, $query, $property ) = @_;
1924  ***    480            66                 8793      return defined $property && defined $query->{State}
                           100                        
1925                                                        && $query->{State} =~ m/$property/;
1926                                                  }
1927                                                  
1928                                                  sub _find_match_Command {
1929          55                   55           248      my ( $self, $query, $property ) = @_;
1930  ***     55            33                 1018      return defined $property && defined $query->{Command}
      ***                   66                        
1931                                                        && $query->{Command} =~ m/$property/;
1932                                                  }
1933                                                  
1934                                                  sub _find_match_Info {
1935           6                    6            51      my ( $self, $query, $property ) = @_;
1936  ***      6            66                  196      return defined $property && defined $query->{Info}
      ***                   66                        
1937                                                        && $query->{Info} =~ m/$property/;
1938                                                  }
1939                                                  
1940                                                  sub _d {
1941  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1942  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1943  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1944                                                          @_;
1945  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1946                                                  }
1947                                                  
1948                                                  1;
1949                                                  
1950                                                  # ###########################################################################
1951                                                  # End Processlist package
1952                                                  # ###########################################################################
1953                                                  
1954                                                  # ###########################################################################
1955                                                  # TextResultSetParser package 5266
1956                                                  # ###########################################################################
1957                                                  package TextResultSetParser;
1958                                                  
1959                                                  
1960           5                    5            37   use strict;
               5                                 13   
               5                                 25   
1961           5                    5            32   use warnings FATAL => 'all';
               5                                 12   
               5                                 24   
1962           5                    5            27   use English qw(-no_match_vars);
               5                                 13   
               5                                 30   
1963                                                  
1964           5                    5            47   use Data::Dumper;
               5                                 12   
               5                                 34   
1965                                                  $Data::Dumper::Indent    = 1;
1966                                                  $Data::Dumper::Sortkeys  = 1;
1967                                                  $Data::Dumper::Quotekeys = 0;
1968                                                  
1969  ***      5            50      5            45   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 14   
               5                                 65   
1970                                                  
1971                                                  sub new {
1972          10                   10            46      my ( $class, %args ) = @_;
1973          10                                 39      my $self = { %args };
1974          10                                 60      return bless $self, $class;
1975                                                  }
1976                                                  
1977                                                  sub _parse_tabular {
1978           2                    2            11      my ( $text, @cols ) = @_;
1979           2                                  5      my %row;
1980           2                                 37      my @vals = $text =~ m/\| +([^\|]*?)(?= +\|)/msg;
1981           2    100                          13      return (undef, \@vals) unless @cols;
1982           1                                  7      @row{@cols} = @vals;
1983           1                                  7      return (\%row, undef);
1984                                                  }
1985                                                  
1986                                                  sub _parse_tab_sep {
1987  ***      0                    0             0      my ( $text, @cols ) = @_;
1988  ***      0                                  0      my %row;
1989  ***      0                                  0      my @vals = split(/\t/, $text);
1990  ***      0      0                           0      return (undef, \@vals) unless @cols;
1991  ***      0                                  0      @row{@cols} = @vals;
1992  ***      0                                  0      return (\%row, undef);
1993                                                  }
1994                                                  
1995                                                  sub parse_vertical_row {
1996         448                  448          1586      my ( $text ) = @_;
1997         448                               9826      my %row = $text =~ m/^\s*(\w+):(?: ([^\n]*))?/msg;
1998         448                               1783      MKDEBUG && _d('vertical row:', Dumper(\%row));
1999         448                               1885      return \%row;
2000                                                  }
2001                                                  
2002                                                  sub parse {
2003          10                   10           297      my ( $self, $text ) = @_;
2004          10                                 44      my $result_set;
2005                                                  
2006          10    100                         381      if ( $text =~ m/^\+---/m ) { # standard "tabular" output
      ***            50                               
      ***            50                               
2007           1                                  3         MKDEBUG && _d('Result set text is standard tabular');
2008           1                                  7         my $line_pattern  = qr/^(\| .*)[\r\n]+/m;
2009           1                                  6         $result_set
2010                                                           = parse_horizontal_row($text, $line_pattern, \&_parse_tabular);
2011                                                     }
2012                                                     elsif ( $text =~ m/^id\tselect_type\t/m ) { # tab-separated
2013  ***      0                                  0         MKDEBUG && _d('Result set text is tab-separated');
2014  ***      0                                  0         my $line_pattern  = qr/^(.*?\t.*)[\r\n]+/m;
2015  ***      0                                  0         $result_set
2016                                                           = parse_horizontal_row($text, $line_pattern, \&_parse_tab_sep);
2017                                                     }
2018                                                     elsif ( $text =~ m/\*\*\* \d+\. row/ ) { # "vertical" output
2019           9                                 21         MKDEBUG && _d('Result set text is vertical (\G)');
2020           9                                 42         foreach my $row ( split_vertical_rows($text) ) {
2021         448                               1669            push @$result_set, parse_vertical_row($row);
2022                                                        }
2023                                                     }
2024                                                     else {
2025  ***      0                                  0         die "Cannot determine if text is tabular, tab-separated or veritcal:\n"
2026                                                           . $text;
2027                                                     }
2028                                                  
2029  ***     10     50                          84      if ( $self->{value_for} ) {
2030  ***      0                                  0         foreach my $result_set ( @$result_set ) {
2031  ***      0                                  0            foreach my $key ( keys %$result_set ) {
2032  ***      0      0                           0               $result_set->{$key} = $self->{value_for}->{ $result_set->{$key} }
2033                                                                 if exists $self->{value_for}->{ $result_set->{$key} };
2034                                                           }
2035                                                        }
2036                                                     }
2037                                                  
2038          10                                 59      return $result_set;
2039                                                  }
2040                                                  
2041                                                  sub parse_horizontal_row {
2042           1                    1             4      my ( $text, $line_pattern, $sub ) = @_;
2043           1                                  4      my @result_sets = ();
2044           1                                  3      my @cols        = ();
2045           1                                 10      foreach my $line ( $text =~ m/$line_pattern/g ) {
2046           2                                  8         my ( $row, $cols ) = $sub->($line, @cols);
2047           2    100                           8         if ( $row ) {
2048           1                                  5            push @result_sets, $row;
2049                                                        }
2050                                                        else {
2051           1                                  8            @cols = @$cols;
2052                                                        }
2053                                                     }
2054           1                                 13      return \@result_sets;
2055                                                  }
2056                                                  
2057                                                  sub split_vertical_rows {
2058           9                    9           188      my ( $text ) = @_;
2059           9                                 33      my $ROW_HEADER = '\*{3,} \d+\. row \*{3,}';
2060           9                              23942      my @rows = $text =~ m/($ROW_HEADER.*?)(?=$ROW_HEADER|\z)/omgs;
2061           9                                230      return @rows;
2062                                                  }
2063                                                  
2064                                                  sub _d {
2065  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2066  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2067  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2068                                                          @_;
2069  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2070                                                  }
2071                                                  
2072                                                  1;
2073                                                  
2074                                                  # ###########################################################################
2075                                                  # End TextResultSetParser package
2076                                                  # ###########################################################################
2077                                                  
2078                                                  # ###########################################################################
2079                                                  # This is a combination of modules and programs in one -- a runnable module.
2080                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2081                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2082                                                  #
2083                                                  # Check at the end of this package for the call to main() which actually runs
2084                                                  # the program.
2085                                                  # ###########################################################################
2086                                                  package mk_kill;
2087                                                  
2088           5                    5            33   use English qw(-no_match_vars);
               5                                 13   
               5                                 25   
2089           5                    5            34   use POSIX qw(setsid);
               5                                 23   
               5                                 41   
2090           5                    5            34   use List::Util qw(max);
               5                                 11   
               5                                 26   
2091                                                  
2092                                                  Transformers->import qw(ts);
2093                                                  
2094  ***      5            50      5            35   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 12   
               5                                 64   
2095                                                  
2096                                                  $OUTPUT_AUTOFLUSH = 1;
2097                                                  
2098                                                  my $o;
2099                                                  my $dp;
2100                                                  
2101                                                  # ########################################################################
2102                                                  # Configuration info.
2103                                                  # ########################################################################
2104                                                  
2105                                                  sub main {
2106          12                   12          2144      @ARGV = @_;  # set global ARGV for this package
2107                                                  
2108          12                                165      my $pl = new Processlist();
2109          12                                133      my $vp = new VersionParser();
2110          12                                121      $dp    = new DSNParser();
2111                                                  
2112                                                     # ########################################################################
2113                                                     # Get configuration information.
2114                                                     # ########################################################################
2115          12                                249      $o = new OptionParser(
2116                                                        description => q{kills, prints or executes another script for queries }
2117                                                                     . q{in MySQL that match certain criteria.  }
2118                                                                     . q{If FILE is not given, mk-kill executes SHOW PROCESSLIST }
2119                                                                     . q{on MySQL to get queries.  Else, mk-kill will get }
2120                                                                     . q{queries from FILE which should contain the output of }
2121                                                                     . q{SHOW PROCESSLIST.  If FILE is -, mk-kill reads from }
2122                                                                     . q{STDIN.},
2123                                                        prompt      => '[OPTION]... [FILE...]',
2124                                                        strict      => 0,
2125                                                     );
2126          12                               1306      $o->get_specs();
2127          12                                 86      $o->get_opts();
2128                                                  
2129          12    100                          70      if ( !$o->got('busy-time') ) {
2130  ***      9     50                          44         $o->set('interval', 30) unless $o->got('interval');
2131                                                     }
2132                                                     else {
2133  ***      3     50                          13         $o->set('interval', max(1, $o->get('busy-time') / 2))
2134                                                           unless $o->got('interval');
2135                                                     }
2136                                                  
2137                                                     # If parsing files, then don't wait.
2138          12    100                          57      if ( @ARGV ) {
2139          10                                 40         $o->set('interval', 0);
2140                                                     }
2141                                                  
2142          12                                 63      $o->usage_or_errors();
2143                                                  
2144                                                     # ########################################################################
2145                                                     # Connect to MySQL if not reading files.
2146                                                     # ########################################################################
2147          12                                 34      my $dsn;
2148          12                                 35      my $dbh;
2149          12                                 39      my $kill_sth;
2150          12    100                          62      if ( !@ARGV ) {
2151           2                                 26         $dsn      = $dp->parse_options($o);
2152           2                                 36         $dbh      = get_cxn($dsn, 1); 
2153           2    100                          16         $kill_sth = $o->get('kill-query') ? $dbh->prepare('KILL QUERY ?')
2154                                                                  :                         $dbh->prepare('KILL ?');
2155                                                     }
2156                                                  
2157                                                     # ########################################################################
2158                                                     # Make input sub that will either get processlist from MySQL or a file.
2159                                                     # ########################################################################
2160          12                                 44      my $get_proclist;
2161          12    100                          57      if ( @ARGV ) {
2162          10                                 24         MKDEBUG && _d('Getting processlist from files:', @ARGV);
2163          10                                 99         my $trp = new TextResultSetParser();
2164          10                                 24         my $fh;
2165                                                        $get_proclist = sub {
2166  ***     10     50            10            40            if ( !$fh ) {
2167          10                                 37               my $file = shift @ARGV;
2168  ***     10     50                          38               die 'No more files' unless $file;
2169  ***     10     50                          42               if ( $file eq '-' ) {
2170  ***      0                                  0                  $fh = *STDIN;
2171                                                              }
2172                                                              else {
2173  ***     10     50                         406                  if ( !open $fh, '<', $file ) {
2174  ***      0                                  0                     warn "Cannot open $file: $OS_ERROR";
2175  ***      0                                  0                     $fh = undef;
2176  ***      0                                  0                     return;
2177                                                                 }
2178                                                              }
2179                                                           }
2180                                                  
2181  ***     10     50                          40            if ( $fh ) {
2182          10                                 66               local $INPUT_RECORD_SEPARATOR = '';
2183          10                                907               my $proclist_text = <$fh>;
2184  ***     10     50                          39               if ( $proclist_text ) {
2185          10                                 52                  return $trp->parse($proclist_text);
2186                                                              }
2187                                                              else {
2188                                                                 # No more proclists in this file.
2189  ***      0                                  0                  $fh = undef;
2190                                                              }
2191                                                           }
2192                                                  
2193  ***      0                                  0            return;
2194          10                                 99         };
2195                                                     }
2196                                                     else {
2197           2                                  8         MKDEBUG && _d('Getting processlist from MySQL');
2198           2                                  5         my $proc_sth = $dbh->prepare('SHOW FULL PROCESSLIST');
2199                                                        $get_proclist = sub {
2200           2                    2           382            $proc_sth->execute();
2201           2                                 79            return $proc_sth->fetchall_arrayref({});
2202           2                                 48         };
2203                                                     }
2204                                                  
2205                                                     # ########################################################################
2206                                                     # Daemonize only after (potentially) asking for passwords for --ask-pass.
2207                                                     # ########################################################################
2208          12                                 32      my $daemon;
2209  ***     12     50                          60      if ( $o->get('daemonize') ) {
      ***            50                               
2210  ***      0                                  0         $daemon = new Daemon(o=>$o);
2211  ***      0                                  0         $daemon->daemonize();
2212  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
2213                                                     }
2214                                                     elsif ( $o->get('pid') ) {
2215                                                        # We're not daemoninzing, it just handles PID stuff.
2216  ***      0                                  0         $daemon = new Daemon(o=>$o);
2217  ***      0                                  0         $daemon->make_PID_file();
2218                                                     }
2219                                                  
2220                                                     # ########################################################################
2221                                                     # Start working.
2222                                                     # ########################################################################
2223          12                                 58      my $start    = time();
2224  ***     12            50                   56      my $end      = $start + ($o->get('run-time') || 0); # When we should exit
2225          12                                 36      my $now      = $start;
2226                                                  
2227  ***     12     50                          57      my %find_spec = (
2228                                                        only_oldest => $o->get('only-oldest'),
2229                                                        busy_time   => $o->get('busy-time'),
2230                                                        idle_time   => $o->get('idle-time'),
2231                                                        ignore => {
2232                                                           Command  => $o->get('ignore-command'),
2233                                                           db       => $o->get('ignore-db'),
2234                                                           Host     => $o->get('ignore-host'),
2235                                                           Id       => $o->get('ignore-self') ? $dbh->{mysql_thread_id} : undef,
2236                                                           Info     => $o->get('ignore-info'),
2237                                                           State    => $o->get('ignore-state'),
2238                                                           User     => $o->get('ignore-user'),
2239                                                        },
2240                                                        match => {
2241                                                           Command  => $o->get('match-command'),
2242                                                           db       => $o->get('match-db'),
2243                                                           Host     => $o->get('match-host'),
2244                                                           Info     => $o->get('match-info'),
2245                                                           State    => $o->get('match-state'),
2246                                                           User     => $o->get('match-user'),
2247                                                        },
2248                                                     );
2249                                                  
2250          12                                 60      my $iters_done = 0;
2251          12                                 50      my $iters_todo = $o->get('iterations');
2252  ***     12            33                  212      while (                                              # Quit if:
      ***                   66                        
      ***                   66                        
2253                                                        ($start == $end || $now < $end)                   # time is exceeded
2254                                                        && (!$iters_todo || $iters_done++ < $iters_todo ) # or iterations exceeded
2255                                                     ) {
2256          12                                 83         heartbeat('Checking processlist, iteration '.$iters_done);
2257          12                                 31         my $proclist;
2258          12                                 41         eval { $proclist = $get_proclist->(); };
              12                                 47   
2259  ***     12     50                          70         if ( $EVAL_ERROR ) {
2260  ***      0      0                           0            last if $EVAL_ERROR =~ m/No more files/;
2261  ***      0                                  0            die "Error getting SHOW PROCESSLIST: $EVAL_ERROR";
2262                                                        }
2263                                                  
2264          12                                 35         my @queries;
2265  ***     12     50                          52         if ( $proclist ) {
2266          12                                119            @queries = $pl->find($proclist, %find_spec);
2267          12                                 77            heartbeat('Matched ' . scalar @queries . ' queries');
2268                                                           MATCHING_QUERY:
2269          12                                 53            foreach my $query ( @queries ) {
2270  ***     11     50                          50               if ( $o->get('print') ) {
2271  ***     11    100     50                   94                  printf "# %s %s %d (%s %d sec) %s\n",
      ***                   50                        
2272                                                                    ts(time), $o->get('kill-query') ? 'KILL QUERY' : 'KILL',
2273                                                                    $query->{Id}, ($query->{Command} || 'NULL'), $query->{Time},
2274                                                                    ($query->{Info} || 'NULL');
2275                                                              }
2276  ***     11     50                          57               if ( $o->get('execute-command') ) {
2277  ***      0                                  0                  exec_cmd($o->get('execute-command'));
2278  ***      0                                  0                  heartbeat('Executed ' . $o->get('execute-command'));
2279                                                              }
2280          11    100    100                   49               if ( $o->get('kill') || $o->get('kill-query') ) {
2281  ***      2     50                          13                  sleep $o->get('wait-before-kill') if $o->get('wait-before-kill');
2282           2                                303                  $kill_sth->execute($query->{Id});
2283           2                                 24                  heartbeat("Killed $query->{Id}");
2284           2                                 15                  MKDEBUG && _d('Killed', $query->{Id});
2285                                                              }
2286                                                           }
2287                                                        }
2288                                                        else {
2289  ***      0                                  0            MKDEBUG && _d('No proclist returned');
2290  ***      0                                  0            heartbeat('Processlist returned no queries');
2291                                                        }
2292                                                  
2293                                                        # Don't sleep if we're going to exit after waking up.  If $iters_todo is
2294                                                        # 0 (infinity), always sleep.  And only sleep if we're live (i.e. not
2295                                                        # reading from files).
2296  ***     12     50     33                  149         if ( (!$iters_todo || $iters_done < $iters_todo)
      ***                   33                        
2297                                                              && $dbh ) {
2298  ***      0      0      0                    0            if ( @queries && $o->get('wait-after-kill') ) {
2299  ***      0                                  0               MKDEBUG && _d("Sleeping after killing queries");
2300  ***      0                                  0               sleep $o->get('wait-after-kill');
2301                                                           }
2302                                                           else {
2303  ***      0                                  0               MKDEBUG && _d("Sleeping normal interval");
2304  ***      0                                  0               sleep $o->get('interval');
2305                                                           }
2306                                                        }
2307          12                                621         $now = time();
2308                                                     }
2309                                                  
2310          12                                 50      heartbeat('Done checking processlist');
2311          12                                340      return 0;
2312                                                  }
2313                                                  
2314                                                  
2315                                                  # ############################################################################
2316                                                  # Subroutines.
2317                                                  # ############################################################################
2318                                                  
2319                                                  sub get_cxn {
2320           2                    2            20      my ( $dsn, $ac ) = @_;
2321  ***      2     50                          14      if ( $o->get('ask-pass') ) {
2322  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password: "); 
2323                                                     }
2324           2                                 36      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => $ac});
2325           2                                 23      $dbh->{InactiveDestroy} = 1; # Because of forking.
2326           2                                 19      return $dbh;
2327                                                  }
2328                                                  
2329                                                  # Forks and detaches from parent to execute the given command;
2330                                                  # does not block parent.
2331                                                  sub exec_cmd {
2332  ***      0                    0             0      my ( $cmd ) = @_;
2333  ***      0                                  0      MKDEBUG && _d('exec cmd:', $cmd);
2334  ***      0      0                           0      return unless $cmd;
2335                                                  
2336  ***      0                                  0      my $pid = fork();
2337  ***      0      0                           0      if ( $pid ) {
2338                                                        # parent
2339  ***      0                                  0         MKDEBUG && _d('child pid:', $pid);
2340  ***      0                                  0         return $pid;
2341                                                     }
2342                                                  
2343                                                     # child
2344  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2345  ***      0                                  0      my $retval = system($cmd);
2346  ***      0                                  0      $retval = $retval >> 8;
2347  ***      0                                  0      MKDEBUG && _d('child exit status:', $retval);
2348  ***      0                                  0      exit $retval;
2349                                                  }
2350                                                  
2351                                                  sub heartbeat {
2352          38                   38           168      my ( $msg ) = @_;
2353  ***     38     50                         181      print '# ', ts(time), " $msg\n" if $o->get('heartbeat');
2354          38                                 99      MKDEBUG && _d($msg);
2355          38                                107      return;
2356                                                  }
2357                                                  
2358                                                  sub _d {
2359  ***      0                    0                    my ($package, undef, $line) = caller 0;
2360  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2361  ***      0                                              map { defined $_ ? $_ : 'undef' }
2362                                                          @_;
2363  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2364                                                  }
2365                                                  
2366                                                  # ############################################################################
2367                                                  # Run the program.
2368                                                  # ############################################################################
2369                                                  if ( !caller ) { exit main(@ARGV); }
2370                                                  
2371                                                  1; # Because this is a module as well as a script.
2372                                                  
2373                                                  # ############################################################################
2374                                                  # Documentation
2375                                                  # ############################################################################
2376                                                  =pod
2377                                                  
2378                                                  =head1 NAME
2379                                                  
2380                                                  mk-kill - Kill MySQL queries that match certain criteria.
2381                                                  
2382                                                  =head1 SYNOPSIS
2383                                                  
2384                                                  Kill queries running longer than 60s:
2385                                                  
2386                                                    mk-kill --busy-time 60 --kill
2387                                                  
2388                                                  Print, do not kill, queries running longer than 60s:
2389                                                  
2390                                                    mk-kill --busy-time 60 --print
2391                                                  
2392                                                  Check for sleeping processes and kill them all every 10s:
2393                                                  
2394                                                    mk-kill --match-command Sleep --kill --no-only-oldest --interval 10
2395                                                  
2396                                                  Print all login processes:
2397                                                  
2398                                                    mk-kill --match-state login --print --no-only-oldest
2399                                                  
2400                                                  =head1 RISKS
2401                                                  
2402                                                  The following section is included to inform users about the potential risks,
2403                                                  whether known or unknown, of using this tool.  The two main categories of risks
2404                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2405                                                  tools) and those created by bugs.
2406                                                  
2407                                                  mk-kill is designed to kill queries if you use the L<"--kill"> option is given,
2408                                                  and that might disrupt your database's users, of course.  You should test with
2409                                                  the <"--print"> option, which is safe, if you're unsure what the tool will do.
2410                                                  
2411                                                  At the time of this release, we know of no bugs that could cause serious harm to
2412                                                  users.
2413                                                  
2414                                                  The authoritative source for updated information is always the online issue
2415                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2416                                                  see a list of such issues at the following URL:
2417                                                  L<http://www.maatkit.org/bugs/mk-kill>.
2418                                                  
2419                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2420                                                  
2421                                                  =head1 DESCRIPTION
2422                                                  
2423                                                  mk-kill captures queries from SHOW PROCESSLIST, filters them, and then either
2424                                                  kills or prints them.  This is also known as a "slow query sniper" in some
2425                                                  circles.  The idea is to watch for queries that might be consuming too many
2426                                                  resources, and kill them.
2427                                                  
2428                                                  For brevity, we talk about killing queries, but they may just be printed
2429                                                  (or some other future action) depending on what options are given.
2430                                                  
2431                                                  Normally mk-kill connects to MySQL to get queries from SHOW PROCESSLIST.
2432                                                  Alternatively, it can read SHOW PROCESSLIST output from files.  In this case,
2433                                                  mk-kill does not connect to MySQL and L<"--kill"> has no effect.  You should
2434                                                  use L<"--print"> instead when reading files.  The ability to read a file (or
2435                                                  - for STDIN) allows you to capture SHOW PROCESSLIST and test it later with
2436                                                  mk-kill to make sure that your matches kill the proper queries.  There are a
2437                                                  lot of special rules to follow, such as "don't kill replication threads,"
2438                                                  so be careful to not kill something important!
2439                                                  
2440                                                  Two important options to know are L<"--busy-time"> and L<"--[no]only-oldest">.
2441                                                  First, whereas most match/filter options match their corresponding value from
2442                                                  SHOW PROCESSLIST (e.g. L<"--match-command"> matches a query's Command value),
2443                                                  the Time value is matched by L<"--busy-time">.  See also L<"--interval">.
2444                                                  
2445                                                  Secondly, L<"--[no]only-oldest"> affects which matching query is killed.
2446                                                  By default, the matching query with the highest Time value is killed.  So
2447                                                  if you want to match and kill ALL queries for a certain criteria regardless
2448                                                  of which is the "oldest", you must specify C<--no-only-oldest>.
2449                                                  
2450                                                  mk-kill is a work in progress, and there is much more it could do.
2451                                                  
2452                                                  =head1 OUTPUT
2453                                                  
2454                                                  If only L<"--kill"> then there is no output.  If only L<"--print"> then a
2455                                                  timestamped KILL statement if printed for every query that would have
2456                                                  been killed, like:
2457                                                  
2458                                                    # 2009-07-15T15:04:01 KILL 8 (Query 42 sec) SELECT * FROM huge_table
2459                                                  
2460                                                  The line shows a timestamp, the query's Id (8), its Time (42 sec) and its
2461                                                  Info (usually the query SQL).
2462                                                  
2463                                                  If both L<"--kill"> and L<"--print"> are given, then matching queries are
2464                                                  killed and a line for each like the one above is printed.
2465                                                  
2466                                                  Any command executed by L<"--execute-command"> is responsible for its own
2467                                                  output and logging.  After being executed, mk-kill has no control or interaction
2468                                                  with the command.
2469                                                  
2470                                                  =head1 OPTIONS
2471                                                  
2472                                                  Specify at least one of L<"--kill">, L<"--kill-query">, L<"--print"> or L<"--execute-command">.
2473                                                  
2474                                                  =over
2475                                                  
2476                                                  =item --ask-pass
2477                                                  
2478                                                  Prompt for a password when connecting to MySQL.
2479                                                  
2480                                                  =item --charset
2481                                                  
2482                                                  short form: -A; type: string
2483                                                  
2484                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2485                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
2486                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
2487                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
2488                                                  
2489                                                  =item --config
2490                                                  
2491                                                  type: Array
2492                                                  
2493                                                  Read this comma-separated list of config files; if specified, this must be the
2494                                                  first option on the command line.
2495                                                  
2496                                                  =item --daemonize
2497                                                  
2498                                                  Fork to the background and detach from the shell.  POSIX operating systems
2499                                                  only.
2500                                                  
2501                                                  =item --defaults-file
2502                                                  
2503                                                  short form: -F; type: string
2504                                                  
2505                                                  Only read mysql options from the given file.  You must give an absolute
2506                                                  pathname.
2507                                                  
2508                                                  =item --heartbeat
2509                                                  
2510                                                  Print information to STDOUT about what is being done.
2511                                                  
2512                                                  =item --help
2513                                                  
2514                                                  Show help and exit.
2515                                                  
2516                                                  =item --host
2517                                                  
2518                                                  short form: -h; type: string
2519                                                  
2520                                                  Connect to host.
2521                                                  
2522                                                  =item --interval
2523                                                  
2524                                                  type: time
2525                                                  
2526                                                  How often to check for queries to kill.  If L<"--busy-time"> is not given,
2527                                                  then the default interval is 30 seconds.  Else the default is half as often
2528                                                  as L<"--busy-time">.  If both L<"--interval"> and L<"--busy-time"> are given,
2529                                                  then the explicit L<"--interval"> value is used.
2530                                                  
2531                                                  =item --iterations
2532                                                  
2533                                                  type: int; default: 1
2534                                                  
2535                                                  How many times to iterate through the find-and-kill cycle.  If 0, iterate
2536                                                  to infinity.  See also L<"--run-time">.
2537                                                  
2538                                                  =item --log
2539                                                  
2540                                                  type: string
2541                                                  
2542                                                  Print all output to this file when daemonized.
2543                                                  
2544                                                  =item --password
2545                                                  
2546                                                  short form: -p; type: string
2547                                                  
2548                                                  Password to use when connecting.
2549                                                  
2550                                                  =item --pid
2551                                                  
2552                                                  type: string
2553                                                  
2554                                                  Create the given PID file when daemonized.  The file contains the process ID of
2555                                                  the daemonized instance.  The PID file is removed when the daemonized instance
2556                                                  exits.  The program checks for the existence of the PID file when starting; if
2557                                                  it exists and the process with the matching PID exists, the program exits.
2558                                                  
2559                                                  =item --port
2560                                                  
2561                                                  short form: -P; type: int
2562                                                  
2563                                                  Port number to use for connection.
2564                                                  
2565                                                  =item --run-time
2566                                                  
2567                                                  type: time
2568                                                  
2569                                                  How long to run before exiting.
2570                                                  
2571                                                  =item --set-vars
2572                                                  
2573                                                  type: string; default: wait_timeout=10000
2574                                                  
2575                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2576                                                  will be appended to SET and executed.
2577                                                  
2578                                                  =item --socket
2579                                                  
2580                                                  short form: -S; type: string
2581                                                  
2582                                                  Socket file to use for connection.
2583                                                  
2584                                                  =item --user
2585                                                  
2586                                                  short form: -u; type: string
2587                                                  
2588                                                  User for login if not current user.
2589                                                  
2590                                                  =item --version
2591                                                  
2592                                                  Show version and exit.
2593                                                  
2594                                                  =item --wait-after-kill
2595                                                  
2596                                                  type: time
2597                                                  
2598                                                  Wait after killing a query, before looking for more to kill.  The purpose of
2599                                                  this is to give blocked queries a chance to execute, so we don't kill a query
2600                                                  that's blocking a bunch of others, and then kill the others immediately
2601                                                  afterwards.
2602                                                  
2603                                                  =item --wait-before-kill
2604                                                  
2605                                                  type: time
2606                                                  
2607                                                  Wait before killing a query.  The purpose of this is to give
2608                                                  L<"--execute-command"> a chance to see the matching query and gather other
2609                                                  MySQL or system information before it's killed.
2610                                                  
2611                                                  =back
2612                                                  
2613                                                  =head2 MATCHES
2614                                                  
2615                                                  These options specify what criteria a query must match for C<mk-kill>
2616                                                  to either L<"--kill">, L<"--print"> or L<"--execute-command"> for it.
2617                                                  The ignore commands take precedence.  The matches for command, db, host, etc.
2618                                                  correspond to the columns returned by SHOW PROCESSLIST: Command, db, Host, etc.
2619                                                  All pattern matches are case-senstive.
2620                                                  
2621                                                  =over
2622                                                  
2623                                                  =item --busy-time
2624                                                  
2625                                                  type: time; group: Matches
2626                                                  
2627                                                  Kill connections that have been running for longer than this time.  The queries
2628                                                  must be in Command=Query status.  This matches a query's Time value as
2629                                                  reported by SHOW PROCESSLIST.
2630                                                  
2631                                                  =item --idle-time
2632                                                  
2633                                                  type: time; group: Matches
2634                                                  
2635                                                  Kill connections that have been idle/sleeping for longer than this time.
2636                                                  The queries must be in Command=Sleep status.  This matches a query's Time
2637                                                  value as reported by SHOW PROCESSLIST.
2638                                                  
2639                                                  =item --ignore-command
2640                                                  
2641                                                  type: string; group: Matches; default: Binlog.Dump
2642                                                  
2643                                                  Ignore queries whose Command matches this Perl regex.  The default is to keep
2644                                                  the slave threads from being killed on the master.
2645                                                  
2646                                                  See L<"--match-command">.
2647                                                  
2648                                                  =item --ignore-db
2649                                                  
2650                                                  type: string; group: Matches
2651                                                  
2652                                                  Ignore queries whose db (database) matches this Perl regex.
2653                                                  
2654                                                  See L<"--match-db">.
2655                                                  
2656                                                  =item --ignore-host
2657                                                  
2658                                                  type: string; group: Matches
2659                                                  
2660                                                  Ignore queries whose Host matches this Perl regex.
2661                                                  
2662                                                  See L<"--match-host">.
2663                                                  
2664                                                  =item --ignore-info
2665                                                  
2666                                                  type: string; group: Matches
2667                                                  
2668                                                  Ignore queries whose Info (query) matches this Perl regex.
2669                                                  
2670                                                  See L<"--match-info">.
2671                                                  
2672                                                  =item --[no]ignore-self
2673                                                  
2674                                                  default: yes; group: Matches
2675                                                  
2676                                                  Don't kill mk-kill's own connection.
2677                                                  
2678                                                  =item --ignore-state
2679                                                  
2680                                                  type: string; group: Matches; default: Locked
2681                                                  
2682                                                  Ignore queries whose State matches this Perl regex.  The default is to keep
2683                                                  threads from being killed if they are locked waiting for another thread.
2684                                                  
2685                                                  See L<"--match-state">.
2686                                                  
2687                                                  =item --ignore-user
2688                                                  
2689                                                  type: string; group: Matches; default: system.user
2690                                                  
2691                                                  Ignore queries whose user matches this Perl regex.  The default is to keep the
2692                                                  replication threads from being killed on the slave.
2693                                                  
2694                                                  See L<"--match-user">.
2695                                                  
2696                                                  =item --match-command
2697                                                  
2698                                                  type: string; group: Matches
2699                                                  
2700                                                  Kill only queries whose Command matches this Perl regex.
2701                                                  
2702                                                  Common Command values are:
2703                                                  
2704                                                    Query
2705                                                    Sleep
2706                                                    Binlog Dump
2707                                                    Connect
2708                                                    Delayed insert
2709                                                    Execute
2710                                                    Fetch
2711                                                    Init DB
2712                                                    Kill
2713                                                    Prepare
2714                                                    Processlist
2715                                                    Quit
2716                                                    Reset stmt
2717                                                    Table Dump
2718                                                  
2719                                                  See L<http://dev.mysql.com/doc/refman/5.1/en/thread-commands.html> for a full
2720                                                  list and description of Command values.
2721                                                  
2722                                                  =item --match-db
2723                                                  
2724                                                  type: string; group: Matches
2725                                                  
2726                                                  Kill only queries whose db (database) matches this Perl regex.
2727                                                  
2728                                                  =item --match-host
2729                                                  
2730                                                  type: string; group: Matches
2731                                                  
2732                                                  Kill only queries whose Host matches this Perl regex.
2733                                                  
2734                                                  The Host value often time includes the port like "host:port".
2735                                                  
2736                                                  =item --match-info
2737                                                  
2738                                                  type: string; group: Matches
2739                                                  
2740                                                  Kill only queries whose Info (query) matches this Perl regex.
2741                                                  
2742                                                  The Info column of the processlist shows the query that is being executed
2743                                                  or NULL if no query is being executed.
2744                                                  
2745                                                  =item --match-state
2746                                                  
2747                                                  type: string; group: Matches
2748                                                  
2749                                                  Kill only queries whose State matches this Perl regex.
2750                                                  
2751                                                  Common State values are:
2752                                                  
2753                                                    Locked
2754                                                    login
2755                                                    copy to tmp table
2756                                                    Copying to tmp table
2757                                                    Copying to tmp table on disk
2758                                                    Creating tmp table
2759                                                    executing
2760                                                    Reading from net
2761                                                    Sending data
2762                                                    Sorting for order
2763                                                    Sorting result
2764                                                    Table lock
2765                                                    Updating
2766                                                  
2767                                                  See L<http://dev.mysql.com/doc/refman/5.1/en/general-thread-states.html> for
2768                                                  a full list and description of State values.
2769                                                  
2770                                                  =item --match-user
2771                                                  
2772                                                  type: string; group: Matches
2773                                                  
2774                                                  Kill only queries whose User matches this Perl regex.
2775                                                  
2776                                                  =item --[no]only-oldest
2777                                                  
2778                                                  default: yes; group: Matches
2779                                                  
2780                                                  Only kill the single oldest query.  This is to prevent killing queries that
2781                                                  aren't really long-running, they're just long-waiting.  This sorts matching
2782                                                  queries by Time and kills the one with the highest Time value.
2783                                                  
2784                                                  =back
2785                                                  
2786                                                  =head2 ACTIONS
2787                                                  
2788                                                  When a query matches, one or more of these actions is taken.  The actions are
2789                                                  taken in this order: L<"--print">, L<"--execute-command">, L<"--kill">.
2790                                                  If given, mk-kill sleeps for L<"--wait-before-kill"> before L<"--kill"> (if
2791                                                  L<"--kill"> is given).  This order allows L<"--execute-command"> to see the 
2792                                                  output of L<"--print"> and the query before L<"--kill">.  This may be helpful
2793                                                  because mk-kill does not pass any information to L<"--execute-command">.
2794                                                  
2795                                                  =over
2796                                                  
2797                                                  =item --execute-command
2798                                                  
2799                                                  type: string; group: Actions
2800                                                  
2801                                                  Execute this command when a query matches.
2802                                                  
2803                                                  After the command is executed, mk-kill has no control over it, so the command
2804                                                  is responsible for its own info gathering, logging, interval, etc.  The
2805                                                  command is excuted each time a query matches, so be careful that the command
2806                                                  behaves well when multiple instances are ran.  No information from mk-kill is
2807                                                  passed to the command.
2808                                                  
2809                                                  See also L<"--wait-before-kill">.
2810                                                  
2811                                                  =item --kill
2812                                                  
2813                                                  group: Actions
2814                                                  
2815                                                  Kill the connection for matching queries.
2816                                                  
2817                                                  This option makes mk-kill kill the connections (a.k.a. processes, threads) that
2818                                                  have matching queries.  Use L<"--kill-query"> if you only want to kill
2819                                                  individual queries and not their connections.  If both L<"--kill"> and
2820                                                  L<"--kill-query"> are specified, only L<"--kill-query"> is used.
2821                                                  
2822                                                  Unless L<"--print"> is also given, no other information is printed that shows
2823                                                  that mk-kill matched and killed a query.
2824                                                  
2825                                                  See also L<"--wait-before-kill"> and L<"--wait-after-kill">.
2826                                                  
2827                                                  =item --kill-query
2828                                                  
2829                                                  group: Actions
2830                                                  
2831                                                  Kill matching queries.
2832                                                  
2833                                                  This option makes mk-kill kill matching queries.  This requires MySQL 5.0 or
2834                                                  newer.  Unlike L<"--kill"> which kills the connection for matching queries,
2835                                                  this option only kills the query, not its connection.  If both L<"--kill"> and
2836                                                  L<"--kill-query"> are specified, only L<"--kill-query"> is used.
2837                                                  
2838                                                  =item --print
2839                                                  
2840                                                  group: Actions
2841                                                  
2842                                                  Print a KILL statement for matching queries; does not actually kill queries.
2843                                                  
2844                                                  If you just want to see which queries match and would be killed without
2845                                                  actually killing them, specify L<"--print">.  To both kill and print
2846                                                  matching queries, specify both L<"--kill"> and L<"--print">.
2847                                                  
2848                                                  =back
2849                                                  
2850                                                  =head1 DOWNLOADING
2851                                                  
2852                                                  You can download Maatkit from Google Code at
2853                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2854                                                  easily with a command like the following:
2855                                                  
2856                                                     wget http://www.maatkit.org/get/toolname
2857                                                     or
2858                                                     wget http://www.maatkit.org/trunk/toolname
2859                                                  
2860                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2861                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2862                                                  needed.  The first URL gets the latest released version of the tool, and the
2863                                                  second gets the latest trunk code from Subversion.
2864                                                  
2865                                                  =head1 ENVIRONMENT
2866                                                  
2867                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2868                                                  the Maatkit tools:
2869                                                  
2870                                                     MKDEBUG=1 mk-....
2871                                                  
2872                                                  =head1 SYSTEM REQUIREMENTS
2873                                                  
2874                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2875                                                  installed in any reasonably new version of Perl.
2876                                                  
2877                                                  =head1 BUGS
2878                                                  
2879                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-kill>.
2880                                                  
2881                                                  Please use Google Code Issues and Groups to report bugs or request support:
2882                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2883                                                  discuss Maatkit.
2884                                                  
2885                                                  Please include the complete command-line used to reproduce the problem you are
2886                                                  seeing, the version of all MySQL servers involved, the complete output of the
2887                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2888                                                  running with the C<MKDEBUG=1> environment variable.
2889                                                  
2890                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2891                                                  
2892                                                  This program is copyright 2009-@CURRENTYEAR@ Baron Schwartz.
2893                                                  Feedback and improvements are welcome.
2894                                                  
2895                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2896                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2897                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2898                                                  
2899                                                  This program is free software; you can redistribute it and/or modify it under
2900                                                  the terms of the GNU General Public License as published by the Free Software
2901                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2902                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2903                                                  licenses.
2904                                                  
2905                                                  You should have received a copy of the GNU General Public License along with
2906                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2907                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2908                                                  
2909                                                  =head1 AUTHOR
2910                                                  
2911                                                  Baron Schwartz
2912                                                  
2913                                                  =head1 ABOUT MAATKIT
2914                                                  
2915                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2916                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2917                                                  code contributors.  Both are employed by Percona.  Financial support for
2918                                                  Maatkit development is primarily provided by Percona and its clients. 
2919                                                  
2920                                                  =head1 VERSION
2921                                                  
2922                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5455 $.
2923                                                  
2924                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
57    ***     50      0     12   unless $args{$arg}
63    ***     50     12      0   exists $args{'strict'} ? :
106   ***     50      0     12   unless open my $fh, '<', $file
126          100   3864     12   unless $para =~ /^=head1 OPTIONS/
131          100     12     12   if $para =~ /^=over/
139   ***     50      0     12   unless $para
142          100    492     12   if (my($option) = $para =~ /^=item --(.*)/)
149          100    432     60   if ($para =~ /: /) { }
153   ***     50      0    780   unless $attributes{$attrib}
157          100     84    348   if ($attribs{'short form'})
173   ***     50      0    492   if $para =~ /^=item/
175          100     24    468   if (my($base_option) = $option =~ /^\[no\](.*)/)
180          100     84    408   $attribs{'short form'} ? :
             100     24    468   $attribs{'negatable'} ? :
      ***     50      0    492   $attribs{'cumulative'} ? :
             100    372    120   $attribs{'type'} ? :
             100     84    408   $attribs{'default'} ? :
             100    240    252   $attribs{'group'} ? :
192   ***     50      0    864   unless $para
195          100     12    852   if ($para =~ /^=head1/)
199          100    492    360   if $para =~ /^=item --/
203   ***     50      0     12   unless @specs
214          100    492     12   if (ref $opt) { }
219   ***     50      0    492   if (not $long)
224   ***     50      0    492   if exists $$self{'opts'}{$long}
227   ***     50      0    492   if (length $long == 1)
232          100     84    408   if ($short) { }
233   ***     50      0     84   if exists $$self{'short_opts'}{$short}
242          100     24    468   $$opt{'spec'} =~ /!/ ? :
243   ***     50      0    492   $$opt{'spec'} =~ /\+/ ? :
244   ***     50      0    492   $$opt{'desc'} =~ /required/ ? :
256   ***     50      0    492   if ($type and $type eq 'd' and not $$self{'dp'})
261          100     84    408   if $type and $type =~ /[HhAadzm]/
263          100     84    408   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
264   ***     50     84      0   defined $def ? :
268          100     12    480   if ($long eq 'config')
272   ***     50      0    492   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
285   ***     50      0     12   if ($opt =~ /mutually exclusive|one and only one/)
290   ***     50     12      0   if ($opt =~ /at least one|one and only one/)
295   ***     50      0     12   if ($opt =~ /default to/)
300   ***     50      0     12   if ($opt =~ /restricted to option groups/)
310   ***     50      0     12   unless $rule_ok
327   ***     50      0     48   unless exists $$self{'opts'}{$long}
351   ***      0      0      0   unless exists $$self{'opts'}{$long}
371   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     33      0   exists $$self{'opts'}{$opt} ? :
376   ***     50      0     33   if ($$opt{'is_cumulative'}) { }
391   ***     50      0    396   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     96    396   exists $$self{'defaults'}{$long} ? :
400   ***     50      0     12   if (@ARGV and $ARGV[0] eq '--config')
404   ***     50     12      0   if ($self->has('config'))
410   ***     50     48      0   if ($EVAL_ERROR)
411   ***     50      0     48   $self->got('config') ? :
426   ***     50      0     12   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
429   ***     50      0     12   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
430   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
436   ***     50      0     12   if (@ARGV and $$self{'strict'})
442   ***      0      0      0   if (@set > 1)
453   ***     50      0     12   if (@set == 0)
463          100     33    459   if ($$opt{'got'}) { }
      ***     50      0    459   elsif ($$opt{'is_required'}) { }
464   ***     50      0     33   if (exists $$self{'disables'}{$long})
471   ***     50      0     33   if (exists $$self{'allowed_groups'}{$long})
483   ***      0      0      0   if $restricted_opt eq $long
484   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
489   ***      0      0      0   if (@restricted_opts)
491   ***      0      0      0   if (@restricted_opts == 1) { }
520          100    120    372   unless $opt and $$opt{'type'}
523          100      4    368   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    368   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    368   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0    368   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     12    356   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
526   ***     50      4      0   if (not $suffix)
532   ***     50      4      0   if ($suffix =~ /[smhd]/) { }
533   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***     50      4      0   $suffix eq 's' ? :
548   ***      0      0      0   if ($from_key)
559   ***      0      0      0   if (defined $num) { }
560   ***      0      0      0   if ($factor)
587          100     16    353   length $opt == 1 ? :
588   ***     50      0    369   unless $long and exists $$self{'opts'}{$long}
595   ***     50      0     72   length $opt == 1 ? :
596   ***     50      0     72   unless $long and exists $$self{'opts'}{$long}
603          100     16     12   length $opt == 1 ? :
604          100     26      2   defined $long ? :
609   ***     50      0     22   length $opt == 1 ? :
610   ***     50      0     22   unless $long and exists $$self{'opts'}{$long}
644   ***     50      0     12   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0     12   elsif (scalar @{$$self{'errors'};}) { }
645   ***      0      0      0   unless print $self->print_usage
649   ***      0      0      0   unless print $self->print_errors
658   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
667   ***      0      0      0   unless $$self{'got_opts'}
670   ***      0      0      0   $$_{'is_negatable'} ? :
674   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
690   ***      0      0      0   $group eq 'default' ? :
696   ***      0      0      0   $$opt{'is_negatable'} ? :
699   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
708   ***      0      0      0   if ($short) { }
717   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
721   ***      0      0      0   if ($$self{'dp'})
729   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
741   ***      0      0      0   if ref $_[0] eq 'OptionParser'
744   ***      0      0      0   unless print $prompt
752   ***      0      0      0   unless print "\n"
755   ***      0      0      0   if ($EVAL_ERROR)
777   ***     50     48      0   unless open my $fh, '<', $filename
785   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
788   ***      0      0      0   if ($line eq '--')
793   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
811   ***      0      0      0   unless open my $fh, '<', $file
815   ***      0      0      0   unless $para =~ /^=pod$/m
819   ***      0      0      0   unless $para =~ /$regex/
824   ***      0      0      0   unless close $fh
838   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
853   ***      0      0      0   defined $_ ? :
891   ***      0      0      0   if (not $$self{$dbh})
895   ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
902   ***      0      0      0   defined $_ ? :
988   ***     50      0     18   if (@_ > 2)
997   ***     50      0      6   if (not $dsn)
1009  ***     50     18      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1021  ***     50      0     48   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1027         100     30     18   if (not defined $final_props{$key})
1034  ***     50      0     18   unless exists $opts{$key}
1037  ***     50      0      6   if (my $required = $self->prop('required'))
1039  ***      0      0      0   unless $final_props{$key}
1048  ***     50      0      2   unless ref $o eq 'OptionParser'
1051         100     14      2   if $o->has($_)
1061  ***      0      0      0   unless ref $dsn
1062  ***      0      0      0   $_ eq 'p' ? :
1063  ***      0      0      0   if defined $$dsn{$_}
1076  ***      0      0      0   $opts{$key}{'copy'} ? :
1090  ***     50      0      6   if ($driver eq 'Pg') { }
1122  ***     50      0      6   $cxn_string =~ /charset=utf8/ ? :
1131  ***     50      0      6   if (not $have_dbi)
1150  ***     50      6      0   if ($cxn_string =~ /mysql/i)
1158  ***     50      0      6   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1163  ***      0      0      0   if ($charset eq 'utf8') { }
1164  ***      0      0      0   unless binmode STDOUT, ':utf8'
1168  ***      0      0      0   unless binmode STDOUT
1172  ***     50      0      6   if ($self->prop('set-vars'))
1179  ***     50      0      6   if (not $dbh and $EVAL_ERROR)
1181  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1194  ***      0      0      0   if (not $tries)
1216  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1233  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1243  ***      0      0      0   unless $dsn_1
1244  ***      0      0      0   unless $dsn_2
1248  ***      0      0      0   if ($args{'overwrite'}) { }
1249  ***      0      0      0   defined $$dsn_1{$key} ? :
1252  ***      0      0      0   defined $$dsn_2{$key} ? :
1261  ***      0      0      0   defined $_ ? :
1290  ***      0      0      0   unless $args{$arg}
1293  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1309  ***      0      0      0   unless defined(my $pid = fork)
1310  ***      0      0      0   if ($pid)
1317  ***      0      0      0   unless POSIX::setsid()
1318  ***      0      0      0   unless chdir '/'
1324  ***      0      0      0   if (-t STDIN)
1326  ***      0      0      0   unless open STDIN, '/dev/null'
1330  ***      0      0      0   if ($$self{'log_file'}) { }
1332  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1336  ***      0      0      0   unless open STDERR, '>&STDOUT'
1340  ***      0      0      0   if (-t STDOUT)
1342  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1345  ***      0      0      0   if (-t STDERR)
1347  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1358  ***      0      0      0   $self ? :
1360  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1363  ***      0      0      0   if $EVAL_ERROR
1365  ***      0      0      0   if ($pid) { }
1367  ***      0      0      0   if ($pid_is_alive) { }
1389  ***      0      0      0   if (exists $$self{'child'})
1401  ***      0      0      0   if (not $PID_file)
1408  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1410  ***      0      0      0   unless print $PID_FH $PID
1412  ***      0      0      0   unless close $PID_FH
1421  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1422  ***      0      0      0   unless unlink $$self{'PID_file'}
1434  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1440  ***      0      0      0   defined $_ ? :
1488  ***      0      0      0   defined $args{'p_ms'} ? :
1489  ***      0      0      0   defined $args{'p_s'} ? :
1492  ***      0      0      0   if $t < 0
1494  ***      0      0      0   if $t =~ /e/
1498  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1519  ***      0      0      0   $p ? :
1526  ***      0      0      0   unless $secs
1528  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1533  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1552  ***      0      0      0   defined $args{'p'} ? :
1553  ***      0      0      0   defined $args{'d'} ? :
1560  ***      0      0      0   $num =~ /\./ || $n ? :
1569  ***     50      0     11   $gmt ? :
1575  ***     50      0     11   if (my($us) = $time =~ /(\.\d+)$/)
1585  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1588  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
1597  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
1598  ***      0      0      0   $gmt ? :
1601  ***      0      0      0   if (defined $us)
1613  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
1614  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1624  ***      0      0      0   unless $hms
1629  ***      0      0      0   unless $hms
1634  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1650  ***      0      0      0   defined $_ ? :
1706  ***      0      0      0   unless $args{$arg}
1711  ***      0      0      0   unless $code
1714  ***      0      0      0   if ($$self{'curr_rows'}) { }
1720  ***      0      0      0   if ($rows and scalar @$rows) { }
1737  ***      0      0      0   if (not $curr and @curr)
1741  ***      0      0      0   if (not $prev and @prev)
1745  ***      0      0      0   if ($curr or $prev)
1746  ***      0      0      0   if ($curr and $prev and $$curr[0] == $$prev[0]) { }
      ***      0      0      0   elsif (not $curr or $curr and $prev and $$curr[0] > $$prev[0]) { }
1748  ***      0      0      0   $$curr[5] =~ /\D/ ? :
1750  ***      0      0      0   if ($$prev[7])
1751  ***      0      0      0   if (not $$curr[7] or $$prev[7] ne $$curr[7]) { }
      ***      0      0      0   elsif (defined $$curr[5] and $$curr[5] < $$prev[5]) { }
      ***      0      0      0   elsif ($$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge) { }
1766  ***      0      0      0   if ($is_new)
1770  ***      0      0      0   if ($$curr[7])
1771  ***      0      0      0   if ($$prev[7] and not $is_new) { }
1792  ***      0      0      0   if ($$curr[7] and defined $$curr[5])
1804  ***      0      0      0   scalar @curr ? :
1813  ***      0      0      0   if ($$row[5] < $time - $$row[10])
1847         100    104    354   if ($find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query')
1848         100     91     13   if ($$query{'Time'} < $find_spec{'busy_time'})
1856         100      1    366   if ($find_spec{'idle_time'} and ($$query{'Command'} || '') eq 'Sleep')
1857  ***     50      0      1   if ($$query{'Time'} < $find_spec{'idle_time'})
1868         100    118   1475   if (defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property}))
1873         100    236   1239   if (defined $find_spec{'match'}{$property})
1874         100    202     34   if (not $self->$filter($query, $find_spec{'match'}{$property}))
1882  ***     50     47      0   if ($matched)
1890         100      9      3   if (@matches and $find_spec{'only_oldest'})
1942  ***      0      0      0   defined $_ ? :
1981         100      1      1   unless @cols
1990  ***      0      0      0   unless @cols
2006         100      1      9   if ($text =~ /^\+---/m) { }
      ***     50      0      9   elsif ($text =~ /^id\tselect_type\t/m) { }
      ***     50      9      0   elsif ($text =~ /\*\*\* \d+\. row/) { }
2029  ***     50      0     10   if ($$self{'value_for'})
2032  ***      0      0      0   if exists $$self{'value_for'}{$$result_set{$key}}
2047         100      1      1   if ($row) { }
2066  ***      0      0      0   defined $_ ? :
2129         100      9      3   if (not $o->got('busy-time')) { }
2130  ***     50      9      0   unless $o->got('interval')
2133  ***     50      3      0   unless $o->got('interval')
2138         100     10      2   if (@ARGV)
2150         100      2     10   if (not @ARGV)
2153         100      1      1   $o->get('kill-query') ? :
2161         100     10      2   if (@ARGV) { }
2166  ***     50     10      0   if (not $fh)
2168  ***     50      0     10   unless $file
2169  ***     50      0     10   if ($file eq '-') { }
2173  ***     50      0     10   if (not open $fh, '<', $file)
2181  ***     50     10      0   if ($fh)
2184  ***     50     10      0   if ($proclist_text) { }
2209  ***     50      0     12   if ($o->get('daemonize')) { }
      ***     50      0     12   elsif ($o->get('pid')) { }
2227  ***     50     12      0   $o->get('ignore-self') ? :
2259  ***     50      0     12   if ($EVAL_ERROR)
2260  ***      0      0      0   if $EVAL_ERROR =~ /No more files/
2265  ***     50     12      0   if ($proclist) { }
2270  ***     50     11      0   if ($o->get('print'))
2271         100      1     10   $o->get('kill-query') ? :
2276  ***     50      0     11   if ($o->get('execute-command'))
2280         100      2      9   if ($o->get('kill') or $o->get('kill-query'))
2281  ***     50      0      2   if $o->get('wait-before-kill')
2296  ***     50      0     12   if (!$iters_todo || $iters_done < $iters_todo and $dbh)
2298  ***      0      0      0   if (@queries and $o->get('wait-after-kill')) { }
2321  ***     50      0      2   if ($o->get('ask-pass'))
2334  ***      0      0      0   unless $cmd
2337  ***      0      0      0   if ($pid)
2344  ***      0      0      0   unless POSIX::setsid()
2353  ***     50      0     38   if $o->get('heartbeat')
2360  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
1720  ***      0      0      0   $rows and scalar @$rows

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
256   ***     66    120    372      0   $type and $type eq 'd'
      ***     33    492      0      0   $type and $type eq 'd' and not $$self{'dp'}
261          100    120    288     84   $type and $type =~ /[HhAadzm]/
400   ***     33      0     12      0   @ARGV and $ARGV[0] eq '--config'
429   ***     33      0     12      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
436   ***     66      2     10      0   @ARGV and $$self{'strict'}
520   ***     66      0    120    372   $opt and $$opt{'type'}
523          100    285     83      4   $val and $$opt{'type'} eq 'm'
      ***     66    285     83      0   $val and $$opt{'type'} eq 'd'
      ***     66    285     83      0   $val and $$opt{'type'} eq 'z'
      ***     66    285     83      0   defined $val and $$opt{'type'} eq 'h'
      ***     66    285     71      0   defined $val and $$opt{'type'} eq 'a'
588   ***     33      0      0    369   $long and exists $$self{'opts'}{$long}
596   ***     33      0      0     72   $long and exists $$self{'opts'}{$long}
610   ***     33      0      0     22   $long and exists $$self{'opts'}{$long}
699   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
793   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1021  ***     66     18     30      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     48      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1143  ***     66      6      0      6   not $dbh and $tries--
1179  ***     33      6      0      0   not $dbh and $EVAL_ERROR
1360  ***      0      0      0      0   $PID_file and -f $PID_file
1421  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1498  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1556  ***      0      0      0      0   $num >= $d and $n < @units - 1
1634  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
1737  ***      0      0      0      0   not $curr and @curr
1741  ***      0      0      0      0   not $prev and @prev
1746  ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] == $$prev[0]
      ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] > $$prev[0]
1751  ***      0      0      0      0   defined $$curr[5] and $$curr[5] < $$prev[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge
1771  ***      0      0      0      0   $$prev[7] and not $is_new
1792  ***      0      0      0      0   $$curr[7] and defined $$curr[5]
1847  ***     66    354      0    104   $find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query'
1856  ***     66    366      0      1   $find_spec{'idle_time'} and ($$query{'Command'} || '') eq 'Sleep'
1868         100    914    561    118   defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property})
1890         100      2      1      9   @matches and $find_spec{'only_oldest'}
1901  ***     33      0      0      9   defined $property && defined $$query{'Id'}
      ***     66      0      7      2   defined $property && defined $$query{'Id'} && $$query{'Id'} == $property
1906  ***     33      0      0    365   defined $property && defined $$query{'User'}
      ***     66      0    253    112   defined $property && defined $$query{'User'} && $$query{'User'} =~ /$property/
1912  ***      0      0      0      0   defined $property && defined $$query{'Host'}
      ***      0      0      0      0   defined $property && defined $$query{'Host'} && $$query{'Host'} =~ /$property/
1918  ***      0      0      0      0   defined $property && defined $$query{'db'}
      ***      0      0      0      0   defined $property && defined $$query{'db'} && $$query{'db'} =~ /$property/
1924  ***     66      0     93    387   defined $property && defined $$query{'State'}
             100     93    357     30   defined $property && defined $$query{'State'} && $$query{'State'} =~ /$property/
1930  ***     33      0      0     55   defined $property && defined $$query{'Command'}
      ***     66      0     50      5   defined $property && defined $$query{'Command'} && $$query{'Command'} =~ /$property/
1936  ***     66      0      3      3   defined $property && defined $$query{'Info'}
      ***     66      3      0      3   defined $property && defined $$query{'Info'} && $$query{'Info'} =~ /$property/
2252  ***     66      0     12     12   $start == $end || $now < $end and !$iters_todo || $iters_done++ < $iters_todo
2296  ***     33     12      0      0   !$iters_todo || $iters_done < $iters_todo and $dbh
2298  ***      0      0      0      0   @queries and $o->get('wait-after-kill')

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
41    ***     50      0      5   $ENV{'MKDEBUG'} || 0
61    ***     50     12      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
63    ***     50     12      0   $args{'prompt'} || '<options>'
      ***     50      0     12   $args{'dp'} || undef
105   ***     50      0     12   $file ||= '/home/daniel/dev/maatkit/mk-kill/mk-kill'
246   ***     50    492      0   $$opt{'group'} ||= 'default'
528   ***     50      0      4   $s || 's'
537   ***     50      0      4   $prefix || ''
565   ***      0      0      0   $pre || ''
572   ***      0      0      0   $val || ''
575   ***     50     12      0   $val || ''
633   ***      0      0      0   $$self{'description'} || ''
701   ***      0      0      0   $s ||= 's'
727   ***      0      0      0   $$opt{'type'} || ''
875   ***     50      0      5   $ENV{'MKDEBUG'} || 0
931   ***     50      0      5   $ENV{'MKDEBUG'} || 0
1002  ***     50      0      6   $prev ||= {}
1003  ***     50      0      6   $defaults ||= {}
1076  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1089  ***     50      0      6   $self->prop('dbidriver') || ''
1093  ***      0      0      0   $$info{'D'} || ''
1099  ***     50      0      6   $$info{'D'} || ''
1121  ***     50      6      0   $opts ||= {}
1216  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1232  ***      0      0      0   $level ||= 0
1233  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1285  ***     50      0      5   $ENV{'MKDEBUG'} || 0
1464  ***     50      0      5   $ENV{'MKDEBUG'} || 0
1518  ***      0      0      0   $args{'p'} || 0
1520  ***      0      0      0   $of ||= 1
1525  ***      0      0      0   $secs ||= 0
1676  ***     50      0      5   $ENV{'MKDEBUG'} || 0
1729  ***      0      0      0   $$self{'prev_rows'} ||= []
1730  ***      0      0      0   $$self{'new_rows'} ||= []
1847  ***     50    104      0   $$query{'Command'} || ''
1856  ***     50      1      0   $$query{'Command'} || ''
1969  ***     50      0      5   $ENV{'MKDEBUG'} || 0
2094  ***     50      0      5   $ENV{'MKDEBUG'} || 0
2224  ***     50      0     12   $o->get('run-time') || 0
2271  ***     50     11      0   $$query{'Command'} || 'NULL'
      ***     50     11      0   $$query{'Info'} || 'NULL'

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
60    ***     33     12      0      0   $program_name ||= $PROGRAM_NAME
61    ***     33     12      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     12      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
523   ***     33      0      0    368   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66     12      0    356   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1112  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1113  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1114  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1115  ***      0      0      0      0   $$dsn{'u'} ||= $user
1116  ***      0      0      0      0   $$dsn{'D'} ||= $db
1434  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1528  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1560  ***      0      0      0      0   $num =~ /\./ || $n
1745  ***      0      0      0      0   $curr or $prev
1746  ***      0      0      0      0   not $curr or $curr and $prev and $$curr[0] > $$prev[0]
1751  ***      0      0      0      0   not $$curr[7] or $$prev[7] ne $$curr[7]
2252  ***     33     24      0      0   $start == $end || $now < $end
      ***     66      0     12     12   !$iters_todo || $iters_done++ < $iters_todo
2280         100      1      1      9   $o->get('kill') or $o->get('kill-query')
2296  ***     33      0      0     12   !$iters_todo || $iters_done < $iters_todo


Covered Subroutines
-------------------

Subroutine           Count Location                                     
-------------------- ----- ---------------------------------------------
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1279
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1280
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1282
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1283
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1285
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1458
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1459
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1460
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1461
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1462
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1464
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1667
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1668
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1669
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1671
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1676
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1689
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1960
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1961
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1962
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1964
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:1969
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:2088
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:2089
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:2090
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:2094
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:22  
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:23  
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:34  
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:35  
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:37  
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:38  
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:39  
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:41  
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:870 
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:871 
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:873 
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:875 
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:919 
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:920 
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:921 
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:922 
BEGIN                    5 /home/daniel/dev/maatkit/mk-kill/mk-kill:931 
__ANON__                10 /home/daniel/dev/maatkit/mk-kill/mk-kill:2166
__ANON__                 2 /home/daniel/dev/maatkit/mk-kill/mk-kill:2200
__ANON__                33 /home/daniel/dev/maatkit/mk-kill/mk-kill:424 
_find_match_Command     55 /home/daniel/dev/maatkit/mk-kill/mk-kill:1929
_find_match_Id           9 /home/daniel/dev/maatkit/mk-kill/mk-kill:1900
_find_match_Info         6 /home/daniel/dev/maatkit/mk-kill/mk-kill:1935
_find_match_State      480 /home/daniel/dev/maatkit/mk-kill/mk-kill:1923
_find_match_User       365 /home/daniel/dev/maatkit/mk-kill/mk-kill:1905
_get_participants       12 /home/daniel/dev/maatkit/mk-kill/mk-kill:324 
_parse_specs            12 /home/daniel/dev/maatkit/mk-kill/mk-kill:210 
_parse_tabular           2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1978
_pod_to_specs           12 /home/daniel/dev/maatkit/mk-kill/mk-kill:104 
_read_config_file       48 /home/daniel/dev/maatkit/mk-kill/mk-kill:776 
_set_option             33 /home/daniel/dev/maatkit/mk-kill/mk-kill:370 
_validate_type         492 /home/daniel/dev/maatkit/mk-kill/mk-kill:519 
find                    12 /home/daniel/dev/maatkit/mk-kill/mk-kill:1839
get                    369 /home/daniel/dev/maatkit/mk-kill/mk-kill:586 
get_cxn                  2 /home/daniel/dev/maatkit/mk-kill/mk-kill:2320
get_cxn_params           6 /home/daniel/dev/maatkit/mk-kill/mk-kill:1086
get_dbh                  6 /home/daniel/dev/maatkit/mk-kill/mk-kill:1120
get_defaults_files      12 /home/daniel/dev/maatkit/mk-kill/mk-kill:99  
get_opts                12 /home/daniel/dev/maatkit/mk-kill/mk-kill:387 
get_specs               12 /home/daniel/dev/maatkit/mk-kill/mk-kill:92  
got                     72 /home/daniel/dev/maatkit/mk-kill/mk-kill:594 
has                     28 /home/daniel/dev/maatkit/mk-kill/mk-kill:602 
heartbeat               38 /home/daniel/dev/maatkit/mk-kill/mk-kill:2352
main                    12 /home/daniel/dev/maatkit/mk-kill/mk-kill:2106
new                     12 /home/daniel/dev/maatkit/mk-kill/mk-kill:1692
new                     10 /home/daniel/dev/maatkit/mk-kill/mk-kill:1972
new                     12 /home/daniel/dev/maatkit/mk-kill/mk-kill:55  
new                     12 /home/daniel/dev/maatkit/mk-kill/mk-kill:878 
new                     16 /home/daniel/dev/maatkit/mk-kill/mk-kill:934 
parse                   10 /home/daniel/dev/maatkit/mk-kill/mk-kill:2003
parse                    6 /home/daniel/dev/maatkit/mk-kill/mk-kill:996 
parse_horizontal_row     1 /home/daniel/dev/maatkit/mk-kill/mk-kill:2042
parse_options            2 /home/daniel/dev/maatkit/mk-kill/mk-kill:1047
parse_vertical_row     448 /home/daniel/dev/maatkit/mk-kill/mk-kill:1996
prop                    18 /home/daniel/dev/maatkit/mk-kill/mk-kill:987 
set                     22 /home/daniel/dev/maatkit/mk-kill/mk-kill:608 
split_vertical_rows      9 /home/daniel/dev/maatkit/mk-kill/mk-kill:2058
ts                      11 /home/daniel/dev/maatkit/mk-kill/mk-kill:1568
usage_or_errors         12 /home/daniel/dev/maatkit/mk-kill/mk-kill:643 

Uncovered Subroutines
---------------------

Subroutine           Count Location                                     
-------------------- ----- ---------------------------------------------
DESTROY                  0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1433
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1260
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1439
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1649
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1941
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2065
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2359
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:852 
_d                       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:901 
_find_match_Host         0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1911
_find_match_db           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1917
_get_rows                0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1832
_make_PID_file           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1398
_parse_tab_sep           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1987
_remove_PID_file         0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1420
any_unix_timestamp       0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1611
as_string                0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1060
check_PID_file           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1357
clone                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:829 
copy                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1242
daemonize                0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1306
descr                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:632 
disconnect               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1225
errors                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:622 
exec_cmd                 0 /home/daniel/dev/maatkit/mk-kill/mk-kill:2332
fill_in_dsn              0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1108
get_defaults             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:360 
get_groups               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:365 
get_hostname             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1215
make_PID_file            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1388
make_checksum            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1642
make_event               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1811
micro_t                  0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1487
new                      0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1288
opts                     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:336 
parse                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:883 
parse_event              0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1703
parse_timestamp          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1584
percentage_of            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1517
print_active_handles     0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1231
print_errors             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:656 
print_usage              0 /home/daniel/dev/maatkit/mk-kill/mk-kill:666 
prompt                   0 /home/daniel/dev/maatkit/mk-kill/mk-kill:627 
prompt_noecho            0 /home/daniel/dev/maatkit/mk-kill/mk-kill:741 
read_para_after          0 /home/daniel/dev/maatkit/mk-kill/mk-kill:810 
save_error               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:617 
secs_to_time             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1524
set_defaults             0 /home/daniel/dev/maatkit/mk-kill/mk-kill:348 
short_opts               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:342 
shorten                  0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1551
unix_timestamp           0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1596
usage                    0 /home/daniel/dev/maatkit/mk-kill/mk-kill:1069
version_ge               0 /home/daniel/dev/maatkit/mk-kill/mk-kill:890 


