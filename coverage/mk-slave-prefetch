---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...refetch/mk-slave-prefetch   20.7    7.7    8.0   37.1    n/a    0.7   17.1
mk-slave-prefetch.t            96.8   50.0   33.3  100.0    n/a   99.3   91.1
Total                          22.8    8.0    8.2   39.0    n/a  100.0   18.6
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:40:03 2010
Finish:       Thu Jan 28 22:40:03 2010

Run:          ./mk-slave-prefetch.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:40:05 2010
Finish:       Thu Jan 28 22:40:07 2010

/home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-slave-prefetch, a program to pipeline relay logs on a MySQL slave.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22             1                    1            10   use strict;
               1                                  4   
               1                                 16   
23             1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
28                                                    
29             1                    1            11   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
30                                                    $OUTPUT_AUTOFLUSH = 1;
31                                                    
32                                                    # ###########################################################################
33                                                    # OptionParser package 5266
34                                                    # ###########################################################################
35                                                    package OptionParser;
36                                                    
37             1                    1             7   use strict;
               1                                  2   
               1                                  8   
38             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
39                                                    
40             1                    1             9   use Getopt::Long;
               1                                  4   
               1                                  7   
41             1                    1             7   use List::Util qw(max);
               1                                  2   
               1                                 11   
42             1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
43                                                    
44    ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 24   
45                                                    
46                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
47                                                    
48                                                    my %attributes = (
49                                                       'type'       => 1,
50                                                       'short form' => 1,
51                                                       'group'      => 1,
52                                                       'default'    => 1,
53                                                       'cumulative' => 1,
54                                                       'negatable'  => 1,
55                                                    );
56                                                    
57                                                    sub new {
58    ***      0                    0             0      my ( $class, %args ) = @_;
59    ***      0                                  0      foreach my $arg ( qw(description) ) {
60    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
61                                                       }
62    ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
63    ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
64    ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
65                                                    
66    ***      0      0      0                    0      my $self = {
      ***                    0                        
67                                                          description    => $args{description},
68                                                          prompt         => $args{prompt} || '<options>',
69                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
70                                                          dp             => $args{dp}     || undef,
71                                                          program_name   => $program_name,
72                                                          opts           => {},
73                                                          got_opts       => 0,
74                                                          short_opts     => {},
75                                                          defaults       => {},
76                                                          groups         => {},
77                                                          allowed_groups => {},
78                                                          errors         => [],
79                                                          rules          => [],  # desc of rules for --help
80                                                          mutex          => [],  # rule: opts are mutually exclusive
81                                                          atleast1       => [],  # rule: at least one opt is required
82                                                          disables       => {},  # rule: opt disables other opts 
83                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
84                                                          default_files  => [
85                                                             "/etc/maatkit/maatkit.conf",
86                                                             "/etc/maatkit/$program_name.conf",
87                                                             "$home/.maatkit.conf",
88                                                             "$home/.$program_name.conf",
89                                                          ],
90                                                       };
91    ***      0                                  0      return bless $self, $class;
92                                                    }
93                                                    
94                                                    sub get_specs {
95    ***      0                    0             0      my ( $self, $file ) = @_;
96    ***      0                                  0      my @specs = $self->_pod_to_specs($file);
97    ***      0                                  0      $self->_parse_specs(@specs);
98    ***      0                                  0      return;
99                                                    }
100                                                   
101                                                   sub get_defaults_files {
102   ***      0                    0             0      my ( $self ) = @_;
103   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
104                                                   }
105                                                   
106                                                   sub _pod_to_specs {
107   ***      0                    0             0      my ( $self, $file ) = @_;
108   ***      0             0                    0      $file ||= __FILE__;
109   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
110                                                   
111   ***      0                                  0      my %types = (
112                                                         string => 's', # standard Getopt type
113                                                         'int'  => 'i', # standard Getopt type
114                                                         float  => 'f', # standard Getopt type
115                                                         Hash   => 'H', # hash, formed from a comma-separated list
116                                                         hash   => 'h', # hash as above, but only if a value is given
117                                                         Array  => 'A', # array, similar to Hash
118                                                         array  => 'a', # array, similar to hash
119                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
120                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
121                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
122                                                      );
123   ***      0                                  0      my @specs = ();
124   ***      0                                  0      my @rules = ();
125   ***      0                                  0      my $para;
126                                                   
127   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
128   ***      0                                  0      while ( $para = <$fh> ) {
129   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
130   ***      0                                  0         last;
131                                                      }
132                                                   
133   ***      0                                  0      while ( $para = <$fh> ) {
134   ***      0      0                           0         last if $para =~ m/^=over/;
135   ***      0                                  0         chomp $para;
136   ***      0                                  0         $para =~ s/\s+/ /g;
137   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
138   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
139   ***      0                                  0         push @rules, $para;
140                                                      }
141                                                   
142   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
143                                                   
144   ***      0                                  0      do {
145   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
146   ***      0                                  0            chomp $para;
147   ***      0                                  0            MKDEBUG && _d($para);
148   ***      0                                  0            my %attribs;
149                                                   
150   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
151                                                   
152   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
153   ***      0                                  0               $para =~ s/\s+\Z//g;
154   ***      0                                  0               %attribs = map {
155   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
156   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
157                                                                        unless $attributes{$attrib};
158   ***      0                                  0                     ($attrib, $val);
159                                                                  } split(/; /, $para);
160   ***      0      0                           0               if ( $attribs{'short form'} ) {
161   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
162                                                               }
163   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
164                                                            }
165                                                            else {
166   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
167                                                            }
168                                                   
169   ***      0                                  0            $para =~ s/\s+\Z//g;
170   ***      0                                  0            $para =~ s/\s+/ /g;
171   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
172                                                   
173   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
174   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
175                                                   
176   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
177                                                   
178   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
179   ***      0                                  0               $option = $base_option;
180   ***      0                                  0               $attribs{'negatable'} = 1;
181                                                            }
182                                                   
183   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
184                                                               spec  => $option
185                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
186                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
187                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
188                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
189                                                               desc  => $para
190                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
191                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
192                                                            };
193                                                         }
194   ***      0                                  0         while ( $para = <$fh> ) {
195   ***      0      0                           0            last unless $para;
196                                                   
197                                                   
198   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
199   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
200   ***      0                                  0               last;
201                                                            }
202   ***      0      0                           0            last if $para =~ m/^=item --/;
203                                                         }
204                                                      } while ( $para );
205                                                   
206   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
207                                                   
208   ***      0                                  0      close $fh;
209   ***      0                                  0      return @specs, @rules;
210                                                   }
211                                                   
212                                                   sub _parse_specs {
213   ***      0                    0             0      my ( $self, @specs ) = @_;
214   ***      0                                  0      my %disables; # special rule that requires deferred checking
215                                                   
216   ***      0                                  0      foreach my $opt ( @specs ) {
217   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
218                                                            MKDEBUG && _d('Parsing opt spec:',
219   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
220                                                   
221   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
222   ***      0      0                           0            if ( !$long ) {
223   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
224                                                            }
225   ***      0                                  0            $opt->{long} = $long;
226                                                   
227   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
228   ***      0                                  0            $self->{opts}->{$long} = $opt;
229                                                   
230   ***      0      0                           0            if ( length $long == 1 ) {
231   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
232   ***      0                                  0               $self->{short_opts}->{$long} = $long;
233                                                            }
234                                                   
235   ***      0      0                           0            if ( $short ) {
236   ***      0      0                           0               die "Duplicate short option -$short"
237                                                                  if exists $self->{short_opts}->{$short};
238   ***      0                                  0               $self->{short_opts}->{$short} = $long;
239   ***      0                                  0               $opt->{short} = $short;
240                                                            }
241                                                            else {
242   ***      0                                  0               $opt->{short} = undef;
243                                                            }
244                                                   
245   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
246   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
247   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
248                                                   
249   ***      0             0                    0            $opt->{group} ||= 'default';
250   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
251                                                   
252   ***      0                                  0            $opt->{value} = undef;
253   ***      0                                  0            $opt->{got}   = 0;
254                                                   
255   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
256   ***      0                                  0            $opt->{type} = $type;
257   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
258                                                   
259   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
260   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
261                                                                  . "was given when this OptionParser object was created";
262                                                            }
263                                                   
264   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
265                                                   
266   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
267   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
268   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
269                                                            }
270                                                   
271   ***      0      0                           0            if ( $long eq 'config' ) {
272   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
273                                                            }
274                                                   
275   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
276   ***      0                                  0               $disables{$long} = $dis;
277   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
278                                                            }
279                                                   
280   ***      0                                  0            $self->{opts}->{$long} = $opt;
281                                                         }
282                                                         else { # It's an option rule, not a spec.
283   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
284   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
285   ***      0                                  0            my @participants = $self->_get_participants($opt);
286   ***      0                                  0            my $rule_ok = 0;
287                                                   
288   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
289   ***      0                                  0               $rule_ok = 1;
290   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
291   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
292                                                            }
293   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
294   ***      0                                  0               $rule_ok = 1;
295   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
296   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
297                                                            }
298   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
299   ***      0                                  0               $rule_ok = 1;
300   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
301   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
302                                                            }
303   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
304   ***      0                                  0               $rule_ok = 1;
305   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
306   ***      0                                  0               my @groups = split(',', $groups);
307   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
308   ***      0                                  0                  s/\s+//;
309   ***      0                                  0                  $_ => 1;
310                                                               } @groups;
311                                                            }
312                                                   
313   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
314                                                         }
315                                                      }
316                                                   
317   ***      0                                  0      foreach my $long ( keys %disables ) {
318   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
319   ***      0                                  0         $self->{disables}->{$long} = \@participants;
320   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
321                                                      }
322                                                   
323   ***      0                                  0      return; 
324                                                   }
325                                                   
326                                                   sub _get_participants {
327   ***      0                    0             0      my ( $self, $str ) = @_;
328   ***      0                                  0      my @participants;
329   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
330   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
331                                                            unless exists $self->{opts}->{$long};
332   ***      0                                  0         push @participants, $long;
333                                                      }
334   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
335   ***      0                                  0      return @participants;
336                                                   }
337                                                   
338                                                   sub opts {
339   ***      0                    0             0      my ( $self ) = @_;
340   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
341   ***      0                                  0      return %opts;
342                                                   }
343                                                   
344                                                   sub short_opts {
345   ***      0                    0             0      my ( $self ) = @_;
346   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
347   ***      0                                  0      return %short_opts;
348                                                   }
349                                                   
350                                                   sub set_defaults {
351   ***      0                    0             0      my ( $self, %defaults ) = @_;
352   ***      0                                  0      $self->{defaults} = {};
353   ***      0                                  0      foreach my $long ( keys %defaults ) {
354   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
355                                                            unless exists $self->{opts}->{$long};
356   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
357   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
358                                                      }
359   ***      0                                  0      return;
360                                                   }
361                                                   
362                                                   sub get_defaults {
363   ***      0                    0             0      my ( $self ) = @_;
364   ***      0                                  0      return $self->{defaults};
365                                                   }
366                                                   
367                                                   sub get_groups {
368   ***      0                    0             0      my ( $self ) = @_;
369   ***      0                                  0      return $self->{groups};
370                                                   }
371                                                   
372                                                   sub _set_option {
373   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
374   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
375                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
376                                                               : die "Getopt::Long gave a nonexistent option: $opt";
377                                                   
378   ***      0                                  0      $opt = $self->{opts}->{$long};
379   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
380   ***      0                                  0         $opt->{value}++;
381                                                      }
382                                                      else {
383   ***      0                                  0         $opt->{value} = $val;
384                                                      }
385   ***      0                                  0      $opt->{got} = 1;
386   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
387                                                   }
388                                                   
389                                                   sub get_opts {
390   ***      0                    0             0      my ( $self ) = @_; 
391                                                   
392   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
393   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
394   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
395                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
396                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
397                                                            : undef;
398                                                      }
399   ***      0                                  0      $self->{got_opts} = 0;
400                                                   
401   ***      0                                  0      $self->{errors} = [];
402                                                   
403   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
404   ***      0                                  0         shift @ARGV;
405   ***      0                                  0         $self->_set_option('config', shift @ARGV);
406                                                      }
407   ***      0      0                           0      if ( $self->has('config') ) {
408   ***      0                                  0         my @extra_args;
409   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
410   ***      0                                  0            eval {
411   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
412                                                            };
413   ***      0      0                           0            if ( $EVAL_ERROR ) {
414   ***      0      0                           0               if ( $self->got('config') ) {
415   ***      0                                  0                  die $EVAL_ERROR;
416                                                               }
417                                                               elsif ( MKDEBUG ) {
418                                                                  _d($EVAL_ERROR);
419                                                               }
420                                                            }
421                                                         }
422   ***      0                                  0         unshift @ARGV, @extra_args;
423                                                      }
424                                                   
425   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
426                                                      GetOptions(
427   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
428   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
429   ***      0      0                           0         values %{$self->{opts}}
430                                                      ) or $self->save_error('Error parsing options');
431                                                   
432   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
433   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
434                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
435                                                               or die "Cannot print: $OS_ERROR";
436   ***      0                                  0         exit 0;
437                                                      }
438                                                   
439   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
440   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
441                                                      }
442                                                   
443   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
444   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
445   ***      0      0                           0         if ( @set > 1 ) {
446   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
447   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
448                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
449                                                                    . ' are mutually exclusive.';
450   ***      0                                  0            $self->save_error($err);
451                                                         }
452                                                      }
453                                                   
454   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
455   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
456   ***      0      0                           0         if ( @set == 0 ) {
457   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
458   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
459                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
460   ***      0                                  0            $self->save_error("Specify at least one of $err");
461                                                         }
462                                                      }
463                                                   
464   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
465   ***      0                                  0         my $opt = $self->{opts}->{$long};
466   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
467   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
468   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
469   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
470   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
471                                                                  'because', $long,'disables them');
472                                                            }
473                                                   
474   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
475                                                   
476   ***      0                                  0               my @restricted_groups = grep {
477   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
478   ***      0                                  0               } keys %{$self->{groups}};
479                                                   
480   ***      0                                  0               my @restricted_opts;
481   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
482   ***      0                                  0                  RESTRICTED_OPT:
483   ***      0                                  0                  foreach my $restricted_opt (
484                                                                     keys %{$self->{groups}->{$restricted_group}} )
485                                                                  {
486   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
487   ***      0      0                           0                     push @restricted_opts, $restricted_opt
488                                                                        if $self->{opts}->{$restricted_opt}->{got};
489                                                                  }
490                                                               }
491                                                   
492   ***      0      0                           0               if ( @restricted_opts ) {
493   ***      0                                  0                  my $err;
494   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
495   ***      0                                  0                     $err = "--$restricted_opts[0]";
496                                                                  }
497                                                                  else {
498   ***      0                                  0                     $err = join(', ',
499   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
500   ***      0                                  0                               grep { $_ } 
501                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
502                                                                            )
503                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
504                                                                  }
505   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
506                                                               }
507                                                            }
508                                                   
509                                                         }
510                                                         elsif ( $opt->{is_required} ) { 
511   ***      0                                  0            $self->save_error("Required option --$long must be specified");
512                                                         }
513                                                   
514   ***      0                                  0         $self->_validate_type($opt);
515                                                      }
516                                                   
517   ***      0                                  0      $self->{got_opts} = 1;
518   ***      0                                  0      return;
519                                                   }
520                                                   
521                                                   sub _validate_type {
522   ***      0                    0             0      my ( $self, $opt ) = @_;
523   ***      0      0      0                    0      return unless $opt && $opt->{type};
524   ***      0                                  0      my $val = $opt->{value};
525                                                   
526   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
527   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
528   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
529   ***      0      0                           0         if ( !$suffix ) {
530   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
531   ***      0             0                    0            $suffix = $s || 's';
532   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
533                                                               $opt->{long}, '(value:', $val, ')');
534                                                         }
535   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
536   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
537                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
538                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
539                                                                 :                  $num * 86400;   # Days
540   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
541   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
542                                                         }
543                                                         else {
544   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
545                                                         }
546                                                      }
547                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
548   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
549   ***      0                                  0         my $prev = {};
550   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
551   ***      0      0                           0         if ( $from_key ) {
552   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
553   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
554                                                         }
555   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
556   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
557                                                      }
558                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
559   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
560   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
561   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
562   ***      0      0                           0         if ( defined $num ) {
563   ***      0      0                           0            if ( $factor ) {
564   ***      0                                  0               $num *= $factor_for{$factor};
565   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
566                                                                  'to num', $num, '* factor', $factor);
567                                                            }
568   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
569                                                         }
570                                                         else {
571   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
572                                                         }
573                                                      }
574                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
575   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
576                                                      }
577                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
578   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
579                                                      }
580                                                      else {
581   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
582                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
583                                                      }
584                                                   
585   ***      0                                  0      return;
586                                                   }
587                                                   
588                                                   sub get {
589   ***      0                    0             0      my ( $self, $opt ) = @_;
590   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
591   ***      0      0      0                    0      die "Option $opt does not exist"
592                                                         unless $long && exists $self->{opts}->{$long};
593   ***      0                                  0      return $self->{opts}->{$long}->{value};
594                                                   }
595                                                   
596                                                   sub got {
597   ***      0                    0             0      my ( $self, $opt ) = @_;
598   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
599   ***      0      0      0                    0      die "Option $opt does not exist"
600                                                         unless $long && exists $self->{opts}->{$long};
601   ***      0                                  0      return $self->{opts}->{$long}->{got};
602                                                   }
603                                                   
604                                                   sub has {
605   ***      0                    0             0      my ( $self, $opt ) = @_;
606   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
607   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
608                                                   }
609                                                   
610                                                   sub set {
611   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
612   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
613   ***      0      0      0                    0      die "Option $opt does not exist"
614                                                         unless $long && exists $self->{opts}->{$long};
615   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
616   ***      0                                  0      return;
617                                                   }
618                                                   
619                                                   sub save_error {
620   ***      0                    0             0      my ( $self, $error ) = @_;
621   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
622                                                   }
623                                                   
624                                                   sub errors {
625   ***      0                    0             0      my ( $self ) = @_;
626   ***      0                                  0      return $self->{errors};
627                                                   }
628                                                   
629                                                   sub prompt {
630   ***      0                    0             0      my ( $self ) = @_;
631   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
632                                                   }
633                                                   
634                                                   sub descr {
635   ***      0                    0             0      my ( $self ) = @_;
636   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
637                                                                 . "  For more details, please use the --help option, "
638                                                                 . "or try 'perldoc $PROGRAM_NAME' "
639                                                                 . "for complete documentation.";
640   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
641   ***      0                                  0      $descr =~ s/ +$//mg;
642   ***      0                                  0      return $descr;
643                                                   }
644                                                   
645                                                   sub usage_or_errors {
646   ***      0                    0             0      my ( $self ) = @_;
647   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
648   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
649   ***      0                                  0         exit 0;
650                                                      }
651                                                      elsif ( scalar @{$self->{errors}} ) {
652   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
653   ***      0                                  0         exit 0;
654                                                      }
655   ***      0                                  0      return;
656                                                   }
657                                                   
658                                                   sub print_errors {
659   ***      0                    0             0      my ( $self ) = @_;
660   ***      0                                  0      my $usage = $self->prompt() . "\n";
661   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
662   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
663                                                                 . "\n";
664                                                      }
665   ***      0                                  0      return $usage . "\n" . $self->descr();
666                                                   }
667                                                   
668                                                   sub print_usage {
669   ***      0                    0             0      my ( $self ) = @_;
670   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
671   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
672                                                   
673   ***      0      0                           0      my $maxl = max(
674   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
675                                                         @opts);
676                                                   
677   ***      0      0                           0      my $maxs = max(0,
678   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
679   ***      0                                  0         values %{$self->{short_opts}});
680                                                   
681   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
682   ***      0                                  0      my $rcol = 80 - $lcol - 6;
683   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
684                                                   
685   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
686                                                   
687   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
688                                                   
689   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
690   ***      0                                  0      push @groups, 'default';
691                                                   
692   ***      0                                  0      foreach my $group ( reverse @groups ) {
693   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
694   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
695   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
696                                                            grep { $_->{group} eq $group }
697                                                            @opts )
698                                                         {
699   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
700   ***      0                                  0            my $short = $opt->{short};
701   ***      0                                  0            my $desc  = $opt->{desc};
702   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
703   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
704   ***      0             0                    0               $s    ||= 's';
705   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
706   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
707                                                                      . "d=days; if no suffix, $s is used.";
708                                                            }
709   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
710   ***      0                                  0            $desc =~ s/ +$//mg;
711   ***      0      0                           0            if ( $short ) {
712   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
713                                                            }
714                                                            else {
715   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
716                                                            }
717                                                         }
718                                                      }
719                                                   
720   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
721   ***      0                                  0         $usage .= "\nRules:\n\n";
722   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
723                                                      }
724   ***      0      0                           0      if ( $self->{dp} ) {
725   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
726                                                      }
727   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
728   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
729   ***      0                                  0         my $val   = $opt->{value};
730   ***      0             0                    0         my $type  = $opt->{type} || '';
731   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
732   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
733                                                                   : !defined $val             ? '(No value)'
734                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
735                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
736                                                                   : $type =~ m/A|a/           ? join(',', @$val)
737                                                                   :                             $val;
738   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
739                                                      }
740   ***      0                                  0      return $usage;
741                                                   }
742                                                   
743                                                   sub prompt_noecho {
744   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
745   ***      0                                  0      my ( $prompt ) = @_;
746   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
747   ***      0      0                           0      print $prompt
748                                                         or die "Cannot print: $OS_ERROR";
749   ***      0                                  0      my $response;
750   ***      0                                  0      eval {
751   ***      0                                  0         require Term::ReadKey;
752   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
753   ***      0                                  0         chomp($response = <STDIN>);
754   ***      0                                  0         Term::ReadKey::ReadMode('normal');
755   ***      0      0                           0         print "\n"
756                                                            or die "Cannot print: $OS_ERROR";
757                                                      };
758   ***      0      0                           0      if ( $EVAL_ERROR ) {
759   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
760                                                      }
761   ***      0                                  0      return $response;
762                                                   }
763                                                   
764                                                   if ( MKDEBUG ) {
765                                                      print '# ', $^X, ' ', $], "\n";
766                                                      my $uname = `uname -a`;
767                                                      if ( $uname ) {
768                                                         $uname =~ s/\s+/ /g;
769                                                         print "# $uname\n";
770                                                      }
771                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
772                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
773                                                         ($main::SVN_REV || ''), __LINE__);
774                                                      print('# Arguments: ',
775                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
776                                                   }
777                                                   
778                                                   sub _read_config_file {
779   ***      0                    0             0      my ( $self, $filename ) = @_;
780   ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
781   ***      0                                  0      my @args;
782   ***      0                                  0      my $prefix = '--';
783   ***      0                                  0      my $parse  = 1;
784                                                   
785                                                      LINE:
786   ***      0                                  0      while ( my $line = <$fh> ) {
787   ***      0                                  0         chomp $line;
788   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
789   ***      0                                  0         $line =~ s/\s+#.*$//g;
790   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
791   ***      0      0                           0         if ( $line eq '--' ) {
792   ***      0                                  0            $prefix = '';
793   ***      0                                  0            $parse  = 0;
794   ***      0                                  0            next LINE;
795                                                         }
796   ***      0      0      0                    0         if ( $parse
      ***             0                               
797                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
798                                                         ) {
799   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
800                                                         }
801                                                         elsif ( $line =~ m/./ ) {
802   ***      0                                  0            push @args, $line;
803                                                         }
804                                                         else {
805   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
806                                                         }
807                                                      }
808   ***      0                                  0      close $fh;
809   ***      0                                  0      return @args;
810                                                   }
811                                                   
812                                                   sub read_para_after {
813   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
814   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
815   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
816   ***      0                                  0      my $para;
817   ***      0                                  0      while ( $para = <$fh> ) {
818   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
819   ***      0                                  0         last;
820                                                      }
821   ***      0                                  0      while ( $para = <$fh> ) {
822   ***      0      0                           0         next unless $para =~ m/$regex/;
823   ***      0                                  0         last;
824                                                      }
825   ***      0                                  0      $para = <$fh>;
826   ***      0                                  0      chomp($para);
827   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
828   ***      0                                  0      return $para;
829                                                   }
830                                                   
831                                                   sub clone {
832   ***      0                    0             0      my ( $self ) = @_;
833                                                   
834   ***      0                                  0      my %clone = map {
835   ***      0                                  0         my $hashref  = $self->{$_};
836   ***      0                                  0         my $val_copy = {};
837   ***      0                                  0         foreach my $key ( keys %$hashref ) {
838   ***      0                                  0            my $ref = ref $hashref->{$key};
839   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
840   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
841   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
842                                                                              : $hashref->{$key};
843                                                         }
844   ***      0                                  0         $_ => $val_copy;
845                                                      } qw(opts short_opts defaults);
846                                                   
847   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
848   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
849                                                      }
850                                                   
851   ***      0                                  0      return bless \%clone;     
852                                                   }
853                                                   
854                                                   sub _d {
855   ***      0                    0             0      my ($package, undef, $line) = caller 0;
856   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
857   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
858                                                           @_;
859   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
860                                                   }
861                                                   
862                                                   1;
863                                                   
864                                                   # ###########################################################################
865                                                   # End OptionParser package
866                                                   # ###########################################################################
867                                                   
868                                                   # ###########################################################################
869                                                   # VersionParser package 5266
870                                                   # ###########################################################################
871                                                   package VersionParser;
872                                                   
873            1                    1            13   use strict;
               1                                  3   
               1                                  8   
874            1                    1            11   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
875                                                   
876            1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                 11   
877                                                   
878   ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 17   
879                                                   
880                                                   sub new {
881   ***      0                    0             0      my ( $class ) = @_;
882   ***      0                                  0      bless {}, $class;
883                                                   }
884                                                   
885                                                   sub parse {
886   ***      0                    0             0      my ( $self, $str ) = @_;
887   ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
888   ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
889   ***      0                                  0      return $result;
890                                                   }
891                                                   
892                                                   sub version_ge {
893   ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
894   ***      0      0                           0      if ( !$self->{$dbh} ) {
895   ***      0                                  0         $self->{$dbh} = $self->parse(
896                                                            $dbh->selectrow_array('SELECT VERSION()'));
897                                                      }
898   ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
899   ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
900   ***      0                                  0      return $result;
901                                                   }
902                                                   
903                                                   sub _d {
904   ***      0                    0             0      my ($package, undef, $line) = caller 0;
905   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
906   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
907                                                           @_;
908   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
909                                                   }
910                                                   
911                                                   1;
912                                                   
913                                                   # ###########################################################################
914                                                   # End VersionParser package
915                                                   # ###########################################################################
916                                                   
917                                                   # ###########################################################################
918                                                   # DSNParser package 5266
919                                                   # ###########################################################################
920                                                   package DSNParser;
921                                                   
922            1                    1             7   use strict;
               1                                  3   
               1                                 19   
923            1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  4   
924            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
925            1                    1             7   use Data::Dumper;
               1                                  3   
               1                                  8   
926                                                   $Data::Dumper::Indent    = 0;
927                                                   $Data::Dumper::Quotekeys = 0;
928                                                   
929                                                   eval {
930                                                      require DBI;
931                                                   };
932                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
933                                                   
934   ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 13   
935                                                   
936                                                   sub new {
937            1                    1           119      my ( $class, @opts ) = @_;
938            1                                 47      my $self = {
939                                                         opts => {
940                                                            A => {
941                                                               desc => 'Default character set',
942                                                               dsn  => 'charset',
943                                                               copy => 1,
944                                                            },
945                                                            D => {
946                                                               desc => 'Database to use',
947                                                               dsn  => 'database',
948                                                               copy => 1,
949                                                            },
950                                                            F => {
951                                                               desc => 'Only read default options from the given file',
952                                                               dsn  => 'mysql_read_default_file',
953                                                               copy => 1,
954                                                            },
955                                                            h => {
956                                                               desc => 'Connect to host',
957                                                               dsn  => 'host',
958                                                               copy => 1,
959                                                            },
960                                                            p => {
961                                                               desc => 'Password to use when connecting',
962                                                               dsn  => 'password',
963                                                               copy => 1,
964                                                            },
965                                                            P => {
966                                                               desc => 'Port number to use for connection',
967                                                               dsn  => 'port',
968                                                               copy => 1,
969                                                            },
970                                                            S => {
971                                                               desc => 'Socket file to use for connection',
972                                                               dsn  => 'mysql_socket',
973                                                               copy => 1,
974                                                            },
975                                                            u => {
976                                                               desc => 'User for login if not current user',
977                                                               dsn  => 'user',
978                                                               copy => 1,
979                                                            },
980                                                         },
981                                                      };
982            1                                  8      foreach my $opt ( @opts ) {
983   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
984   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
985                                                      }
986            1                                 23      return bless $self, $class;
987                                                   }
988                                                   
989                                                   sub prop {
990            6                    6            46      my ( $self, $prop, $value ) = @_;
991   ***      6     50                          49      if ( @_ > 2 ) {
992   ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
993   ***      0                                  0         $self->{$prop} = $value;
994                                                      }
995            6                                 79      return $self->{$prop};
996                                                   }
997                                                   
998                                                   sub parse {
999            2                    2           168      my ( $self, $dsn, $prev, $defaults ) = @_;
1000  ***      2     50                          18      if ( !$dsn ) {
1001  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1002  ***      0                                  0         return;
1003                                                     }
1004           2                                  6      MKDEBUG && _d('Parsing', $dsn);
1005  ***      2            50                   17      $prev     ||= {};
1006  ***      2            50                   16      $defaults ||= {};
1007           2                                  8      my %given_props;
1008           2                                  8      my %final_props;
1009           2                                 10      my %opts = %{$self->{opts}};
               2                                 37   
1010                                                  
1011           2                                 28      foreach my $dsn_part ( split(/,/, $dsn) ) {
1012  ***      8     50                         114         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1013           8                                 62            $given_props{$prop_key} = $prop_val;
1014                                                        }
1015                                                        else {
1016  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1017  ***      0                                  0            $given_props{h} = $dsn_part;
1018                                                        }
1019                                                     }
1020                                                  
1021           2                                 18      foreach my $key ( keys %opts ) {
1022          16                                 55         MKDEBUG && _d('Finding value for', $key);
1023          16                                 90         $final_props{$key} = $given_props{$key};
1024  ***     16     50     66                  230         if (   !defined $final_props{$key}
      ***                   33                        
1025                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1026                                                        {
1027  ***      0                                  0            $final_props{$key} = $prev->{$key};
1028  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1029                                                        }
1030          16    100                         121         if ( !defined $final_props{$key} ) {
1031           8                                 46            $final_props{$key} = $defaults->{$key};
1032           8                                 34            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1033                                                        }
1034                                                     }
1035                                                  
1036           2                                 23      foreach my $key ( keys %given_props ) {
1037  ***      8     50                          61         die "Unrecognized DSN part '$key' in '$dsn'\n"
1038                                                           unless exists $opts{$key};
1039                                                     }
1040  ***      2     50                          17      if ( (my $required = $self->prop('required')) ) {
1041  ***      0                                  0         foreach my $key ( keys %$required ) {
1042  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1043                                                        }
1044                                                     }
1045                                                  
1046           2                                 25      return \%final_props;
1047                                                  }
1048                                                  
1049                                                  sub parse_options {
1050  ***      0                    0             0      my ( $self, $o ) = @_;
1051  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1052  ***      0                                  0      my $dsn_string
1053                                                        = join(',',
1054  ***      0      0                           0             map  { "$_=".$o->get($_); }
1055  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1056  ***      0                                  0             keys %{$self->{opts}}
1057                                                          );
1058  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1059  ***      0                                  0      return $self->parse($dsn_string);
1060                                                  }
1061                                                  
1062                                                  sub as_string {
1063  ***      0                    0             0      my ( $self, $dsn ) = @_;
1064  ***      0      0                           0      return $dsn unless ref $dsn;
1065  ***      0      0                           0      return join(',',
1066  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1067  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1068                                                        sort keys %$dsn );
1069                                                  }
1070                                                  
1071                                                  sub usage {
1072  ***      0                    0             0      my ( $self ) = @_;
1073  ***      0                                  0      my $usage
1074                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1075                                                        . "  KEY  COPY  MEANING\n"
1076                                                        . "  ===  ====  =============================================\n";
1077  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1078  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1079  ***      0      0      0                    0         $usage .= "  $key    "
1080                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1081                                                               .  ($opts{$key}->{desc} || '[No description]')
1082                                                               . "\n";
1083                                                     }
1084  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1085  ***      0                                  0      return $usage;
1086                                                  }
1087                                                  
1088                                                  sub get_cxn_params {
1089           2                    2            44      my ( $self, $info ) = @_;
1090           2                                  8      my $dsn;
1091           2                                  8      my %opts = %{$self->{opts}};
               2                                 29   
1092  ***      2            50                   17      my $driver = $self->prop('dbidriver') || '';
1093  ***      2     50                          15      if ( $driver eq 'Pg' ) {
1094  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1095  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1096  ***      0             0                    0                        grep { defined $info->{$_} }
1097                                                                       qw(h P));
1098                                                     }
1099                                                     else {
1100           4                                 51         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1101          10                                 61            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1102  ***      2            50                   41                        grep { defined $info->{$_} }
1103                                                                       qw(F h P S A))
1104                                                           . ';mysql_read_default_group=client';
1105                                                     }
1106           2                                  8      MKDEBUG && _d($dsn);
1107           2                                 29      return ($dsn, $info->{u}, $info->{p});
1108                                                  }
1109                                                  
1110                                                  sub fill_in_dsn {
1111  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1112  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1113  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1114  ***      0                                  0      $user =~ s/@.*//;
1115  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1116  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1117  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1118  ***      0             0                    0      $dsn->{u} ||= $user;
1119  ***      0             0                    0      $dsn->{D} ||= $db;
1120                                                  }
1121                                                  
1122                                                  sub get_dbh {
1123           2                    2            23      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1124  ***      2            50                   18      $opts ||= {};
1125  ***      2     50                          31      my $defaults = {
1126                                                        AutoCommit         => 0,
1127                                                        RaiseError         => 1,
1128                                                        PrintError         => 0,
1129                                                        ShowErrorStatement => 1,
1130                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1131                                                     };
1132           2                                 17      @{$defaults}{ keys %$opts } = values %$opts;
               2                                 15   
1133                                                  
1134  ***      2     50                          15      if ( !$have_dbi ) {
1135  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1136                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1137                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1138                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1139                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1140                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1141                                                  
1142                                                     }
1143                                                  
1144           2                                  8      my $dbh;
1145           2                                  9      my $tries = 2;
1146  ***      2            66                   50      while ( !$dbh && $tries-- ) {
1147                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1148           2                                  8            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1149                                                  
1150           2                                  9         eval {
1151           2                                 21            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1152                                                  
1153  ***      2     50                          32            if ( $cxn_string =~ m/mysql/i ) {
1154           2                                  8               my $sql;
1155                                                  
1156           2                                 11               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1157                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1158           2                                  8               MKDEBUG && _d($dbh, ':', $sql);
1159           2                                370               $dbh->do($sql);
1160                                                  
1161  ***      2     50                          27               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1162  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1163  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1164  ***      0                                  0                  $dbh->do($sql);
1165  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1166  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1167  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1168                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1169                                                                 }
1170                                                                 else {
1171  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1172                                                                 }
1173                                                              }
1174                                                  
1175  ***      2     50                          20               if ( $self->prop('set-vars') ) {
1176  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1177  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1178  ***      0                                  0                  $dbh->do($sql);
1179                                                              }
1180                                                           }
1181                                                        };
1182  ***      2     50     33                   35         if ( !$dbh && $EVAL_ERROR ) {
1183  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1184  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1185  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1186  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1187                                                           }
1188                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1189  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1190                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1191                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1192                                                                 . "DBD::mysql is not installed, try:\n"
1193                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1194                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1195                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1196                                                           }
1197  ***      0      0                           0            if ( !$tries ) {
1198  ***      0                                  0               die $EVAL_ERROR;
1199                                                           }
1200                                                        }
1201                                                     }
1202                                                  
1203           2                                  7      MKDEBUG && _d('DBH info: ',
1204                                                        $dbh,
1205                                                        Dumper($dbh->selectrow_hashref(
1206                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1207                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1208                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1209                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1210                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1211                                                        '$DBI::VERSION:',        $DBI::VERSION,
1212                                                     );
1213                                                  
1214           2                                 20      return $dbh;
1215                                                  }
1216                                                  
1217                                                  sub get_hostname {
1218  ***      0                    0             0      my ( $self, $dbh ) = @_;
1219  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1220  ***      0                                  0         return $host;
1221                                                     }
1222  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1223                                                        'SELECT /*!50038 @@hostname, */ 1');
1224  ***      0                                  0      return $hostname;
1225                                                  }
1226                                                  
1227                                                  sub disconnect {
1228  ***      0                    0             0      my ( $self, $dbh ) = @_;
1229  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1230  ***      0                                  0      $dbh->disconnect;
1231                                                  }
1232                                                  
1233                                                  sub print_active_handles {
1234  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1235  ***      0             0                    0      $level ||= 0;
1236  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1237                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1238                                                        or die "Cannot print: $OS_ERROR";
1239  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1240  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1241                                                     }
1242                                                  }
1243                                                  
1244                                                  sub copy {
1245  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1246  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1247  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1248  ***      0                                  0      my %new_dsn = map {
1249  ***      0                                  0         my $key = $_;
1250  ***      0                                  0         my $val;
1251  ***      0      0                           0         if ( $args{overwrite} ) {
1252  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1253                                                        }
1254                                                        else {
1255  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1256                                                        }
1257  ***      0                                  0         $key => $val;
1258  ***      0                                  0      } keys %{$self->{opts}};
1259  ***      0                                  0      return \%new_dsn;
1260                                                  }
1261                                                  
1262                                                  sub _d {
1263  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1264  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1265  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1266                                                          @_;
1267  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1268                                                  }
1269                                                  
1270                                                  1;
1271                                                  
1272                                                  # ###########################################################################
1273                                                  # End DSNParser package
1274                                                  # ###########################################################################
1275                                                  
1276                                                  # ###########################################################################
1277                                                  # BinaryLogParser package 5358
1278                                                  # ###########################################################################
1279                                                  package BinaryLogParser;
1280                                                  
1281           1                    1             7   use strict;
               1                                  3   
               1                                  6   
1282           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
1283           1                    1            14   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
1284                                                  
1285           1                    1             6   use Data::Dumper;
               1                                  3   
               1                                  6   
1286                                                  $Data::Dumper::Indent    = 1;
1287                                                  $Data::Dumper::Sortkeys  = 1;
1288                                                  $Data::Dumper::Quotekeys = 0;
1289                                                  
1290  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 18   
1291                                                  
1292                                                  sub new {
1293  ***      0                    0             0      my ( $class, %args ) = @_;
1294  ***      0                                  0      my $self = {
1295                                                        delim     => undef,
1296                                                        delim_len => 0,
1297                                                     };
1298  ***      0                                  0      return bless $self, $class;
1299                                                  }
1300                                                  
1301                                                  my $binlog_line_1 = qr/at (\d+)$/m;
1302                                                  my $binlog_line_2 = qr/^#(\d{6}\s+\d{1,2}:\d\d:\d\d)\s+server\s+id\s+(\d+)\s+end_log_pos\s+(\d+)\s+(\S+)\s*([^\n]*)$/m;
1303                                                  my $binlog_line_2_rest = qr/thread_id=(\d+)\s+exec_time=(\d+)\s+error_code=(\d+)/m;
1304                                                  
1305                                                  sub parse_event {
1306  ***      0                    0             0      my ( $self, %args ) = @_;
1307  ***      0                                  0      my @required_args = qw(next_event tell);
1308  ***      0                                  0      foreach my $arg ( @required_args ) {
1309  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1310                                                     }
1311  ***      0                                  0      my ($next_event, $tell) = @args{@required_args};
1312                                                  
1313  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = ";\n#";
1314  ***      0                                  0      my $pos_in_log = $tell->();
1315  ***      0                                  0      my $stmt;
1316  ***      0                                  0      my ($delim, $delim_len) = ($self->{delim}, $self->{delim_len});
1317                                                  
1318                                                     EVENT:
1319  ***      0                                  0      while ( defined($stmt = $next_event->()) ) {
1320  ***      0                                  0         my @properties = ('pos_in_log', $pos_in_log);
1321  ***      0                                  0         my ($ts, $sid, $end, $type, $rest);
1322  ***      0                                  0         $pos_in_log = $tell->();
1323  ***      0                                  0         $stmt =~ s/;\n#?\Z//;
1324                                                  
1325  ***      0                                  0         my ( $got_offset, $got_hdr );
1326  ***      0                                  0         my $pos = 0;
1327  ***      0                                  0         my $len = length($stmt);
1328  ***      0                                  0         my $found_arg = 0;
1329                                                        LINE:
1330  ***      0                                  0         while ( $stmt =~ m/^(.*)$/mg ) { # /g requires scalar match.
1331  ***      0                                  0            $pos     = pos($stmt);  # Be careful not to mess this up!
1332  ***      0                                  0            my $line = $1;          # Necessary for /g and pos() to work.
1333  ***      0      0                           0            $line    =~ s/$delim// if $delim;
1334  ***      0                                  0            MKDEBUG && _d($line);
1335                                                  
1336  ***      0      0                           0            if ( $line =~ m/^\/\*.+\*\/;/ ) {
1337  ***      0                                  0               MKDEBUG && _d('Comment line');
1338  ***      0                                  0               next LINE;
1339                                                           }
1340                                                   
1341  ***      0      0                           0            if ( $line =~ m/^DELIMITER/m ) {
1342  ***      0                                  0               my ( $del ) = $line =~ m/^DELIMITER (\S*)$/m;
1343  ***      0      0                           0               if ( $del ) {
1344  ***      0                                  0                  $self->{delim_len} = $delim_len = length $del;
1345  ***      0                                  0                  $self->{delim}     = $delim     = quotemeta $del;
1346  ***      0                                  0                  MKDEBUG && _d('delimiter:', $delim);
1347                                                              }
1348                                                              else {
1349  ***      0                                  0                  MKDEBUG && _d('Delimiter reset to ;');
1350  ***      0                                  0                  $self->{delim}     = $delim     = undef;
1351  ***      0                                  0                  $self->{delim_len} = $delim_len = 0;
1352                                                              }
1353  ***      0                                  0               next LINE;
1354                                                           }
1355                                                  
1356  ***      0      0                           0            next LINE if $line =~ m/End of log file/;
1357                                                  
1358  ***      0      0      0                    0            if ( !$got_offset && (my ( $offset ) = $line =~ m/$binlog_line_1/m) ) {
      ***             0      0                        
      ***             0                               
1359  ***      0                                  0               MKDEBUG && _d('Got the at offset line');
1360  ***      0                                  0               push @properties, 'offset', $offset;
1361  ***      0                                  0               $got_offset++;
1362                                                           }
1363                                                  
1364                                                           elsif ( !$got_hdr && $line =~ m/^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/ ) {
1365  ***      0                                  0               ($ts, $sid, $end, $type, $rest) = $line =~ m/$binlog_line_2/m;
1366  ***      0                                  0               MKDEBUG && _d('Got the header line; type:', $type, 'rest:', $rest);
1367  ***      0                                  0               push @properties, 'cmd', 'Query', 'ts', $ts, 'server_id', $sid,
1368                                                                 'end_log_pos', $end;
1369  ***      0                                  0               $got_hdr++;
1370                                                           }
1371                                                  
1372                                                           elsif ( $line =~ m/^(?:#|use |SET)/i ) {
1373                                                  
1374  ***      0      0                           0               if ( my ( $db ) = $line =~ m/^use ([^;]+)/ ) {
      ***             0                               
1375  ***      0                                  0                  MKDEBUG && _d("Got a default database:", $db);
1376  ***      0                                  0                  push @properties, 'db', $db;
1377                                                              }
1378                                                  
1379                                                              elsif ( my ($setting) = $line =~ m/^SET\s+([^;]*)/ ) {
1380  ***      0                                  0                  MKDEBUG && _d("Got some setting:", $setting);
1381  ***      0                                  0                  push @properties, map { s/\s+//; lc } split(/,|\s*=\s*/, $setting);
      ***      0                                  0   
      ***      0                                  0   
1382                                                              }
1383                                                  
1384                                                           }
1385                                                           else {
1386  ***      0                                  0               MKDEBUG && _d("Got the query/arg line at pos", $pos);
1387  ***      0                                  0               $found_arg++;
1388  ***      0      0      0                    0               if ( $got_offset && $got_hdr ) {
1389  ***      0      0                           0                  if ( $type eq 'Xid' ) {
      ***             0                               
      ***             0                               
1390  ***      0                                  0                     my ($xid) = $rest =~ m/(\d+)/;
1391  ***      0                                  0                     push @properties, 'Xid', $xid;
1392                                                                 }
1393                                                                 elsif ( $type eq 'Query' ) {
1394  ***      0                                  0                     my ($i, $t, $c) = $rest =~ m/$binlog_line_2_rest/m;
1395  ***      0                                  0                     push @properties, 'Thread_id', $i, 'Query_time', $t,
1396                                                                                      'error_code', $c;
1397                                                                 }
1398                                                                 elsif ( $type eq 'Start:' ) {
1399  ***      0                                  0                     MKDEBUG && _d("Binlog start");
1400                                                                 }
1401                                                                 else {
1402  ***      0                                  0                     MKDEBUG && _d('Unknown event type:', $type);
1403  ***      0                                  0                     next EVENT;
1404                                                                 }
1405                                                              }
1406                                                              else {
1407  ***      0                                  0                  MKDEBUG && _d("It's not a query/arg, it's just some SQL fluff");
1408  ***      0                                  0                  push @properties, 'cmd', 'Query', 'ts', undef;
1409                                                              }
1410                                                  
1411  ***      0      0                           0               my $delim_len = ($pos == length($stmt) ? $delim_len : 0);
1412  ***      0                                  0               my $arg = substr($stmt, $pos - length($line) - $delim_len);
1413                                                  
1414  ***      0      0                           0               $arg =~ s/$delim// if $delim; # Remove the delimiter.
1415                                                  
1416  ***      0      0                           0               if ( $arg =~ m/^DELIMITER/m ) {
1417  ***      0                                  0                  my ( $del ) = $arg =~ m/^DELIMITER (\S*)$/m;
1418  ***      0      0                           0                  if ( $del ) {
1419  ***      0                                  0                     $self->{delim_len} = $delim_len = length $del;
1420  ***      0                                  0                     $self->{delim}     = $delim     = quotemeta $del;
1421  ***      0                                  0                     MKDEBUG && _d('delimiter:', $delim);
1422                                                                 }
1423                                                                 else {
1424  ***      0                                  0                     MKDEBUG && _d('Delimiter reset to ;');
1425  ***      0                                  0                     $del       = ';';
1426  ***      0                                  0                     $self->{delim}     = $delim     = undef;
1427  ***      0                                  0                     $self->{delim_len} = $delim_len = 0;
1428                                                                 }
1429                                                  
1430  ***      0                                  0                  $arg =~ s/^DELIMITER.*$//m;  # Remove DELIMITER from arg.
1431                                                              }
1432                                                  
1433  ***      0                                  0               $arg =~ s/;$//gm;  # Ensure ending ; are gone.
1434  ***      0                                  0               $arg =~ s/\s+$//;  # Remove trailing spaces and newlines.
1435                                                  
1436  ***      0                                  0               push @properties, 'arg', $arg, 'bytes', length($arg);
1437  ***      0                                  0               last LINE;
1438                                                           }
1439                                                        } # LINE
1440                                                  
1441  ***      0      0                           0         if ( $found_arg ) {
1442  ***      0                                  0            MKDEBUG && _d('Properties of event:', Dumper(\@properties));
1443  ***      0                                  0            my $event = { @properties };
1444  ***      0                                  0            return $event;
1445                                                        }
1446                                                        else {
1447  ***      0                                  0            MKDEBUG && _d('Event had no arg');
1448                                                        }
1449                                                     } # EVENT
1450                                                  
1451  ***      0      0                           0      $args{oktorun}->(0) if $args{oktorun};
1452  ***      0                                  0      return;
1453                                                  }
1454                                                  
1455                                                  sub _d {
1456  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1457  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1458  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1459                                                          @_;
1460  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1461                                                  }
1462                                                  
1463                                                  1;
1464                                                  
1465                                                  # ###########################################################################
1466                                                  # End BinaryLogParser package
1467                                                  # ###########################################################################
1468                                                  
1469                                                  # ###########################################################################
1470                                                  # QueryRewriter package 5356
1471                                                  # ###########################################################################
1472           1                    1             8   use strict;
               1                                  3   
               1                                  5   
1473           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
1474                                                  
1475                                                  package QueryRewriter;
1476                                                  
1477           1                    1             5   use English qw(-no_match_vars);
               1                                  3   
               1                                  4   
1478                                                  
1479  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 17   
1480                                                  
1481                                                  our $verbs   = qr{^SHOW|^FLUSH|^COMMIT|^ROLLBACK|^BEGIN|SELECT|INSERT
1482                                                                    |UPDATE|DELETE|REPLACE|^SET|UNION|^START|^LOCK}xi;
1483                                                  my $quote_re = qr/"(?:(?!(?<!\\)").)*"|'(?:(?!(?<!\\)').)*'/; # Costly!
1484                                                  my $bal;
1485                                                  $bal         = qr/
1486                                                                    \(
1487                                                                    (?:
1488                                                                       (?> [^()]+ )    # Non-parens without backtracking
1489                                                                       |
1490                                                                       (??{ $bal })    # Group with matching parens
1491                                                                    )*
1492                                                                    \)
1493                                                                   /x;
1494                                                  
1495                                                  my $olc_re = qr/(?:--|#)[^'"\r\n]*(?=[\r\n]|\Z)/;  # One-line comments
1496                                                  my $mlc_re = qr#/\*[^!].*?\*/#sm;                  # But not /*!version */
1497                                                  my $vlc_re = qr#/\*.*?[0-9+].*?\*/#sm;                  # But for replacing SHOW + /*!version */
1498                                                  my $vlc_rf = qr#^(SHOW).*?/\*![0-9+].*?\*/#sm;    		# ^^ if its starts with SHOW followed by version
1499                                                  
1500                                                  sub new {
1501  ***      0                    0             0      my ( $class, %args ) = @_;
1502  ***      0                                  0      my $self = { %args };
1503  ***      0                                  0      return bless $self, $class;
1504                                                  }
1505                                                  
1506                                                  sub strip_comments {
1507  ***      0                    0             0      my ( $self, $query ) = @_;
1508  ***      0      0                           0      return unless $query;
1509  ***      0                                  0      $query =~ s/$olc_re//go;
1510  ***      0                                  0      $query =~ s/$mlc_re//go;
1511  ***      0      0                           0      if ( $query =~ m/$vlc_rf/i ) { # contains show + version
1512  ***      0                                  0      			$query =~ s/$vlc_re//go;
1513                                                     }
1514  ***      0                                  0      return $query;
1515                                                  }
1516                                                  
1517                                                  sub shorten {
1518  ***      0                    0             0      my ( $self, $query, $length ) = @_;
1519  ***      0                                  0      $query =~ s{
1520                                                        \A(
1521                                                           (?:INSERT|REPLACE)
1522                                                           (?:\s+LOW_PRIORITY|DELAYED|HIGH_PRIORITY|IGNORE)?
1523                                                           (?:\s\w+)*\s+\S+\s+VALUES\s*\(.*?\)
1524                                                        )
1525                                                        \s*,\s*\(.*?(ON\s+DUPLICATE|\Z)}
1526                                                        {$1 /*... omitted ...*/$2}xsi;
1527                                                  
1528  ***      0      0                           0      return $query unless $query =~ m/IN\s*\(\s*(?!select)/i;
1529                                                  
1530  ***      0                                  0      my $last_length  = 0;
1531  ***      0                                  0      my $query_length = length($query);
1532  ***      0             0                    0      while (
      ***                    0                        
      ***                    0                        
1533                                                        $length          > 0
1534                                                        && $query_length > $length
1535                                                        && $query_length < ( $last_length || $query_length + 1 )
1536                                                     ) {
1537  ***      0                                  0         $last_length = $query_length;
1538  ***      0                                  0         $query =~ s{
1539  ***      0                                  0            (\bIN\s*\()    # The opening of an IN list
1540                                                           ([^\)]+)       # Contents of the list, assuming no item contains paren
1541                                                           (?=\))           # Close of the list
1542                                                        }
1543                                                        {
1544                                                           $1 . __shorten($2)
1545                                                        }gexsi;
1546                                                     }
1547                                                  
1548  ***      0                                  0      return $query;
1549                                                  }
1550                                                  
1551                                                  sub __shorten {
1552  ***      0                    0             0      my ( $snippet ) = @_;
1553  ***      0                                  0      my @vals = split(/,/, $snippet);
1554  ***      0      0                           0      return $snippet unless @vals > 20;
1555  ***      0                                  0      my @keep = splice(@vals, 0, 20);  # Remove and save the first 20 items
1556                                                     return
1557  ***      0                                  0         join(',', @keep)
1558                                                        . "/*... omitted "
1559                                                        . scalar(@vals)
1560                                                        . " items ...*/";
1561                                                  }
1562                                                  
1563                                                  sub fingerprint {
1564  ***      0                    0             0      my ( $self, $query ) = @_;
1565                                                  
1566  ***      0      0                           0      $query =~ m#\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `# # mysqldump query
1567                                                        && return 'mysqldump';
1568  ***      0      0                           0      $query =~ m#/\*\w+\.\w+:[0-9]/[0-9]\*/#     # mk-table-checksum, etc query
1569                                                        && return 'maatkit';
1570  ***      0      0                           0      $query =~ m/\A# administrator command: /
1571                                                        && return $query;
1572  ***      0      0                           0      $query =~ m/\A\s*(call\s+\S+)\(/i
1573                                                        && return lc($1); # Warning! $1 used, be careful.
1574  ***      0      0                           0      if ( my ($beginning) = $query =~ m/\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is ) {
1575  ***      0                                  0         $query = $beginning; # Shorten multi-value INSERT statements ASAP
1576                                                     }
1577                                                  
1578  ***      0                                  0      $query =~ s/$olc_re//go;
1579  ***      0                                  0      $query =~ s/$mlc_re//go;
1580  ***      0      0                           0      $query =~ s/\Ause \S+\Z/use ?/i       # Abstract the DB in USE
1581                                                        && return $query;
1582                                                  
1583  ***      0                                  0      $query =~ s/\\["']//g;                # quoted strings
1584  ***      0                                  0      $query =~ s/".*?"/?/sg;               # quoted strings
1585  ***      0                                  0      $query =~ s/'.*?'/?/sg;               # quoted strings
1586  ***      0                                  0      $query =~ s/[0-9+-][0-9a-f.xb+-]*/?/g;# Anything vaguely resembling numbers
1587  ***      0                                  0      $query =~ s/[xb.+-]\?/?/g;            # Clean up leftovers
1588  ***      0                                  0      $query =~ s/\A\s+//;                  # Chop off leading whitespace
1589  ***      0                                  0      chomp $query;                         # Kill trailing whitespace
1590  ***      0                                  0      $query =~ tr[ \n\t\r\f][ ]s;          # Collapse whitespace
1591  ***      0                                  0      $query = lc $query;
1592  ***      0                                  0      $query =~ s/\bnull\b/?/g;             # Get rid of NULLs
1593  ***      0                                  0      $query =~ s{                          # Collapse IN and VALUES lists
1594                                                                 \b(in|values?)(?:[\s,]*\([\s?,]*\))+
1595                                                                }
1596                                                                {$1(?+)}gx;
1597  ***      0                                  0      $query =~ s{                          # Collapse UNION
1598                                                                 \b(select\s.*?)(?:(\sunion(?:\sall)?)\s\1)+
1599                                                                }
1600                                                                {$1 /*repeat$2*/}xg;
1601  ***      0                                  0      $query =~ s/\blimit \?(?:, ?\?| offset \?)?/limit ?/; # LIMIT
1602  ***      0                                  0      return $query;
1603                                                  }
1604                                                  
1605                                                  sub _distill_verbs {
1606  ***      0                    0             0      my ( $self, $query ) = @_;
1607                                                  
1608  ***      0      0                           0      $query =~ m/\A\s*call\s+(\S+)\(/i
1609                                                        && return "CALL $1"; # Warning! $1 used, be careful.
1610  ***      0      0                           0      if ( $query =~ m/\A# administrator command:/ ) {
1611  ***      0                                  0   		$query =~ s/# administrator command:/ADMIN/go;
1612  ***      0                                  0   		$query = uc $query;
1613  ***      0                                  0          	return "$query";
1614                                                     }
1615  ***      0      0                           0      $query =~ m/\A\s*use\s+/
1616                                                        && return "USE";
1617  ***      0      0                           0      $query =~ m/\A\s*UNLOCK TABLES/i
1618                                                        && return "UNLOCK";
1619  ***      0      0                           0      $query =~ m/\A\s*xa\s+(\S+)/i
1620                                                        && return "XA_$1";
1621                                                  
1622  ***      0                                  0      $query = $self->strip_comments($query);
1623                                                  
1624  ***      0      0                           0      if ( $query =~ m/\A\s*SHOW\s+/i ) {
1625  ***      0                                  0         my @what = $query =~ m/SHOW\s+(\S+)(?:\s+(\S+))?/i;
1626  ***      0                                  0         MKDEBUG && _d('SHOW', @what);
1627  ***      0      0                           0         return unless scalar @what;
1628  ***      0                                  0         @what = map { uc $_ } grep { defined $_ } @what; 
      ***      0                                  0   
      ***      0                                  0   
1629                                                  
1630  ***      0      0      0                    0         if ( $what[0] =~ m/CREATE/
      ***                    0                        
      ***                    0                        
1631                                                             || ($what[1] && $what[1] =~ m/STATUS/)
1632                                                             || $what[0] =~ m/MASTER/ ) {
1633  ***      0                                  0            return "SHOW $what[0] $what[1]";
1634                                                        }
1635                                                        else {
1636  ***      0      0                           0            $what[0] =~ m/GLOBAL/ ? return "SHOW $what[1]"
1637                                                                    :              return "SHOW $what[0]";
1638                                                        }
1639                                                     }
1640                                                  
1641  ***      0                                  0      eval $QueryParser::data_def_stmts;
1642  ***      0                                  0      eval $QueryParser::tbl_ident;
1643  ***      0                                  0      my ( $dds ) = $query =~ /^\s*($QueryParser::data_def_stmts)\b/i;
1644  ***      0      0                           0      if ( $dds ) {
1645  ***      0                                  0         my ( $obj ) = $query =~ m/$dds.+(DATABASE|TABLE)\b/i;
1646  ***      0      0                           0         $obj = uc $obj if $obj;
1647  ***      0                                  0         MKDEBUG && _d('Data def statment:', $dds, 'obj:', $obj);
1648  ***      0                                  0         my ($db_or_tbl)
1649                                                           = $query =~ m/(?:TABLE|DATABASE)\s+($QueryParser::tbl_ident)(\s+.*)?/i;
1650  ***      0                                  0         MKDEBUG && _d('Matches db or table:', $db_or_tbl);
1651  ***      0      0                           0         return uc($dds . ($obj ? " $obj" : '')), $db_or_tbl;
1652                                                     }
1653                                                  
1654  ***      0                                  0      my @verbs = $query =~ m/\b($verbs)\b/gio;
1655  ***      0                                  0      @verbs    = do {
1656  ***      0                                  0         my $last = '';
1657  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } map { uc } @verbs;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
1658                                                     };
1659  ***      0                                  0      my $verbs = join(q{ }, @verbs);
1660  ***      0                                  0      $verbs =~ s/( UNION SELECT)+/ UNION/g;
1661                                                  
1662  ***      0                                  0      return $verbs;
1663                                                  }
1664                                                  
1665                                                  sub _distill_tables {
1666  ***      0                    0             0      my ( $self, $query, $table, %args ) = @_;
1667  ***      0             0                    0      my $qp = $args{QueryParser} || $self->{QueryParser};
1668  ***      0      0                           0      die "I need a QueryParser argument" unless $qp;
1669                                                  
1670  ***      0                                  0      my @tables = map {
1671  ***      0                                  0         $_ =~ s/`//g;
1672  ***      0                                  0         $_ =~ s/(_?)[0-9]+/$1?/g;
1673  ***      0                                  0         $_;
1674  ***      0                                  0      } grep { defined $_ } $qp->get_tables($query);
1675                                                  
1676  ***      0      0                           0      push @tables, $table if $table;
1677                                                  
1678  ***      0                                  0      @tables = do {
1679  ***      0                                  0         my $last = '';
1680  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } @tables;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
1681                                                     };
1682                                                  
1683  ***      0                                  0      return @tables;
1684                                                  }
1685                                                  
1686                                                  sub distill {
1687  ***      0                    0             0      my ( $self, $query, %args ) = @_;
1688                                                  
1689  ***      0      0                           0      if ( $args{generic} ) {
1690  ***      0                                  0         my ($cmd, $arg) = $query =~ m/^(\S+)\s+(\S+)/;
1691  ***      0      0                           0         return '' unless $cmd;
1692  ***      0      0                           0         $query = (uc $cmd) . ($arg ? " $arg" : '');
1693                                                     }
1694                                                     else {
1695  ***      0                                  0         my ($verbs, $table)  = $self->_distill_verbs($query, %args);
1696  ***      0                                  0         my @tables           = $self->_distill_tables($query, $table, %args);
1697  ***      0                                  0         $query               = join(q{ }, $verbs, @tables);
1698                                                     }
1699                                                     
1700  ***      0      0                           0      if ( $args{trf} ) {
1701  ***      0                                  0         $query = $args{trf}->($query, %args);
1702                                                     }
1703                                                  
1704  ***      0                                  0      return $query;
1705                                                  }
1706                                                  
1707                                                  sub convert_to_select {
1708  ***      0                    0             0      my ( $self, $query ) = @_;
1709  ***      0      0                           0      return unless $query;
1710  ***      0                                  0      $query =~ s{
      ***      0                                  0   
1711                                                                   \A.*?
1712                                                                   update\s+(.*?)
1713                                                                   \s+set\b(.*?)
1714                                                                   (?:\s*where\b(.*?))?
1715                                                                   (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
1716                                                                   \Z
1717                                                                }
1718                                                                {__update_to_select($1, $2, $3, $4)}exsi
1719  ***      0                                  0         || $query =~ s{
1720                                                                      \A.*?
1721                                                                      (?:insert|replace)\s+
1722                                                                      .*?\binto\b(.*?)\(([^\)]+)\)\s*
1723                                                                      values?\s*(\(.*?\))\s*
1724                                                                      (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
1725                                                                      \Z
1726                                                                   }
1727                                                                   {__insert_to_select($1, $2, $3)}exsi
1728  ***      0      0      0                    0         || $query =~ s{
1729                                                                      \A.*?
1730                                                                      delete\s+(.*?)
1731                                                                      \bfrom\b(.*)
1732                                                                      \Z
1733                                                                   }
1734                                                                   {__delete_to_select($1, $2)}exsi;
1735  ***      0                                  0      $query =~ s/\s*on\s+duplicate\s+key\s+update.*\Z//si;
1736  ***      0                                  0      $query =~ s/\A.*?(?=\bSELECT\s*\b)//ism;
1737  ***      0                                  0      return $query;
1738                                                  }
1739                                                  
1740                                                  sub convert_select_list {
1741  ***      0                    0             0      my ( $self, $query ) = @_;
1742  ***      0      0                           0      $query =~ s{
      ***      0                                  0   
1743                                                                 \A\s*select(.*?)\bfrom\b
1744                                                                }
1745                                                                {$1 =~ m/\*/ ? "select 1 from" : "select isnull(coalesce($1)) from"}exi;
1746  ***      0                                  0      return $query;
1747                                                  }
1748                                                  
1749                                                  sub __delete_to_select {
1750  ***      0                    0             0      my ( $delete, $join ) = @_;
1751  ***      0      0                           0      if ( $join =~ m/\bjoin\b/ ) {
1752  ***      0                                  0         return "select 1 from $join";
1753                                                     }
1754  ***      0                                  0      return "select * from $join";
1755                                                  }
1756                                                  
1757                                                  sub __insert_to_select {
1758  ***      0                    0             0      my ( $tbl, $cols, $vals ) = @_;
1759  ***      0                                  0      MKDEBUG && _d('Args:', @_);
1760  ***      0                                  0      my @cols = split(/,/, $cols);
1761  ***      0                                  0      MKDEBUG && _d('Cols:', @cols);
1762  ***      0                                  0      $vals =~ s/^\(|\)$//g; # Strip leading/trailing parens
1763  ***      0                                  0      my @vals = $vals =~ m/($quote_re|[^,]*${bal}[^,]*|[^,]+)/g;
1764  ***      0                                  0      MKDEBUG && _d('Vals:', @vals);
1765  ***      0      0                           0      if ( @cols == @vals ) {
1766  ***      0                                  0         return "select * from $tbl where "
1767  ***      0                                  0            . join(' and ', map { "$cols[$_]=$vals[$_]" } (0..$#cols));
1768                                                     }
1769                                                     else {
1770  ***      0                                  0         return "select * from $tbl limit 1";
1771                                                     }
1772                                                  }
1773                                                  
1774                                                  sub __update_to_select {
1775  ***      0                    0             0      my ( $from, $set, $where, $limit ) = @_;
1776  ***      0      0                           0      return "select $set from $from "
      ***             0                               
1777                                                        . ( $where ? "where $where" : '' )
1778                                                        . ( $limit ? " $limit "      : '' );
1779                                                  }
1780                                                  
1781                                                  sub wrap_in_derived {
1782  ***      0                    0             0      my ( $self, $query ) = @_;
1783  ***      0      0                           0      return unless $query;
1784  ***      0      0                           0      return $query =~ m/\A\s*select/i
1785                                                        ? "select 1 from ($query) as x limit 1"
1786                                                        : $query;
1787                                                  }
1788                                                  
1789                                                  sub _d {
1790  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1791  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1792  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1793                                                          @_;
1794  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1795                                                  }
1796                                                  
1797                                                  1;
1798                                                  
1799                                                  # ###########################################################################
1800                                                  # End QueryRewriter package
1801                                                  # ###########################################################################
1802                                                  
1803                                                  # ###########################################################################
1804                                                  # Daemon package 5266
1805                                                  # ###########################################################################
1806                                                  
1807                                                  package Daemon;
1808                                                  
1809           1                    1             8   use strict;
               1                                  3   
               1                                  6   
1810           1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
1811                                                  
1812           1                    1             6   use POSIX qw(setsid);
               1                                  2   
               1                                  7   
1813           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                271   
1814                                                  
1815  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 15   
1816                                                  
1817                                                  sub new {
1818  ***      0                    0             0      my ( $class, %args ) = @_;
1819  ***      0                                  0      foreach my $arg ( qw(o) ) {
1820  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1821                                                     }
1822  ***      0                                  0      my $o = $args{o};
1823  ***      0      0                           0      my $self = {
      ***             0                               
1824                                                        o        => $o,
1825                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1826                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1827                                                     };
1828                                                  
1829  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1830                                                  
1831  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1832  ***      0                                  0      return bless $self, $class;
1833                                                  }
1834                                                  
1835                                                  sub daemonize {
1836  ***      0                    0             0      my ( $self ) = @_;
1837                                                  
1838  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1839  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1840  ***      0      0                           0      if ( $pid ) {
1841  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1842  ***      0                                  0         exit;
1843                                                     }
1844                                                  
1845  ***      0                                  0      $self->{child} = 1;
1846                                                  
1847  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1848  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1849                                                  
1850  ***      0                                  0      $self->_make_PID_file();
1851                                                  
1852  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
1853                                                  
1854  ***      0      0                           0      if ( -t STDIN ) {
1855  ***      0                                  0         close STDIN;
1856  ***      0      0                           0         open  STDIN, '/dev/null'
1857                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1858                                                     }
1859                                                  
1860  ***      0      0                           0      if ( $self->{log_file} ) {
1861  ***      0                                  0         close STDOUT;
1862  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1863                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1864                                                  
1865  ***      0                                  0         close STDERR;
1866  ***      0      0                           0         open  STDERR, ">&STDOUT"
1867                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1868                                                     }
1869                                                     else {
1870  ***      0      0                           0         if ( -t STDOUT ) {
1871  ***      0                                  0            close STDOUT;
1872  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
1873                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1874                                                        }
1875  ***      0      0                           0         if ( -t STDERR ) {
1876  ***      0                                  0            close STDERR;
1877  ***      0      0                           0            open  STDERR, '>', '/dev/null'
1878                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1879                                                        }
1880                                                     }
1881                                                  
1882  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1883  ***      0                                  0      return;
1884                                                  }
1885                                                  
1886                                                  sub check_PID_file {
1887  ***      0                    0             0      my ( $self, $file ) = @_;
1888  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1889  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1890  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1891  ***      0                                  0         my $pid;
1892  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1893  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1894  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1895  ***      0      0                           0         if ( $pid ) {
1896  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1897  ***      0      0                           0            if ( $pid_is_alive ) {
1898  ***      0                                  0               die "The PID file $PID_file already exists "
1899                                                                 . " and the PID that it contains, $pid, is running";
1900                                                           }
1901                                                           else {
1902  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1903                                                                 . "contains, $pid, is not running";
1904                                                           }
1905                                                        }
1906                                                        else {
1907  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1908                                                              . "contain a PID";
1909                                                        }
1910                                                     }
1911                                                     else {
1912  ***      0                                  0         MKDEBUG && _d('No PID file');
1913                                                     }
1914  ***      0                                  0      return;
1915                                                  }
1916                                                  
1917                                                  sub make_PID_file {
1918  ***      0                    0             0      my ( $self ) = @_;
1919  ***      0      0                           0      if ( exists $self->{child} ) {
1920  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1921                                                     }
1922  ***      0                                  0      $self->_make_PID_file();
1923  ***      0                                  0      $self->{rm_PID_file} = 1;
1924  ***      0                                  0      return;
1925                                                  }
1926                                                  
1927                                                  sub _make_PID_file {
1928  ***      0                    0             0      my ( $self ) = @_;
1929                                                  
1930  ***      0                                  0      my $PID_file = $self->{PID_file};
1931  ***      0      0                           0      if ( !$PID_file ) {
1932  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1933  ***      0                                  0         return;
1934                                                     }
1935                                                  
1936  ***      0                                  0      $self->check_PID_file();
1937                                                  
1938  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1939                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1940  ***      0      0                           0      print $PID_FH $PID
1941                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1942  ***      0      0                           0      close $PID_FH
1943                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1944                                                  
1945  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1946  ***      0                                  0      return;
1947                                                  }
1948                                                  
1949                                                  sub _remove_PID_file {
1950  ***      0                    0             0      my ( $self ) = @_;
1951  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1952  ***      0      0                           0         unlink $self->{PID_file}
1953                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1954  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1955                                                     }
1956                                                     else {
1957  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1958                                                     }
1959  ***      0                                  0      return;
1960                                                  }
1961                                                  
1962                                                  sub DESTROY {
1963  ***      0                    0             0      my ( $self ) = @_;
1964  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1965  ***      0                                  0      return;
1966                                                  }
1967                                                  
1968                                                  sub _d {
1969  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1970  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1971  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1972                                                          @_;
1973  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1974                                                  }
1975                                                  
1976                                                  1;
1977                                                  
1978                                                  # ###########################################################################
1979                                                  # End Daemon package
1980                                                  # ###########################################################################
1981                                                  
1982                                                  # ###########################################################################
1983                                                  # MySQLDump package 5266
1984                                                  # ###########################################################################
1985                                                  package MySQLDump;
1986                                                  
1987           1                    1             7   use strict;
               1                                  2   
               1                                  5   
1988           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
1989                                                  
1990           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  4   
1991                                                  
1992  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 13   
1993                                                  
1994                                                  ( our $before = <<'EOF') =~ s/^   //gm;
1995                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
1996                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
1997                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
1998                                                     /*!40101 SET NAMES utf8 */;
1999                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
2000                                                     /*!40103 SET TIME_ZONE='+00:00' */;
2001                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
2002                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2003                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2004                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2005                                                  EOF
2006                                                  
2007                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2008                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2009                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2010                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2011                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2012                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2013                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2014                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2015                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2016                                                  EOF
2017                                                  
2018                                                  sub new {
2019           1                    1            19      my ( $class, %args ) = @_;
2020  ***      1     50                          11      $args{cache} = 1 unless defined $args{cache};
2021           1                                 20      my $self = bless \%args, $class;
2022           1                                  7      return $self;
2023                                                  }
2024                                                  
2025                                                  sub dump {
2026  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2027                                                  
2028  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2029  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2030  ***      0      0                           0         return unless $ddl;
2031  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
2032  ***      0                                  0            return $before
2033                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2034                                                              . $ddl->[1] . ";\n";
2035                                                        }
2036                                                        else {
2037  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2038                                                              . '/*!50001 DROP VIEW IF EXISTS '
2039                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2040                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2041                                                        }
2042                                                     }
2043                                                     elsif ( $what eq 'triggers' ) {
2044  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2045  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
2046  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
2047  ***      0                                  0            foreach my $trg ( @$trgs ) {
2048  ***      0      0                           0               if ( $trg->{sql_mode} ) {
2049  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2050                                                              }
2051  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
2052  ***      0      0                           0               if ( $trg->{definer} ) {
2053  ***      0                                  0                  my ( $user, $host )
2054  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
2055                                                                      split('@', $trg->{definer}, 2);
2056  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
2057                                                              }
2058  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2059                                                                 $quoter->quote($trg->{trigger}),
2060  ***      0                                  0                  @{$trg}{qw(timing event)},
2061                                                                 $quoter->quote($trg->{table}),
2062                                                                 $trg->{statement});
2063                                                           }
2064  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2065  ***      0                                  0            return $result;
2066                                                        }
2067                                                        else {
2068  ***      0                                  0            return undef;
2069                                                        }
2070                                                     }
2071                                                     elsif ( $what eq 'view' ) {
2072  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2073  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2074                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2075                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2076                                                     }
2077                                                     else {
2078  ***      0                                  0         die "You didn't say what to dump.";
2079                                                     }
2080                                                  }
2081                                                  
2082                                                  sub _use_db {
2083           6                    6            36      my ( $self, $dbh, $quoter, $new ) = @_;
2084           6    100                          31      if ( !$new ) {
2085           1                                  2         MKDEBUG && _d('No new DB to use');
2086           1                                  4         return;
2087                                                     }
2088           5                                 17      my $sql = 'SELECT DATABASE()';
2089           5                                 11      MKDEBUG && _d($sql);
2090           5                                 14      my $curr = $dbh->selectrow_array($sql);
2091  ***      5    100     66                  706      if ( $curr && $new && $curr eq $new ) {
      ***                   66                        
2092           4                                 10         MKDEBUG && _d('Current and new DB are the same');
2093           4                                 18         return $curr;
2094                                                     }
2095           1                                 13      $sql = 'USE ' . $quoter->quote($new);
2096           1                                  4      MKDEBUG && _d($sql);
2097           1                                118      $dbh->do($sql);
2098           1                                  9      return $curr;
2099                                                  }
2100                                                  
2101                                                  sub get_create_table {
2102           3                    3            23      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2103  ***      3     50     33                   26      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2104           3                                 15         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2105                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2106                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2107                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2108           3                                  8         MKDEBUG && _d($sql);
2109           3                                  9         eval { $dbh->do($sql); };
               3                                727   
2110           3                                 10         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2111           3                                 24         my $curr_db = $self->_use_db($dbh, $quoter, $db);
2112           3                                 17         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2113           3                                  8         MKDEBUG && _d($sql);
2114           3                                  9         my $href;
2115           3                                 13         eval { $href = $dbh->selectrow_hashref($sql); };
               3                                  7   
2116  ***      3     50                          24         if ( $EVAL_ERROR ) {
2117  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2118  ***      0                                  0            return;
2119                                                        }
2120           3                                 16         $self->_use_db($dbh, $quoter, $curr_db);
2121           3                                 11         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2122                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2123           3                                  8         MKDEBUG && _d($sql);
2124           3                                276         $dbh->do($sql);
2125           3                                 25         my ($key) = grep { m/create table/i } keys %$href;
               6                                 45   
2126  ***      3     50                          18         if ( $key ) {
2127           3                                  7            MKDEBUG && _d('This table is a base table');
2128           3                                 43            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2129                                                        }
2130                                                        else {
2131  ***      0                                  0            MKDEBUG && _d('This table is a view');
2132  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
2133  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2134                                                        }
2135                                                     }
2136           3                                 38      return $self->{tables}->{$db}->{$tbl};
2137                                                  }
2138                                                  
2139                                                  sub get_columns {
2140  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2141  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
2142  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2143  ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
2144  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2145  ***      0                                  0         MKDEBUG && _d($sql);
2146  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2147  ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
2148  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
2149                                                           map {
2150  ***      0                                  0               my %row;
2151  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2152  ***      0                                  0               \%row;
2153                                                           } @$cols
2154                                                        ];
2155                                                     }
2156  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
2157                                                  }
2158                                                  
2159                                                  sub get_tmp_table {
2160  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2161  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2162  ***      0                                  0      $result .= join(",\n",
2163  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2164  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2165  ***      0                                  0      $result .= "\n)";
2166  ***      0                                  0      MKDEBUG && _d($result);
2167  ***      0                                  0      return $result;
2168                                                  }
2169                                                  
2170                                                  sub get_triggers {
2171  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2172  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2173  ***      0                                  0         $self->{triggers}->{$db} = {};
2174  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2175                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2176                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2177                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2178  ***      0                                  0         MKDEBUG && _d($sql);
2179  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
2180  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2181  ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2182  ***      0                                  0         MKDEBUG && _d($sql);
2183  ***      0                                  0         my $sth = $dbh->prepare($sql);
2184  ***      0                                  0         $sth->execute();
2185  ***      0      0                           0         if ( $sth->rows ) {
2186  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
2187  ***      0                                  0            foreach my $trg (@$trgs) {
2188  ***      0                                  0               my %trg;
2189  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
2190  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
2191                                                           }
2192                                                        }
2193  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2194                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2195  ***      0                                  0         MKDEBUG && _d($sql);
2196  ***      0                                  0         $dbh->do($sql);
2197                                                     }
2198  ***      0      0                           0      if ( $tbl ) {
2199  ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
2200                                                     }
2201  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
2202                                                  }
2203                                                  
2204                                                  sub get_databases {
2205  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
2206  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2207  ***      0                                  0         my $sql = 'SHOW DATABASES';
2208  ***      0                                  0         my @params;
2209  ***      0      0                           0         if ( $like ) {
2210  ***      0                                  0            $sql .= ' LIKE ?';
2211  ***      0                                  0            push @params, $like;
2212                                                        }
2213  ***      0                                  0         my $sth = $dbh->prepare($sql);
2214  ***      0                                  0         MKDEBUG && _d($sql, @params);
2215  ***      0                                  0         $sth->execute( @params );
2216  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
2217  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
2218  ***      0                                  0         return @dbs;
2219                                                     }
2220  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
2221                                                  }
2222                                                  
2223                                                  sub get_table_status {
2224  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2225  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2226  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2227  ***      0                                  0         my @params;
2228  ***      0      0                           0         if ( $like ) {
2229  ***      0                                  0            $sql .= ' LIKE ?';
2230  ***      0                                  0            push @params, $like;
2231                                                        }
2232  ***      0                                  0         MKDEBUG && _d($sql, @params);
2233  ***      0                                  0         my $sth = $dbh->prepare($sql);
2234  ***      0                                  0         $sth->execute(@params);
2235  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2236  ***      0                                  0         @tables = map {
2237  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
2238  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2239  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2240  ***      0                                  0            delete $tbl{type};
2241  ***      0                                  0            \%tbl;
2242                                                        } @tables;
2243  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
2244  ***      0                                  0         return @tables;
2245                                                     }
2246  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
2247                                                  }
2248                                                  
2249                                                  sub get_table_list {
2250  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2251  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2252  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2253  ***      0                                  0         my @params;
2254  ***      0      0                           0         if ( $like ) {
2255  ***      0                                  0            $sql .= ' LIKE ?';
2256  ***      0                                  0            push @params, $like;
2257                                                        }
2258  ***      0                                  0         MKDEBUG && _d($sql, @params);
2259  ***      0                                  0         my $sth = $dbh->prepare($sql);
2260  ***      0                                  0         $sth->execute(@params);
2261  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
2262  ***      0      0      0                    0         @tables = map {
2263  ***      0                                  0            my %tbl = (
2264                                                              name   => $_->[0],
2265                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2266                                                           );
2267  ***      0                                  0            \%tbl;
2268                                                        } @tables;
2269  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
2270  ***      0                                  0         return @tables;
2271                                                     }
2272  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
2273                                                  }
2274                                                  
2275                                                  sub _d {
2276  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2277  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2278  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2279                                                          @_;
2280  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2281                                                  }
2282                                                  
2283                                                  1;
2284                                                  
2285                                                  # ###########################################################################
2286                                                  # End MySQLDump package
2287                                                  # ###########################################################################
2288                                                  
2289                                                  # ###########################################################################
2290                                                  # TableParser package 5266
2291                                                  # ###########################################################################
2292                                                  package TableParser;
2293                                                  
2294           1                    1             8   use strict;
               1                                  3   
               1                                  5   
2295           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
2296           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                 10   
2297           1                    1             6   use Data::Dumper;
               1                                  2   
               1                                  6   
2298                                                  $Data::Dumper::Indent    = 1;
2299                                                  $Data::Dumper::Sortkeys  = 1;
2300                                                  $Data::Dumper::Quotekeys = 0;
2301                                                  
2302  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 14   
2303                                                  
2304                                                  
2305                                                  sub new {
2306           1                    1            10      my ( $class, %args ) = @_;
2307           1                                  7      my @required_args = qw(Quoter);
2308           1                                  7      foreach my $arg ( @required_args ) {
2309  ***      1     50                          12         die "I need a $arg argument" unless $args{$arg};
2310                                                     }
2311           1                                  9      my $self = { %args };
2312           1                                 20      return bless $self, $class;
2313                                                  }
2314                                                  
2315                                                  
2316                                                  sub parse {
2317           3                    3            15      my ( $self, $ddl, $opts ) = @_;
2318  ***      3     50                          16      return unless $ddl;
2319  ***      3     50                          18      if ( ref $ddl eq 'ARRAY' ) {
2320  ***      3     50                          16         if ( lc $ddl->[0] eq 'table' ) {
2321           3                                 20            $ddl = $ddl->[1];
2322                                                        }
2323                                                        else {
2324                                                           return {
2325  ***      0                                  0               engine => 'VIEW',
2326                                                           };
2327                                                        }
2328                                                     }
2329                                                  
2330  ***      3     50                          35      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
2331  ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
2332                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
2333                                                     }
2334                                                  
2335           3                                 29      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
2336  ***      3     50                          26      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
2337                                                  
2338           3                                 84      $ddl =~ s/(`[^`]+`)/\L$1/g;
2339                                                  
2340           3                                 22      my $engine = $self->get_engine($ddl);
2341                                                  
2342           3                                 58      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
2343           3                                 15      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
               9                                 49   
2344           3                                 10      MKDEBUG && _d('Columns:', join(', ', @cols));
2345                                                  
2346           3                                  9      my %def_for;
2347           3                                 26      @def_for{@cols} = @defs;
2348                                                  
2349           3                                 12      my (@nums, @null);
2350           3                                 10      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
2351           3                                 14      foreach my $col ( @cols ) {
2352           9                                 29         my $def = $def_for{$col};
2353           9                                 64         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
2354  ***      9     50                          35         die "Can't determine column type for $def" unless $type;
2355           9                                 31         $type_for{$col} = $type;
2356  ***      9     50                          49         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
2357           9                                 36            push @nums, $col;
2358           9                                 32            $is_numeric{$col} = 1;
2359                                                        }
2360           9    100                          45         if ( $def !~ m/NOT NULL/ ) {
2361           6                                 19            push @null, $col;
2362           6                                 21            $is_nullable{$col} = 1;
2363                                                        }
2364  ***      9     50                          49         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
2365                                                     }
2366                                                  
2367           3                                 25      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
2368                                                  
2369                                                     return {
2370           9                                 43         name           => $name,
2371                                                        cols           => \@cols,
2372           9                                 96         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
2373           3                                 33         is_col         => { map { $_ => 1 } @cols },
2374                                                        null_cols      => \@null,
2375                                                        is_nullable    => \%is_nullable,
2376                                                        is_autoinc     => \%is_autoinc,
2377                                                        clustered_key  => $clustered_key,
2378                                                        keys           => $keys,
2379                                                        defs           => \%def_for,
2380                                                        numeric_cols   => \@nums,
2381                                                        is_numeric     => \%is_numeric,
2382                                                        engine         => $engine,
2383                                                        type_for       => \%type_for,
2384                                                     };
2385                                                  }
2386                                                  
2387                                                  sub sort_indexes {
2388  ***      0                    0             0      my ( $self, $tbl ) = @_;
2389                                                  
2390                                                     my @indexes
2391  ***      0                                  0         = sort {
2392  ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
2393                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
2394                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
2395  ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
2396                                                        }
2397                                                        grep {
2398  ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
2399                                                        }
2400  ***      0                                  0         sort keys %{$tbl->{keys}};
2401                                                  
2402  ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
2403  ***      0                                  0      return @indexes;
2404                                                  }
2405                                                  
2406                                                  sub find_best_index {
2407  ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
2408  ***      0                                  0      my $best;
2409  ***      0      0                           0      if ( $index ) {
2410  ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
2411                                                     }
2412  ***      0      0                           0      if ( !$best ) {
2413  ***      0      0                           0         if ( $index ) {
2414  ***      0                                  0            die "Index '$index' does not exist in table";
2415                                                        }
2416                                                        else {
2417  ***      0                                  0            ($best) = $self->sort_indexes($tbl);
2418                                                        }
2419                                                     }
2420  ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
2421  ***      0                                  0      return $best;
2422                                                  }
2423                                                  
2424                                                  sub find_possible_keys {
2425  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
2426  ***      0      0                           0      return () unless $where;
2427  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
2428                                                        . ' WHERE ' . $where;
2429  ***      0                                  0      MKDEBUG && _d($sql);
2430  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
2431  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
2432  ***      0      0                           0      if ( $expl->{possible_keys} ) {
2433  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
2434  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
2435  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
2436  ***      0      0                           0         if ( $expl->{key} ) {
2437  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
2438  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
2439  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
2440  ***      0                                  0            my %seen;
2441  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
2442                                                        }
2443  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
2444  ***      0                                  0         return @candidates;
2445                                                     }
2446                                                     else {
2447  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
2448  ***      0                                  0         return ();
2449                                                     }
2450                                                  }
2451                                                  
2452                                                  sub check_table {
2453  ***      0                    0             0      my ( $self, %args ) = @_;
2454  ***      0                                  0      my @required_args = qw(dbh db tbl);
2455  ***      0                                  0      foreach my $arg ( @required_args ) {
2456  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2457                                                     }
2458  ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
2459  ***      0                                  0      my $q      = $self->{Quoter};
2460  ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
2461  ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
2462                                                  
2463  ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
2464                                                             . ' LIKE ' . $q->literal_like($tbl);
2465  ***      0                                  0      MKDEBUG && _d($sql);
2466  ***      0                                  0      my $row;
2467  ***      0                                  0      eval {
2468  ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
2469                                                     };
2470  ***      0      0                           0      if ( $EVAL_ERROR ) {
2471  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
2472  ***      0                                  0         return 0;
2473                                                     }
2474  ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
2475  ***      0                                  0         MKDEBUG && _d('Table does not exist');
2476  ***      0                                  0         return 0;
2477                                                     }
2478                                                  
2479  ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
2480  ***      0      0                           0      return 1 unless $args{all_privs};
2481                                                  
2482  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
2483  ***      0                                  0      MKDEBUG && _d($sql);
2484  ***      0                                  0      eval {
2485  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
2486                                                     };
2487  ***      0      0                           0      if ( $EVAL_ERROR ) {
2488  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
2489  ***      0                                  0         return 0;
2490                                                     }
2491  ***      0      0                           0      if ( !scalar keys %$row ) {
2492  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
2493  ***      0                                  0         return 0;
2494                                                     }
2495  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
2496                                                  
2497  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
2498  ***      0                                  0      MKDEBUG && _d($sql);
2499  ***      0                                  0      eval {
2500  ***      0                                  0         $dbh->do($sql);
2501                                                     };
2502  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
2503                                                  
2504  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
2505                                                        ($can_delete ? 'delete' : ''));
2506                                                  
2507  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
2508                                                            && $can_delete) ) {
2509  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
2510  ***      0                                  0         return 0;
2511                                                     }
2512                                                  
2513  ***      0                                  0      MKDEBUG && _d('User has all privs');
2514  ***      0                                  0      return 1;
2515                                                  }
2516                                                  
2517                                                  sub get_engine {
2518           6                    6            29      my ( $self, $ddl, $opts ) = @_;
2519           6                                 78      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
2520           6                                 17      MKDEBUG && _d('Storage engine:', $engine);
2521  ***      6            50                   35      return $engine || undef;
2522                                                  }
2523                                                  
2524                                                  sub get_keys {
2525           3                    3            18      my ( $self, $ddl, $opts, $is_nullable ) = @_;
2526           3                                 15      my $engine        = $self->get_engine($ddl);
2527           3                                 11      my $keys          = {};
2528           3                                 10      my $clustered_key = undef;
2529                                                  
2530                                                     KEY:
2531           3                                102      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
2532                                                  
2533  ***      9     50                          39         next KEY if $key =~ m/FOREIGN/;
2534                                                  
2535           9                                 28         my $key_ddl = $key;
2536           9                                 20         MKDEBUG && _d('Parsed key:', $key_ddl);
2537                                                  
2538  ***      9     50                          50         if ( $engine !~ m/MEMORY|HEAP/ ) {
2539           9                                 32            $key =~ s/USING HASH/USING BTREE/;
2540                                                        }
2541                                                  
2542           9                                 75         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
2543           9                                 40         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
2544  ***      9            33                  123         $type = $type || $special || 'BTREE';
      ***                   50                        
2545  ***      9     50     33                   62         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
2546                                                           && $engine =~ m/HEAP|MEMORY/i )
2547                                                        {
2548  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
2549                                                        }
2550                                                  
2551           9                                 64         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
2552           9    100                          48         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
2553           9                                 25         my @cols;
2554           9                                 19         my @col_prefixes;
2555           9                                 43         foreach my $col_def ( split(',', $cols) ) {
2556          12                                 77            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
2557          12                                 47            push @cols, $name;
2558          12                                 45            push @col_prefixes, $prefix;
2559                                                        }
2560           9                                 41         $name =~ s/`//g;
2561                                                  
2562           9                                 20         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
2563                                                  
2564          12                                 52         $keys->{$name} = {
2565                                                           name         => $name,
2566                                                           type         => $type,
2567                                                           colnames     => $cols,
2568                                                           cols         => \@cols,
2569                                                           col_prefixes => \@col_prefixes,
2570                                                           is_unique    => $unique,
2571          12                                116            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
2572           9                                 49            is_col       => { map { $_ => 1 } @cols },
2573                                                           ddl          => $key_ddl,
2574                                                        };
2575                                                  
2576  ***      9    100     66                  111         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
2577           3                                 14            my $this_key = $keys->{$name};
2578  ***      3     50      0                   18            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
2579           3                                 15               $clustered_key = 'PRIMARY';
2580                                                           }
2581                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
2582  ***      0                                  0               $clustered_key = $this_key->{name};
2583                                                           }
2584           3                                 10            MKDEBUG && $clustered_key && _d('This key is the clustered key');
2585                                                        }
2586                                                     }
2587                                                  
2588           3                                 21      return $keys, $clustered_key;
2589                                                  }
2590                                                  
2591                                                  sub get_fks {
2592  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
2593  ***      0                                  0      my $fks = {};
2594                                                  
2595  ***      0                                  0      foreach my $fk (
2596                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
2597                                                     {
2598  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
2599  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
2600  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
2601                                                  
2602  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
2603  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
2604                                                        }
2605                                                  
2606  ***      0                                  0         $fks->{$name} = {
2607                                                           name           => $name,
2608                                                           colnames       => $cols,
2609  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
2610                                                           parent_tbl     => $parent,
2611                                                           parent_colnames=> $parent_cols,
2612  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
2613                                                           ddl            => $fk,
2614                                                        };
2615                                                     }
2616                                                  
2617  ***      0                                  0      return $fks;
2618                                                  }
2619                                                  
2620                                                  sub remove_auto_increment {
2621  ***      0                    0             0      my ( $self, $ddl ) = @_;
2622  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
2623  ***      0                                  0      return $ddl;
2624                                                  }
2625                                                  
2626                                                  sub remove_secondary_indexes {
2627  ***      0                    0             0      my ( $self, $ddl ) = @_;
2628  ***      0                                  0      my $sec_indexes_ddl;
2629  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
2630                                                  
2631  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
2632  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
2633  ***      0             0                    0         $clustered_key  ||= '';
2634                                                  
2635  ***      0                                  0         my @sec_indexes   = map {
2636  ***      0                                  0            my $key_def = $_->{ddl};
2637  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
2638  ***      0                                  0            $ddl =~ s/\s+$key_def//;
2639  ***      0                                  0            "ADD $_->{ddl}";
2640                                                        }
2641  ***      0                                  0         grep { $_->{name} ne $clustered_key }
2642  ***      0                                  0         values %{$tbl_struct->{keys}};
2643  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
2644                                                  
2645  ***      0      0                           0         if ( @sec_indexes ) {
2646  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
2647  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
2648                                                        }
2649                                                  
2650  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
2651                                                     }
2652                                                     else {
2653  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
2654                                                           $tbl_struct->{engine}, 'table');
2655                                                     }
2656                                                  
2657  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
2658                                                  }
2659                                                  
2660                                                  sub _d {
2661  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2662  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2663  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2664                                                          @_;
2665  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2666                                                  }
2667                                                  
2668                                                  1;
2669                                                  
2670                                                  # ###########################################################################
2671                                                  # End TableParser package
2672                                                  # ###########################################################################
2673                                                  
2674                                                  # ###########################################################################
2675                                                  # QueryParser package 5266
2676                                                  # ###########################################################################
2677                                                  package QueryParser;
2678                                                  
2679           1                    1             8   use strict;
               1                                  3   
               1                                 10   
2680           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                257   
2681           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
2682                                                  
2683  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 16   
2684                                                  our $tbl_ident = qr/(?:`[^`]+`|\w+)(?:\.(?:`[^`]+`|\w+))?/;
2685                                                  our $tbl_regex = qr{
2686                                                           \b(?:FROM|JOIN|(?<!KEY\s)UPDATE|INTO) # Words that precede table names
2687                                                           \b\s*
2688                                                           ($tbl_ident
2689                                                              (?: (?:\s+ (?:AS\s+)? \w+)?, \s*$tbl_ident )*
2690                                                           )
2691                                                        }xio;
2692                                                  our $has_derived = qr{
2693                                                        \b(?:FROM|JOIN|,)
2694                                                        \s*\(\s*SELECT
2695                                                     }xi;
2696                                                  
2697                                                  our $data_def_stmts = qr/(?:CREATE|ALTER|TRUNCATE|DROP|RENAME)/i;
2698                                                  
2699                                                  our $data_manip_stmts = qr/(?:INSERT|UPDATE|DELETE|REPLACE)/i;
2700                                                  
2701                                                  sub new {
2702           1                    1             6      my ( $class ) = @_;
2703           1                                 18      bless {}, $class;
2704                                                  }
2705                                                  
2706                                                  sub get_tables {
2707           3                    3            17      my ( $self, $query ) = @_;
2708  ***      3     50                          18      return unless $query;
2709           3                                  8      MKDEBUG && _d('Getting tables for', $query);
2710                                                  
2711           3                                130      my ( $ddl_stmt ) = $query =~ /^\s*($data_def_stmts)\b/i;
2712  ***      3     50                          29      if ( $ddl_stmt ) {
2713  ***      0                                  0         MKDEBUG && _d('Special table type:', $ddl_stmt);
2714  ***      0                                  0         $query =~ s/IF NOT EXISTS//i;
2715  ***      0      0                           0         if ( $query =~ m/$ddl_stmt DATABASE\b/i ) {
2716  ***      0                                  0            MKDEBUG && _d('Query alters a database, not a table');
2717  ***      0                                  0            return ();
2718                                                        }
2719  ***      0      0      0                    0         if ( $ddl_stmt =~ m/CREATE/i && $query =~ m/$ddl_stmt\b.+?\bSELECT\b/i ) {
2720  ***      0                                  0            my ($select) = $query =~ m/\b(SELECT\b.+)/is;
2721  ***      0                                  0            MKDEBUG && _d('CREATE TABLE ... SELECT:', $select);
2722  ***      0                                  0            return $self->get_tables($select);
2723                                                        }
2724  ***      0                                  0         my ($tbl) = $query =~ m/TABLE\s+($tbl_ident)(\s+.*)?/i;
2725  ***      0                                  0         MKDEBUG && _d('Matches table:', $tbl);
2726  ***      0                                  0         return ($tbl);
2727                                                     }
2728                                                  
2729           3                                 22      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
2730                                                  
2731  ***      3     50                          19      if ( $query =~ /^\s*LOCK TABLES/i ) {
2732  ***      0                                  0         MKDEBUG && _d('Special table type: LOCK TABLES');
2733  ***      0                                  0         $query =~ s/^(\s*LOCK TABLES\s+)//;
2734  ***      0                                  0         $query =~ s/\s+(?:READ|WRITE|LOCAL)+\s*//g;
2735  ***      0                                  0         MKDEBUG && _d('Locked tables:', $query);
2736  ***      0                                  0         $query = "FROM $query";
2737                                                     }
2738                                                  
2739           3                                 14      $query =~ s/\\["']//g;                # quoted strings
2740           3                                 10      $query =~ s/".*?"/?/sg;               # quoted strings
2741           3                                 11      $query =~ s/'.*?'/?/sg;               # quoted strings
2742                                                  
2743           3                                  9      my @tables;
2744           3                                 57      foreach my $tbls ( $query =~ m/$tbl_regex/gio ) {
2745           3                                  9         MKDEBUG && _d('Match tables:', $tbls);
2746           3                                 20         foreach my $tbl ( split(',', $tbls) ) {
2747           3                                 83            $tbl =~ s/\s*($tbl_ident)(\s+.*)?/$1/gio;
2748                                                  
2749  ***      3     50                          27            if ( $tbl !~ m/[a-zA-Z]/ ) {
2750  ***      0                                  0               MKDEBUG && _d('Skipping suspicious table name:', $tbl);
2751  ***      0                                  0               next;
2752                                                           }
2753                                                  
2754           3                                 21            push @tables, $tbl;
2755                                                        }
2756                                                     }
2757           3                                 19      return @tables;
2758                                                  }
2759                                                  
2760                                                  sub has_derived_table {
2761  ***      0                    0             0      my ( $self, $query ) = @_;
2762  ***      0                                  0      my $match = $query =~ m/$has_derived/;
2763  ***      0                                  0      MKDEBUG && _d($query, 'has ' . ($match ? 'a' : 'no') . ' derived table');
2764  ***      0                                  0      return $match;
2765                                                  }
2766                                                  
2767                                                  sub get_aliases {
2768  ***      0                    0             0      my ( $self, $query ) = @_;
2769  ***      0      0                           0      return unless $query;
2770  ***      0                                  0      my $aliases;
2771                                                  
2772  ***      0                                  0      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
2773                                                  
2774  ***      0                                  0      $query =~ s/ (?:INNER|OUTER|CROSS|LEFT|RIGHT|NATURAL)//ig;
2775                                                  
2776  ***      0                                  0      my ($tbl_refs, $from) = $query =~ m{
2777                                                        (
2778                                                           (FROM|INTO|UPDATE)\b\s*   # Keyword before table refs
2779                                                           .+?                       # Table refs
2780                                                        )
2781                                                        (?:\s+|\z)                   # If the query does not end with the table
2782                                                        (?:WHERE|ORDER|LIMIT|HAVING|SET|VALUES|\z) # Keyword after table refs
2783                                                     }ix;
2784                                                  
2785  ***      0      0      0                    0      die "Failed to parse table references from $query"
2786                                                        unless $tbl_refs && $from;
2787                                                  
2788  ***      0                                  0      MKDEBUG && _d('tbl refs:', $tbl_refs);
2789                                                  
2790  ***      0                                  0      my $before_tbl = qr/(?:,|JOIN|\s|$from)+/i;
2791                                                  
2792  ***      0                                  0      my $after_tbl  = qr/(?:,|JOIN|ON|USING|\z)/i;
2793                                                  
2794  ***      0                                  0      $tbl_refs =~ s/ = /=/g;
2795                                                  
2796  ***      0                                  0      while (
2797                                                        $tbl_refs =~ m{
2798                                                           $before_tbl\b\s*
2799                                                              ( ($tbl_ident) (?:\s+ (?:AS\s+)? (\w+))? )
2800                                                           \s*$after_tbl
2801                                                        }xgio )
2802                                                     {
2803  ***      0                                  0         my ( $tbl_ref, $db_tbl, $alias ) = ($1, $2, $3);
2804  ***      0                                  0         MKDEBUG && _d('Match table:', $tbl_ref);
2805                                                  
2806  ***      0      0                           0         if ( $tbl_ref =~ m/^AS\s+\w+/i ) {
2807  ***      0                                  0            MKDEBUG && _d('Subquery', $tbl_ref);
2808  ***      0                                  0            $aliases->{$alias} = undef;
2809  ***      0                                  0            next;
2810                                                        }
2811                                                  
2812  ***      0                                  0         my ( $db, $tbl ) = $db_tbl =~ m/^(?:(.*?)\.)?(.*)/;
2813  ***      0             0                    0         $aliases->{$alias || $tbl} = $tbl;
2814  ***      0      0                           0         $aliases->{DATABASE}->{$tbl} = $db if $db;
2815                                                     }
2816  ***      0                                  0      return $aliases;
2817                                                  }
2818                                                  
2819                                                  sub split {
2820  ***      0                    0             0      my ( $self, $query ) = @_;
2821  ***      0      0                           0      return unless $query;
2822  ***      0                                  0      $query = $self->clean_query($query);
2823  ***      0                                  0      MKDEBUG && _d('Splitting', $query);
2824                                                  
2825  ***      0                                  0      my $verbs = qr{SELECT|INSERT|UPDATE|DELETE|REPLACE|UNION|CREATE}i;
2826                                                  
2827  ***      0                                  0      my @split_statements = grep { $_ } split(m/\b($verbs\b(?!(?:\s*\()))/io, $query);
      ***      0                                  0   
2828                                                  
2829  ***      0                                  0      my @statements;
2830  ***      0      0                           0      if ( @split_statements == 1 ) {
2831  ***      0                                  0         push @statements, $query;
2832                                                     }
2833                                                     else {
2834                                                        for ( my $i = 0; $i <= $#split_statements; $i += 2 ) {
2835  ***      0                                  0            push @statements, $split_statements[$i].$split_statements[$i+1];
2836                                                  
2837  ***      0      0      0                    0            if ( $statements[-2] && $statements[-2] =~ m/on duplicate key\s+$/i ) {
2838  ***      0                                  0               $statements[-2] .= pop @statements;
2839                                                           }
2840  ***      0                                  0         }
2841                                                     }
2842                                                  
2843  ***      0                                  0      MKDEBUG && _d('statements:', map { $_ ? "<$_>" : 'none' } @statements);
2844  ***      0                                  0      return @statements;
2845                                                  }
2846                                                  
2847                                                  sub clean_query {
2848  ***      0                    0             0      my ( $self, $query ) = @_;
2849  ***      0      0                           0      return unless $query;
2850  ***      0                                  0      $query =~ s!/\*.*?\*/! !g;  # Remove /* comment blocks */
2851  ***      0                                  0      $query =~ s/^\s+//;         # Remove leading spaces
2852  ***      0                                  0      $query =~ s/\s+$//;         # Remove trailing spaces
2853  ***      0                                  0      $query =~ s/\s{2,}/ /g;     # Remove extra spaces
2854  ***      0                                  0      return $query;
2855                                                  }
2856                                                  
2857                                                  sub split_subquery {
2858  ***      0                    0             0      my ( $self, $query ) = @_;
2859  ***      0      0                           0      return unless $query;
2860  ***      0                                  0      $query = $self->clean_query($query);
2861  ***      0                                  0      $query =~ s/;$//;
2862                                                  
2863  ***      0                                  0      my @subqueries;
2864  ***      0                                  0      my $sqno = 0;  # subquery number
2865  ***      0                                  0      my $pos  = 0;
2866  ***      0                                  0      while ( $query =~ m/(\S+)(?:\s+|\Z)/g ) {
2867  ***      0                                  0         $pos = pos($query);
2868  ***      0                                  0         my $word = $1;
2869  ***      0                                  0         MKDEBUG && _d($word, $sqno);
2870  ***      0      0                           0         if ( $word =~ m/^\(?SELECT\b/i ) {
2871  ***      0                                  0            my $start_pos = $pos - length($word) - 1;
2872  ***      0      0                           0            if ( $start_pos ) {
2873  ***      0                                  0               $sqno++;
2874  ***      0                                  0               MKDEBUG && _d('Subquery', $sqno, 'starts at', $start_pos);
2875  ***      0                                  0               $subqueries[$sqno] = {
2876                                                                 start_pos => $start_pos,
2877                                                                 end_pos   => 0,
2878                                                                 len       => 0,
2879                                                                 words     => [$word],
2880                                                                 lp        => 1, # left parentheses
2881                                                                 rp        => 0, # right parentheses
2882                                                                 done      => 0,
2883                                                              };
2884                                                           }
2885                                                           else {
2886  ***      0                                  0               MKDEBUG && _d('Main SELECT at pos 0');
2887                                                           }
2888                                                        }
2889                                                        else {
2890  ***      0      0                           0            next unless $sqno;  # next unless we're in a subquery
2891  ***      0                                  0            MKDEBUG && _d('In subquery', $sqno);
2892  ***      0                                  0            my $sq = $subqueries[$sqno];
2893  ***      0      0                           0            if ( $sq->{done} ) {
2894  ***      0                                  0               MKDEBUG && _d('This subquery is done; SQL is for',
2895                                                                 ($sqno - 1 ? "subquery $sqno" : "the main SELECT"));
2896  ***      0                                  0               next;
2897                                                           }
2898  ***      0                                  0            push @{$sq->{words}}, $word;
      ***      0                                  0   
2899  ***      0             0                    0            my $lp = ($word =~ tr/\(//) || 0;
2900  ***      0             0                    0            my $rp = ($word =~ tr/\)//) || 0;
2901  ***      0                                  0            MKDEBUG && _d('parentheses left', $lp, 'right', $rp);
2902  ***      0      0                           0            if ( ($sq->{lp} + $lp) - ($sq->{rp} + $rp) == 0 ) {
2903  ***      0                                  0               my $end_pos = $pos - 1;
2904  ***      0                                  0               MKDEBUG && _d('Subquery', $sqno, 'ends at', $end_pos);
2905  ***      0                                  0               $sq->{end_pos} = $end_pos;
2906  ***      0                                  0               $sq->{len}     = $end_pos - $sq->{start_pos};
2907                                                           }
2908                                                        }
2909                                                     }
2910                                                  
2911  ***      0                                  0      for my $i ( 1..$#subqueries ) {
2912  ***      0                                  0         my $sq = $subqueries[$i];
2913  ***      0      0                           0         next unless $sq;
2914  ***      0                                  0         $sq->{sql} = join(' ', @{$sq->{words}});
      ***      0                                  0   
2915  ***      0                                  0         substr $query,
2916                                                           $sq->{start_pos} + 1,  # +1 for (
2917                                                           $sq->{len} - 1,        # -1 for )
2918                                                           "__subquery_$i";
2919                                                     }
2920                                                  
2921  ***      0                                  0      return $query, map { $_->{sql} } grep { defined $_ } @subqueries;
      ***      0                                  0   
      ***      0                                  0   
2922                                                  }
2923                                                  
2924                                                  sub query_type {
2925  ***      0                    0             0      my ( $self, $query, $qr ) = @_;
2926  ***      0                                  0      my ($type, undef) = $qr->_distill_verbs($query);
2927  ***      0                                  0      my $rw;
2928  ***      0      0      0                    0      if ( $type =~ m/^SELECT\b/ ) {
      ***             0                               
2929  ***      0                                  0         $rw = 'read';
2930                                                     }
2931                                                     elsif ( $type =~ m/^$data_manip_stmts\b/
2932                                                             || $type =~ m/^$data_def_stmts\b/  ) {
2933  ***      0                                  0         $rw = 'write'
2934                                                     }
2935                                                  
2936                                                     return {
2937  ***      0                                  0         type => $type,
2938                                                        rw   => $rw,
2939                                                     }
2940                                                  }
2941                                                  
2942                                                  sub _d {
2943  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2944  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2945  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2946                                                          @_;
2947  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2948                                                  }
2949                                                  
2950                                                  1;
2951                                                  
2952                                                  # ###########################################################################
2953                                                  # End QueryParser package
2954                                                  # ###########################################################################
2955                                                  
2956                                                  # ###########################################################################
2957                                                  # Quoter package 5266
2958                                                  # ###########################################################################
2959           1                    1             7   use strict;
               1                                  3   
               1                                 18   
2960           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
2961                                                  
2962                                                  package Quoter;
2963                                                  
2964           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
2965                                                  
2966  ***      1            50      1            15   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 14   
2967                                                  
2968                                                  sub new {
2969           1                    1             9      my ( $class ) = @_;
2970           1                                 32      bless {}, $class;
2971                                                  }
2972                                                  
2973                                                  sub quote {
2974          52                   52           215      my ( $self, @vals ) = @_;
2975          52                                185      foreach my $val ( @vals ) {
2976          58                                222         $val =~ s/`/``/g;
2977                                                     }
2978          52                                181      return join('.', map { '`' . $_ . '`' } @vals);
              58                                355   
2979                                                  }
2980                                                  
2981                                                  sub quote_val {
2982          36                   36           134      my ( $self, $val, $is_numeric ) = @_;
2983                                                  
2984          36    100                         156      return 'NULL' unless defined $val;  # undef = NULL
2985  ***     24     50                          93      return "''" if $val eq '';          # blank string = ''
2986                                                  
2987  ***     24     50                          85      if ( !defined $is_numeric ) {
2988          24    100                         131         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
2989                                                     }
2990                                                  
2991          24    100                         112      return $val if $is_numeric;
2992                                                  
2993           3                                 13      $val =~ s/(['\\])/\\$1/g;
2994           3                                 47      return "'$val'";
2995                                                  }
2996                                                  
2997                                                  sub split_unquote {
2998           6                    6            31      my ( $self, $db_tbl, $default_db ) = @_;
2999           6                                 38      $db_tbl =~ s/`//g;
3000           6                                 36      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
3001           6    100                          26      if ( !$tbl ) {
3002           3                                  8         $tbl = $db;
3003           3                                  9         $db  = $default_db;
3004                                                     }
3005           6                                 33      return ($db, $tbl);
3006                                                  }
3007                                                  
3008                                                  sub literal_like {
3009  ***      0                    0             0      my ( $self, $like ) = @_;
3010  ***      0      0                           0      return unless $like;
3011  ***      0                                  0      $like =~ s/([%_])/\\$1/g;
3012  ***      0                                  0      return "'$like'";
3013                                                  }
3014                                                  
3015                                                  1;
3016                                                  
3017                                                  # ###########################################################################
3018                                                  # End Quoter package
3019                                                  # ###########################################################################
3020                                                  
3021                                                  # ###########################################################################
3022                                                  # SlavePrefetch package 5266
3023                                                  # ###########################################################################
3024                                                  package SlavePrefetch;
3025                                                  
3026           1                    1             7   use strict;
               1                                  2   
               1                                  6   
3027           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  4   
3028           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  4   
3029                                                  
3030           1                    1             7   use List::Util qw(min max sum);
               1                                  3   
               1                                  5   
3031           1                    1             6   use Time::HiRes qw(gettimeofday);
               1                                  2   
               1                                 13   
3032           1                    1             6   use Data::Dumper;
               1                                  3   
               1                                  6   
3033                                                  $Data::Dumper::Indent    = 1;
3034                                                  $Data::Dumper::Sortkeys  = 1;
3035                                                  $Data::Dumper::Quotekeys = 0;
3036                                                  
3037  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 13   
3038                                                  
3039                                                  sub new {
3040  ***      0                    0             0      my ( $class, %args ) = @_;
3041  ***      0                                  0      my @required_args = qw(dbh oktorun chk_int chk_min chk_max
3042                                                                            datadir QueryRewriter);
3043  ***      0                                  0      foreach my $arg ( @required_args ) {
3044  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3045                                                     }
3046  ***      0             0                    0      $args{'offset'}            ||= 128;
3047  ***      0             0                    0      $args{'window'}            ||= 4_096;
3048  ***      0             0                    0      $args{'io-lag'}            ||= 1_024;
3049  ***      0             0                    0      $args{'query-sample-size'} ||= 4;
3050  ***      0             0                    0      $args{'max-query-time'}    ||= 1;
3051                                                  
3052                                                     my $self = {
3053                                                        %args, 
3054                                                        pos          => 0,
3055                                                        next         => 0,
3056                                                        last_ts      => 0,
3057                                                        slave        => undef,
3058                                                        last_chk     => 0,
3059                                                        stats        => {
3060                                                           events => 0
3061                                                        },
3062                                                        query_stats  => {},
3063                                                        query_errors => {},
3064                                                        callbacks    => {
3065                                                           show_slave_status => sub {
3066  ***      0                    0             0               my ( $dbh ) = @_;
3067  ***      0                                  0               return $dbh->selectrow_hashref("SHOW SLAVE STATUS");
3068                                                           }, 
3069                                                           use_db            => sub {
3070  ***      0                    0             0               my ( $dbh, $db ) = @_;
3071  ***      0                                  0               eval {
3072  ***      0                                  0                  MKDEBUG && _d('USE', $db);
3073  ***      0                                  0                  $dbh->do("USE `$db`");
3074                                                              };
3075  ***      0                                  0               MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3076  ***      0                                  0               return;
3077                                                           },
3078  ***      0                                  0            wait_for_master   => \&_wait_for_master,
3079                                                        },
3080                                                     };
3081                                                  
3082  ***      0      0                           0      init_stats($self->{stats}, $args{stats_file}, $args{'query-sample-size'})
3083                                                        if $args{stats_file};
3084                                                  
3085  ***      0                                  0      return bless $self, $class;
3086                                                  }
3087                                                  
3088                                                  sub set_callbacks {
3089  ***      0                    0             0      my ( $self, %callbacks ) = @_;
3090  ***      0                                  0      foreach my $func ( keys %callbacks ) {
3091  ***      0      0                           0         die "Callback $func does not exist"
3092                                                           unless exists $self->{callbacks}->{$func};
3093  ***      0                                  0         $self->{callbacks}->{$func} = $callbacks{$func};
3094  ***      0                                  0         MKDEBUG && _d('Set new callback for', $func);
3095                                                     }
3096  ***      0                                  0      return;
3097                                                  }
3098                                                  
3099                                                  sub init_stats {
3100  ***      0                    0             0      my ( $stats, $file, $n_samples ) = @_;
3101  ***      0      0                           0      open my $fh, "<", $file or die $OS_ERROR;
3102  ***      0                                  0      MKDEBUG && _d('Reading saved stats from', $file);
3103  ***      0                                  0      my ($type, $rest);
3104  ***      0                                  0      while ( my $line = <$fh> ) {
3105  ***      0                                  0         ($type, $rest) = $line =~ m/^# (query|stats): (.*)$/;
3106  ***      0      0                           0         next unless $type;
3107  ***      0      0                           0         if ( $type eq 'query' ) {
3108  ***      0                                  0            $stats->{$rest} = { seen => 1, samples => [] };
3109                                                        }
3110                                                        else {
3111  ***      0                                  0            my ( $seen, $exec, $sum, $avg )
3112                                                              = $rest =~ m/seen=(\S+) exec=(\S+) sum=(\S+) avg=(\S+)/;
3113  ***      0      0                           0            if ( $seen ) {
3114  ***      0                                  0               $stats->{$rest}->{samples}
3115  ***      0                                  0                  = [ map { $avg } (1..$n_samples) ];
3116  ***      0                                  0               $stats->{$rest}->{avg} = $avg;
3117                                                           }
3118                                                        }
3119                                                     }
3120  ***      0      0                           0      close $fh or die $OS_ERROR;
3121  ***      0                                  0      return;
3122                                                  }
3123                                                  
3124                                                  sub incr_stat {
3125  ***      0                    0             0      my ( $self, $stat ) = @_;
3126  ***      0                                  0      $self->{stats}->{$stat}++;
3127  ***      0                                  0      return;
3128                                                  }
3129                                                  
3130                                                  sub get_stats {
3131  ***      0                    0             0      my ( $self ) = @_;
3132  ***      0                                  0      return $self->{stats}, $self->{query_stats}, $self->{query_errors};
3133                                                  }
3134                                                  
3135                                                  sub reset_stats {
3136  ***      0                    0             0      my ( $self, %args ) = @_;
3137  ***      0      0      0                    0      $self->{stats} = { events => 0, } if $args{all} || $args{stats};
3138  ***      0      0      0                    0      $self->{query_stats}  = {}        if $args{all} || $args{query_stats};
3139  ***      0      0      0                    0      $self->{query_errors} = {}        if $args{all} || $args{query_errors};
3140  ***      0                                  0      return;
3141                                                  }
3142                                                  
3143                                                  
3144                                                  sub open_relay_log {
3145  ***      0                    0             0      my ( $self, %args ) = @_;
3146  ***      0                                  0      my @required_args = qw(tmpdir);
3147  ***      0                                  0      foreach my $arg ( @required_args ) {
3148  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3149                                                     }
3150  ***      0                                  0      my ($tmpdir)    = @args{@required_args};
3151  ***      0             0                    0      my $datadir     = $args{datadir}     || $self->{datadir};
3152  ***      0             0                    0      my $start_pos   = $args{start_pos}   || $self->{slave}->{pos};
3153  ***      0             0                    0      my $file        = $args{file}        || $self->{slave}->{file};
3154  ***      0             0                    0      my $mysqlbinlog = $args{mysqlbinlog} || 'mysqlbinlog';
3155                                                  
3156  ***      0      0                           0      if ( !-r "$datadir/$file" ) {
3157  ***      0                                  0         die "Relay log $datadir/$file does not exist or is not readable";
3158                                                     }
3159                                                  
3160  ***      0                                  0      my $cmd = "$mysqlbinlog -l $tmpdir "
3161                                                             . " --start-pos=$start_pos $datadir/$file"
3162                                                             . (MKDEBUG ? ' 2>/dev/null' : '');
3163  ***      0                                  0      MKDEBUG && _d('Opening relay log:', $cmd);
3164                                                  
3165  ***      0      0                           0      open my $fh, "$cmd |" or die $OS_ERROR; # Succeeds even on error
3166  ***      0      0                           0      if ( $CHILD_ERROR ) {
3167  ***      0                                  0         die "$cmd returned exit code " . ($CHILD_ERROR >> 8)
3168                                                           . '.  Try running the command manually or using MKDEBUG=1' ;
3169                                                     }
3170  ***      0                                  0      $self->{cmd} = $cmd;
3171  ***      0                                  0      $self->{stats}->{mysqlbinlog}++;
3172  ***      0                                  0      return $fh;
3173                                                  }
3174                                                  
3175                                                  sub close_relay_log {
3176  ***      0                    0             0      my ( $self, $fh ) = @_;
3177  ***      0                                  0      MKDEBUG && _d('Closing relay log');
3178  ***      0                                  0      my $procs = `ps -eaf | grep mysqlbinlog | grep -v grep`;
3179  ***      0                                  0      my $cmd   = $self->{cmd};
3180  ***      0                                  0      MKDEBUG && _d($procs);
3181  ***      0      0                           0      if ( my ($line) = $procs =~ m/^(.*?\d\s+$cmd)$/m ) {
3182  ***      0                                  0         chomp $line;
3183  ***      0                                  0         MKDEBUG && _d($line);
3184  ***      0      0                           0         if ( my ( $proc ) = $line =~ m/(\d+)/ ) {
3185  ***      0                                  0            MKDEBUG && _d('Will kill process', $proc);
3186  ***      0                                  0            kill(15, $proc);
3187                                                        }
3188                                                     }
3189                                                     else {
3190  ***      0                                  0         warn "Cannot find mysqlbinlog command in ps";
3191                                                     }
3192  ***      0      0                           0      if ( !close($fh) ) {
3193  ***      0      0                           0         if ( $OS_ERROR ) {
3194  ***      0                                  0            warn "Error closing mysqlbinlog pipe: $OS_ERROR\n";
3195                                                        }
3196                                                        else {
3197  ***      0                                  0            MKDEBUG && _d('Exit status', $CHILD_ERROR,'from mysqlbinlog');
3198                                                        }
3199                                                     }
3200  ***      0                                  0      return;
3201                                                  }
3202                                                  
3203                                                  sub _check_slave_status {
3204  ***      0                    0             0      my ( $self ) = @_;
3205                                                     return
3206  ***      0      0      0                    0         $self->{pos} > $self->{slave}->{pos}
3207                                                        && ($self->{stats}->{events} - $self->{last_chk}) >= $self->{chk_int}
3208                                                           ? 1 : 0;
3209                                                  }
3210                                                  
3211                                                  sub _get_next_chk_int {
3212  ***      0                    0             0      my ( $self ) = @_;
3213  ***      0      0                           0      if ( $self->{pos} <= $self->{slave}->{pos} ) {
3214  ***      0                                  0         return max($self->{chk_min}, $self->{chk_int} / 2);
3215                                                     }
3216                                                     else {
3217  ***      0                                  0         return min($self->{chk_max}, $self->{chk_int} * 2);
3218                                                     }
3219                                                  }
3220                                                  
3221                                                  sub _get_slave_status {
3222  ***      0                    0             0      my ( $self, $callback ) = @_;
3223  ***      0                                  0      $self->{stats}->{show_slave_status}++;
3224                                                  
3225                                                  
3226  ***      0                                  0      my $show_slave_status = $self->{callbacks}->{show_slave_status};
3227  ***      0                                  0      my $status            = $show_slave_status->($self->{dbh}); 
3228  ***      0      0      0                    0      if ( !$status || !%$status ) {
3229  ***      0                                  0         die "No output from SHOW SLAVE STATUS";
3230                                                     }
3231  ***      0      0      0                    0      my %status = (
3232                                                        running => ($status->{slave_sql_running} || '') eq 'Yes',
3233                                                        file    => $status->{relay_log_file},
3234                                                        pos     => $status->{relay_log_pos},
3235                                                        lag   => $status->{master_log_file} eq $status->{relay_master_log_file}
3236                                                               ? $status->{read_master_log_pos} - $status->{exec_master_log_pos}
3237                                                               : 0,
3238                                                        mfile => $status->{relay_master_log_file},
3239                                                        mpos  => $status->{exec_master_log_pos},
3240                                                     );
3241                                                  
3242  ***      0                                  0      $self->{slave}    = \%status;
3243  ***      0                                  0      $self->{last_chk} = $self->{stats}->{events};
3244  ***      0                                  0      MKDEBUG && _d('Slave status:', Dumper($self->{slave}));
3245  ***      0                                  0      return;
3246                                                  }
3247                                                  
3248                                                  sub get_slave_status {
3249  ***      0                    0             0      my ( $self ) = @_;
3250  ***      0                                  0      return $self->{slave};
3251                                                  }
3252                                                  
3253                                                  sub slave_is_running {
3254  ***      0                    0             0      my ( $self ) = @_;
3255  ***      0                                  0      return $self->{slave}->{running};
3256                                                  }
3257                                                  
3258                                                  sub get_interval {
3259  ***      0                    0             0      my ( $self ) = @_;
3260  ***      0                                  0      return $self->{stats}->{events}, $self->{last_chk};
3261                                                  }
3262                                                  
3263                                                  sub get_pipeline_pos {
3264  ***      0                    0             0      my ( $self ) = @_;
3265  ***      0                                  0      return $self->{pos}, $self->{next}, $self->{last_ts};
3266                                                  }
3267                                                  
3268                                                  sub set_pipeline_pos {
3269  ***      0                    0             0      my ( $self, $pos, $next, $ts ) = @_;
3270  ***      0      0      0                    0      die "pos must be >= 0"  unless defined $pos && $pos >= 0;
3271  ***      0      0      0                    0      die "next must be >= 0" unless defined $pos && $pos >= 0;
3272  ***      0                                  0      $self->{pos}     = $pos;
3273  ***      0                                  0      $self->{next}    = $next;
3274  ***      0             0                    0      $self->{last_ts} = $ts || 0;  # undef same as zero
3275  ***      0                                  0      MKDEBUG && _d('Set pipeline pos', @_);
3276  ***      0                                  0      return;
3277                                                  }
3278                                                  
3279                                                  sub reset_pipeline_pos {
3280  ***      0                    0             0      my ( $self ) = @_;
3281  ***      0                                  0      $self->{pos}     = 0; # Current position we're reading in relay log.
3282  ***      0                                  0      $self->{next}    = 0; # Start of next relay log event.
3283  ***      0                                  0      $self->{last_ts} = 0; # Last seen timestamp.
3284  ***      0                                  0      MKDEBUG && _d('Reset pipeline');
3285  ***      0                                  0      return;
3286                                                  }
3287                                                  
3288                                                  sub pipeline_event {
3289  ***      0                    0             0      my ( $self, $event, @callbacks ) = @_;
3290  ***      0                                  0      $self->{stats}->{events}++;
3291                                                  
3292  ***      0      0                           0      if ( !$event->{offset} ) {
3293  ***      0                                  0         MKDEBUG && _d('Event has no offset, skipping');
3294  ***      0                                  0         $self->{stats}->{event_without_offset}++;
3295  ***      0                                  0         return;
3296                                                     }
3297                                                  
3298  ***      0      0                           0      $self->{pos}  = $event->{offset} if $event->{offset};
3299  ***      0             0                    0      $self->{next} = max($self->{next},$self->{pos}+($event->{end_log_pos} || 0));
3300                                                  
3301  ***      0      0      0                    0      if ( $self->{progress}
3302                                                          && $self->{stats}->{events} % $self->{progress} == 0 ) {
3303  ***      0                                  0         print("# $self->{slave}->{file} $self->{pos} ",
3304  ***      0                                  0            join(' ', map { "$_:$self->{stats}->{$_}" } keys %{$self->{stats}}),
      ***      0                                  0   
3305                                                           "\n");
3306                                                     }
3307                                                  
3308  ***      0      0                           0      if ( $self->_check_slave_status() ) { 
3309  ***      0                                  0         MKDEBUG && _d('Checking slave status at interval',
3310                                                           $self->{stats}->{events});
3311  ***      0                                  0         $self->_get_slave_status();
3312  ***      0                                  0         $self->{chk_int} = $self->_get_next_chk_int();
3313  ***      0                                  0         MKDEBUG && _d('Next check interval:', $self->{chk_int});
3314                                                     }
3315                                                  
3316  ***      0      0                           0      return unless $self->_in_window();
3317                                                  
3318  ***      0      0                           0      if ( $event->{arg} ) {
3319  ***      0      0                           0         if ( my ($file) = $event->{arg} =~ m/INFILE ('[^']+')/i ) {
3320  ***      0                                  0            $self->{stats}->{load_data_infile}++;
3321  ***      0      0                           0            if ( !unlink($file) ) {
3322  ***      0                                  0               MKDEBUG && _d('Could not unlink', $file);
3323  ***      0                                  0               $self->{stats}->{could_not_unlink}++;
3324                                                           }
3325  ***      0                                  0            return;
3326                                                        }
3327                                                  
3328  ***      0                                  0         my ($query, $fingerprint) = $self->prepare_query($event->{arg});
3329  ***      0      0                           0         if ( !$query ) {
3330  ***      0                                  0            MKDEBUG && _d('Failed to prepare query, skipping');
3331  ***      0                                  0            return;
3332                                                        }
3333                                                  
3334  ***      0                                  0         my $db = $event->{db};
3335  ***      0      0      0                    0         if ( $db && (!$self->{last_db} || $self->{last_db} ne $db) ) {
      ***                    0                        
3336  ***      0                                  0            MKDEBUG && _d('Change db, last:', $self->{last_db}, 'current:', $db);
3337  ***      0                                  0            $self->{callbacks}->{use_db}->($self->{dbh}, $db);
3338  ***      0                                  0            $self->{last_db} = $db;
3339                                                        }
3340  ***      0      0                           0         $self->{stats}->{no_database}++ unless $self->{last_db};
3341                                                  
3342  ***      0                                  0         $self->{stats}->{do_query}++;
3343  ***      0                                  0         foreach my $callback ( @callbacks ) {
3344  ***      0                                  0            $callback->(
3345                                                              query       => $query,
3346                                                              fingerprint => $fingerprint,
3347                                                              db          => $self->{last_db},
3348                                                           );
3349                                                        }
3350                                                     }
3351                                                  
3352  ***      0                                  0      return;
3353                                                  }
3354                                                  
3355                                                  sub get_window {
3356  ***      0                    0             0      my ( $self ) = @_;
3357  ***      0                                  0      return $self->{offset}, $self->{window};
3358                                                  }
3359                                                  
3360                                                  sub set_window {
3361  ***      0                    0             0      my ( $self, $offset, $window ) = @_;
3362  ***      0      0                           0      die "offset must be > 0" unless $offset;
3363  ***      0      0                           0      die "window must be > 0" unless $window;
3364  ***      0                                  0      $self->{offset} = $offset;
3365  ***      0                                  0      $self->{window} = $window;
3366  ***      0                                  0      MKDEBUG && _d('Set window', @_);
3367  ***      0                                  0      return;
3368                                                  }
3369                                                  
3370                                                  sub _in_window {
3371  ***      0                    0             0      my ( $self ) = @_;
3372  ***      0                                  0      MKDEBUG && _d('Checking window, pos:', $self->{pos},
3373                                                        'next', $self->{next},
3374                                                        'slave pos:', $self->{slave}->{pos},
3375                                                        'master pos', $self->{slave}->{mpos});
3376                                                  
3377  ***      0      0                           0      return 0 unless $self->_far_enough_ahead();
3378                                                  
3379  ***      0                                  0      my $wait_for_master = $self->{callbacks}->{wait_for_master};
3380  ***      0                                  0      my %wait_args       = (
3381                                                        dbh       => $self->{dbh},
3382                                                        mfile     => $self->{slave}->{mfile},
3383                                                        until_pos => $self->next_window(),
3384                                                     );
3385  ***      0                                  0      my $oktorun = 1;
3386  ***      0             0                    0      while ( ($oktorun = $self->{oktorun}->(only_if_slave_is_running => 1,
      ***                    0                        
3387                                                                                slave_is_running => $self->slave_is_running()))
3388                                                             && ($self->_too_far_ahead() || $self->_too_close_to_io()) )
3389                                                     {
3390  ***      0                                  0         $self->{stats}->{master_pos_wait}++;
3391  ***      0      0                           0         if ( $wait_for_master->(%wait_args) > 0 ) {
3392  ***      0      0                           0            if ( $self->_too_far_ahead() ) {
      ***             0                               
3393  ***      0                                  0               $self->{stats}->{too_far_ahead}++;
3394                                                           }
3395                                                           elsif ( $self->_too_close_to_io() ) {
3396  ***      0                                  0               $self->{stats}->{too_close_to_io_thread}++;
3397                                                           }
3398                                                        }
3399                                                        else {
3400  ***      0                                  0            MKDEBUG && _d('SQL thread did not advance');
3401                                                        }
3402  ***      0                                  0         $self->_get_slave_status();
3403                                                     }
3404                                                  
3405  ***      0      0                           0      if ( !$oktorun ) {
3406  ***      0                                  0         MKDEBUG && _d('Not oktorun while waiting for event',
3407                                                           $self->{stats}->{events});
3408  ***      0                                  0         return 0;
3409                                                     }
3410                                                  
3411  ***      0                                  0      MKDEBUG && _d('Event', $self->{stats}->{events}, 'is in the window');
3412  ***      0                                  0      return 1;
3413                                                  }
3414                                                  
3415                                                  sub _far_enough_ahead {
3416  ***      0                    0             0      my ( $self ) = @_;
3417  ***      0      0                           0      if ( $self->{pos} < $self->{slave}->{pos} + $self->{offset} ) {
3418  ***      0                                  0         MKDEBUG && _d($self->{pos}, 'is not',
3419                                                           $self->{offset}, 'ahead of', $self->{slave}->{pos});
3420  ***      0                                  0         $self->{stats}->{not_far_enough_ahead}++;
3421  ***      0                                  0         return 0;
3422                                                     }
3423  ***      0                                  0      return 1;
3424                                                  }
3425                                                  
3426                                                  sub _too_far_ahead {
3427  ***      0                    0             0      my ( $self ) = @_;
3428  ***      0      0                           0      my $too_far =
3429                                                        $self->{pos}
3430                                                           > $self->{slave}->{pos} + $self->{offset} + $self->{window} ? 1 : 0;
3431  ***      0                                  0      MKDEBUG && _d('pos', $self->{pos}, 'too far ahead of',
3432                                                        'slave pos', $self->{slave}->{pos}, ':', $too_far ? 'yes' : 'no');
3433  ***      0                                  0      return $too_far;
3434                                                  }
3435                                                  
3436                                                  sub _too_close_to_io {
3437  ***      0                    0             0      my ( $self ) = @_;
3438  ***      0             0                    0      my $too_close= $self->{slave}->{lag}
3439                                                        && $self->{pos}
3440                                                           >= $self->{slave}->{pos} + $self->{slave}->{lag} - $self->{'io-lag'};
3441  ***      0                                  0      MKDEBUG && _d('pos', $self->{pos},
3442                                                        'too close to I/O thread pos', $self->{slave}->{pos}, '+',
3443                                                        $self->{slave}->{lag}, ':', $too_close ? 'yes' : 'no');
3444  ***      0                                  0      return $too_close;
3445                                                  }
3446                                                  
3447                                                  sub _wait_for_master {
3448  ***      0                    0             0      my ( %args ) = @_;
3449  ***      0                                  0      my @required_args = qw(dbh mfile until_pos);
3450  ***      0                                  0      foreach my $arg ( @required_args ) {
3451  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3452                                                     }
3453  ***      0             0                    0      my $timeout = $args{timeout} || 1;
3454  ***      0                                  0      my ($dbh, $mfile, $until_pos) = @args{@required_args};
3455  ***      0                                  0      my $sql = "SELECT COALESCE(MASTER_POS_WAIT('$mfile',$until_pos,$timeout),0)";
3456  ***      0                                  0      MKDEBUG && _d('Waiting for master:', $sql);
3457  ***      0                                  0      my $start = gettimeofday();
3458  ***      0                                  0      my ($events) = $dbh->selectrow_array($sql);
3459  ***      0                                  0      MKDEBUG && _d('Waited', (gettimeofday - $start), 'and got', $events);
3460  ***      0                                  0      return $events;
3461                                                  }
3462                                                  
3463                                                  sub next_window {
3464  ***      0                    0             0      my ( $self ) = @_;
3465  ***      0                                  0      my $next_window = 
3466                                                           $self->{slave}->{mpos}                    # master pos
3467                                                           + ($self->{pos} - $self->{slave}->{pos})  # how far we're ahead
3468                                                           - $self->{offset};                        # offset;
3469  ***      0                                  0      MKDEBUG && _d('Next window, master pos:', $self->{slave}->{mpos},
3470                                                        'next window:', $next_window,
3471                                                        'bytes left:', $next_window - $self->{offset} - $self->{slave}->{mpos});
3472  ***      0                                  0      return $next_window;
3473                                                  }
3474                                                  
3475                                                  sub prepare_query {
3476  ***      0                    0             0      my ( $self, $query ) = @_;
3477  ***      0                                  0      my $qr = $self->{QueryRewriter};
3478                                                  
3479  ***      0                                  0      $query = $qr->strip_comments($query);
3480                                                  
3481  ***      0      0                           0      return unless $self->query_is_allowed($query);
3482                                                  
3483  ***      0      0                           0      if ( (my ($new_ts) = $query =~ m/SET timestamp=(\d+)/) ) {
3484  ***      0                                  0         MKDEBUG && _d('timestamp query:', $query);
3485  ***      0      0                           0         if ( $new_ts == $self->{last_ts} ) {
3486  ***      0                                  0            MKDEBUG && _d('Already saw timestamp', $new_ts);
3487  ***      0                                  0            $self->{stats}->{same_timestamp}++;
3488  ***      0                                  0            return;
3489                                                        }
3490                                                        else {
3491  ***      0                                  0            $self->{last_ts} = $new_ts;
3492                                                        }
3493                                                     }
3494                                                  
3495  ***      0                                  0      my $select = $qr->convert_to_select($query);
3496  ***      0      0                           0      if ( $select !~ m/\A\s*(?:set|select|use)/i ) {
3497  ***      0                                  0         MKDEBUG && _d('Cannot rewrite query as SELECT:',
3498                                                           (length $query > 240 ? substr($query, 0, 237) . '...' : $query));
3499  ***      0      0                           0         _d($query) if $self->{'print-nonrewritten'};
3500  ***      0                                  0         $self->{stats}->{query_not_rewritten}++;
3501  ***      0                                  0         return;
3502                                                     }
3503                                                  
3504  ***      0                                  0      my $fingerprint = $qr->fingerprint(
3505                                                        $select,
3506                                                        { prefixes => $self->{'num-prefix'} }
3507                                                     );
3508                                                  
3509  ***      0      0                           0      if ((my $avg = $self->get_avg($fingerprint)) >= $self->{'max-query-time'}) {
3510  ***      0                                  0         MKDEBUG && _d('Avg time', $avg, 'too long for', $fingerprint);
3511  ***      0                                  0         $self->{stats}->{query_too_long}++;
3512  ***      0                                  0         return $self->_wait_skip_query($avg);
3513                                                     }
3514                                                  
3515  ***      0                                  0      $select = $qr->convert_select_list($select);
3516                                                  
3517                                                  
3518  ***      0                                  0      return $select, $fingerprint;
3519                                                  }
3520                                                  
3521                                                  sub _wait_skip_query {
3522  ***      0                    0             0      my ( $self, $wait ) = @_;
3523  ***      0                                  0      my $wait_for_master = $self->{callbacks}->{wait_for_master};
3524  ***      0                                  0      my $until_pos = 
3525                                                           $self->{slave}->{mpos}                    # master pos
3526                                                           + ($self->{pos} - $self->{slave}->{pos})  # how far we're ahead
3527                                                           + 1;                                      # 1 past this query
3528  ***      0                                  0      my %wait_args       = (
3529                                                        dbh       => $self->{dbh},
3530                                                        mfile     => $self->{slave}->{mfile},
3531                                                        until_pos => $until_pos,
3532                                                        timeout   => $wait,
3533                                                     );
3534  ***      0                                  0      my $start = gettimeofday();
3535  ***      0             0                    0      while ( $self->{oktorun}->(only_if_slave_is_running => 1,
3536                                                                                slave_is_running => $self->slave_is_running())
3537                                                             && ($self->{slave}->{pos} <= $self->{pos}) ) {
3538  ***      0                                  0         $self->{stats}->{master_pos_wait}++;
3539  ***      0                                  0         $wait_for_master->(%wait_args);
3540  ***      0                                  0         $self->_get_slave_status();
3541  ***      0                                  0         MKDEBUG && _d('Bytes until slave reaches wait-skip query:',
3542                                                           $self->{pos} - $self->{slave}->{pos});
3543                                                     }
3544  ***      0                                  0      MKDEBUG && _d('Waited', (gettimeofday - $start), 'to skip query');
3545  ***      0                                  0      $self->_get_slave_status();
3546  ***      0                                  0      return;
3547                                                  }
3548                                                  
3549                                                  sub query_is_allowed {
3550  ***      0                    0             0      my ( $self, $query ) = @_;
3551  ***      0      0                           0      return unless $query;
3552  ***      0      0                           0      if ( $query =~ m/\A\s*(?:set [t@]|use|insert|update|delete|replace)/i ) {
3553  ***      0                                  0         my $reject_regexp = $self->{reject_regexp};
3554  ***      0                                  0         my $permit_regexp = $self->{permit_regexp};
3555  ***      0      0      0                    0         if ( ($reject_regexp && $query =~ m/$reject_regexp/o)
      ***                    0                        
      ***                    0                        
3556                                                             || ($permit_regexp && $query !~ m/$permit_regexp/o) )
3557                                                        {
3558  ***      0                                  0            MKDEBUG && _d('Query is not allowed, fails permit/reject regexp');
3559  ***      0                                  0            $self->{stats}->{event_filtered_out}++;
3560  ***      0                                  0            return 0;
3561                                                        }
3562  ***      0                                  0         return 1;
3563                                                     }
3564  ***      0                                  0      MKDEBUG && _d('Query is not allowed, wrong type');
3565  ***      0                                  0      $self->{stats}->{event_not_allowed}++;
3566  ***      0                                  0      return 0;
3567                                                  }
3568                                                  
3569                                                  sub exec {
3570  ***      0                    0             0      my ( $self, %args ) = @_;
3571  ***      0                                  0      my $query       = $args{query};
3572  ***      0                                  0      my $fingerprint = $args{fingerprint};
3573  ***      0                                  0      eval {
3574  ***      0                                  0         my $start = gettimeofday();
3575  ***      0                                  0         $self->{dbh}->do($query);
3576  ***      0                                  0         $self->__store_avg($fingerprint, gettimeofday() - $start);
3577                                                     };
3578  ***      0      0                           0      if ( $EVAL_ERROR ) {
3579  ***      0                                  0         $self->{stats}->{query_error}++;
3580  ***      0                                  0         $self->{query_errors}->{$fingerprint}++;
3581  ***      0      0      0                    0         if ( (($self->{errors} || 0) == 2) || MKDEBUG ) {
      ***                    0                        
3582  ***      0                                  0            _d($EVAL_ERROR);
3583  ***      0                                  0            _d('SQL was:', $query);
3584                                                        }
3585                                                     }
3586  ***      0                                  0      return;
3587                                                  }
3588                                                  
3589                                                  sub __store_avg {
3590  ***      0                    0             0      my ( $self, $fingerprint, $time ) = @_;
3591  ***      0                                  0      MKDEBUG && _d('Execution time:', $fingerprint, $time);
3592  ***      0             0                    0      my $query_stats = $self->{query_stats}->{$fingerprint} ||= {};
3593  ***      0             0                    0      my $samples     = $query_stats->{samples} ||= [];
3594  ***      0                                  0      push @$samples, $time;
3595  ***      0      0                           0      if ( @$samples > $self->{'query-sample-size'} ) {
3596  ***      0                                  0         shift @$samples;
3597                                                     }
3598  ***      0                                  0      $query_stats->{avg} = sum(@$samples) / $self->{'query-sample-size'};
3599  ***      0                                  0      $query_stats->{exec}++;
3600  ***      0                                  0      $query_stats->{sum} += $time;
3601  ***      0                                  0      MKDEBUG && _d('Average time:', $query_stats->{avg});
3602  ***      0                                  0      return;
3603                                                  }
3604                                                  
3605                                                  sub get_avg {
3606  ***      0                    0             0      my ( $self, $fingerprint ) = @_;
3607  ***      0                                  0      $self->{query_stats}->{$fingerprint}->{seen}++;
3608  ***      0             0                    0      return $self->{query_stats}->{$fingerprint}->{avg} || 0;
3609                                                  }
3610                                                  
3611                                                  sub _d {
3612  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3613  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3614  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3615                                                          @_;
3616  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3617                                                  }
3618                                                  
3619                                                  1;
3620                                                  
3621                                                  # ###########################################################################
3622                                                  # End SlavePrefetch package
3623                                                  # ###########################################################################
3624                                                  
3625                                                  # ###########################################################################
3626                                                  # This is a combination of modules and programs in one -- a runnable module.
3627                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
3628                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
3629                                                  #
3630                                                  # Check at the end of this package for the call to main() which actually runs
3631                                                  # the program.
3632                                                  # ###########################################################################
3633                                                  package mk_slave_prefetch;
3634                                                  
3635           1                    1             7   use English qw(-no_match_vars);
               1                                  3   
               1                                 10   
3636           1                    1            22   use threads;
               1                                  3   
               1                                 10   
3637           1                    1            42   use Thread::Queue;
               1                                  3   
               1                                 18   
3638           1                    1             9   use List::Util qw(max sum);
               1                                  3   
               1                                 10   
3639           1                    1            14   use sigtrap qw(handler finish untrapped normal-signals);
               1                                  4   
               1                                 43   
3640                                                  
3641           1                    1             9   use Data::Dumper;
               1                                  3   
               1                                  8   
3642                                                  $Data::Dumper::Indent    = 1;
3643                                                  $Data::Dumper::Sortkeys  = 1;
3644                                                  $Data::Dumper::Quotekeys = 0;
3645                                                  
3646  ***      1            50      1             8   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 20   
3647                                                  
3648                                                  # $oktorun must be global so finish() can access it if we catch a signal.
3649                                                  my $oktorun = 1;
3650                                                  
3651                                                  sub main {
3652  ***      0                    0             0      @ARGV = @_;  # set global ARGV for this package
3653                                                  
3654  ***      0                                  0      my $dp = new DSNParser();
3655  ***      0                                  0      my $o  = new OptionParser(
3656                                                        strict      => 0,
3657                                                        prompt      => '[OPTION...] [FILE]',
3658                                                        description => q{pipelines relay logs to pre-warm the slave's caches.},
3659                                                     );
3660  ***      0                                  0      $o->get_specs();
3661  ***      0                                  0      $o->get_opts();
3662                                                  
3663  ***      0                                  0      $dp->prop('set-vars', $o->get('set-vars'));
3664                                                  
3665  ***      0      0                           0      if ( $o->get('run-time') ) {
3666  ***      0                                  0         $o->set('run-time', max($o->get('run-time'), 1));
3667                                                     }
3668                                                  
3669  ***      0                                  0      my ($chk_int, $chk_min, $chk_max) = @{$o->get('check-interval')};
      ***      0                                  0   
3670  ***      0      0      0                    0      if ( grep { !defined $_ || $_ !~ m/^\d+$/ } ($chk_int, $chk_min, $chk_max) )
      ***      0      0      0                    0   
      ***             0      0                        
3671                                                     {
3672  ***      0                                  0         $o->save_error("You must specify three elements for --check-interval");
3673                                                     }
3674                                                     elsif ( $chk_int > $chk_max || $chk_int < $chk_min
3675                                                             || $chk_max < $chk_min || $chk_min < 0 ) {
3676  ***      0                                  0         $o->save_error("You specified an invalid range for --check-interval");
3677                                                     }
3678                                                  
3679  ***      0      0                           0      if ( @ARGV > 1 ) {
3680  ***      0                                  0         $o->save_error("You can specify only one FILE");
3681                                                     }
3682                                                  
3683  ***      0                                  0      $o->usage_or_errors();
3684                                                  
3685                                                     # ########################################################################
3686                                                     # First things first: if --stop was given, create the sentinel file.
3687                                                     # ########################################################################
3688  ***      0      0                           0      if ( $o->get('stop') ) {
3689  ***      0                                  0         my $sentinel = $o->get('sentinel');
3690  ***      0      0                           0         open my $file, ">", $sentinel
3691                                                           or die "Cannot open $sentinel: $OS_ERROR\n";
3692  ***      0      0                           0         print $file "Remove this file to permit mk-slave-prefetch to run\n"
3693                                                           or die "Cannot write to $sentinel: $OS_ERROR\n";
3694  ***      0      0                           0         close $file
3695                                                           or die "Cannot close $sentinel: $OS_ERROR\n";
3696  ***      0                                  0         print "Successfully created file $sentinel\n";
3697  ***      0                                  0         return 0;
3698                                                     }
3699                                                  
3700                                                     # ########################################################################
3701                                                     # Get the database connection and set it up as desired: Lowercase all
3702                                                     # column names for fetchrow_hashref. Don't disconnect on fork.  Disable
3703                                                     # the query cache.
3704                                                     # ########################################################################
3705  ***      0      0                           0      if ( $o->get('ask-pass') ) {
3706  ***      0                                  0         $o->set('password', OptionParser::prompt_noecho("Enter password: "));
3707                                                     }
3708  ***      0                                  0      my $dsn = $dp->parse_options($o);
3709  ***      0                                  0      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1 });
3710  ***      0                                  0      $dbh->{FetchHashKeyName} = 'NAME_lc';
3711  ***      0                                  0      $dbh->{InactiveDestroy}  = 1;
3712  ***      0                                  0      $dbh->do('/*!40001 set @@session.query_cache_type=OFF */');
3713                                                  
3714                                                     # ########################################################################
3715                                                     # Daemonize only after (potentially) asking for passwords.
3716                                                     # ########################################################################
3717  ***      0                                  0      my $daemon;
3718  ***      0      0                           0      if ( $o->get('daemonize') ) {
      ***             0                               
3719  ***      0                                  0         $daemon = new Daemon(o=>$o);
3720  ***      0                                  0         $daemon->daemonize();
3721  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
3722                                                     }
3723                                                     elsif ( $o->get('pid') ) {
3724                                                        # We're not daemoninzing, it just handles PID stuff.
3725  ***      0                                  0         $daemon = new Daemon(o=>$o);
3726  ***      0                                  0         $daemon->make_PID_file();
3727                                                     }
3728                                                  
3729                                                     # ########################################################################
3730                                                     # Ready to work now.
3731                                                     # ########################################################################
3732  ***      0                                  0      my $lp  = new BinaryLogParser();
3733  ***      0                                  0      my $qr  = new QueryRewriter();
3734  ***      0                                  0      my $vp  = new VersionParser();
3735                                                  
3736  ***      0                                  0      my ($datadir) = ($dbh->selectrow_array('SHOW VARIABLES LIKE "datadir"'))[1];
3737  ***      0                                  0      MKDEBUG && _d('Data directory', $datadir);
3738                                                  
3739                                                     # Create the prefetching threads.
3740  ***      0                                  0      my $query_queue = new Thread::Queue;
3741  ***      0             0                    0      my $n_threads   = $o->get('threads') || 1;
3742                                                  
3743                                                     # To avoid having threads close/re-open MySQL connections, we pre-create a
3744                                                     # connection for each thread.  $dbhs[0] is our connection (the script),
3745                                                     # and $dbhs[1..n_threads-1] are for the threads.  Thread IDs start at 1
3746                                                     # and are unique so they shouldn't overlap. -- Originally I wanted to
3747                                                     # enqueue the dbh with the query but dequeue(COUNT) only works with
3748                                                     # Thread::Queue v2.01+ but Perl v5.10.0 has v2.00; Perl 5.10.1 is needed
3749                                                     # which has v2.11.  So this is the more backwards-compatible solution
3750                                                     # (i.e. it should work in Perl 5.8, too).
3751  ***      0                                  0      my @dbhs = ($dbh);
3752                                                  
3753  ***      0      0                           0      if ( $o->get('secondary-indexes') ) {
3754  ***      0                                  0         for ( 0..$n_threads-1 ) {
3755                                                           # Create a connection for this thread.
3756  ***      0                                  0            my $thr_dbh = $dp->get_dbh($dp->get_cxn_params($dsn),{ AutoCommit => 1 });
3757  ***      0                                  0            $thr_dbh->{FetchHashKeyName} = 'NAME_lc';
3758  ***      0                                  0            $thr_dbh->{InactiveDestroy}  = 1;
3759  ***      0                                  0            $thr_dbh->do('/*!40001 set @@session.query_cache_type=OFF */');
3760  ***      0                                  0            push @dbhs, $thr_dbh;
3761                                                  
3762                                                           my $thr = threads::async {
3763  ***      0                    0             0               my $query;
3764  ***      0                                  0               my $tid = threads::tid();
3765  ***      0                                  0               MKDEBUG && _d('Thread', $tid, 'is alive');
3766  ***      0                                  0               while( $query = $query_queue->dequeue() ) {
3767  ***      0      0                           0                  if ( $query ) {
3768  ***      0                                  0                     eval { $dbhs[$tid]->do($query); };
      ***      0                                  0   
3769  ***      0                                  0                     MKDEBUG && $EVAL_ERROR && _d('Error executing', $query, ':',
3770                                                                       $EVAL_ERROR);
3771                                                                 };
3772                                                              }
3773  ***      0                                  0               MKDEBUG && _d('Thread', $tid, 'is done');
3774  ***      0                                  0            };
3775  ***      0                                  0            $thr->detach();
3776  ***      0                                  0            MKDEBUG && _d('Thread', $thr->tid(), 'created and detached');
3777                                                        }
3778                                                     }
3779                                                  
3780                                                     # Declare these before new SlavePrefetch so they're available to the
3781                                                     # oktorun callback arg but don't define them yet because spf->new()
3782                                                     # could be slow if it has a huge stats_file to initialize. 
3783  ***      0                                  0      my $time;
3784  ***      0                                  0      my $now;
3785  ***      0                                  0      my $end;
3786  ***      0                                  0      my %oktorun_args = (
3787                                                        sentinel => $o->get('sentinel'),
3788                                                        time     => $time,
3789                                                        end      => $end,
3790                                                        now      => \$now,
3791                                                     );
3792                                                  
3793                                                     # Declare but don't define $spf yet so we can reference it in a
3794                                                     # callback to itself that's passed in @callbacks to $spf->new().
3795  ***      0                                  0      my $spf;
3796  ***      0                                  0      my @callbacks;
3797  ***      0      0                           0      if ( $o->get('execute') ) {
3798                                                        push @callbacks, sub {
3799  ***      0                    0             0            MKDEBUG && _d('callback: execute');
3800  ***      0                                  0            return $spf->exec(@_);
3801  ***      0                                  0         };
3802                                                     }
3803  ***      0      0                           0      if ( $o->get('secondary-indexes') ) {
3804  ***      0                                  0         my $q   = new Quoter();
3805  ***      0                                  0         my $tp  = new TableParser(Quoter => $q);
3806  ***      0                                  0         my $du  = new MySQLDump(cache => 0);
3807  ***      0                                  0         my $qp  = new QueryParser();
3808                                                  
3809                                                        push @callbacks, sub {
3810  ***      0                    0             0            my ( %args ) = @_;
3811  ***      0                                  0            MKDEBUG && _d('callback: secondary indexes');
3812  ***      0                                  0            my @secondary_index_queries = get_secondary_index_queries(
3813                                                              %args,
3814                                                              dbh         => $dbh,  # script dbh for SHOW CREATE TABLE, etc.
3815                                                              MySQLDump   => $du,
3816                                                              TableParser => $tp,
3817                                                              Quoter      => $q,
3818                                                              QueryParser => $qp,
3819                                                           );
3820  ***      0                                  0            $query_queue->enqueue(@secondary_index_queries);
3821  ***      0                                  0            return;
3822  ***      0                                  0         };   
3823                                                     }
3824  ***      0      0                           0      if ( $o->get('print') ) {
3825                                                        push @callbacks, sub {
3826  ***      0                    0             0            my ( %args ) = @_;
3827  ***      0                                  0            MKDEBUG && _d('callback: print');
3828  ***      0                                  0            print $args{query}, ";\n";
3829  ***      0                                  0            return;
3830  ***      0                                  0         };
3831                                                     }
3832  ***      0                                  0      my %spf_options = map { $_ => $o->get($_) } qw(
      ***      0                                  0   
3833                                                        offset
3834                                                        window
3835                                                        io-lag
3836                                                        query-sample-size
3837                                                        errors
3838                                                        num-prefix
3839                                                        max-query-time
3840                                                        print-nonrewritten
3841                                                        reject-regexp
3842                                                        permit-regexp
3843                                                        progress
3844                                                     );
3845                                                     $spf = new SlavePrefetch(
3846                                                        dbh             => $dbh,
3847                                                        oktorun         => sub {
3848  ***      0                    0             0            my ( %args_from_spf ) = @_;
3849  ***      0                                  0            return oktorun(
3850                                                              %args_from_spf,
3851                                                              %oktorun_args,
3852                                                           );
3853                                                        },
3854  ***      0                                  0         chk_int         => $chk_int,
3855                                                        chk_min         => $chk_min,
3856                                                        chk_max         => $chk_max,
3857                                                        datadir         => $datadir,
3858                                                        QueryRewriter   => $qr,
3859                                                        have_subqueries => $vp->version_ge($dbh,'4.1.0'),
3860                                                        stats_file      => shift @ARGV,
3861                                                        %spf_options,
3862                                                     );
3863                                                  
3864  ***      0                                  0      $time = $o->get('run-time');
3865  ***      0                                  0      $now  = time();
3866  ***      0             0                    0      $end  = $now + ( $time || 0 );  # When we should exit
3867                                                  
3868  ***      0                                  0      eval {
3869  ***      0                                  0         while ( oktorun(%oktorun_args) ) {
3870  ***      0                                  0            $spf->_get_slave_status();
3871  ***      0      0                           0            if ( $spf->slave_is_running() ) {
3872  ***      0                                  0               my $fh          = $spf->open_relay_log(tmpdir => $o->get('tmpdir'));
3873  ***      0                    0             0               my $next_event  = sub { return <$fh>;    };
      ***      0                                  0   
3874  ***      0                    0             0               my $tell        = sub { return tell $fh; };
      ***      0                                  0   
3875  ***      0                                  0               my $more_events     = 1;
3876  ***      0                    0             0               my $more_events_sub = sub { $more_events = $_[0]; };
      ***      0                                  0   
3877                                                              EVENT:
3878  ***      0                                  0               while (
3879                                                                 oktorun(
3880                                                                    only_if_slave_is_running => 1,
3881                                                                    slave_is_running         => $spf->slave_is_running(),
3882                                                                    %oktorun_args) )
3883                                                              {
3884  ***      0                                  0                  my $event = $lp->parse_event(
3885                                                                    next_event => $next_event,
3886                                                                    tell       => $tell,
3887                                                                    oktorun    => $more_events_sub,
3888                                                                 );
3889  ***      0      0                           0                  if ( $event ) {
3890  ***      0                                  0                     $spf->pipeline_event($event, @callbacks);
3891                                                                 }
3892  ***      0      0                           0                  last EVENT unless $more_events;
3893                                                              }
3894                                                           }
3895                                                           else {
3896  ***      0                                  0               MKDEBUG && _d('Slave is not running');
3897                                                           }
3898                                                  
3899  ***      0      0                           0            if ( oktorun(%oktorun_args) ) {
3900  ***      0                                  0               $spf->incr_stat('sleep');
3901  ***      0                                  0               MKDEBUG && _d('Sleeping', time);
3902  ***      0                                  0               sleep 1;
3903                                                           }
3904                                                        }
3905                                                        # Reset pos, next, etc. before next run.
3906  ***      0                                  0         $spf->reset_pipeline_pos();
3907                                                     };
3908  ***      0      0                           0      if ( $EVAL_ERROR ) {
3909  ***      0                                  0         print $EVAL_ERROR;
3910                                                     }
3911                                                  
3912                                                     # Print statistics
3913  ***      0                                  0      my ($stats, $query_stats, $query_errors) = $spf->get_stats();
3914  ***      0      0                           0      if ( $o->get('statistics') ) {
3915                                                        # Print operations in order of descending count, with percentage.
3916  ***      0                                  0         my $maxlen = max(0, map { length($_) } keys %$stats);
      ***      0                                  0   
3917  ***      0             0                    0         my $total  = sum(0, ($stats->{events} || 1));
3918  ***      0                                  0         printf("# %-${maxlen}s \%10s %10s\n", qw(Action Count Pct));
3919  ***      0                                  0         my $fmt = "# %-${maxlen}s \%10d %10.2f\n";
3920  ***      0                                  0         foreach my $key (
      ***      0                                  0   
3921                                                           reverse sort { $stats->{$a} <=> $stats->{$b} } keys %$stats )
3922                                                        {
3923  ***      0                                  0            printf($fmt, $key, $stats->{$key}, $stats->{$key} / $total * 100);
3924                                                        }
3925                                                  
3926                                                        # Print normalized queries, their average exec times, times seen and
3927                                                        # times executed.  Sort in order of times seen descending.
3928  ***      0                                  0         foreach my $query (
      ***      0                                  0   
3929                                                           reverse sort {
3930                                                              $query_stats->{$a}->{seen} <=> $query_stats->{$b}->{seen}
3931                                                           } keys %$query_stats )
3932                                                        {
3933  ***      0                                  0            my $stats = $query_stats->{$query};
3934  ***      0             0                    0            print
3935                                                              "# query: ", $query, "\n# stats: ",
3936                                                              join(' ',
3937  ***      0                                  0                  (map { "$_=" . ($stats->{$_} || '0') } qw(seen exec sum avg))),
3938                                                              "\n";
3939                                                        }
3940                                                     }
3941                                                  
3942                                                     # Print normalized versions of the queries that caused errors.
3943  ***      0      0                           0      if ( $o->get('errors') == 1 ) {
3944  ***      0                                  0         foreach my $query (
      ***      0                                  0   
3945                                                           reverse sort {
3946                                                              $query_errors->{$a} <=> $query_errors->{$b} } keys %$query_errors
3947                                                        ) {
3948  ***      0                                  0            print "# error $query_errors->{$query} times: ", $query, "\n";
3949                                                        }
3950                                                     }
3951                                                  
3952  ***      0                                  0      return 0;
3953                                                  }
3954                                                  
3955                                                  # ############################################################################
3956                                                  # Subroutines
3957                                                  # ############################################################################
3958                                                  
3959                                                  # Catches signals so we can exit gracefully.
3960                                                  sub finish {
3961  ***      0                    0             0      my ( $signal ) = @_;
3962  ***      0                                  0      print STDERR "Exiting on SIG$signal.\n";
3963  ***      0                                  0      $oktorun = 0;
3964  ***      0                                  0      return;
3965                                                  }
3966                                                  
3967                                                  # It's ok to run if we haven't been told to stop, we haven't exceeded the
3968                                                  # time.  The parameter adds the further restriction that the slave must be
3969                                                  # running.
3970                                                  sub oktorun {
3971  ***      0                    0             0      my ( %args ) = @_;
3972                                                  
3973                                                     # These default vals make it oktorun.
3974  ***      0             0                    0      my $only_if_slave_running = $args{only_if_slave_is_running} || 0;
3975  ***      0             0                    0      my $slave_is_running      = $args{slave_is_running} || 0;
3976  ***      0             0                    0      my $sentinel              = $args{sentinel} || '';
3977  ***      0             0                    0      my $time                  = $args{time} || 0;
3978  ***      0             0                    0      my $end                   = $args{end} || 0;
3979  ***      0             0                    0      my $now                   = $args{now} || 0;
3980                                                  
3981                                                     # Notice the dereference: we're modifying the arg!
3982  ***      0      0      0                    0      $$now = time() if $now && ref $now;
3983                                                  
3984  ***      0             0                    0      return (!$only_if_slave_running || $slave_is_running)
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
3985                                                        && !-f $sentinel
3986                                                        && ((!$time || $now < $end) && $oktorun);
3987                                                  }
3988                                                  
3989                                                  sub get_secondary_index_queries {
3990           3                    3            82      my ( %args ) = @_;
3991           3                                 38      my @required_args = qw(dbh query
3992                                                                            MySQLDump TableParser Quoter QueryParser);
3993           3                                 22      foreach my $arg ( @required_args ) {
3994  ***     18     50                         122         die "I need a $arg argument" unless $args{$arg};
3995                                                     }
3996           3                                 26      my ($dbh, $query, $du, $tp, $q, $qp) = @args{@required_args};
3997           3                                 20      my $db = $args{db};
3998                                                  
3999  ***      3     50                          36      if ( $query !~ m/select 1 from/ ) {
4000  ***      0                                  0         MKDEBUG && _d("Query doesn't 'select 1 from'; is it a rewritten query?");
4001  ***      0                                  0         return;
4002                                                     }
4003           3                                 33      $query =~ s/select 1 from/select * from/;
4004                                                  
4005           3                                  8      MKDEBUG && _d('Getting secondary index queries for', $query);
4006                                                  
4007           3                                 41      my @tbls = $qp->get_tables($query);
4008           3                                 10      my $tbl  = $tbls[0];
4009  ***      3     50                          13      if ( !$tbl ) {
4010  ***      0                                  0         MKDEBUG && _d('Cannot parse tables from', $query);
4011  ***      0                                  0         return;
4012                                                     }
4013           3                                 24      ($db, $tbl) = $q->split_unquote($tbl);
4014           3                                  6      MKDEBUG && _d('Using table', $tbl);
4015  ***      3     50                          13      if ( !$db ) {
4016  ***      0                                  0         MKDEBUG && _d('No db for table, skipping query');
4017  ***      0                                  0         return;
4018                                                     }
4019                                                  
4020           3                                  7      my $tbl_struct;
4021           3                                 11      eval {
4022           3                                 31         $tbl_struct = $tp->parse($du->get_create_table($dbh, $q, $db, $tbl));
4023                                                     };
4024  ***      3     50     33                   35      if ( $EVAL_ERROR || !$tbl_struct ) {
4025  ***      0                                  0         MKDEBUG && _d('Failed to', $tbl, 'struct:', $EVAL_ERROR);
4026  ***      0                                  0         return;
4027                                                     }
4028                                                  
4029           3                                  7      my $rows;
4030           3                                 10      eval {
4031           3                                 66         $rows = $dbh->selectall_arrayref($query, { Slice => {} });
4032                                                     };
4033  ***      3     50                          31      if ( $EVAL_ERROR ) {
4034  ***      0                                  0         MKDEBUG && _d('Error executing prefetch query:', $EVAL_ERROR);
4035  ***      0                                  0         return;
4036                                                     }
4037  ***      3     50                         763      if ( @$rows == 0 ) {
4038  ***      0                                  0         MKDEBUG && _d("Query didn't return any rows");
4039  ***      0                                  0         return;
4040                                                     }
4041                                                  
4042           3                                 35      return make_secondary_index_queries(
4043                                                        %args,
4044                                                        rows       => $rows,
4045                                                        db_tbl     => $q->quote($db, $tbl),
4046                                                        tbl_struct => $tbl_struct,
4047                                                     );
4048                                                  }
4049                                                  
4050                                                  sub make_secondary_index_queries {
4051           3                    3            37      my ( %args ) = @_;
4052           3                                 19      my @required_args = qw(rows db_tbl tbl_struct Quoter);
4053           3                                 13      foreach my $arg ( @required_args ) {
4054  ***     12     50                          55         die "I need a $arg argument" unless $args{$arg};
4055                                                     }
4056           3                                 19      my ($rows, $db_tbl, $tbl_struct, $q) = @args{@required_args};
4057                                                  
4058  ***      3            50                   16      my $ck = $tbl_struct->{clustered_key} || '';
4059           3                                  9      my @sec_indexes = grep { $_ ne $ck } keys %{$tbl_struct->{keys}};
               9                                 34   
               3                                 18   
4060           3                                  9      MKDEBUG && _d('Secondary indexes:', join(', ', @sec_indexes)); 
4061                                                  
4062           3                                  9      my @queries;
4063           3                                 10      foreach my $sec_index ( @sec_indexes ) {
4064           6                                 16         my @selects;
4065           6                                 18         my @cols     = @{$tbl_struct->{keys}->{$sec_index}->{cols}};
               6                                 36   
4066           6                                 27         my $sel_cols = join(', ', map { $q->quote($_) } @cols);
               9                                 33   
4067           6                                 17         my %seen_clause;
4068           6                                 20         foreach my $row ( @$rows ) {
4069          24                                 60            my $all_clauses = '';
4070          36                                115            my @clauses = map {
4071          24                                 69               my $val = $row->{$_};
4072          36    100                         125               my $sep = defined $val ? '=' : ' IS ';
4073          36                                124               my $clause = $q->quote($_) . $sep . $q->quote_val($val);
4074          36                                 99               $all_clauses .= $clause;
4075          36                                129               $clause;
4076                                                           } @cols;
4077          24    100                         128            next if $seen_clause{$all_clauses}++;
4078  ***     21     50                          74            next unless scalar @clauses;
4079          21                                145            my $sql = "SELECT $sel_cols FROM $db_tbl "
4080                                                                   . "FORCE INDEX(`$sec_index`) "
4081                                                                   . "WHERE " . join(' AND ', @clauses)
4082                                                                   . " LIMIT 1";
4083          21                                 83            push @selects, $sql;
4084                                                        }
4085           6                                 38         my $union_sql = join("\nUNION ALL ", @selects);
4086           6                                 13         MKDEBUG && _d('Queries for', $sec_index, 'index:', $union_sql);
4087           6                                 31         push @queries, $union_sql; 
4088                                                     }
4089                                                  
4090           3                                 97      return @queries;
4091                                                  }
4092                                                  
4093                                                  sub _d {
4094  ***      0                    0                    my ($package, undef, $line) = caller 0;
4095  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4096  ***      0                                              map { defined $_ ? $_ : 'undef' }
4097                                                          @_;
4098  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4099                                                  }
4100                                                  
4101                                                  # ############################################################################
4102                                                  # Run the program.
4103                                                  # ############################################################################
4104                                                  if ( !caller ) { exit main(@ARGV); }
4105                                                  
4106                                                  1; # Because this is a module as well as a script.
4107                                                  
4108                                                  # ############################################################################
4109                                                  # Documentation.
4110                                                  # ############################################################################
4111                                                  
4112                                                  =pod
4113                                                  
4114                                                  =head1 NAME
4115                                                  
4116                                                  mk-slave-prefetch - Pipeline relay logs on a MySQL slave to pre-warm caches.
4117                                                  
4118                                                  =head1 SYNOPSIS
4119                                                  
4120                                                   mk-slave-prefetch
4121                                                   mk-slave-prefetch --statistics > /path/to/saved/statistics
4122                                                   mk-slave-prefetch /path/to/saved/statistics
4123                                                  
4124                                                  =head1 RISKS
4125                                                  
4126                                                  The following section is included to inform users about the potential risks,
4127                                                  whether known or unknown, of using this tool.  The two main categories of risks
4128                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
4129                                                  tools) and those created by bugs.
4130                                                  
4131                                                  mk-slave-prefetch is read-only by default, and is generally low-risk.  It does
4132                                                  execute SQL statements, but these should be SELECT only.  Despite this, it might
4133                                                  be a good idea to make it connect to MySQL with a user account that has minimal
4134                                                  privileges.  Here is an example of how to grant the necessary privileges:
4135                                                  
4136                                                     GRANT SELECT, REPLICATION CLIENT, REPLICATION SLAVE ON *.*
4137                                                        TO 'prefetch'@'%' IDENTIFIED BY 'sp33dmeup!';
4138                                                  
4139                                                  At the time of this release, we know of no bugs that could cause serious harm to
4140                                                  users.
4141                                                  
4142                                                  The authoritative source for updated information is always the online issue
4143                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
4144                                                  see a list of such issues at the following URL:
4145                                                  L<http://www.maatkit.org/bugs/mk-slave-prefetch>.
4146                                                  
4147                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
4148                                                  
4149                                                  =head1 DESCRIPTION
4150                                                  
4151                                                  mk-slave-prefetch reads the slave's relay log slightly ahead of where the
4152                                                  slave's SQL thread is reading, converts statements into C<SELECT>, and
4153                                                  executes them.  In theory, this should help alleviate the effects of the
4154                                                  slave's single-threaded SQL execution.  It will help take advantage of
4155                                                  multiple CPUs and disks by pre-reading the data from disk, so the data is
4156                                                  already in the cache when the slave SQL thread executes the un-modified
4157                                                  version of the statement.
4158                                                  
4159                                                  C<mk-slave-prefetch> learns how long it takes statements to execute, and doesn't
4160                                                  try to execute those that take a very long time.  You can ask it to print what
4161                                                  it has learned after it executes.  You can also specify a filename on the
4162                                                  command line.  The file should contain the statistics printed by a previous
4163                                                  run.  These will be used to pre-populate the statistics so it doesn't have to
4164                                                  re-learn.
4165                                                  
4166                                                  This program is based on concepts I heard Paul Tuckfield explain at the November
4167                                                  2006 MySQL Camp un-conference.  However, the code is my own work.  I have not
4168                                                  seen any other implementation of Paul's idea.
4169                                                  
4170                                                  =head1 DOES IT WORK?
4171                                                  
4172                                                  Does it work?  Does it actually speed up the slave?
4173                                                  
4174                                                  That depends on your workload, hardware, and other factors.  It might work when
4175                                                  the following are true:
4176                                                  
4177                                                  =over
4178                                                  
4179                                                  =item *
4180                                                  
4181                                                  The slave's data is much larger than memory, and the workload is mostly randomly
4182                                                  scattered small (single-row is ideal) changes.
4183                                                  
4184                                                  =item *
4185                                                  
4186                                                  There are lots of high-concurrency C<UPDATE> and C<DELETE> statements on the
4187                                                  master.
4188                                                  
4189                                                  =item *
4190                                                  
4191                                                  The slave SQL thread is I/O-bound, but the slave overall has plenty of spare I/O
4192                                                  capacity (definitely more than one disk spindle).
4193                                                  
4194                                                  =item *
4195                                                  
4196                                                  The slave uses InnoDB or another storage engine with row-level locking.
4197                                                  
4198                                                  =back
4199                                                  
4200                                                  It does B<not> speed up replication on my slaves, which mostly have large
4201                                                  queries like C<INSERT .. SELECT .. GROUP BY>.  In my benchmarks it seemed to
4202                                                  make no difference at all, positive or negative.
4203                                                  
4204                                                  On the wrong workload or slave configuration, this technique might actually make
4205                                                  the slaves slower.  Your mileage will vary.
4206                                                  
4207                                                  User-contributed benchmarks are welcome.
4208                                                  
4209                                                  =head1 OPTIONS
4210                                                  
4211                                                  Specify at least one of L<"--print">, L<"--[no]execute"> or L<"--stop">.
4212                                                  
4213                                                  =over
4214                                                  
4215                                                  =item --ask-pass
4216                                                  
4217                                                  Prompt for a password when connecting to MySQL.
4218                                                  
4219                                                  =item --charset
4220                                                  
4221                                                  short form: -A; type: string
4222                                                  
4223                                                  Default character set.  If the value is utf8, sets Perl's binmode on
4224                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
4225                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
4226                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
4227                                                  connecting to MySQL.
4228                                                  
4229                                                  =item --check-interval
4230                                                  
4231                                                  type: Array; default: 16,1,1024
4232                                                  
4233                                                  How often to check the slave: init,min,max.  This many relay log events should
4234                                                  pass before checking the output of C<SHOW SLAVE STATUS>.  The syntax is a
4235                                                  three-number range: initial, minimum, and maximum.  You should be able to leave
4236                                                  this at the defaults.
4237                                                  
4238                                                  C<mk-slave-prefetch> varies the check interval in powers of two, depending on
4239                                                  whether it decides the check was necessary.
4240                                                  
4241                                                  =item --config
4242                                                  
4243                                                  type: Array
4244                                                  
4245                                                  Read this comma-separated list of config files; if specified, this must be the
4246                                                  first option on the command line.
4247                                                  
4248                                                  =item --daemonize
4249                                                  
4250                                                  Fork to the background and detach from the shell.  POSIX
4251                                                  operating systems only.
4252                                                  
4253                                                  =item --database
4254                                                  
4255                                                  short form: -D; type: string
4256                                                  
4257                                                  The database to use for the connection.  The initial connection will be to this
4258                                                  database, but mk-slave-prefetch will issue C<USE> statements as required by the
4259                                                  binary log events.
4260                                                  
4261                                                  =item --defaults-file
4262                                                  
4263                                                  short form: -F; type: string
4264                                                  
4265                                                  Only read mysql options from the given file.  You must give an absolute
4266                                                  pathname.
4267                                                  
4268                                                  =item --errors
4269                                                  
4270                                                  cumulative: yes
4271                                                  
4272                                                  Print queries that caused errors.  If specified once, at exit; if twice, in
4273                                                  realtime.
4274                                                  
4275                                                  If you specify this option once, you will see a report at the end of the script
4276                                                  execution, showing the normalized queries and the number of times they were
4277                                                  seen.  If you specify this option twice, you will see the errors printed out as
4278                                                  they occur, but no normalized report at the end of execution.
4279                                                  
4280                                                  =item --[no]execute
4281                                                  
4282                                                  default: yes
4283                                                  
4284                                                  Execute the transformed queries to warm the caches.
4285                                                  
4286                                                  =item --help
4287                                                  
4288                                                  Show help and exit.
4289                                                  
4290                                                  =item --host
4291                                                  
4292                                                  short form: -h; type: string
4293                                                  
4294                                                  Connect to host.
4295                                                  
4296                                                  =item --io-lag
4297                                                  
4298                                                  type: size; default: 1k
4299                                                  
4300                                                  How many bytes to lag the slave I/O thread.  This helps avoid C<mysqlbinlog>
4301                                                  reading right off the end of the relay log file.
4302                                                  
4303                                                  =item --log
4304                                                  
4305                                                  type: string
4306                                                  
4307                                                  Print all output to this file when daemonized.
4308                                                  
4309                                                  =item --max-query-time
4310                                                  
4311                                                  type: float; default: 1
4312                                                  
4313                                                  Do not run queries longer than this many seconds; fractions allowed.  If
4314                                                  C<mk-slave-prefetch> predicts the query will take longer to execute, it will
4315                                                  skip the query.  This is based on the theory that pre-warming the cache is most
4316                                                  beneficial for short queries.
4317                                                  
4318                                                  C<mk-slave-prefetch> learns how long queries require to execute.  It keeps an
4319                                                  average over the last L<"--query-sample-size"> samples of each query.  The
4320                                                  averages are based on an abstracted version of the query, with specific
4321                                                  parameters replaced by placeholders.  The result is a sort of "fingerprint"
4322                                                  for the query, not executable SQL.  You can see the learned statistics with the
4323                                                  L<"--statistics"> option.
4324                                                  
4325                                                  You can pre-load query fingerprints, and average execution times, from a file.
4326                                                  This way you don't have to wait for C<mk-slave-prefetch> to learn all over
4327                                                  every time you start it.  Just specify the file on the command line.  The
4328                                                  format should be the same as the output from L<"--statistics">.
4329                                                  
4330                                                  You might also want to filter out some statements completely, or let only some
4331                                                  statements through.  See the L<"--reject-regexp"> and L<"--permit-regexp">
4332                                                  options.
4333                                                  
4334                                                  If C<mk-slave-prefetch> hasn't seen a query's fingerprint before, and thus
4335                                                  doesn't know how long it will take to execute, it wraps it in a subuery, like
4336                                                  this:
4337                                                  
4338                                                     SELECT 1 FROM ( <query> ) AS X LIMIT 1;
4339                                                  
4340                                                  This helps avoid fetching a lot of data back to the client when a query is
4341                                                  very large.  It requires a version of MySQL that supports subqueries (version
4342                                                  4.1 and newer).  If yours doesn't, the subquery trick can't be used, so the
4343                                                  query might fetch a lot of data back to the client.
4344                                                  
4345                                                  Once a query's fingerprint has been seen, so it's known that the query isn't
4346                                                  enormously slow, C<mk-slave-prefetch> just rewrites the C<SELECT> list for
4347                                                  efficiency.  (Avoiding the subquery reduces the query's overhead for short
4348                                                  queries).  The rewritten query will then look like the following;
4349                                                  
4350                                                     SELECT ISNULL(COALESCE(<columns>)) FROM ...
4351                                                  
4352                                                  =item --num-prefix
4353                                                  
4354                                                  Abstract away numeric table name prefixes.  This causes the following two
4355                                                  queries to "fingeprint" to the same thing:
4356                                                  
4357                                                    select from 1_2_users;
4358                                                    select from 2_3_users;
4359                                                  
4360                                                  =item --offset
4361                                                  
4362                                                  type: size; default: 128
4363                                                  
4364                                                  How many bytes C<mk-slave-prefetch> will try to stay in front of the slave SQL
4365                                                  thread.  It will not execute log events it doesn't think are at least this far
4366                                                  ahead of the SQL thread.  See also L<"--window">.
4367                                                  
4368                                                  =item --password
4369                                                  
4370                                                  short form: -p; type: string
4371                                                  
4372                                                  Password to use when connecting.
4373                                                  
4374                                                  =item --permit-regexp
4375                                                  
4376                                                  type: string
4377                                                  
4378                                                  Permit queries matching this Perl regexp.  This is a filter for log events.  The
4379                                                  regular expression is matched against the raw log event, before any
4380                                                  transformations are applied.  If specified, this option will permit only log
4381                                                  events matching the regular expression.
4382                                                  
4383                                                  =item --pid
4384                                                  
4385                                                  type: string
4386                                                  
4387                                                  Create the given PID file when daemonized.  The file contains the process
4388                                                  ID of the daemonized instance.  The PID file is removed when the
4389                                                  daemonized instance exits.  The program checks for the existence of the
4390                                                  PID file when starting; if it exists and the process with the matching PID
4391                                                  exists, the program exits.
4392                                                  
4393                                                  =item --port
4394                                                  
4395                                                  short form: -P; type: int
4396                                                  
4397                                                  Port number to use for connection.
4398                                                  
4399                                                  =item --print
4400                                                  
4401                                                  Print the transformed relay log events to standard output.
4402                                                  
4403                                                  =item --print-nonrewritten
4404                                                  
4405                                                  Print queries that could not be transformed into C<SELECT>.
4406                                                  
4407                                                  =item --progress
4408                                                  
4409                                                  type: int
4410                                                  
4411                                                  Print progress information every X events.  The information is the current log
4412                                                  file and position, plus a summary of the statistics gathered.
4413                                                  
4414                                                  =item --query-sample-size
4415                                                  
4416                                                  type: int; default: 4
4417                                                  
4418                                                  Average query exec time over this many queries.  The last C<N> queries with a
4419                                                  given fingerprint are averaged together to get the average query execution time
4420                                                  (see L<"--max-query-time">).  
4421                                                  
4422                                                  =item --reject-regexp
4423                                                  
4424                                                  type: string
4425                                                  
4426                                                  Reject queries matching this Perl regexp.  Similar to L<"--permit-regexp">, but
4427                                                  has the opposite effect: log events must B<not> match the regular expression.
4428                                                  
4429                                                  =item --run-time
4430                                                  
4431                                                  type: time
4432                                                  
4433                                                  How long C<mk-slave-prefetch> should run before exiting.  The default is to run forever.
4434                                                  
4435                                                  =item --secondary-indexes
4436                                                  
4437                                                  Prefetch secondary indexes for pipelined queries.
4438                                                  
4439                                                  =item --sentinel
4440                                                  
4441                                                  type: string; default: /tmp/mk-slave-prefetch-sentinel
4442                                                  
4443                                                  Exit if this file exists.
4444                                                  
4445                                                  =item --set-vars
4446                                                  
4447                                                  type: string; default: wait_timeout=10000
4448                                                  
4449                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
4450                                                  string will be appended to SET and executed.
4451                                                  
4452                                                  =item --socket
4453                                                  
4454                                                  short form: -S; type: string
4455                                                  
4456                                                  Socket file to use for connection.
4457                                                  
4458                                                  =item --statistics
4459                                                  
4460                                                  Print execution statistics after exiting.  The statistics are in two sections:
4461                                                  counters, and queries.  The counters simply count the number of times events
4462                                                  occur.  You may see the following counters:
4463                                                  
4464                                                     NAME                    MEANING
4465                                                     ======================  =======================================
4466                                                     mysqlbinlog             Executed mysqlbinlog to read log events.
4467                                                     events                  The total number of relay log events.
4468                                                     not_far_enough_ahead    An event was not at least L<"--offset">
4469                                                                             bytes ahead of the SQL thread.
4470                                                     too_far_ahead           An event was more than L<"--offset">
4471                                                                             + L<"--window"> bytes ahead of the SQL thread.
4472                                                     too_close_to_io_thread  An event was less than L<"--io-lag"> bytes
4473                                                                             away from the I/O thread's position.
4474                                                     event_not_allowed       An event wasn't a SET, USE, INSERT,
4475                                                                             UPDATE, DELETE or REPLACE query.
4476                                                     event_filtered_out      An event was filtered out because of
4477                                                                             L<"--permit-regexp"> or L<"--reject-regexp">.
4478                                                     same_timestamp          A SET TIMESTAMP event was ignored because
4479                                                                             it had the same timestamp as the last one.
4480                                                     do_query                A transformed event was executed
4481                                                                             or printed.
4482                                                     query_error             An executed query had an error.
4483                                                     query_too_long          An event was not executed because its
4484                                                                             average query length exceeded
4485                                                                             L<"--max-query-time">.
4486                                                     query_not_rewritten     A query could not be rewritten to a
4487                                                                             SELECT.
4488                                                     master_pos_wait         The tool waited for the SQL thread to
4489                                                                             catch up.
4490                                                     show_slave_status       The tool queried SHOW SLAVE STATUS.
4491                                                     load_data_infile        The tool found a LOAD DATA INFILE query
4492                                                                             and unlinked (deleted) the temp file.
4493                                                     could_not_unlink        The tool failed to unlink a temp file.
4494                                                     sleep                   The tool slept for a second because the 
4495                                                                             slave's SQL thread was not running, or
4496                                                                             because it read past the end of the log.
4497                                                  
4498                                                  After the counters, C<mk-slave-prefetch> prints information about each query
4499                                                  fingerprint it has seen, two lines per fingerprint.  The first line contains
4500                                                  the query's fingerprint.  The second line contains the number of times the
4501                                                  fingerprint was seen, number of times executed, the sum of the execution
4502                                                  times, and the average execution time over the last L<"--query-sample-size">
4503                                                  samples.
4504                                                  
4505                                                  =item --stop
4506                                                  
4507                                                  Stop running instances by creating the L<"--sentinel"> file.
4508                                                  
4509                                                  =item --threads
4510                                                  
4511                                                  type: int; default: 2
4512                                                  
4513                                                  Number of concurrent threads to use for pipelining queries.
4514                                                  
4515                                                  =item --tmpdir
4516                                                  
4517                                                  type: string; default: /dev/null
4518                                                  
4519                                                  Where to create temp files for C<LOAD DATA INFILE> queries.  The default will
4520                                                  cause C<mysqlbinlog> to skip the file and the associated C<LOAD DATA INFILE>
4521                                                  command entirely.
4522                                                  
4523                                                  If C<mk-slave-prefetch> sees a C<LOAD DATA INFILE> command (which it won't if
4524                                                  this is left at the default), it will try to remove the temporary file, then
4525                                                  skip the event.
4526                                                  
4527                                                  =item --user
4528                                                  
4529                                                  short form: -u; type: string
4530                                                  
4531                                                  User for login if not current user.
4532                                                  
4533                                                  =item --version
4534                                                  
4535                                                  Show version and exit.
4536                                                  
4537                                                  =item --window
4538                                                  
4539                                                  type: size; default: 4k
4540                                                  
4541                                                  The max bytes ahead of the slave C<mk-slave-prefetch> should get.  Defines the
4542                                                  window within which C<mk-slave-prefetch> considers a query OK to execute.  The
4543                                                  window begins at the slave SQL thread's last known position plus L<"--offset">
4544                                                  bytes, and extends for the specified number of bytes.
4545                                                  
4546                                                  If C<mk-slave-prefetch> sees a log event that is too far in the future, it will
4547                                                  increment the C<too_far_ahead> counter and wait for the slave SQL thread to
4548                                                  catch up (which increments the C<master_pos_wait> counter).  If an event isn't
4549                                                  far enough ahead of the SQL thread, it will be discarded and the
4550                                                  C<not_far_enough_ahead> counter increments.
4551                                                  
4552                                                  Watching the mentioned statistics can help you understand how to tune the
4553                                                  window.  You want C<mk-slave-prefetch> to run just ahead of the SQL thread, not
4554                                                  throwing out a lot of events for being too far ahead or not far enough ahead.
4555                                                  
4556                                                  =back
4557                                                  
4558                                                  =head1 DOWNLOADING
4559                                                  
4560                                                  You can download Maatkit from Google Code at
4561                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
4562                                                  easily with a command like the following:
4563                                                  
4564                                                     wget http://www.maatkit.org/get/toolname
4565                                                     or
4566                                                     wget http://www.maatkit.org/trunk/toolname
4567                                                  
4568                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
4569                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
4570                                                  needed.  The first URL gets the latest released version of the tool, and the
4571                                                  second gets the latest trunk code from Subversion.
4572                                                  
4573                                                  =head1 ENVIRONMENT
4574                                                  
4575                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
4576                                                  the Maatkit tools:
4577                                                  
4578                                                     MKDEBUG=1 mk-....
4579                                                  
4580                                                  =head1 SYSTEM REQUIREMENTS
4581                                                  
4582                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
4583                                                  installed in any reasonably new version of Perl.
4584                                                  
4585                                                  =head1 BUGS
4586                                                  
4587                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-slave-prefetch>.
4588                                                  
4589                                                  Please use Google Code Issues and Groups to report bugs or request support:
4590                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
4591                                                  discuss Maatkit.
4592                                                  
4593                                                  Please include the complete command-line used to reproduce the problem you are
4594                                                  seeing, the version of all MySQL servers involved, the complete output of the
4595                                                  tool when run with L<"--version">, and if possible, debugging output produced by
4596                                                  running with the C<MKDEBUG=1> environment variable.
4597                                                  
4598                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
4599                                                  
4600                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
4601                                                  Feedback and improvements are welcome.
4602                                                  
4603                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
4604                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
4605                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
4606                                                  
4607                                                  This program is free software; you can redistribute it and/or modify it under
4608                                                  the terms of the GNU General Public License as published by the Free Software
4609                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
4610                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
4611                                                  licenses.
4612                                                  
4613                                                  You should have received a copy of the GNU General Public License along with
4614                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
4615                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
4616                                                  
4617                                                  =head1 AUTHOR
4618                                                  
4619                                                  Baron Schwartz, Daniel Nichter
4620                                                  
4621                                                  =head1 ABOUT MAATKIT
4622                                                  
4623                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
4624                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
4625                                                  code contributors.  Both are employed by Percona.  Financial support for
4626                                                  Maatkit development is primarily provided by Percona and its clients. 
4627                                                  
4628                                                  =head1 VERSION
4629                                                  
4630                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
4631                                                  
4632                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
60    ***      0      0      0   unless $args{$arg}
66    ***      0      0      0   exists $args{'strict'} ? :
109   ***      0      0      0   unless open my $fh, '<', $file
129   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
134   ***      0      0      0   if $para =~ /^=over/
142   ***      0      0      0   unless $para
145   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
152   ***      0      0      0   if ($para =~ /: /) { }
156   ***      0      0      0   unless $attributes{$attrib}
160   ***      0      0      0   if ($attribs{'short form'})
176   ***      0      0      0   if $para =~ /^=item/
178   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
183   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
195   ***      0      0      0   unless $para
198   ***      0      0      0   if ($para =~ /^=head1/)
202   ***      0      0      0   if $para =~ /^=item --/
206   ***      0      0      0   unless @specs
217   ***      0      0      0   if (ref $opt) { }
222   ***      0      0      0   if (not $long)
227   ***      0      0      0   if exists $$self{'opts'}{$long}
230   ***      0      0      0   if (length $long == 1)
235   ***      0      0      0   if ($short) { }
236   ***      0      0      0   if exists $$self{'short_opts'}{$short}
245   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
246   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
247   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
259   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
264   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
266   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
267   ***      0      0      0   defined $def ? :
271   ***      0      0      0   if ($long eq 'config')
275   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
288   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
293   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
298   ***      0      0      0   if ($opt =~ /default to/)
303   ***      0      0      0   if ($opt =~ /restricted to option groups/)
313   ***      0      0      0   unless $rule_ok
330   ***      0      0      0   unless exists $$self{'opts'}{$long}
354   ***      0      0      0   unless exists $$self{'opts'}{$long}
374   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
379   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
394   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
403   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
407   ***      0      0      0   if ($self->has('config'))
413   ***      0      0      0   if ($EVAL_ERROR)
414   ***      0      0      0   $self->got('config') ? :
429   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
432   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
433   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
439   ***      0      0      0   if (@ARGV and $$self{'strict'})
445   ***      0      0      0   if (@set > 1)
456   ***      0      0      0   if (@set == 0)
466   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
467   ***      0      0      0   if (exists $$self{'disables'}{$long})
474   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
486   ***      0      0      0   if $restricted_opt eq $long
487   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
492   ***      0      0      0   if (@restricted_opts)
494   ***      0      0      0   if (@restricted_opts == 1) { }
523   ***      0      0      0   unless $opt and $$opt{'type'}
526   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
529   ***      0      0      0   if (not $suffix)
535   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
536   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
551   ***      0      0      0   if ($from_key)
562   ***      0      0      0   if (defined $num) { }
563   ***      0      0      0   if ($factor)
590   ***      0      0      0   length $opt == 1 ? :
591   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
598   ***      0      0      0   length $opt == 1 ? :
599   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
606   ***      0      0      0   length $opt == 1 ? :
607   ***      0      0      0   defined $long ? :
612   ***      0      0      0   length $opt == 1 ? :
613   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
647   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
648   ***      0      0      0   unless print $self->print_usage
652   ***      0      0      0   unless print $self->print_errors
661   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
670   ***      0      0      0   unless $$self{'got_opts'}
673   ***      0      0      0   $$_{'is_negatable'} ? :
677   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
693   ***      0      0      0   $group eq 'default' ? :
699   ***      0      0      0   $$opt{'is_negatable'} ? :
702   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
711   ***      0      0      0   if ($short) { }
720   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
724   ***      0      0      0   if ($$self{'dp'})
732   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
744   ***      0      0      0   if ref $_[0] eq 'OptionParser'
747   ***      0      0      0   unless print $prompt
755   ***      0      0      0   unless print "\n"
758   ***      0      0      0   if ($EVAL_ERROR)
780   ***      0      0      0   unless open my $fh, '<', $filename
788   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
791   ***      0      0      0   if ($line eq '--')
796   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
814   ***      0      0      0   unless open my $fh, '<', $file
818   ***      0      0      0   unless $para =~ /^=pod$/m
822   ***      0      0      0   unless $para =~ /$regex/
827   ***      0      0      0   unless close $fh
841   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
856   ***      0      0      0   defined $_ ? :
894   ***      0      0      0   if (not $$self{$dbh})
898   ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
905   ***      0      0      0   defined $_ ? :
991   ***     50      0      6   if (@_ > 2)
1000  ***     50      0      2   if (not $dsn)
1012  ***     50      8      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1024  ***     50      0     16   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1030         100      8      8   if (not defined $final_props{$key})
1037  ***     50      0      8   unless exists $opts{$key}
1040  ***     50      0      2   if (my $required = $self->prop('required'))
1042  ***      0      0      0   unless $final_props{$key}
1051  ***      0      0      0   unless ref $o eq 'OptionParser'
1054  ***      0      0      0   if $o->has($_)
1064  ***      0      0      0   unless ref $dsn
1065  ***      0      0      0   $_ eq 'p' ? :
1066  ***      0      0      0   if defined $$dsn{$_}
1079  ***      0      0      0   $opts{$key}{'copy'} ? :
1093  ***     50      0      2   if ($driver eq 'Pg') { }
1125  ***     50      0      2   $cxn_string =~ /charset=utf8/ ? :
1134  ***     50      0      2   if (not $have_dbi)
1153  ***     50      2      0   if ($cxn_string =~ /mysql/i)
1161  ***     50      0      2   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1166  ***      0      0      0   if ($charset eq 'utf8') { }
1167  ***      0      0      0   unless binmode STDOUT, ':utf8'
1171  ***      0      0      0   unless binmode STDOUT
1175  ***     50      0      2   if ($self->prop('set-vars'))
1182  ***     50      0      2   if (not $dbh and $EVAL_ERROR)
1184  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1197  ***      0      0      0   if (not $tries)
1219  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1236  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1246  ***      0      0      0   unless $dsn_1
1247  ***      0      0      0   unless $dsn_2
1251  ***      0      0      0   if ($args{'overwrite'}) { }
1252  ***      0      0      0   defined $$dsn_1{$key} ? :
1255  ***      0      0      0   defined $$dsn_2{$key} ? :
1264  ***      0      0      0   defined $_ ? :
1309  ***      0      0      0   unless $args{$arg}
1333  ***      0      0      0   if $delim
1336  ***      0      0      0   if ($line =~ m[^/\*.+\*/;])
1341  ***      0      0      0   if ($line =~ /^DELIMITER/m)
1343  ***      0      0      0   if ($del) { }
1356  ***      0      0      0   if $line =~ /End of log file/
1358  ***      0      0      0   if (not $got_offset and my($offset) = $line =~ /$binlog_line_1/m) { }
      ***      0      0      0   elsif (not $got_hdr and $line =~ /^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/) { }
      ***      0      0      0   elsif ($line =~ /^(?:#|use |SET)/i) { }
1374  ***      0      0      0   if (my($db) = $line =~ /^use ([^;]+)/) { }
      ***      0      0      0   elsif (my($setting) = $line =~ /^SET\s+([^;]*)/) { }
1388  ***      0      0      0   if ($got_offset and $got_hdr) { }
1389  ***      0      0      0   if ($type eq 'Xid') { }
      ***      0      0      0   elsif ($type eq 'Query') { }
      ***      0      0      0   elsif ($type eq 'Start:') { }
1411  ***      0      0      0   $pos == length $stmt ? :
1414  ***      0      0      0   if $delim
1416  ***      0      0      0   if ($arg =~ /^DELIMITER/m)
1418  ***      0      0      0   if ($del) { }
1441  ***      0      0      0   if ($found_arg) { }
1451  ***      0      0      0   if $args{'oktorun'}
1457  ***      0      0      0   defined $_ ? :
1508  ***      0      0      0   unless $query
1511  ***      0      0      0   if ($query =~ /$vlc_rf/i)
1528  ***      0      0      0   unless $query =~ /IN\s*\(\s*(?!select)/i
1554  ***      0      0      0   unless @vals > 20
1566  ***      0      0      0   if $query =~ m[\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `]
1568  ***      0      0      0   if $query =~ m[/\*\w+\.\w+:[0-9]/[0-9]\*/]
1570  ***      0      0      0   if $query =~ /\A# administrator command: /
1572  ***      0      0      0   if $query =~ /\A\s*(call\s+\S+)\(/i
1574  ***      0      0      0   if (my($beginning) = $query =~ /\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is)
1580  ***      0      0      0   if $query =~ s/\Ause \S+\Z/use ?/i
1608  ***      0      0      0   if $query =~ /\A\s*call\s+(\S+)\(/i
1610  ***      0      0      0   if ($query =~ /\A# administrator command:/)
1615  ***      0      0      0   if $query =~ /\A\s*use\s+/
1617  ***      0      0      0   if $query =~ /\A\s*UNLOCK TABLES/i
1619  ***      0      0      0   if $query =~ /\A\s*xa\s+(\S+)/i
1624  ***      0      0      0   if ($query =~ /\A\s*SHOW\s+/i)
1627  ***      0      0      0   unless scalar @what
1630  ***      0      0      0   if ($what[0] =~ /CREATE/ or $what[1] and $what[1] =~ /STATUS/ or $what[0] =~ /MASTER/) { }
1636  ***      0      0      0   $what[0] =~ /GLOBAL/ ? :
1644  ***      0      0      0   if ($dds)
1646  ***      0      0      0   if $obj
1651  ***      0      0      0   $obj ? :
1668  ***      0      0      0   unless $qp
1676  ***      0      0      0   if $table
1689  ***      0      0      0   if ($args{'generic'}) { }
1691  ***      0      0      0   unless $cmd
1692  ***      0      0      0   $arg ? :
1700  ***      0      0      0   if ($args{'trf'})
1709  ***      0      0      0   unless $query
1728  ***      0      0      0   unless $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
1742  ***      0      0      0   $1 =~ /\*/ ? :
1751  ***      0      0      0   if ($join =~ /\bjoin\b/)
1765  ***      0      0      0   if (@cols == @vals) { }
1776  ***      0      0      0   $where ? :
      ***      0      0      0   $limit ? :
1783  ***      0      0      0   unless $query
1784  ***      0      0      0   $query =~ /\A\s*select/i ? :
1791  ***      0      0      0   defined $_ ? :
1820  ***      0      0      0   unless $args{$arg}
1823  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1839  ***      0      0      0   unless defined(my $pid = fork)
1840  ***      0      0      0   if ($pid)
1847  ***      0      0      0   unless POSIX::setsid()
1848  ***      0      0      0   unless chdir '/'
1854  ***      0      0      0   if (-t STDIN)
1856  ***      0      0      0   unless open STDIN, '/dev/null'
1860  ***      0      0      0   if ($$self{'log_file'}) { }
1862  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1866  ***      0      0      0   unless open STDERR, '>&STDOUT'
1870  ***      0      0      0   if (-t STDOUT)
1872  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1875  ***      0      0      0   if (-t STDERR)
1877  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1888  ***      0      0      0   $self ? :
1890  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1893  ***      0      0      0   if $EVAL_ERROR
1895  ***      0      0      0   if ($pid) { }
1897  ***      0      0      0   if ($pid_is_alive) { }
1919  ***      0      0      0   if (exists $$self{'child'})
1931  ***      0      0      0   if (not $PID_file)
1938  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1940  ***      0      0      0   unless print $PID_FH $PID
1942  ***      0      0      0   unless close $PID_FH
1951  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1952  ***      0      0      0   unless unlink $$self{'PID_file'}
1964  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1970  ***      0      0      0   defined $_ ? :
2020  ***     50      0      1   unless defined $args{'cache'}
2028  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2030  ***      0      0      0   unless $ddl
2031  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2045  ***      0      0      0   if ($trgs and @$trgs) { }
2048  ***      0      0      0   if ($$trg{'sql_mode'})
2052  ***      0      0      0   if ($$trg{'definer'})
2084         100      1      5   if (not $new)
2091         100      4      1   if ($curr and $new and $curr eq $new)
2103  ***     50      3      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2116  ***     50      0      3   if ($EVAL_ERROR)
2126  ***     50      3      0   if ($key) { }
2142  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2172  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2185  ***      0      0      0   if ($sth->rows)
2198  ***      0      0      0   if ($tbl)
2206  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2209  ***      0      0      0   if ($like)
2217  ***      0      0      0   unless $like
2225  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2228  ***      0      0      0   if ($like)
2243  ***      0      0      0   unless $like
2251  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2254  ***      0      0      0   if ($like)
2262  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2269  ***      0      0      0   unless $like
2277  ***      0      0      0   defined $_ ? :
2309  ***     50      0      1   unless $args{$arg}
2318  ***     50      0      3   unless $ddl
2319  ***     50      3      0   if (ref $ddl eq 'ARRAY')
2320  ***     50      3      0   if (lc $$ddl[0] eq 'table') { }
2330  ***     50      0      3   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
2336  ***     50      3      0   if $name
2354  ***     50      0      9   unless $type
2356  ***     50      9      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
2360         100      6      3   if (not $def =~ /NOT NULL/)
2364  ***     50      0      9   $def =~ /AUTO_INCREMENT/i ? :
2395  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
2409  ***      0      0      0   if ($index)
2412  ***      0      0      0   if (not $best)
2413  ***      0      0      0   if ($index) { }
2426  ***      0      0      0   unless $where
2432  ***      0      0      0   if ($$expl{'possible_keys'}) { }
2436  ***      0      0      0   if ($$expl{'key'})
2456  ***      0      0      0   unless $args{$arg}
2470  ***      0      0      0   if ($EVAL_ERROR)
2474  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
2480  ***      0      0      0   unless $args{'all_privs'}
2487  ***      0      0      0   if ($EVAL_ERROR)
2491  ***      0      0      0   if (not scalar keys %$row)
2502  ***      0      0      0   $EVAL_ERROR ? :
2507  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
2533  ***     50      0      9   if $key =~ /FOREIGN/
2538  ***     50      9      0   if (not $engine =~ /MEMORY|HEAP/)
2545  ***     50      0      9   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
2552         100      3      6   $key =~ /PRIMARY|UNIQUE/ ? :
2576         100      3      6   if ($engine =~ /InnoDB/i and not $clustered_key)
2578  ***     50      3      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
2602  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
2631  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
2645  ***      0      0      0   if (@sec_indexes)
2662  ***      0      0      0   defined $_ ? :
2708  ***     50      0      3   unless $query
2712  ***     50      0      3   if ($ddl_stmt)
2715  ***      0      0      0   if ($query =~ /$ddl_stmt DATABASE\b/i)
2719  ***      0      0      0   if ($ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i)
2731  ***     50      0      3   if ($query =~ /^\s*LOCK TABLES/i)
2749  ***     50      0      3   if (not $tbl =~ /[a-zA-Z]/)
2769  ***      0      0      0   unless $query
2785  ***      0      0      0   unless $tbl_refs and $from
2806  ***      0      0      0   if ($tbl_ref =~ /^AS\s+\w+/i)
2814  ***      0      0      0   if $db
2821  ***      0      0      0   unless $query
2830  ***      0      0      0   if (@split_statements == 1) { }
2837  ***      0      0      0   if ($statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i)
2849  ***      0      0      0   unless $query
2859  ***      0      0      0   unless $query
2870  ***      0      0      0   if ($word =~ /^\(?SELECT\b/i) { }
2872  ***      0      0      0   if ($start_pos) { }
2890  ***      0      0      0   unless $sqno
2893  ***      0      0      0   if ($$sq{'done'})
2902  ***      0      0      0   if ($$sq{'lp'} + $lp - ($$sq{'rp'} + $rp) == 0)
2913  ***      0      0      0   unless $sq
2928  ***      0      0      0   if ($type =~ /^SELECT\b/) { }
      ***      0      0      0   elsif ($type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/) { }
2944  ***      0      0      0   defined $_ ? :
2984         100     12     24   unless defined $val
2985  ***     50      0     24   if $val eq ''
2987  ***     50     24      0   if (not defined $is_numeric)
2988         100      3     21   $val =~ /^0|\D/ ? :
2991         100     21      3   if $is_numeric
3001         100      3      3   if (not $tbl)
3010  ***      0      0      0   unless $like
3044  ***      0      0      0   unless $args{$arg}
3082  ***      0      0      0   if $args{'stats_file'}
3091  ***      0      0      0   unless exists $$self{'callbacks'}{$func}
3101  ***      0      0      0   unless open my $fh, '<', $file
3106  ***      0      0      0   unless $type
3107  ***      0      0      0   if ($type eq 'query') { }
3113  ***      0      0      0   if ($seen)
3120  ***      0      0      0   unless close $fh
3137  ***      0      0      0   if $args{'all'} or $args{'stats'}
3138  ***      0      0      0   if $args{'all'} or $args{'query_stats'}
3139  ***      0      0      0   if $args{'all'} or $args{'query_errors'}
3148  ***      0      0      0   unless $args{$arg}
3156  ***      0      0      0   if (not -r "$datadir/$file")
3165  ***      0      0      0   unless open my $fh, "$cmd |"
3166  ***      0      0      0   if ($CHILD_ERROR)
3181  ***      0      0      0   if (my($line) = $procs =~ /^(.*?\d\s+$cmd)$/m) { }
3184  ***      0      0      0   if (my($proc) = $line =~ /(\d+)/)
3192  ***      0      0      0   if (not close $fh)
3193  ***      0      0      0   if ($OS_ERROR) { }
3206  ***      0      0      0   $$self{'pos'} > $$self{'slave'}{'pos'} && $$self{'stats'}{'events'} - $$self{'last_chk'} >= $$self{'chk_int'} ? :
3213  ***      0      0      0   if ($$self{'pos'} <= $$self{'slave'}{'pos'}) { }
3228  ***      0      0      0   if (not $status or not %$status)
3231  ***      0      0      0   $$status{'master_log_file'} eq $$status{'relay_master_log_file'} ? :
3270  ***      0      0      0   unless defined $pos and $pos >= 0
3271  ***      0      0      0   unless defined $pos and $pos >= 0
3292  ***      0      0      0   if (not $$event{'offset'})
3298  ***      0      0      0   if $$event{'offset'}
3301  ***      0      0      0   if ($$self{'progress'} and $$self{'stats'}{'events'} % $$self{'progress'} == 0)
3308  ***      0      0      0   if ($self->_check_slave_status)
3316  ***      0      0      0   unless $self->_in_window
3318  ***      0      0      0   if ($$event{'arg'})
3319  ***      0      0      0   if (my($file) = $$event{'arg'} =~ /INFILE ('[^']+')/i)
3321  ***      0      0      0   if (not unlink $file)
3329  ***      0      0      0   if (not $query)
3335  ***      0      0      0   if ($db and !$$self{'last_db'} || $$self{'last_db'} ne $db)
3340  ***      0      0      0   unless $$self{'last_db'}
3362  ***      0      0      0   unless $offset
3363  ***      0      0      0   unless $window
3377  ***      0      0      0   unless $self->_far_enough_ahead
3391  ***      0      0      0   if (&$wait_for_master(%wait_args) > 0) { }
3392  ***      0      0      0   if ($self->_too_far_ahead) { }
      ***      0      0      0   elsif ($self->_too_close_to_io) { }
3405  ***      0      0      0   if (not $oktorun)
3417  ***      0      0      0   if ($$self{'pos'} < $$self{'slave'}{'pos'} + $$self{'offset'})
3428  ***      0      0      0   $$self{'pos'} > $$self{'slave'}{'pos'} + $$self{'offset'} + $$self{'window'} ? :
3451  ***      0      0      0   unless $args{$arg}
3481  ***      0      0      0   unless $self->query_is_allowed($query)
3483  ***      0      0      0   if (my($new_ts) = $query =~ /SET timestamp=(\d+)/)
3485  ***      0      0      0   if ($new_ts == $$self{'last_ts'}) { }
3496  ***      0      0      0   if (not $select =~ /\A\s*(?:set|select|use)/i)
3499  ***      0      0      0   if $$self{'print-nonrewritten'}
3509  ***      0      0      0   if ((my $avg = $self->get_avg($fingerprint)) >= $$self{'max-query-time'})
3551  ***      0      0      0   unless $query
3552  ***      0      0      0   if ($query =~ /\A\s*(?:set [t\@]|use|insert|update|delete|replace)/i)
3555  ***      0      0      0   if ($reject_regexp and $query =~ /$reject_regexp/o or $permit_regexp and not $query =~ /$permit_regexp/o)
3578  ***      0      0      0   if ($EVAL_ERROR)
3581  ***      0      0      0   if (($$self{'errors'} || 0) == 2 or 0)
3595  ***      0      0      0   if (@$samples > $$self{'query-sample-size'})
3613  ***      0      0      0   defined $_ ? :
3665  ***      0      0      0   if ($o->get('run-time'))
3670  ***      0      0      0   unless not defined $_
      ***      0      0      0   if (grep {not $_ =~ /^\d+$/ unless not defined $_;} $chk_int, $chk_min, $chk_max) { }
      ***      0      0      0   elsif ($chk_int > $chk_max or $chk_int < $chk_min or $chk_max < $chk_min or $chk_min < 0) { }
3679  ***      0      0      0   if (@ARGV > 1)
3688  ***      0      0      0   if ($o->get('stop'))
3690  ***      0      0      0   unless open my $file, '>', $sentinel
3692  ***      0      0      0   unless print $file "Remove this file to permit mk-slave-prefetch to run\n"
3694  ***      0      0      0   unless close $file
3705  ***      0      0      0   if ($o->get('ask-pass'))
3718  ***      0      0      0   if ($o->get('daemonize')) { }
      ***      0      0      0   elsif ($o->get('pid')) { }
3753  ***      0      0      0   if ($o->get('secondary-indexes'))
3767  ***      0      0      0   if ($query)
3797  ***      0      0      0   if ($o->get('execute'))
3803  ***      0      0      0   if ($o->get('secondary-indexes'))
3824  ***      0      0      0   if ($o->get('print'))
3871  ***      0      0      0   if ($spf->slave_is_running) { }
3889  ***      0      0      0   if ($event)
3892  ***      0      0      0   unless $more_events
3899  ***      0      0      0   if (oktorun(%oktorun_args))
3908  ***      0      0      0   if ($EVAL_ERROR)
3914  ***      0      0      0   if ($o->get('statistics'))
3943  ***      0      0      0   if ($o->get('errors') == 1)
3982  ***      0      0      0   if $now and ref $now
3994  ***     50      0     18   unless $args{$arg}
3999  ***     50      0      3   if (not $query =~ /select 1 from/)
4009  ***     50      0      3   if (not $tbl)
4015  ***     50      0      3   if (not $db)
4024  ***     50      0      3   if ($EVAL_ERROR or not $tbl_struct)
4033  ***     50      0      3   if ($EVAL_ERROR)
4037  ***     50      0      3   if (@$rows == 0)
4054  ***     50      0     12   unless $args{$arg}
4072         100     24     12   defined $val ? :
4077         100      3     21   if $seen_clause{$all_clauses}++
4078  ***     50      0     21   unless scalar @clauses
4095  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
259   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
264   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
403   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
432   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
439   ***      0      0      0      0   @ARGV and $$self{'strict'}
523   ***      0      0      0      0   $opt and $$opt{'type'}
526   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
591   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
599   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
613   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
702   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
796   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1024  ***     66      8      8      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     16      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1146  ***     66      2      0      2   not $dbh and $tries--
1182  ***     33      2      0      0   not $dbh and $EVAL_ERROR
1358  ***      0      0      0      0   not $got_offset and my($offset) = $line =~ /$binlog_line_1/m
      ***      0      0      0      0   not $got_hdr and $line =~ /^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/
1388  ***      0      0      0      0   $got_offset and $got_hdr
1532  ***      0      0      0      0   $length > 0 and $query_length > $length
      ***      0      0      0      0   $length > 0 and $query_length > $length and $query_length < ($last_length || $query_length + 1)
1630  ***      0      0      0      0   $what[1] and $what[1] =~ /STATUS/
1890  ***      0      0      0      0   $PID_file and -f $PID_file
1951  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2045  ***      0      0      0      0   $trgs and @$trgs
2091  ***     66      1      0      4   $curr and $new
      ***     66      1      0      4   $curr and $new and $curr eq $new
2507  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
2545  ***     33      9      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33      9      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
2576  ***     66      0      6      3   $engine =~ /InnoDB/i and not $clustered_key
2578  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
2602  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
2719  ***      0      0      0      0   $ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i
2785  ***      0      0      0      0   $tbl_refs and $from
2837  ***      0      0      0      0   $statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i
3206  ***      0      0      0      0   $$self{'pos'} > $$self{'slave'}{'pos'} && $$self{'stats'}{'events'} - $$self{'last_chk'} >= $$self{'chk_int'}
3270  ***      0      0      0      0   defined $pos and $pos >= 0
3271  ***      0      0      0      0   defined $pos and $pos >= 0
3301  ***      0      0      0      0   $$self{'progress'} and $$self{'stats'}{'events'} % $$self{'progress'} == 0
3335  ***      0      0      0      0   $db and !$$self{'last_db'} || $$self{'last_db'} ne $db
3386  ***      0      0      0      0   $oktorun = $$self{'oktorun'}('only_if_slave_is_running', 1, 'slave_is_running', $self->slave_is_running) and $self->_too_far_ahead || $self->_too_close_to_io
3438  ***      0      0      0      0   $$self{'slave'}{'lag'} && $$self{'pos'} >= $$self{'slave'}{'pos'} + $$self{'slave'}{'lag'} - $$self{'io-lag'}
3535  ***      0      0      0      0   $$self{'oktorun'}('only_if_slave_is_running', 1, 'slave_is_running', $self->slave_is_running) and $$self{'slave'}{'pos'} <= $$self{'pos'}
3555  ***      0      0      0      0   $reject_regexp and $query =~ /$reject_regexp/o
      ***      0      0      0      0   $permit_regexp and not $query =~ /$permit_regexp/o
3982  ***      0      0      0      0   $now and ref $now
3984  ***      0      0      0      0   (!$only_if_slave_running || $slave_is_running) && !-f($sentinel)
      ***      0      0      0      0   (!$time || $now < $end) && $oktorun
      ***      0      0      0      0   (!$only_if_slave_running || $slave_is_running) && !-f($sentinel) && ((!$time || $now < $end) && $oktorun)

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
44    ***     50      0      1   $ENV{'MKDEBUG'} || 0
64    ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
66    ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
108   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch'
249   ***      0      0      0   $$opt{'group'} ||= 'default'
531   ***      0      0      0   $s || 's'
540   ***      0      0      0   $prefix || ''
568   ***      0      0      0   $pre || ''
575   ***      0      0      0   $val || ''
578   ***      0      0      0   $val || ''
636   ***      0      0      0   $$self{'description'} || ''
704   ***      0      0      0   $s ||= 's'
730   ***      0      0      0   $$opt{'type'} || ''
878   ***     50      0      1   $ENV{'MKDEBUG'} || 0
934   ***     50      0      1   $ENV{'MKDEBUG'} || 0
1005  ***     50      0      2   $prev ||= {}
1006  ***     50      0      2   $defaults ||= {}
1079  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1092  ***     50      0      2   $self->prop('dbidriver') || ''
1096  ***      0      0      0   $$info{'D'} || ''
1102  ***     50      0      2   $$info{'D'} || ''
1124  ***     50      2      0   $opts ||= {}
1219  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1235  ***      0      0      0   $level ||= 0
1236  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1290  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1479  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1815  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1992  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2262  ***      0      0      0   $$_[1] || ''
2302  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2521  ***     50      6      0   $engine || undef
2544  ***     50      0      9   $type || $special || 'BTREE'
2631  ***      0      0      0   $$tbl_struct{'engine'} || ''
2633  ***      0      0      0   $clustered_key ||= ''
2683  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2899  ***      0      0      0   $word =~ tr/(// || 0
2900  ***      0      0      0   $word =~ tr/)// || 0
2966  ***     50      0      1   $ENV{'MKDEBUG'} || 0
3037  ***     50      0      1   $ENV{'MKDEBUG'} || 0
3046  ***      0      0      0   $args{'offset'} ||= 128
3047  ***      0      0      0   $args{'window'} ||= 4096
3048  ***      0      0      0   $args{'io-lag'} ||= 1024
3049  ***      0      0      0   $args{'query-sample-size'} ||= 4
3050  ***      0      0      0   $args{'max-query-time'} ||= 1
3154  ***      0      0      0   $args{'mysqlbinlog'} || 'mysqlbinlog'
3231  ***      0      0      0   $$status{'slave_sql_running'} || ''
3274  ***      0      0      0   $ts || 0
3299  ***      0      0      0   $$event{'end_log_pos'} || 0
3453  ***      0      0      0   $args{'timeout'} || 1
3581  ***      0      0      0   $$self{'errors'} || 0
      ***      0      0      0   ($$self{'errors'} || 0) == 2 or 0
3592  ***      0      0      0   $$self{'query_stats'}{$fingerprint} ||= {}
3593  ***      0      0      0   $$query_stats{'samples'} ||= []
3608  ***      0      0      0   $$self{'query_stats'}{$fingerprint}{'avg'} || 0
3646  ***     50      0      1   $ENV{'MKDEBUG'} || 0
3741  ***      0      0      0   $o->get('threads') || 1
3866  ***      0      0      0   $time || 0
3917  ***      0      0      0   $$stats{'events'} || 1
3934  ***      0      0      0   $$stats{$_} || '0'
3974  ***      0      0      0   $args{'only_if_slave_is_running'} || 0
3975  ***      0      0      0   $args{'slave_is_running'} || 0
3976  ***      0      0      0   $args{'sentinel'} || ''
3977  ***      0      0      0   $args{'time'} || 0
3978  ***      0      0      0   $args{'end'} || 0
3979  ***      0      0      0   $args{'now'} || 0
4058  ***     50      3      0   $$tbl_struct{'clustered_key'} || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
63    ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
64    ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
526   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1115  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1116  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1117  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1118  ***      0      0      0      0   $$dsn{'u'} ||= $user
1119  ***      0      0      0      0   $$dsn{'D'} ||= $db
1532  ***      0      0      0      0   $last_length || $query_length + 1
1630  ***      0      0      0      0   $what[0] =~ /CREATE/ or $what[1] and $what[1] =~ /STATUS/
      ***      0      0      0      0   $what[0] =~ /CREATE/ or $what[1] and $what[1] =~ /STATUS/ or $what[0] =~ /MASTER/
1667  ***      0      0      0      0   $args{'QueryParser'} || $$self{'QueryParser'}
1728  ***      0      0      0      0   $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
1964  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2103  ***     33      3      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2142  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2172  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2206  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2225  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2239  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2251  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2395  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
2474  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
2495  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
2544  ***     33      0      0      9   $type || $special
2813  ***      0      0      0      0   $alias or $tbl
2928  ***      0      0      0      0   $type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/
3137  ***      0      0      0      0   $args{'all'} or $args{'stats'}
3138  ***      0      0      0      0   $args{'all'} or $args{'query_stats'}
3139  ***      0      0      0      0   $args{'all'} or $args{'query_errors'}
3151  ***      0      0      0      0   $args{'datadir'} || $$self{'datadir'}
3152  ***      0      0      0      0   $args{'start_pos'} || $$self{'slave'}{'pos'}
3153  ***      0      0      0      0   $args{'file'} || $$self{'slave'}{'file'}
3228  ***      0      0      0      0   not $status or not %$status
3335  ***      0      0      0      0   !$$self{'last_db'} || $$self{'last_db'} ne $db
3386  ***      0      0      0      0   $self->_too_far_ahead || $self->_too_close_to_io
3555  ***      0      0      0      0   $reject_regexp and $query =~ /$reject_regexp/o or $permit_regexp and not $query =~ /$permit_regexp/o
3670  ***      0      0      0      0   $chk_int > $chk_max or $chk_int < $chk_min
      ***      0      0      0      0   $chk_int > $chk_max or $chk_int < $chk_min or $chk_max < $chk_min
      ***      0      0      0      0   $chk_int > $chk_max or $chk_int < $chk_min or $chk_max < $chk_min or $chk_min < 0
3984  ***      0      0      0      0   !$only_if_slave_running || $slave_is_running
      ***      0      0      0      0   !$time || $now < $end
4024  ***     33      0      0      3   $EVAL_ERROR or not $tbl_struct


Covered Subroutines
-------------------

Subroutine                   Count Location                                                         
---------------------------- ----- -----------------------------------------------------------------
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1281
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1282
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1283
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1285
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1290
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1472
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1473
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1477
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1479
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1809
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1810
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1812
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1813
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1815
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1987
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1988
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1990
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1992
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:22  
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2294
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2295
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2296
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2297
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:23  
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2302
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2679
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2680
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2681
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2683
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:29  
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2959
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2960
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2964
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2966
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3026
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3027
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3028
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3030
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3031
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3032
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3037
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3635
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3636
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3637
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3638
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3639
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3641
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3646
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:37  
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:38  
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:40  
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:41  
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:42  
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:44  
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:873 
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:874 
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:876 
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:878 
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:922 
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:923 
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:924 
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:925 
BEGIN                            1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:934 
_use_db                          6 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2083
get_create_table                 3 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2102
get_cxn_params                   2 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1089
get_dbh                          2 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1123
get_engine                       6 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2518
get_keys                         3 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2525
get_secondary_index_queries      3 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3990
get_tables                       3 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2707
make_secondary_index_queries     3 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:4051
new                              1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2019
new                              1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2306
new                              1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2702
new                              1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2969
new                              1 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:937 
parse                            3 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2317
parse                            2 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:999 
prop                             6 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:990 
quote                           52 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2974
quote_val                       36 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2982
split_unquote                    6 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2998

Uncovered Subroutines
---------------------

Subroutine                   Count Location                                                         
---------------------------- ----- -----------------------------------------------------------------
DESTROY                          0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1963
__ANON__                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3066
__ANON__                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3070
__ANON__                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3763
__ANON__                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3799
__ANON__                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3810
__ANON__                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3826
__ANON__                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3848
__ANON__                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3873
__ANON__                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3874
__ANON__                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3876
__ANON__                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:427 
__delete_to_select               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1750
__insert_to_select               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1758
__shorten                        0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1552
__store_avg                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3590
__update_to_select               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1775
_check_slave_status              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3204
_d                               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1263
_d                               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1456
_d                               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1790
_d                               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1969
_d                               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2276
_d                               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2661
_d                               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2943
_d                               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3612
_d                               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:4094
_d                               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:855 
_d                               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:904 
_distill_tables                  0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1666
_distill_verbs                   0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1606
_far_enough_ahead                0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3416
_get_next_chk_int                0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3212
_get_participants                0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:327 
_get_slave_status                0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3222
_in_window                       0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3371
_make_PID_file                   0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1928
_parse_specs                     0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:213 
_pod_to_specs                    0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:107 
_read_config_file                0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:779 
_remove_PID_file                 0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1950
_set_option                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:373 
_too_close_to_io                 0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3437
_too_far_ahead                   0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3427
_validate_type                   0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:522 
_wait_for_master                 0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3448
_wait_skip_query                 0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3522
as_string                        0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1063
check_PID_file                   0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1887
check_table                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2453
clean_query                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2848
clone                            0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:832 
close_relay_log                  0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3176
convert_select_list              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1741
convert_to_select                0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1708
copy                             0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1245
daemonize                        0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1836
descr                            0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:635 
disconnect                       0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1228
distill                          0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1687
dump                             0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2026
errors                           0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:625 
exec                             0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3570
fill_in_dsn                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1111
find_best_index                  0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2407
find_possible_keys               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2425
fingerprint                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1564
finish                           0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3961
get                              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:589 
get_aliases                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2768
get_avg                          0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3606
get_columns                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2140
get_databases                    0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2205
get_defaults                     0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:363 
get_defaults_files               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:102 
get_fks                          0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2592
get_groups                       0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:368 
get_hostname                     0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1218
get_interval                     0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3259
get_opts                         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:390 
get_pipeline_pos                 0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3264
get_slave_status                 0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3249
get_specs                        0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:95  
get_stats                        0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3131
get_table_list                   0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2250
get_table_status                 0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2224
get_tmp_table                    0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2160
get_triggers                     0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2171
get_window                       0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3356
got                              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:597 
has                              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:605 
has_derived_table                0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2761
incr_stat                        0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3125
init_stats                       0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3100
literal_like                     0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3009
main                             0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3652
make_PID_file                    0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1918
new                              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1293
new                              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1501
new                              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1818
new                              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3040
new                              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:58  
new                              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:881 
next_window                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3464
oktorun                          0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3971
open_relay_log                   0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3145
opts                             0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:339 
parse                            0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:886 
parse_event                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1306
parse_options                    0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1050
pipeline_event                   0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3289
prepare_query                    0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3476
print_active_handles             0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1234
print_errors                     0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:659 
print_usage                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:669 
prompt                           0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:630 
prompt_noecho                    0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:744 
query_is_allowed                 0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3550
query_type                       0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2925
read_para_after                  0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:813 
remove_auto_increment            0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2621
remove_secondary_indexes         0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2627
reset_pipeline_pos               0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3280
reset_stats                      0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3136
save_error                       0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:620 
set                              0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:611 
set_callbacks                    0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3089
set_defaults                     0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:351 
set_pipeline_pos                 0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3269
set_window                       0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3361
short_opts                       0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:345 
shorten                          0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1518
slave_is_running                 0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:3254
sort_indexes                     0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2388
split                            0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2820
split_subquery                   0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:2858
strip_comments                   0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1507
usage                            0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1072
usage_or_errors                  0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:646 
version_ge                       0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:893 
wrap_in_derived                  0 /home/daniel/dev/maatkit/mk-slave-prefetch/mk-slave-prefetch:1782


mk-slave-prefetch.t

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     BEGIN {
4     ***      1     50     33      1            32      die "The MAATKIT_TRUNK environment variable is not set.  See http://code.google.com/p/maatkit/wiki/Testing"
5                                                           unless $ENV{MAATKIT_TRUNK} && -d $ENV{MAATKIT_TRUNK};
6              1                                  7      unshift @INC, "$ENV{MAATKIT_TRUNK}/common";
7                                                     };
8                                                     
9              1                    1            11   use strict;
               1                                  2   
               1                                  6   
10             1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
11             1                    1            11   use English qw(-no_match_vars);
               1                                  3   
               1                                  7   
12             1                    1            10   use Test::More;
               1                                  3   
               1                                 10   
13                                                    
14             1                    1            13   use MaatkitTest;
               1                                  3   
               1                                 12   
15             1                    1            12   use Sandbox;
               1                                  2   
               1                                 13   
16             1                                 21   require "$trunk/mk-slave-prefetch/mk-slave-prefetch";
17                                                    
18             1                                 17   my $dp = new DSNParser();
19             1                                 16   my $sb = new Sandbox(basedir => '/tmp', DSNParser => $dp);
20             1                                104   my $master_dbh = $sb->get_dbh_for('master');
21             1                                 32   my $slave_dbh  = $sb->get_dbh_for('slave1');
22                                                    
23    ***      1     50                          29   if ( !$master_dbh ) {
      ***            50                               
24    ***      0                                  0      plan skip_all => 'Cannot connect to sandbox master';
25                                                    }
26                                                    elsif ( !$slave_dbh ) {
27    ***      0                                  0      plan skip_all => 'Cannot connect to sandbox slave';
28                                                    }
29                                                    else {
30             1                                 12      plan tests => 11;
31                                                    }
32                                                    
33             1                                730   my $q  = new Quoter();
34             1                                 14   my $du = new MySQLDump(cache => 0);
35             1                                 13   my $tp = new TableParser(Quoter => $q);
36             1                                 14   my $qp = new QueryParser();
37             1                                 10   my %common_modules = (
38                                                       MySQLDump   => $du,
39                                                       TableParser => $tp,
40                                                       QueryParser => $qp,
41                                                       Quoter      => $q,
42                                                    );
43                                                    
44             1                             175355   my $output = `$trunk/mk-slave-prefetch/mk-slave-prefetch --help`;
45             1                                 52   like($output, qr/Prompt for a password/, 'It compiles');
46                                                    
47                                                    # ###########################################################################
48                                                    # Test making queries for secondary indexes.
49                                                    # ###########################################################################
50             1                                601   $sb->load_file('slave1', 'mk-slave-prefetch/t/samples/secondary_indexes.sql');
51                                                    
52             1                             315251   my @queries = mk_slave_prefetch::get_secondary_index_queries(
53                                                       dbh         => $slave_dbh,
54                                                       db          => 'test2',
55                                                       query       => 'select 1 from test2.t order by a',
56                                                       %common_modules,
57                                                    );
58             1                                 20   is_deeply(
59                                                       \@queries,
60                                                       [
61                                                          "SELECT `c` FROM `test2`.`t` FORCE INDEX(`c`) WHERE `c`=3 LIMIT 1
62                                                    UNION ALL SELECT `c` FROM `test2`.`t` FORCE INDEX(`c`) WHERE `c`=2 LIMIT 1
63                                                    UNION ALL SELECT `c` FROM `test2`.`t` FORCE INDEX(`c`) WHERE `c`=5 LIMIT 1
64                                                    UNION ALL SELECT `c` FROM `test2`.`t` FORCE INDEX(`c`) WHERE `c`='0' LIMIT 1
65                                                    UNION ALL SELECT `c` FROM `test2`.`t` FORCE INDEX(`c`) WHERE `c` IS NULL LIMIT 1
66                                                    UNION ALL SELECT `c` FROM `test2`.`t` FORCE INDEX(`c`) WHERE `c`=7 LIMIT 1",
67                                                    
68                                                    
69                                                          "SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b`=2 AND `c`=3 LIMIT 1
70                                                    UNION ALL SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b`=2 AND `c`=2 LIMIT 1
71                                                    UNION ALL SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b`=4 AND `c`=5 LIMIT 1
72                                                    UNION ALL SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b`='0' AND `c`='0' LIMIT 1
73                                                    UNION ALL SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b`=1 AND `c`=2 LIMIT 1
74                                                    UNION ALL SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b`=6 AND `c` IS NULL LIMIT 1
75                                                    UNION ALL SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b` IS NULL AND `c`=7 LIMIT 1
76                                                    UNION ALL SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b` IS NULL AND `c` IS NULL LIMIT 1",
77                                                       ],
78                                                       'Secondary index queries for multi-row prefetch query'
79                                                    );
80                                                    
81             1                                 15   @queries = mk_slave_prefetch::get_secondary_index_queries(
82                                                       dbh         => $slave_dbh,
83                                                       db          => 'test2',
84                                                       query       => 'select 1 from test2.t where a=1 and b=2',
85                                                       %common_modules,
86                                                    );
87             1                                 11   is_deeply(
88                                                       \@queries,
89                                                       [
90                                                          "SELECT `c` FROM `test2`.`t` FORCE INDEX(`c`) WHERE `c`=3 LIMIT 1",
91                                                    
92                                                          "SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b`=2 AND `c`=3 LIMIT 1",
93                                                       ],
94                                                       'Secondary index queries for single-row prefetch query'
95                                                    );
96                                                    
97             1                                 11   @queries = mk_slave_prefetch::get_secondary_index_queries(
98                                                       dbh         => $slave_dbh,
99                                                       db          => 'test2',
100                                                      query       => 'select 1 from `test2`.`t` where a>5',
101                                                      %common_modules,
102                                                   );
103            1                                 10   is_deeply(
104                                                      \@queries,
105                                                      [
106                                                         "SELECT `c` FROM `test2`.`t` FORCE INDEX(`c`) WHERE `c` IS NULL LIMIT 1
107                                                   UNION ALL SELECT `c` FROM `test2`.`t` FORCE INDEX(`c`) WHERE `c`=7 LIMIT 1",
108                                                   
109                                                         "SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b`=6 AND `c` IS NULL LIMIT 1
110                                                   UNION ALL SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b` IS NULL AND `c`=7 LIMIT 1
111                                                   UNION ALL SELECT `b`, `c` FROM `test2`.`t` FORCE INDEX(`b`) WHERE `b` IS NULL AND `c` IS NULL LIMIT 1",
112                                                      ],
113                                                      'Secondary index queries with NULL row values'
114                                                   );
115                                                   
116                                                   # ###########################################################################
117                                                   # Check daemonization.
118                                                   # ###########################################################################
119            1                                 11   my $cmd = "$trunk/mk-slave-prefetch/mk-slave-prefetch -F /tmp/12346/my.sandbox.cnf --daemonize --pid /tmp/mk-slave-prefetch.pid --print";
120            1                             154015   diag(`$cmd 1>/dev/null 2>/dev/null`);
121            1                              87549   $output = `ps -eaf | grep 'mk-slave-prefetch \-F' | grep -v grep`;
122            1                                151   like($output, qr/$cmd/, 'It lives daemonized');
123            1                                 56   ok(-f '/tmp/mk-slave-prefetch.pid', 'PID file created');
124                                                   
125            1                                 29   my ($pid) = $output =~ /\s+(\d+)\s+/;
126            1                               6566   $output = `cat /tmp/mk-slave-prefetch.pid`;
127            1                                 62   is($output, $pid, 'PID file has correct PID');
128                                                   
129                                                   # Kill it by testing --stop.
130            1                             193661   $output = `$trunk/mk-slave-prefetch/mk-slave-prefetch --stop`;
131            1                                 58   like(
132                                                      $output,
133                                                      qr{created file /tmp/mk-slave-prefetch-sentinel},
134                                                      'Create sentinel file'
135                                                   );
136                                                   
137            1                             1000250   sleep 1;
138            1                              39002   $output = `ps -eaf | grep 'mk-slave-prefetch \-F' | grep -v grep`;
139            1                                 66   is($output, '', 'Stops for sentinel');
140            1                                 32   ok(! -f '/tmp/mk-slave-prefetch.pid', 'PID file removed');
141                                                   
142            1                               6788   `rm -f /tmp/mk-slave-prefetch-sentinel`;
143                                                   
144                                                   # #########################################################################
145                                                   # Issue 391: Add --pid option to all scripts
146                                                   # #########################################################################
147            1                               6982   `touch /tmp/mk-script.pid`;
148            1                             227760   $output = `$trunk/mk-slave-prefetch/mk-slave-prefetch -F /tmp/12346/my.sandbox.cnf --print --pid /tmp/mk-script.pid 2>&1`;
149            1                                 61   like(
150                                                      $output,
151                                                      qr{PID file /tmp/mk-script.pid already exists},
152                                                      'Dies if PID file already exists (--pid without --daemonize) (issue 391)'
153                                                   );
154            1                               3974   `rm -rf /tmp/mk-script.pid`;
155                                                   
156                                                   
157                                                   # #############################################################################
158                                                   # Done.
159                                                   # #############################################################################
160            1                                  8   exit;


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
4     ***     50      0      1   unless $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}
23    ***     50      0      1   if (not $master_dbh) { }
      ***     50      0      1   elsif (not $slave_dbh) { }


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
4     ***     33      0      0      1   $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}


Covered Subroutines
-------------------

Subroutine Count Location              
---------- ----- ----------------------
BEGIN          1 mk-slave-prefetch.t:10
BEGIN          1 mk-slave-prefetch.t:11
BEGIN          1 mk-slave-prefetch.t:12
BEGIN          1 mk-slave-prefetch.t:14
BEGIN          1 mk-slave-prefetch.t:15
BEGIN          1 mk-slave-prefetch.t:4 
BEGIN          1 mk-slave-prefetch.t:9 


