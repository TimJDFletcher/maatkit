---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...lel-dump/mk-parallel-dump   58.2   39.3   36.7   66.2    n/a  100.0   51.0
Total                          58.2   39.3   36.7   66.2    n/a  100.0   51.0
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:22 2010
Finish:       Thu Jan 28 22:24:22 2010

Run:          ./001_chunk_tables.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:24 2010
Finish:       Thu Jan 28 22:24:24 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:26:04 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:40 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:35 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:22 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:53 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:18 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:59 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:44 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:33 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:32 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:40 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:57 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:55 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:37 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:59 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:32 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:26:06 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:46 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:59 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:49 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:51 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:55 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:35 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:52 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:28 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:49 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:46 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:20 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:12 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:28 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:09 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:02 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:38 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:15 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:25 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:30 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:57 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:19 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:27 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:30 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:04 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:37 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:53 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:07 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:42 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:36 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:43 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:47 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:51 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:50 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:24 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:26:02 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:26:06 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:52 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:14 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:30 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:30 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:23 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:02 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:26:02 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:55 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:04 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:47 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:28 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:40 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:50 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:55 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:59 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:33 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:07 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:34 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:26:04 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:17 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:42 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:26:26 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:12 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:44 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:45 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:24:37 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:45 2010

Run:          ./101_dump_sakila.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:27 2010
Finish:       Thu Jan 28 22:25:09 2010

Run:          ./102_filters.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:29 2010
Finish:       Thu Jan 28 22:26:31 2010

Run:          ./103_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:34 2010
Finish:       Thu Jan 28 22:26:35 2010

Run:          ./104_gzip.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:38 2010
Finish:       Thu Jan 28 22:26:38 2010

Run:          ./104_gzip.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:38 2010
Finish:       Thu Jan 28 22:26:40 2010

Run:          ./104_gzip.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:38 2010
Finish:       Thu Jan 28 22:26:46 2010

Run:          ./104_gzip.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:38 2010
Finish:       Thu Jan 28 22:26:38 2010

Run:          ./104_gzip.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:38 2010
Finish:       Thu Jan 28 22:26:44 2010

Run:          ./104_gzip.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:38 2010
Finish:       Thu Jan 28 22:26:43 2010

Run:          ./104_gzip.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:38 2010
Finish:       Thu Jan 28 22:26:42 2010

Run:          ./105_resume.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:50 2010
Finish:       Thu Jan 28 22:26:51 2010

Run:          ./106_progress.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:54 2010
Finish:       Thu Jan 28 22:26:55 2010

Run:          ./107_locking.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:26:59 2010
Finish:       Thu Jan 28 22:26:59 2010

Run:          ./201_issue_223.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:02 2010
Finish:       Thu Jan 28 22:27:03 2010

Run:          ./202_issue_275.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:06 2010
Finish:       Thu Jan 28 22:27:06 2010

Run:          ./203_issue_170.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:10 2010
Finish:       Thu Jan 28 22:27:10 2010

Run:          ./204_issue_534.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:13 2010
Finish:       Thu Jan 28 22:27:13 2010

Run:          ./205_issue_446.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:16 2010
Finish:       Thu Jan 28 22:27:17 2010

Run:          ./207_issue_15.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:20 2010
Finish:       Thu Jan 28 22:27:20 2010

Run:          ./208_issue_642.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:24 2010
Finish:       Thu Jan 28 22:27:24 2010

Run:          ./209_issue_31.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:27 2010
Finish:       Thu Jan 28 22:27:28 2010

/home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program dumps MySQL tables in parallel.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22           102                  102           844   use strict;
             102                                218   
             102                                712   
23           102                  102           625   use warnings FATAL => 'all';
             102                                217   
             102                                792   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5530 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # DSNParser package 5266
31                                                    # ###########################################################################
32                                                    package DSNParser;
33                                                    
34           102                  102           704   use strict;
             102                                224   
             102                                495   
35           102                  102           611   use warnings FATAL => 'all';
             102                                221   
             102                                575   
36           102                  102           696   use English qw(-no_match_vars);
             102                                208   
             102                                630   
37           102                  102           631   use Data::Dumper;
             102                                301   
             102                                810   
38                                                    $Data::Dumper::Indent    = 0;
39                                                    $Data::Dumper::Quotekeys = 0;
40                                                    
41                                                    eval {
42                                                       require DBI;
43                                                    };
44                                                    my $have_dbi = $EVAL_ERROR ? 0 : 1;
45                                                    
46    ***    102            50    102           628   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
             102                                219   
             102                               1543   
47                                                    
48                                                    sub new {
49           528                  528          7529      my ( $class, @opts ) = @_;
50           528                              50010      my $self = {
51                                                          opts => {
52                                                             A => {
53                                                                desc => 'Default character set',
54                                                                dsn  => 'charset',
55                                                                copy => 1,
56                                                             },
57                                                             D => {
58                                                                desc => 'Database to use',
59                                                                dsn  => 'database',
60                                                                copy => 1,
61                                                             },
62                                                             F => {
63                                                                desc => 'Only read default options from the given file',
64                                                                dsn  => 'mysql_read_default_file',
65                                                                copy => 1,
66                                                             },
67                                                             h => {
68                                                                desc => 'Connect to host',
69                                                                dsn  => 'host',
70                                                                copy => 1,
71                                                             },
72                                                             p => {
73                                                                desc => 'Password to use when connecting',
74                                                                dsn  => 'password',
75                                                                copy => 1,
76                                                             },
77                                                             P => {
78                                                                desc => 'Port number to use for connection',
79                                                                dsn  => 'port',
80                                                                copy => 1,
81                                                             },
82                                                             S => {
83                                                                desc => 'Socket file to use for connection',
84                                                                dsn  => 'mysql_socket',
85                                                                copy => 1,
86                                                             },
87                                                             u => {
88                                                                desc => 'User for login if not current user',
89                                                                dsn  => 'user',
90                                                                copy => 1,
91                                                             },
92                                                          },
93                                                       };
94           528                               5996      foreach my $opt ( @opts ) {
95    ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
96    ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
97                                                       }
98           528                               5842      return bless $self, $class;
99                                                    }
100                                                   
101                                                   sub prop {
102         2784                 2784         19465      my ( $self, $prop, $value ) = @_;
103         2784    100                       17961      if ( @_ > 2 ) {
104          428                               1346         MKDEBUG && _d('Setting', $prop, 'property');
105          428                               2508         $self->{$prop} = $value;
106                                                      }
107         2784                              24665      return $self->{$prop};
108                                                   }
109                                                   
110                                                   sub parse {
111          614                  614         14883      my ( $self, $dsn, $prev, $defaults ) = @_;
112   ***    614     50                        6487      if ( !$dsn ) {
113   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
114   ***      0                                  0         return;
115                                                      }
116          614                               3063      MKDEBUG && _d('Parsing', $dsn);
117   ***    614            50                 9586      $prev     ||= {};
118   ***    614            50                 5756      $defaults ||= {};
119          614                               3062      my %given_props;
120          614                               2575      my %final_props;
121          614                               2501      my %opts = %{$self->{opts}};
             614                              15206   
122                                                   
123          614                               8876      foreach my $dsn_part ( split(/,/, $dsn) ) {
124   ***    914     50                       16961         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
125          914                               8001            $given_props{$prop_key} = $prop_val;
126                                                         }
127                                                         else {
128   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
129   ***      0                                  0            $given_props{h} = $dsn_part;
130                                                         }
131                                                      }
132                                                   
133          614                               4846      foreach my $key ( keys %opts ) {
134         4912                              13416         MKDEBUG && _d('Finding value for', $key);
135         4912                              24400         $final_props{$key} = $given_props{$key};
136   ***   4912     50     66                61674         if (   !defined $final_props{$key}
      ***                   33                        
137                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
138                                                         {
139   ***      0                                  0            $final_props{$key} = $prev->{$key};
140   ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
141                                                         }
142         4912    100                       26519         if ( !defined $final_props{$key} ) {
143         3998                              16521            $final_props{$key} = $defaults->{$key};
144         3998                              14811            MKDEBUG && _d('Copying value for', $key, 'from defaults');
145                                                         }
146                                                      }
147                                                   
148          614                               5211      foreach my $key ( keys %given_props ) {
149   ***    914     50                        5892         die "Unrecognized DSN part '$key' in '$dsn'\n"
150                                                            unless exists $opts{$key};
151                                                      }
152   ***    614     50                        4691      if ( (my $required = $self->prop('required')) ) {
153   ***      0                                  0         foreach my $key ( keys %$required ) {
154   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
155                                                         }
156                                                      }
157                                                   
158          614                               7865      return \%final_props;
159                                                   }
160                                                   
161                                                   sub parse_options {
162          514                  514          3803      my ( $self, $o ) = @_;
163   ***    514     50                        4841      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
164          514                               3815      my $dsn_string
165                                                         = join(',',
166         4112    100                       40080             map  { "$_=".$o->get($_); }
167          514                               9628             grep { $o->has($_) && $o->get($_) }
168          514                               2619             keys %{$self->{opts}}
169                                                           );
170          514                               4112      MKDEBUG && _d('DSN string made from options:', $dsn_string);
171          514                               5719      return $self->parse($dsn_string);
172                                                   }
173                                                   
174                                                   sub as_string {
175   ***      0                    0             0      my ( $self, $dsn ) = @_;
176   ***      0      0                           0      return $dsn unless ref $dsn;
177   ***      0      0                           0      return join(',',
178   ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
179   ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
180                                                         sort keys %$dsn );
181                                                   }
182                                                   
183                                                   sub usage {
184   ***      0                    0             0      my ( $self ) = @_;
185   ***      0                                  0      my $usage
186                                                         = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
187                                                         . "  KEY  COPY  MEANING\n"
188                                                         . "  ===  ====  =============================================\n";
189   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
190   ***      0                                  0      foreach my $key ( sort keys %opts ) {
191   ***      0      0      0                    0         $usage .= "  $key    "
192                                                                .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
193                                                                .  ($opts{$key}->{desc} || '[No description]')
194                                                                . "\n";
195                                                      }
196   ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
197   ***      0                                  0      return $usage;
198                                                   }
199                                                   
200                                                   sub get_cxn_params {
201          614                  614          4353      my ( $self, $info ) = @_;
202          614                               2430      my $dsn;
203          614                               2126      my %opts = %{$self->{opts}};
             614                               6984   
204   ***    614            50                 4427      my $driver = $self->prop('dbidriver') || '';
205   ***    614     50                        3621      if ( $driver eq 'Pg' ) {
206   ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
207   ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
208   ***      0             0                    0                        grep { defined $info->{$_} }
209                                                                        qw(h P));
210                                                      }
211                                                      else {
212          714                               9494         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
213         3070                              14661            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
214   ***    614            50                12887                        grep { defined $info->{$_} }
215                                                                        qw(F h P S A))
216                                                            . ';mysql_read_default_group=client';
217                                                      }
218          614                               2352      MKDEBUG && _d($dsn);
219          614                              10291      return ($dsn, $info->{u}, $info->{p});
220                                                   }
221                                                   
222                                                   sub fill_in_dsn {
223   ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
224   ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
225   ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
226   ***      0                                  0      $user =~ s/@.*//;
227   ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
228   ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
229   ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
230   ***      0             0                    0      $dsn->{u} ||= $user;
231   ***      0             0                    0      $dsn->{D} ||= $db;
232                                                   }
233                                                   
234                                                   sub get_dbh {
235          614                  614          6406      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
236          614           100                 4457      $opts ||= {};
237   ***    614     50                       32429      my $defaults = {
238                                                         AutoCommit         => 0,
239                                                         RaiseError         => 1,
240                                                         PrintError         => 0,
241                                                         ShowErrorStatement => 1,
242                                                         mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
243                                                      };
244          614                               4007      @{$defaults}{ keys %$opts } = values %$opts;
             614                               3710   
245                                                   
246   ***    614     50                        3823      if ( !$have_dbi ) {
247   ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
248                                                            . "installed or not found.  Run 'perl -MDBI' to see the directories "
249                                                            . "that Perl searches for DBI.  If DBI is not installed, try:\n"
250                                                            . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
251                                                            . "  RHEL/CentOS    yum install perl-DBI\n"
252                                                            . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
253                                                   
254                                                      }
255                                                   
256          614                               1901      my $dbh;
257          614                               2436      my $tries = 2;
258   ***    614            66                13768      while ( !$dbh && $tries-- ) {
259                                                         MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
260          614                               2029            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
261                                                   
262          614                               3694         eval {
263          614                              18855            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
264                                                   
265   ***    614     50                       10470            if ( $cxn_string =~ m/mysql/i ) {
266          614                               2135               my $sql;
267                                                   
268          614                               3057               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
269                                                                    . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
270          614                               1709               MKDEBUG && _d($dbh, ':', $sql);
271          614                              68302               $dbh->do($sql);
272                                                   
273   ***    614     50                        7643               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
274   ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
275   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
276   ***      0                                  0                  $dbh->do($sql);
277   ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
278   ***      0      0                           0                  if ( $charset eq 'utf8' ) {
279   ***      0      0                           0                     binmode(STDOUT, ':utf8')
280                                                                        or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
281                                                                  }
282                                                                  else {
283   ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
284                                                                  }
285                                                               }
286                                                   
287          614    100                        5274               if ( $self->prop('set-vars') ) {
288          514                               3321                  $sql = "SET " . $self->prop('set-vars');
289          514                               1464                  MKDEBUG && _d($dbh, ':', $sql);
290          514                              50063                  $dbh->do($sql);
291                                                               }
292                                                            }
293                                                         };
294   ***    614     50     33                 8804         if ( !$dbh && $EVAL_ERROR ) {
295   ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
296   ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
297   ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
298   ***      0                                  0               delete $defaults->{mysql_enable_utf8};
299                                                            }
300                                                            elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
301   ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
302                                                                  . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
303                                                                  . "the directories that Perl searches for DBD::mysql.  If "
304                                                                  . "DBD::mysql is not installed, try:\n"
305                                                                  . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
306                                                                  . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
307                                                                  . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
308                                                            }
309   ***      0      0                           0            if ( !$tries ) {
310   ***      0                                  0               die $EVAL_ERROR;
311                                                            }
312                                                         }
313                                                      }
314                                                   
315          614                               1682      MKDEBUG && _d('DBH info: ',
316                                                         $dbh,
317                                                         Dumper($dbh->selectrow_hashref(
318                                                            'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
319                                                         'Connection info:',      $dbh->{mysql_hostinfo},
320                                                         'Character set info:',   Dumper($dbh->selectall_arrayref(
321                                                                        'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
322                                                         '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
323                                                         '$DBI::VERSION:',        $DBI::VERSION,
324                                                      );
325                                                   
326          614                               4870      return $dbh;
327                                                   }
328                                                   
329                                                   sub get_hostname {
330   ***      0                    0             0      my ( $self, $dbh ) = @_;
331   ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
332   ***      0                                  0         return $host;
333                                                      }
334   ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
335                                                         'SELECT /*!50038 @@hostname, */ 1');
336   ***      0                                  0      return $hostname;
337                                                   }
338                                                   
339                                                   sub disconnect {
340   ***      0                    0             0      my ( $self, $dbh ) = @_;
341   ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
342   ***      0                                  0      $dbh->disconnect;
343                                                   }
344                                                   
345                                                   sub print_active_handles {
346   ***      0                    0             0      my ( $self, $thing, $level ) = @_;
347   ***      0             0                    0      $level ||= 0;
348   ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
349                                                         $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
350                                                         or die "Cannot print: $OS_ERROR";
351   ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
352   ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
353                                                      }
354                                                   }
355                                                   
356                                                   sub copy {
357   ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
358   ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
359   ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
360   ***      0                                  0      my %new_dsn = map {
361   ***      0                                  0         my $key = $_;
362   ***      0                                  0         my $val;
363   ***      0      0                           0         if ( $args{overwrite} ) {
364   ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
365                                                         }
366                                                         else {
367   ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
368                                                         }
369   ***      0                                  0         $key => $val;
370   ***      0                                  0      } keys %{$self->{opts}};
371   ***      0                                  0      return \%new_dsn;
372                                                   }
373                                                   
374                                                   sub _d {
375   ***      0                    0             0      my ($package, undef, $line) = caller 0;
376   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
377   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
378                                                           @_;
379   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
380                                                   }
381                                                   
382                                                   1;
383                                                   
384                                                   # ###########################################################################
385                                                   # End DSNParser package
386                                                   # ###########################################################################
387                                                   
388                                                   # ###########################################################################
389                                                   # OptionParser package 5266
390                                                   # ###########################################################################
391                                                   package OptionParser;
392                                                   
393          102                  102           838   use strict;
             102                                381   
             102                                609   
394          102                  102           699   use warnings FATAL => 'all';
             102                                207   
             102                                539   
395                                                   
396          102                  102          1136   use Getopt::Long;
             102                                392   
             102                                710   
397          102                  102           728   use List::Util qw(max);
             102                                375   
             102                               1127   
398          102                  102           632   use English qw(-no_match_vars);
             102                                220   
             102                                862   
399                                                   
400   ***    102            50    102           717   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
             102                                554   
             102                               1558   
401                                                   
402                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
403                                                   
404                                                   my %attributes = (
405                                                      'type'       => 1,
406                                                      'short form' => 1,
407                                                      'group'      => 1,
408                                                      'default'    => 1,
409                                                      'cumulative' => 1,
410                                                      'negatable'  => 1,
411                                                   );
412                                                   
413                                                   sub new {
414          429                  429         15431      my ( $class, %args ) = @_;
415          429                               3773      foreach my $arg ( qw(description) ) {
416   ***    429     50                        3668         die "I need a $arg argument" unless $args{$arg};
417                                                      }
418          429                              13431      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
419   ***    429            33                 2801      $program_name ||= $PROGRAM_NAME;
420   ***    429            33                 5813      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
421                                                   
422          429    100    100                46140      my $self = {
      ***                   50                        
423                                                         description    => $args{description},
424                                                         prompt         => $args{prompt} || '<options>',
425                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
426                                                         dp             => $args{dp}     || undef,
427                                                         program_name   => $program_name,
428                                                         opts           => {},
429                                                         got_opts       => 0,
430                                                         short_opts     => {},
431                                                         defaults       => {},
432                                                         groups         => {},
433                                                         allowed_groups => {},
434                                                         errors         => [],
435                                                         rules          => [],  # desc of rules for --help
436                                                         mutex          => [],  # rule: opts are mutually exclusive
437                                                         atleast1       => [],  # rule: at least one opt is required
438                                                         disables       => {},  # rule: opt disables other opts 
439                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
440                                                         default_files  => [
441                                                            "/etc/maatkit/maatkit.conf",
442                                                            "/etc/maatkit/$program_name.conf",
443                                                            "$home/.maatkit.conf",
444                                                            "$home/.$program_name.conf",
445                                                         ],
446                                                      };
447          429                               6681      return bless $self, $class;
448                                                   }
449                                                   
450                                                   sub get_specs {
451          429                  429          2296      my ( $self, $file ) = @_;
452          429                               4534      my @specs = $self->_pod_to_specs($file);
453          429                              15008      $self->_parse_specs(@specs);
454          429                               3398      return;
455                                                   }
456                                                   
457                                                   sub get_defaults_files {
458          429                  429          2065      my ( $self ) = @_;
459          429                               1622      return @{$self->{default_files}};
             429                               5515   
460                                                   }
461                                                   
462                                                   sub _pod_to_specs {
463          429                  429          2139      my ( $self, $file ) = @_;
464          429           100                 2721      $file ||= __FILE__;
465   ***    429     50                       25481      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
466                                                   
467          429                              17804      my %types = (
468                                                         string => 's', # standard Getopt type
469                                                         'int'  => 'i', # standard Getopt type
470                                                         float  => 'f', # standard Getopt type
471                                                         Hash   => 'H', # hash, formed from a comma-separated list
472                                                         hash   => 'h', # hash as above, but only if a value is given
473                                                         Array  => 'A', # array, similar to Hash
474                                                         array  => 'a', # array, similar to hash
475                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
476                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
477                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
478                                                      );
479          429                               3895      my @specs = ();
480          429                               1854      my @rules = ();
481          429                               1382      my $para;
482                                                   
483          429                               4882      local $INPUT_RECORD_SEPARATOR = '';
484          429                              10592      while ( $para = <$fh> ) {
485       247962    100                      2087869         next unless $para =~ m/^=head1 OPTIONS/;
486          429                               2146         last;
487                                                      }
488                                                   
489          429                               3222      while ( $para = <$fh> ) {
490          858    100                        6045         last if $para =~ m/^=over/;
491          429                               1729         chomp $para;
492          429                               4532         $para =~ s/\s+/ /g;
493          429                              17296         $para =~ s/$POD_link_re/$1/go;
494          429                               1574         MKDEBUG && _d('Option rule:', $para);
495          429                               4881         push @rules, $para;
496                                                      }
497                                                   
498   ***    429     50                        2090      die 'POD has no OPTIONS section' unless $para;
499                                                   
500          429                               1713      do {
501        19305    100                      163054         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
502        18876                              64539            chomp $para;
503        18876                              73161            MKDEBUG && _d($para);
504        18876                              52118            my %attribs;
505                                                   
506        18876                              88412            $para = <$fh>; # read next paragraph, possibly attributes
507                                                   
508        18876    100                       90385            if ( $para =~ m/: / ) { # attributes
509        13728                              79666               $para =~ s/\s+\Z//g;
510        20592                             148728               %attribs = map {
511        13728                              79328                     my ( $attrib, $val) = split(/: /, $_);
512   ***  20592     50                      114624                     die "Unrecognized attribute for --$option: $attrib"
513                                                                        unless $attributes{$attrib};
514        20592                             142088                     ($attrib, $val);
515                                                                  } split(/; /, $para);
516        13728    100                       88091               if ( $attribs{'short form'} ) {
517         5577                              33874                  $attribs{'short form'} =~ s/-//;
518                                                               }
519        13728                              76920               $para = <$fh>; # read next paragraph, probably short help desc
520                                                            }
521                                                            else {
522         5148                              14587               MKDEBUG && _d('Option has no attributes');
523                                                            }
524                                                   
525        18876                             153206            $para =~ s/\s+\Z//g;
526        18876                             158305            $para =~ s/\s+/ /g;
527        18876                             118840            $para =~ s/$POD_link_re/$1/go;
528                                                   
529        18876                              91033            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
530        18876                              48197            MKDEBUG && _d('Short help:', $para);
531                                                   
532   ***  18876     50                       94064            die "No description after option spec $option" if $para =~ m/^=item/;
533                                                   
534        18876    100                      116466            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
535         2574                               8643               $option = $base_option;
536         2574                              12275               $attribs{'negatable'} = 1;
537                                                            }
538                                                   
539        18876    100                      413834            push @specs, {
                    100                               
                    100                               
                    100                               
                    100                               
      ***            50                               
540                                                               spec  => $option
541                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
542                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
543                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
544                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
545                                                               desc  => $para
546                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
547                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
548                                                            };
549                                                         }
550        19305                             163237         while ( $para = <$fh> ) {
551   ***  33462     50                      141888            last unless $para;
552                                                   
553                                                   
554        33462    100                      155656            if ( $para =~ m/^=head1/ ) {
555          429                               1850               $para = undef; # Can't 'last' out of a do {} block.
556          429                               2703               last;
557                                                            }
558        33033    100                      268137            last if $para =~ m/^=item --/;
559                                                         }
560                                                      } while ( $para );
561                                                   
562   ***    429     50                        2330      die 'No valid specs in POD OPTIONS' unless @specs;
563                                                   
564          429                               6073      close $fh;
565          429                               1923      return @specs, @rules;
566                                                   }
567                                                   
568                                                   sub _parse_specs {
569          429                  429          5502      my ( $self, @specs ) = @_;
570          429                               2342      my %disables; # special rule that requires deferred checking
571                                                   
572          429                               3131      foreach my $opt ( @specs ) {
573        19305    100                       85216         if ( ref $opt ) { # It's an option spec, not a rule.
574                                                            MKDEBUG && _d('Parsing opt spec:',
575        18876                              47533               map { ($_, '=>', $opt->{$_}) } keys %$opt);
576                                                   
577        18876                             170752            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
578   ***  18876     50                       98927            if ( !$long ) {
579   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
580                                                            }
581        18876                              84493            $opt->{long} = $long;
582                                                   
583   ***  18876     50                      109316            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
584        18876                             110605            $self->{opts}->{$long} = $opt;
585                                                   
586   ***  18876     50                       90066            if ( length $long == 1 ) {
587   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
588   ***      0                                  0               $self->{short_opts}->{$long} = $long;
589                                                            }
590                                                   
591        18876    100                       73586            if ( $short ) {
592   ***   5577     50                       31436               die "Duplicate short option -$short"
593                                                                  if exists $self->{short_opts}->{$short};
594         5577                             250967               $self->{short_opts}->{$short} = $long;
595         5577                              25028               $opt->{short} = $short;
596                                                            }
597                                                            else {
598        13299                              57609               $opt->{short} = undef;
599                                                            }
600                                                   
601        18876    100                      125844            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
602        18876    100                      115248            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
603   ***  18876     50                      137590            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
604                                                   
605   ***  18876            50                94512            $opt->{group} ||= 'default';
606        18876                             119068            $self->{groups}->{ $opt->{group} }->{$long} = 1;
607                                                   
608        18876                              75091            $opt->{value} = undef;
609        18876                              78489            $opt->{got}   = 0;
610                                                   
611        18876                             123225            my ( $type ) = $opt->{spec} =~ m/=(.)/;
612        18876                              81579            $opt->{type} = $type;
613        18876                              47719            MKDEBUG && _d($long, 'type:', $type);
614                                                   
615   ***  18876     50     66               190831            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
616   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
617                                                                  . "was given when this OptionParser object was created";
618                                                            }
619                                                   
620        18876    100    100               226900            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
621                                                   
622        18876    100                      144104            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
623   ***   3861     50                       29065               $self->{defaults}->{$long} = defined $def ? $def : 1;
624         3861                              11277               MKDEBUG && _d($long, 'default:', $def);
625                                                            }
626                                                   
627        18876    100                       93012            if ( $long eq 'config' ) {
628          429                               3378               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
629                                                            }
630                                                   
631        18876    100                      123782            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
632          858                               3994               $disables{$long} = $dis;
633          858                               2756               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
634                                                            }
635                                                   
636        18876                             111595            $self->{opts}->{$long} = $opt;
637                                                         }
638                                                         else { # It's an option rule, not a spec.
639          429                               1138            MKDEBUG && _d('Parsing rule:', $opt); 
640          429                               1427            push @{$self->{rules}}, $opt;
             429                               2905   
641          429                               5392            my @participants = $self->_get_participants($opt);
642          429                               1868            my $rule_ok = 0;
643                                                   
644   ***    429     50                        7025            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
645          429                               1502               $rule_ok = 1;
646          429                               1431               push @{$self->{mutex}}, \@participants;
             429                               2819   
647          429                               1498               MKDEBUG && _d(@participants, 'are mutually exclusive');
648                                                            }
649   ***    429     50                        4790            if ( $opt =~ m/at least one|one and only one/ ) {
650   ***      0                                  0               $rule_ok = 1;
651   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
652   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
653                                                            }
654   ***    429     50                        3815            if ( $opt =~ m/default to/ ) {
655   ***      0                                  0               $rule_ok = 1;
656   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
657   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
658                                                            }
659   ***    429     50                        3333            if ( $opt =~ m/restricted to option groups/ ) {
660   ***      0                                  0               $rule_ok = 1;
661   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
662   ***      0                                  0               my @groups = split(',', $groups);
663   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
664   ***      0                                  0                  s/\s+//;
665   ***      0                                  0                  $_ => 1;
666                                                               } @groups;
667                                                            }
668                                                   
669   ***    429     50                        4252            die "Unrecognized option rule: $opt" unless $rule_ok;
670                                                         }
671                                                      }
672                                                   
673          429                               3268      foreach my $long ( keys %disables ) {
674          858                               4990         my @participants = $self->_get_participants($disables{$long});
675          858                               5531         $self->{disables}->{$long} = \@participants;
676          858                               3908         MKDEBUG && _d('Option', $long, 'disables', @participants);
677                                                      }
678                                                   
679          429                               3737      return; 
680                                                   }
681                                                   
682                                                   sub _get_participants {
683         1287                 1287          8315      my ( $self, $str ) = @_;
684         1287                               4193      my @participants;
685         1287                              13201      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
686   ***   1716     50                       11098         die "Option --$long does not exist while processing rule $str"
687                                                            unless exists $self->{opts}->{$long};
688         1716                               9369         push @participants, $long;
689                                                      }
690         1287                               4401      MKDEBUG && _d('Participants for', $str, ':', @participants);
691         1287                               8770      return @participants;
692                                                   }
693                                                   
694                                                   sub opts {
695   ***      0                    0             0      my ( $self ) = @_;
696   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
697   ***      0                                  0      return %opts;
698                                                   }
699                                                   
700                                                   sub short_opts {
701   ***      0                    0             0      my ( $self ) = @_;
702   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
703   ***      0                                  0      return %short_opts;
704                                                   }
705                                                   
706                                                   sub set_defaults {
707   ***      0                    0             0      my ( $self, %defaults ) = @_;
708   ***      0                                  0      $self->{defaults} = {};
709   ***      0                                  0      foreach my $long ( keys %defaults ) {
710   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
711                                                            unless exists $self->{opts}->{$long};
712   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
713   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
714                                                      }
715   ***      0                                  0      return;
716                                                   }
717                                                   
718                                                   sub get_defaults {
719   ***      0                    0             0      my ( $self ) = @_;
720   ***      0                                  0      return $self->{defaults};
721                                                   }
722                                                   
723                                                   sub get_groups {
724   ***      0                    0             0      my ( $self ) = @_;
725   ***      0                                  0      return $self->{groups};
726                                                   }
727                                                   
728                                                   sub _set_option {
729         2742                 2742         15770      my ( $self, $opt, $val ) = @_;
730   ***   2742      0                        7060      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
731                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
732                                                               : die "Getopt::Long gave a nonexistent option: $opt";
733                                                   
734         2742                               6569      $opt = $self->{opts}->{$long};
735   ***   2742     50                       20377      if ( $opt->{is_cumulative} ) {
736   ***      0                                  0         $opt->{value}++;
737                                                      }
738                                                      else {
739         2742                              13211         $opt->{value} = $val;
740                                                      }
741         2742                              11660      $opt->{got} = 1;
742         2742                              12916      MKDEBUG && _d('Got option', $long, '=', $val);
743                                                   }
744                                                   
745                                                   sub get_opts {
746          430                  430          2436      my ( $self ) = @_; 
747                                                   
748          430                               1648      foreach my $long ( keys %{$self->{opts}} ) {
             430                               7907   
749        18920                              91622         $self->{opts}->{$long}->{got} = 0;
750        18920    100                      196814         $self->{opts}->{$long}->{value}
                    100                               
751                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
752                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
753                                                            : undef;
754                                                      }
755          430                               3397      $self->{got_opts} = 0;
756                                                   
757          430                               2538      $self->{errors} = [];
758                                                   
759   ***    430     50     33                 8054      if ( @ARGV && $ARGV[0] eq "--config" ) {
760   ***      0                                  0         shift @ARGV;
761   ***      0                                  0         $self->_set_option('config', shift @ARGV);
762                                                      }
763   ***    430     50                        5320      if ( $self->has('config') ) {
764          430                               1879         my @extra_args;
765          430                               3929         foreach my $filename ( split(',', $self->get('config')) ) {
766         1720                               5989            eval {
767         1720                              11611               push @extra_args, $self->_read_config_file($filename);
768                                                            };
769   ***   1720     50                       11394            if ( $EVAL_ERROR ) {
770   ***   1720     50                       10133               if ( $self->got('config') ) {
771   ***      0                                  0                  die $EVAL_ERROR;
772                                                               }
773                                                               elsif ( MKDEBUG ) {
774                                                                  _d($EVAL_ERROR);
775                                                               }
776                                                            }
777                                                         }
778          430                               3863         unshift @ARGV, @extra_args;
779                                                      }
780                                                   
781          430                               7028      Getopt::Long::Configure('no_ignore_case', 'bundling');
782                                                      GetOptions(
783        18490                 2742        163601         map    { $_->{spec} => sub { $self->_set_option(@_); } }
            2742                              16788   
           18920                              91106   
784          430                               4469         grep   { $_->{long} ne 'config' } # --config is handled specially above.
785   ***    430     50                        2121         values %{$self->{opts}}
786                                                      ) or $self->save_error('Error parsing options');
787                                                   
788   ***    430     50     33                43188      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
789   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
790                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
791                                                               or die "Cannot print: $OS_ERROR";
792   ***      0                                  0         exit 0;
793                                                      }
794                                                   
795   ***    430     50     33                 4446      if ( @ARGV && $self->{strict} ) {
796   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
797                                                      }
798                                                   
799          430                               1713      foreach my $mutex ( @{$self->{mutex}} ) {
             430                               3300   
800          430                               2218         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
             860                               6240   
801   ***    430     50                        3738         if ( @set > 1 ) {
802   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
803   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
804                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
805                                                                    . ' are mutually exclusive.';
806   ***      0                                  0            $self->save_error($err);
807                                                         }
808                                                      }
809                                                   
810          430                               1640      foreach my $required ( @{$self->{atleast1}} ) {
             430                               2813   
811   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
812   ***      0      0                           0         if ( @set == 0 ) {
813   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
814   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
815                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
816   ***      0                                  0            $self->save_error("Specify at least one of $err");
817                                                         }
818                                                      }
819                                                   
820          430                               1572      foreach my $long ( keys %{$self->{opts}} ) {
             430                               7416   
821        18920                              95415         my $opt = $self->{opts}->{$long};
822        18920    100                      136772         if ( $opt->{got} ) {
      ***            50                               
823         2742    100                       17746            if ( exists $self->{disables}->{$long} ) {
824          137                               1040               my @disable_opts = @{$self->{disables}->{$long}};
             137                               1569   
825          137                                759               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
             137                               1379   
826          137                                469               MKDEBUG && _d('Unset options', @disable_opts,
827                                                                  'because', $long,'disables them');
828                                                            }
829                                                   
830   ***   2742     50                       17776            if ( exists $self->{allowed_groups}->{$long} ) {
831                                                   
832   ***      0                                  0               my @restricted_groups = grep {
833   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
834   ***      0                                  0               } keys %{$self->{groups}};
835                                                   
836   ***      0                                  0               my @restricted_opts;
837   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
838   ***      0                                  0                  RESTRICTED_OPT:
839   ***      0                                  0                  foreach my $restricted_opt (
840                                                                     keys %{$self->{groups}->{$restricted_group}} )
841                                                                  {
842   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
843   ***      0      0                           0                     push @restricted_opts, $restricted_opt
844                                                                        if $self->{opts}->{$restricted_opt}->{got};
845                                                                  }
846                                                               }
847                                                   
848   ***      0      0                           0               if ( @restricted_opts ) {
849   ***      0                                  0                  my $err;
850   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
851   ***      0                                  0                     $err = "--$restricted_opts[0]";
852                                                                  }
853                                                                  else {
854   ***      0                                  0                     $err = join(', ',
855   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
856   ***      0                                  0                               grep { $_ } 
857                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
858                                                                            )
859                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
860                                                                  }
861   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
862                                                               }
863                                                            }
864                                                   
865                                                         }
866                                                         elsif ( $opt->{is_required} ) { 
867   ***      0                                  0            $self->save_error("Required option --$long must be specified");
868                                                         }
869                                                   
870        18920                              91227         $self->_validate_type($opt);
871                                                      }
872                                                   
873          430                               5018      $self->{got_opts} = 1;
874          430                               1729      return;
875                                                   }
876                                                   
877                                                   sub _validate_type {
878        18920                18920         91046      my ( $self, $opt ) = @_;
879   ***  18920    100     66               236264      return unless $opt && $opt->{type};
880        10750                              46679      my $val = $opt->{value};
881                                                   
882        10750    100    100               371764      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
                    100    100                        
                    100    100                        
      ***                   66                        
      ***                   66                        
883          430                               1216         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
884          430                              10067         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
885   ***    430     50                        7341         if ( !$suffix ) {
886   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
887   ***      0             0                    0            $suffix = $s || 's';
888   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
889                                                               $opt->{long}, '(value:', $val, ')');
890                                                         }
891   ***    430     50                        4877         if ( $suffix =~ m/[smhd]/ ) {
892   ***    430      0                        5081            $val = $suffix eq 's' ? $num            # Seconds
      ***            50                               
      ***            50                               
893                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
894                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
895                                                                 :                  $num * 86400;   # Days
896   ***    430            50                 7962            $opt->{value} = ($prefix || '') . $val;
897          430                               1722            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
898                                                         }
899                                                         else {
900   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
901                                                         }
902                                                      }
903                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
904   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
905   ***      0                                  0         my $prev = {};
906   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
907   ***      0      0                           0         if ( $from_key ) {
908   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
909   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
910                                                         }
911   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
912   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
913                                                      }
914                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
915   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
916   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
917   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
918   ***      0      0                           0         if ( defined $num ) {
919   ***      0      0                           0            if ( $factor ) {
920   ***      0                                  0               $num *= $factor_for{$factor};
921   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
922                                                                  'to num', $num, '* factor', $factor);
923                                                            }
924   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
925                                                         }
926                                                         else {
927   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
928                                                         }
929                                                      }
930                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
931         1879           100                22987         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
            1402                              11068   
932                                                      }
933                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
934   ***    430            50                 9120         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
935                                                      }
936                                                      else {
937         8011                              24906         MKDEBUG && _d('Nothing to validate for option',
938                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
939                                                      }
940                                                   
941        10750                              50201      return;
942                                                   }
943                                                   
944                                                   sub get {
945        78314                78314        450926      my ( $self, $opt ) = @_;
946        78314    100                      438930      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
947   ***  78314     50     33               897856      die "Option $opt does not exist"
948                                                         unless $long && exists $self->{opts}->{$long};
949        78314                             976004      return $self->{opts}->{$long}->{value};
950                                                   }
951                                                   
952                                                   sub got {
953         2369                 2369         15971      my ( $self, $opt ) = @_;
954   ***   2369     50                       13421      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
955   ***   2369     50     33                29984      die "Option $opt does not exist"
956                                                         unless $long && exists $self->{opts}->{$long};
957         2369                              27907      return $self->{opts}->{$long}->{got};
958                                                   }
959                                                   
960                                                   sub has {
961         8394                 8394         45164      my ( $self, $opt ) = @_;
962         8394    100                       57486      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
963         8394    100                      120402      return defined $long ? exists $self->{opts}->{$long} : 0;
964                                                   }
965                                                   
966                                                   sub set {
967         1077                 1077         83795      my ( $self, $opt, $val ) = @_;
968   ***   1077     50                        7262      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
969   ***   1077     50     33                15443      die "Option $opt does not exist"
970                                                         unless $long && exists $self->{opts}->{$long};
971         1077                               6298      $self->{opts}->{$long}->{value} = $val;
972         1077                               4254      return;
973                                                   }
974                                                   
975                                                   sub save_error {
976   ***      0                    0             0      my ( $self, $error ) = @_;
977   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
978                                                   }
979                                                   
980                                                   sub errors {
981   ***      0                    0             0      my ( $self ) = @_;
982   ***      0                                  0      return $self->{errors};
983                                                   }
984                                                   
985                                                   sub prompt {
986   ***      0                    0             0      my ( $self ) = @_;
987   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
988                                                   }
989                                                   
990                                                   sub descr {
991   ***      0                    0             0      my ( $self ) = @_;
992   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
993                                                                 . "  For more details, please use the --help option, "
994                                                                 . "or try 'perldoc $PROGRAM_NAME' "
995                                                                 . "for complete documentation.";
996   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
997   ***      0                                  0      $descr =~ s/ +$//mg;
998   ***      0                                  0      return $descr;
999                                                   }
1000                                                  
1001                                                  sub usage_or_errors {
1002         428                  428          2363      my ( $self ) = @_;
1003  ***    428     50                        3566      if ( $self->{opts}->{help}->{got} ) {
      ***    428     50                        3143   
1004  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1005  ***      0                                  0         exit 0;
1006                                                     }
1007                                                     elsif ( scalar @{$self->{errors}} ) {
1008  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1009  ***      0                                  0         exit 0;
1010                                                     }
1011         428                               1586      return;
1012                                                  }
1013                                                  
1014                                                  sub print_errors {
1015  ***      0                    0             0      my ( $self ) = @_;
1016  ***      0                                  0      my $usage = $self->prompt() . "\n";
1017  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1018  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1019                                                                . "\n";
1020                                                     }
1021  ***      0                                  0      return $usage . "\n" . $self->descr();
1022                                                  }
1023                                                  
1024                                                  sub print_usage {
1025  ***      0                    0             0      my ( $self ) = @_;
1026  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1027  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1028                                                  
1029  ***      0      0                           0      my $maxl = max(
1030  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1031                                                        @opts);
1032                                                  
1033  ***      0      0                           0      my $maxs = max(0,
1034  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1035  ***      0                                  0         values %{$self->{short_opts}});
1036                                                  
1037  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1038  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1039  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1040                                                  
1041  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1042                                                  
1043  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1044                                                  
1045  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1046  ***      0                                  0      push @groups, 'default';
1047                                                  
1048  ***      0                                  0      foreach my $group ( reverse @groups ) {
1049  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1050  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1051  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1052                                                           grep { $_->{group} eq $group }
1053                                                           @opts )
1054                                                        {
1055  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1056  ***      0                                  0            my $short = $opt->{short};
1057  ***      0                                  0            my $desc  = $opt->{desc};
1058  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1059  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1060  ***      0             0                    0               $s    ||= 's';
1061  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1062  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1063                                                                     . "d=days; if no suffix, $s is used.";
1064                                                           }
1065  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1066  ***      0                                  0            $desc =~ s/ +$//mg;
1067  ***      0      0                           0            if ( $short ) {
1068  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1069                                                           }
1070                                                           else {
1071  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1072                                                           }
1073                                                        }
1074                                                     }
1075                                                  
1076  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1077  ***      0                                  0         $usage .= "\nRules:\n\n";
1078  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1079                                                     }
1080  ***      0      0                           0      if ( $self->{dp} ) {
1081  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1082                                                     }
1083  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1084  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1085  ***      0                                  0         my $val   = $opt->{value};
1086  ***      0             0                    0         my $type  = $opt->{type} || '';
1087  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1088  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1089                                                                  : !defined $val             ? '(No value)'
1090                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1091                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1092                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1093                                                                  :                             $val;
1094  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1095                                                     }
1096  ***      0                                  0      return $usage;
1097                                                  }
1098                                                  
1099                                                  sub prompt_noecho {
1100  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1101  ***      0                                  0      my ( $prompt ) = @_;
1102  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1103  ***      0      0                           0      print $prompt
1104                                                        or die "Cannot print: $OS_ERROR";
1105  ***      0                                  0      my $response;
1106  ***      0                                  0      eval {
1107  ***      0                                  0         require Term::ReadKey;
1108  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1109  ***      0                                  0         chomp($response = <STDIN>);
1110  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1111  ***      0      0                           0         print "\n"
1112                                                           or die "Cannot print: $OS_ERROR";
1113                                                     };
1114  ***      0      0                           0      if ( $EVAL_ERROR ) {
1115  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1116                                                     }
1117  ***      0                                  0      return $response;
1118                                                  }
1119                                                  
1120                                                  if ( MKDEBUG ) {
1121                                                     print '# ', $^X, ' ', $], "\n";
1122                                                     my $uname = `uname -a`;
1123                                                     if ( $uname ) {
1124                                                        $uname =~ s/\s+/ /g;
1125                                                        print "# $uname\n";
1126                                                     }
1127                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1128                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1129                                                        ($main::SVN_REV || ''), __LINE__);
1130                                                     print('# Arguments: ',
1131                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1132                                                  }
1133                                                  
1134                                                  sub _read_config_file {
1135        1720                 1720          9010      my ( $self, $filename ) = @_;
1136  ***   1720     50                        5554      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1137  ***      0                                  0      my @args;
1138  ***      0                                  0      my $prefix = '--';
1139  ***      0                                  0      my $parse  = 1;
1140                                                  
1141                                                     LINE:
1142  ***      0                                  0      while ( my $line = <$fh> ) {
1143  ***      0                                  0         chomp $line;
1144  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1145  ***      0                                  0         $line =~ s/\s+#.*$//g;
1146  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1147  ***      0      0                           0         if ( $line eq '--' ) {
1148  ***      0                                  0            $prefix = '';
1149  ***      0                                  0            $parse  = 0;
1150  ***      0                                  0            next LINE;
1151                                                        }
1152  ***      0      0      0                    0         if ( $parse
      ***             0                               
1153                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1154                                                        ) {
1155  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1156                                                        }
1157                                                        elsif ( $line =~ m/./ ) {
1158  ***      0                                  0            push @args, $line;
1159                                                        }
1160                                                        else {
1161  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1162                                                        }
1163                                                     }
1164  ***      0                                  0      close $fh;
1165  ***      0                                  0      return @args;
1166                                                  }
1167                                                  
1168                                                  sub read_para_after {
1169  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1170  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1171  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1172  ***      0                                  0      my $para;
1173  ***      0                                  0      while ( $para = <$fh> ) {
1174  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1175  ***      0                                  0         last;
1176                                                     }
1177  ***      0                                  0      while ( $para = <$fh> ) {
1178  ***      0      0                           0         next unless $para =~ m/$regex/;
1179  ***      0                                  0         last;
1180                                                     }
1181  ***      0                                  0      $para = <$fh>;
1182  ***      0                                  0      chomp($para);
1183  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1184  ***      0                                  0      return $para;
1185                                                  }
1186                                                  
1187                                                  sub clone {
1188  ***      0                    0             0      my ( $self ) = @_;
1189                                                  
1190  ***      0                                  0      my %clone = map {
1191  ***      0                                  0         my $hashref  = $self->{$_};
1192  ***      0                                  0         my $val_copy = {};
1193  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1194  ***      0                                  0            my $ref = ref $hashref->{$key};
1195  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1196  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1197  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1198                                                                             : $hashref->{$key};
1199                                                        }
1200  ***      0                                  0         $_ => $val_copy;
1201                                                     } qw(opts short_opts defaults);
1202                                                  
1203  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1204  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1205                                                     }
1206                                                  
1207  ***      0                                  0      return bless \%clone;     
1208                                                  }
1209                                                  
1210                                                  sub _d {
1211  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1212  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1213  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1214                                                          @_;
1215  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1216                                                  }
1217                                                  
1218                                                  1;
1219                                                  
1220                                                  # ###########################################################################
1221                                                  # End OptionParser package
1222                                                  # ###########################################################################
1223                                                  
1224                                                  # ###########################################################################
1225                                                  # TableParser package 5266
1226                                                  # ###########################################################################
1227                                                  package TableParser;
1228                                                  
1229         102                  102          1052   use strict;
             102                                222   
             102                                744   
1230         102                  102           617   use warnings FATAL => 'all';
             102                                466   
             102                                724   
1231         102                  102           632   use English qw(-no_match_vars);
             102                                224   
             102                                711   
1232         102                  102           701   use Data::Dumper;
             102                                300   
             102                                697   
1233                                                  $Data::Dumper::Indent    = 1;
1234                                                  $Data::Dumper::Sortkeys  = 1;
1235                                                  $Data::Dumper::Quotekeys = 0;
1236                                                  
1237  ***    102            50    102           631   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
             102                                296   
             102                               1531   
1238                                                  
1239                                                  
1240                                                  sub new {
1241         429                  429          5031      my ( $class, %args ) = @_;
1242         429                               2642      my @required_args = qw(Quoter);
1243         429                               3201      foreach my $arg ( @required_args ) {
1244  ***    429     50                        3919         die "I need a $arg argument" unless $args{$arg};
1245                                                     }
1246         429                               2932      my $self = { %args };
1247         429                               5293      return bless $self, $class;
1248                                                  }
1249                                                  
1250                                                  
1251                                                  sub parse {
1252        1237                 1237          7278      my ( $self, $ddl, $opts ) = @_;
1253  ***   1237     50                        5937      return unless $ddl;
1254  ***   1237     50                        8343      if ( ref $ddl eq 'ARRAY' ) {
1255  ***   1237     50                        7292         if ( lc $ddl->[0] eq 'table' ) {
1256        1237                               6552            $ddl = $ddl->[1];
1257                                                        }
1258                                                        else {
1259                                                           return {
1260  ***      0                                  0               engine => 'VIEW',
1261                                                           };
1262                                                        }
1263                                                     }
1264                                                  
1265  ***   1237     50                       14202      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
1266  ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
1267                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
1268                                                     }
1269                                                  
1270        1237                              14136      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
1271  ***   1237     50                       13960      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
1272                                                  
1273        1237                              60376      $ddl =~ s/(`[^`]+`)/\L$1/g;
1274                                                  
1275        1237                               8970      my $engine = $self->get_engine($ddl);
1276                                                  
1277        1237                              69181      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
1278        1237                               6310      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
            7344                              46030   
1279        1237                               4366      MKDEBUG && _d('Columns:', join(', ', @cols));
1280                                                  
1281        1237                               3934      my %def_for;
1282        1237                              13940      @def_for{@cols} = @defs;
1283                                                  
1284        1237                               4264      my (@nums, @null);
1285        1237                               4638      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
1286        1237                               6459      foreach my $col ( @cols ) {
1287        7344                              26453         my $def = $def_for{$col};
1288        7344                              50227         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
1289  ***   7344     50                       32204         die "Can't determine column type for $def" unless $type;
1290        7344                              27178         $type_for{$col} = $type;
1291        7344    100                       49957         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
1292        3916                              14603            push @nums, $col;
1293        3916                              15405            $is_numeric{$col} = 1;
1294                                                        }
1295        7344    100                       36469         if ( $def !~ m/NOT NULL/ ) {
1296        1907                               7635            push @null, $col;
1297        1907                               7583            $is_nullable{$col} = 1;
1298                                                        }
1299        7344    100                       44494         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
1300                                                     }
1301                                                  
1302        1237                              10273      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
1303                                                  
1304                                                     return {
1305        7344                              36130         name           => $name,
1306                                                        cols           => \@cols,
1307        7344                              52443         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
1308        1237                              13743         is_col         => { map { $_ => 1 } @cols },
1309                                                        null_cols      => \@null,
1310                                                        is_nullable    => \%is_nullable,
1311                                                        is_autoinc     => \%is_autoinc,
1312                                                        clustered_key  => $clustered_key,
1313                                                        keys           => $keys,
1314                                                        defs           => \%def_for,
1315                                                        numeric_cols   => \@nums,
1316                                                        is_numeric     => \%is_numeric,
1317                                                        engine         => $engine,
1318                                                        type_for       => \%type_for,
1319                                                     };
1320                                                  }
1321                                                  
1322                                                  sub sort_indexes {
1323  ***      0                    0             0      my ( $self, $tbl ) = @_;
1324                                                  
1325                                                     my @indexes
1326  ***      0                                  0         = sort {
1327  ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
1328                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
1329                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
1330  ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
1331                                                        }
1332                                                        grep {
1333  ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
1334                                                        }
1335  ***      0                                  0         sort keys %{$tbl->{keys}};
1336                                                  
1337  ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
1338  ***      0                                  0      return @indexes;
1339                                                  }
1340                                                  
1341                                                  sub find_best_index {
1342  ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
1343  ***      0                                  0      my $best;
1344  ***      0      0                           0      if ( $index ) {
1345  ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
1346                                                     }
1347  ***      0      0                           0      if ( !$best ) {
1348  ***      0      0                           0         if ( $index ) {
1349  ***      0                                  0            die "Index '$index' does not exist in table";
1350                                                        }
1351                                                        else {
1352  ***      0                                  0            ($best) = $self->sort_indexes($tbl);
1353                                                        }
1354                                                     }
1355  ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
1356  ***      0                                  0      return $best;
1357                                                  }
1358                                                  
1359                                                  sub find_possible_keys {
1360  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
1361  ***      0      0                           0      return () unless $where;
1362  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
1363                                                        . ' WHERE ' . $where;
1364  ***      0                                  0      MKDEBUG && _d($sql);
1365  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
1366  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
1367  ***      0      0                           0      if ( $expl->{possible_keys} ) {
1368  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
1369  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
1370  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
1371  ***      0      0                           0         if ( $expl->{key} ) {
1372  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
1373  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
1374  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
1375  ***      0                                  0            my %seen;
1376  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
1377                                                        }
1378  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
1379  ***      0                                  0         return @candidates;
1380                                                     }
1381                                                     else {
1382  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
1383  ***      0                                  0         return ();
1384                                                     }
1385                                                  }
1386                                                  
1387                                                  sub check_table {
1388  ***      0                    0             0      my ( $self, %args ) = @_;
1389  ***      0                                  0      my @required_args = qw(dbh db tbl);
1390  ***      0                                  0      foreach my $arg ( @required_args ) {
1391  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1392                                                     }
1393  ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
1394  ***      0                                  0      my $q      = $self->{Quoter};
1395  ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
1396  ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
1397                                                  
1398  ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
1399                                                             . ' LIKE ' . $q->literal_like($tbl);
1400  ***      0                                  0      MKDEBUG && _d($sql);
1401  ***      0                                  0      my $row;
1402  ***      0                                  0      eval {
1403  ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
1404                                                     };
1405  ***      0      0                           0      if ( $EVAL_ERROR ) {
1406  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1407  ***      0                                  0         return 0;
1408                                                     }
1409  ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
1410  ***      0                                  0         MKDEBUG && _d('Table does not exist');
1411  ***      0                                  0         return 0;
1412                                                     }
1413                                                  
1414  ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
1415  ***      0      0                           0      return 1 unless $args{all_privs};
1416                                                  
1417  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
1418  ***      0                                  0      MKDEBUG && _d($sql);
1419  ***      0                                  0      eval {
1420  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
1421                                                     };
1422  ***      0      0                           0      if ( $EVAL_ERROR ) {
1423  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1424  ***      0                                  0         return 0;
1425                                                     }
1426  ***      0      0                           0      if ( !scalar keys %$row ) {
1427  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
1428  ***      0                                  0         return 0;
1429                                                     }
1430  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
1431                                                  
1432  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
1433  ***      0                                  0      MKDEBUG && _d($sql);
1434  ***      0                                  0      eval {
1435  ***      0                                  0         $dbh->do($sql);
1436                                                     };
1437  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
1438                                                  
1439  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
1440                                                        ($can_delete ? 'delete' : ''));
1441                                                  
1442  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
1443                                                            && $can_delete) ) {
1444  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
1445  ***      0                                  0         return 0;
1446                                                     }
1447                                                  
1448  ***      0                                  0      MKDEBUG && _d('User has all privs');
1449  ***      0                                  0      return 1;
1450                                                  }
1451                                                  
1452                                                  sub get_engine {
1453        2474                 2474         13508      my ( $self, $ddl, $opts ) = @_;
1454        2474                              63310      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
1455        2474                               7351      MKDEBUG && _d('Storage engine:', $engine);
1456  ***   2474            50                14578      return $engine || undef;
1457                                                  }
1458                                                  
1459                                                  sub get_keys {
1460        1237                 1237          8356      my ( $self, $ddl, $opts, $is_nullable ) = @_;
1461        1237                               6242      my $engine        = $self->get_engine($ddl);
1462        1237                               4764      my $keys          = {};
1463        1237                               4095      my $clustered_key = undef;
1464                                                  
1465                                                     KEY:
1466        1237                              27207      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
1467                                                  
1468  ***   3016     50                       13127         next KEY if $key =~ m/FOREIGN/;
1469                                                  
1470        3016                               9395         my $key_ddl = $key;
1471        3016                               7401         MKDEBUG && _d('Parsed key:', $key_ddl);
1472                                                  
1473  ***   3016     50                       18306         if ( $engine !~ m/MEMORY|HEAP/ ) {
1474        3016                              10257            $key =~ s/USING HASH/USING BTREE/;
1475                                                        }
1476                                                  
1477        3016                              25142         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
1478        3016                              14870         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
1479  ***   3016            66                37420         $type = $type || $special || 'BTREE';
                           100                        
1480  ***   3016     50     33                22497         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
1481                                                           && $engine =~ m/HEAP|MEMORY/i )
1482                                                        {
1483  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
1484                                                        }
1485                                                  
1486        3016                              23198         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
1487        3016    100                       17968         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
1488        3016                               8085         my @cols;
1489        3016                               7431         my @col_prefixes;
1490        3016                              15022         foreach my $col_def ( split(',', $cols) ) {
1491        3358                              24441            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
1492        3358                              12633            push @cols, $name;
1493        3358                              15425            push @col_prefixes, $prefix;
1494                                                        }
1495        3016                              14550         $name =~ s/`//g;
1496                                                  
1497        3016                               7252         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
1498                                                  
1499        3358                              16532         $keys->{$name} = {
1500                                                           name         => $name,
1501                                                           type         => $type,
1502                                                           colnames     => $cols,
1503                                                           cols         => \@cols,
1504                                                           col_prefixes => \@col_prefixes,
1505                                                           is_unique    => $unique,
1506        3358                              37368            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
1507        3016                              18106            is_col       => { map { $_ => 1 } @cols },
1508                                                           ddl          => $key_ddl,
1509                                                        };
1510                                                  
1511        3016    100    100                35496         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
1512        1039                               3965            my $this_key = $keys->{$name};
1513  ***   1039     50      0                 5046            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
1514        1039                               3405               $clustered_key = 'PRIMARY';
1515                                                           }
1516                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
1517  ***      0                                  0               $clustered_key = $this_key->{name};
1518                                                           }
1519        1039                               4216            MKDEBUG && $clustered_key && _d('This key is the clustered key');
1520                                                        }
1521                                                     }
1522                                                  
1523        1237                               8748      return $keys, $clustered_key;
1524                                                  }
1525                                                  
1526                                                  sub get_fks {
1527  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
1528  ***      0                                  0      my $fks = {};
1529                                                  
1530  ***      0                                  0      foreach my $fk (
1531                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
1532                                                     {
1533  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
1534  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
1535  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
1536                                                  
1537  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
1538  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
1539                                                        }
1540                                                  
1541  ***      0                                  0         $fks->{$name} = {
1542                                                           name           => $name,
1543                                                           colnames       => $cols,
1544  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
1545                                                           parent_tbl     => $parent,
1546                                                           parent_colnames=> $parent_cols,
1547  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
1548                                                           ddl            => $fk,
1549                                                        };
1550                                                     }
1551                                                  
1552  ***      0                                  0      return $fks;
1553                                                  }
1554                                                  
1555                                                  sub remove_auto_increment {
1556  ***      0                    0             0      my ( $self, $ddl ) = @_;
1557  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
1558  ***      0                                  0      return $ddl;
1559                                                  }
1560                                                  
1561                                                  sub remove_secondary_indexes {
1562  ***      0                    0             0      my ( $self, $ddl ) = @_;
1563  ***      0                                  0      my $sec_indexes_ddl;
1564  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
1565                                                  
1566  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
1567  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
1568  ***      0             0                    0         $clustered_key  ||= '';
1569                                                  
1570  ***      0                                  0         my @sec_indexes   = map {
1571  ***      0                                  0            my $key_def = $_->{ddl};
1572  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
1573  ***      0                                  0            $ddl =~ s/\s+$key_def//;
1574  ***      0                                  0            "ADD $_->{ddl}";
1575                                                        }
1576  ***      0                                  0         grep { $_->{name} ne $clustered_key }
1577  ***      0                                  0         values %{$tbl_struct->{keys}};
1578  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
1579                                                  
1580  ***      0      0                           0         if ( @sec_indexes ) {
1581  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
1582  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
1583                                                        }
1584                                                  
1585  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
1586                                                     }
1587                                                     else {
1588  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
1589                                                           $tbl_struct->{engine}, 'table');
1590                                                     }
1591                                                  
1592  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
1593                                                  }
1594                                                  
1595                                                  sub _d {
1596  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1597  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1598  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1599                                                          @_;
1600  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1601                                                  }
1602                                                  
1603                                                  1;
1604                                                  
1605                                                  # ###########################################################################
1606                                                  # End TableParser package
1607                                                  # ###########################################################################
1608                                                  
1609                                                  # ###########################################################################
1610                                                  # MySQLDump package 5266
1611                                                  # ###########################################################################
1612                                                  package MySQLDump;
1613                                                  
1614         102                  102           833   use strict;
             102                                668   
             102                                759   
1615         102                  102           694   use warnings FATAL => 'all';
             102                                248   
             102                                845   
1616                                                  
1617         102                  102           622   use English qw(-no_match_vars);
             102                                214   
             102                                522   
1618                                                  
1619  ***    102            50    102           712   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
             102                                302   
             102                               1452   
1620                                                  
1621                                                  ( our $before = <<'EOF') =~ s/^   //gm;
1622                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
1623                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
1624                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
1625                                                     /*!40101 SET NAMES utf8 */;
1626                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
1627                                                     /*!40103 SET TIME_ZONE='+00:00' */;
1628                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
1629                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
1630                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
1631                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
1632                                                  EOF
1633                                                  
1634                                                  ( our $after = <<'EOF') =~ s/^   //gm;
1635                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
1636                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
1637                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
1638                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
1639                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
1640                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
1641                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
1642                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
1643                                                  EOF
1644                                                  
1645                                                  sub new {
1646         429                  429          4855      my ( $class, %args ) = @_;
1647  ***    429     50                        3437      $args{cache} = 1 unless defined $args{cache};
1648         429                               4287      my $self = bless \%args, $class;
1649         429                               2488      return $self;
1650                                                  }
1651                                                  
1652                                                  sub dump {
1653  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
1654                                                  
1655  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
1656  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
1657  ***      0      0                           0         return unless $ddl;
1658  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
1659  ***      0                                  0            return $before
1660                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
1661                                                              . $ddl->[1] . ";\n";
1662                                                        }
1663                                                        else {
1664  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
1665                                                              . '/*!50001 DROP VIEW IF EXISTS '
1666                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
1667                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
1668                                                        }
1669                                                     }
1670                                                     elsif ( $what eq 'triggers' ) {
1671  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
1672  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
1673  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
1674  ***      0                                  0            foreach my $trg ( @$trgs ) {
1675  ***      0      0                           0               if ( $trg->{sql_mode} ) {
1676  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
1677                                                              }
1678  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
1679  ***      0      0                           0               if ( $trg->{definer} ) {
1680  ***      0                                  0                  my ( $user, $host )
1681  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
1682                                                                      split('@', $trg->{definer}, 2);
1683  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
1684                                                              }
1685  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
1686                                                                 $quoter->quote($trg->{trigger}),
1687  ***      0                                  0                  @{$trg}{qw(timing event)},
1688                                                                 $quoter->quote($trg->{table}),
1689                                                                 $trg->{statement});
1690                                                           }
1691  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
1692  ***      0                                  0            return $result;
1693                                                        }
1694                                                        else {
1695  ***      0                                  0            return undef;
1696                                                        }
1697                                                     }
1698                                                     elsif ( $what eq 'view' ) {
1699  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
1700  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
1701                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
1702                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
1703                                                     }
1704                                                     else {
1705  ***      0                                  0         die "You didn't say what to dump.";
1706                                                     }
1707                                                  }
1708                                                  
1709                                                  sub _use_db {
1710        2474                 2474         15658      my ( $self, $dbh, $quoter, $new ) = @_;
1711        2474    100                       12165      if ( !$new ) {
1712         360                               1023         MKDEBUG && _d('No new DB to use');
1713         360                               1523         return;
1714                                                     }
1715        2114                               6847      my $sql = 'SELECT DATABASE()';
1716        2114                               4808      MKDEBUG && _d($sql);
1717        2114                               5433      my $curr = $dbh->selectrow_array($sql);
1718  ***   2114    100     66               227730      if ( $curr && $new && $curr eq $new ) {
      ***                   66                        
1719        1754                               4730         MKDEBUG && _d('Current and new DB are the same');
1720        1754                               8046         return $curr;
1721                                                     }
1722         360                               2676      $sql = 'USE ' . $quoter->quote($new);
1723         360                               1083      MKDEBUG && _d($sql);
1724         360                              33644      $dbh->do($sql);
1725         360                               3681      return $curr;
1726                                                  }
1727                                                  
1728                                                  sub get_create_table {
1729        1237                 1237          7905      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
1730  ***   1237     50     33                10474      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
1731        1237                               4816         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
1732                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
1733                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
1734                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
1735        1237                               3170         MKDEBUG && _d($sql);
1736        1237                               3608         eval { $dbh->do($sql); };
            1237                             206387   
1737        1237                               4381         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
1738        1237                               8715         my $curr_db = $self->_use_db($dbh, $quoter, $db);
1739        1237                               7780         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
1740        1237                               3484         MKDEBUG && _d($sql);
1741        1237                               3486         my $href;
1742        1237                               3612         eval { $href = $dbh->selectrow_hashref($sql); };
            1237                               2982   
1743  ***   1237     50                       10267         if ( $EVAL_ERROR ) {
1744  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
1745  ***      0                                  0            return;
1746                                                        }
1747        1237                               6522         $self->_use_db($dbh, $quoter, $curr_db);
1748        1237                               4239         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
1749                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
1750        1237                               3259         MKDEBUG && _d($sql);
1751        1237                             132135         $dbh->do($sql);
1752        1237                              12107         my ($key) = grep { m/create table/i } keys %$href;
            2474                              20605   
1753  ***   1237     50                        6475         if ( $key ) {
1754        1237                               3123            MKDEBUG && _d('This table is a base table');
1755        1237                              16958            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
1756                                                        }
1757                                                        else {
1758  ***      0                                  0            MKDEBUG && _d('This table is a view');
1759  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
1760  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
1761                                                        }
1762                                                     }
1763        1237                              14278      return $self->{tables}->{$db}->{$tbl};
1764                                                  }
1765                                                  
1766                                                  sub get_columns {
1767  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
1768  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
1769  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
1770  ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
1771  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
1772  ***      0                                  0         MKDEBUG && _d($sql);
1773  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
1774  ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
1775  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
1776                                                           map {
1777  ***      0                                  0               my %row;
1778  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
1779  ***      0                                  0               \%row;
1780                                                           } @$cols
1781                                                        ];
1782                                                     }
1783  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
1784                                                  }
1785                                                  
1786                                                  sub get_tmp_table {
1787  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
1788  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
1789  ***      0                                  0      $result .= join(",\n",
1790  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
1791  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
1792  ***      0                                  0      $result .= "\n)";
1793  ***      0                                  0      MKDEBUG && _d($result);
1794  ***      0                                  0      return $result;
1795                                                  }
1796                                                  
1797                                                  sub get_triggers {
1798  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
1799  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
1800  ***      0                                  0         $self->{triggers}->{$db} = {};
1801  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
1802                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
1803                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
1804                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
1805  ***      0                                  0         MKDEBUG && _d($sql);
1806  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
1807  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
1808  ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
1809  ***      0                                  0         MKDEBUG && _d($sql);
1810  ***      0                                  0         my $sth = $dbh->prepare($sql);
1811  ***      0                                  0         $sth->execute();
1812  ***      0      0                           0         if ( $sth->rows ) {
1813  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
1814  ***      0                                  0            foreach my $trg (@$trgs) {
1815  ***      0                                  0               my %trg;
1816  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
1817  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
1818                                                           }
1819                                                        }
1820  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
1821                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
1822  ***      0                                  0         MKDEBUG && _d($sql);
1823  ***      0                                  0         $dbh->do($sql);
1824                                                     }
1825  ***      0      0                           0      if ( $tbl ) {
1826  ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
1827                                                     }
1828  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
1829                                                  }
1830                                                  
1831                                                  sub get_databases {
1832  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
1833  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
1834  ***      0                                  0         my $sql = 'SHOW DATABASES';
1835  ***      0                                  0         my @params;
1836  ***      0      0                           0         if ( $like ) {
1837  ***      0                                  0            $sql .= ' LIKE ?';
1838  ***      0                                  0            push @params, $like;
1839                                                        }
1840  ***      0                                  0         my $sth = $dbh->prepare($sql);
1841  ***      0                                  0         MKDEBUG && _d($sql, @params);
1842  ***      0                                  0         $sth->execute( @params );
1843  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
1844  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
1845  ***      0                                  0         return @dbs;
1846                                                     }
1847  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
1848                                                  }
1849                                                  
1850                                                  sub get_table_status {
1851        2242                 2242         14805      my ( $self, $dbh, $quoter, $db, $like ) = @_;
1852  ***   2242     50     33                19778      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                   33                        
1853        2242                              12810         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
1854        2242                               6977         my @params;
1855  ***   2242     50                        9699         if ( $like ) {
1856        2242                               6785            $sql .= ' LIKE ?';
1857        2242                               8631            push @params, $like;
1858                                                        }
1859        2242                               6038         MKDEBUG && _d($sql, @params);
1860        2242                               6912         my $sth = $dbh->prepare($sql);
1861        2242                             3746690         $sth->execute(@params);
1862        2242                              12642         my @tables = @{$sth->fetchall_arrayref({})};
            2242                              25196   
1863        2242                               6835         @tables = map {
1864        2242                              23282            my %tbl; # Make a copy with lowercased keys
1865        2242                              25414            @tbl{ map { lc $_ } keys %$_ } = values %$_;
           40356                             164489   
1866  ***   2242             0                20933            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                   33                        
1867        2242                               7961            delete $tbl{type};
1868        2242                              18310            \%tbl;
1869                                                        } @tables;
1870  ***   2242     50                        9951         $self->{table_status}->{$db} = \@tables unless $like;
1871        2242                              56080         return @tables;
1872                                                     }
1873  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
1874                                                  }
1875                                                  
1876                                                  sub get_table_list {
1877  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
1878  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
1879  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
1880  ***      0                                  0         my @params;
1881  ***      0      0                           0         if ( $like ) {
1882  ***      0                                  0            $sql .= ' LIKE ?';
1883  ***      0                                  0            push @params, $like;
1884                                                        }
1885  ***      0                                  0         MKDEBUG && _d($sql, @params);
1886  ***      0                                  0         my $sth = $dbh->prepare($sql);
1887  ***      0                                  0         $sth->execute(@params);
1888  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
1889  ***      0      0      0                    0         @tables = map {
1890  ***      0                                  0            my %tbl = (
1891                                                              name   => $_->[0],
1892                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
1893                                                           );
1894  ***      0                                  0            \%tbl;
1895                                                        } @tables;
1896  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
1897  ***      0                                  0         return @tables;
1898                                                     }
1899  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
1900                                                  }
1901                                                  
1902                                                  sub _d {
1903  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1904  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1905  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1906                                                          @_;
1907  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1908                                                  }
1909                                                  
1910                                                  1;
1911                                                  
1912                                                  # ###########################################################################
1913                                                  # End MySQLDump package
1914                                                  # ###########################################################################
1915                                                  
1916                                                  # ###########################################################################
1917                                                  # TableChunker package 5266
1918                                                  # ###########################################################################
1919         102                  102           837   use strict;
             102                                306   
             102                                622   
1920         102                  102           697   use warnings FATAL => 'all';
             102                                225   
             102                                528   
1921                                                  
1922                                                  package TableChunker;
1923                                                  
1924         102                  102           610   use English qw(-no_match_vars);
             102                                303   
             102                                531   
1925         102                  102           781   use POSIX qw(ceil);
             102                                297   
             102                                654   
1926         102                  102           711   use List::Util qw(min max);
             102                                952   
             102                                603   
1927         102                  102           613   use Data::Dumper;
             102                                220   
             102                                843   
1928                                                  $Data::Dumper::Indent    = 1;
1929                                                  $Data::Dumper::Sortkeys  = 1;
1930                                                  $Data::Dumper::Quotekeys = 0;
1931                                                  
1932  ***    102            50    102           737   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
             102                                211   
             102                               1455   
1933                                                  
1934                                                  sub new {
1935         429                  429          3698      my ( $class, %args ) = @_;
1936         429                               3501      foreach my $arg ( qw(Quoter MySQLDump) ) {
1937  ***    858     50                        6084         die "I need a $arg argument" unless $args{$arg};
1938                                                     }
1939         429                               2993      my $self = { %args };
1940         429                               5475      return bless $self, $class;
1941                                                  }
1942                                                  
1943                                                  my $EPOCH      = '1970-01-01';
1944                                                  my %int_types  = map { $_ => 1 }
1945                                                     qw(bigint date datetime int mediumint smallint time timestamp tinyint year);
1946                                                  my %real_types = map { $_ => 1 }
1947                                                     qw(decimal double float);
1948                                                  
1949                                                  sub find_chunk_columns {
1950        1147                 1147          6092      my ( $self, %args ) = @_;
1951        1147                               5639      foreach my $arg ( qw(tbl_struct) ) {
1952  ***   1147     50                        7152         die "I need a $arg argument" unless $args{$arg};
1953                                                     }
1954        1147                               4523      my $tbl_struct = $args{tbl_struct};
1955                                                  
1956        1147                               3137      my @possible_indexes;
1957        1147                               3582      foreach my $index ( values %{ $tbl_struct->{keys} } ) {
            1147                               7675   
1958                                                  
1959        2711    100                       14915         next unless $index->{type} eq 'BTREE';
1960                                                  
1961  ***   2654            33                 6089         defined $_ && next for @{ $index->{col_prefixes} };
            2654                               8443   
            2654                              21112   
1962                                                  
1963  ***   2654     50                       12855         if ( $args{exact} ) {
1964  ***      0      0      0                    0            next unless $index->{is_unique} && @{$index->{cols}} == 1;
      ***      0                                  0   
1965                                                        }
1966                                                  
1967        2654                              13586         push @possible_indexes, $index;
1968                                                     }
1969                                                     MKDEBUG && _d('Possible chunk indexes in order:',
1970        1147                               3453         join(', ', map { $_->{name} } @possible_indexes));
1971                                                  
1972        1147                               4030      my $can_chunk_exact = 0;
1973        1147                               3845      my @candidate_cols;
1974        1147                               4387      foreach my $index ( @possible_indexes ) { 
1975        2654                              12533         my $col = $index->{cols}->[0];
1976                                                  
1977  ***   2654    100     66                22645         next unless ( $int_types{$tbl_struct->{type_for}->{$col}}
1978                                                                      || $real_types{$tbl_struct->{type_for}->{$col}} );
1979                                                  
1980        2389                              17751         push @candidate_cols, { column => $col, index => $index->{name} };
1981                                                     }
1982                                                  
1983  ***   1147     50     50                 8092      $can_chunk_exact = 1 if $args{exact} && scalar @candidate_cols;
1984                                                  
1985        1147                               2996      if ( MKDEBUG ) {
1986                                                        my $chunk_type = $args{exact} ? 'Exact' : 'Inexact';
1987                                                        _d($chunk_type, 'chunkable:',
1988                                                           join(', ', map { "$_->{column} on $_->{index}" } @candidate_cols));
1989                                                     }
1990                                                  
1991        1147                               3100      my @result;
1992        1147                               2896      MKDEBUG && _d('Ordering columns by order in tbl, PK first');
1993        1147    100                        7096      if ( $tbl_struct->{keys}->{PRIMARY} ) {
1994        1006                               5868         my $pk_first_col = $tbl_struct->{keys}->{PRIMARY}->{cols}->[0];
1995        1006                               3238         @result          = grep { $_->{column} eq $pk_first_col } @candidate_cols;
            2389                              12064   
1996        1006                               3958         @candidate_cols  = grep { $_->{column} ne $pk_first_col } @candidate_cols;
            2389                              11063   
1997                                                     }
1998        1147                               4394      my $i = 0;
1999        1147                               3619      my %col_pos = map { $_ => $i++ } @{$tbl_struct->{cols}};
            6427                              31544   
            1147                               5834   
2000        1147                               5655      push @result, sort { $col_pos{$a->{column}} <=> $col_pos{$b->{column}} }
             777                               4152   
2001                                                                      @candidate_cols;
2002                                                  
2003        1147                               3937      if ( MKDEBUG ) {
2004                                                        _d('Chunkable columns:',
2005                                                           join(', ', map { "$_->{column} on $_->{index}" } @result));
2006                                                        _d('Can chunk exactly:', $can_chunk_exact);
2007                                                     }
2008                                                  
2009        1147                               8313      return ($can_chunk_exact, @result);
2010                                                  }
2011                                                  
2012                                                  sub calculate_chunks {
2013        1006                 1006         10604      my ( $self, %args ) = @_;
2014        1006                               8183      foreach my $arg ( qw(dbh tbl_struct chunk_col min max rows_in_range
2015                                                                          chunk_size dbh) ) {
2016  ***   8048     50                       38340         die "I need a $arg argument" unless defined $args{$arg};
2017                                                     }
2018        1006                               3240      MKDEBUG && _d('Calculate chunks for', Dumper(\%args));
2019        1006                               4120      my $dbh = $args{dbh};
2020                                                  
2021        1006                               3025      my @chunks;
2022        1006                               3579      my ($range_func, $start_point, $end_point);
2023        1006                               6373      my $col_type = $args{tbl_struct}->{type_for}->{$args{chunk_col}};
2024        1006                               3143      MKDEBUG && _d('chunk col type:', $col_type);
2025                                                  
2026                                                  
2027  ***   1006     50                       16645      if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
2028        1006                               3808         $start_point = $args{min};
2029        1006                               3318         $end_point   = $args{max};
2030        1006                               3295         $range_func  = 'range_num';
2031                                                     }
2032                                                     elsif ( $col_type eq 'timestamp' ) {
2033  ***      0                                  0         my $sql = "SELECT UNIX_TIMESTAMP('$args{min}'), UNIX_TIMESTAMP('$args{max}')";
2034  ***      0                                  0         MKDEBUG && _d($sql);
2035  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2036  ***      0                                  0         $range_func  = 'range_timestamp';
2037                                                     }
2038                                                     elsif ( $col_type eq 'date' ) {
2039  ***      0                                  0         my $sql = "SELECT TO_DAYS('$args{min}'), TO_DAYS('$args{max}')";
2040  ***      0                                  0         MKDEBUG && _d($sql);
2041  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2042  ***      0                                  0         $range_func  = 'range_date';
2043                                                     }
2044                                                     elsif ( $col_type eq 'time' ) {
2045  ***      0                                  0         my $sql = "SELECT TIME_TO_SEC('$args{min}'), TIME_TO_SEC('$args{max}')";
2046  ***      0                                  0         MKDEBUG && _d($sql);
2047  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2048  ***      0                                  0         $range_func  = 'range_time';
2049                                                     }
2050                                                     elsif ( $col_type eq 'datetime' ) {
2051  ***      0                                  0         $start_point = $self->timestampdiff($dbh, $args{min});
2052  ***      0                                  0         $end_point   = $self->timestampdiff($dbh, $args{max});
2053  ***      0                                  0         $range_func  = 'range_datetime';
2054                                                     }
2055                                                     else {
2056  ***      0                                  0         die "I don't know how to chunk $col_type\n";
2057                                                     }
2058                                                  
2059  ***   1006     50                        4907      if ( !defined $start_point ) {
2060  ***      0                                  0         MKDEBUG && _d('Start point is undefined');
2061  ***      0                                  0         $start_point = 0;
2062                                                     }
2063  ***   1006     50     33                13847      if ( !defined $end_point || $end_point < $start_point ) {
2064  ***      0                                  0         MKDEBUG && _d('End point is undefined or before start point');
2065  ***      0                                  0         $end_point = 0;
2066                                                     }
2067        1006                               2459      MKDEBUG && _d('Start and end of chunk range:',$start_point,',', $end_point);
2068                                                  
2069        1006                               9843      my $interval = $args{chunk_size}
2070                                                                  * ($end_point - $start_point)
2071                                                                  / $args{rows_in_range};
2072  ***   1006     50                        5834      if ( $int_types{$col_type} ) {
2073        1006                               9121         $interval = ceil($interval);
2074                                                     }
2075  ***   1006            33                 4417      $interval ||= $args{chunk_size};
2076  ***   1006     50                        4908      if ( $args{exact} ) {
2077  ***      0                                  0         $interval = $args{chunk_size};
2078                                                     }
2079        1006                               2333      MKDEBUG && _d('Chunk interval:', $interval, 'units');
2080                                                  
2081        1006                               6476      my $col = $self->{Quoter}->quote($args{chunk_col});
2082  ***   1006     50                        4338      if ( $start_point < $end_point ) {
2083        1006                               3111         my ( $beg, $end );
2084        1006                               3352         my $iter = 0;
2085                                                        for ( my $i = $start_point; $i < $end_point; $i += $interval ) {
2086        4834                              28592            ( $beg, $end ) = $self->$range_func($dbh, $i, $interval, $end_point);
2087                                                  
2088        4834    100                       22402            if ( $iter++ == 0 ) {
2089        1006                               6394               push @chunks, "$col < " . $self->quote($end);
2090                                                           }
2091                                                           else {
2092        3828                              20282               push @chunks, "$col >= " . $self->quote($beg) . " AND $col < " . $self->quote($end);
2093                                                           }
2094        1006                               3054         }
2095                                                  
2096        1006                               6189         my $nullable = $args{tbl_struct}->{is_nullable}->{$args{chunk_col}};
2097        1006                               2916         pop @chunks;
2098        1006    100                        4383         if ( @chunks ) {
2099         379                               2573            push @chunks, "$col >= " . $self->quote($beg);
2100                                                        }
2101                                                        else {
2102  ***    627     50                        3363            push @chunks, $nullable ? "$col IS NOT NULL" : '1=1';
2103                                                        }
2104  ***   1006     50                        4842         if ( $nullable ) {
2105  ***      0                                  0            push @chunks, "$col IS NULL";
2106                                                        }
2107                                                  
2108                                                     }
2109                                                     else {
2110  ***      0                                  0         MKDEBUG && _d('No chunks; using single chunk 1=1');
2111  ***      0                                  0         push @chunks, '1=1';
2112                                                     }
2113                                                  
2114        1006                               9914      return @chunks;
2115                                                  }
2116                                                  
2117                                                  sub get_first_chunkable_column {
2118        1147                 1147          8724      my ( $self, %args ) = @_;
2119        1147                               5982      foreach my $arg ( qw(tbl_struct) ) {
2120  ***   1147     50                        7206         die "I need a $arg argument" unless $args{$arg};
2121                                                     }
2122        1147                               8702      my ($exact, @cols) = $self->find_chunk_columns(%args);
2123        1147                              11069      return ( $cols[0]->{column}, $cols[0]->{index} );
2124                                                  }
2125                                                  
2126                                                  sub size_to_rows {
2127        1006                 1006          8750      my ( $self, %args ) = @_;
2128        1006                               6808      my @required_args = qw(dbh db tbl chunk_size);
2129        1006                               5263      foreach my $arg ( @required_args ) {
2130  ***   4024     50                       20406         die "I need a $arg argument" unless $args{$arg};
2131                                                     }
2132        1006                               6520      my ($dbh, $db, $tbl, $chunk_size) = @args{@required_args};
2133        1006                               3934      my $q  = $self->{Quoter};
2134        1006                               3718      my $du = $self->{MySQLDump};
2135                                                  
2136        1006                               3489      my ($n_rows, $avg_row_length);
2137                                                  
2138        1006                              15132      my ( $num, $suffix ) = $chunk_size =~ m/^(\d+)([MGk])?$/;
2139  ***   1006     50                        5712      if ( $suffix ) { # Convert to bytes.
      ***            50                               
2140  ***      0      0                           0         $chunk_size = $suffix eq 'k' ? $num * 1_024
      ***             0                               
2141                                                                    : $suffix eq 'M' ? $num * 1_024 * 1_024
2142                                                                    :                  $num * 1_024 * 1_024 * 1_024;
2143                                                     }
2144                                                     elsif ( $num ) {
2145        1006                               4039         $n_rows = $num;
2146                                                     }
2147                                                     else {
2148  ***      0                                  0         die "Invalid chunk size $chunk_size; must be an integer "
2149                                                           . "with optional suffix kMG";
2150                                                     }
2151                                                  
2152  ***   1006     50     33                11784      if ( $suffix || $args{avg_row_length} ) {
2153        1006                               6256         my ($status) = $du->get_table_status($dbh, $q, $db, $tbl);
2154        1006                               5628         $avg_row_length = $status->{avg_row_length};
2155  ***   1006     50                        8844         if ( !defined $n_rows ) {
2156  ***      0      0                           0            $n_rows = $avg_row_length ? ceil($chunk_size / $avg_row_length) : undef;
2157                                                        }
2158                                                     }
2159                                                  
2160  ***   1006     50                       12084      return wantarray ? ($n_rows, $avg_row_length) : $n_rows;
2161                                                  }
2162                                                  
2163                                                  sub get_range_statistics {
2164        1006                 1006          9267      my ( $self, %args ) = @_;
2165        1006                               5815      my @required_args = qw(dbh db tbl chunk_col);
2166        1006                               4441      foreach my $arg ( @required_args ) {
2167  ***   4024     50                       19166         die "I need a $arg argument" unless $args{$arg};
2168                                                     }
2169        1006                               6451      my ($dbh, $db, $tbl, $col) = @args{@required_args};
2170        1006                               3269      my $where = $args{where};
2171        1006                               3980      my $q = $self->{Quoter};
2172  ***   1006     50                        4509      my $sql = "SELECT MIN(" . $q->quote($col) . "), MAX(" . $q->quote($col)
2173                                                        . ") FROM " . $q->quote($db, $tbl)
2174                                                        . ($where ? " WHERE $where" : '');
2175        1006                               3226      MKDEBUG && _d($sql);
2176        1006                               2986      my ( $min, $max );
2177        1006                               3111      eval {
2178        1006                               3258         ( $min, $max ) = $dbh->selectrow_array($sql);
2179                                                     };
2180  ***   1006     50                      279612      if ( $EVAL_ERROR ) {
2181  ***      0                                  0         chomp $EVAL_ERROR;
2182  ***      0      0                           0         if ( $EVAL_ERROR =~ m/in your SQL syntax/ ) {
2183  ***      0                                  0            die "$EVAL_ERROR (WHERE clause: $where)";
2184                                                        }
2185                                                        else {
2186  ***      0                                  0            die $EVAL_ERROR;
2187                                                        }
2188                                                     }
2189  ***   1006     50                        5604      $sql = "EXPLAIN SELECT * FROM " . $q->quote($db, $tbl)
2190                                                        . ($where ? " WHERE $where" : '');
2191        1006                               3031      MKDEBUG && _d($sql);
2192        1006                               2708      my $expl = $dbh->selectrow_hashref($sql);
2193                                                     return (
2194        1006                              20483         min           => $min,
2195                                                        max           => $max,
2196                                                        rows_in_range => $expl->{rows},
2197                                                     );
2198                                                  }
2199                                                  
2200                                                  sub quote {
2201        9041                 9041         37604      my ( $self, $val ) = @_;
2202  ***   9041     50                       91862      return $val =~ m/\d[:-]/ ? qq{"$val"} : $val;
2203                                                  }
2204                                                  
2205                                                  sub inject_chunks {
2206  ***      0                    0             0      my ( $self, %args ) = @_;
2207  ***      0                                  0      foreach my $arg ( qw(database table chunks chunk_num query) ) {
2208  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
2209                                                     }
2210  ***      0                                  0      MKDEBUG && _d('Injecting chunk', $args{chunk_num});
2211  ***      0                                  0      my $query   = $args{query};
2212  ***      0                                  0      my $comment = sprintf("/*%s.%s:%d/%d*/",
2213                                                        $args{database}, $args{table},
2214  ***      0                                  0         $args{chunk_num} + 1, scalar @{$args{chunks}});
2215  ***      0                                  0      $query =~ s!/\*PROGRESS_COMMENT\*/!$comment!;
2216  ***      0                                  0      my $where = "WHERE (" . $args{chunks}->[$args{chunk_num}] . ')';
2217  ***      0      0      0                    0      if ( $args{where} && grep { $_ } @{$args{where}} ) {
      ***      0                                  0   
      ***      0                                  0   
2218  ***      0                                  0         $where .= " AND ("
2219  ***      0                                  0            . join(" AND ", map { "($_)" } grep { $_ } @{$args{where}} )
      ***      0                                  0   
      ***      0                                  0   
2220                                                           . ")";
2221                                                     }
2222  ***      0                                  0      my $db_tbl     = $self->{Quoter}->quote(@args{qw(database table)});
2223  ***      0             0                    0      my $index_hint = $args{index_hint} || '';
2224                                                  
2225  ***      0                                  0      MKDEBUG && _d('Parameters:',
2226                                                        Dumper({WHERE => $where, DB_TBL => $db_tbl, INDEX_HINT => $index_hint}));
2227  ***      0                                  0      $query =~ s!/\*WHERE\*/! $where!;
2228  ***      0                                  0      $query =~ s!/\*DB_TBL\*/!$db_tbl!;
2229  ***      0                                  0      $query =~ s!/\*INDEX_HINT\*/! $index_hint!;
2230  ***      0                                  0      $query =~ s!/\*CHUNK_NUM\*/! $args{chunk_num} AS chunk_num,!;
2231                                                  
2232  ***      0                                  0      return $query;
2233                                                  }
2234                                                  
2235                                                  sub range_num {
2236        4834                 4834         33165      my ( $self, $dbh, $start, $interval, $max ) = @_;
2237        4834                              27871      my $end = min($max, $start + $interval);
2238                                                  
2239                                                  
2240  ***   4834     50                       24030      $start = sprintf('%.17f', $start) if $start =~ /e/;
2241  ***   4834     50                       21475      $end   = sprintf('%.17f', $end)   if $end   =~ /e/;
2242                                                  
2243        4834                              14213      $start =~ s/\.(\d{5}).*$/.$1/;
2244        4834                              13741      $end   =~ s/\.(\d{5}).*$/.$1/;
2245                                                  
2246  ***   4834     50                       19808      if ( $end > $start ) {
2247        4834                              26910         return ( $start, $end );
2248                                                     }
2249                                                     else {
2250  ***      0                                  0         die "Chunk size is too small: $end !> $start\n";
2251                                                     }
2252                                                  }
2253                                                  
2254                                                  sub range_time {
2255  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2256  ***      0                                  0      my $sql = "SELECT SEC_TO_TIME($start), SEC_TO_TIME(LEAST($max, $start + $interval))";
2257  ***      0                                  0      MKDEBUG && _d($sql);
2258  ***      0                                  0      return $dbh->selectrow_array($sql);
2259                                                  }
2260                                                  
2261                                                  sub range_date {
2262  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2263  ***      0                                  0      my $sql = "SELECT FROM_DAYS($start), FROM_DAYS(LEAST($max, $start + $interval))";
2264  ***      0                                  0      MKDEBUG && _d($sql);
2265  ***      0                                  0      return $dbh->selectrow_array($sql);
2266                                                  }
2267                                                  
2268                                                  sub range_datetime {
2269  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2270  ***      0                                  0      my $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $start SECOND), "
2271                                                         . "DATE_ADD('$EPOCH', INTERVAL LEAST($max, $start + $interval) SECOND)";
2272  ***      0                                  0      MKDEBUG && _d($sql);
2273  ***      0                                  0      return $dbh->selectrow_array($sql);
2274                                                  }
2275                                                  
2276                                                  sub range_timestamp {
2277  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2278  ***      0                                  0      my $sql = "SELECT FROM_UNIXTIME($start), FROM_UNIXTIME(LEAST($max, $start + $interval))";
2279  ***      0                                  0      MKDEBUG && _d($sql);
2280  ***      0                                  0      return $dbh->selectrow_array($sql);
2281                                                  }
2282                                                  
2283                                                  sub timestampdiff {
2284  ***      0                    0             0      my ( $self, $dbh, $time ) = @_;
2285  ***      0                                  0      my $sql = "SELECT (COALESCE(TO_DAYS('$time'), 0) * 86400 + TIME_TO_SEC('$time')) "
2286                                                        . "- TO_DAYS('$EPOCH 00:00:00') * 86400";
2287  ***      0                                  0      MKDEBUG && _d($sql);
2288  ***      0                                  0      my ( $diff ) = $dbh->selectrow_array($sql);
2289  ***      0                                  0      $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $diff SECOND)";
2290  ***      0                                  0      MKDEBUG && _d($sql);
2291  ***      0                                  0      my ( $check ) = $dbh->selectrow_array($sql);
2292  ***      0      0                           0      die <<"   EOF"
2293                                                     Incorrect datetime math: given $time, calculated $diff but checked to $check.
2294                                                     This is probably because you are using a version of MySQL that overflows on
2295                                                     large interval values to DATE_ADD().  If not, please report this as a bug.
2296                                                     EOF
2297                                                        unless $check eq $time;
2298  ***      0                                  0      return $diff;
2299                                                  }
2300                                                  
2301                                                  sub _d {
2302  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2303  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2304  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2305                                                          @_;
2306  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2307                                                  }
2308                                                  
2309                                                  1;
2310                                                  
2311                                                  # ###########################################################################
2312                                                  # End TableChunker package
2313                                                  # ###########################################################################
2314                                                  
2315                                                  # ###########################################################################
2316                                                  # Quoter package 5266
2317                                                  # ###########################################################################
2318         102                  102           905   use strict;
             102                                228   
             102                                724   
2319         102                  102           861   use warnings FATAL => 'all';
             102                                295   
             102                               2119   
2320                                                  
2321                                                  package Quoter;
2322                                                  
2323         102                  102         19974   use English qw(-no_match_vars);
             102                               2218   
             102                                863   
2324                                                  
2325  ***    102            50    102           700   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
             102                                211   
             102                               1523   
2326                                                  
2327                                                  sub new {
2328         429                  429          2786      my ( $class ) = @_;
2329         429                               5506      bless {}, $class;
2330                                                  }
2331                                                  
2332                                                  sub quote {
2333       16963                16963         91284      my ( $self, @vals ) = @_;
2334       16963                              72340      foreach my $val ( @vals ) {
2335       20287                              97249         $val =~ s/`/``/g;
2336                                                     }
2337       16963                              67754      return join('.', map { '`' . $_ . '`' } @vals);
           20287                             136775   
2338                                                  }
2339                                                  
2340                                                  sub quote_val {
2341  ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
2342                                                  
2343  ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
2344  ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
2345                                                  
2346  ***      0      0                           0      if ( !defined $is_numeric ) {
2347  ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
2348                                                     }
2349                                                  
2350  ***      0      0                           0      return $val if $is_numeric;
2351                                                  
2352  ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
2353  ***      0                                  0      return "'$val'";
2354                                                  }
2355                                                  
2356                                                  sub split_unquote {
2357        1237                 1237          6590      my ( $self, $db_tbl, $default_db ) = @_;
2358        1237                               9064      $db_tbl =~ s/`//g;
2359        1237                               8100      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
2360  ***   1237     50                        6165      if ( !$tbl ) {
2361        1237                               3632         $tbl = $db;
2362        1237                               3713         $db  = $default_db;
2363                                                     }
2364        1237                               6583      return ($db, $tbl);
2365                                                  }
2366                                                  
2367                                                  sub literal_like {
2368  ***      0                    0             0      my ( $self, $like ) = @_;
2369  ***      0      0                           0      return unless $like;
2370  ***      0                                  0      $like =~ s/([%_])/\\$1/g;
2371  ***      0                                  0      return "'$like'";
2372                                                  }
2373                                                  
2374                                                  1;
2375                                                  
2376                                                  # ###########################################################################
2377                                                  # End Quoter package
2378                                                  # ###########################################################################
2379                                                  
2380                                                  # ###########################################################################
2381                                                  # Transformers package 5266
2382                                                  # ###########################################################################
2383                                                  
2384                                                  package Transformers;
2385                                                  
2386         102                  102           718   use strict;
             102                                219   
             102                                514   
2387         102                  102           607   use warnings FATAL => 'all';
             102                                212   
             102                                512   
2388         102                  102           609   use English qw(-no_match_vars);
             102                                536   
             102                               1107   
2389         102                  102          1403   use Time::Local qw(timegm timelocal);
             102                                304   
             102                               1108   
2390         102                  102           703   use Digest::MD5 qw(md5_hex);
             102                                215   
             102                                717   
2391                                                  
2392  ***    102            50    102           616   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
             102                                214   
             102                               1316   
2393                                                  
2394                                                  require Exporter;
2395                                                  our @ISA         = qw(Exporter);
2396                                                  our %EXPORT_TAGS = ();
2397                                                  our @EXPORT      = ();
2398                                                  our @EXPORT_OK   = qw(
2399                                                     micro_t
2400                                                     percentage_of
2401                                                     secs_to_time
2402                                                     shorten
2403                                                     ts
2404                                                     parse_timestamp
2405                                                     unix_timestamp
2406                                                     any_unix_timestamp
2407                                                     make_checksum
2408                                                  );
2409                                                  
2410                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
2411                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
2412                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
2413                                                  
2414                                                  sub micro_t {
2415  ***      0                    0             0      my ( $t, %args ) = @_;
2416  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
2417  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
2418  ***      0                                  0      my $f;
2419                                                  
2420  ***      0      0                           0      $t = 0 if $t < 0;
2421                                                  
2422  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
2423                                                  
2424  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
2425                                                  
2426  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
2427  ***      0                                  0         $f = ($t * 1000000) . 'us';
2428                                                     }
2429                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
2430  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
2431  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
2432                                                     }
2433                                                     elsif ($t >= 1) {
2434  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
2435  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
2436                                                     }
2437                                                     else {
2438  ***      0                                  0         $f = 0;  # $t should = 0 at this point
2439                                                     }
2440                                                  
2441  ***      0                                  0      return $f;
2442                                                  }
2443                                                  
2444                                                  sub percentage_of {
2445  ***      0                    0             0      my ( $is, $of, %args ) = @_;
2446  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
2447  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
2448  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
2449                                                  }
2450                                                  
2451                                                  sub secs_to_time {
2452         746                  746          4563      my ( $secs, $fmt ) = @_;
2453  ***    746            50                 3283      $secs ||= 0;
2454  ***    746     50                        2624      return '00:00' unless $secs;
2455                                                  
2456  ***    746     50     33                 5748      $fmt ||= $secs >= 86_400 ? 'd'
      ***            50                               
2457                                                            : $secs >= 3_600  ? 'h'
2458                                                            :                   'm';
2459                                                  
2460                                                     return
2461  ***    746     50                       16530         $fmt eq 'd' ? sprintf(
      ***            50                               
2462                                                           "%d+%02d:%02d:%02d",
2463                                                           int($secs / 86_400),
2464                                                           int(($secs % 86_400) / 3_600),
2465                                                           int(($secs % 3_600) / 60),
2466                                                           $secs % 60)
2467                                                        : $fmt eq 'h' ? sprintf(
2468                                                           "%02d:%02d:%02d",
2469                                                           int(($secs % 86_400) / 3_600),
2470                                                           int(($secs % 3_600) / 60),
2471                                                           $secs % 60)
2472                                                        : sprintf(
2473                                                           "%02d:%02d",
2474                                                           int(($secs % 3_600) / 60),
2475                                                           $secs % 60);
2476                                                  }
2477                                                  
2478                                                  sub shorten {
2479        1492                 1492          7932      my ( $num, %args ) = @_;
2480  ***   1492     50                        7094      my $p = defined $args{p} ? $args{p} : 2;     # float precision
2481  ***   1492     50                        5677      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
2482        1492                               3949      my $n = 0;
2483        1492                              14571      my @units = ('', qw(k M G T P E Z Y));
2484  ***   1492            66                20033      while ( $num >= $d && $n < @units - 1 ) {
2485        1492                               4707         $num /= $d;
2486        1492                               8052         ++$n;
2487                                                     }
2488  ***   1492     50     66                51282      return sprintf(
2489                                                        $num =~ m/\./ || $n
2490                                                           ? "%.${p}f%s"
2491                                                           : '%d',
2492                                                        $num, $units[$n]);
2493                                                  }
2494                                                  
2495                                                  sub ts {
2496         817                  817          3491      my ( $time, $gmt ) = @_;
2497  ***    817     50                       28265      my ( $sec, $min, $hour, $mday, $mon, $year )
2498                                                        = $gmt ? gmtime($time) : localtime($time);
2499         817                               2901      $mon  += 1;
2500         817                               2307      $year += 1900;
2501         817                               4902      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
2502                                                        $year, $mon, $mday, $hour, $min, $sec);
2503  ***    817     50                       19000      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
2504         817                               6622         $us = sprintf("%.6f", $us);
2505         817                               3726         $us =~ s/^0\././;
2506         817                               2540         $val .= $us;
2507                                                     }
2508         817                               8838      return $val;
2509                                                  }
2510                                                  
2511                                                  sub parse_timestamp {
2512  ***      0                    0             0      my ( $val ) = @_;
2513  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
2514                                                           = $val =~ m/^$mysql_ts$/ )
2515                                                     {
2516  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
2517                                                                       . (defined $f ? '%02.6f' : '%02d'),
2518                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
2519                                                     }
2520  ***      0                                  0      return $val;
2521                                                  }
2522                                                  
2523                                                  sub unix_timestamp {
2524  ***      0                    0             0      my ( $val, $gmt ) = @_;
2525  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
2526  ***      0      0                           0         $val = $gmt
2527                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
2528                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
2529  ***      0      0                           0         if ( defined $us ) {
2530  ***      0                                  0            $us = sprintf('%.6f', $us);
2531  ***      0                                  0            $us =~ s/^0\././;
2532  ***      0                                  0            $val .= $us;
2533                                                        }
2534                                                     }
2535  ***      0                                  0      return $val;
2536                                                  }
2537                                                  
2538                                                  sub any_unix_timestamp {
2539  ***      0                    0             0      my ( $val, $callback ) = @_;
2540                                                  
2541  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
2542  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
2543                                                           : $suffix eq 'm' ? $n * 60       # Minutes
2544                                                           : $suffix eq 'h' ? $n * 3600     # Hours
2545                                                           : $suffix eq 'd' ? $n * 86400    # Days
2546                                                           :                  $n;           # default: Seconds
2547  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
2548  ***      0                                  0         return time - $n;
2549                                                     }
2550                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
2551  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
2552  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2553  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
2554                                                     }
2555                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
2556  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
2557  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2558  ***      0                                  0         return unix_timestamp($val);
2559                                                     }
2560                                                     else {
2561  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
2562  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
2563                                                     }
2564                                                  
2565  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
2566  ***      0                                  0      return;
2567                                                  }
2568                                                  
2569                                                  sub make_checksum {
2570  ***      0                    0             0      my ( $val ) = @_;
2571  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
2572  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
2573  ***      0                                  0      return $checksum;
2574                                                  }
2575                                                  
2576                                                  sub _d {
2577  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2578  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2579  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2580                                                          @_;
2581  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2582                                                  }
2583                                                  
2584                                                  1;
2585                                                  
2586                                                  # ###########################################################################
2587                                                  # End Transformers package
2588                                                  # ###########################################################################
2589                                                  
2590                                                  # ###########################################################################
2591                                                  # MaatkitCommon package 5266
2592                                                  # ###########################################################################
2593                                                  package MaatkitCommon;
2594                                                  
2595                                                  
2596         102                  102           720   use strict;
             102                                290   
             102                                532   
2597         102                  102           613   use warnings FATAL => 'all';
             102                                206   
             102                               1012   
2598                                                  
2599         102                  102           615   use English qw(-no_match_vars);
             102                                222   
             102                                609   
2600                                                  
2601                                                  require Exporter;
2602                                                  our @ISA         = qw(Exporter);
2603                                                  our %EXPORT_TAGS = ();
2604                                                  our @EXPORT      = qw();
2605                                                  our @EXPORT_OK   = qw(
2606                                                     _d
2607                                                     get_number_of_cpus
2608                                                  );
2609                                                  
2610  ***    102            50    102           711   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
             102                                289   
             102                               2576   
2611                                                  
2612                                                  sub _d {
2613  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2614  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2615  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2616                                                          @_;
2617  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2618                                                  }
2619                                                  
2620                                                  sub get_number_of_cpus {
2621         428                  428          1991      my ( $sys_info ) = @_;
2622         428                               1506      my $n_cpus; 
2623                                                  
2624         428                               1423      my $cpuinfo;
2625  ***    428     50     33                35213      if ( $sys_info || (open $cpuinfo, "<", "/proc/cpuinfo") ) {
2626         428                               5080         local $INPUT_RECORD_SEPARATOR = undef;
2627  ***    428            33                31983         my $contents = $sys_info || <$cpuinfo>;
2628         428                               1678         MKDEBUG && _d('sys info:', $contents);
2629  ***    428     50                        7564         close $cpuinfo if $cpuinfo;
2630         428                               7539         $n_cpus = scalar( map { $_ } $contents =~ m/(processor)/g );
             856                               4134   
2631         428                               1922         MKDEBUG && _d('Got', $n_cpus, 'cpus from /proc/cpuinfo');
2632  ***    428     50                        1631         return $n_cpus if $n_cpus;
2633                                                     }
2634                                                  
2635                                                  
2636  ***      0      0      0                    0      if ( $sys_info || ($OSNAME =~ m/freebsd/i) || ($OSNAME =~ m/darwin/i) ) { 
      ***                    0                        
2637  ***      0             0                    0         my $contents = $sys_info || `sysctl hw.ncpu`;
2638  ***      0                                  0         MKDEBUG && _d('sys info:', $contents);
2639  ***      0      0                           0         ($n_cpus) = $contents =~ m/(\d)/ if $contents;
2640  ***      0                                  0         MKDEBUG && _d('Got', $n_cpus, 'cpus from sysctl hw.ncpu');
2641  ***      0      0                           0         return $n_cpus if $n_cpus;
2642                                                     } 
2643                                                  
2644  ***      0             0                    0      $n_cpus ||= $ENV{NUMBER_OF_PROCESSORS};
2645                                                  
2646  ***      0             0                    0      return $n_cpus || 1; # There has to be at least 1 CPU.
2647                                                  }
2648                                                  
2649                                                  1;
2650                                                  
2651                                                  # ###########################################################################
2652                                                  # End MaatkitCommon package
2653                                                  # ###########################################################################
2654                                                  
2655                                                  # ###########################################################################
2656                                                  # Daemon package 5266
2657                                                  # ###########################################################################
2658                                                  
2659                                                  package Daemon;
2660                                                  
2661         102                  102           719   use strict;
             102                                212   
             102                                512   
2662         102                  102           610   use warnings FATAL => 'all';
             102                                215   
             102                                844   
2663                                                  
2664         102                  102           608   use POSIX qw(setsid);
             102                                220   
             102                                632   
2665         102                  102           611   use English qw(-no_match_vars);
             102                                256   
             102                                513   
2666                                                  
2667  ***    102            50    102           619   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
             102                                212   
             102                               1655   
2668                                                  
2669                                                  sub new {
2670  ***      0                    0             0      my ( $class, %args ) = @_;
2671  ***      0                                  0      foreach my $arg ( qw(o) ) {
2672  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2673                                                     }
2674  ***      0                                  0      my $o = $args{o};
2675  ***      0      0                           0      my $self = {
      ***             0                               
2676                                                        o        => $o,
2677                                                        log_file => $o->has('log') ? $o->get('log') : undef,
2678                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
2679                                                     };
2680                                                  
2681  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
2682                                                  
2683  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
2684  ***      0                                  0      return bless $self, $class;
2685                                                  }
2686                                                  
2687                                                  sub daemonize {
2688  ***      0                    0             0      my ( $self ) = @_;
2689                                                  
2690  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
2691  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
2692  ***      0      0                           0      if ( $pid ) {
2693  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
2694  ***      0                                  0         exit;
2695                                                     }
2696                                                  
2697  ***      0                                  0      $self->{child} = 1;
2698                                                  
2699  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2700  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
2701                                                  
2702  ***      0                                  0      $self->_make_PID_file();
2703                                                  
2704  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
2705                                                  
2706  ***      0      0                           0      if ( -t STDIN ) {
2707  ***      0                                  0         close STDIN;
2708  ***      0      0                           0         open  STDIN, '/dev/null'
2709                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
2710                                                     }
2711                                                  
2712  ***      0      0                           0      if ( $self->{log_file} ) {
2713  ***      0                                  0         close STDOUT;
2714  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
2715                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
2716                                                  
2717  ***      0                                  0         close STDERR;
2718  ***      0      0                           0         open  STDERR, ">&STDOUT"
2719                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
2720                                                     }
2721                                                     else {
2722  ***      0      0                           0         if ( -t STDOUT ) {
2723  ***      0                                  0            close STDOUT;
2724  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
2725                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
2726                                                        }
2727  ***      0      0                           0         if ( -t STDERR ) {
2728  ***      0                                  0            close STDERR;
2729  ***      0      0                           0            open  STDERR, '>', '/dev/null'
2730                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
2731                                                        }
2732                                                     }
2733                                                  
2734  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
2735  ***      0                                  0      return;
2736                                                  }
2737                                                  
2738                                                  sub check_PID_file {
2739  ***      0                    0             0      my ( $self, $file ) = @_;
2740  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
2741  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
2742  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
2743  ***      0                                  0         my $pid;
2744  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
2745  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
2746  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
2747  ***      0      0                           0         if ( $pid ) {
2748  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
2749  ***      0      0                           0            if ( $pid_is_alive ) {
2750  ***      0                                  0               die "The PID file $PID_file already exists "
2751                                                                 . " and the PID that it contains, $pid, is running";
2752                                                           }
2753                                                           else {
2754  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
2755                                                                 . "contains, $pid, is not running";
2756                                                           }
2757                                                        }
2758                                                        else {
2759  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
2760                                                              . "contain a PID";
2761                                                        }
2762                                                     }
2763                                                     else {
2764  ***      0                                  0         MKDEBUG && _d('No PID file');
2765                                                     }
2766  ***      0                                  0      return;
2767                                                  }
2768                                                  
2769                                                  sub make_PID_file {
2770  ***      0                    0             0      my ( $self ) = @_;
2771  ***      0      0                           0      if ( exists $self->{child} ) {
2772  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
2773                                                     }
2774  ***      0                                  0      $self->_make_PID_file();
2775  ***      0                                  0      $self->{rm_PID_file} = 1;
2776  ***      0                                  0      return;
2777                                                  }
2778                                                  
2779                                                  sub _make_PID_file {
2780  ***      0                    0             0      my ( $self ) = @_;
2781                                                  
2782  ***      0                                  0      my $PID_file = $self->{PID_file};
2783  ***      0      0                           0      if ( !$PID_file ) {
2784  ***      0                                  0         MKDEBUG && _d('No PID file to create');
2785  ***      0                                  0         return;
2786                                                     }
2787                                                  
2788  ***      0                                  0      $self->check_PID_file();
2789                                                  
2790  ***      0      0                           0      open my $PID_FH, '>', $PID_file
2791                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
2792  ***      0      0                           0      print $PID_FH $PID
2793                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
2794  ***      0      0                           0      close $PID_FH
2795                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
2796                                                  
2797  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
2798  ***      0                                  0      return;
2799                                                  }
2800                                                  
2801                                                  sub _remove_PID_file {
2802  ***      0                    0             0      my ( $self ) = @_;
2803  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
2804  ***      0      0                           0         unlink $self->{PID_file}
2805                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
2806  ***      0                                  0         MKDEBUG && _d('Removed PID file');
2807                                                     }
2808                                                     else {
2809  ***      0                                  0         MKDEBUG && _d('No PID to remove');
2810                                                     }
2811  ***      0                                  0      return;
2812                                                  }
2813                                                  
2814                                                  sub DESTROY {
2815  ***      0                    0             0      my ( $self ) = @_;
2816  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
2817  ***      0                                  0      return;
2818                                                  }
2819                                                  
2820                                                  sub _d {
2821  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2822  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2823  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2824                                                          @_;
2825  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2826                                                  }
2827                                                  
2828                                                  1;
2829                                                  
2830                                                  # ###########################################################################
2831                                                  # End Daemon package
2832                                                  # ###########################################################################
2833                                                  
2834                                                  # ###########################################################################
2835                                                  # SchemaIterator package 5473
2836                                                  # ###########################################################################
2837                                                  package SchemaIterator;
2838                                                  
2839         102                  102           721   use strict;
             102                                305   
             102                                516   
2840         102                  102           616   use warnings FATAL => 'all';
             102                                208   
             102                                588   
2841                                                  
2842         102                  102           613   use English qw(-no_match_vars);
             102                                215   
             102                                516   
2843         102                  102           632   use Data::Dumper;
             102                                310   
             102                                537   
2844                                                  $Data::Dumper::Indent    = 1;
2845                                                  $Data::Dumper::Sortkeys  = 1;
2846                                                  $Data::Dumper::Quotekeys = 0;
2847                                                  
2848  ***    102            50    102           702   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
             102                                240   
             102                               1333   
2849                                                  
2850                                                  sub new {
2851         428                  428          2928      my ( $class, %args ) = @_;
2852         428                               3720      foreach my $arg ( qw(Quoter) ) {
2853  ***    428     50                        4649         die "I need a $arg argument" unless $args{$arg};
2854                                                     }
2855         428                               4345      my $self = {
2856                                                        %args,
2857                                                        filter => undef,
2858                                                        dbs    => [],
2859                                                     };
2860         428                               5220      return bless $self, $class;
2861                                                  }
2862                                                  
2863                                                  sub make_filter {
2864         428                  428          2432      my ( $self, $o ) = @_;
2865         428                               3202      my @lines = (
2866                                                        'sub {',
2867                                                        '   my ( $dbh, $db, $tbl ) = @_;',
2868                                                        '   my $engine = undef;',
2869                                                     );
2870                                                  
2871                                                  
2872  ***    428     50                        2512      my @permit_dbs = _make_filter('unless', '$db', $o->get('databases'))
2873                                                        if $o->has('databases');
2874  ***    428     50                        3826      my @reject_dbs = _make_filter('if', '$db', $o->get('ignore-databases'))
2875                                                        if $o->has('ignore-databases');
2876         428                               1447      my @dbs_regex;
2877  ***    428     50     33                 2501      if ( $o->has('databases-regex') && (my $p = $o->get('databases-regex')) ) {
2878  ***      0                                  0         push @dbs_regex, "      return 0 unless \$db && (\$db =~ m/$p/o);";
2879                                                     }
2880         428                               1783      my @reject_dbs_regex;
2881  ***    428     50     33                 2130      if ( $o->has('ignore-databases-regex')
2882                                                          && (my $p = $o->get('ignore-databases-regex')) ) {
2883  ***      0                                  0         push @reject_dbs_regex, "      return 0 if \$db && (\$db =~ m/$p/o);";
2884                                                     }
2885  ***    428     50     33                 5049      if ( @permit_dbs || @reject_dbs || @dbs_regex || @reject_dbs_regex ) {
      ***                   33                        
      ***                   33                        
2886  ***    428     50                        5488         push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
2887                                                           '   if ( $db ) {',
2888                                                              (@permit_dbs        ? @permit_dbs       : ()),
2889                                                              (@reject_dbs        ? @reject_dbs       : ()),
2890                                                              (@dbs_regex         ? @dbs_regex        : ()),
2891                                                              (@reject_dbs_regex  ? @reject_dbs_regex : ()),
2892                                                           '   }';
2893                                                     }
2894                                                  
2895  ***    428     50     33                 2647      if ( $o->has('tables') || $o->has('ignore-tables')
      ***                   33                        
2896                                                          || $o->has('ignore-tables-regex') ) {
2897                                                  
2898         428                               2069         my $have_qtbl       = 0;
2899         428                               1369         my $have_only_qtbls = 0;
2900         428                               1424         my %qtbls;
2901                                                  
2902         428                               1286         my @permit_tbls;
2903         428                               1271         my @permit_qtbls;
2904         428                               1294         my %permit_qtbls;
2905         428    100                        2222         if ( $o->get('tables') ) {
2906         161                               1295            my %tbls;
2907                                                           map {
2908  ***    183     50                        1641               if ( $_ =~ m/\./ ) {
             161                                851   
2909  ***      0                                  0                  $permit_qtbls{$_} = 1;
2910                                                              }
2911                                                              else {
2912         183                               1173                  $tbls{$_} = 1;
2913                                                              }
2914         161                               1038            } keys %{ $o->get('tables') };
2915         161                               1097            @permit_tbls  = _make_filter('unless', '$tbl', \%tbls);
2916         161                               1181            @permit_qtbls = _make_filter('unless', '$qtbl', \%permit_qtbls);
2917                                                  
2918  ***    161     50                        1105            if ( @permit_qtbls ) {
2919  ***      0                                  0               push @lines,
2920                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
2921  ***      0                                  0               $have_qtbl = 1;
2922                                                           }
2923                                                        }
2924                                                  
2925         428                               2637         my @reject_tbls;
2926         428                               1366         my @reject_qtbls;
2927         428                               1489         my %reject_qtbls;
2928  ***    428     50                        2501         if ( $o->get('ignore-tables') ) {
2929         428                               1425            my %tbls;
2930                                                           map {
2931  ***      0      0                           0               if ( $_ =~ m/\./ ) {
             428                               2141   
2932  ***      0                                  0                  $reject_qtbls{$_} = 1;
2933                                                              }
2934                                                              else {
2935  ***      0                                  0                  $tbls{$_} = 1;
2936                                                              }
2937         428                               1795            } keys %{ $o->get('ignore-tables') };
2938         428                               2869            @reject_tbls= _make_filter('if', '$tbl', \%tbls);
2939         428                               2641            @reject_qtbls = _make_filter('if', '$qtbl', \%reject_qtbls);
2940                                                  
2941  ***    428     50     33                 3380            if ( @reject_qtbls && !$have_qtbl ) {
2942  ***      0                                  0               push @lines,
2943                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
2944                                                           }
2945                                                        }
2946                                                  
2947  ***    428     50     33                 3410         if ( keys %permit_qtbls  && !@permit_dbs ) {
2948  ***      0                                  0            my $dbs = {};
2949  ***      0                                  0            map {
2950  ***      0                                  0               my ($db, undef) = split(/\./, $_);
2951  ***      0                                  0               $dbs->{$db} = 1;
2952                                                           } keys %permit_qtbls;
2953  ***      0                                  0            MKDEBUG && _d('Adding restriction "--databases',
2954                                                                 (join(',', keys %$dbs) . '"'));
2955  ***      0      0                           0            if ( keys %$dbs ) {
2956  ***      0                                  0               $o->set('databases', $dbs);
2957  ***      0                                  0               return $self->make_filter($o);
2958                                                           }
2959                                                        }
2960                                                  
2961         428                               1570         my @tbls_regex;
2962  ***    428     50     33                 3166         if ( $o->has('tables-regex') && (my $p = $o->get('tables-regex')) ) {
2963  ***      0                                  0            push @tbls_regex, "      return 0 unless \$tbl && (\$tbl =~ m/$p/o);";
2964                                                        }
2965         428                               1712         my @reject_tbls_regex;
2966  ***    428     50     33                 2570         if ( $o->has('ignore-tables-regex')
2967                                                             && (my $p = $o->get('ignore-tables-regex')) ) {
2968  ***      0                                  0            push @reject_tbls_regex,
2969                                                              "      return 0 if \$tbl && (\$tbl =~ m/$p/o);";
2970                                                        }
2971                                                  
2972         428                               1359         my @get_eng;
2973         428                               1494         my @permit_engs;
2974         428                               1573         my @reject_engs;
2975  ***    428     50     33                 2414         if ( ($o->has('engines') && $o->get('engines'))
      ***                   33                        
      ***                   33                        
2976                                                             || ($o->has('ignore-engines') && $o->get('ignore-engines')) ) {
2977         428                               3712            push @get_eng,
2978                                                              '      my $sql = "SHOW TABLE STATUS "',
2979                                                              '              . ($db ? "FROM `$db`" : "")',
2980                                                              '              . " LIKE \'$tbl\'";',
2981                                                              '      MKDEBUG && _d($sql);',
2982                                                              '      eval {',
2983                                                              '         $engine = $dbh->selectrow_hashref($sql)->{engine};',
2984                                                              '      };',
2985                                                              '      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);',
2986                                                              '      MKDEBUG && _d($tbl, "uses engine", $engine);',
2987                                                              '      $engine = lc $engine if $engine;',
2988                                                           @permit_engs
2989                                                              = _make_filter('unless', '$engine', $o->get('engines'), 1);
2990                                                           @reject_engs
2991         428                               2650               = _make_filter('if', '$engine', $o->get('ignore-engines'), 1)
2992                                                        }
2993                                                  
2994  ***    428     50     66                15174         if ( @permit_tbls || @reject_tbls || @tbls_regex || @reject_tbls_regex
      ***                   66                        
      ***                   66                        
      ***                   66                        
      ***                   66                        
2995                                                             || @permit_engs || @reject_engs ) {
2996         428    100                       12481            push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
2997                                                              '   if ( $tbl ) {',
2998                                                                 (@permit_tbls       ? @permit_tbls        : ()),
2999                                                                 (@reject_tbls       ? @reject_tbls        : ()),
3000                                                                 (@tbls_regex        ? @tbls_regex         : ()),
3001                                                                 (@reject_tbls_regex ? @reject_tbls_regex  : ()),
3002                                                                 (@permit_qtbls      ? @permit_qtbls       : ()),
3003                                                                 (@reject_qtbls      ? @reject_qtbls       : ()),
3004                                                                 (@get_eng           ? @get_eng            : ()),
3005                                                                 (@permit_engs       ? @permit_engs        : ()),
3006                                                                 (@reject_engs       ? @reject_engs        : ()),
3007                                                              '   }';
3008                                                        }
3009                                                     }
3010                                                  
3011         428                               2698      push @lines,
3012                                                        '   MKDEBUG && _d(\'Passes filters:\', $db, $tbl, $engine, $dbh);',
3013                                                        '   return 1;',  '}';
3014                                                  
3015         428                               4749      my $code = join("\n", @lines);
3016         428                               1290      MKDEBUG && _d('filter sub:', $code);
3017  ***    428     50                      158868      my $filter_sub= eval $code
3018                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
3019                                                  
3020         428                               6821      return $filter_sub;
3021                                                  }
3022                                                  
3023                                                  sub set_filter {
3024         428                  428          2639      my ( $self, $filter_sub ) = @_;
3025         428                               2080      $self->{filter} = $filter_sub;
3026         428                               1293      MKDEBUG && _d('Set filter sub');
3027         428                               1574      return;
3028                                                  }
3029                                                  
3030                                                  sub get_db_itr {
3031         428                  428          4240      my ( $self, %args ) = @_;
3032         428                               2578      my @required_args = qw(dbh);
3033         428                               2092      foreach my $arg ( @required_args ) {
3034  ***    428     50                        3787         die "I need a $arg argument" unless $args{$arg};
3035                                                     }
3036         428                               2578      my ($dbh) = @args{@required_args};
3037                                                  
3038         428                               2049      my $filter = $self->{filter};
3039         428                               1593      my @dbs;
3040         428                               1573      eval {
3041         428                               2242         my $sql = 'SHOW DATABASES';
3042         428                               1279         MKDEBUG && _d($sql);
3043  ***   1968     50                       17499         @dbs =  grep {
3044         428                               1234            my $ok = $filter ? $filter->($dbh, $_, undef) : 1;
3045        1968    100                       20946            $ok = 0 if $_ =~ m/information_schema|lost\+found/;
3046        1968                               8605            $ok;
3047         428                               1645         } @{ $dbh->selectcol_arrayref($sql) };
3048         428                               2489         MKDEBUG && _d('Found', scalar @dbs, 'databases');
3049                                                     };
3050         428                               1146      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3051                                                     return sub {
3052         856                  856          6843         return shift @dbs;
3053         428                               5278      };
3054                                                  }
3055                                                  
3056                                                  sub get_tbl_itr {
3057         428                  428          5784      my ( $self, %args ) = @_;
3058         428                               3281      my @required_args = qw(dbh db);
3059         428                               3275      foreach my $arg ( @required_args ) {
3060  ***    856     50                        6079         die "I need a $arg argument" unless $args{$arg};
3061                                                     }
3062         428                               3504      my ($dbh, $db, $views) = @args{@required_args, 'views'};
3063                                                  
3064         428                               1997      my $filter = $self->{filter};
3065         428                               1517      my @tbls;
3066  ***    428     50                        2477      if ( $db ) {
3067         428                               1429         eval {
3068         428                               4904            my $sql = 'SHOW /*!50002 FULL*/ TABLES FROM '
3069                                                                   . $self->{Quoter}->quote($db);
3070         428                               1485            MKDEBUG && _d($sql);
3071        1236                               6417            @tbls = map {
3072        5365                             230190               $_->[0]
3073                                                           }
3074                                                           grep {
3075         428                               1489               my ($tbl, $type) = @$_;
3076  ***   5365     50                       38957               my $ok = $filter ? $filter->($dbh, $db, $tbl) : 1;
3077  ***   5365     50                       28386               if ( !$views ) {
3078  ***   5365    100     50                39429                  $ok = 0 if ($type || '') eq 'VIEW';
3079                                                              }
3080        5365                              21348               $ok;
3081                                                           }
3082         428                               1934            @{ $dbh->selectall_arrayref($sql) };
3083         428                              10936            MKDEBUG && _d('Found', scalar @tbls, 'tables in', $db);
3084                                                        };
3085         428                               1714         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3086                                                     }
3087                                                     else {
3088  ***      0                                  0         MKDEBUG && _d('No db given so no tables');
3089                                                     }
3090                                                     return sub {
3091        1664                 1664         15758         return shift @tbls;
3092         428                               6483      };
3093                                                  }
3094                                                  
3095                                                  sub _make_filter {
3096        2890                 2890         18348      my ( $cond, $var_name, $objs, $lc ) = @_;
3097        2890                              10235      my @lines;
3098        2890    100                       18209      if ( scalar keys %$objs ) {
3099        1398    100                       13258         my $test = join(' || ',
3100        1017                               6091            map { "$var_name eq '" . ($lc ? lc $_ : $_) ."'" } keys %$objs);
3101        1017                              10564         push @lines, "      return 0 $cond $var_name && ($test);",
3102                                                     }
3103        2890                              19288      return @lines;
3104                                                  }
3105                                                  
3106                                                  sub _d {
3107  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3108  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3109  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3110                                                          @_;
3111  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3112                                                  }
3113                                                  
3114                                                  1;
3115                                                  
3116                                                  # ###########################################################################
3117                                                  # End SchemaIterator package
3118                                                  # ###########################################################################
3119                                                  
3120                                                  # ###########################################################################
3121                                                  # This is a combination of modules and programs in one -- a runnable module.
3122                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
3123                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
3124                                                  #
3125                                                  # Check at the end of this package for the call to main() which actually runs
3126                                                  # the program.
3127                                                  # ###########################################################################
3128                                                  package mk_parallel_dump;
3129                                                  
3130         102                  102           718   use English qw(-no_match_vars);
             102                                305   
             102                                523   
3131         102                  102           794   use File::Basename qw(dirname);
             102                                299   
             102                               1332   
3132         102                  102           618   use File::Spec;
             102                                220   
             102                               1094   
3133         102                  102           618   use List::Util qw(max);
             102                                209   
             102                                604   
3134         102                  102           608   use POSIX;
             102                                219   
             102                                602   
3135         102                  102           819   use Time::HiRes qw(time);
             102                                303   
             102                                808   
3136         102                  102           698   use Data::Dumper;
             102                                219   
             102                                614   
3137                                                  $Data::Dumper::Indent    = 1;
3138                                                  $Data::Dumper::Sortkeys  = 1;
3139                                                  $Data::Dumper::Quotekeys = 0;
3140                                                  
3141                                                  eval {
3142                                                    require IO::Compress::Gzip;
3143                                                    IO::Compress::Gzip->import(qw(gzip $GzipError));
3144                                                  };
3145                                                  my $can_gzip = $EVAL_ERROR ? 0 : 1;
3146                                                  
3147                                                  Transformers->import( qw(shorten secs_to_time ts) );
3148                                                  
3149  ***    102            50    102           624   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
             102                                307   
             102                               1541   
3150                                                  
3151                                                  # Global variables.
3152                                                  
3153                                                  sub main {
3154         428                  428        213101      @ARGV = @_;  # set global ARGV for this package
3155                                                  
3156                                                     # ########################################################################
3157                                                     # Get configuration information.
3158                                                     # ########################################################################
3159         428                              16558      my $dp = new DSNParser();
3160         428                              12437      my $o  = new OptionParser(
3161                                                        strict      => 0,
3162                                                        prompt      => '[OPTION]...',
3163                                                        description => q{dumps sets of MySQL tables in parallel.},
3164                                                     );
3165         428                               3885      $o->get_specs();
3166         428                               5872      $o->get_opts();
3167                                                  
3168         428                               3350      $dp->prop('set-vars', $o->get('set-vars'));
3169                                                  
3170  ***    428     50                        3146      $o->set('threads', max(2, MaatkitCommon::get_number_of_cpus()))
3171                                                        unless $o->got('threads');
3172                                                  
3173                                                     # ########################################################################
3174                                                     # Process options.
3175                                                     # ########################################################################
3176         428                               3146      $o->set('base-dir', File::Spec->rel2abs($o->get('base-dir')));
3177                                                  
3178  ***    428     50                        2853      if ( !$o->get('help') ) {
3179  ***    428     50                        2505         if ( !$o->get('threads') ) {
3180  ***      0                                  0            $o->save_error("You must specify --threads");
3181                                                        }
3182                                                  
3183  ***    428     50     33                 6206         if ( !$o->get('help') && $o->get('lossless-floats') && !$o->get('tab') ) {
      ***                   33                        
3184  ***      0                                  0            $o->save_error("--lossless-floats requires --tab");
3185                                                        }
3186                                                     }
3187                                                  
3188  ***    428     50                        2530      if ( $o->get('csv') ) {
3189  ***      0                                  0         $o->set('tab', 1);
3190                                                     }
3191                                                  
3192         428    100                        2420      if ( $o->get('tab') ) {
3193  ***    221     50                        1466         $o->set('umask', 0) unless $o->got('umask');
3194                                                     }
3195                                                  
3196  ***    428     50                        2501      if ( $o->get('umask') ) {
3197  ***      0                                  0         umask oct($o->get('umask'));
3198                                                     }
3199                                                  
3200  ***    428     50     66                 2547      if ( $o->get('gzip') && !$can_gzip ) {
3201  ***      0                                  0         $o->save_error("Cannot --gzip because the IO::Compress::Gzip module "
3202                                                           . "is not installed.  Install the module or specify --no-gzip.");
3203                                                     }
3204                                                  
3205         428                               3872      $o->usage_or_errors();
3206                                                  
3207                                                     # ########################################################################
3208                                                     # If --pid, check it first since we'll die if it already exits.
3209                                                     # ########################################################################
3210         428                               1351      my $daemon;
3211  ***    428     50                        2354      if ( $o->get('pid') ) {
3212                                                        # We're not daemonizing, it just handles PID stuff.  Keep $daemon
3213                                                        # in the the scope of main() because when it's destroyed it automatically
3214                                                        # removes the PID file.
3215  ***      0                                  0         $daemon = new Daemon(o=>$o);
3216  ***      0                                  0         $daemon->make_PID_file();
3217                                                     }
3218                                                  
3219                                                     # ########################################################################
3220                                                     # Connect.
3221                                                     # ########################################################################
3222  ***    428     50                        3313      if ( $o->get('ask-pass') ) {
3223  ***      0                                  0         $o->set('password', OptionParser::prompt_noecho("Enter password: "));
3224                                                     }
3225                                                  
3226         428                               5899      my $dsn                  = $dp->parse_options($o);
3227         428                               5669      my $dbh                  = $dp->get_dbh($dp->get_cxn_params($dsn));
3228         428                               3832      $dbh->{InactiveDestroy}  = 1;         # Don't die on fork().
3229         428                               3138      $dbh->{FetchHashKeyName} = 'NAME_lc'; # Lowercases all column names for fetchrow_hashref() 
3230                                                  
3231                                                     # ########################################################################
3232                                                     # Stop the slave if desired.
3233                                                     # ########################################################################
3234  ***    428     50     33                 3596      if ( $o->get('stop-slave') && !$o->get('dry-run') ) {
3235  ***      0                                  0         my $sql = 'SHOW STATUS LIKE "Slave_running"';
3236  ***      0                                  0         MKDEBUG && _d($sql);
3237  ***      0                                  0         my (undef, $slave_running) = $dbh->selectrow_array($sql);
3238  ***      0                                  0         MKDEBUG && _d($slave_running);
3239  ***      0      0      0                    0         if ( ($slave_running || '') ne 'ON' ) {
3240  ***      0                                  0            die "This server is not a running slave";
3241                                                        }
3242  ***      0                                  0         $sql = 'STOP SLAVE';
3243  ***      0                                  0         MKDEBUG && _d($sql);
3244  ***      0                                  0         $dbh->do($sql);
3245                                                     }
3246                                                  
3247                                                     # ########################################################################
3248                                                     # Lock the whole server if desired.
3249                                                     # ########################################################################
3250  ***    428     50     33                 2578      if ( $o->get('flush-lock') && !$o->get('dry-run') ) {
3251  ***      0                                  0         my $sql = 'FLUSH TABLES WITH READ LOCK';
3252  ***      0                                  0         MKDEBUG && _d($sql);
3253  ***      0                                  0         $dbh->do($sql);
3254                                                     }
3255                                                  
3256                                                     # ########################################################################
3257                                                     # Make common modules.
3258                                                     # ########################################################################
3259         428                              12131      my $q  = new Quoter();
3260         428                               8251      my $tp = new TableParser(Quoter => $q);
3261         428                               9998      my $du = new MySQLDump(cache => 0);
3262         428                               8777      my $tc = new TableChunker(Quoter => $q, MySQLDump => $du);
3263         428                               5477      my %common_modules = (
3264                                                        OptionParser => $o,
3265                                                        DSNParser    => $dp,
3266                                                        Quoter       => $q,
3267                                                        TableParser  => $tp,
3268                                                        TableChunker => $tc,
3269                                                        MySQLDump    => $du,
3270                                                     );
3271         428                              11527      my $si = new SchemaIterator(
3272                                                        Quoter => $q,
3273                                                     );
3274                                                  
3275                                                     # ########################################################################
3276                                                     # Find each db.tbl to dump.
3277                                                     # ######################################################################## 
3278         428                               1503      my @tbls;
3279         428                               1357      my %stat_totals;  # for all dbs and tbls
3280         428                               2368      my %stats_for;    # for each db and tbl
3281         428                               1514      my $bytes  = 0;  # for progress
3282         428                               1555      my $done   = 0;  # for progress
3283         428                               1562      my $maxdb  = 0;  # for report
3284         428                               1634      my $maxtbl = 0;  # for report
3285                                                  
3286         428                               4925      $si->set_filter($si->make_filter($o));
3287         428                               4832      my $next_db = $si->get_db_itr(dbh => $dbh);
3288                                                     DATABASE:
3289         428                               2356      while ( my $db = $next_db->() ) {
3290         428                               1513         MKDEBUG && _d('Getting tables from', $db);
3291         428                               3564         my $next_tbl = $si->get_tbl_itr(
3292                                                           dbh   => $dbh,
3293                                                           db    => $db,
3294                                                           views => 0,
3295                                                        );
3296                                                        TABLE:
3297         428                               2786         while ( my $tbl = $next_tbl->() ) {
3298        1236                               3509            MKDEBUG && _d('Getting table', $tbl);
3299        1236                               3569            my $tbl_struct;
3300        1236                               3913            eval {
3301        1236                              11793               $tbl_struct = $tp->parse(
3302                                                                 $du->get_create_table($dbh, $q, $db, $tbl));
3303                                                           };
3304  ***   1236     50                        8803            if ( !$tbl_struct ) {
3305                                                              # If this happens errors will be printed to STDERR so the
3306                                                              # user knows what table is broken.  The errors are like:
3307                                                              # Failed to SHOW CREATE TABLE `test`.`broken_tbl`.  The table
3308                                                              # may be damaged.
3309                                                              # Error: DBD::mysql::db selectrow_hashref failed: Incorrect
3310                                                              # information in file: './test/broken_tbl.frm' [for Statement
3311                                                              # "SHOW CREATE TABLE `test`.`broken_tbl`"] at ...
3312  ***      0                                  0               MKDEBUG && _d('Error getting table def');
3313  ***      0                                  0               $stats_for{$db}->{exit} = 1;
3314  ***      0                                  0               $stat_totals{exit} = 1;
3315  ***      0                                  0               next TABLE;
3316                                                           }
3317                                                  
3318                                                           # Get table size.
3319        1236                               4393            my $size = 0;
3320  ***   1236     50     33                 8717            if ( $o->get('biggest-first') || $o->get('progress') ) {
3321        1236                               3391               my @tbl_stats;
3322        1236                               3828               eval {
3323        1236                              11460                  @tbl_stats = $du->get_table_status($dbh, $q, $db, $tbl);
3324                                                              };
3325  ***   1236     50                        6857               if ( $EVAL_ERROR ) {
3326  ***      0                                  0                  MKDEBUG && _d('Error getting table status', $EVAL_ERROR);
3327  ***      0                                  0                  $stats_for{$db}->{exit} = 1;
3328  ***      0                                  0                  $stat_totals{exit} = 1;
3329  ***      0                                  0                  next TABLE;
3330                                                              }
3331  ***   1236            50                 8510               $size   = $tbl_stats[0]->{data_length} || 0;
3332  ***   1236            50                15290               $bytes += $tbl_stats[0]->{data_length} || 0;
3333                                                           }
3334                                                  
3335        1236                              11881            push @tbls, {
3336                                                              db         => $db,
3337                                                              tbl        => $tbl,
3338                                                              tbl_struct => $tbl_struct,
3339                                                              size       => $size,
3340                                                           };
3341                                                  
3342                                                           # For $fmt below.
3343        1236    100                        6883            $maxdb  = length $db  if length $db  > $maxdb;
3344        1236    100                       11223            $maxtbl = length $tbl if length $tbl > $maxtbl;
3345                                                        } # next table
3346                                                     } # next database
3347                                                  
3348                                                     # ########################################################################
3349                                                     # Sort the tables biggest-first.
3350                                                     # ########################################################################
3351  ***    428     50                        4899      if ( $o->get('biggest-first') ) {
3352         428                               3218         @tbls = sort { $b->{size} <=> $a->{size} } @tbls;
            2644                               9789   
3353                                                     }
3354                                                     # Exclude tbl_struct from this debug else the output may be enormous.
3355                                                     MKDEBUG && _d("Found tables\n",
3356         428                               1642         join("\n", map { join ' ', @{$_}{qw(db tbl size)} } @tbls));
3357                                                  
3358                                                     # ########################################################################
3359                                                     # Chunk each table which by default means just one chunk, 1=1, unless
3360                                                     # --chunk-size is specified.  Do this after sorting the tables so chunks
3361                                                     # for the biggest tables will be done first.
3362                                                     # ########################################################################
3363         428                               9800      my @chunks = chunk_tables(
3364                                                        tbls        => \@tbls,
3365                                                        dbh         => $dbh,
3366                                                        stat_totals => \%stat_totals,
3367                                                        stats_for   => \%stats_for,
3368                                                        %common_modules,
3369                                                     );
3370                                                  
3371                                                     # ########################################################################
3372                                                     # Flush logs and get binlog pos.
3373                                                     # ########################################################################
3374  ***    428     50     33                 3577      if ( $o->get('flush-log') && !$o->get('dry-run') ) {
3375  ***      0                                  0         my $sql = 'FLUSH LOGS';
3376  ***      0                                  0         MKDEBUG && _d($sql);
3377  ***      0                                  0         $dbh->do($sql);
3378                                                     }
3379  ***    428     50     33                 2504      if ( $o->get('bin-log-position') && !$o->get('dry-run') ) {
3380         428                               4752         dump_binlog_pos(
3381                                                           dbh    => $dbh,
3382                                                           chunks => \@chunks,
3383                                                           %common_modules,
3384                                                        );
3385                                                     }
3386                                                  
3387                                                     # #####################################################################
3388                                                     # Design the format for printing out.
3389                                                     # #####################################################################
3390  ***    428     50     50                 8153      my $db_tbl_width = $maxdb + (($o->get('verbose')||0) > 1 ? $maxtbl : 0) + 1;
3391  ***    428     50                        2936      $db_tbl_width    = 14 if $db_tbl_width < 14;
3392         428                               2471      my $fmt = "%5s %5s %5s %8s %-${db_tbl_width}s %-s";
3393         428    100                        3375      info($o, 0, sprintf($fmt,
3394                                                        qw(CHUNK TIME EXIT SKIPPED DATABASE.TABLE),
3395                                                        ($o->get('progress') ? 'PROGRESS' : ''))
3396                                                     );
3397                                                  
3398                                                     # #####################################################################
3399                                                     # Assign the work to child processes.  Initially just start --threads
3400                                                     # number of children.  Each child that exits will trigger a new one to
3401                                                     # start after that.  This is really a terrible hack -- I wish Perl had
3402                                                     # decent threading support so I could just queue work for a fixed pool
3403                                                     # of worker threads!
3404                                                     # #####################################################################
3405                                                     
3406                                                     # This signal handler will do nothing but wake up the sleeping parent process
3407                                                     # and record the exit status and time of the child that exited (as a side
3408                                                     # effect of not discarding the signal).
3409         428                               1865      my %kids;
3410         428                               1562      my %exited_children;
3411                                                     $SIG{CHLD} = sub {
3412        4328                 4328         35414         my $kid;
3413        4328                             131072         while (($kid = waitpid(-1, POSIX::WNOHANG)) > 0) {
3414        3182                               7897            MKDEBUG && _d('Process', $kid, 'exited with', $CHILD_ERROR);
3415                                                           # Must right-shift to get the actual exit status of the child.
3416        3182                              72421            $exited_children{$kid}->{exit} = $CHILD_ERROR >> 8;
3417        3182                              73086            $exited_children{$kid}->{time} = time();
3418                                                        }
3419         428                              15625      };
3420                                                  
3421         428                               7545      my $start = time();
3422         428           100                 4482      while ( @chunks || %kids ) {
3423                                                        # Wait for the MySQL server to become responsive.
3424        9053                              68228         my $tries = 0;
3425  ***   9053            33               2303182         while ( !$dbh->ping && $tries++ < $o->get('wait') ) {
3426  ***      0                                  0            sleep(1);
3427  ***      0                                  0            eval {
3428  ***      0                                  0               $dbh = $dp->get_dbh($dp->get_cxn_params($dp->parse_options($o)));
3429                                                           };
3430  ***      0      0                           0            if ( $EVAL_ERROR ) {
3431  ***      0                                  0               info($o, 0, 'Waiting: ' . scalar(localtime)
3432                                                                 . ' ' . mysql_error_msg($EVAL_ERROR));
3433                                                           }
3434                                                        }
3435  ***   9053     50                       66144         if ( $tries >= $o->get('wait') ) {
3436  ***      0                                  0            die "Too many retries, exiting.\n";
3437                                                        }
3438                                                  
3439                                                        # Start a new child process.
3440        9053           100                75753         while ( @chunks && (keys %kids < $o->get('threads')) ) {
3441        3635                              35332            my $chunk = shift @chunks;
3442        3635                              19359            my $file  = filename($o->get('base-dir'),
3443                                                              interp($chunk, '%D', '%N.%6C'));
3444  ***   3635     50                       19418            makedir($file) unless $o->get('dry-run');
3445                                                  
3446                                                           # Set start time for database, table and chunk.  Do this before
3447                                                           # possibly skipping the chunk so report_stats() doesn't die due
3448                                                           # to a db or tbl not having a time value.
3449        3635    100                       24683            $stats_for{$chunk->{D}}->{start_time} = time
3450                                                              if $chunk->{first_tbl_in_db};
3451        3635    100                       24211            $stats_for{$chunk->{D}}->{tables}->{$chunk->{N}}->{start_time} = time
3452                                                              if $chunk->{C} == 0;
3453        3635                              31982            $chunk->{start_time} = time;
3454                                                  
3455                                                           # See if this chunk has already been done.
3456  ***   3635    100     66                17704            if ( $o->get('resume') && (-f "$file.sql" || -f "$file.sql.gz") ) {
      ***                   66                        
3457  ***    288            50                 1488               $done += $chunk->{Z} || 0;
3458         288                               1056               $stat_totals{skipped}++;
3459         288                               1272               $stats_for{$chunk->{D}}->{skipped}++;
3460         288                               1464               $stats_for{$chunk->{D}}->{tables}->{$chunk->{N}}->{skipped}++;
3461         288                                936               $chunk->{skipped}++;
3462         288                               1272               my $progress = update_progress($o, $start, $bytes, $done);
3463         288                               1008               $chunk->{exit} = 0;
3464         288                                936               $chunk->{time} = 0;
3465         288                               1896               report_stats(
3466                                                                 chunk       => $chunk,
3467                                                                 stat_totals => \%stat_totals,
3468                                                                 stats_for   => \%stats_for,
3469                                                                 fmt         => $fmt,
3470                                                                 progress    => $progress,
3471                                                                 %common_modules,
3472                                                              );
3473         288                               3144               next;
3474                                                           }
3475                                                  
3476                                                           # Lock the table if --lock-tables and this is the first chunk
3477                                                           # of the table.  It will be unlocked after the table's last chunk.
3478                                                           # Do this here, not in a child, so the lock holds during all
3479                                                           # chunks (each child makes a new connection to MySQL so if the
3480                                                           # child that does this chunk acquires the lock, it will be lost
3481                                                           # when it exits).
3482  ***   3347     50     66                30216            if ( $chunk->{C} == 0
      ***                   33                        
3483                                                                && $o->get('lock-tables')
3484                                                                && !$o->get('dry-run') ) {
3485  ***      0                                  0               my $db_tbl = $q->quote($chunk->{D}, $chunk->{N});
3486  ***      0                                  0               my $sql    = "LOCK TABLES $db_tbl READ";
3487  ***      0                                  0               MKDEBUG && _d($sql);
3488  ***      0                                  0               eval {
3489  ***      0                                  0                  $dbh->do($sql);
3490                                                              };
3491                                                              # This shouldn't happen.
3492  ***      0      0                           0               warn $EVAL_ERROR if $EVAL_ERROR;
3493                                                           }
3494                                                  
3495        3347                             19512034            my $pid = fork();
3496  ***   3347     50                       61271            die "Can't fork: $OS_ERROR" unless defined $pid;
3497        3347    100                       57628            if ( $pid ) {              # I'm the parent
3498        3261                             367109               $kids{$pid} = $chunk;
3499                                                           }
3500                                                           else {                     # I'm the child
3501          86                              14339               $SIG{CHLD} = 'DEFAULT'; # See bug #1886444
3502          86                              11580               MKDEBUG && _d('Start PID', $PID);
3503          86                              20347               my $exit_status = dump_chunk(
3504                                                                 chunk => $chunk,
3505                                                                 file  => $file,
3506                                                                 %common_modules,
3507                                                              );
3508          86                                419               MKDEBUG && _d('End PID', $PID, 'exit status', $exit_status);
3509          86                                729               exit $exit_status;
3510                                                           }
3511                                                        }
3512                                                  
3513                                                        # Possibly wait for child.
3514        8967                              68467         my $reaped = 0;
3515        8967                             103815         foreach my $pid ( keys %exited_children ) {
3516        3182                              13578            my $chunk = $kids{$pid};
3517        3182                              22098            $chunk->{exit} = $exited_children{$pid}->{exit};
3518        3182                              26344            $chunk->{time} = $exited_children{$pid}->{time} - $chunk->{start_time};
3519                                                  
3520  ***   3182     50     66                27951            if ( $chunk->{last_chunk_in_tbl}
      ***                   33                        
3521                                                                && $o->get('lock-tables')
3522                                                                && !$o->get('dry-run') ) {
3523  ***      0                                  0               my $db_tbl = $q->quote($chunk->{D}, $chunk->{N});
3524  ***      0                                  0               my $sql    = "UNLOCK TABLES";
3525  ***      0                                  0               MKDEBUG && _d($sql);
3526  ***      0                                  0               eval {
3527  ***      0                                  0                  $dbh->do($sql);
3528                                                              };
3529  ***      0      0                           0               warn $EVAL_ERROR if $EVAL_ERROR;
3530                                                           }
3531                                                  
3532  ***   3182            50                25691            $done += $chunk->{Z} || 0;
3533        3182                              56226            my $progress = update_progress($o, $start, $bytes, $done);
3534        3182                              97799            report_stats(
3535                                                              chunk       => $chunk,
3536                                                              stat_totals => \%stat_totals,
3537                                                              stats_for   => \%stats_for,
3538                                                              fmt         => $fmt,
3539                                                              progress    => $progress,
3540                                                              %common_modules,
3541                                                           );
3542                                                  
3543        3182                              11558            $reaped = 1;
3544        3182                              12367            delete $kids{$pid};
3545        3182                              71791            delete $exited_children{$pid};
3546                                                        }
3547                                                  
3548        8967    100                       72210         if ( !$reaped ) {
3549                                                           # Don't busy-wait.  But don't wait forever either, as a child
3550                                                           # may exit and signal while we're not sleeping, so if we sleep
3551                                                           # forever we may not get the signal.
3552        5785                              15135            MKDEBUG && _d('No children reaped, sleeping');
3553        5785                             2604708053            sleep 1;
3554                                                        }
3555                                                     } # while chunks or kids
3556                                                  
3557                                                     # ########################################################################
3558                                                     # Unlock tables possibly locked with FLUSH TABLES WITH READ LOCK.
3559                                                     # ########################################################################
3560  ***    342     50                        2539      if ( !$o->get('dry-run') ) {
3561         342                               1787         my $sql = 'UNLOCK TABLES';
3562         342                               1052         MKDEBUG && _d($sql);
3563         342                              30267         $dbh->do($sql);
3564                                                     }
3565         342                              22646      $dbh->commit();
3566                                                  
3567                                                     # ########################################################################
3568                                                     # Restart the slave if desired.
3569                                                     # ########################################################################
3570  ***    342     50     33                 1998      if ( $o->get('stop-slave') && !$o->get('dry-run') ) {
3571  ***      0                                  0         my $sql = 'START SLAVE';
3572  ***      0                                  0         MKDEBUG && _d($sql);
3573  ***      0                                  0         $dbh->do($sql);
3574                                                     }
3575                                                  
3576         342                              11687      $dbh->disconnect();
3577                                                  
3578         342                               4643      $stat_totals{wallclock} = time() - $start;
3579         342                               1702      my $progress = '';
3580         342    100                        1538      if ( $o->get('progress') ) {
3581         213                               1704         $progress = 'done at ' . ts(time) .', '
3582                                                                  . join(', ',
3583          71                                497                        map { "$stat_totals{counts}->{$_} $_" }
3584                                                                          qw(databases tables chunks));
3585                                                     }
3586  ***    342            50                12030      info($o, 0, sprintf($fmt,
                           100                        
3587                                                           'all',
3588                                                           sprintf('%.2f', $stat_totals{wallclock}),
3589                                                           $stat_totals{exit} || 0,
3590                                                           $stat_totals{skipped} || 0,
3591                                                           '-',
3592                                                           $progress)
3593                                                     );
3594                                                  
3595  ***    342            50               199854      return $stat_totals{exit} || 0;
3596                                                  }
3597                                                  
3598                                                  # ############################################################################
3599                                                  # Subroutines
3600                                                  # ############################################################################
3601                                                  
3602                                                  sub mysql_error_msg {
3603  ***      0                    0             0      my ( $text ) = @_;
3604  ***      0                                  0      $text =~ s/^.*?failed: (.*?) at \S+ line (\d+).*$/$1 at line $2/s;
3605  ***      0                                  0      return $text;
3606                                                  }
3607                                                  
3608                                                  sub chunk_tables {
3609         432                  432          6851      my ( %args ) = @_;
3610         432                               4303      my @required_args = qw(dbh tbls stat_totals stats_for OptionParser
3611                                                                            Quoter TableChunker);
3612         432                               3704      foreach my $arg ( @required_args ) {
3613  ***   3024     50                       18375         die "I need a $arg argument" unless $args{$arg};
3614                                                     }
3615         432                               4141      my ($dbh, $tbls, $stat_totals, $stats_for) = @args{@required_args};
3616                                                  
3617         432    100                        2761      if ( scalar @$tbls == 0 ) {
3618          69                                759         MKDEBUG && _d('No tables to chunk');
3619          69                                897         return ();
3620                                                     }
3621                                                  
3622         363                                996      my %seen_db;
3623         363                               1309      my $last_db  = '';
3624         363                               1813      my $n_tables = scalar @$tbls - 1;
3625         363                               1310      my $chunkno  = 0;
3626         363                               1225      my @chunks;
3627         363                               2193      for my $tblno ( 0..$n_tables ) {
3628        1249                               5872         my $tbl  = $tbls->[$tblno];
3629        1249                              11398         my $cols = make_col_list(tbl_struct=>$tbl->{tbl_struct}, %args);
3630        1249                               4841         eval {
3631        1249                               4081            my $i = 0;
3632        5704                              91673            push @chunks, map {
3633        1249                              10243               my $chunk = {
3634                                                                 D => $_->{D},  # Database name
3635                                                                 N => $_->{N},  # Table name
3636                                                                 W => $_->{W},  # WHERE clause
3637                                                                 E => $_->{E},  # Storage engine
3638                                                                 Z => $_->{Z},  # Chunk size
3639                                                                 C => $i++,     # Chunk number for this table
3640                                                                 L => $cols,    # SELECT list
3641                                                                 S => $tbl->{tbl_struct},
3642                                                              };
3643                                                  
3644                                                              # @chunks is a continuous list of db.tbl.chunk.  To report per-db
3645                                                              # and per-tbl info we need to know the first table in each db
3646                                                              # and the number of chunks in each db and table.  So, this chunk
3647                                                              # is the first in this db if this db has never been seen before,
3648                                                              # and...
3649        5704    100                       33185               $chunk->{first_tbl_in_db} = 1 if !$seen_db{$chunk->{D}}++;
3650                                                  
3651        5704                              15721               $chunkno++;
3652        5704                              20309               $chunk;  # save the chunk
3653                                                           } get_chunks(tbl => $tbl, %args);
3654                                                  
3655                                                           # ...save the number of chunk in each db and table.  These values
3656                                                           # are decremented so we can reliably know when a table and db are
3657                                                           # fully done (when there's no more chunks left).
3658        1249                              19383            $stats_for->{$tbl->{db}}->{tables}->{$tbl->{tbl}}->{chunks_left} += $i;
3659        1249                               6209            $stats_for->{$tbl->{db}}->{chunks_left} += $i;
3660                                                  
3661                                                           # Save the number of chunks again.  These values aren't modified;
3662                                                           # they for status reports (see report_stats()).
3663        1249                               8356            $stats_for->{$tbl->{db}}->{tables}->{$tbl->{tbl}}->{chunks} = $i;
3664        1249                               6194            $stats_for->{$tbl->{db}}->{chunks} += $i;
3665                                                  
3666                                                           # last_chunk_in_tbl is used to tell us when we can unlock the
3667                                                           # table if using --lock-tables.  The last chunk (-1) is the last
3668                                                           # one for this table.
3669        1249                               9432            $chunks[-1]->{last_chunk_in_tbl} = 1;  
3670                                                        };
3671  ***   1249     50                        8498         if ( $EVAL_ERROR ) {
3672  ***      0                                  0            MKDEBUG && _d('Error getting chunks for', $tbl->{db}, '.', $tbl->{tbl},
3673                                                              ':', $EVAL_ERROR);
3674  ***      0                                  0            $stat_totals->{exit} |= 1;
3675  ***      0                                  0            $stats_for->{$tbl->{db}}->{$tbl->{tbl}}->{exit} |= 1;
3676  ***      0                                  0            next;
3677                                                        }
3678                                                     }
3679                                                  
3680         363                               3053      $stat_totals->{counts}->{databases} = scalar keys %seen_db;
3681         363                               2231      $stat_totals->{counts}->{tables}    = scalar @$tbls;
3682         363                               1756      $stat_totals->{counts}->{chunks}    = scalar @chunks;
3683                                                  
3684         363                               5643      return @chunks;
3685                                                  }
3686                                                  
3687                                                  # Return a list of all columns not '*' so we can build a proper
3688                                                  # "INSERT INTO tbl (cols) VALUES ..." in dump_sql_chunk().
3689                                                  # For FLOAT and DOUBLE, if lossless floating point dumps are desired,
3690                                                  # wrap the column with REPLACE(FORMAT(col, 17), ',', '').
3691                                                  sub make_col_list {
3692        1249                 1249         13306      my ( %args ) = @_;
3693        1249                               8892      my @required_args = qw(tbl_struct OptionParser Quoter);
3694        1249                               6553      foreach my $arg ( @required_args ) {
3695  ***   3747     50                       19276         die "I need a $arg argument" unless $args{$arg};
3696                                                     }
3697        1249                               6732      my ($tbl_struct, $o, $q) = @args{@required_args};
3698                                                  
3699        7344                              18373      my @cols = map {
3700        1249                               8150         my $col;
3701  ***   7344     50     33                59873         if ( $tbl_struct->{type_for}->{$_} =~ m/float|double/
3702                                                             && $o->get('lossless-floats') ) {
3703  ***      0                                  0            $col = sprintf("REPLACE(FORMAT(%s, 17), ',', '')", $q->quote($_));
3704                                                        }
3705                                                        else {
3706        7344                              29878            $col = $q->quote($_);
3707                                                        }
3708        7344                              29663         $col;
3709        1249                               4272      } @{$tbl_struct->{cols}};
3710                                                  
3711        1249                              11521      return join(',', @cols);
3712                                                  }
3713                                                  
3714                                                  sub get_chunks {
3715        1249                 1249         10324      my ( %args ) = @_;
3716        1249                               8049      my @required_args = qw(tbl dbh OptionParser TableChunker);
3717        1249                               6286      foreach my $arg ( @required_args ) {
3718  ***   4996     50                       23937         die "I need a $arg argument" unless $args{$arg};
3719                                                     }
3720        1249                               7677      my (undef, $dbh, $o, $tc) = @args{@required_args};
3721        1249                               5234      my $db         = $args{tbl}->{db};
3722        1249                               5165      my $tbl        = $args{tbl}->{tbl};
3723        1249                               5028      my $tbl_struct = $args{tbl}->{tbl_struct};
3724                                                  
3725                                                     # Decide where to store the file of chunks, which is important for resuming a
3726                                                     # dump -- the precalculated chunks must be used, not re-calculated, or
3727                                                     # resuming might go awry.
3728        1249                               6392      my $chunkfile = filename($o->get('base-dir'),
3729                                                        interp({D => $db, N => $tbl}, '%D', '%N.chunks'));
3730        1249    100                        7926      makedir($chunkfile) unless $o->get('dry-run');
3731                                                  
3732                                                     # Resume dump by reading chunk boundaries from chunk file
3733                                                     # if it already exists.
3734        1249    100    100                 7059      if ( $o->get('resume') && -f $chunkfile ) {
3735          57                                171         MKDEBUG && _d('Chunk file', $chunkfile, 'exists, using it');
3736  ***     57     50                        1254         open my $fh, "<", $chunkfile or die "Can't open $chunkfile: $OS_ERROR";
3737          57                                456         my @chunks;
3738          57                               1596         while ( my $where = <$fh> ) {
3739         684                               1824            chomp $where;
3740         684                               7581            push @chunks, {
3741                                                              D => $db,
3742                                                              N => $tbl,
3743                                                              W => $where,
3744                                                              E => $tbl_struct->{engine},
3745                                                              Z => $args{tbl}->{size},
3746                                                           };
3747                                                        };
3748  ***     57     50                         513         close $fh or die "Can't close $chunkfile: $OS_ERROR";
3749          57                                171         return @chunks;
3750                                                     }
3751                                                  
3752                                                     # By default we can't/don't chunk because --chunk-size has no default
3753                                                     # value so each table is one big chunk (1=1).
3754        1192                              14720      my $cant_chunk = {
3755                                                        D => $db,
3756                                                        N => $tbl,
3757                                                        W => '1=1',
3758                                                        E => $tbl_struct->{engine},
3759                                                        Z => $args{tbl}->{size},
3760                                                     };
3761        1192    100                        5548      return $cant_chunk unless $o->get('chunk-size');
3762                                                  
3763                                                     # Check that this table can be chunked.
3764        1147                              10354      my ($col, undef)  = $tc->get_first_chunkable_column(tbl_struct=>$tbl_struct);
3765        1147    100                        6106      return $cant_chunk unless $col;
3766        1006                               7489      my %range_stats = $tc->get_range_statistics(
3767                                                        dbh       => $dbh,
3768                                                        db        => $db,
3769                                                        tbl       => $tbl,
3770                                                        chunk_col => $col
3771                                                     );
3772        3018                              13947      return $cant_chunk
3773  ***   1006     50                        5661         if grep { !defined $range_stats{$_} } qw(min max rows_in_range);
3774                                                  
3775                                                     # Get chunk boundaries (WHERE clauses).
3776        1006                               7788      my ($rows_per_chunk, $avg_row_len) = $tc->size_to_rows(
3777                                                        dbh            => $dbh,
3778                                                        db             => $db,
3779                                                        tbl            => $tbl,
3780                                                        chunk_size     => $o->get('chunk-size'),
3781                                                        avg_row_length => 1,  # always get avg row length
3782                                                     );
3783        1006                              10078      my @chunk_boundaries = $tc->calculate_chunks(
3784                                                        dbh        => $dbh,
3785                                                        tbl_struct => $tbl_struct,
3786                                                        chunk_col  => $col,
3787                                                        chunk_size => $rows_per_chunk,
3788                                                        %range_stats,
3789                                                     );
3790        1006                               5207      my $avg_chunk_size = $rows_per_chunk * $avg_row_len;
3791        1006                               2504      MKDEBUG && _d('Rows per chunk:', $rows_per_chunk,
3792                                                        'avg row len:', $avg_row_len, 'avg chunk size:', $avg_chunk_size);
3793                                                  
3794                                                     # Write chunk boundaries to the chunk file.
3795        1006                               2574      my $fh;
3796  ***   1006     50                        6153      if ( !$o->get('dry-run') ) {
3797  ***   1006     50                       74146         open $fh, ">", $chunkfile or die "Can't open $chunkfile: $OS_ERROR";
3798                                                     }
3799                                                     my @chunks = map {
3800  ***   1006     50                        4826         if ( !$o->get('dry-run') ) {
            4834                              21180   
3801  ***   4834     50                       35930            print $fh $_, "\n" or die "Can't print to $chunkfile: $OS_ERROR";
3802                                                        }
3803                                                        {
3804        4834                              43069            D => $db,
3805                                                           N => $tbl,
3806                                                           W => $_,
3807                                                           E => $tbl_struct->{engine},
3808                                                           Z => $avg_chunk_size,
3809                                                        }
3810                                                     } @chunk_boundaries;
3811  ***   1006     50                        5933      if ( !$o->get('dry-run') ) {
3812  ***   1006     50                       37319         close $fh or die "Can't close $chunkfile: $OS_ERROR";
3813                                                     }
3814                                                  
3815        1006                               3352      return @chunks;
3816                                                  }
3817                                                  
3818                                                  # Prints a message.
3819                                                  sub info {
3820        4966                 4966         49001      my ( $o, $level, $msg ) = @_;
3821        4966    100                       24412      return if $o->get('quiet');
3822  ***   1875    100     50                 8738      print "$msg\n" if $level <= ($o->get('verbose') || 0);
3823                                                  }
3824                                                  
3825                                                  # Interpolates % directives from a db/tbl hashref, to insert % variables into
3826                                                  # arguments.  The available macros are as follows:
3827                                                  # 
3828                                                  #  MACRO  MEANING
3829                                                  #  =====  =================
3830                                                  #  %D     The database name
3831                                                  #  %N     The table name
3832                                                  #  %C     The chunk number
3833                                                  #  %W     The WHERE clause
3834                                                  #
3835                                                  # You can place a number between the % and the letter.  The macro replacement
3836                                                  # then assumes it's a digit and pads it with leading zeroes (in practice, this is
3837                                                  # only useful for %C).
3838                                                  sub interp {
3839        4909                 4909         45237      my ( $chunk, @strings ) = @_;
3840       13453    100                      195088      map {
3841        4909                              29381         $_ =~ s/%(\d+)?([SDNCW])/$1 ? sprintf("%0$1d", $chunk->{$2})
            9818                             141587   
3842                                                                                    : $chunk->{$2}/ge
3843                                                     } @strings;
3844        4909                              68358      return @strings;
3845                                                  }
3846                                                  
3847                                                  # Dump a chunk of a table.  Each table is a single chunk (1=1) unless
3848                                                  # --chunk-size is specified.
3849                                                  sub dump_chunk {
3850          86                   86          7018      my ( %args ) = @_;
3851          86                               2518      my @required_args = qw(chunk file DSNParser OptionParser Quoter MySQLDump);
3852          86                               1378      foreach my $arg ( @required_args ) {
3853  ***    516     50                        4978         die "I need a $arg argument" unless $args{$arg};
3854                                                     }
3855          86                               1070      my ($chunk, $file, $dp, $o, $q, $du) = @args{@required_args};
3856          86                               3799      my $D           = $q->quote($chunk->{D});
3857          86                               1392      my $N           = $q->quote($chunk->{N});
3858          86                                477      my $exit_status = 0;
3859                                                  
3860          86                                256      MKDEBUG && $chunk->{C} == 0 && _d('Dumping', Dumper($chunk));
3861                                                  
3862          86                                280      my $dbh;
3863  ***     86     50                        3740      if ( !$o->get('dry-run') ) {
3864          86                               4537         $dbh = $dp->get_dbh($dp->get_cxn_params($dp->parse_options($o)));
3865                                                     }
3866                                                  
3867                                                     # Dump SHOW CREATE TABLE  before the first chunk.
3868  ***     86    100     66                 2312      if ( $chunk->{C} == 0 && !$o->get('dry-run') ) {
3869          25                                103         my $ddl = $dbh->selectrow_arrayref("SHOW CREATE TABLE $D.$N")->[1];
3870  ***     25     50                        6545         if ( $ddl ) {
3871          25                                169            my $ctfile = filename($o->get('base-dir'),
3872                                                                                 interp($chunk, '%D', '00_%N.sql'));
3873  ***     25     50                        4455            open my $fh, '>', $ctfile or die "Can't open $ctfile: $OS_ERROR";
3874  ***     25     50                         362            print $fh $ddl            or die "Can't print to $ctfile: $OS_ERROR";
3875  ***     25     50                         136            close $fh                 or die "Can't close $ctfile: $OS_ERROR";
3876                                                        }
3877                                                        else {
3878  ***      0                                  0            warn "Failed to dump SHOW CREATE TABLE $D.$N";
3879  ***      0                                  0            $exit_status = 1;
3880                                                        }
3881                                                     }
3882                                                  
3883          86    100                         980      if ( $o->get('tab') ) {  # dump via SELECT INTO OUTFILE
3884  ***     11     50                         193         my $sql
3885                                                          = $o->get('csv')
3886                                                          ?    "SELECT $chunk->{L} INTO OUTFILE '$file.txt' "
3887                                                             . "FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\\\"' "
3888                                                             . "LINES TERMINATED BY '\\n' FROM $D.$N WHERE $chunk->{W}"
3889                                                          :    "SELECT $chunk->{L} INTO OUTFILE '$file.txt' "
3890                                                             . "FROM $D.$N WHERE $chunk->{W};";
3891  ***     11     50                          83         if ( $o->get('dry-run') ) {
3892  ***      0      0                           0            print $sql, "\n" unless $o->get('quiet');
3893                                                        }
3894                                                        else {
3895          11                                 55            eval {
3896          11                              12227               $dbh->do($sql);
3897                                                           };
3898  ***     11     50                         135            if ( $EVAL_ERROR ) {
3899  ***      0                                  0               warn mysql_error_msg($EVAL_ERROR) . "\n";
3900  ***      0                                  0               $exit_status |= 1;
3901                                                           }
3902                                                        }
3903                                                     }
3904                                                     else {
3905          75    100                        1665         $file = $o->get('gzip') ? "$file.sql.gz" : "$file.sql";
3906          75                                279         my $fh;
3907  ***     75     50                         368         if ( !$o->get('dry-run') ) {
3908  ***     75     50                        9646            open $fh, '>', $file or die "Cannot open $file: $OS_ERROR";
3909                                                        }
3910          75                                994         $exit_status |= dump_sql_chunk(
3911                                                           chunk   => $chunk,
3912                                                           file    => $file,
3913                                                           fh      => $fh,
3914                                                           dbh     => $dbh,
3915                                                           dry_run => $o->get('dry-run'),
3916                                                           %args
3917                                                        );
3918  ***     75     50     33                 2914         if ( $fh && !$o->get('dry-run') ) {
3919  ***     75     50                         279            close $fh or die "Cannot close $file: $OS_ERROR";
3920                                                        }
3921                                                     }
3922                                                  
3923  ***     86     50                       17376      $dbh->disconnect() if $dbh;
3924                                                  
3925          86                               6947      return $exit_status;
3926                                                  }
3927                                                  
3928                                                  sub dump_sql_chunk {
3929          75                   75          3111      my ( %args ) = @_;
3930          75                                598      my @required_args = qw(chunk file Quoter OptionParser);
3931  ***     75     50                         638      push @required_args, qw(fh dbh) unless $args{dry_run};
3932          75                                453      foreach my $arg ( @required_args ) {
3933  ***    450     50                        2134         die "I need a $arg argument" unless $args{$arg};
3934                                                     }
3935          75                               1451      my ($chunk, $file, $q, $o, $fh, $dbh) = @args{@required_args};
3936          75                               2369      my $exit_status = 0;
3937                                                  
3938                                                     # Open a compressed filehandle if --gzip.  Else, just point
3939                                                     # $zfh to non-compressed $fh.  Only use $zfh after this point.
3940                                                     # Caller closes $fh so don't close $zfh here.
3941          75                                252      my $zfh;
3942  ***     75    100     66                  350      if ( $o->get('gzip') && !$o->get('dry-run') ) {
3943          59                                254         our $GzipError;
3944  ***     59     50                        2461         $zfh = new IO::Compress::Gzip($fh)
3945                                                           or die "IO::Compress::Gzip failed: $GzipError\n";
3946                                                     }
3947                                                     else {
3948          16                                 68         $zfh = $fh;  # no compression (--no-gzip)
3949                                                     }
3950                                                  
3951          75                                908      my $tbl_struct = $chunk->{S};
3952          75                                335      my $n_cols     = scalar @{$tbl_struct->{cols}};
              75                                976   
3953          75                                682      my $db_tbl     = $q->quote($chunk->{D}, $chunk->{N});
3954          75                                341      my $tz_utc     = "/*!40103 SET TIME_ZONE='+00:00' */;";
3955          75                                987      my $sql        = "SELECT /*chunk $chunk->{C}*/ $chunk->{L} "
3956                                                                    . "FROM $db_tbl "
3957                                                                    . "WHERE  $chunk->{W};";
3958                                                  
3959                                                     # Set timezone to UTC/GMT for consistent dump/restore
3960                                                     # of TIMESTAMP columns.
3961  ***     75     50                         528      if ( $o->get('tz-utc') ) {
3962          75                                242         MKDEBUG && _d($dbh, $tz_utc);
3963  ***     75     50                         381         if ( $o->get('dry-run') ) {
3964  ***      0                                  0            print $tz_utc, "\n";
3965                                                        }
3966                                                        else {
3967          75                              22230            $dbh->do($tz_utc);
3968          75                               2309            print $zfh $tz_utc, "\n";
3969                                                        }
3970                                                     }
3971                                                  
3972                                                     # Print the SELECT chunk and return early if dry-run.  Everything
3973                                                     # below is actual data-accessing work.
3974  ***     75     50                         619      if ( $o->get('dry-run') ) {
3975  ***      0                                  0         print $sql, "\n";
3976  ***      0                                  0         return $exit_status;
3977                                                     }
3978                                                  
3979                                                     # Execute the SELECT chunk to get the rows to dump.  Don't use
3980                                                     # $dbh->selectall_arrayref() because it does not throw errors
3981                                                     # from execute, so we would miss stuff like "the table is marked
3982                                                     # as crashed".
3983          75                                286      MKDEBUG && _d($dbh, $sql);
3984          75                                309      my $rows;
3985          75                                288      eval {
3986          75                                243         my $sth = $dbh->prepare($sql);
3987          75                             177449         $sth->execute();
3988          75                             147392         $rows = $sth->fetchall_arrayref();
3989                                                     };
3990  ***     75     50                         714      if ( $EVAL_ERROR ) {
3991  ***      0                                  0         MKDEBUG && _d($dbh, $EVAL_ERROR);
3992  ***      0                                  0         $exit_status = 1;  # general error unless...
3993  ***      0      0                           0         $exit_status = 3 if $EVAL_ERROR =~ m/ crashed /;
3994  ***      0                                  0         return $exit_status;
3995                                                     }
3996                                                  
3997                                                     # Write the INSERT for the row values to the dump file, row by row.
3998                                                     # Don't build the whole INSERT else $sql may consume a lot of memory.
3999  ***     75     50                         496      if ( @$rows ) {
4000          75                               1097         $sql = "INSERT /*chunk $chunk->{C}*/ "
4001                                                             . "INTO " . $q->quote($chunk->{N}) . " ($chunk->{L}) VALUES ";
4002          75                                278         MKDEBUG && _d('Write', $sql, 'to', $file);
4003          75                                496         print $zfh $sql;
4004          75                                400         my $rowno = 0;
4005                                                        ROW:
4006          75                                428         foreach my $row ( @$rows ) {
4007                                                           COL:
4008       49090                             293777            for my $i ( 0..($n_cols-1) ) {
4009                                                              # Escape and quote column values in place (i.e. in $row).
4010      305236    100                      1077063               if ( $row->[$i] ) {
4011      303390                             1104129                  my $col = $tbl_struct->{cols}->[$i];
4012      303390    100                      1550240                  if ( !$tbl_struct->{is_numeric}->{$col} ) {
4013      113794                             432677                     $row->[$i] = q{'}.escape_string_for_mysql($row->[$i]).q{'};
4014                                                                 }
4015                                                                 # Numeric columns are not quoted.
4016                                                              }
4017                                                              else {
4018        1846    100                        9789                  $row->[$i] = defined $row->[$i] ? q{''} : 'NULL';
4019                                                              }
4020                                                           }
4021       49090    100                      304868            my $val = ($rowno++ ? ',(' : '(') . join(',', @$row) . ')';
4022       49090                             152568            print $zfh $val;
4023                                                        }
4024          75                                258         print $zfh ";\n";
4025          75                                367         MKDEBUG && _d('Dumped', $rowno, 'rows');
4026                                                     }
4027                                                     else {
4028  ***      0                                  0         MKDEBUG && _d('Empty table:', $db_tbl);
4029                                                     }
4030                                                  
4031          75                               2278      return $exit_status;
4032                                                  }
4033                                                  
4034                                                  # Perl version of escape_string_for_mysql() in mysys/charset.c.
4035                                                  sub escape_string_for_mysql {
4036      113794               113794        408974      my ( $str ) = @_;
4037  *** 113794     50                      438485      return unless $str;
4038      113794                             352970      $str =~ s/\\/\\\\/g;  # match this first
4039      113794                             303723      $str =~ s/\x00/\\0/g;
4040      113794                             300692      $str =~ s/\n/\\n/g;
4041      113794                             295657      $str =~ s/\r/\\r/g;
4042      113794                             320013      $str =~ s/(['"])/\\$1/g;
4043      113794                             313609      $str =~ s/\032/\\Z/g;
4044      113794                             670978      return $str;
4045                                                  }
4046                                                  
4047                                                  # Makes a filename.
4048                                                  sub filename {
4049        5337                 5337         51861      my ( $base_dir, @file_name ) = @_;
4050        5337                             109281      my $filename = File::Spec->catfile($base_dir, @file_name);
4051        5337                             904008      return $filename;
4052                                                  }
4053                                                  
4054                                                  {
4055                                                     # Do not memorize else tests will fail because we don't
4056                                                     # recreate dirs that the tests rm.
4057                                                  
4058                                                     # If the directory doesn't exist, makes the directory.
4059                                                     sub makedir {
4060        5300                 5300         25230         my ( $filename ) = @_;
4061        5300                             111350         my @dirs = File::Spec->splitdir(dirname($filename));
4062        5300                             1262809         foreach my $i ( 0 .. $#dirs ) {
4063       20772                             141312            my $dir = File::Spec->catdir(@dirs[0 .. $i]);
4064       20772    100                      1181103            if ( ! -d $dir ) {
4065         673                               2078               MKDEBUG && _d('mkdir', $dir);
4066  ***    673     50                       47099               mkdir($dir, 0777) or die "Failed to mkdir $dir: $OS_ERROR";
4067                                                           }
4068                                                        }
4069                                                     }
4070                                                  }
4071                                                  
4072                                                  sub dump_binlog_pos {
4073         428                  428          6016      my ( %args ) = @_;
4074         428                               3736      my @required_args = qw(dbh chunks OptionParser);
4075         428                               3336      foreach my $arg ( @required_args ) {
4076  ***   1284     50                        8640         die "I need a $arg argument" unless $args{$arg};
4077                                                     }
4078         428                               3021      my ($dbh, $chunks, $o) = @args{@required_args};
4079                                                  
4080         428                               2923      my $file = filename($o->get('base-dir'), '', '00_master_data.sql');
4081  ***    428     50                        2781      makedir($file) unless $o->get('dry-run');
4082         428                               1572      MKDEBUG && _d('Writing to', $file);
4083  ***    428     50                       28792      open my $fh, ">", $file or die "Cannot open $file: $OS_ERROR";
4084         428                               3164      my %wanted = map { $_ => 1 }
            4280                              27393   
4085                                                        qw(file position master_host master_port master_log_file
4086                                                        read_master_log_pos relay_log_file relay_log_pos
4087                                                        relay_master_log_file exec_master_log_pos);
4088                                                  
4089         428                               3338      my ( $master_pos, $slave_pos );
4090         428                               1649      eval {
4091         428                               1719         my $sql = 'SHOW MASTER STATUS';
4092         428                               1297         MKDEBUG && _d($sql);
4093         428                               1304         $master_pos = $dbh->selectrow_hashref($sql);
4094                                                     };
4095         428                               3524      eval {
4096         428                               2438         my $sql = 'SHOW SLAVE STATUS';
4097         428                               1634         MKDEBUG && _d($sql);
4098         428                               1146         $slave_pos = $dbh->selectrow_hashref($sql);
4099  ***    428      0                        1864         print $fh "CHANGE MASTER TO MASTER_HOST='$slave_pos->{master_host}', "
4100                                                           . "MASTER_LOG_FILE='$slave_pos->{relay_master_log_file}', "
4101                                                           . "MASTER_LOG_POS=$slave_pos->{exec_master_log_pos}\n"
4102                                                           or die $OS_ERROR;
4103                                                     };
4104                                                  
4105         428                               3647      foreach my $thing ( $master_pos, $slave_pos ) {
4106  ***    856     50                        4922         next unless $thing;
4107         856                               9498         foreach my $key ( grep { $wanted{$_} } sort keys %$thing ) {
            1712                               8209   
4108  ***    856     50                       13177            print $fh "-- $key $thing->{$key}\n"
4109                                                              or die $OS_ERROR;
4110                                                        }
4111                                                     }
4112                                                  
4113                                                     # Put the details of the chunks into the file.
4114         428                               2439      foreach my $chunk ( @$chunks ) {
4115  ***   5688     50                       58517         print $fh "-- CHUNK $chunk->{D} $chunk->{N} $chunk->{C} $chunk->{W}\n"
4116                                                           or die $OS_ERROR;
4117                                                     }
4118                                                  
4119  ***    428     50                       20693      close $fh or die $OS_ERROR;
4120                                                  
4121         428                               1493      return;
4122                                                  }
4123                                                  
4124                                                  sub report_stats {
4125        3470                 3470        121172      my ( %args ) = @_;
4126        3470                              26487      my @required_args = qw(chunk stat_totals stats_for fmt progress
4127                                                                            OptionParser);
4128        3470                              43264      foreach my $arg ( @required_args ) {
4129  ***  20820     50                       93360         die "I need a $arg argument" unless defined $args{$arg};
4130                                                     }
4131        3470                              40006      my ($chunk, $stat_totals, $stats_for, $fmt, $progress, $o)
4132                                                        = @args{@required_args};
4133                                                  
4134        3470                              12839      my $exit_status = $chunk->{exit};
4135                                                  
4136                                                     # Update stat totals (global stats).
4137        3470                              14622      $stat_totals->{exit} |= $exit_status;
4138                                                  
4139                                                     # Update database and table stats.
4140        3470                              18484      my $db        = $chunk->{D};
4141        3470                              11955      my $tbl       = $chunk->{N};
4142        3470                              16862      my $db_stats  = $stats_for->{$db};
4143        3470                              25595      my $tbl_stats = $stats_for->{$db}->{tables}->{$tbl};
4144        3470                              12191      foreach my $stats ( $db_stats, $tbl_stats ) {
4145        6940                              23191         $stats->{exit} |= $exit_status;
4146        6940                              39900         $stats->{chunks_left} -= 1;
4147                                                     }
4148                                                  
4149                                                     # Report completed chunk.
4150        3470           100               157415      info($o, 2, sprintf($fmt,
4151                                                        $chunk->{C},
4152                                                        sprintf('%.2f', $chunk->{time}),
4153                                                        $exit_status,
4154                                                        $chunk->{skipped} || 0,
4155                                                        "$chunk->{D}.$chunk->{N}",
4156                                                        $progress,)
4157                                                     );
4158                                                  
4159                                                     # Report completed table.
4160        3470    100                       28363      if ( !$tbl_stats->{chunks_left} ) {
4161  ***    453            50                17270         info($o, 1, sprintf($fmt,
                           100                        
4162                                                           'tbl',
4163                                                           sprintf('%.2f', time - $tbl_stats->{start_time}),
4164                                                           $tbl_stats->{exit} || 0,
4165                                                           $tbl_stats->{skipped}  || 0,
4166                                                           "$chunk->{D}.$chunk->{N}",
4167                                                           $progress,)
4168                                                        );
4169                                                     }
4170                                                  
4171                                                     # Report completed database.
4172        3470    100                       15577      if ( !$db_stats->{chunks_left} ) {
4173  ***    273            50                 7677         info($o, 0, sprintf($fmt,
                           100                        
4174                                                              'db',
4175                                                              sprintf('%.2f', time - $db_stats->{start_time}),
4176                                                              $db_stats->{exit} || 0,
4177                                                              $db_stats->{skipped}  || 0,
4178                                                              $chunk->{D},
4179                                                              $progress,)
4180                                                        );
4181                                                     }
4182                                                  
4183        3470                              19618      return;
4184                                                  }
4185                                                  
4186                                                  sub update_progress {
4187        3470                 3470         24907      my ( $o, $start, $bytes, $done ) = @_;
4188        3470                              34131      my $progress = '';
4189        3470    100                       14817      if ( $o->get('progress') ) {
4190  ***    746            50                 4434         my $pct = $done / ($bytes || 1);
4191         746                               4408         my $now = time();
4192  ***    746            50                 3809         my $remaining = ($now - $start) / ($pct || 1);
4193         746                               8305         $progress = sprintf("%s/%s %6.2f%% ETA %s (%s)",
4194                                                              shorten($done),
4195                                                              shorten($bytes),
4196                                                              $pct * 100,
4197                                                              secs_to_time($remaining),
4198                                                              ts($now + $remaining),
4199                                                           );
4200                                                     }
4201        3470                              28564      return $progress;
4202                                                  }
4203                                                  
4204                                                  sub _d {
4205  ***      0                    0                    my ($package, undef, $line) = caller 0;
4206  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4207  ***      0                                              map { defined $_ ? $_ : 'undef' }
4208                                                          @_;
4209  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4210                                                  }
4211                                                  
4212                                                  # ############################################################################
4213                                                  # Run the program.
4214                                                  # ############################################################################
4215                                                  if ( !caller ) { exit main(@ARGV); }
4216                                                  
4217                                                  1; # Because this is a module as well as a script.
4218                                                  
4219                                                  # ############################################################################
4220                                                  # Documentation.
4221                                                  # ############################################################################
4222                                                  
4223                                                  =pod
4224                                                  
4225                                                  =head1 NAME
4226                                                  
4227                                                  mk-parallel-dump - Dump MySQL tables in parallel.
4228                                                  
4229                                                  =head1 SYNOPSIS
4230                                                  
4231                                                  Dump all databases and tables to the current directory:
4232                                                  
4233                                                    mk-parallel-dump
4234                                                  
4235                                                  Dump all databases and tables via SELECT INTO OUTFILE to /tmp/dumps:
4236                                                  
4237                                                    mk-parallel-dump --tab --base-dir /tmp/dumps
4238                                                  
4239                                                  Dump only table db.foo in chunks of ten thousand rows using 8 threads:
4240                                                  
4241                                                    mk-parallel-dump --databases db --tables foo \
4242                                                       --chunk-size 10000 --threads 8
4243                                                  
4244                                                  Dump tables in chunks of approximately 10kb of data (not ten thousand rows!):
4245                                                  
4246                                                    mk-parallel-dump --chunk-size 10k
4247                                                  
4248                                                  =head1 RISKS
4249                                                  
4250                                                  The following section is included to inform users about the potential risks,
4251                                                  whether known or unknown, of using this tool.  The two main categories of risks
4252                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
4253                                                  tools) and those created by bugs.
4254                                                  
4255                                                  mk-parallel-dump is not a backup program!  It is only designed for fast data
4256                                                  exports, for purposes such as quickly loading data into test systems.  Do not
4257                                                  use mk-parallel-dump for backups.
4258                                                  
4259                                                  At the time of this release, we know of no bugs that could cause serious harm to
4260                                                  users.
4261                                                  
4262                                                  The authoritative source for updated information is always the online issue
4263                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
4264                                                  see a list of such issues at the following URL:
4265                                                  L<http://www.maatkit.org/bugs/mk-parallel-dump>.
4266                                                  
4267                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
4268                                                  
4269                                                  =head1 DESCRIPTION
4270                                                  
4271                                                  mk-parallel-dump connects to a MySQL server, finds database and table names,
4272                                                  and dumps them in parallel for speed.  Only tables and data are dumped;
4273                                                  view definitions or any kind of stored code (triggers, events, routines,
4274                                                  procedures, etc.) are not dumped.  However, if you dump the C<mysql> database,
4275                                                  you'll be dumping the stored routines anyway.
4276                                                  
4277                                                  Exit status is 0 if everything went well, 1 if any chunks failed, and any
4278                                                  other value indicates an internal error.
4279                                                  
4280                                                  To dump all tables to uncompressed text files in the current directory, each
4281                                                  database with its own directory, with a global read lock, flushing and
4282                                                  recording binary log positions, each table in a single file:
4283                                                  
4284                                                    mk-parallel-dump
4285                                                  
4286                                                  To dump tables elsewhere:
4287                                                  
4288                                                    mk-parallel-dump --base-dir /path/to/elsewhere
4289                                                  
4290                                                  To dump to tab-separated files with C<SELECT INTO OUTFILE>, each table with
4291                                                  separate data and SQL files:
4292                                                  
4293                                                    mk-parallel-dump --tab
4294                                                  
4295                                                  mk-parallel-dump doesn't clean out any destination directories before
4296                                                  dumping into them.  You can move away the old destination, then remove it
4297                                                  after a successful dump, with a shell script like the following:
4298                                                  
4299                                                     #!/bin/sh
4300                                                     CNT=`ls | grep -c old`;
4301                                                     if [ -d default ]; then mv default default.old.$CNT;
4302                                                     mk-parallel-dump
4303                                                     if [ $? != 0 ]
4304                                                     then
4305                                                        echo "There were errors, not purging old sets."
4306                                                     else
4307                                                        echo "No errors during dump, purging old sets."
4308                                                        rm -rf default.old.*
4309                                                     fi
4310                                                  
4311                                                  mk-parallel-dump checks whether files have been created before dumping.  If the
4312                                                  file has been created, it skips the table or chunk that would have created the
4313                                                  file.  This makes it possible to resume dumps.  If you don't want this behavior,
4314                                                  and instead you want a full dump, then move away the old files or specify
4315                                                  L<"--[no]resume">.
4316                                                  
4317                                                  =head1 CHUNKS
4318                                                  
4319                                                  mk-parallel-dump can break your tables into chunks when dumping, and put
4320                                                  approximately the amount of data you specify into each chunk.  This is useful
4321                                                  for two reasons:
4322                                                  
4323                                                  =over
4324                                                  
4325                                                  =item *
4326                                                  
4327                                                  A table that is dumped in chunks can be dumped in many threads simultaneously.
4328                                                  
4329                                                  =item *
4330                                                  
4331                                                  Dumping in chunks creates small files, which can be imported more efficiently
4332                                                  and safely.  Importing a single huge file can be a lot of extra work for
4333                                                  transactional storage engines like InnoDB.  A huge file can create a huge
4334                                                  rollback segment in your tablespace.  If the import fails, the rollback can take
4335                                                  a very long time.
4336                                                  
4337                                                  =back
4338                                                  
4339                                                  To dump in chunks, specify the L<"--chunk-size"> option.  This option is an
4340                                                  integer with an optional suffix.  Without the suffix, it's the number of rows
4341                                                  you want in each chunk.  With the suffix, it's the approximate size of the data.
4342                                                  
4343                                                  mk-parallel-dump tries to use index statistics to calculate where the
4344                                                  boundaries between chunks should be.  If the values are not evenly distributed,
4345                                                  some chunks can have a lot of rows, and others may have very few or even none.
4346                                                  Some chunks can exceed the size you want.
4347                                                  
4348                                                  When you specify the size with a suffix, the allowed suffixes are k, M and G,
4349                                                  for kibibytes, mebibytes, and gibibytes, respectively.  mk-parallel-dump
4350                                                  doesn't know anything about data size.  It asks MySQL (via C<SHOW TABLE STATUS>)
4351                                                  how long an average row is in the table, and converts your option to a number
4352                                                  of rows.
4353                                                  
4354                                                  Not all tables can be broken into chunks.  mk-parallel-dump looks for an
4355                                                  index whose leading column is numeric (integers, real numbers, and date and time
4356                                                  types).  It prefers the primary key if its first column is chunk-able.
4357                                                  Otherwise it chooses the first chunk-able column in the table.
4358                                                  
4359                                                  Generating a series of C<WHERE> clauses to divide a table into evenly-sized
4360                                                  chunks is difficult.  If you have any ideas on how to improve the algorithm,
4361                                                  please write to the author (see L<"BUGS">).
4362                                                  
4363                                                  =head1 OUTPUT
4364                                                  
4365                                                  Output depends on L<"--verbose">, L<"--progress">, L<"--dry-run"> and
4366                                                  L<"--quiet">.  If L<"--dry-run"> is specified mk-parallel-dump prints the
4367                                                  commands or SQL statements that it would use to dump data but it does not
4368                                                  actually dump any data.  If L<"--quiet"> is specified there is no output;
4369                                                  this overrides all other options that affect the output.
4370                                                  
4371                                                  The default output is something like the following example:
4372                                                  
4373                                                    CHUNK  TIME  EXIT  SKIPPED DATABASE.TABLE 
4374                                                       db  0.28     0        0 sakila         
4375                                                      all  0.28     0        0 -
4376                                                  
4377                                                  =over
4378                                                  
4379                                                  =item CHUNK
4380                                                  
4381                                                  The CHUNK column signifies what kind of information is in the line:
4382                                                  
4383                                                    Value  Meaning
4384                                                    =====  ========================================================
4385                                                    db     This line contains summary information about a database.
4386                                                    tbl    This line contains summary information about a table.
4387                                                    <int>  This line contains information about the Nth chunk of a
4388                                                           table.
4389                                                  
4390                                                  The types of lines you'll see depend on the L<"--chunk-size"> option and
4391                                                  L<"--verbose"> options.  mk-parallel-dump treats evrything as a chunk.  If you
4392                                                  don't specify L<"--chunk-size">, then each table is one big chunk and each
4393                                                  database is a chunk (of all its tables).  Thus, there is output for numbered
4394                                                  table chunks (L<"--chunk-size">), table chunks, and database chunks.
4395                                                  
4396                                                  =item TIME
4397                                                  
4398                                                  The TIME column shows the wallclock time elapsed while the chunk was dumped.  If
4399                                                  CHUNK is "db" or "tbl", this time is the total wallclock time elapsed for the
4400                                                  database or table.
4401                                                  
4402                                                  =item EXIT
4403                                                  
4404                                                  The EXIT column shows the exit status of the chunk.  Any non-zero exit signifies
4405                                                  an error.  The cause of errors are usually printed to STDERR.
4406                                                  
4407                                                  =item SKIPPED
4408                                                  
4409                                                  The SKIPPED column shows how many chunks were skipped.  These are not
4410                                                  errors.  Chunks are skipped if the dump can be resumed.  See L<"--[no]resume">.
4411                                                  
4412                                                  =item DATABASE.TABLE
4413                                                  
4414                                                  The DATABASE.TABLE column shows to which table the chunk belongs.  For "db"
4415                                                  chunks, this shows just the database.  Chunks are printed when they complete,
4416                                                  and this is often out of the order you'd expect.  For example, you might see a
4417                                                  chunk for db1.table_1, then a chunk for db2.table_2, then another chunk for
4418                                                  db1.table_1, then the "db" chunk summary for db2.
4419                                                  
4420                                                  =item PROGRESS
4421                                                  
4422                                                  If you specify L<"--progress">, then the tool adds a PROGRESS column after
4423                                                  DATABASE.TABLE, which contains text similar to the following:
4424                                                  
4425                                                    PROGRESS
4426                                                    4.10M/4.10M 100.00% ETA ... 00:00 (2009-10-16T15:37:49)
4427                                                    done at 2009-10-16T15:37:48, 1 databases, 16 tables, 16 chunks
4428                                                  
4429                                                  This column shows information about the amount of data dumped so far, the
4430                                                  amount of data left to dump, and an ETA ("estimated time of arrival").  The ETA
4431                                                  is a best-effort prediction when everything will be finished dumping.  Sometimes
4432                                                  the ETA is very accurate, but at other times it can be significantly wrong.
4433                                                  
4434                                                  =back
4435                                                  
4436                                                  The final line of the output is special: it summarizes all chunks (all table
4437                                                  chunks, tables and databases).
4438                                                  
4439                                                  If you specify L<"--verbose"> once, then the output includes "tbl" CHUNKS:
4440                                                  
4441                                                    CHUNK  TIME  EXIT  SKIPPED DATABASE.TABLE 
4442                                                      tbl  0.07     0        0 sakila.payment 
4443                                                      tbl  0.08     0        0 sakila.rental  
4444                                                      tbl  0.03     0        0 sakila.film    
4445                                                       db  0.28     0        0 sakila         
4446                                                      all  0.28     0        0 -
4447                                                  
4448                                                  And if you specify L<"--verbose"> twice in conjunction with L<"--chunk-size">,
4449                                                  then the ouput includes the chunks:
4450                                                  
4451                                                    CHUNK  TIME  EXIT  SKIPPED DATABASE.TABLE       
4452                                                        0  0.03     0        0 sakila.payment       
4453                                                        1  0.03     0        0 sakila.payment      
4454                                                      tbl  0.10     0        0 sakila.payment
4455                                                        0  0.01     0        1 sakila.store         
4456                                                      tbl  0.02     0        1 sakila.store         
4457                                                       db  0.20     0        1 sakila               
4458                                                      all  0.21     0        1 -               
4459                                                  
4460                                                  The output shows that C<sakila.payment> was dumped in two chunks, and
4461                                                  C<sakila.store> was dumped in one chunk that was skipped.
4462                                                  
4463                                                  =head1 SPEED OF PARALLEL DUMPS
4464                                                  
4465                                                  How much faster is it to dump in parallel?  That depends on your hardware and
4466                                                  data.  You may be able dump files twice as fast, or more if you have lots of
4467                                                  disks and CPUs.  At the time of writing, no benchmarks exist for the current
4468                                                  release.  User-contributed results for older versions of mk-parallel-dump showed
4469                                                  very good speedup depending on the hardware.  Here are two links you can use as
4470                                                  reference: 
4471                                                  
4472                                                  =over
4473                                                  
4474                                                  =item *
4475                                                  
4476                                                  L<http://www.paragon-cs.com/wordpress/?p=52>
4477                                                  
4478                                                  =item *
4479                                                  
4480                                                  L<http://mituzas.lt/2009/02/03/mydumper/>
4481                                                  
4482                                                  =back
4483                                                  
4484                                                  =head1 OPTIONS
4485                                                  
4486                                                  L<"--lock-tables"> and L<"--[no]flush-lock"> are mutually exclusive.
4487                                                  
4488                                                  =over
4489                                                  
4490                                                  =item --ask-pass
4491                                                  
4492                                                  Prompt for a password when connecting to MySQL.
4493                                                  
4494                                                  =item --base-dir
4495                                                  
4496                                                  type: string
4497                                                  
4498                                                  The base directory in which files will be stored.
4499                                                  
4500                                                  The default is the current working directory.  Each database gets its own
4501                                                  directory under the base directory.  So if the base directory is C</tmp>
4502                                                  and database C<foo> is dumped, then the directory C</tmp/foo> is created which
4503                                                  contains all the table dump files for C<foo>.
4504                                                  
4505                                                  =item --[no]biggest-first
4506                                                  
4507                                                  default: yes
4508                                                  
4509                                                  Process tables in descending order of size (biggest to smallest).
4510                                                  
4511                                                  This strategy gives better parallelization.  Suppose there are 8 threads and
4512                                                  the last table is huge.  We will finish everything else and then be running
4513                                                  single-threaded while that one finishes.  If that one runs first, then we will
4514                                                  have the max number of threads running at a time for as long as possible.
4515                                                  
4516                                                  =item --[no]bin-log-position
4517                                                  
4518                                                  default: yes
4519                                                  
4520                                                  Dump the master/slave position.
4521                                                  
4522                                                  Dump binary log positions from both C<SHOW MASTER STATUS> and C<SHOW SLAVE
4523                                                  STATUS>, whichever can be retrieved from the server.  The data is dumped to a
4524                                                  file named F<00_master_data.sql> in the C<"--base-dir">.
4525                                                  
4526                                                  The file also contains details of each table dumped, including the WHERE clauses
4527                                                  used to dump it in chunks.
4528                                                  
4529                                                  =item --charset
4530                                                  
4531                                                  short form: -A; type: string
4532                                                  
4533                                                  Default character set.  If the value is utf8, sets Perl's binmode on
4534                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
4535                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
4536                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
4537                                                  connecting to MySQL.
4538                                                  
4539                                                  =item --chunk-size
4540                                                  
4541                                                  type: string
4542                                                  
4543                                                  Number of rows or data size to dump per file.
4544                                                  
4545                                                  Specifies that the table should be dumped in segments of approximately the size
4546                                                  given.  The syntax is either a plain integer, which is interpreted as a number
4547                                                  of rows per chunk, or an integer with a suffix of G, M, or k, which is
4548                                                  interpreted as the size of the data to be dumped in each chunk.  See L<"CHUNKS">
4549                                                  for more details.
4550                                                  
4551                                                  =item --config
4552                                                  
4553                                                  type: Array
4554                                                  
4555                                                  Read this comma-separated list of config files; if specified, this must be the
4556                                                  first option on the command line.
4557                                                  
4558                                                  =item --csv
4559                                                  
4560                                                  Do L<"--tab"> dump in CSV format (implies L<"--tab">).
4561                                                  
4562                                                  Changes L<"--tab"> options so the dump file is in comma-separated values
4563                                                  (CSV) format.  The SELECT INTO OUTFILE statement looks like the following, and
4564                                                  can be re-loaded with the same options:
4565                                                  
4566                                                     SELECT * INTO OUTFILE %D.%N.%6C.txt
4567                                                     FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"'
4568                                                     LINES TERMINATED BY '\n' FROM %D.%N;
4569                                                  
4570                                                  =item --databases
4571                                                  
4572                                                  short form: -d; type: hash
4573                                                  
4574                                                  Dump only this comma-separated list of databases.
4575                                                  
4576                                                  =item --databases-regex
4577                                                  
4578                                                  type: string
4579                                                  
4580                                                  Dump only databases whose names match this Perl regex.
4581                                                  
4582                                                  =item --defaults-file
4583                                                  
4584                                                  short form: -F; type: string
4585                                                  
4586                                                  Only read mysql options from the given file.  You must give an absolute
4587                                                  pathname.
4588                                                  
4589                                                  =item --dry-run
4590                                                  
4591                                                  Print commands instead of executing them.
4592                                                  
4593                                                  =item --engines
4594                                                  
4595                                                  short form: -e; type: hash
4596                                                  
4597                                                  Dump only tables that use this comma-separated list of storage engines.
4598                                                  
4599                                                  =item --[no]flush-lock
4600                                                  
4601                                                  Use C<FLUSH TABLES WITH READ LOCK>.
4602                                                  
4603                                                  This is enabled by default.  The lock is taken once, at the beginning of the
4604                                                  whole process and is released after all tables have been dumped.  If you want
4605                                                  to lock only the tables you're dumping, use L<"--lock-tables">.  
4606                                                  
4607                                                  =item --flush-log
4608                                                  
4609                                                  Execute C<FLUSH LOGS> when getting binlog positions.
4610                                                  
4611                                                  This option is NOT enabled by default because it causes the MySQL server to
4612                                                  rotate its error log, potentially overwriting error messages.
4613                                                  
4614                                                  =item --[no]gzip
4615                                                  
4616                                                  default: yes
4617                                                  
4618                                                  Compress (gzip) SQL dump files; does not work with L<"--format"> tab.
4619                                                  
4620                                                  The IO::Compress::Gzip Perl module is used to compress SQL dump files
4621                                                  as they are written to disk.  The resulting dump files have a C<.gz>
4622                                                  extension, like C<table.000000.sql.gz>.  They can be uncompressed with
4623                                                  L<gzip>.  L<mk-parallel-restore> will automatically uncompress them, too,
4624                                                  when restoring.
4625                                                  
4626                                                  This option does not work with L<"--format"> tab because the MySQL server
4627                                                  writes the tab dump files directly using C<SELECT INTO OUTFILE>.
4628                                                  
4629                                                  =item --help
4630                                                  
4631                                                  Show help and exit.
4632                                                  
4633                                                  =item --host
4634                                                  
4635                                                  short form: -h; type: string
4636                                                  
4637                                                  Connect to host.
4638                                                  
4639                                                  =item --ignore-databases
4640                                                  
4641                                                  type: Hash
4642                                                  
4643                                                  Ignore this comma-separated list of databases.
4644                                                  
4645                                                  =item --ignore-databases-regex
4646                                                  
4647                                                  type: string
4648                                                  
4649                                                  Ignore databases whose names match this Perl regex.
4650                                                  
4651                                                  =item --ignore-engines
4652                                                  
4653                                                  type: Hash; default: FEDERATED,MRG_MyISAM
4654                                                  
4655                                                  Do not dump tables that use this comma-separated list of storage engines.
4656                                                  
4657                                                  The schema file will be dumped as usual.  This prevents dumping data for
4658                                                  Federated tables and Merge tables.
4659                                                  
4660                                                  =item --ignore-tables
4661                                                  
4662                                                  type: Hash
4663                                                  
4664                                                  Ignore this comma-separated list of table names.
4665                                                  
4666                                                  Table names may be qualified with the database name.
4667                                                  
4668                                                  =item --ignore-tables-regex
4669                                                  
4670                                                  type: string
4671                                                  
4672                                                  Ignore tables whose names match the Perl regex.
4673                                                  
4674                                                  =item --lock-tables
4675                                                  
4676                                                  Use C<LOCK TABLES> (disables L<"--[no]flush-lock">).
4677                                                  
4678                                                  Disables L<"--[no]flush-lock"> (unless it was explicitly set) and locks tables
4679                                                  with C<LOCK TABLES READ>.  The lock is taken and released for every table as
4680                                                  it is dumped.
4681                                                  
4682                                                  =item --lossless-floats
4683                                                  
4684                                                  Dump float types with extra precision for lossless restore (requires L<"--tab">).
4685                                                  
4686                                                  Wraps these types with a call to C<FORMAT()> with 17 digits of precision.
4687                                                  According to the comments in Google's patches, this will give lossless dumping
4688                                                  and reloading in most cases.  (I shamelessly stole this technique from them.  I
4689                                                  don't know enough about floating-point math to have an opinion).
4690                                                  
4691                                                  This works only with L<"--tab">.
4692                                                  
4693                                                  =item --password
4694                                                  
4695                                                  short form: -p; type: string
4696                                                  
4697                                                  Password to use when connecting.
4698                                                  
4699                                                  =item --pid
4700                                                  
4701                                                  type: string
4702                                                  
4703                                                  Create the given PID file.  The file contains the process ID of the script.
4704                                                  The PID file is removed when the script exits.  Before starting, the script
4705                                                  checks if the PID file already exists.  If it does not, then the script creates
4706                                                  and writes its own PID to it.  If it does, then the script checks the following:
4707                                                  if the file contains a PID and a process is running with that PID, then
4708                                                  the script dies; or, if there is no process running with that PID, then the
4709                                                  script overwrites the file with its own PID and starts; else, if the file
4710                                                  contains no PID, then the script dies.
4711                                                  
4712                                                  =item --port
4713                                                  
4714                                                  short form: -P; type: int
4715                                                  
4716                                                  Port number to use for connection.
4717                                                  
4718                                                  =item --progress
4719                                                  
4720                                                  Display progress reports.
4721                                                  
4722                                                  Progress is displayed each time a table or chunk of a table finishes dumping.
4723                                                  Progress is calculated by measuring the average data size of each full chunk
4724                                                  and assuming all bytes are created equal.  The output is the completed and
4725                                                  total bytes, the percent completed, estimated time remaining, and estimated
4726                                                  completion time.  For example:
4727                                                  
4728                                                    40.72k/112.00k  36.36% ETA 00:00 (2009-10-27T19:17:53)
4729                                                  
4730                                                  If L<"--chunk-size"> is not specified then each table is effectively one big
4731                                                  chunk and the progress reports are pretty accurate.  When L<"--chunk-size">
4732                                                  is specified the progress reports can be skewed because of averaging.
4733                                                  
4734                                                  Progress reports are inaccurate when a dump is resumed.  This is known issue
4735                                                  and will be fixed in a later release.
4736                                                  
4737                                                  =item --quiet
4738                                                  
4739                                                  short form: -q
4740                                                  
4741                                                  Quiet output; disables L<"--verbose">.
4742                                                  
4743                                                  =item --[no]resume
4744                                                  
4745                                                  default: yes
4746                                                  
4747                                                  Resume dumps.
4748                                                  
4749                                                  =item --set-vars
4750                                                  
4751                                                  type: string; default: wait_timeout=10000
4752                                                  
4753                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
4754                                                  will be appended to SET and executed.
4755                                                  
4756                                                  =item --socket
4757                                                  
4758                                                  short form: -S; type: string
4759                                                  
4760                                                  Socket file to use for connection.
4761                                                  
4762                                                  =item --stop-slave
4763                                                  
4764                                                  Issue C<STOP SLAVE> on server before dumping data.
4765                                                  
4766                                                  This ensures that the data is not changing during the dump.  Issues C<START
4767                                                  SLAVE> after the dump is complete.
4768                                                  
4769                                                  If the slave is not running, throws an error and exits.  This is to prevent
4770                                                  possibly bad things from happening if the slave is not running because of a
4771                                                  problem, or because someone intentionally stopped the slave for maintenance or
4772                                                  some other purpose.
4773                                                  
4774                                                  =item --tab
4775                                                  
4776                                                  Dump tab-separated (sets L<"--umask"> 0).
4777                                                  
4778                                                  Dump via C<SELECT INTO OUTFILE>, which is similar to what C<mysqldump> does with
4779                                                  the L<"--tab"> option, but you're not constrained to a single database at a
4780                                                  time.
4781                                                  
4782                                                  Before you use this option, make sure you know what C<SELECT INTO OUTFILE> does!
4783                                                  I recommend using it only if you're running mk-parallel-dump on the same
4784                                                  machine as the MySQL server, but there is no protection if you don't.
4785                                                  
4786                                                  This option sets L<"--umask"> to zero so auto-created directories are writable
4787                                                  by the MySQL server.
4788                                                  
4789                                                  =item --tables
4790                                                  
4791                                                  short form: -t; type: hash
4792                                                  
4793                                                  Dump only this comma-separated list of table names.
4794                                                  
4795                                                  Table names may be qualified with the database name.
4796                                                  
4797                                                  =item --tables-regex
4798                                                  
4799                                                  type: string
4800                                                  
4801                                                  Dump only tables whose names match this Perl regex.
4802                                                  
4803                                                  =item --threads
4804                                                  
4805                                                  type: int; default: 2
4806                                                  
4807                                                  Number of threads to dump concurrently.
4808                                                  
4809                                                  Specifies the number of parallel processes to run.  The default is 2 (this is
4810                                                  mk-parallel-dump, after all -- 1 is not parallel).  On GNU/Linux machines,
4811                                                  the default is the number of times 'processor' appears in F</proc/cpuinfo>.  On
4812                                                  Windows, the default is read from the environment.  In any case, the default is
4813                                                  at least 2, even when there's only a single processor.
4814                                                  
4815                                                  =item --[no]tz-utc
4816                                                  
4817                                                  default: yes
4818                                                  
4819                                                  Enable TIMESTAMP columns to be dumped and reloaded between different time zones. 
4820                                                  mk-parallel-dump sets its connection time zone to UTC and adds
4821                                                  C<SET TIME_ZONE='+00:00'> to the dump file.  Without this option, TIMESTAMP
4822                                                  columns are dumped and reloaded in the time zones local to the source and
4823                                                  destination servers, which can cause the values to change.  This option also
4824                                                  protects against changes due to daylight saving time.
4825                                                  
4826                                                  This option is identical to C<mysqldump --tz-utc>.  In fact, the above text
4827                                                  was copied from mysqldump's man page.
4828                                                  
4829                                                  =item --umask
4830                                                  
4831                                                  type: string
4832                                                  
4833                                                  Set the program's C<umask> to this octal value.
4834                                                  
4835                                                  This is useful when you want created files and directories to be readable or
4836                                                  writable by other users (for example, the MySQL server itself).
4837                                                  
4838                                                  =item --user
4839                                                  
4840                                                  short form: -u; type: string
4841                                                  
4842                                                  User for login if not current user.
4843                                                  
4844                                                  =item --verbose
4845                                                  
4846                                                  short form: -v; cumulative: yes
4847                                                  
4848                                                  Be verbose; can specify multiple times.
4849                                                  
4850                                                  See L<"OUTPUT">.
4851                                                  
4852                                                  =item --version
4853                                                  
4854                                                  Show version and exit.
4855                                                  
4856                                                  =item --wait
4857                                                  
4858                                                  short form: -w; type: time; default: 5m
4859                                                  
4860                                                  Wait limit when the server is down.
4861                                                  
4862                                                  If the MySQL server crashes during dumping, waits until the server comes back
4863                                                  and then continues with the rest of the tables.  C<mk-parallel-dump> will
4864                                                  check the server every second until this time is exhausted, at which point it
4865                                                  will give up and exit.
4866                                                  
4867                                                  This implements Peter Zaitsev's "safe dump" request: sometimes a dump on a
4868                                                  server that has corrupt data will kill the server.  mk-parallel-dump will
4869                                                  wait for the server to restart, then keep going.  It's hard to say which table
4870                                                  killed the server, so no tables will be retried.  Tables that were being
4871                                                  concurrently dumped when the crash happened will not be retried.  No additional
4872                                                  locks will be taken after the server restarts; it's assumed this behavior is
4873                                                  useful only on a server you're not trying to dump while it's in production.
4874                                                  
4875                                                  =back
4876                                                  
4877                                                  =head1 DOWNLOADING
4878                                                  
4879                                                  You can download Maatkit from Google Code at
4880                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
4881                                                  easily with a command like the following:
4882                                                  
4883                                                     wget http://www.maatkit.org/get/toolname
4884                                                     or
4885                                                     wget http://www.maatkit.org/trunk/toolname
4886                                                  
4887                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
4888                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
4889                                                  needed.  The first URL gets the latest released version of the tool, and the
4890                                                  second gets the latest trunk code from Subversion.
4891                                                  
4892                                                  =head1 ENVIRONMENT
4893                                                  
4894                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
4895                                                  the Maatkit tools:
4896                                                  
4897                                                     MKDEBUG=1 mk-....
4898                                                  
4899                                                  =head1 SYSTEM REQUIREMENTS
4900                                                  
4901                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
4902                                                  installed in any reasonably new version of Perl.
4903                                                  
4904                                                  This program works best on GNU/Linux.  Filename quoting might not work well on
4905                                                  Microsoft Windows if you have spaces or funny characters in your database or
4906                                                  table names.
4907                                                  
4908                                                  =head1 BUGS
4909                                                  
4910                                                  For a list of known bugs see L<http://www.maatkit.org/bugs/mk-parallel-dump>.
4911                                                  
4912                                                  Please use Google Code Issues and Groups to report bugs or request support:
4913                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
4914                                                  discuss Maatkit.
4915                                                  
4916                                                  Please include the complete command-line used to reproduce the problem you are
4917                                                  seeing, the version of all MySQL servers involved, the complete output of the
4918                                                  tool when run with L<"--version">, and if possible, debugging output produced by
4919                                                  running with the C<MKDEBUG=1> environment variable.
4920                                                  
4921                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
4922                                                  
4923                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
4924                                                  Feedback and improvements are welcome.
4925                                                  
4926                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
4927                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
4928                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
4929                                                  
4930                                                  This program is free software; you can redistribute it and/or modify it under
4931                                                  the terms of the GNU General Public License as published by the Free Software
4932                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
4933                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
4934                                                  licenses.
4935                                                  
4936                                                  You should have received a copy of the GNU General Public License along with
4937                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
4938                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
4939                                                  
4940                                                  =head1 SEE ALSO
4941                                                  
4942                                                  See also L<mk-parallel-restore>.
4943                                                  
4944                                                  =head1 AUTHOR
4945                                                  
4946                                                  Baron Schwartz
4947                                                  
4948                                                  =head1 ABOUT MAATKIT
4949                                                  
4950                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
4951                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
4952                                                  code contributors.  Both are employed by Percona.  Financial support for
4953                                                  Maatkit development is primarily provided by Percona and its clients. 
4954                                                  
4955                                                  =head1 VERSION
4956                                                  
4957                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5530 $.
4958                                                  
4959                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
103          100    428   2356   if (@_ > 2)
112   ***     50      0    614   if (not $dsn)
124   ***     50    914      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
136   ***     50      0   4912   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
142          100   3998    914   if (not defined $final_props{$key})
149   ***     50      0    914   unless exists $opts{$key}
152   ***     50      0    614   if (my $required = $self->prop('required'))
154   ***      0      0      0   unless $final_props{$key}
163   ***     50      0    514   unless ref $o eq 'OptionParser'
166          100   3598    514   if $o->has($_)
176   ***      0      0      0   unless ref $dsn
177   ***      0      0      0   $_ eq 'p' ? :
178   ***      0      0      0   if defined $$dsn{$_}
191   ***      0      0      0   $opts{$key}{'copy'} ? :
205   ***     50      0    614   if ($driver eq 'Pg') { }
237   ***     50      0    614   $cxn_string =~ /charset=utf8/ ? :
246   ***     50      0    614   if (not $have_dbi)
265   ***     50    614      0   if ($cxn_string =~ /mysql/i)
273   ***     50      0    614   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
278   ***      0      0      0   if ($charset eq 'utf8') { }
279   ***      0      0      0   unless binmode STDOUT, ':utf8'
283   ***      0      0      0   unless binmode STDOUT
287          100    514    100   if ($self->prop('set-vars'))
294   ***     50      0    614   if (not $dbh and $EVAL_ERROR)
296   ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
309   ***      0      0      0   if (not $tries)
331   ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
348   ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
358   ***      0      0      0   unless $dsn_1
359   ***      0      0      0   unless $dsn_2
363   ***      0      0      0   if ($args{'overwrite'}) { }
364   ***      0      0      0   defined $$dsn_1{$key} ? :
367   ***      0      0      0   defined $$dsn_2{$key} ? :
376   ***      0      0      0   defined $_ ? :
416   ***     50      0    429   unless $args{$arg}
422          100    428      1   exists $args{'strict'} ? :
465   ***     50      0    429   unless open my $fh, '<', $file
485          100 247533    429   unless $para =~ /^=head1 OPTIONS/
490          100    429    429   if $para =~ /^=over/
498   ***     50      0    429   unless $para
501          100  18876    429   if (my($option) = $para =~ /^=item --(.*)/)
508          100  13728   5148   if ($para =~ /: /) { }
512   ***     50      0  20592   unless $attributes{$attrib}
516          100   5577   8151   if ($attribs{'short form'})
532   ***     50      0  18876   if $para =~ /^=item/
534          100   2574  16302   if (my($base_option) = $option =~ /^\[no\](.*)/)
539          100   5577  13299   $attribs{'short form'} ? :
             100   2574  16302   $attribs{'negatable'} ? :
             100    429  18447   $attribs{'cumulative'} ? :
             100  10725   8151   $attribs{'type'} ? :
             100   3861  15015   $attribs{'default'} ? :
      ***     50      0  18876   $attribs{'group'} ? :
551   ***     50      0  33462   unless $para
554          100    429  33033   if ($para =~ /^=head1/)
558          100  18876  14157   if $para =~ /^=item --/
562   ***     50      0    429   unless @specs
573          100  18876    429   if (ref $opt) { }
578   ***     50      0  18876   if (not $long)
583   ***     50      0  18876   if exists $$self{'opts'}{$long}
586   ***     50      0  18876   if (length $long == 1)
591          100   5577  13299   if ($short) { }
592   ***     50      0   5577   if exists $$self{'short_opts'}{$short}
601          100   2574  16302   $$opt{'spec'} =~ /!/ ? :
602          100    429  18447   $$opt{'spec'} =~ /\+/ ? :
603   ***     50      0  18876   $$opt{'desc'} =~ /required/ ? :
615   ***     50      0  18876   if ($type and $type eq 'd' and not $$self{'dp'})
620          100   3432  15444   if $type and $type =~ /[HhAadzm]/
622          100   3861  15015   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
623   ***     50   3861      0   defined $def ? :
627          100    429  18447   if ($long eq 'config')
631          100    858  18018   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
644   ***     50    429      0   if ($opt =~ /mutually exclusive|one and only one/)
649   ***     50      0    429   if ($opt =~ /at least one|one and only one/)
654   ***     50      0    429   if ($opt =~ /default to/)
659   ***     50      0    429   if ($opt =~ /restricted to option groups/)
669   ***     50      0    429   unless $rule_ok
686   ***     50      0   1716   unless exists $$self{'opts'}{$long}
710   ***      0      0      0   unless exists $$self{'opts'}{$long}
730   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50   2742      0   exists $$self{'opts'}{$opt} ? :
735   ***     50      0   2742   if ($$opt{'is_cumulative'}) { }
750          100    430  14190   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100   4300  14620   exists $$self{'defaults'}{$long} ? :
759   ***     50      0    430   if (@ARGV and $ARGV[0] eq '--config')
763   ***     50    430      0   if ($self->has('config'))
769   ***     50   1720      0   if ($EVAL_ERROR)
770   ***     50      0   1720   $self->got('config') ? :
785   ***     50      0    430   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
788   ***     50      0    430   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
789   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
795   ***     50      0    430   if (@ARGV and $$self{'strict'})
801   ***     50      0    430   if (@set > 1)
812   ***      0      0      0   if (@set == 0)
822          100   2742  16178   if ($$opt{'got'}) { }
      ***     50      0  16178   elsif ($$opt{'is_required'}) { }
823          100    137   2605   if (exists $$self{'disables'}{$long})
830   ***     50      0   2742   if (exists $$self{'allowed_groups'}{$long})
842   ***      0      0      0   if $restricted_opt eq $long
843   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
848   ***      0      0      0   if (@restricted_opts)
850   ***      0      0      0   if (@restricted_opts == 1) { }
879          100   8170  10750   unless $opt and $$opt{'type'}
882          100    430  10320   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0  10320   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0  10320   elsif ($val and $$opt{'type'} eq 'z') { }
             100   1879   8441   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100    430   8011   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
885   ***     50      0    430   if (not $suffix)
891   ***     50    430      0   if ($suffix =~ /[smhd]/) { }
892   ***      0      0      0   $suffix eq 'h' ? :
      ***     50    430      0   $suffix eq 'm' ? :
      ***     50      0    430   $suffix eq 's' ? :
907   ***      0      0      0   if ($from_key)
918   ***      0      0      0   if (defined $num) { }
919   ***      0      0      0   if ($factor)
946          100   4112  74202   length $opt == 1 ? :
947   ***     50      0  78314   unless $long and exists $$self{'opts'}{$long}
954   ***     50      0   2369   length $opt == 1 ? :
955   ***     50      0   2369   unless $long and exists $$self{'opts'}{$long}
962          100   4112   4282   length $opt == 1 ? :
963          100   7880    514   defined $long ? :
968   ***     50      0   1077   length $opt == 1 ? :
969   ***     50      0   1077   unless $long and exists $$self{'opts'}{$long}
1003  ***     50      0    428   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0    428   elsif (scalar @{$$self{'errors'};}) { }
1004  ***      0      0      0   unless print $self->print_usage
1008  ***      0      0      0   unless print $self->print_errors
1017  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1026  ***      0      0      0   unless $$self{'got_opts'}
1029  ***      0      0      0   $$_{'is_negatable'} ? :
1033  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1049  ***      0      0      0   $group eq 'default' ? :
1055  ***      0      0      0   $$opt{'is_negatable'} ? :
1058  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1067  ***      0      0      0   if ($short) { }
1076  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1080  ***      0      0      0   if ($$self{'dp'})
1088  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1100  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1103  ***      0      0      0   unless print $prompt
1111  ***      0      0      0   unless print "\n"
1114  ***      0      0      0   if ($EVAL_ERROR)
1136  ***     50   1720      0   unless open my $fh, '<', $filename
1144  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1147  ***      0      0      0   if ($line eq '--')
1152  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1170  ***      0      0      0   unless open my $fh, '<', $file
1174  ***      0      0      0   unless $para =~ /^=pod$/m
1178  ***      0      0      0   unless $para =~ /$regex/
1183  ***      0      0      0   unless close $fh
1197  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1212  ***      0      0      0   defined $_ ? :
1244  ***     50      0    429   unless $args{$arg}
1253  ***     50      0   1237   unless $ddl
1254  ***     50   1237      0   if (ref $ddl eq 'ARRAY')
1255  ***     50   1237      0   if (lc $$ddl[0] eq 'table') { }
1265  ***     50      0   1237   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
1271  ***     50   1237      0   if $name
1289  ***     50      0   7344   unless $type
1291         100   3916   3428   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
1295         100   1907   5437   if (not $def =~ /NOT NULL/)
1299         100    925   6419   $def =~ /AUTO_INCREMENT/i ? :
1330  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1344  ***      0      0      0   if ($index)
1347  ***      0      0      0   if (not $best)
1348  ***      0      0      0   if ($index) { }
1361  ***      0      0      0   unless $where
1367  ***      0      0      0   if ($$expl{'possible_keys'}) { }
1371  ***      0      0      0   if ($$expl{'key'})
1391  ***      0      0      0   unless $args{$arg}
1405  ***      0      0      0   if ($EVAL_ERROR)
1409  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
1415  ***      0      0      0   unless $args{'all_privs'}
1422  ***      0      0      0   if ($EVAL_ERROR)
1426  ***      0      0      0   if (not scalar keys %$row)
1437  ***      0      0      0   $EVAL_ERROR ? :
1442  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
1468  ***     50      0   3016   if $key =~ /FOREIGN/
1473  ***     50   3016      0   if (not $engine =~ /MEMORY|HEAP/)
1480  ***     50      0   3016   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
1487         100   1210   1806   $key =~ /PRIMARY|UNIQUE/ ? :
1511         100   1039   1977   if ($engine =~ /InnoDB/i and not $clustered_key)
1513  ***     50   1039      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
1537  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
1566  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
1580  ***      0      0      0   if (@sec_indexes)
1597  ***      0      0      0   defined $_ ? :
1647  ***     50      0    429   unless defined $args{'cache'}
1655  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
1657  ***      0      0      0   unless $ddl
1658  ***      0      0      0   if ($$ddl[0] eq 'table') { }
1672  ***      0      0      0   if ($trgs and @$trgs) { }
1675  ***      0      0      0   if ($$trg{'sql_mode'})
1679  ***      0      0      0   if ($$trg{'definer'})
1711         100    360   2114   if (not $new)
1718         100   1754    360   if ($curr and $new and $curr eq $new)
1730  ***     50   1237      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
1743  ***     50      0   1237   if ($EVAL_ERROR)
1753  ***     50   1237      0   if ($key) { }
1769  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
1799  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
1812  ***      0      0      0   if ($sth->rows)
1825  ***      0      0      0   if ($tbl)
1833  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
1836  ***      0      0      0   if ($like)
1844  ***      0      0      0   unless $like
1852  ***     50   2242      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
1855  ***     50   2242      0   if ($like)
1870  ***     50      0   2242   unless $like
1878  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
1881  ***      0      0      0   if ($like)
1889  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
1896  ***      0      0      0   unless $like
1904  ***      0      0      0   defined $_ ? :
1937  ***     50      0    858   unless $args{$arg}
1952  ***     50      0   1147   unless $args{$arg}
1959         100     57   2654   unless $$index{'type'} eq 'BTREE'
1963  ***     50      0   2654   if ($args{'exact'})
1964  ***      0      0      0   unless $$index{'is_unique'} and @{$$index{'cols'};} == 1
1977         100    265   2389   unless $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
1983  ***     50      0   1147   if $args{'exact'} and scalar @candidate_cols
1993         100   1006    141   if ($$tbl_struct{'keys'}{'PRIMARY'})
2016  ***     50      0   8048   unless defined $args{$arg}
2027  ***     50   1006      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type eq 'timestamp') { }
      ***      0      0      0   elsif ($col_type eq 'date') { }
      ***      0      0      0   elsif ($col_type eq 'time') { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
2059  ***     50      0   1006   if (not defined $start_point)
2063  ***     50      0   1006   if (not defined $end_point or $end_point < $start_point)
2072  ***     50   1006      0   if ($int_types{$col_type})
2076  ***     50      0   1006   if ($args{'exact'})
2082  ***     50   1006      0   if ($start_point < $end_point) { }
2088         100   1006   3828   if ($iter++ == 0) { }
2098         100    379    627   if (@chunks) { }
2102  ***     50      0    627   $nullable ? :
2104  ***     50      0   1006   if ($nullable)
2120  ***     50      0   1147   unless $args{$arg}
2130  ***     50      0   4024   unless $args{$arg}
2139  ***     50      0   1006   if ($suffix) { }
      ***     50   1006      0   elsif ($num) { }
2140  ***      0      0      0   $suffix eq 'M' ? :
      ***      0      0      0   $suffix eq 'k' ? :
2152  ***     50   1006      0   if ($suffix or $args{'avg_row_length'})
2155  ***     50      0   1006   if (not defined $n_rows)
2156  ***      0      0      0   $avg_row_length ? :
2160  ***     50   1006      0   wantarray ? :
2167  ***     50      0   4024   unless $args{$arg}
2172  ***     50      0   1006   $where ? :
2180  ***     50      0   1006   if ($EVAL_ERROR)
2182  ***      0      0      0   if ($EVAL_ERROR =~ /in your SQL syntax/) { }
2189  ***     50      0   1006   $where ? :
2202  ***     50      0   9041   $val =~ /\d[:-]/ ? :
2208  ***      0      0      0   unless defined $args{$arg}
2217  ***      0      0      0   if ($args{'where'} and grep {$_;} @{$args{'where'};})
2240  ***     50      0   4834   if $start =~ /e/
2241  ***     50      0   4834   if $end =~ /e/
2246  ***     50   4834      0   if ($end > $start) { }
2292  ***      0      0      0   unless $check eq $time
2303  ***      0      0      0   defined $_ ? :
2343  ***      0      0      0   unless defined $val
2344  ***      0      0      0   if $val eq ''
2346  ***      0      0      0   if (not defined $is_numeric)
2347  ***      0      0      0   $val =~ /^0|\D/ ? :
2350  ***      0      0      0   if $is_numeric
2360  ***     50   1237      0   if (not $tbl)
2369  ***      0      0      0   unless $like
2416  ***      0      0      0   defined $args{'p_ms'} ? :
2417  ***      0      0      0   defined $args{'p_s'} ? :
2420  ***      0      0      0   if $t < 0
2422  ***      0      0      0   if $t =~ /e/
2426  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
2447  ***      0      0      0   $p ? :
2454  ***     50      0    746   unless $secs
2456  ***     50      0    746   $secs >= 3600 ? :
      ***     50      0    746   $secs >= 86400 ? :
2461  ***     50      0    746   $fmt eq 'h' ? :
      ***     50      0    746   $fmt eq 'd' ? :
2480  ***     50      0   1492   defined $args{'p'} ? :
2481  ***     50      0   1492   defined $args{'d'} ? :
2488  ***     50   1492      0   $num =~ /\./ || $n ? :
2497  ***     50      0    817   $gmt ? :
2503  ***     50    817      0   if (my($us) = $time =~ /(\.\d+)$/)
2513  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
2516  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
2525  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
2526  ***      0      0      0   $gmt ? :
2529  ***      0      0      0   if (defined $us)
2541  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
2542  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
2552  ***      0      0      0   unless $hms
2557  ***      0      0      0   unless $hms
2562  ***      0      0      0   if $callback and ref $callback eq 'CODE'
2578  ***      0      0      0   defined $_ ? :
2614  ***      0      0      0   defined $_ ? :
2625  ***     50    428      0   if ($sys_info or open $cpuinfo, '<', '/proc/cpuinfo')
2629  ***     50    428      0   if $cpuinfo
2632  ***     50    428      0   if $n_cpus
2636  ***      0      0      0   if ($sys_info or $OSNAME =~ /freebsd/i or $OSNAME =~ /darwin/i)
2639  ***      0      0      0   if $contents
2641  ***      0      0      0   if $n_cpus
2672  ***      0      0      0   unless $args{$arg}
2675  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
2691  ***      0      0      0   unless defined(my $pid = fork)
2692  ***      0      0      0   if ($pid)
2699  ***      0      0      0   unless POSIX::setsid()
2700  ***      0      0      0   unless chdir '/'
2706  ***      0      0      0   if (-t STDIN)
2708  ***      0      0      0   unless open STDIN, '/dev/null'
2712  ***      0      0      0   if ($$self{'log_file'}) { }
2714  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
2718  ***      0      0      0   unless open STDERR, '>&STDOUT'
2722  ***      0      0      0   if (-t STDOUT)
2724  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
2727  ***      0      0      0   if (-t STDERR)
2729  ***      0      0      0   unless open STDERR, '>', '/dev/null'
2740  ***      0      0      0   $self ? :
2742  ***      0      0      0   if ($PID_file and -f $PID_file) { }
2745  ***      0      0      0   if $EVAL_ERROR
2747  ***      0      0      0   if ($pid) { }
2749  ***      0      0      0   if ($pid_is_alive) { }
2771  ***      0      0      0   if (exists $$self{'child'})
2783  ***      0      0      0   if (not $PID_file)
2790  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
2792  ***      0      0      0   unless print $PID_FH $PID
2794  ***      0      0      0   unless close $PID_FH
2803  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
2804  ***      0      0      0   unless unlink $$self{'PID_file'}
2816  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
2822  ***      0      0      0   defined $_ ? :
2853  ***     50      0    428   unless $args{$arg}
2872  ***     50    428      0   if $o->has('databases')
2874  ***     50    428      0   if $o->has('ignore-databases')
2877  ***     50      0    428   if ($o->has('databases-regex') and my $p = $o->get('databases-regex'))
2881  ***     50      0    428   if ($o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex'))
2885  ***     50    428      0   if (@permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex)
2886  ***     50    428      0   @permit_dbs ? :
      ***     50      0    428   @reject_dbs ? :
      ***     50      0    428   @dbs_regex ? :
      ***     50      0    428   @reject_dbs_regex ? :
2895  ***     50    428      0   if ($o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex'))
2905         100    161    267   if ($o->get('tables'))
2908  ***     50      0    183   if ($_ =~ /\./) { }
2918  ***     50      0    161   if (@permit_qtbls)
2928  ***     50    428      0   if ($o->get('ignore-tables'))
2931  ***      0      0      0   if ($_ =~ /\./) { }
2941  ***     50      0    428   if (@reject_qtbls and not $have_qtbl)
2947  ***     50      0    428   if (keys %permit_qtbls and not @permit_dbs)
2955  ***      0      0      0   if (keys %$dbs)
2962  ***     50      0    428   if ($o->has('tables-regex') and my $p = $o->get('tables-regex'))
2966  ***     50      0    428   if ($o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex'))
2975  ***     50    428      0   if ($o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines'))
2994  ***     50    428      0   if (@permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs)
2996         100    161    267   @permit_tbls ? :
      ***     50      0    428   @reject_tbls ? :
      ***     50      0    428   @tbls_regex ? :
      ***     50      0    428   @reject_tbls_regex ? :
      ***     50      0    428   @permit_qtbls ? :
      ***     50      0    428   @reject_qtbls ? :
      ***     50    428      0   @get_eng ? :
      ***     50      0    428   @permit_engs ? :
      ***     50    428      0   @reject_engs ? :
3017  ***     50      0    428   unless my $filter_sub = eval $code
3034  ***     50      0    428   unless $args{$arg}
3043  ***     50   1968      0   $filter ? :
3045         100    428   1540   if $_ =~ /information_schema|lost\+found/
3060  ***     50      0    856   unless $args{$arg}
3066  ***     50    428      0   if ($db) { }
3076  ***     50   5365      0   $filter ? :
3077  ***     50   5365      0   if (not $views)
3078         100   1595   3770   if ($type || '') eq 'VIEW'
3098         100   1017   1873   if (scalar keys %$objs)
3099         100    787    611   $lc ? :
3108  ***      0      0      0   defined $_ ? :
3170  ***     50    428      0   unless $o->got('threads')
3178  ***     50    428      0   if (not $o->get('help'))
3179  ***     50      0    428   if (not $o->get('threads'))
3183  ***     50      0    428   if (not $o->get('help') and $o->get('lossless-floats') and not $o->get('tab'))
3188  ***     50      0    428   if ($o->get('csv'))
3192         100    221    207   if ($o->get('tab'))
3193  ***     50    221      0   unless $o->got('umask')
3196  ***     50      0    428   if ($o->get('umask'))
3200  ***     50      0    428   if ($o->get('gzip') and not $can_gzip)
3211  ***     50      0    428   if ($o->get('pid'))
3222  ***     50      0    428   if ($o->get('ask-pass'))
3234  ***     50      0    428   if ($o->get('stop-slave') and not $o->get('dry-run'))
3239  ***      0      0      0   if (($slave_running || '') ne 'ON')
3250  ***     50      0    428   if ($o->get('flush-lock') and not $o->get('dry-run'))
3304  ***     50      0   1236   if (not $tbl_struct)
3320  ***     50   1236      0   if ($o->get('biggest-first') or $o->get('progress'))
3325  ***     50      0   1236   if ($EVAL_ERROR)
3343         100    359    877   if length $db > $maxdb
3344         100    609    627   if length $tbl > $maxtbl
3351  ***     50    428      0   if ($o->get('biggest-first'))
3374  ***     50      0    428   if ($o->get('flush-log') and not $o->get('dry-run'))
3379  ***     50    428      0   if ($o->get('bin-log-position') and not $o->get('dry-run'))
3390  ***     50      0    428   ($o->get('verbose') || 0) > 1 ? :
3391  ***     50    428      0   if $db_tbl_width < 14
3393         100     81    347   $o->get('progress') ? :
3430  ***      0      0      0   if ($EVAL_ERROR)
3435  ***     50      0   9053   if ($tries >= $o->get('wait'))
3444  ***     50   3635      0   unless $o->get('dry-run')
3449         100    359   3276   if $$chunk{'first_tbl_in_db'}
3451         100    557   3078   if $$chunk{'C'} == 0
3456         100    288   3347   if ($o->get('resume') and -f "$file.sql" || -f "$file.sql.gz")
3482  ***     50      0   3347   if ($$chunk{'C'} == 0 and $o->get('lock-tables') and not $o->get('dry-run'))
3492  ***      0      0      0   if $EVAL_ERROR
3496  ***     50      0   3347   unless defined $pid
3497         100   3261     86   if ($pid) { }
3520  ***     50      0   3182   if ($$chunk{'last_chunk_in_tbl'} and $o->get('lock-tables') and not $o->get('dry-run'))
3529  ***      0      0      0   if $EVAL_ERROR
3548         100   5785   3182   if (not $reaped)
3560  ***     50    342      0   if (not $o->get('dry-run'))
3570  ***     50      0    342   if ($o->get('stop-slave') and not $o->get('dry-run'))
3580         100     71    271   if ($o->get('progress'))
3613  ***     50      0   3024   unless $args{$arg}
3617         100     69    363   if (scalar @$tbls == 0)
3649         100    365   5339   if not $seen_db{$$chunk{'D'}}++
3671  ***     50      0   1249   if ($EVAL_ERROR)
3695  ***     50      0   3747   unless $args{$arg}
3701  ***     50      0   7344   if ($$tbl_struct{'type_for'}{$_} =~ /float|double/ and $o->get('lossless-floats')) { }
3718  ***     50      0   4996   unless $args{$arg}
3730         100   1237     12   unless $o->get('dry-run')
3734         100     57   1192   if ($o->get('resume') and -f $chunkfile)
3736  ***     50      0     57   unless open my $fh, '<', $chunkfile
3748  ***     50      0     57   unless close $fh
3761         100     45   1147   unless $o->get('chunk-size')
3765         100    141   1006   unless $col
3773  ***     50      0   1006   if grep {not defined $range_stats{$_};} 'min', 'max', 'rows_in_range'
3796  ***     50   1006      0   if (not $o->get('dry-run'))
3797  ***     50      0   1006   unless open $fh, '>', $chunkfile
3800  ***     50   4834      0   if (not $o->get('dry-run'))
3801  ***     50      0   4834   unless print $fh $_, "\n"
3811  ***     50   1006      0   if (not $o->get('dry-run'))
3812  ***     50      0   1006   unless close $fh
3821         100   3091   1875   if $o->get('quiet')
3822         100    780   1095   if $level <= ($o->get('verbose') || 0)
3840         100   3635   9818   $1 ? :
3853  ***     50      0    516   unless $args{$arg}
3863  ***     50     86      0   if (not $o->get('dry-run'))
3868         100     25     61   if ($$chunk{'C'} == 0 and not $o->get('dry-run'))
3870  ***     50     25      0   if ($ddl) { }
3873  ***     50      0     25   unless open my $fh, '>', $ctfile
3874  ***     50      0     25   unless print $fh $ddl
3875  ***     50      0     25   unless close $fh
3883         100     11     75   if ($o->get('tab')) { }
3884  ***     50      0     11   $o->get('csv') ? :
3891  ***     50      0     11   if ($o->get('dry-run')) { }
3892  ***      0      0      0   unless $o->get('quiet')
3898  ***     50      0     11   if ($EVAL_ERROR)
3905         100     59     16   $o->get('gzip') ? :
3907  ***     50     75      0   if (not $o->get('dry-run'))
3908  ***     50      0     75   unless open $fh, '>', $file
3918  ***     50     75      0   if ($fh and not $o->get('dry-run'))
3919  ***     50      0     75   unless close $fh
3923  ***     50     86      0   if $dbh
3931  ***     50     75      0   unless $args{'dry_run'}
3933  ***     50      0    450   unless $args{$arg}
3942         100     59     16   if ($o->get('gzip') and not $o->get('dry-run')) { }
3944  ***     50      0     59   unless $zfh = 'IO::Compress::Gzip'->new($fh)
3961  ***     50     75      0   if ($o->get('tz-utc'))
3963  ***     50      0     75   if ($o->get('dry-run')) { }
3974  ***     50      0     75   if ($o->get('dry-run'))
3990  ***     50      0     75   if ($EVAL_ERROR)
3993  ***      0      0      0   if $EVAL_ERROR =~ / crashed /
3999  ***     50     75      0   if (@$rows) { }
4010         100 303390   1846   if ($$row[$i]) { }
4012         100 113794 189596   if (not $$tbl_struct{'is_numeric'}{$col})
4018         100    653   1193   defined $$row[$i] ? :
4021         100  49015     75   $rowno++ ? :
4037  ***     50      0 113794   unless $str
4064         100    673  20099   if (not -d $dir)
4066  ***     50      0    673   unless mkdir $dir, 511
4076  ***     50      0   1284   unless $args{$arg}
4081  ***     50    428      0   unless $o->get('dry-run')
4083  ***     50      0    428   unless open my $fh, '>', $file
4099  ***      0      0      0   unless print $fh "CHANGE MASTER TO MASTER_HOST='$$slave_pos{'master_host'}', " . "MASTER_LOG_FILE='$$slave_pos{'relay_master_log_file'}', " . "MASTER_LOG_POS=$$slave_pos{'exec_master_log_pos'}\n"
4106  ***     50      0    856   unless $thing
4108  ***     50      0    856   unless print $fh "-- $key $$thing{$key}\n"
4115  ***     50      0   5688   unless print $fh "-- CHUNK $$chunk{'D'} $$chunk{'N'} $$chunk{'C'} $$chunk{'W'}\n"
4119  ***     50      0    428   unless close $fh
4129  ***     50      0  20820   unless defined $args{$arg}
4160         100    453   3017   if (not $$tbl_stats{'chunks_left'})
4172         100    273   3197   if (not $$db_stats{'chunks_left'})
4189         100    746   2724   if ($o->get('progress'))
4206  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
1961  ***     33   2939      0   0
1983  ***     50   1147      0   $args{'exact'} and scalar @candidate_cols

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
136   ***     66    914   3998      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33   4912      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
258   ***     66    614      0    614   not $dbh and $tries--
294   ***     33    614      0      0   not $dbh and $EVAL_ERROR
615   ***     66   8151  10725      0   $type and $type eq 'd'
      ***     33  18876      0      0   $type and $type eq 'd' and not $$self{'dp'}
620          100   8151   7293   3432   $type and $type =~ /[HhAadzm]/
759   ***     33      0    430      0   @ARGV and $ARGV[0] eq '--config'
788   ***     33      0    430      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
795   ***     33    430      0      0   @ARGV and $$self{'strict'}
879   ***     66      0   8170  10750   $opt and $$opt{'type'}
882          100   6736   3584    430   $val and $$opt{'type'} eq 'm'
      ***     66   6736   3584      0   $val and $$opt{'type'} eq 'd'
      ***     66   6736   3584      0   $val and $$opt{'type'} eq 'z'
             100   5876   2565    589   defined $val and $$opt{'type'} eq 'h'
      ***     66   5876   2135      0   defined $val and $$opt{'type'} eq 'a'
947   ***     33      0      0  78314   $long and exists $$self{'opts'}{$long}
955   ***     33      0      0   2369   $long and exists $$self{'opts'}{$long}
969   ***     33      0      0   1077   $long and exists $$self{'opts'}{$long}
1058  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1152  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1442  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
1480  ***     33   3016      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33   3016      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
1511         100    114   1863   1039   $engine =~ /InnoDB/i and not $clustered_key
1513  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
1537  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
1672  ***      0      0      0      0   $trgs and @$trgs
1718  ***     66    360      0   1754   $curr and $new
      ***     66    360      0   1754   $curr and $new and $curr eq $new
1964  ***      0      0      0      0   $$index{'is_unique'} and @{$$index{'cols'};} == 1
2217  ***      0      0      0      0   $args{'where'} and grep {$_;} @{$args{'where'};}
2426  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
2484  ***     66   1492      0   1492   $num >= $d and $n < @units - 1
2562  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
2742  ***      0      0      0      0   $PID_file and -f $PID_file
2803  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2877  ***     33      0    428      0   $o->has('databases-regex') and my $p = $o->get('databases-regex')
2881  ***     33      0    428      0   $o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex')
2941  ***     33    428      0      0   @reject_qtbls and not $have_qtbl
2947  ***     33    428      0      0   keys %permit_qtbls and not @permit_dbs
2962  ***     33      0    428      0   $o->has('tables-regex') and my $p = $o->get('tables-regex')
2966  ***     33      0    428      0   $o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex')
2975  ***     33      0    428      0   $o->has('engines') and $o->get('engines')
      ***     33      0      0    428   $o->has('ignore-engines') and $o->get('ignore-engines')
3183  ***     33      0    428      0   not $o->get('help') and $o->get('lossless-floats')
      ***     33    428      0      0   not $o->get('help') and $o->get('lossless-floats') and not $o->get('tab')
3200  ***     66    367     61      0   $o->get('gzip') and not $can_gzip
3234  ***     33    428      0      0   $o->get('stop-slave') and not $o->get('dry-run')
3250  ***     33    428      0      0   $o->get('flush-lock') and not $o->get('dry-run')
3374  ***     33    428      0      0   $o->get('flush-log') and not $o->get('dry-run')
3379  ***     33      0      0    428   $o->get('bin-log-position') and not $o->get('dry-run')
3425  ***     33   9053      0      0   not $dbh->ping and $tries++ < $o->get('wait')
3440         100   1158   7809   3635   @chunks and keys %kids < $o->get('threads')
3456  ***     66      0   3347    288   $o->get('resume') and -f "$file.sql" || -f "$file.sql.gz"
3482  ***     66   2814    533      0   $$chunk{'C'} == 0 and $o->get('lock-tables')
      ***     33   3347      0      0   $$chunk{'C'} == 0 and $o->get('lock-tables') and not $o->get('dry-run')
3520  ***     66   2753    429      0   $$chunk{'last_chunk_in_tbl'} and $o->get('lock-tables')
      ***     33   3182      0      0   $$chunk{'last_chunk_in_tbl'} and $o->get('lock-tables') and not $o->get('dry-run')
3570  ***     33    342      0      0   $o->get('stop-slave') and not $o->get('dry-run')
3701  ***     33   7344      0      0   $$tbl_struct{'type_for'}{$_} =~ /float|double/ and $o->get('lossless-floats')
3734         100     13   1179     57   $o->get('resume') and -f $chunkfile
3868  ***     66     61      0     25   $$chunk{'C'} == 0 and not $o->get('dry-run')
3918  ***     33      0      0     75   $fh and not $o->get('dry-run')
3942  ***     66     16      0     59   $o->get('gzip') and not $o->get('dry-run')

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
46    ***     50      0    102   $ENV{'MKDEBUG'} || 0
117   ***     50      0    614   $prev ||= {}
118   ***     50      0    614   $defaults ||= {}
191   ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
204   ***     50      0    614   $self->prop('dbidriver') || ''
208   ***      0      0      0   $$info{'D'} || ''
214   ***     50      0    614   $$info{'D'} || ''
236          100    100    514   $opts ||= {}
331   ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
347   ***      0      0      0   $level ||= 0
348   ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
400   ***     50      0    102   $ENV{'MKDEBUG'} || 0
419   ***     33    429      0   0
420   ***     50    429      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
422          100    428      1   $args{'prompt'} || '<options>'
      ***     50      0    429   $args{'dp'} || undef
464          100      1    428   $file ||= '/home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump'
605   ***     50  18876      0   $$opt{'group'} ||= 'default'
887   ***      0      0      0   $s || 's'
896   ***     50      0    430   $prefix || ''
924   ***      0      0      0   $pre || ''
931          100   1019    860   $val || ''
934   ***     50    430      0   $val || ''
992   ***      0      0      0   $$self{'description'} || ''
1060  ***      0      0      0   $s ||= 's'
1086  ***      0      0      0   $$opt{'type'} || ''
1237  ***     50      0    102   $ENV{'MKDEBUG'} || 0
1456  ***     50   2474      0   $engine || undef
1479         100     57   2959   $type || $special || 'BTREE'
1566  ***      0      0      0   $$tbl_struct{'engine'} || ''
1568  ***      0      0      0   $clustered_key ||= ''
1619  ***     50      0    102   $ENV{'MKDEBUG'} || 0
1866  ***     33   2242      0   0
1889  ***      0      0      0   $$_[1] || ''
1932  ***     50      0    102   $ENV{'MKDEBUG'} || 0
2075  ***     33   1006      0   0
2223  ***      0      0      0   $args{'index_hint'} || ''
2325  ***     50      0    102   $ENV{'MKDEBUG'} || 0
2392  ***     50      0    102   $ENV{'MKDEBUG'} || 0
2446  ***      0      0      0   $args{'p'} || 0
2448  ***      0      0      0   $of ||= 1
2453  ***     50    746      0   $secs ||= 0
2456  ***     33      0    746   0
2610  ***     50      0    102   $ENV{'MKDEBUG'} || 0
2646  ***      0      0      0   $n_cpus || 1
2667  ***     50      0    102   $ENV{'MKDEBUG'} || 0
2848  ***     50      0    102   $ENV{'MKDEBUG'} || 0
3078  ***     50   5365      0   $type || ''
3149  ***     50      0    102   $ENV{'MKDEBUG'} || 0
3239  ***      0      0      0   $slave_running || ''
3331  ***     50   1236      0   $tbl_stats[0]{'data_length'} || 0
3332  ***     50   1236      0   $tbl_stats[0]{'data_length'} || 0
3390  ***     50      0    428   $o->get('verbose') || 0
3457  ***     50    288      0   $$chunk{'Z'} || 0
3532  ***     50   3182      0   $$chunk{'Z'} || 0
3586  ***     50      0    342   $stat_totals{'exit'} || 0
             100      1    341   $stat_totals{'skipped'} || 0
3595  ***     50      0    342   $stat_totals{'exit'} || 0
3822  ***     50      0   1875   $o->get('verbose') || 0
4150         100    288   3182   $$chunk{'skipped'} || 0
4161  ***     50      0    453   $$tbl_stats{'exit'} || 0
             100     24    429   $$tbl_stats{'skipped'} || 0
4173  ***     50      0    273   $$db_stats{'exit'} || 0
             100      1    272   $$db_stats{'skipped'} || 0
4190  ***     50    746      0   $bytes || 1
4192  ***     50    746      0   $pct || 1

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
227   ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
228   ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
229   ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
230   ***      0      0      0      0   $$dsn{'u'} ||= $user
231   ***      0      0      0      0   $$dsn{'D'} ||= $db
420   ***     33    429      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33    429      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
882          100   1290    589   8441   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66    430      0   8011   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1330  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1409  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
1430  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
1479  ***     66      0     57   2959   $type || $special
1730  ***     33   1237      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
1769  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
1799  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
1833  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
1852  ***     33   2242      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***     33   2242      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
1866  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
1878  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
1977  ***     66   2389      0    265   $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2063  ***     33      0      0   1006   not defined $end_point or $end_point < $start_point
2152  ***     33      0   1006      0   $suffix or $args{'avg_row_length'}
2488  ***     66    746    746      0   $num =~ /\./ || $n
2625  ***     33      0    428      0   $sys_info or open $cpuinfo, '<', '/proc/cpuinfo'
2627  ***     33      0    428      0   $sys_info || <$cpuinfo>
2636  ***      0      0      0      0   $sys_info or $OSNAME =~ /freebsd/i
      ***      0      0      0      0   $sys_info or $OSNAME =~ /freebsd/i or $OSNAME =~ /darwin/i
2637  ***      0      0      0      0   $sys_info || `sysctl hw.ncpu`
2644  ***      0      0      0      0   $n_cpus ||= $ENV{'NUMBER_OF_PROCESSORS'}
2816  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2885  ***     33    428      0      0   @permit_dbs or @reject_dbs
      ***     33    428      0      0   @permit_dbs or @reject_dbs or @dbs_regex
      ***     33    428      0      0   @permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex
2895  ***     33    428      0      0   $o->has('tables') or $o->has('ignore-tables')
      ***     33    428      0      0   $o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex')
2975  ***     33      0    428      0   $o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines')
2994  ***     66    161      0    267   @permit_tbls or @reject_tbls
      ***     66    161      0    267   @permit_tbls or @reject_tbls or @tbls_regex
      ***     66    161      0    267   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex
      ***     66    161      0    267   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs
      ***     66    161    267      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs
3320  ***     33   1236      0      0   $o->get('biggest-first') or $o->get('progress')
3422         100   8168    885    342   @chunks or %kids
3456  ***     66    288      0   3347   -f "$file.sql" || -f "$file.sql.gz"


Covered Subroutines
-------------------

Subroutine                  Count Location                                                       
-------------------------- ------ ---------------------------------------------------------------
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1229
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1230
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1231
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1232
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1237
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1614
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1615
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1617
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1619
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1919
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1920
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1924
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1925
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1926
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1927
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1932
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:22  
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:23  
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2318
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2319
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2323
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2325
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2386
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2387
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2388
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2389
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2390
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2392
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2596
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2597
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2599
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2610
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2661
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2662
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2664
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2665
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2667
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2839
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2840
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2842
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2843
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2848
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3130
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3131
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3132
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3133
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3134
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3135
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3136
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3149
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:34  
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:35  
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:36  
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:37  
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:393 
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:394 
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:396 
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:397 
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:398 
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:400 
BEGIN                         102 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:46  
__ANON__                      856 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3052
__ANON__                     1664 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3091
__ANON__                     4328 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3412
__ANON__                     2742 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:783 
_get_participants            1287 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:683 
_make_filter                 2890 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3096
_parse_specs                  429 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:569 
_pod_to_specs                 429 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:463 
_read_config_file            1720 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1135
_set_option                  2742 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:729 
_use_db                      2474 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1710
_validate_type              18920 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:878 
calculate_chunks             1006 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2013
chunk_tables                  432 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3609
dump_binlog_pos               428 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:4073
dump_chunk                     86 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3850
dump_sql_chunk                 75 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3929
escape_string_for_mysql    113794 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:4036
filename                     5337 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:4049
find_chunk_columns           1147 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1950
get                         78314 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:945 
get_chunks                   1249 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3715
get_create_table             1237 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1729
get_cxn_params                614 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:201 
get_db_itr                    428 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3031
get_dbh                       614 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:235 
get_defaults_files            429 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:458 
get_engine                   2474 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1453
get_first_chunkable_column   1147 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2118
get_keys                     1237 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1460
get_number_of_cpus            428 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2621
get_opts                      430 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:746 
get_range_statistics         1006 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2164
get_specs                     429 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:451 
get_table_status             2242 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1851
get_tbl_itr                   428 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3057
got                          2369 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:953 
has                          8394 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:961 
info                         4966 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3820
interp                       4909 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3839
main                          428 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3154
make_col_list                1249 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3692
make_filter                   428 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2864
makedir                      5300 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:4060
new                           429 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1241
new                           429 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1646
new                           429 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1935
new                           429 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2328
new                           428 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2851
new                           429 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:414 
new                           528 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:49  
parse                         614 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:111 
parse                        1237 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1252
parse_options                 514 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:162 
prop                         2784 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:102 
quote                        9041 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2201
quote                       16963 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2333
range_num                    4834 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2236
report_stats                 3470 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:4125
secs_to_time                  746 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2452
set                          1077 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:967 
set_filter                    428 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3024
shorten                      1492 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2479
size_to_rows                 1006 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2127
split_unquote                1237 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2357
ts                            817 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2496
update_progress              3470 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:4187
usage_or_errors               428 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1002

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                                       
-------------------------- ------ ---------------------------------------------------------------
DESTROY                         0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2815
_d                              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1211
_d                              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1596
_d                              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1903
_d                              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2302
_d                              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2577
_d                              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2613
_d                              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2821
_d                              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3107
_d                              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:375 
_d                              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:4205
_make_PID_file                  0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2780
_remove_PID_file                0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2802
any_unix_timestamp              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2539
as_string                       0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:175 
check_PID_file                  0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2739
check_table                     0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1388
clone                           0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1188
copy                            0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:357 
daemonize                       0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2688
descr                           0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:991 
disconnect                      0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:340 
dump                            0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1653
errors                          0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:981 
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:223 
find_best_index                 0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1342
find_possible_keys              0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1360
get_columns                     0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1767
get_databases                   0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1832
get_defaults                    0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:719 
get_fks                         0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1527
get_groups                      0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:724 
get_hostname                    0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:330 
get_table_list                  0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1877
get_tmp_table                   0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1787
get_triggers                    0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1798
inject_chunks                   0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2206
literal_like                    0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2368
make_PID_file                   0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2770
make_checksum                   0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2570
micro_t                         0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2415
mysql_error_msg                 0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:3603
new                             0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2670
opts                            0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:695 
parse_timestamp                 0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2512
percentage_of                   0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2445
print_active_handles            0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:346 
print_errors                    0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1015
print_usage                     0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1025
prompt                          0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:986 
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1100
quote_val                       0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2341
range_date                      0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2262
range_datetime                  0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2269
range_time                      0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2255
range_timestamp                 0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2277
read_para_after                 0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1169
remove_auto_increment           0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1556
remove_secondary_indexes        0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1562
save_error                      0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:976 
set_defaults                    0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:707 
short_opts                      0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:701 
sort_indexes                    0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:1323
timestampdiff                   0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2284
unix_timestamp                  0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:2524
usage                           0 /home/daniel/dev/maatkit/mk-parallel-dump/mk-parallel-dump:184 


