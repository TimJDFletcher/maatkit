---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...ndex-usage/mk-index-usage   44.6   25.3   24.9   61.8    n/a  100.0   38.5
Total                          44.6   25.3   24.9   61.8    n/a  100.0   38.5
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun  8 16:13:15 2010
Finish:       Tue Jun  8 16:13:15 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Jun  8 16:13:17 2010
Finish:       Tue Jun  8 16:13:18 2010

/home/daniel/dev/maatkit/mk-index-usage/mk-index-usage

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2010-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             1                    1             8   use strict;
               1                                  2   
               1                                  6   
21             1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 6369 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # DSNParser package 6366
29                                                    # This package is a copy without comments from the original.  The original
30                                                    # with comments and its test file can be found in the SVN repository at,
31                                                    #   trunk/common/DSNParser.pm
32                                                    #   trunk/common/t/DSNParser.t
33                                                    # See http://code.google.com/p/maatkit/wiki/Developers for more information.
34                                                    # ###########################################################################
35                                                    package DSNParser;
36                                                    
37             1                    1             6   use strict;
               1                                  2   
               1                                  5   
38             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
39             1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
40             1                    1             7   use Data::Dumper;
               1                                  3   
               1                                  7   
41                                                    $Data::Dumper::Indent    = 0;
42                                                    $Data::Dumper::Quotekeys = 0;
43                                                    
44                                                    eval {
45                                                       require DBI;
46                                                    };
47                                                    my $have_dbi = $EVAL_ERROR ? 0 : 1;
48                                                    
49    ***      1            50      1             8   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 15   
50                                                    
51                                                    sub new {
52             7                    7            90      my ( $class, %args ) = @_;
53             7                                 63      foreach my $arg ( qw(opts) ) {
54    ***      7     50                          72         die "I need a $arg argument" unless $args{$arg};
55                                                       }
56             7                                 48      my $self = {
57                                                          opts => {}  # h, P, u, etc.  Should come from DSN OPTIONS section in POD.
58                                                       };
59             7                                 31      foreach my $opt ( @{$args{opts}} ) {
               7                                 55   
60    ***     57     50     33                  608         if ( !$opt->{key} || !$opt->{desc} ) {
61    ***      0                                  0            die "Invalid DSN option: ", Dumper($opt);
62                                                          }
63                                                          MKDEBUG && _d('DSN option:',
64                                                             join(', ',
65            57                                150               map { "$_=" . (defined $opt->{$_} ? ($opt->{$_} || '') : 'undef') }
66                                                                   keys %$opt
67                                                             )
68                                                          );
69    ***     57            50                  661         $self->{opts}->{$opt->{key}} = {
70                                                             dsn  => $opt->{dsn},
71                                                             desc => $opt->{desc},
72                                                             copy => $opt->{copy} || 0,
73                                                          };
74                                                       }
75             7                                184      return bless $self, $class;
76                                                    }
77                                                    
78                                                    sub prop {
79            33                   33           185      my ( $self, $prop, $value ) = @_;
80            33    100                         169      if ( @_ > 2 ) {
81             6                                 15         MKDEBUG && _d('Setting', $prop, 'property');
82             6                                 27         $self->{$prop} = $value;
83                                                       }
84            33                                248      return $self->{$prop};
85                                                    }
86                                                    
87                                                    sub parse {
88             7                    7           166      my ( $self, $dsn, $prev, $defaults ) = @_;
89    ***      7     50                          37      if ( !$dsn ) {
90    ***      0                                  0         MKDEBUG && _d('No DSN to parse');
91    ***      0                                  0         return;
92                                                       }
93             7                                 17      MKDEBUG && _d('Parsing', $dsn);
94    ***      7            50                   42      $prev     ||= {};
95    ***      7            50                   36      $defaults ||= {};
96             7                                 23      my %given_props;
97             7                                 23      my %final_props;
98             7                                 31      my $opts = $self->{opts};
99                                                    
100            7                                 55      foreach my $dsn_part ( split(/,/, $dsn) ) {
101   ***     10     50                         129         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
102           10                                 69            $given_props{$prop_key} = $prop_val;
103                                                         }
104                                                         else {
105   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
106   ***      0                                  0            $given_props{h} = $dsn_part;
107                                                         }
108                                                      }
109                                                   
110            7                                 48      foreach my $key ( keys %$opts ) {
111           57                                135         MKDEBUG && _d('Finding value for', $key);
112           57                                221         $final_props{$key} = $given_props{$key};
113   ***     57     50     66                  609         if (   !defined $final_props{$key}
      ***                   33                        
114                                                              && defined $prev->{$key} && $opts->{$key}->{copy} )
115                                                         {
116   ***      0                                  0            $final_props{$key} = $prev->{$key};
117   ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
118                                                         }
119           57    100                         262         if ( !defined $final_props{$key} ) {
120           47                                170            $final_props{$key} = $defaults->{$key};
121           47                                148            MKDEBUG && _d('Copying value for', $key, 'from defaults');
122                                                         }
123                                                      }
124                                                   
125            7                                 38      foreach my $key ( keys %given_props ) {
126   ***     10     50                          57         die "Unknown DSN option '$key' in '$dsn'.  For more details, "
127                                                               . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
128                                                               . "for complete documentation."
129                                                            unless exists $opts->{$key};
130                                                      }
131   ***      7     50                          38      if ( (my $required = $self->prop('required')) ) {
132   ***      0                                  0         foreach my $key ( keys %$required ) {
133   ***      0      0                           0            die "Missing required DSN option '$key' in '$dsn'.  For more details, "
134                                                                  . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
135                                                                  . "for complete documentation."
136                                                               unless $final_props{$key};
137                                                         }
138                                                      }
139                                                   
140            7                                 98      return \%final_props;
141                                                   }
142                                                   
143                                                   sub parse_options {
144            6                    6            27      my ( $self, $o ) = @_;
145   ***      6     50                          37      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
146            6                                 39      my $dsn_string
147                                                         = join(',',
148           48    100                         195             map  { "$_=".$o->get($_); }
149            6                                 49             grep { $o->has($_) && $o->get($_) }
150            6                                 23             keys %{$self->{opts}}
151                                                           );
152            6                                 29      MKDEBUG && _d('DSN string made from options:', $dsn_string);
153            6                                 41      return $self->parse($dsn_string);
154                                                   }
155                                                   
156                                                   sub as_string {
157   ***      0                    0             0      my ( $self, $dsn, $props ) = @_;
158   ***      0      0                           0      return $dsn unless ref $dsn;
159   ***      0      0                           0      my %allowed = $props ? map { $_=>1 } @$props : ();
      ***      0                                  0   
160   ***      0      0                           0      return join(',',
161   ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_})  }
162   ***      0      0                           0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
163   ***      0                                  0         grep { !$props || $allowed{$_}                   }
164                                                         sort keys %$dsn );
165                                                   }
166                                                   
167                                                   sub usage {
168   ***      0                    0             0      my ( $self ) = @_;
169   ***      0                                  0      my $usage
170                                                         = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
171                                                         . "  KEY  COPY  MEANING\n"
172                                                         . "  ===  ====  =============================================\n";
173   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
174   ***      0                                  0      foreach my $key ( sort keys %opts ) {
175   ***      0      0      0                    0         $usage .= "  $key    "
176                                                                .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
177                                                                .  ($opts{$key}->{desc} || '[No description]')
178                                                                . "\n";
179                                                      }
180   ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
181   ***      0                                  0      return $usage;
182                                                   }
183                                                   
184                                                   sub get_cxn_params {
185            7                    7            42      my ( $self, $info ) = @_;
186            7                                 21      my $dsn;
187            7                                 25      my %opts = %{$self->{opts}};
               7                                125   
188   ***      7            50                   43      my $driver = $self->prop('dbidriver') || '';
189   ***      7     50                          36      if ( $driver eq 'Pg' ) {
190   ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
191   ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
192   ***      0             0                    0                        grep { defined $info->{$_} }
193                                                                        qw(h P));
194                                                      }
195                                                      else {
196            8                                 72         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
197           35                                150            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
198   ***      7            50                  116                        grep { defined $info->{$_} }
199                                                                        qw(F h P S A))
200                                                            . ';mysql_read_default_group=client';
201                                                      }
202            7                                263      MKDEBUG && _d($dsn);
203            7                                107      return ($dsn, $info->{u}, $info->{p});
204                                                   }
205                                                   
206                                                   sub fill_in_dsn {
207   ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
208   ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
209   ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
210   ***      0                                  0      $user =~ s/@.*//;
211   ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
212   ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
213   ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
214   ***      0             0                    0      $dsn->{u} ||= $user;
215   ***      0             0                    0      $dsn->{D} ||= $db;
216                                                   }
217                                                   
218                                                   sub get_dbh {
219            7                    7            51      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
220            7           100                   41      $opts ||= {};
221   ***      7     50                         175      my $defaults = {
222                                                         AutoCommit         => 0,
223                                                         RaiseError         => 1,
224                                                         PrintError         => 0,
225                                                         ShowErrorStatement => 1,
226                                                         mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
227                                                      };
228            7                                 38      @{$defaults}{ keys %$opts } = values %$opts;
               7                                 28   
229                                                   
230   ***      7     50                          50      if ( $opts->{mysql_use_result} ) {
231   ***      0                                  0         $defaults->{mysql_use_result} = 1;
232                                                      }
233                                                   
234   ***      7     50                          35      if ( !$have_dbi ) {
235   ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
236                                                            . "installed or not found.  Run 'perl -MDBI' to see the directories "
237                                                            . "that Perl searches for DBI.  If DBI is not installed, try:\n"
238                                                            . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
239                                                            . "  RHEL/CentOS    yum install perl-DBI\n"
240                                                            . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
241                                                   
242                                                      }
243                                                   
244            7                                 22      my $dbh;
245            7                                 22      my $tries = 2;
246   ***      7            66                   86      while ( !$dbh && $tries-- ) {
247                                                         MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
248            7                                 19            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
249                                                   
250            7                                 23         eval {
251            7                                129            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
252                                                   
253   ***      7     50                          72            if ( $cxn_string =~ m/mysql/i ) {
254            7                                 27               my $sql;
255                                                   
256            7                                 28               $sql = 'SELECT @@SQL_MODE';
257            7                                 17               MKDEBUG && _d($dbh, $sql);
258            7                                 19               my ($sql_mode) = $dbh->selectrow_array($sql);
259                                                   
260   ***      7     50                        1084               $sql = 'SET @@SQL_QUOTE_SHOW_CREATE = 1'
261                                                                    . '/*!40101, @@SQL_MODE=\'NO_AUTO_VALUE_ON_ZERO'
262                                                                    . ($sql_mode ? ",$sql_mode" : '')
263                                                                    . '\'*/';
264            7                                 17               MKDEBUG && _d($dbh, $sql);
265            7                                546               $dbh->do($sql);
266                                                   
267   ***      7     50                          72               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
268   ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
269   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
270   ***      0                                  0                  $dbh->do($sql);
271   ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
272   ***      0      0                           0                  if ( $charset eq 'utf8' ) {
273   ***      0      0                           0                     binmode(STDOUT, ':utf8')
274                                                                        or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
275                                                                  }
276                                                                  else {
277   ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
278                                                                  }
279                                                               }
280                                                   
281            7    100                          50               if ( $self->prop('set-vars') ) {
282            6                                 27                  $sql = "SET " . $self->prop('set-vars');
283            6                                 16                  MKDEBUG && _d($dbh, ':', $sql);
284            6                                358                  $dbh->do($sql);
285                                                               }
286                                                            }
287                                                         };
288   ***      7     50     33                   86         if ( !$dbh && $EVAL_ERROR ) {
289   ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
290   ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
291   ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
292   ***      0                                  0               delete $defaults->{mysql_enable_utf8};
293                                                            }
294                                                            elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
295   ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
296                                                                  . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
297                                                                  . "the directories that Perl searches for DBD::mysql.  If "
298                                                                  . "DBD::mysql is not installed, try:\n"
299                                                                  . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
300                                                                  . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
301                                                                  . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
302                                                            }
303   ***      0      0                           0            if ( !$tries ) {
304   ***      0                                  0               die $EVAL_ERROR;
305                                                            }
306                                                         }
307                                                      }
308                                                   
309            7                                 18      MKDEBUG && _d('DBH info: ',
310                                                         $dbh,
311                                                         Dumper($dbh->selectrow_hashref(
312                                                            'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
313                                                         'Connection info:',      $dbh->{mysql_hostinfo},
314                                                         'Character set info:',   Dumper($dbh->selectall_arrayref(
315                                                                        'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
316                                                         '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
317                                                         '$DBI::VERSION:',        $DBI::VERSION,
318                                                      );
319                                                   
320            7                                 51      return $dbh;
321                                                   }
322                                                   
323                                                   sub get_hostname {
324   ***      0                    0             0      my ( $self, $dbh ) = @_;
325   ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
326   ***      0                                  0         return $host;
327                                                      }
328   ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
329                                                         'SELECT /*!50038 @@hostname, */ 1');
330   ***      0                                  0      return $hostname;
331                                                   }
332                                                   
333                                                   sub disconnect {
334   ***      0                    0             0      my ( $self, $dbh ) = @_;
335   ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
336   ***      0                                  0      $dbh->disconnect;
337                                                   }
338                                                   
339                                                   sub print_active_handles {
340   ***      0                    0             0      my ( $self, $thing, $level ) = @_;
341   ***      0             0                    0      $level ||= 0;
342   ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
343                                                         $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
344                                                         or die "Cannot print: $OS_ERROR";
345   ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
346   ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
347                                                      }
348                                                   }
349                                                   
350                                                   sub copy {
351   ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
352   ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
353   ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
354   ***      0                                  0      my %new_dsn = map {
355   ***      0                                  0         my $key = $_;
356   ***      0                                  0         my $val;
357   ***      0      0                           0         if ( $args{overwrite} ) {
358   ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
359                                                         }
360                                                         else {
361   ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
362                                                         }
363   ***      0                                  0         $key => $val;
364   ***      0                                  0      } keys %{$self->{opts}};
365   ***      0                                  0      return \%new_dsn;
366                                                   }
367                                                   
368                                                   sub _d {
369   ***      0                    0             0      my ($package, undef, $line) = caller 0;
370   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
371   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
372                                                           @_;
373   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
374                                                   }
375                                                   
376                                                   1;
377                                                   
378                                                   # ###########################################################################
379                                                   # End DSNParser package
380                                                   # ###########################################################################
381                                                   
382                                                   # ###########################################################################
383                                                   # Quoter package 6240
384                                                   # This package is a copy without comments from the original.  The original
385                                                   # with comments and its test file can be found in the SVN repository at,
386                                                   #   trunk/common/Quoter.pm
387                                                   #   trunk/common/t/Quoter.t
388                                                   # See http://code.google.com/p/maatkit/wiki/Developers for more information.
389                                                   # ###########################################################################
390                                                   package Quoter;
391                                                   
392            1                    1             8   use strict;
               1                                  2   
               1                                  6   
393            1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
394            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
395                                                   
396   ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 19   
397                                                   
398                                                   sub new {
399            6                    6            34      my ( $class ) = @_;
400            6                                 48      return bless {}, $class;
401                                                   }
402                                                   
403                                                   sub quote {
404          497                  497          2670      my ( $self, @vals ) = @_;
405          497                               2021      foreach my $val ( @vals ) {
406          736                               3213         $val =~ s/`/``/g;
407                                                      }
408          497                               1986      return join('.', map { '`' . $_ . '`' } @vals);
             736                               5101   
409                                                   }
410                                                   
411                                                   sub quote_val {
412   ***      0                    0             0      my ( $self, $val ) = @_;
413                                                   
414   ***      0      0                           0      return 'NULL' unless defined $val;         # undef = NULL
415   ***      0      0                           0      return "''" if $val eq '';                 # blank string = ''
416   ***      0      0                           0      return $val if $val =~ m/^0x[0-9a-fA-F]/;  # hex value like 0xe5f190
417                                                   
418   ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
419   ***      0                                  0      return "'$val'";
420                                                   }
421                                                   
422                                                   sub split_unquote {
423   ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
424   ***      0                                  0      $db_tbl =~ s/`//g;
425   ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
426   ***      0      0                           0      if ( !$tbl ) {
427   ***      0                                  0         $tbl = $db;
428   ***      0                                  0         $db  = $default_db;
429                                                      }
430   ***      0                                  0      return ($db, $tbl);
431                                                   }
432                                                   
433                                                   sub literal_like {
434   ***      0                    0             0      my ( $self, $like ) = @_;
435   ***      0      0                           0      return unless $like;
436   ***      0                                  0      $like =~ s/([%_])/\\$1/g;
437   ***      0                                  0      return "'$like'";
438                                                   }
439                                                   
440                                                   sub join_quote {
441   ***      0                    0             0      my ( $self, $default_db, $db_tbl ) = @_;
442   ***      0      0                           0      return unless $db_tbl;
443   ***      0                                  0      my ($db, $tbl) = split(/[.]/, $db_tbl);
444   ***      0      0                           0      if ( !$tbl ) {
445   ***      0                                  0         $tbl = $db;
446   ***      0                                  0         $db  = $default_db;
447                                                      }
448   ***      0      0      0                    0      $db  = "`$db`"  if $db  && $db  !~ m/^`/;
449   ***      0      0      0                    0      $tbl = "`$tbl`" if $tbl && $tbl !~ m/^`/;
450   ***      0      0                           0      return $db ? "$db.$tbl" : $tbl;
451                                                   }
452                                                   
453                                                   1;
454                                                   
455                                                   # ###########################################################################
456                                                   # End Quoter package
457                                                   # ###########################################################################
458                                                   
459                                                   # ###########################################################################
460                                                   # OptionParser package 6322
461                                                   # This package is a copy without comments from the original.  The original
462                                                   # with comments and its test file can be found in the SVN repository at,
463                                                   #   trunk/common/OptionParser.pm
464                                                   #   trunk/common/t/OptionParser.t
465                                                   # See http://code.google.com/p/maatkit/wiki/Developers for more information.
466                                                   # ###########################################################################
467                                                   package OptionParser;
468                                                   
469            1                    1             6   use strict;
               1                                  3   
               1                                  5   
470            1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
471                                                   
472            1                    1            12   use Getopt::Long;
               1                                  3   
               1                                  7   
473            1                    1             7   use List::Util qw(max);
               1                                  2   
               1                                 12   
474            1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
475                                                   
476   ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 19   
477                                                   
478                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
479                                                   
480                                                   sub new {
481           12                   12           204      my ( $class, %args ) = @_;
482           12                                 85      foreach my $arg ( qw(description) ) {
483   ***     12     50                          97         die "I need a $arg argument" unless $args{$arg};
484                                                      }
485                                                   
486           12                                167      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
487   ***     12            50                   59      $program_name ||= $PROGRAM_NAME;
488   ***     12            33                  340      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
489                                                   
490           12                                148      my %attributes = (
491                                                         'type'       => 1,
492                                                         'short form' => 1,
493                                                         'group'      => 1,
494                                                         'default'    => 1,
495                                                         'cumulative' => 1,
496                                                         'negatable'  => 1,
497                                                      );
498                                                   
499           12                                878      my $self = {
500                                                         strict            => 1,
501                                                         prompt            => '<options>',
502                                                         head1             => 'OPTIONS',
503                                                         skip_rules        => 0,
504                                                         item              => '--(.*)',
505                                                         attributes        => \%attributes,
506                                                         parse_attributes  => \&_parse_attribs,
507                                                   
508                                                         %args,
509                                                   
510                                                         program_name      => $program_name,
511                                                         opts              => {},
512                                                         got_opts          => 0,
513                                                         short_opts        => {},
514                                                         defaults          => {},
515                                                         groups            => {},
516                                                         allowed_groups    => {},
517                                                         errors            => [],
518                                                         rules             => [],  # desc of rules for --help
519                                                         mutex             => [],  # rule: opts are mutually exclusive
520                                                         atleast1          => [],  # rule: at least one opt is required
521                                                         disables          => {},  # rule: opt disables other opts 
522                                                         defaults_to       => {},  # rule: opt defaults to value of other opt
523                                                         DSNParser         => undef,
524                                                         default_files     => [
525                                                            "/etc/maatkit/maatkit.conf",
526                                                            "/etc/maatkit/$program_name.conf",
527                                                            "$home/.maatkit.conf",
528                                                            "$home/.$program_name.conf",
529                                                         ],
530                                                         types             => {
531                                                            string => 's', # standard Getopt type
532                                                            int    => 'i', # standard Getopt type
533                                                            float  => 'f', # standard Getopt type
534                                                            Hash   => 'H', # hash, formed from a comma-separated list
535                                                            hash   => 'h', # hash as above, but only if a value is given
536                                                            Array  => 'A', # array, similar to Hash
537                                                            array  => 'a', # array, similar to hash
538                                                            DSN    => 'd', # DSN
539                                                            size   => 'z', # size with kMG suffix (powers of 2^10)
540                                                            time   => 'm', # time, with an optional suffix of s/h/m/d
541                                                         },
542                                                      };
543                                                   
544           12                                139      return bless $self, $class;
545                                                   }
546                                                   
547                                                   sub get_specs {
548            6                    6            27      my ( $self, $file ) = @_;
549   ***      6            50                   34      $file ||= __FILE__;
550            6                                 61      my @specs = $self->_pod_to_specs($file);
551            6                                129      $self->_parse_specs(@specs);
552                                                   
553   ***      6     50                         201      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
554            6                                 19      my $contents = do { local $/ = undef; <$fh> };
               6                                 41   
               6                               1772   
555            6                                 35      close $file;
556   ***      6     50                         411      if ( $contents =~ m/^=head1 DSN OPTIONS/m ) {
557            6                                 39         MKDEBUG && _d('Parsing DSN OPTIONS');
558            6                                 55         my $dsn_attribs = {
559                                                            dsn  => 1,
560                                                            copy => 1,
561                                                         };
562                                                         my $parse_dsn_attribs = sub {
563           48                   48           232            my ( $self, $option, $attribs ) = @_;
564           96                                353            map {
565           48                                244               my $val = $attribs->{$_};
566   ***     96     50                         503               if ( $val ) {
567   ***     96     50                         466                  $val    = $val eq 'yes' ? 1
                    100                               
568                                                                          : $val eq 'no'  ? 0
569                                                                          :                 $val;
570           96                                675                  $attribs->{$_} = $val;
571                                                               }
572                                                            } keys %$attribs;
573                                                            return {
574           48                                695               key => $option,
575                                                               %$attribs,
576                                                            };
577            6                                 81         };
578            6                                 70         my $dsn_o = new OptionParser(
579                                                            description       => 'DSN OPTIONS',
580                                                            head1             => 'DSN OPTIONS',
581                                                            dsn               => 0,         # XXX don't infinitely recurse!
582                                                            item              => '\* (.)',  # key opts are a single character
583                                                            skip_rules        => 1,         # no rules before opts
584                                                            attributes        => $dsn_attribs,
585                                                            parse_attributes  => $parse_dsn_attribs,
586                                                         );
587           48                                548         my @dsn_opts = map {
588            6                                 40            my $opts = {
589                                                               key  => $_->{spec}->{key},
590                                                               dsn  => $_->{spec}->{dsn},
591                                                               copy => $_->{spec}->{copy},
592                                                               desc => $_->{desc},
593                                                            };
594           48                                182            $opts;
595                                                         } $dsn_o->_pod_to_specs($file);
596            6                                172         $self->{DSNParser} = DSNParser->new(opts => \@dsn_opts);
597                                                      }
598                                                   
599            6                                 16      return;
600                                                   }
601                                                   
602                                                   sub DSNParser {
603            6                    6            27      my ( $self ) = @_;
604            6                                 30      return $self->{DSNParser};
605                                                   };
606                                                   
607                                                   sub get_defaults_files {
608            6                    6            27      my ( $self ) = @_;
609            6                                 18      return @{$self->{default_files}};
               6                                 74   
610                                                   }
611                                                   
612                                                   sub _pod_to_specs {
613           12                   12            64      my ( $self, $file ) = @_;
614   ***     12            50                   61      $file ||= __FILE__;
615   ***     12     50                         367      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
616                                                   
617           12                                 42      my @specs = ();
618           12                                 40      my @rules = ();
619           12                                 37      my $para;
620                                                   
621           12                                 82      local $INPUT_RECORD_SEPARATOR = '';
622           12                                236      while ( $para = <$fh> ) {
623         7350    100                       67441         next unless $para =~ m/^=head1 $self->{head1}/;
624           12                                 43         last;
625                                                      }
626                                                   
627           12                                112      while ( $para = <$fh> ) {
628           18    100                         115         last if $para =~ m/^=over/;
629   ***      6     50                          53         next if $self->{skip_rules};
630   ***      0                                  0         chomp $para;
631   ***      0                                  0         $para =~ s/\s+/ /g;
632   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
633   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
634   ***      0                                  0         push @rules, $para;
635                                                      }
636                                                   
637   ***     12     50                          54      die "POD has no $self->{head1} section" unless $para;
638                                                   
639           12                                 40      do {
640          150    100                        1622         if ( my ($option) = $para =~ m/^=item $self->{item}/ ) {
641          138                                407            chomp $para;
642          138                                325            MKDEBUG && _d($para);
643          138                                385            my %attribs;
644                                                   
645          138                                574            $para = <$fh>; # read next paragraph, possibly attributes
646                                                   
647          138    100                         648            if ( $para =~ m/: / ) { # attributes
648          120                                699               $para =~ s/\s+\Z//g;
649          228                               1205               %attribs = map {
650          120                                664                     my ( $attrib, $val) = split(/: /, $_);
651   ***    228     50                        1316                     die "Unrecognized attribute for --$option: $attrib"
652                                                                        unless $self->{attributes}->{$attrib};
653          228                               1318                     ($attrib, $val);
654                                                                  } split(/; /, $para);
655          120    100                         674               if ( $attribs{'short form'} ) {
656           48                                262                  $attribs{'short form'} =~ s/-//;
657                                                               }
658          120                                581               $para = <$fh>; # read next paragraph, probably short help desc
659                                                            }
660                                                            else {
661           18                                 51               MKDEBUG && _d('Option has no attributes');
662                                                            }
663                                                   
664          138                                988            $para =~ s/\s+\Z//g;
665          138                                959            $para =~ s/\s+/ /g;
666          138                                625            $para =~ s/$POD_link_re/$1/go;
667                                                   
668          138                                586            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
669          138                                332            MKDEBUG && _d('Short help:', $para);
670                                                   
671   ***    138     50                         620            die "No description after option spec $option" if $para =~ m/^=item/;
672                                                   
673   ***    138     50                         687            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
674   ***      0                                  0               $option = $base_option;
675   ***      0                                  0               $attribs{'negatable'} = 1;
676                                                            }
677                                                   
678          138    100                         936            push @specs, {
      ***            50                               
679                                                               spec  => $self->{parse_attributes}->($self, $option, \%attribs), 
680                                                               desc  => $para
681                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
682                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
683                                                            };
684                                                         }
685          150                               1188         while ( $para = <$fh> ) {
686   ***    174     50                         688            last unless $para;
687          174    100                         791            if ( $para =~ m/^=head1/ ) {
688           12                                 43               $para = undef; # Can't 'last' out of a do {} block.
689           12                                 71               last;
690                                                            }
691          162    100                        1708            last if $para =~ m/^=item /;
692                                                         }
693                                                      } while ( $para );
694                                                   
695   ***     12     50                          58      die "No valid specs in $self->{head1}" unless @specs;
696                                                   
697           12                                155      close $fh;
698           12                                 43      return @specs, @rules;
699                                                   }
700                                                   
701                                                   sub _parse_specs {
702            6                    6            42      my ( $self, @specs ) = @_;
703            6                                 22      my %disables; # special rule that requires deferred checking
704                                                   
705            6                                 36      foreach my $opt ( @specs ) {
706   ***     90     50                         356         if ( ref $opt ) { # It's an option spec, not a rule.
707                                                            MKDEBUG && _d('Parsing opt spec:',
708           90                                228               map { ($_, '=>', $opt->{$_}) } keys %$opt);
709                                                   
710           90                                788            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
711   ***     90     50                         433            if ( !$long ) {
712   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
713                                                            }
714           90                                366            $opt->{long} = $long;
715                                                   
716   ***     90     50                         468            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
717           90                                454            $self->{opts}->{$long} = $opt;
718                                                   
719   ***     90     50                         416            if ( length $long == 1 ) {
720   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
721   ***      0                                  0               $self->{short_opts}->{$long} = $long;
722                                                            }
723                                                   
724           90    100                         322            if ( $short ) {
725   ***     48     50                         237               die "Duplicate short option -$short"
726                                                                  if exists $self->{short_opts}->{$short};
727           48                                306               $self->{short_opts}->{$short} = $long;
728           48                                196               $opt->{short} = $short;
729                                                            }
730                                                            else {
731           42                                168               $opt->{short} = undef;
732                                                            }
733                                                   
734   ***     90     50                         553            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
735   ***     90     50                         511            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
736   ***     90     50                         536            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
737                                                   
738   ***     90            50                  407            $opt->{group} ||= 'default';
739           90                                513            $self->{groups}->{ $opt->{group} }->{$long} = 1;
740                                                   
741           90                                330            $opt->{value} = undef;
742           90                                344            $opt->{got}   = 0;
743                                                   
744           90                                560            my ( $type ) = $opt->{spec} =~ m/=(.)/;
745           90                                387            $opt->{type} = $type;
746           90                                209            MKDEBUG && _d($long, 'type:', $type);
747                                                   
748                                                   
749           90    100    100                  863            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
750                                                   
751           90    100                         627            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
752   ***     18     50                         112               $self->{defaults}->{$long} = defined $def ? $def : 1;
753           18                                 52               MKDEBUG && _d($long, 'default:', $def);
754                                                            }
755                                                   
756           90    100                         385            if ( $long eq 'config' ) {
757            6                                 48               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
758                                                            }
759                                                   
760   ***     90     50                         530            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
761   ***      0                                  0               $disables{$long} = $dis;
762   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
763                                                            }
764                                                   
765           90                                508            $self->{opts}->{$long} = $opt;
766                                                         }
767                                                         else { # It's an option rule, not a spec.
768   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
769   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
770   ***      0                                  0            my @participants = $self->_get_participants($opt);
771   ***      0                                  0            my $rule_ok = 0;
772                                                   
773   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
774   ***      0                                  0               $rule_ok = 1;
775   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
776   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
777                                                            }
778   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
779   ***      0                                  0               $rule_ok = 1;
780   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
781   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
782                                                            }
783   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
784   ***      0                                  0               $rule_ok = 1;
785   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
786   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
787                                                            }
788   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
789   ***      0                                  0               $rule_ok = 1;
790   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
791   ***      0                                  0               my @groups = split(',', $groups);
792   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
793   ***      0                                  0                  s/\s+//;
794   ***      0                                  0                  $_ => 1;
795                                                               } @groups;
796                                                            }
797                                                   
798   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
799                                                         }
800                                                      }
801                                                   
802            6                                 41      foreach my $long ( keys %disables ) {
803   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
804   ***      0                                  0         $self->{disables}->{$long} = \@participants;
805   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
806                                                      }
807                                                   
808            6                                 31      return; 
809                                                   }
810                                                   
811                                                   sub _get_participants {
812   ***      0                    0             0      my ( $self, $str ) = @_;
813   ***      0                                  0      my @participants;
814   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
815   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
816                                                            unless exists $self->{opts}->{$long};
817   ***      0                                  0         push @participants, $long;
818                                                      }
819   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
820   ***      0                                  0      return @participants;
821                                                   }
822                                                   
823                                                   sub opts {
824   ***      0                    0             0      my ( $self ) = @_;
825   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
826   ***      0                                  0      return %opts;
827                                                   }
828                                                   
829                                                   sub short_opts {
830   ***      0                    0             0      my ( $self ) = @_;
831   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
832   ***      0                                  0      return %short_opts;
833                                                   }
834                                                   
835                                                   sub set_defaults {
836   ***      0                    0             0      my ( $self, %defaults ) = @_;
837   ***      0                                  0      $self->{defaults} = {};
838   ***      0                                  0      foreach my $long ( keys %defaults ) {
839   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
840                                                            unless exists $self->{opts}->{$long};
841   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
842   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
843                                                      }
844   ***      0                                  0      return;
845                                                   }
846                                                   
847                                                   sub get_defaults {
848   ***      0                    0             0      my ( $self ) = @_;
849   ***      0                                  0      return $self->{defaults};
850                                                   }
851                                                   
852                                                   sub get_groups {
853   ***      0                    0             0      my ( $self ) = @_;
854   ***      0                                  0      return $self->{groups};
855                                                   }
856                                                   
857                                                   sub _set_option {
858            7                    7            53      my ( $self, $opt, $val ) = @_;
859   ***      7      0                          18      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
860                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
861                                                               : die "Getopt::Long gave a nonexistent option: $opt";
862                                                   
863            7                                 15      $opt = $self->{opts}->{$long};
864   ***      7     50                          43      if ( $opt->{is_cumulative} ) {
865   ***      0                                  0         $opt->{value}++;
866                                                      }
867                                                      else {
868            7                                 28         $opt->{value} = $val;
869                                                      }
870            7                                 26      $opt->{got} = 1;
871            7                                 29      MKDEBUG && _d('Got option', $long, '=', $val);
872                                                   }
873                                                   
874                                                   sub get_opts {
875            6                    6            30      my ( $self ) = @_; 
876                                                   
877            6                                 20      foreach my $long ( keys %{$self->{opts}} ) {
               6                                 76   
878           90                                409         $self->{opts}->{$long}->{got} = 0;
879   ***     90     50                         888         $self->{opts}->{$long}->{value}
                    100                               
880                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
881                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
882                                                            : undef;
883                                                      }
884            6                                 32      $self->{got_opts} = 0;
885                                                   
886            6                                 35      $self->{errors} = [];
887                                                   
888   ***      6     50     33                   86      if ( @ARGV && $ARGV[0] eq "--config" ) {
889   ***      0                                  0         shift @ARGV;
890   ***      0                                  0         $self->_set_option('config', shift @ARGV);
891                                                      }
892   ***      6     50                          52      if ( $self->has('config') ) {
893            6                                 19         my @extra_args;
894            6                                 54         foreach my $filename ( split(',', $self->get('config')) ) {
895           24                                 69            eval {
896           24                                133               push @extra_args, $self->_read_config_file($filename);
897                                                            };
898   ***     24     50                         133            if ( $EVAL_ERROR ) {
899   ***     24     50                         115               if ( $self->got('config') ) {
900   ***      0                                  0                  die $EVAL_ERROR;
901                                                               }
902                                                               elsif ( MKDEBUG ) {
903                                                                  _d($EVAL_ERROR);
904                                                               }
905                                                            }
906                                                         }
907            6                                 38         unshift @ARGV, @extra_args;
908                                                      }
909                                                   
910            6                                 87      Getopt::Long::Configure('no_ignore_case', 'bundling');
911                                                      GetOptions(
912           84                    7           725         map    { $_->{spec} => sub { $self->_set_option(@_); } }
               7                                 54   
              90                                399   
913            6                                 39         grep   { $_->{long} ne 'config' } # --config is handled specially above.
914   ***      6     50                          25         values %{$self->{opts}}
915                                                      ) or $self->save_error('Error parsing options');
916                                                   
917   ***      6     50     33                  247      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
918   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
919                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
920                                                               or die "Cannot print: $OS_ERROR";
921   ***      0                                  0         exit 0;
922                                                      }
923                                                   
924   ***      6     50     33                   77      if ( @ARGV && $self->{strict} ) {
925   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
926                                                      }
927                                                   
928            6                                 20      foreach my $mutex ( @{$self->{mutex}} ) {
               6                                 36   
929   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
930   ***      0      0                           0         if ( @set > 1 ) {
931   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
932   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
933                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
934                                                                    . ' are mutually exclusive.';
935   ***      0                                  0            $self->save_error($err);
936                                                         }
937                                                      }
938                                                   
939            6                                 21      foreach my $required ( @{$self->{atleast1}} ) {
               6                                 32   
940   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
941   ***      0      0                           0         if ( @set == 0 ) {
942   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
943   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
944                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
945   ***      0                                  0            $self->save_error("Specify at least one of $err");
946                                                         }
947                                                      }
948                                                   
949            6                                 26      $self->_check_opts( keys %{$self->{opts}} );
               6                                 76   
950            6                                 31      $self->{got_opts} = 1;
951            6                                 18      return;
952                                                   }
953                                                   
954                                                   sub _check_opts {
955            6                    6            59      my ( $self, @long ) = @_;
956            6                                 29      my $long_last = scalar @long;
957            6                                 31      while ( @long ) {
958            6                                 55         foreach my $i ( 0..$#long ) {
959           90                                308            my $long = $long[$i];
960   ***     90     50                         349            next unless $long;
961           90                                363            my $opt  = $self->{opts}->{$long};
962           90    100                         558            if ( $opt->{got} ) {
      ***            50                               
963   ***      7     50                          37               if ( exists $self->{disables}->{$long} ) {
964   ***      0                                  0                  my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
965   ***      0                                  0                  map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
966   ***      0                                  0                  MKDEBUG && _d('Unset options', @disable_opts,
967                                                                     'because', $long,'disables them');
968                                                               }
969                                                   
970   ***      7     50                          46               if ( exists $self->{allowed_groups}->{$long} ) {
971                                                   
972   ***      0                                  0                  my @restricted_groups = grep {
973   ***      0                                  0                     !exists $self->{allowed_groups}->{$long}->{$_}
974   ***      0                                  0                  } keys %{$self->{groups}};
975                                                   
976   ***      0                                  0                  my @restricted_opts;
977   ***      0                                  0                  foreach my $restricted_group ( @restricted_groups ) {
978   ***      0                                  0                     RESTRICTED_OPT:
979   ***      0                                  0                     foreach my $restricted_opt (
980                                                                        keys %{$self->{groups}->{$restricted_group}} )
981                                                                     {
982   ***      0      0                           0                        next RESTRICTED_OPT if $restricted_opt eq $long;
983   ***      0      0                           0                        push @restricted_opts, $restricted_opt
984                                                                           if $self->{opts}->{$restricted_opt}->{got};
985                                                                     }
986                                                                  }
987                                                   
988   ***      0      0                           0                  if ( @restricted_opts ) {
989   ***      0                                  0                     my $err;
990   ***      0      0                           0                     if ( @restricted_opts == 1 ) {
991   ***      0                                  0                        $err = "--$restricted_opts[0]";
992                                                                     }
993                                                                     else {
994   ***      0                                  0                        $err = join(', ',
995   ***      0                                  0                                  map { "--$self->{opts}->{$_}->{long}" }
996   ***      0                                  0                                  grep { $_ } 
997                                                                                  @restricted_opts[0..scalar(@restricted_opts) - 2]
998                                                                               )
999                                                                             . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1000                                                                    }
1001  ***      0                                  0                     $self->save_error("--$long is not allowed with $err");
1002                                                                 }
1003                                                              }
1004                                                  
1005                                                           }
1006                                                           elsif ( $opt->{is_required} ) { 
1007  ***      0                                  0               $self->save_error("Required option --$long must be specified");
1008                                                           }
1009                                                  
1010          90                                386            $self->_validate_type($opt);
1011  ***     90     50                         375            if ( $opt->{parsed} ) {
1012          90                                372               delete $long[$i];
1013                                                           }
1014                                                           else {
1015  ***      0                                  0               MKDEBUG && _d('Temporarily failed to parse', $long);
1016                                                           }
1017                                                        }
1018                                                  
1019  ***      6     50                          32         die "Failed to parse options, possibly due to circular dependencies"
1020                                                           if @long == $long_last;
1021           6                                 30         $long_last = @long;
1022                                                     }
1023                                                  
1024           6                                 27      return;
1025                                                  }
1026                                                  
1027                                                  sub _validate_type {
1028          90                   90           353      my ( $self, $opt ) = @_;
1029  ***     90     50                         365      return unless $opt;
1030                                                  
1031          90    100                         444      if ( !$opt->{type} ) {
1032          24                                 93         $opt->{parsed} = 1;
1033          24                                 77         return;
1034                                                     }
1035                                                  
1036          66                                299      my $val = $opt->{value};
1037                                                  
1038  ***     66     50     66                 2084      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
      ***           100     66                        
      ***           100     66                        
                           100                        
                           100                        
1039  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1040  ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1041  ***      0      0                           0         if ( !$suffix ) {
1042  ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1043  ***      0             0                    0            $suffix = $s || 's';
1044  ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1045                                                              $opt->{long}, '(value:', $val, ')');
1046                                                        }
1047  ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
1048  ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
1049                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1050                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1051                                                                :                  $num * 86400;   # Days
1052  ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
1053  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1054                                                        }
1055                                                        else {
1056  ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
1057                                                        }
1058                                                     }
1059                                                     elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
1060  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1061  ***      0                                  0         my $prev = {};
1062  ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
1063  ***      0      0                           0         if ( $from_key ) {
1064  ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1065  ***      0      0                           0            if ( $self->{opts}->{$from_key}->{parsed} ) {
1066  ***      0                                  0               $prev = $self->{opts}->{$from_key}->{value};
1067                                                           }
1068                                                           else {
1069  ***      0                                  0               MKDEBUG && _d('Cannot parse', $opt->{long}, 'until',
1070                                                                 $from_key, 'parsed');
1071  ***      0                                  0               return;
1072                                                           }
1073                                                        }
1074  ***      0                                  0         my $defaults = $self->{DSNParser}->parse_options($self);
1075  ***      0                                  0         $opt->{value} = $self->{DSNParser}->parse($val, $prev, $defaults);
1076                                                     }
1077                                                     elsif ( $val && $opt->{type} eq 'z' ) {  # type size
1078  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1079  ***      0                                  0         $self->_parse_size($opt, $val);
1080                                                     }
1081                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1082  ***      6            50                   51         $opt->{value} = { map { $_ => 1 } split(/(?<!\\),\s*/, ($val || '')) };
               6                                 46   
1083                                                     }
1084                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1085  ***     12            50                  171         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
1086                                                     }
1087                                                     else {
1088          48                                127         MKDEBUG && _d('Nothing to validate for option',
1089                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1090                                                     }
1091                                                  
1092          66                                255      $opt->{parsed} = 1;
1093          66                                202      return;
1094                                                  }
1095                                                  
1096                                                  sub get {
1097         102                  102           478      my ( $self, $opt ) = @_;
1098         102    100                         577      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1099  ***    102     50     33                 1062      die "Option $opt does not exist"
1100                                                        unless $long && exists $self->{opts}->{$long};
1101         102                               1076      return $self->{opts}->{$long}->{value};
1102                                                  }
1103                                                  
1104                                                  sub got {
1105          30                   30           155      my ( $self, $opt ) = @_;
1106  ***     30     50                         150      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1107  ***     30     50     33                  344      die "Option $opt does not exist"
1108                                                        unless $long && exists $self->{opts}->{$long};
1109          30                                219      return $self->{opts}->{$long}->{got};
1110                                                  }
1111                                                  
1112                                                  sub has {
1113          96                   96           428      my ( $self, $opt ) = @_;
1114          96    100                         553      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1115          96    100                         986      return defined $long ? exists $self->{opts}->{$long} : 0;
1116                                                  }
1117                                                  
1118                                                  sub set {
1119  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1120  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1121  ***      0      0      0                    0      die "Option $opt does not exist"
1122                                                        unless $long && exists $self->{opts}->{$long};
1123  ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
1124  ***      0                                  0      return;
1125                                                  }
1126                                                  
1127                                                  sub save_error {
1128  ***      0                    0             0      my ( $self, $error ) = @_;
1129  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1130                                                  }
1131                                                  
1132                                                  sub errors {
1133  ***      0                    0             0      my ( $self ) = @_;
1134  ***      0                                  0      return $self->{errors};
1135                                                  }
1136                                                  
1137                                                  sub prompt {
1138  ***      0                    0             0      my ( $self ) = @_;
1139  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1140                                                  }
1141                                                  
1142                                                  sub descr {
1143  ***      0                    0             0      my ( $self ) = @_;
1144  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1145                                                                . "  For more details, please use the --help option, "
1146                                                                . "or try 'perldoc $PROGRAM_NAME' "
1147                                                                . "for complete documentation.";
1148  ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
1149                                                        unless $ENV{DONT_BREAK_LINES};
1150  ***      0                                  0      $descr =~ s/ +$//mg;
1151  ***      0                                  0      return $descr;
1152                                                  }
1153                                                  
1154                                                  sub usage_or_errors {
1155           6                    6            29      my ( $self ) = @_;
1156  ***      6     50                          39      if ( $self->{opts}->{help}->{got} ) {
      ***      6     50                          34   
1157  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1158  ***      0                                  0         exit 0;
1159                                                     }
1160                                                     elsif ( scalar @{$self->{errors}} ) {
1161  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1162  ***      0                                  0         exit 0;
1163                                                     }
1164           6                                 19      return;
1165                                                  }
1166                                                  
1167                                                  sub print_errors {
1168  ***      0                    0             0      my ( $self ) = @_;
1169  ***      0                                  0      my $usage = $self->prompt() . "\n";
1170  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1171  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1172                                                                . "\n";
1173                                                     }
1174  ***      0                                  0      return $usage . "\n" . $self->descr();
1175                                                  }
1176                                                  
1177                                                  sub print_usage {
1178  ***      0                    0             0      my ( $self ) = @_;
1179  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1180  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1181                                                  
1182  ***      0      0                           0      my $maxl = max(
1183  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1184                                                        @opts);
1185                                                  
1186  ***      0      0                           0      my $maxs = max(0,
1187  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1188  ***      0                                  0         values %{$self->{short_opts}});
1189                                                  
1190  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1191  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1192  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1193                                                  
1194  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1195                                                  
1196  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1197                                                  
1198  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1199  ***      0                                  0      push @groups, 'default';
1200                                                  
1201  ***      0                                  0      foreach my $group ( reverse @groups ) {
1202  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1203  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1204  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1205                                                           grep { $_->{group} eq $group }
1206                                                           @opts )
1207                                                        {
1208  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1209  ***      0                                  0            my $short = $opt->{short};
1210  ***      0                                  0            my $desc  = $opt->{desc};
1211  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1212  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1213  ***      0             0                    0               $s    ||= 's';
1214  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1215  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1216                                                                     . "d=days; if no suffix, $s is used.";
1217                                                           }
1218  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1219  ***      0                                  0            $desc =~ s/ +$//mg;
1220  ***      0      0                           0            if ( $short ) {
1221  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1222                                                           }
1223                                                           else {
1224  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1225                                                           }
1226                                                        }
1227                                                     }
1228                                                  
1229  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1230  ***      0                                  0         $usage .= "\nRules:\n\n";
1231  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1232                                                     }
1233  ***      0      0                           0      if ( $self->{DSNParser} ) {
1234  ***      0                                  0         $usage .= "\n" . $self->{DSNParser}->usage();
1235                                                     }
1236  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1237  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1238  ***      0                                  0         my $val   = $opt->{value};
1239  ***      0             0                    0         my $type  = $opt->{type} || '';
1240  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1241  ***      0      0                           0         $val      = $bool              ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1242                                                                  : !defined $val      ? '(No value)'
1243                                                                  : $type eq 'd'       ? $self->{DSNParser}->as_string($val)
1244                                                                  : $type =~ m/H|h/    ? join(',', sort keys %$val)
1245                                                                  : $type =~ m/A|a/    ? join(',', @$val)
1246                                                                  :                    $val;
1247  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1248                                                     }
1249  ***      0                                  0      return $usage;
1250                                                  }
1251                                                  
1252                                                  sub prompt_noecho {
1253  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1254  ***      0                                  0      my ( $prompt ) = @_;
1255  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1256  ***      0      0                           0      print $prompt
1257                                                        or die "Cannot print: $OS_ERROR";
1258  ***      0                                  0      my $response;
1259  ***      0                                  0      eval {
1260  ***      0                                  0         require Term::ReadKey;
1261  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1262  ***      0                                  0         chomp($response = <STDIN>);
1263  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1264  ***      0      0                           0         print "\n"
1265                                                           or die "Cannot print: $OS_ERROR";
1266                                                     };
1267  ***      0      0                           0      if ( $EVAL_ERROR ) {
1268  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1269                                                     }
1270  ***      0                                  0      return $response;
1271                                                  }
1272                                                  
1273                                                  if ( MKDEBUG ) {
1274                                                     print '# ', $^X, ' ', $], "\n";
1275                                                     my $uname = `uname -a`;
1276                                                     if ( $uname ) {
1277                                                        $uname =~ s/\s+/ /g;
1278                                                        print "# $uname\n";
1279                                                     }
1280                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1281                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1282                                                        ($main::SVN_REV || ''), __LINE__);
1283                                                     print('# Arguments: ',
1284                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1285                                                  }
1286                                                  
1287                                                  sub _read_config_file {
1288          24                   24           113      my ( $self, $filename ) = @_;
1289  ***     24     50                          61      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1290  ***      0                                  0      my @args;
1291  ***      0                                  0      my $prefix = '--';
1292  ***      0                                  0      my $parse  = 1;
1293                                                  
1294                                                     LINE:
1295  ***      0                                  0      while ( my $line = <$fh> ) {
1296  ***      0                                  0         chomp $line;
1297  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1298  ***      0                                  0         $line =~ s/\s+#.*$//g;
1299  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1300  ***      0      0                           0         if ( $line eq '--' ) {
1301  ***      0                                  0            $prefix = '';
1302  ***      0                                  0            $parse  = 0;
1303  ***      0                                  0            next LINE;
1304                                                        }
1305  ***      0      0      0                    0         if ( $parse
      ***             0                               
1306                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1307                                                        ) {
1308  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1309                                                        }
1310                                                        elsif ( $line =~ m/./ ) {
1311  ***      0                                  0            push @args, $line;
1312                                                        }
1313                                                        else {
1314  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1315                                                        }
1316                                                     }
1317  ***      0                                  0      close $fh;
1318  ***      0                                  0      return @args;
1319                                                  }
1320                                                  
1321                                                  sub read_para_after {
1322  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1323  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1324  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1325  ***      0                                  0      my $para;
1326  ***      0                                  0      while ( $para = <$fh> ) {
1327  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1328  ***      0                                  0         last;
1329                                                     }
1330  ***      0                                  0      while ( $para = <$fh> ) {
1331  ***      0      0                           0         next unless $para =~ m/$regex/;
1332  ***      0                                  0         last;
1333                                                     }
1334  ***      0                                  0      $para = <$fh>;
1335  ***      0                                  0      chomp($para);
1336  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1337  ***      0                                  0      return $para;
1338                                                  }
1339                                                  
1340                                                  sub clone {
1341  ***      0                    0             0      my ( $self ) = @_;
1342                                                  
1343  ***      0                                  0      my %clone = map {
1344  ***      0                                  0         my $hashref  = $self->{$_};
1345  ***      0                                  0         my $val_copy = {};
1346  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1347  ***      0                                  0            my $ref = ref $hashref->{$key};
1348  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1349  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1350  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1351                                                                             : $hashref->{$key};
1352                                                        }
1353  ***      0                                  0         $_ => $val_copy;
1354                                                     } qw(opts short_opts defaults);
1355                                                  
1356  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1357  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1358                                                     }
1359                                                  
1360  ***      0                                  0      return bless \%clone;     
1361                                                  }
1362                                                  
1363                                                  sub _parse_size {
1364  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1365                                                  
1366  ***      0      0      0                    0      if ( lc($val || '') eq 'null' ) {
1367  ***      0                                  0         MKDEBUG && _d('NULL size for', $opt->{long});
1368  ***      0                                  0         $opt->{value} = 'null';
1369  ***      0                                  0         return;
1370                                                     }
1371                                                  
1372  ***      0                                  0      my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1373  ***      0                                  0      my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1374  ***      0      0                           0      if ( defined $num ) {
1375  ***      0      0                           0         if ( $factor ) {
1376  ***      0                                  0            $num *= $factor_for{$factor};
1377  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{y},
1378                                                              'to num', $num, '* factor', $factor);
1379                                                        }
1380  ***      0             0                    0         $opt->{value} = ($pre || '') . $num;
1381                                                     }
1382                                                     else {
1383  ***      0                                  0         $self->save_error("Invalid size for --$opt->{long}");
1384                                                     }
1385  ***      0                                  0      return;
1386                                                  }
1387                                                  
1388                                                  sub _parse_attribs {
1389          90                   90           423      my ( $self, $option, $attribs ) = @_;
1390          90                                362      my $types = $self->{types};
1391          90    100                        1905      return $option
      ***            50                               
      ***            50                               
                    100                               
1392                                                        . ($attribs->{'short form'} ? '|' . $attribs->{'short form'}   : '' )
1393                                                        . ($attribs->{'negatable'}  ? '!'                              : '' )
1394                                                        . ($attribs->{'cumulative'} ? '+'                              : '' )
1395                                                        . ($attribs->{'type'}       ? '=' . $types->{$attribs->{type}} : '' );
1396                                                  }
1397                                                  
1398                                                  sub _d {
1399  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1400  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1401  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1402                                                          @_;
1403  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1404                                                  }
1405                                                  
1406                                                  1;
1407                                                  
1408                                                  # ###########################################################################
1409                                                  # End OptionParser package
1410                                                  # ###########################################################################
1411                                                  
1412                                                  # ###########################################################################
1413                                                  # QueryParser package 6262
1414                                                  # This package is a copy without comments from the original.  The original
1415                                                  # with comments and its test file can be found in the SVN repository at,
1416                                                  #   trunk/common/QueryParser.pm
1417                                                  #   trunk/common/t/QueryParser.t
1418                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1419                                                  # ###########################################################################
1420                                                  package QueryParser;
1421                                                  
1422           1                    1            10   use strict;
               1                                  2   
               1                                  8   
1423           1                    1             6   use warnings FATAL => 'all';
               1                                  6   
               1                                  7   
1424           1                    1           250   use English qw(-no_match_vars);
               1                                  4   
               1                                  6   
1425                                                  
1426  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 15   
1427                                                  our $tbl_ident = qr/(?:`[^`]+`|\w+)(?:\.(?:`[^`]+`|\w+))?/;
1428                                                  our $tbl_regex = qr{
1429                                                           \b(?:FROM|JOIN|(?<!KEY\s)UPDATE|INTO) # Words that precede table names
1430                                                           \b\s*
1431                                                           \(?                                   # Optional paren around tables
1432                                                           ($tbl_ident
1433                                                              (?: (?:\s+ (?:AS\s+)? \w+)?, \s*$tbl_ident )*
1434                                                           )
1435                                                        }xio;
1436                                                  our $has_derived = qr{
1437                                                        \b(?:FROM|JOIN|,)
1438                                                        \s*\(\s*SELECT
1439                                                     }xi;
1440                                                  
1441                                                  our $data_def_stmts = qr/(?:CREATE|ALTER|TRUNCATE|DROP|RENAME)/i;
1442                                                  
1443                                                  our $data_manip_stmts = qr/(?:INSERT|UPDATE|DELETE|REPLACE)/i;
1444                                                  
1445                                                  sub new {
1446           6                    6            29      my ( $class ) = @_;
1447           6                                 35      bless {}, $class;
1448                                                  }
1449                                                  
1450                                                  sub get_tables {
1451  ***      0                    0             0      my ( $self, $query ) = @_;
1452  ***      0      0                           0      return unless $query;
1453  ***      0                                  0      MKDEBUG && _d('Getting tables for', $query);
1454                                                  
1455  ***      0                                  0      my ( $ddl_stmt ) = $query =~ m/^\s*($data_def_stmts)\b/i;
1456  ***      0      0                           0      if ( $ddl_stmt ) {
1457  ***      0                                  0         MKDEBUG && _d('Special table type:', $ddl_stmt);
1458  ***      0                                  0         $query =~ s/IF NOT EXISTS//i;
1459  ***      0      0                           0         if ( $query =~ m/$ddl_stmt DATABASE\b/i ) {
1460  ***      0                                  0            MKDEBUG && _d('Query alters a database, not a table');
1461  ***      0                                  0            return ();
1462                                                        }
1463  ***      0      0      0                    0         if ( $ddl_stmt =~ m/CREATE/i && $query =~ m/$ddl_stmt\b.+?\bSELECT\b/i ) {
1464  ***      0                                  0            my ($select) = $query =~ m/\b(SELECT\b.+)/is;
1465  ***      0                                  0            MKDEBUG && _d('CREATE TABLE ... SELECT:', $select);
1466  ***      0                                  0            return $self->get_tables($select);
1467                                                        }
1468  ***      0                                  0         my ($tbl) = $query =~ m/TABLE\s+($tbl_ident)(\s+.*)?/i;
1469  ***      0                                  0         MKDEBUG && _d('Matches table:', $tbl);
1470  ***      0                                  0         return ($tbl);
1471                                                     }
1472                                                  
1473  ***      0                                  0      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
1474                                                  
1475  ***      0      0                           0      if ( $query =~ /^\s*LOCK TABLES/i ) {
1476  ***      0                                  0         MKDEBUG && _d('Special table type: LOCK TABLES');
1477  ***      0                                  0         $query =~ s/^(\s*LOCK TABLES\s+)//;
1478  ***      0                                  0         $query =~ s/\s+(?:READ|WRITE|LOCAL)+\s*//g;
1479  ***      0                                  0         MKDEBUG && _d('Locked tables:', $query);
1480  ***      0                                  0         $query = "FROM $query";
1481                                                     }
1482                                                  
1483  ***      0                                  0      $query =~ s/\\["']//g;                # quoted strings
1484  ***      0                                  0      $query =~ s/".*?"/?/sg;               # quoted strings
1485  ***      0                                  0      $query =~ s/'.*?'/?/sg;               # quoted strings
1486                                                  
1487  ***      0                                  0      my @tables;
1488  ***      0                                  0      foreach my $tbls ( $query =~ m/$tbl_regex/gio ) {
1489  ***      0                                  0         MKDEBUG && _d('Match tables:', $tbls);
1490                                                  
1491  ***      0      0                           0         next if $tbls =~ m/\ASELECT\b/i;
1492                                                  
1493  ***      0                                  0         foreach my $tbl ( split(',', $tbls) ) {
1494  ***      0                                  0            $tbl =~ s/\s*($tbl_ident)(\s+.*)?/$1/gio;
1495                                                  
1496  ***      0      0                           0            if ( $tbl !~ m/[a-zA-Z]/ ) {
1497  ***      0                                  0               MKDEBUG && _d('Skipping suspicious table name:', $tbl);
1498  ***      0                                  0               next;
1499                                                           }
1500                                                  
1501  ***      0                                  0            push @tables, $tbl;
1502                                                        }
1503                                                     }
1504  ***      0                                  0      return @tables;
1505                                                  }
1506                                                  
1507                                                  sub has_derived_table {
1508  ***      0                    0             0      my ( $self, $query ) = @_;
1509  ***      0                                  0      my $match = $query =~ m/$has_derived/;
1510  ***      0                                  0      MKDEBUG && _d($query, 'has ' . ($match ? 'a' : 'no') . ' derived table');
1511  ***      0                                  0      return $match;
1512                                                  }
1513                                                  
1514                                                  sub get_aliases {
1515           5                    5            28      my ( $self, $query, $list ) = @_;
1516                                                  
1517           5                                 38      my $result = {
1518                                                        DATABASE => {},
1519                                                        TABLE    => {},
1520                                                     };
1521  ***      5     50                          22      return $result unless $query;
1522                                                  
1523           5                                 36      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
1524                                                  
1525           5                                 30      $query =~ s/ (?:INNER|OUTER|CROSS|LEFT|RIGHT|NATURAL)//ig;
1526                                                  
1527           5                                 15      my @tbl_refs;
1528           5                                 83      my ($tbl_refs, $from) = $query =~ m{
1529                                                        (
1530                                                           (FROM|INTO|UPDATE)\b\s*   # Keyword before table refs
1531                                                           .+?                       # Table refs
1532                                                        )
1533                                                        (?:\s+|\z)                   # If the query does not end with the table
1534                                                        (?:WHERE|ORDER|LIMIT|HAVING|SET|VALUES|\z) # Keyword after table refs
1535                                                     }ix;
1536                                                  
1537  ***      5     50                          29      if ( $tbl_refs ) {
1538                                                  
1539  ***      5     50                          35         if ( $query =~ m/^(?:INSERT|REPLACE)/i ) {
1540  ***      0                                  0            $tbl_refs =~ s/\([^\)]+\)\s*//;
1541                                                        }
1542                                                  
1543           5                                 14         MKDEBUG && _d('tbl refs:', $tbl_refs);
1544                                                  
1545           5                                 93         my $before_tbl = qr/(?:,|JOIN|\s|$from)+/i;
1546                                                  
1547           5                                 31         my $after_tbl  = qr/(?:,|JOIN|ON|USING|\z)/i;
1548                                                  
1549           5                                 30         $tbl_refs =~ s/ = /=/g;
1550                                                  
1551           5                                124         while (
1552                                                           $tbl_refs =~ m{
1553                                                              $before_tbl\b\s*
1554                                                                 ( ($tbl_ident) (?:\s+ (?:AS\s+)? (\w+))? )
1555                                                              \s*$after_tbl
1556                                                           }xgio )
1557                                                        {
1558           5                                 49            my ( $tbl_ref, $db_tbl, $alias ) = ($1, $2, $3);
1559           5                                 13            MKDEBUG && _d('Match table:', $tbl_ref);
1560           5                                 22            push @tbl_refs, $tbl_ref;
1561           5                                 39            $alias = $self->trim_identifier($alias);
1562                                                  
1563  ***      5     50                          31            if ( $tbl_ref =~ m/^AS\s+\w+/i ) {
1564  ***      0                                  0               MKDEBUG && _d('Subquery', $tbl_ref);
1565  ***      0                                  0               $result->{TABLE}->{$alias} = undef;
1566  ***      0                                  0               next;
1567                                                           }
1568                                                  
1569           5                                 44            my ( $db, $tbl ) = $db_tbl =~ m/^(?:(.*?)\.)?(.*)/;
1570           5                                 25            $db  = $self->trim_identifier($db);
1571           5                                 24            $tbl = $self->trim_identifier($tbl);
1572  ***      5            33                   59            $result->{TABLE}->{$alias || $tbl} = $tbl;
1573           5    100                          66            $result->{DATABASE}->{$tbl}        = $db if $db;
1574                                                        }
1575                                                     }
1576                                                     else {
1577  ***      0                                  0         MKDEBUG && _d("No tables ref in", $query);
1578                                                     }
1579                                                  
1580  ***      5     50                          22      if ( $list ) {
1581  ***      0                                  0         return \@tbl_refs;
1582                                                     }
1583                                                     else {
1584           5                                 23         return $result;
1585                                                     }
1586                                                  }
1587                                                  
1588                                                  sub split {
1589  ***      0                    0             0      my ( $self, $query ) = @_;
1590  ***      0      0                           0      return unless $query;
1591  ***      0                                  0      $query = $self->clean_query($query);
1592  ***      0                                  0      MKDEBUG && _d('Splitting', $query);
1593                                                  
1594  ***      0                                  0      my $verbs = qr{SELECT|INSERT|UPDATE|DELETE|REPLACE|UNION|CREATE}i;
1595                                                  
1596  ***      0                                  0      my @split_statements = grep { $_ } split(m/\b($verbs\b(?!(?:\s*\()))/io, $query);
      ***      0                                  0   
1597                                                  
1598  ***      0                                  0      my @statements;
1599  ***      0      0                           0      if ( @split_statements == 1 ) {
1600  ***      0                                  0         push @statements, $query;
1601                                                     }
1602                                                     else {
1603                                                        for ( my $i = 0; $i <= $#split_statements; $i += 2 ) {
1604  ***      0                                  0            push @statements, $split_statements[$i].$split_statements[$i+1];
1605                                                  
1606  ***      0      0      0                    0            if ( $statements[-2] && $statements[-2] =~ m/on duplicate key\s+$/i ) {
1607  ***      0                                  0               $statements[-2] .= pop @statements;
1608                                                           }
1609  ***      0                                  0         }
1610                                                     }
1611                                                  
1612  ***      0                                  0      MKDEBUG && _d('statements:', map { $_ ? "<$_>" : 'none' } @statements);
1613  ***      0                                  0      return @statements;
1614                                                  }
1615                                                  
1616                                                  sub clean_query {
1617  ***      0                    0             0      my ( $self, $query ) = @_;
1618  ***      0      0                           0      return unless $query;
1619  ***      0                                  0      $query =~ s!/\*.*?\*/! !g;  # Remove /* comment blocks */
1620  ***      0                                  0      $query =~ s/^\s+//;         # Remove leading spaces
1621  ***      0                                  0      $query =~ s/\s+$//;         # Remove trailing spaces
1622  ***      0                                  0      $query =~ s/\s{2,}/ /g;     # Remove extra spaces
1623  ***      0                                  0      return $query;
1624                                                  }
1625                                                  
1626                                                  sub split_subquery {
1627  ***      0                    0             0      my ( $self, $query ) = @_;
1628  ***      0      0                           0      return unless $query;
1629  ***      0                                  0      $query = $self->clean_query($query);
1630  ***      0                                  0      $query =~ s/;$//;
1631                                                  
1632  ***      0                                  0      my @subqueries;
1633  ***      0                                  0      my $sqno = 0;  # subquery number
1634  ***      0                                  0      my $pos  = 0;
1635  ***      0                                  0      while ( $query =~ m/(\S+)(?:\s+|\Z)/g ) {
1636  ***      0                                  0         $pos = pos($query);
1637  ***      0                                  0         my $word = $1;
1638  ***      0                                  0         MKDEBUG && _d($word, $sqno);
1639  ***      0      0                           0         if ( $word =~ m/^\(?SELECT\b/i ) {
1640  ***      0                                  0            my $start_pos = $pos - length($word) - 1;
1641  ***      0      0                           0            if ( $start_pos ) {
1642  ***      0                                  0               $sqno++;
1643  ***      0                                  0               MKDEBUG && _d('Subquery', $sqno, 'starts at', $start_pos);
1644  ***      0                                  0               $subqueries[$sqno] = {
1645                                                                 start_pos => $start_pos,
1646                                                                 end_pos   => 0,
1647                                                                 len       => 0,
1648                                                                 words     => [$word],
1649                                                                 lp        => 1, # left parentheses
1650                                                                 rp        => 0, # right parentheses
1651                                                                 done      => 0,
1652                                                              };
1653                                                           }
1654                                                           else {
1655  ***      0                                  0               MKDEBUG && _d('Main SELECT at pos 0');
1656                                                           }
1657                                                        }
1658                                                        else {
1659  ***      0      0                           0            next unless $sqno;  # next unless we're in a subquery
1660  ***      0                                  0            MKDEBUG && _d('In subquery', $sqno);
1661  ***      0                                  0            my $sq = $subqueries[$sqno];
1662  ***      0      0                           0            if ( $sq->{done} ) {
1663  ***      0                                  0               MKDEBUG && _d('This subquery is done; SQL is for',
1664                                                                 ($sqno - 1 ? "subquery $sqno" : "the main SELECT"));
1665  ***      0                                  0               next;
1666                                                           }
1667  ***      0                                  0            push @{$sq->{words}}, $word;
      ***      0                                  0   
1668  ***      0             0                    0            my $lp = ($word =~ tr/\(//) || 0;
1669  ***      0             0                    0            my $rp = ($word =~ tr/\)//) || 0;
1670  ***      0                                  0            MKDEBUG && _d('parentheses left', $lp, 'right', $rp);
1671  ***      0      0                           0            if ( ($sq->{lp} + $lp) - ($sq->{rp} + $rp) == 0 ) {
1672  ***      0                                  0               my $end_pos = $pos - 1;
1673  ***      0                                  0               MKDEBUG && _d('Subquery', $sqno, 'ends at', $end_pos);
1674  ***      0                                  0               $sq->{end_pos} = $end_pos;
1675  ***      0                                  0               $sq->{len}     = $end_pos - $sq->{start_pos};
1676                                                           }
1677                                                        }
1678                                                     }
1679                                                  
1680  ***      0                                  0      for my $i ( 1..$#subqueries ) {
1681  ***      0                                  0         my $sq = $subqueries[$i];
1682  ***      0      0                           0         next unless $sq;
1683  ***      0                                  0         $sq->{sql} = join(' ', @{$sq->{words}});
      ***      0                                  0   
1684  ***      0                                  0         substr $query,
1685                                                           $sq->{start_pos} + 1,  # +1 for (
1686                                                           $sq->{len} - 1,        # -1 for )
1687                                                           "__subquery_$i";
1688                                                     }
1689                                                  
1690  ***      0                                  0      return $query, map { $_->{sql} } grep { defined $_ } @subqueries;
      ***      0                                  0   
      ***      0                                  0   
1691                                                  }
1692                                                  
1693                                                  sub query_type {
1694  ***      0                    0             0      my ( $self, $query, $qr ) = @_;
1695  ***      0                                  0      my ($type, undef) = $qr->distill_verbs($query);
1696  ***      0                                  0      my $rw;
1697  ***      0      0      0                    0      if ( $type =~ m/^SELECT\b/ ) {
      ***             0                               
1698  ***      0                                  0         $rw = 'read';
1699                                                     }
1700                                                     elsif ( $type =~ m/^$data_manip_stmts\b/
1701                                                             || $type =~ m/^$data_def_stmts\b/  ) {
1702  ***      0                                  0         $rw = 'write'
1703                                                     }
1704                                                  
1705                                                     return {
1706  ***      0                                  0         type => $type,
1707                                                        rw   => $rw,
1708                                                     }
1709                                                  }
1710                                                  
1711                                                  sub get_columns {
1712  ***      0                    0             0      my ( $self, $query ) = @_;
1713  ***      0                                  0      my $cols = [];
1714  ***      0      0                           0      return $cols unless $query;
1715  ***      0                                  0      my $cols_def;
1716                                                  
1717  ***      0      0                           0      if ( $query =~ m/^SELECT/i ) {
      ***             0                               
1718  ***      0                                  0         $query =~ s/
1719                                                           ^SELECT\s+
1720                                                             (?:ALL
1721                                                                |DISTINCT
1722                                                                |DISTINCTROW
1723                                                                |HIGH_PRIORITY
1724                                                                |STRAIGHT_JOIN
1725                                                                |SQL_SMALL_RESULT
1726                                                                |SQL_BIG_RESULT
1727                                                                |SQL_BUFFER_RESULT
1728                                                                |SQL_CACHE
1729                                                                |SQL_NO_CACHE
1730                                                                |SQL_CALC_FOUND_ROWS
1731                                                             )\s+
1732                                                        /SELECT /xgi;
1733  ***      0                                  0         ($cols_def) = $query =~ m/^SELECT\s+(.+?)\s+FROM/i;
1734                                                     }
1735                                                     elsif ( $query =~ m/^(?:INSERT|REPLACE)/i ) {
1736  ***      0                                  0         ($cols_def) = $query =~ m/\(([^\)]+)\)\s*VALUE/i;
1737                                                     }
1738                                                  
1739  ***      0                                  0      MKDEBUG && _d('Columns:', $cols_def);
1740  ***      0      0                           0      if ( $cols_def ) {
1741  ***      0                                  0         @$cols = split(',', $cols_def);
1742  ***      0                                  0         map {
1743  ***      0                                  0            my $col = $_;
1744  ***      0                                  0            $col = s/^\s+//g;
1745  ***      0                                  0            $col = s/\s+$//g;
1746  ***      0                                  0            $col;
1747                                                        } @$cols;
1748                                                     }
1749                                                  
1750  ***      0                                  0      return $cols;
1751                                                  }
1752                                                  
1753                                                  sub parse {
1754  ***      0                    0             0      my ( $self, $query ) = @_;
1755  ***      0      0                           0      return unless $query;
1756  ***      0                                  0      my $parsed = {};
1757                                                  
1758  ***      0                                  0      $query =~ s/\n/ /g;
1759  ***      0                                  0      $query = $self->clean_query($query);
1760                                                  
1761  ***      0                                  0      $parsed->{query}   = $query,
1762                                                     $parsed->{tables}  = $self->get_aliases($query, 1);
1763  ***      0                                  0      $parsed->{columns} = $self->get_columns($query);
1764                                                  
1765  ***      0                                  0      my ($type) = $query =~ m/^(\w+)/;
1766  ***      0                                  0      $parsed->{type} = lc $type;
1767                                                  
1768                                                  
1769  ***      0                                  0      $parsed->{sub_queries} = [];
1770                                                  
1771  ***      0                                  0      return $parsed;
1772                                                  }
1773                                                  
1774                                                  sub extract_tables {
1775  ***      0                    0             0      my ( $self, %args ) = @_;
1776  ***      0                                  0      my $query      = $args{query};
1777  ***      0                                  0      my $default_db = $args{default_db};
1778  ***      0             0                    0      my $q          = $self->{Quoter} || $args{Quoter};
1779  ***      0      0                           0      return unless $query;
1780  ***      0                                  0      MKDEBUG && _d('Extracting tables');
1781  ***      0                                  0      my @tables;
1782  ***      0                                  0      my %seen;
1783  ***      0                                  0      foreach my $db_tbl ( $self->get_tables($query) ) {
1784  ***      0      0                           0         next unless $db_tbl;
1785  ***      0      0                           0         next if $seen{$db_tbl}++; # Unique-ify for issue 337.
1786  ***      0                                  0         my ( $db, $tbl ) = $q->split_unquote($db_tbl);
1787  ***      0             0                    0         push @tables, [ $db || $default_db, $tbl ];
1788                                                     }
1789  ***      0                                  0      return @tables;
1790                                                  }
1791                                                  
1792                                                  sub trim_identifier {
1793          15                   15            61      my ($self, $str) = @_;
1794          15    100                          79      return unless defined $str;
1795           6                                 29      $str =~ s/`//g;
1796           6                                 25      $str =~ s/^\s+//;
1797           6                                 25      $str =~ s/\s+$//;
1798           6                                 27      return $str;
1799                                                  }
1800                                                  
1801                                                  sub _d {
1802  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1803  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1804  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1805                                                          @_;
1806  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1807                                                  }
1808                                                  
1809                                                  1;
1810                                                  
1811                                                  # ###########################################################################
1812                                                  # End QueryParser package
1813                                                  # ###########################################################################
1814                                                  
1815                                                  # ###########################################################################
1816                                                  # QueryRewriter package 6132
1817                                                  # This package is a copy without comments from the original.  The original
1818                                                  # with comments and its test file can be found in the SVN repository at,
1819                                                  #   trunk/common/QueryRewriter.pm
1820                                                  #   trunk/common/t/QueryRewriter.t
1821                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1822                                                  # ###########################################################################
1823           1                    1             8   use strict;
               1                                  2   
               1                                  6   
1824           1                    1             6   use warnings FATAL => 'all';
               1                                  6   
               1                                  6   
1825                                                  
1826                                                  package QueryRewriter;
1827                                                  
1828           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
1829                                                  
1830  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 20   
1831                                                  
1832                                                  our $verbs   = qr{^SHOW|^FLUSH|^COMMIT|^ROLLBACK|^BEGIN|SELECT|INSERT
1833                                                                    |UPDATE|DELETE|REPLACE|^SET|UNION|^START|^LOCK}xi;
1834                                                  my $quote_re = qr/"(?:(?!(?<!\\)").)*"|'(?:(?!(?<!\\)').)*'/; # Costly!
1835                                                  my $bal;
1836                                                  $bal         = qr/
1837                                                                    \(
1838                                                                    (?:
1839                                                                       (?> [^()]+ )    # Non-parens without backtracking
1840                                                                       |
1841                                                                       (??{ $bal })    # Group with matching parens
1842                                                                    )*
1843                                                                    \)
1844                                                                   /x;
1845                                                  
1846                                                  my $olc_re = qr/(?:--|#)[^'"\r\n]*(?=[\r\n]|\Z)/;  # One-line comments
1847                                                  my $mlc_re = qr#/\*[^!].*?\*/#sm;                  # But not /*!version */
1848                                                  my $vlc_re = qr#/\*.*?[0-9+].*?\*/#sm;             # For SHOW + /*!version */
1849                                                  my $vlc_rf = qr#^(SHOW).*?/\*![0-9+].*?\*/#sm;     # Variation for SHOW
1850                                                  
1851                                                  
1852                                                  sub new {
1853           6                    6            40      my ( $class, %args ) = @_;
1854           6                                 39      my $self = { %args };
1855           6                                 51      return bless $self, $class;
1856                                                  }
1857                                                  
1858                                                  sub strip_comments {
1859  ***      0                    0             0      my ( $self, $query ) = @_;
1860  ***      0      0                           0      return unless $query;
1861  ***      0                                  0      $query =~ s/$olc_re//go;
1862  ***      0                                  0      $query =~ s/$mlc_re//go;
1863  ***      0      0                           0      if ( $query =~ m/$vlc_rf/i ) { # contains show + version
1864  ***      0                                  0         $query =~ s/$vlc_re//go;
1865                                                     }
1866  ***      0                                  0      return $query;
1867                                                  }
1868                                                  
1869                                                  sub shorten {
1870  ***      0                    0             0      my ( $self, $query, $length ) = @_;
1871  ***      0                                  0      $query =~ s{
1872                                                        \A(
1873                                                           (?:INSERT|REPLACE)
1874                                                           (?:\s+LOW_PRIORITY|DELAYED|HIGH_PRIORITY|IGNORE)?
1875                                                           (?:\s\w+)*\s+\S+\s+VALUES\s*\(.*?\)
1876                                                        )
1877                                                        \s*,\s*\(.*?(ON\s+DUPLICATE|\Z)}
1878                                                        {$1 /*... omitted ...*/$2}xsi;
1879                                                  
1880  ***      0      0                           0      return $query unless $query =~ m/IN\s*\(\s*(?!select)/i;
1881                                                  
1882  ***      0                                  0      my $last_length  = 0;
1883  ***      0                                  0      my $query_length = length($query);
1884  ***      0             0                    0      while (
      ***                    0                        
      ***                    0                        
1885                                                        $length          > 0
1886                                                        && $query_length > $length
1887                                                        && $query_length < ( $last_length || $query_length + 1 )
1888                                                     ) {
1889  ***      0                                  0         $last_length = $query_length;
1890  ***      0                                  0         $query =~ s{
1891  ***      0                                  0            (\bIN\s*\()    # The opening of an IN list
1892                                                           ([^\)]+)       # Contents of the list, assuming no item contains paren
1893                                                           (?=\))           # Close of the list
1894                                                        }
1895                                                        {
1896                                                           $1 . __shorten($2)
1897                                                        }gexsi;
1898                                                     }
1899                                                  
1900  ***      0                                  0      return $query;
1901                                                  }
1902                                                  
1903                                                  sub __shorten {
1904  ***      0                    0             0      my ( $snippet ) = @_;
1905  ***      0                                  0      my @vals = split(/,/, $snippet);
1906  ***      0      0                           0      return $snippet unless @vals > 20;
1907  ***      0                                  0      my @keep = splice(@vals, 0, 20);  # Remove and save the first 20 items
1908                                                     return
1909  ***      0                                  0         join(',', @keep)
1910                                                        . "/*... omitted "
1911                                                        . scalar(@vals)
1912                                                        . " items ...*/";
1913                                                  }
1914                                                  
1915                                                  sub fingerprint {
1916           7                    7            43      my ( $self, $query ) = @_;
1917                                                  
1918  ***      7     50                          42      $query =~ m#\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `# # mysqldump query
1919                                                        && return 'mysqldump';
1920  ***      7     50                          41      $query =~ m#/\*\w+\.\w+:[0-9]/[0-9]\*/#     # mk-table-checksum, etc query
1921                                                        && return 'maatkit';
1922  ***      7     50                          40      $query =~ m/\Aadministrator command: /
1923                                                        && return $query;
1924  ***      7     50                          41      $query =~ m/\A\s*(call\s+\S+)\(/i
1925                                                        && return lc($1); # Warning! $1 used, be careful.
1926  ***      7     50                          43      if ( my ($beginning) = $query =~ m/\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is ) {
1927  ***      0                                  0         $query = $beginning; # Shorten multi-value INSERT statements ASAP
1928                                                     }
1929                                                    
1930           7                                 46      $query =~ s/$olc_re//go;
1931           7                                 26      $query =~ s/$mlc_re//go;
1932  ***      7     50                          46      $query =~ s/\Ause \S+\Z/use ?/i       # Abstract the DB in USE
1933                                                        && return $query;
1934                                                  
1935           7                                 29      $query =~ s/\\["']//g;                # quoted strings
1936           7                                 24      $query =~ s/".*?"/?/sg;               # quoted strings
1937           7                                 24      $query =~ s/'.*?'/?/sg;               # quoted strings
1938           7                                 30      $query =~ s/[0-9+-][0-9a-f.xb+-]*/?/g;# Anything vaguely resembling numbers
1939           7                                 24      $query =~ s/[xb.+-]\?/?/g;            # Clean up leftovers
1940           7                                 24      $query =~ s/\A\s+//;                  # Chop off leading whitespace
1941           7                                 26      chomp $query;                         # Kill trailing whitespace
1942           7                                 34      $query =~ tr[ \n\t\r\f][ ]s;          # Collapse whitespace
1943           7                                 26      $query = lc $query;
1944           7                                 38      $query =~ s/\bnull\b/?/g;             # Get rid of NULLs
1945           7                                 28      $query =~ s{                          # Collapse IN and VALUES lists
1946                                                                 \b(in|values?)(?:[\s,]*\([\s?,]*\))+
1947                                                                }
1948                                                                {$1(?+)}gx;
1949           7                                 33      $query =~ s{                          # Collapse UNION
1950                                                                 \b(select\s.*?)(?:(\sunion(?:\sall)?)\s\1)+
1951                                                                }
1952                                                                {$1 /*repeat$2*/}xg;
1953           7                                 24      $query =~ s/\blimit \?(?:, ?\?| offset \?)?/limit ?/; # LIMIT
1954           7                                 43      return $query;
1955                                                  }
1956                                                  
1957                                                  sub distill_verbs {
1958  ***      0                    0             0      my ( $self, $query ) = @_;
1959                                                  
1960  ***      0      0                           0      $query =~ m/\A\s*call\s+(\S+)\(/i && return "CALL $1";
1961  ***      0      0                           0      $query =~ m/\A\s*use\s+/          && return "USE";
1962  ***      0      0                           0      $query =~ m/\A\s*UNLOCK TABLES/i  && return "UNLOCK";
1963  ***      0      0                           0      $query =~ m/\A\s*xa\s+(\S+)/i     && return "XA_$1";
1964                                                  
1965  ***      0      0                           0      if ( $query =~ m/\Aadministrator command:/ ) {
1966  ***      0                                  0         $query =~ s/administrator command:/ADMIN/;
1967  ***      0                                  0         $query = uc $query;
1968  ***      0                                  0         return $query;
1969                                                     }
1970                                                  
1971  ***      0                                  0      $query = $self->strip_comments($query);
1972                                                  
1973  ***      0      0                           0      if ( $query =~ m/\A\s*SHOW\s+/i ) {
1974  ***      0                                  0         MKDEBUG && _d($query);
1975                                                  
1976  ***      0                                  0         $query = uc $query;
1977  ***      0                                  0         $query =~ s/\s+(?:GLOBAL|SESSION|FULL|STORAGE|ENGINE)\b/ /g;
1978  ***      0                                  0         $query =~ s/\s+COUNT[^)]+\)//g;
1979                                                  
1980  ***      0                                  0         $query =~ s/\s+(?:FOR|FROM|LIKE|WHERE|LIMIT|IN)\b.+//ms;
1981                                                  
1982  ***      0                                  0         $query =~ s/\A(SHOW(?:\s+\S+){1,2}).*\Z/$1/s;
1983  ***      0                                  0         $query =~ s/\s+/ /g;
1984  ***      0                                  0         MKDEBUG && _d($query);
1985  ***      0                                  0         return $query;
1986                                                     }
1987                                                  
1988  ***      0                                  0      eval $QueryParser::data_def_stmts;
1989  ***      0                                  0      eval $QueryParser::tbl_ident;
1990  ***      0                                  0      my ( $dds ) = $query =~ /^\s*($QueryParser::data_def_stmts)\b/i;
1991  ***      0      0                           0      if ( $dds) {
1992  ***      0                                  0         my ( $obj ) = $query =~ m/$dds.+(DATABASE|TABLE)\b/i;
1993  ***      0      0                           0         $obj = uc $obj if $obj;
1994  ***      0                                  0         MKDEBUG && _d('Data def statment:', $dds, 'obj:', $obj);
1995  ***      0                                  0         my ($db_or_tbl)
1996                                                           = $query =~ m/(?:TABLE|DATABASE)\s+($QueryParser::tbl_ident)(\s+.*)?/i;
1997  ***      0                                  0         MKDEBUG && _d('Matches db or table:', $db_or_tbl);
1998  ***      0      0                           0         return uc($dds . ($obj ? " $obj" : '')), $db_or_tbl;
1999                                                     }
2000                                                  
2001  ***      0                                  0      my @verbs = $query =~ m/\b($verbs)\b/gio;
2002  ***      0                                  0      @verbs    = do {
2003  ***      0                                  0         my $last = '';
2004  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } map { uc } @verbs;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
2005                                                     };
2006  ***      0                                  0      my $verb_str = join(q{ }, @verbs);
2007  ***      0                                  0      $verb_str =~ s/( UNION SELECT)+/ UNION/g;
2008                                                  
2009  ***      0                                  0      return $verb_str;
2010                                                  }
2011                                                  
2012                                                  sub __distill_tables {
2013  ***      0                    0             0      my ( $self, $query, $table, %args ) = @_;
2014  ***      0             0                    0      my $qp = $args{QueryParser} || $self->{QueryParser};
2015  ***      0      0                           0      die "I need a QueryParser argument" unless $qp;
2016                                                  
2017  ***      0                                  0      my @tables = map {
2018  ***      0                                  0         $_ =~ s/`//g;
2019  ***      0                                  0         $_ =~ s/(_?)[0-9]+/$1?/g;
2020  ***      0                                  0         $_;
2021  ***      0                                  0      } grep { defined $_ } $qp->get_tables($query);
2022                                                  
2023  ***      0      0                           0      push @tables, $table if $table;
2024                                                  
2025  ***      0                                  0      @tables = do {
2026  ***      0                                  0         my $last = '';
2027  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } @tables;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
2028                                                     };
2029                                                  
2030  ***      0                                  0      return @tables;
2031                                                  }
2032                                                  
2033                                                  sub distill {
2034  ***      0                    0             0      my ( $self, $query, %args ) = @_;
2035                                                  
2036  ***      0      0                           0      if ( $args{generic} ) {
2037  ***      0                                  0         my ($cmd, $arg) = $query =~ m/^(\S+)\s+(\S+)/;
2038  ***      0      0                           0         return '' unless $cmd;
2039  ***      0      0                           0         $query = (uc $cmd) . ($arg ? " $arg" : '');
2040                                                     }
2041                                                     else {
2042  ***      0                                  0         my ($verbs, $table)  = $self->distill_verbs($query, %args);
2043                                                  
2044  ***      0      0      0                    0         if ( $verbs && $verbs =~ m/^SHOW/ ) {
2045  ***      0                                  0            my %alias_for = qw(
2046                                                              SCHEMA   DATABASE
2047                                                              KEYS     INDEX
2048                                                              INDEXES  INDEX
2049                                                           );
2050  ***      0                                  0            map { $verbs =~ s/$_/$alias_for{$_}/ } keys %alias_for;
      ***      0                                  0   
2051  ***      0                                  0            $query = $verbs;
2052                                                        }
2053                                                        else {
2054  ***      0                                  0            my @tables = $self->__distill_tables($query, $table, %args);
2055  ***      0                                  0            $query     = join(q{ }, $verbs, @tables); 
2056                                                        } 
2057                                                     }
2058                                                  
2059  ***      0      0                           0      if ( $args{trf} ) {
2060  ***      0                                  0         $query = $args{trf}->($query, %args);
2061                                                     }
2062                                                  
2063  ***      0                                  0      return $query;
2064                                                  }
2065                                                  
2066                                                  sub convert_to_select {
2067           1                    1             5      my ( $self, $query ) = @_;
2068  ***      1     50                           5      return unless $query;
2069  ***      0                                  0      $query =~ s{
      ***      0                                  0   
2070                                                                   \A.*?
2071                                                                   update\s+(.*?)
2072                                                                   \s+set\b(.*?)
2073                                                                   (?:\s*where\b(.*?))?
2074                                                                   (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
2075                                                                   \Z
2076                                                                }
2077                                                                {__update_to_select($1, $2, $3, $4)}exsi
2078  ***      0                                  0         || $query =~ s{
2079                                                                      \A.*?
2080                                                                      (?:insert(?:\s+ignore)?|replace)\s+
2081                                                                      .*?\binto\b(.*?)\(([^\)]+)\)\s*
2082                                                                      values?\s*(\(.*?\))\s*
2083                                                                      (?:\blimit\b|on\s+duplicate\s+key.*)?\s*
2084                                                                      \Z
2085                                                                   }
2086                                                                   {__insert_to_select($1, $2, $3)}exsi
2087  ***      0                                  0         || $query =~ s{
2088                                                                      \A.*?
2089                                                                      (?:insert(?:\s+ignore)?|replace)\s+
2090                                                                      (?:.*?\binto)\b(.*?)\s*
2091                                                                      set\s+(.*?)\s*
2092                                                                      (?:\blimit\b|on\s+duplicate\s+key.*)?\s*
2093                                                                      \Z
2094                                                                   }
2095                                                                   {__insert_to_select_with_set($1, $2)}exsi
2096  ***      1     50     33                   40         || $query =~ s{
      ***                   33                        
2097                                                                      \A.*?
2098                                                                      delete\s+(.*?)
2099                                                                      \bfrom\b(.*)
2100                                                                      \Z
2101                                                                   }
2102                                                                   {__delete_to_select($1, $2)}exsi;
2103           1                                 15      $query =~ s/\s*on\s+duplicate\s+key\s+update.*\Z//si;
2104           1                                  7      $query =~ s/\A.*?(?=\bSELECT\s*\b)//ism;
2105           1                                  5      return $query;
2106                                                  }
2107                                                  
2108                                                  sub convert_select_list {
2109  ***      0                    0             0      my ( $self, $query ) = @_;
2110  ***      0      0                           0      $query =~ s{
      ***      0                                  0   
2111                                                                 \A\s*select(.*?)\bfrom\b
2112                                                                }
2113                                                                {$1 =~ m/\*/ ? "select 1 from" : "select isnull(coalesce($1)) from"}exi;
2114  ***      0                                  0      return $query;
2115                                                  }
2116                                                  
2117                                                  sub __delete_to_select {
2118  ***      0                    0             0      my ( $delete, $join ) = @_;
2119  ***      0      0                           0      if ( $join =~ m/\bjoin\b/ ) {
2120  ***      0                                  0         return "select 1 from $join";
2121                                                     }
2122  ***      0                                  0      return "select * from $join";
2123                                                  }
2124                                                  
2125                                                  sub __insert_to_select {
2126  ***      0                    0             0      my ( $tbl, $cols, $vals ) = @_;
2127  ***      0                                  0      MKDEBUG && _d('Args:', @_);
2128  ***      0                                  0      my @cols = split(/,/, $cols);
2129  ***      0                                  0      MKDEBUG && _d('Cols:', @cols);
2130  ***      0                                  0      $vals =~ s/^\(|\)$//g; # Strip leading/trailing parens
2131  ***      0                                  0      my @vals = $vals =~ m/($quote_re|[^,]*${bal}[^,]*|[^,]+)/g;
2132  ***      0                                  0      MKDEBUG && _d('Vals:', @vals);
2133  ***      0      0                           0      if ( @cols == @vals ) {
2134  ***      0                                  0         return "select * from $tbl where "
2135  ***      0                                  0            . join(' and ', map { "$cols[$_]=$vals[$_]" } (0..$#cols));
2136                                                     }
2137                                                     else {
2138  ***      0                                  0         return "select * from $tbl limit 1";
2139                                                     }
2140                                                  }
2141                                                  
2142                                                  sub __insert_to_select_with_set {
2143  ***      0                    0             0      my ( $from, $set ) = @_;
2144  ***      0                                  0      $set =~ s/,/ and /g;
2145  ***      0                                  0      return "select * from $from where $set ";
2146                                                  }
2147                                                  
2148                                                  sub __update_to_select {
2149  ***      0                    0             0      my ( $from, $set, $where, $limit ) = @_;
2150  ***      0      0                           0      return "select $set from $from "
      ***             0                               
2151                                                        . ( $where ? "where $where" : '' )
2152                                                        . ( $limit ? " $limit "      : '' );
2153                                                  }
2154                                                  
2155                                                  sub wrap_in_derived {
2156  ***      0                    0             0      my ( $self, $query ) = @_;
2157  ***      0      0                           0      return unless $query;
2158  ***      0      0                           0      return $query =~ m/\A\s*select/i
2159                                                        ? "select 1 from ($query) as x limit 1"
2160                                                        : $query;
2161                                                  }
2162                                                  
2163                                                  sub _d {
2164  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2165  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2166  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2167                                                          @_;
2168  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2169                                                  }
2170                                                  
2171                                                  1;
2172                                                  
2173                                                  # ###########################################################################
2174                                                  # End QueryRewriter package
2175                                                  # ###########################################################################
2176                                                  
2177                                                  # ###########################################################################
2178                                                  # SlowLogParser package 6043
2179                                                  # ###########################################################################
2180                                                  package SlowLogParser;
2181                                                  
2182           1                    1             8   use strict;
               1                                  6   
               1                                  6   
2183           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
2184           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
2185           1                    1             7   use Data::Dumper;
               1                                  2   
               1                                  6   
2186                                                  
2187  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 13   
2188                                                  
2189                                                  sub new {
2190           6                    6            34      my ( $class ) = @_;
2191           6                                 32      my $self = {
2192                                                        pending => [],
2193                                                     };
2194           6                                 36      return bless $self, $class;
2195                                                  }
2196                                                  
2197                                                  my $slow_log_ts_line = qr/^# Time: ([0-9: ]{15})/;
2198                                                  my $slow_log_uh_line = qr/# User\@Host: ([^\[]+|\[[^[]+\]).*?@ (\S*) \[(.*)\]/;
2199                                                  my $slow_log_hd_line = qr{
2200                                                        ^(?:
2201                                                        T[cC][pP]\s[pP]ort:\s+\d+ # case differs on windows/unix
2202                                                        |
2203                                                        [/A-Z].*mysqld,\sVersion.*(?:started\swith:|embedded\slibrary)
2204                                                        |
2205                                                        Time\s+Id\s+Command
2206                                                        ).*\n
2207                                                     }xm;
2208                                                  
2209                                                  sub parse_event {
2210          13                   13           142      my ( $self, %args ) = @_;
2211          13                                 74      my @required_args = qw(next_event tell);
2212          13                                 57      foreach my $arg ( @required_args ) {
2213  ***     26     50                         134         die "I need a $arg argument" unless $args{$arg};
2214                                                     }
2215          13                                 65      my ($next_event, $tell) = @args{@required_args};
2216                                                  
2217          13                                 53      my $pending = $self->{pending};
2218          13                                 88      local $INPUT_RECORD_SEPARATOR = ";\n#";
2219          13                                 54      my $trimlen    = length($INPUT_RECORD_SEPARATOR);
2220          13                                 54      my $pos_in_log = $tell->();
2221          13                                 36      my $stmt;
2222                                                  
2223                                                     EVENT:
2224  ***     13            66                  122      while (
2225                                                           defined($stmt = shift @$pending)
2226                                                        or defined($stmt = $next_event->())
2227                                                     ) {
2228           7                                 48         my @properties = ('cmd', 'Query', 'pos_in_log', $pos_in_log);
2229           7                                 24         $pos_in_log = $tell->();
2230                                                  
2231  ***      7     50                          85         if ( $stmt =~ s/$slow_log_hd_line//go ){ # Throw away header lines in log
2232  ***      0                                  0            my @chunks = split(/$INPUT_RECORD_SEPARATOR/o, $stmt);
2233  ***      0      0                           0            if ( @chunks > 1 ) {
2234  ***      0                                  0               MKDEBUG && _d("Found multiple chunks");
2235  ***      0                                  0               $stmt = shift @chunks;
2236  ***      0                                  0               unshift @$pending, @chunks;
2237                                                           }
2238                                                        }
2239                                                  
2240           7    100                          50         $stmt = '#' . $stmt unless $stmt =~ m/\A#/;
2241           7                                 51         $stmt =~ s/;\n#?\Z//;
2242                                                  
2243                                                  
2244           7                                 32         my ($got_ts, $got_uh, $got_ac, $got_db, $got_set, $got_embed);
2245           7                                 22         my $pos = 0;
2246           7                                 21         my $len = length($stmt);
2247           7                                 22         my $found_arg = 0;
2248                                                        LINE:
2249           7                                 45         while ( $stmt =~ m/^(.*)$/mg ) { # /g is important, requires scalar match.
2250          31                                100            $pos     = pos($stmt);  # Be careful not to mess this up!
2251          31                                128            my $line = $1;          # Necessary for /g and pos() to work.
2252          31                                 73            MKDEBUG && _d($line);
2253                                                  
2254          31    100                         244            if ($line =~ m/^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) {
2255                                                  
2256  ***     24    100     66                  529               if ( !$got_ts && (my ( $time ) = $line =~ m/$slow_log_ts_line/o)) {
                    100    100                        
      ***            50     33                        
      ***           100     33                        
      ***            50      0                        
      ***             0                               
2257           7                                 20                  MKDEBUG && _d("Got ts", $time);
2258           7                                 26                  push @properties, 'ts', $time;
2259           7                                 21                  ++$got_ts;
2260  ***      7     50     33                  111                  if ( !$got_uh
2261                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
2262                                                                 ) {
2263  ***      0                                  0                     MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
2264  ***      0                                  0                     push @properties, 'user', $user, 'host', $host, 'ip', $ip;
2265  ***      0                                  0                     ++$got_uh;
2266                                                                 }
2267                                                              }
2268                                                  
2269                                                              elsif ( !$got_uh
2270                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
2271                                                              ) {
2272           3                                  7                  MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
2273           3                                 15                  push @properties, 'user', $user, 'host', $host, 'ip', $ip;
2274           3                                  7                  ++$got_uh;
2275                                                              }
2276                                                  
2277                                                              elsif (!$got_ac && $line =~ m/^# (?:administrator command:.*)$/) {
2278  ***      0                                  0                  MKDEBUG && _d("Got admin command");
2279  ***      0                                  0                  $line =~ s/^#\s+//;  # string leading "# ".
2280  ***      0                                  0                  push @properties, 'cmd', 'Admin', 'arg', $line;
2281  ***      0                                  0                  push @properties, 'bytes', length($properties[-1]);
2282  ***      0                                  0                  ++$found_arg;
2283  ***      0                                  0                  ++$got_ac;
2284                                                              }
2285                                                  
2286                                                              elsif ( $line =~ m/^# +[A-Z][A-Za-z_]+: \S+/ ) { # Make the test cheap!
2287           7                                 20                  MKDEBUG && _d("Got some line with properties");
2288           7                                110                  my @temp = $line =~ m/(\w+):\s+(\S+|\Z)/g;
2289           7                                 49                  push @properties, @temp;
2290                                                              }
2291                                                  
2292                                                              elsif ( !$got_db && (my ( $db ) = $line =~ m/^use ([^;]+)/ ) ) {
2293           7                                 21                  MKDEBUG && _d("Got a default database:", $db);
2294           7                                 30                  push @properties, 'db', $db;
2295           7                                 21                  ++$got_db;
2296                                                              }
2297                                                  
2298                                                              elsif (!$got_set && (my ($setting) = $line =~ m/^SET\s+([^;]*)/)) {
2299  ***      0                                  0                  MKDEBUG && _d("Got some setting:", $setting);
2300  ***      0                                  0                  push @properties, split(/,|\s*=\s*/, $setting);
2301  ***      0                                  0                  ++$got_set;
2302                                                              }
2303                                                  
2304  ***     24     50     33                  319               if ( !$found_arg && $pos == $len ) {
2305  ***      0                                  0                  MKDEBUG && _d("Did not find arg, looking for special cases");
2306  ***      0                                  0                  local $INPUT_RECORD_SEPARATOR = ";\n";
2307  ***      0      0                           0                  if ( defined(my $l = $next_event->()) ) {
2308  ***      0                                  0                     chomp $l;
2309  ***      0                                  0                     $l =~ s/^\s+//;
2310  ***      0                                  0                     MKDEBUG && _d("Found admin statement", $l);
2311  ***      0                                  0                     push @properties, 'cmd', 'Admin', 'arg', $l;
2312  ***      0                                  0                     push @properties, 'bytes', length($properties[-1]);
2313  ***      0                                  0                     $found_arg++;
2314                                                                 }
2315                                                                 else {
2316  ***      0                                  0                     MKDEBUG && _d("I can't figure out what to do with this line");
2317  ***      0                                  0                     next EVENT;
2318                                                                 }
2319                                                              }
2320                                                           }
2321                                                           else {
2322           7                                 16               MKDEBUG && _d("Got the query/arg line");
2323           7                                 39               my $arg = substr($stmt, $pos - length($line));
2324           7                                 35               push @properties, 'arg', $arg, 'bytes', length($arg);
2325  ***      7     50     33                   92               if ( $args{misc} && $args{misc}->{embed}
      ***                   33                        
2326                                                                 && ( my ($e) = $arg =~ m/($args{misc}->{embed})/)
2327                                                              ) {
2328  ***      0                                  0                  push @properties, $e =~ m/$args{misc}->{capture}/g;
2329                                                              }
2330           7                                 28               last LINE;
2331                                                           }
2332                                                        }
2333                                                  
2334           7                                 15         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
2335           7                                 97         my $event = { @properties };
2336           7                                 84         return $event;
2337                                                     } # EVENT
2338                                                  
2339           6                                 25      @$pending = ();
2340  ***      6     50                          40      $args{oktorun}->(0) if $args{oktorun};
2341           6                                 52      return;
2342                                                  }
2343                                                  
2344                                                  sub _d {
2345  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2346  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2347  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2348                                                          @_;
2349  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2350                                                  }
2351                                                  
2352                                                  1;
2353                                                  
2354                                                  # ###########################################################################
2355                                                  # End SlowLogParser package
2356                                                  # ###########################################################################
2357                                                  
2358                                                  # ###########################################################################
2359                                                  # TableParser package 5980
2360                                                  # ###########################################################################
2361                                                  package TableParser;
2362                                                  
2363           1                    1             7   use strict;
               1                                  2   
               1                                  6   
2364           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
2365           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
2366           1                    1             7   use Data::Dumper;
               1                                  2   
               1                                  4   
2367                                                  $Data::Dumper::Indent    = 1;
2368                                                  $Data::Dumper::Sortkeys  = 1;
2369                                                  $Data::Dumper::Quotekeys = 0;
2370                                                  
2371  ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 12   
2372                                                  
2373                                                  
2374                                                  sub new {
2375           6                    6            44      my ( $class, %args ) = @_;
2376           6                                 33      my @required_args = qw(Quoter);
2377           6                                 35      foreach my $arg ( @required_args ) {
2378  ***      6     50                          44         die "I need a $arg argument" unless $args{$arg};
2379                                                     }
2380           6                                 31      my $self = { %args };
2381           6                                 42      return bless $self, $class;
2382                                                  }
2383                                                  
2384                                                  
2385                                                  sub parse {
2386  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
2387  ***      0      0                           0      return unless $ddl;
2388  ***      0      0                           0      if ( ref $ddl eq 'ARRAY' ) {
2389  ***      0      0                           0         if ( lc $ddl->[0] eq 'table' ) {
2390  ***      0                                  0            $ddl = $ddl->[1];
2391                                                        }
2392                                                        else {
2393                                                           return {
2394  ***      0                                  0               engine => 'VIEW',
2395                                                           };
2396                                                        }
2397                                                     }
2398                                                  
2399  ***      0      0                           0      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
2400  ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
2401                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
2402                                                     }
2403                                                  
2404  ***      0                                  0      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
2405  ***      0      0                           0      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
2406                                                  
2407  ***      0                                  0      $ddl =~ s/(`[^`]+`)/\L$1/g;
2408                                                  
2409  ***      0                                  0      my $engine = $self->get_engine($ddl);
2410                                                  
2411  ***      0                                  0      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
2412  ***      0                                  0      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                  0   
2413  ***      0                                  0      MKDEBUG && _d('Table cols:', join(', ', map { "`$_`" } @cols));
2414                                                  
2415  ***      0                                  0      my %def_for;
2416  ***      0                                  0      @def_for{@cols} = @defs;
2417                                                  
2418  ***      0                                  0      my (@nums, @null);
2419  ***      0                                  0      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
2420  ***      0                                  0      foreach my $col ( @cols ) {
2421  ***      0                                  0         my $def = $def_for{$col};
2422  ***      0                                  0         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
2423  ***      0      0                           0         die "Can't determine column type for $def" unless $type;
2424  ***      0                                  0         $type_for{$col} = $type;
2425  ***      0      0                           0         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
2426  ***      0                                  0            push @nums, $col;
2427  ***      0                                  0            $is_numeric{$col} = 1;
2428                                                        }
2429  ***      0      0                           0         if ( $def !~ m/NOT NULL/ ) {
2430  ***      0                                  0            push @null, $col;
2431  ***      0                                  0            $is_nullable{$col} = 1;
2432                                                        }
2433  ***      0      0                           0         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
2434                                                     }
2435                                                  
2436  ***      0                                  0      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
2437                                                  
2438                                                     return {
2439  ***      0                                  0         name           => $name,
2440                                                        cols           => \@cols,
2441  ***      0                                  0         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
2442  ***      0                                  0         is_col         => { map { $_ => 1 } @cols },
2443                                                        null_cols      => \@null,
2444                                                        is_nullable    => \%is_nullable,
2445                                                        is_autoinc     => \%is_autoinc,
2446                                                        clustered_key  => $clustered_key,
2447                                                        keys           => $keys,
2448                                                        defs           => \%def_for,
2449                                                        numeric_cols   => \@nums,
2450                                                        is_numeric     => \%is_numeric,
2451                                                        engine         => $engine,
2452                                                        type_for       => \%type_for,
2453                                                     };
2454                                                  }
2455                                                  
2456                                                  sub sort_indexes {
2457  ***      0                    0             0      my ( $self, $tbl ) = @_;
2458                                                  
2459                                                     my @indexes
2460  ***      0                                  0         = sort {
2461  ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
2462                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
2463                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
2464  ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
2465                                                        }
2466                                                        grep {
2467  ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
2468                                                        }
2469  ***      0                                  0         sort keys %{$tbl->{keys}};
2470                                                  
2471  ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
2472  ***      0                                  0      return @indexes;
2473                                                  }
2474                                                  
2475                                                  sub find_best_index {
2476  ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
2477  ***      0                                  0      my $best;
2478  ***      0      0                           0      if ( $index ) {
2479  ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
2480                                                     }
2481  ***      0      0                           0      if ( !$best ) {
2482  ***      0      0                           0         if ( $index ) {
2483  ***      0                                  0            die "Index '$index' does not exist in table";
2484                                                        }
2485                                                        else {
2486  ***      0                                  0            ($best) = $self->sort_indexes($tbl);
2487                                                        }
2488                                                     }
2489  ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
2490  ***      0                                  0      return $best;
2491                                                  }
2492                                                  
2493                                                  sub find_possible_keys {
2494  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
2495  ***      0      0                           0      return () unless $where;
2496  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
2497                                                        . ' WHERE ' . $where;
2498  ***      0                                  0      MKDEBUG && _d($sql);
2499  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
2500  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
2501  ***      0      0                           0      if ( $expl->{possible_keys} ) {
2502  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
2503  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
2504  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
2505  ***      0      0                           0         if ( $expl->{key} ) {
2506  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
2507  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
2508  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
2509  ***      0                                  0            my %seen;
2510  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
2511                                                        }
2512  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
2513  ***      0                                  0         return @candidates;
2514                                                     }
2515                                                     else {
2516  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
2517  ***      0                                  0         return ();
2518                                                     }
2519                                                  }
2520                                                  
2521                                                  sub check_table {
2522  ***      0                    0             0      my ( $self, %args ) = @_;
2523  ***      0                                  0      my @required_args = qw(dbh db tbl);
2524  ***      0                                  0      foreach my $arg ( @required_args ) {
2525  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2526                                                     }
2527  ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
2528  ***      0                                  0      my $q      = $self->{Quoter};
2529  ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
2530  ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
2531                                                  
2532  ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
2533                                                             . ' LIKE ' . $q->literal_like($tbl);
2534  ***      0                                  0      MKDEBUG && _d($sql);
2535  ***      0                                  0      my $row;
2536  ***      0                                  0      eval {
2537  ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
2538                                                     };
2539  ***      0      0                           0      if ( $EVAL_ERROR ) {
2540  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
2541  ***      0                                  0         return 0;
2542                                                     }
2543  ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
2544  ***      0                                  0         MKDEBUG && _d('Table does not exist');
2545  ***      0                                  0         return 0;
2546                                                     }
2547                                                  
2548  ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
2549  ***      0      0                           0      return 1 unless $args{all_privs};
2550                                                  
2551  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
2552  ***      0                                  0      MKDEBUG && _d($sql);
2553  ***      0                                  0      eval {
2554  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
2555                                                     };
2556  ***      0      0                           0      if ( $EVAL_ERROR ) {
2557  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
2558  ***      0                                  0         return 0;
2559                                                     }
2560  ***      0      0                           0      if ( !scalar keys %$row ) {
2561  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
2562  ***      0                                  0         return 0;
2563                                                     }
2564  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
2565                                                  
2566  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
2567  ***      0                                  0      MKDEBUG && _d($sql);
2568  ***      0                                  0      eval {
2569  ***      0                                  0         $dbh->do($sql);
2570                                                     };
2571  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
2572                                                  
2573  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
2574                                                        ($can_delete ? 'delete' : ''));
2575                                                  
2576  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
2577                                                            && $can_delete) ) {
2578  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
2579  ***      0                                  0         return 0;
2580                                                     }
2581                                                  
2582  ***      0                                  0      MKDEBUG && _d('User has all privs');
2583  ***      0                                  0      return 1;
2584                                                  }
2585                                                  
2586                                                  sub get_engine {
2587         234                  234          1099      my ( $self, $ddl, $opts ) = @_;
2588         234                               7503      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
2589         234                                737      MKDEBUG && _d('Storage engine:', $engine);
2590  ***    234            50                 1417      return $engine || undef;
2591                                                  }
2592                                                  
2593                                                  sub get_keys {
2594         234                  234          1346      my ( $self, $ddl, $opts, $is_nullable ) = @_;
2595         234                               1073      my $engine        = $self->get_engine($ddl);
2596         234                                780      my $keys          = {};
2597         234                                681      my $clustered_key = undef;
2598                                                  
2599                                                     KEY:
2600         234                               6808      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
2601                                                  
2602  ***    408     50                        1920         next KEY if $key =~ m/FOREIGN/;
2603                                                  
2604         408                               1235         my $key_ddl = $key;
2605         408                                963         MKDEBUG && _d('Parsed key:', $key_ddl);
2606                                                  
2607  ***    408     50                        2423         if ( $engine !~ m/MEMORY|HEAP/ ) {
2608         408                               1420            $key =~ s/USING HASH/USING BTREE/;
2609                                                        }
2610                                                  
2611         408                               3455         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
2612         408                               2037         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
2613  ***    408            66                 5329         $type = $type || $special || 'BTREE';
                           100                        
2614  ***    408     50     33                 3132         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
2615                                                           && $engine =~ m/HEAP|MEMORY/i )
2616                                                        {
2617  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
2618                                                        }
2619                                                  
2620         408                               3240         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
2621         408    100                        2517         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
2622         408                               1076         my @cols;
2623         408                               1005         my @col_prefixes;
2624         408                               3119         foreach my $col_def ( $cols =~ m/`[^`]+`(?:\(\d+\))?/g ) {
2625         570                               3884            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
2626         570                               2343            push @cols, $name;
2627         570                               2510            push @col_prefixes, $prefix;
2628                                                        }
2629         408                               1999         $name =~ s/`//g;
2630                                                  
2631         408                               1022         MKDEBUG && _d( $name, 'key cols:', join(', ', map { "`$_`" } @cols));
2632                                                  
2633         570                               2689         $keys->{$name} = {
2634                                                           name         => $name,
2635                                                           type         => $type,
2636                                                           colnames     => $cols,
2637                                                           cols         => \@cols,
2638                                                           col_prefixes => \@col_prefixes,
2639                                                           is_unique    => $unique,
2640         570                               5596            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
2641         408                               2593            is_col       => { map { $_ => 1 } @cols },
2642                                                           ddl          => $key_ddl,
2643                                                        };
2644                                                  
2645         408    100    100                 4450         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
2646          90                                365            my $this_key = $keys->{$name};
2647  ***     90     50      0                  460            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
2648          90                                313               $clustered_key = 'PRIMARY';
2649                                                           }
2650                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
2651  ***      0                                  0               $clustered_key = $this_key->{name};
2652                                                           }
2653          90                                370            MKDEBUG && $clustered_key && _d('This key is the clustered key');
2654                                                        }
2655                                                     }
2656                                                  
2657         234                               1429      return $keys, $clustered_key;
2658                                                  }
2659                                                  
2660                                                  sub get_fks {
2661  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
2662  ***      0                                  0      my $fks = {};
2663                                                  
2664  ***      0                                  0      foreach my $fk (
2665                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
2666                                                     {
2667  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
2668  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
2669  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
2670                                                  
2671  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
2672  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
2673                                                        }
2674                                                  
2675  ***      0                                  0         $fks->{$name} = {
2676                                                           name           => $name,
2677                                                           colnames       => $cols,
2678  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
2679                                                           parent_tbl     => $parent,
2680                                                           parent_colnames=> $parent_cols,
2681  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
2682                                                           ddl            => $fk,
2683                                                        };
2684                                                     }
2685                                                  
2686  ***      0                                  0      return $fks;
2687                                                  }
2688                                                  
2689                                                  sub remove_auto_increment {
2690  ***      0                    0             0      my ( $self, $ddl ) = @_;
2691  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
2692  ***      0                                  0      return $ddl;
2693                                                  }
2694                                                  
2695                                                  sub remove_secondary_indexes {
2696  ***      0                    0             0      my ( $self, $ddl ) = @_;
2697  ***      0                                  0      my $sec_indexes_ddl;
2698  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
2699                                                  
2700  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
2701  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
2702  ***      0             0                    0         $clustered_key  ||= '';
2703                                                  
2704  ***      0                                  0         my @sec_indexes   = map {
2705  ***      0                                  0            my $key_def = $_->{ddl};
2706  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
2707  ***      0                                  0            $ddl =~ s/\s+$key_def//i;
2708                                                  
2709  ***      0                                  0            my $key_ddl = "ADD $_->{ddl}";
2710  ***      0      0                           0            $key_ddl   .= ',' unless $key_ddl =~ m/,$/;
2711  ***      0                                  0            $key_ddl;
2712                                                        }
2713  ***      0                                  0         grep { $_->{name} ne $clustered_key }
2714  ***      0                                  0         values %{$tbl_struct->{keys}};
2715  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
2716                                                  
2717  ***      0      0                           0         if ( @sec_indexes ) {
2718  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
2719  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
2720                                                        }
2721                                                  
2722  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
2723                                                     }
2724                                                     else {
2725  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
2726                                                           $tbl_struct->{engine}, 'table');
2727                                                     }
2728                                                  
2729  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
2730                                                  }
2731                                                  
2732                                                  sub _d {
2733  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2734  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2735  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2736                                                          @_;
2737  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2738                                                  }
2739                                                  
2740                                                  1;
2741                                                  
2742                                                  # ###########################################################################
2743                                                  # End TableParser package
2744                                                  # ###########################################################################
2745                                                  
2746                                                  # ###########################################################################
2747                                                  # Transformers package 6387
2748                                                  # This package is a copy without comments from the original.  The original
2749                                                  # with comments and its test file can be found in the SVN repository at,
2750                                                  #   trunk/common/Transformers.pm
2751                                                  #   trunk/common/t/Transformers.t
2752                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2753                                                  # ###########################################################################
2754                                                  
2755                                                  package Transformers;
2756                                                  
2757           1                    1             9   use strict;
               1                                  2   
               1                                  6   
2758           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
2759           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  9   
2760           1                    1            13   use Time::Local qw(timegm timelocal);
               1                                  3   
               1                                 10   
2761           1                    1             7   use Digest::MD5 qw(md5_hex);
               1                                  2   
               1                                  7   
2762                                                  
2763  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 13   
2764                                                  
2765                                                  require Exporter;
2766                                                  our @ISA         = qw(Exporter);
2767                                                  our %EXPORT_TAGS = ();
2768                                                  our @EXPORT      = ();
2769                                                  our @EXPORT_OK   = qw(
2770                                                     micro_t
2771                                                     percentage_of
2772                                                     secs_to_time
2773                                                     time_to_secs
2774                                                     shorten
2775                                                     ts
2776                                                     parse_timestamp
2777                                                     unix_timestamp
2778                                                     any_unix_timestamp
2779                                                     make_checksum
2780                                                  );
2781                                                  
2782                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
2783                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
2784                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
2785                                                  
2786                                                  sub micro_t {
2787  ***      0                    0             0      my ( $t, %args ) = @_;
2788  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
2789  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
2790  ***      0                                  0      my $f;
2791                                                  
2792  ***      0      0                           0      $t = 0 if $t < 0;
2793                                                  
2794  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
2795                                                  
2796  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
2797                                                  
2798  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
2799  ***      0                                  0         $f = ($t * 1000000) . 'us';
2800                                                     }
2801                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
2802  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
2803  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
2804                                                     }
2805                                                     elsif ($t >= 1) {
2806  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
2807  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
2808                                                     }
2809                                                     else {
2810  ***      0                                  0         $f = 0;  # $t should = 0 at this point
2811                                                     }
2812                                                  
2813  ***      0                                  0      return $f;
2814                                                  }
2815                                                  
2816                                                  sub percentage_of {
2817  ***      0                    0             0      my ( $is, $of, %args ) = @_;
2818  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
2819  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
2820  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
2821                                                  }
2822                                                  
2823                                                  sub secs_to_time {
2824  ***      0                    0             0      my ( $secs, $fmt ) = @_;
2825  ***      0             0                    0      $secs ||= 0;
2826  ***      0      0                           0      return '00:00' unless $secs;
2827                                                  
2828  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
2829                                                            : $secs >= 3_600  ? 'h'
2830                                                            :                   'm';
2831                                                  
2832                                                     return
2833  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
2834                                                           "%d+%02d:%02d:%02d",
2835                                                           int($secs / 86_400),
2836                                                           int(($secs % 86_400) / 3_600),
2837                                                           int(($secs % 3_600) / 60),
2838                                                           $secs % 60)
2839                                                        : $fmt eq 'h' ? sprintf(
2840                                                           "%02d:%02d:%02d",
2841                                                           int(($secs % 86_400) / 3_600),
2842                                                           int(($secs % 3_600) / 60),
2843                                                           $secs % 60)
2844                                                        : sprintf(
2845                                                           "%02d:%02d",
2846                                                           int(($secs % 3_600) / 60),
2847                                                           $secs % 60);
2848                                                  }
2849                                                  
2850                                                  sub time_to_secs {
2851  ***      0                    0             0      my ( $val, $default_suffix ) = @_;
2852  ***      0      0                           0      die "I need a val argument" unless defined $val;
2853  ***      0                                  0      my $t = 0;
2854  ***      0                                  0      my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
2855  ***      0             0                    0      $suffix = $suffix || $default_suffix || 's';
      ***                    0                        
2856  ***      0      0                           0      if ( $suffix =~ m/[smhd]/ ) {
2857  ***      0      0                           0         $t = $suffix eq 's' ? $num * 1        # Seconds
      ***             0                               
      ***             0                               
2858                                                           : $suffix eq 'm' ? $num * 60       # Minutes
2859                                                           : $suffix eq 'h' ? $num * 3600     # Hours
2860                                                           :                  $num * 86400;   # Days
2861                                                  
2862  ***      0      0      0                    0         $t *= -1 if $prefix && $prefix eq '-';
2863                                                     }
2864                                                     else {
2865  ***      0                                  0         die "Invalid suffix for $val: $suffix";
2866                                                     }
2867  ***      0                                  0      return $t;
2868                                                  }
2869                                                  
2870                                                  sub shorten {
2871  ***      0                    0             0      my ( $num, %args ) = @_;
2872  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
2873  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
2874  ***      0                                  0      my $n = 0;
2875  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
2876  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
2877  ***      0                                  0         $num /= $d;
2878  ***      0                                  0         ++$n;
2879                                                     }
2880  ***      0      0      0                    0      return sprintf(
2881                                                        $num =~ m/\./ || $n
2882                                                           ? "%.${p}f%s"
2883                                                           : '%d',
2884                                                        $num, $units[$n]);
2885                                                  }
2886                                                  
2887                                                  sub ts {
2888  ***      0                    0             0      my ( $time, $gmt ) = @_;
2889  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
2890                                                        = $gmt ? gmtime($time) : localtime($time);
2891  ***      0                                  0      $mon  += 1;
2892  ***      0                                  0      $year += 1900;
2893  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
2894                                                        $year, $mon, $mday, $hour, $min, $sec);
2895  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
2896  ***      0                                  0         $us = sprintf("%.6f", $us);
2897  ***      0                                  0         $us =~ s/^0\././;
2898  ***      0                                  0         $val .= $us;
2899                                                     }
2900  ***      0                                  0      return $val;
2901                                                  }
2902                                                  
2903                                                  sub parse_timestamp {
2904  ***      0                    0             0      my ( $val ) = @_;
2905  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
2906                                                           = $val =~ m/^$mysql_ts$/ )
2907                                                     {
2908  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
2909                                                                       . (defined $f ? '%09.6f' : '%02d'),
2910                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
2911                                                     }
2912  ***      0                                  0      return $val;
2913                                                  }
2914                                                  
2915                                                  sub unix_timestamp {
2916  ***      0                    0             0      my ( $val, $gmt ) = @_;
2917  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
2918  ***      0      0                           0         $val = $gmt
2919                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
2920                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
2921  ***      0      0                           0         if ( defined $us ) {
2922  ***      0                                  0            $us = sprintf('%.6f', $us);
2923  ***      0                                  0            $us =~ s/^0\././;
2924  ***      0                                  0            $val .= $us;
2925                                                        }
2926                                                     }
2927  ***      0                                  0      return $val;
2928                                                  }
2929                                                  
2930                                                  sub any_unix_timestamp {
2931  ***      0                    0             0      my ( $val, $callback ) = @_;
2932                                                  
2933  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
2934  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
2935                                                           : $suffix eq 'm' ? $n * 60       # Minutes
2936                                                           : $suffix eq 'h' ? $n * 3600     # Hours
2937                                                           : $suffix eq 'd' ? $n * 86400    # Days
2938                                                           :                  $n;           # default: Seconds
2939  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
2940  ***      0                                  0         return time - $n;
2941                                                     }
2942                                                     elsif ( $val =~ m/^\d{9,}/ ) {
2943  ***      0                                  0         MKDEBUG && _d('ts is already a unix timestamp');
2944  ***      0                                  0         return $val;
2945                                                     }
2946                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
2947  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
2948  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2949  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
2950                                                     }
2951                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
2952  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
2953  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2954  ***      0                                  0         return unix_timestamp($val);
2955                                                     }
2956                                                     else {
2957  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
2958  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
2959                                                     }
2960                                                  
2961  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
2962  ***      0                                  0      return;
2963                                                  }
2964                                                  
2965                                                  sub make_checksum {
2966          12                   12            50      my ( $val ) = @_;
2967          12                                102      my $checksum = uc substr(md5_hex($val), -16);
2968          12                                 31      MKDEBUG && _d($checksum, 'checksum for', $val);
2969          12                                 46      return $checksum;
2970                                                  }
2971                                                  
2972                                                  sub _d {
2973  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2974  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2975  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2976                                                          @_;
2977  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2978                                                  }
2979                                                  
2980                                                  1;
2981                                                  
2982                                                  # ###########################################################################
2983                                                  # End Transformers package
2984                                                  # ###########################################################################
2985                                                  
2986                                                  # ###########################################################################
2987                                                  # VersionParser package 5266
2988                                                  # ###########################################################################
2989                                                  package VersionParser;
2990                                                  
2991           1                    1             7   use strict;
               1                                  3   
               1                                  5   
2992           1                    1             6   use warnings FATAL => 'all';
               1                                  6   
               1                                  6   
2993                                                  
2994           1                    1             5   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
2995                                                  
2996  ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 13   
2997                                                  
2998                                                  sub new {
2999           6                    6            32      my ( $class ) = @_;
3000           6                                 46      bless {}, $class;
3001                                                  }
3002                                                  
3003                                                  sub parse {
3004           6                    6           645      my ( $self, $str ) = @_;
3005           6                                107      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
3006           6                                 20      MKDEBUG && _d($str, 'parses to', $result);
3007           6                                 32      return $result;
3008                                                  }
3009                                                  
3010                                                  sub version_ge {
3011  ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
3012  ***      0      0                           0      if ( !$self->{$dbh} ) {
3013  ***      0                                  0         $self->{$dbh} = $self->parse(
3014                                                           $dbh->selectrow_array('SELECT VERSION()'));
3015                                                     }
3016  ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
3017  ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
3018  ***      0                                  0      return $result;
3019                                                  }
3020                                                  
3021                                                  sub _d {
3022  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3023  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3024  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3025                                                          @_;
3026  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3027                                                  }
3028                                                  
3029                                                  1;
3030                                                  
3031                                                  # ###########################################################################
3032                                                  # End VersionParser package
3033                                                  # ###########################################################################
3034                                                  
3035                                                  # ###########################################################################
3036                                                  # MySQLDump package 6345
3037                                                  # This package is a copy without comments from the original.  The original
3038                                                  # with comments and its test file can be found in the SVN repository at,
3039                                                  #   trunk/common/MySQLDump.pm
3040                                                  #   trunk/common/t/MySQLDump.t
3041                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3042                                                  # ###########################################################################
3043                                                  package MySQLDump;
3044                                                  
3045           1                    1             7   use strict;
               1                                  2   
               1                                 13   
3046           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
3047                                                  
3048           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
3049                                                  
3050  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 16   
3051                                                  
3052                                                  ( our $before = <<'EOF') =~ s/^   //gm;
3053                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
3054                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
3055                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
3056                                                     /*!40101 SET NAMES utf8 */;
3057                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
3058                                                     /*!40103 SET TIME_ZONE='+00:00' */;
3059                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
3060                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
3061                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
3062                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
3063                                                  EOF
3064                                                  
3065                                                  ( our $after = <<'EOF') =~ s/^   //gm;
3066                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
3067                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
3068                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
3069                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
3070                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
3071                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
3072                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
3073                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
3074                                                  EOF
3075                                                  
3076                                                  sub new {
3077           6                    6            34      my ( $class, %args ) = @_;
3078           6                                 30      my $self = {
3079                                                        cache => 0,  # Afaik no script uses this cache any longer because
3080                                                     };
3081           6                                 35      return bless $self, $class;
3082                                                  }
3083                                                  
3084                                                  sub dump {
3085  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
3086                                                  
3087  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
3088  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
3089  ***      0      0                           0         return unless $ddl;
3090  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
3091  ***      0                                  0            return $before
3092                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
3093                                                              . $ddl->[1] . ";\n";
3094                                                        }
3095                                                        else {
3096  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
3097                                                              . '/*!50001 DROP VIEW IF EXISTS '
3098                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
3099                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
3100                                                        }
3101                                                     }
3102                                                     elsif ( $what eq 'triggers' ) {
3103  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
3104  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
3105  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
3106  ***      0                                  0            foreach my $trg ( @$trgs ) {
3107  ***      0      0                           0               if ( $trg->{sql_mode} ) {
3108  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
3109                                                              }
3110  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
3111  ***      0      0                           0               if ( $trg->{definer} ) {
3112  ***      0                                  0                  my ( $user, $host )
3113  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
3114                                                                      split('@', $trg->{definer}, 2);
3115  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
3116                                                              }
3117  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
3118                                                                 $quoter->quote($trg->{trigger}),
3119  ***      0                                  0                  @{$trg}{qw(timing event)},
3120                                                                 $quoter->quote($trg->{table}),
3121                                                                 $trg->{statement});
3122                                                           }
3123  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
3124  ***      0                                  0            return $result;
3125                                                        }
3126                                                        else {
3127  ***      0                                  0            return undef;
3128                                                        }
3129                                                     }
3130                                                     elsif ( $what eq 'view' ) {
3131  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
3132  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
3133                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
3134                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
3135                                                     }
3136                                                     else {
3137  ***      0                                  0         die "You didn't say what to dump.";
3138                                                     }
3139                                                  }
3140                                                  
3141                                                  sub _use_db {
3142         234                  234          1355      my ( $self, $dbh, $quoter, $new ) = @_;
3143  ***    234     50                        1147      if ( !$new ) {
3144  ***      0                                  0         MKDEBUG && _d('No new DB to use');
3145  ***      0                                  0         return;
3146                                                     }
3147         234                               1086      my $sql = 'USE ' . $quoter->quote($new);
3148         234                                603      MKDEBUG && _d($dbh, $sql);
3149         234                              15629      $dbh->do($sql);
3150         234                               1078      return;
3151                                                  }
3152                                                  
3153                                                  sub get_create_table {
3154         234                  234          1266      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
3155  ***    234     50     33                 1641      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
3156         234                                796         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
3157                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
3158                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
3159                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
3160         234                                541         MKDEBUG && _d($sql);
3161         234                                618         eval { $dbh->do($sql); };
             234                              23809   
3162         234                                790         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3163         234                               1300         $self->_use_db($dbh, $quoter, $db);
3164         234                               1194         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
3165         234                               2533         MKDEBUG && _d($sql);
3166         234                                644         my $href;
3167         234                                665         eval { $href = $dbh->selectrow_hashref($sql); };
             234                                629   
3168  ***    234     50                        1649         if ( $EVAL_ERROR ) {
3169  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
3170  ***      0                                  0            return;
3171                                                        }
3172                                                  
3173         234                                771         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
3174                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
3175         234                                553         MKDEBUG && _d($sql);
3176         234                              16592         $dbh->do($sql);
3177         234                               1672         my ($key) = grep { m/create table/i } keys %$href;
             468                               2724   
3178  ***    234     50                        1063         if ( $key ) {
3179         234                                546            MKDEBUG && _d('This table is a base table');
3180         234                               2842            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
3181                                                        }
3182                                                        else {
3183  ***      0                                  0            MKDEBUG && _d('This table is a view');
3184  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
3185  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
3186                                                        }
3187                                                     }
3188         234                               1838      return $self->{tables}->{$db}->{$tbl};
3189                                                  }
3190                                                  
3191                                                  sub get_columns {
3192  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
3193  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
3194  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
3195  ***      0                                  0         $self->_use_db($dbh, $quoter, $db);
3196  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
3197  ***      0                                  0         MKDEBUG && _d($sql);
3198  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
3199                                                  
3200  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
3201                                                           map {
3202  ***      0                                  0               my %row;
3203  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
3204  ***      0                                  0               \%row;
3205                                                           } @$cols
3206                                                        ];
3207                                                     }
3208  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
3209                                                  }
3210                                                  
3211                                                  sub get_tmp_table {
3212  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
3213  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
3214  ***      0                                  0      $result .= join(",\n",
3215  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
3216  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
3217  ***      0                                  0      $result .= "\n)";
3218  ***      0                                  0      MKDEBUG && _d($result);
3219  ***      0                                  0      return $result;
3220                                                  }
3221                                                  
3222                                                  sub get_triggers {
3223  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
3224  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
3225  ***      0                                  0         $self->{triggers}->{$db} = {};
3226  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
3227                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
3228                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
3229                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
3230  ***      0                                  0         MKDEBUG && _d($sql);
3231  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
3232  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3233  ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
3234  ***      0                                  0         MKDEBUG && _d($sql);
3235  ***      0                                  0         my $sth = $dbh->prepare($sql);
3236  ***      0                                  0         $sth->execute();
3237  ***      0      0                           0         if ( $sth->rows ) {
3238  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
3239  ***      0                                  0            foreach my $trg (@$trgs) {
3240  ***      0                                  0               my %trg;
3241  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
3242  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
3243                                                           }
3244                                                        }
3245  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
3246                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
3247  ***      0                                  0         MKDEBUG && _d($sql);
3248  ***      0                                  0         $dbh->do($sql);
3249                                                     }
3250  ***      0      0                           0      if ( $tbl ) {
3251  ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
3252                                                     }
3253  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
3254                                                  }
3255                                                  
3256                                                  sub get_databases {
3257  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
3258  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
3259  ***      0                                  0         my $sql = 'SHOW DATABASES';
3260  ***      0                                  0         my @params;
3261  ***      0      0                           0         if ( $like ) {
3262  ***      0                                  0            $sql .= ' LIKE ?';
3263  ***      0                                  0            push @params, $like;
3264                                                        }
3265  ***      0                                  0         my $sth = $dbh->prepare($sql);
3266  ***      0                                  0         MKDEBUG && _d($sql, @params);
3267  ***      0                                  0         $sth->execute( @params );
3268  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
3269  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
3270  ***      0                                  0         return @dbs;
3271                                                     }
3272  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
3273                                                  }
3274                                                  
3275                                                  sub get_table_status {
3276  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
3277  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
3278  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
3279  ***      0                                  0         my @params;
3280  ***      0      0                           0         if ( $like ) {
3281  ***      0                                  0            $sql .= ' LIKE ?';
3282  ***      0                                  0            push @params, $like;
3283                                                        }
3284  ***      0                                  0         MKDEBUG && _d($sql, @params);
3285  ***      0                                  0         my $sth = $dbh->prepare($sql);
3286  ***      0                                  0         $sth->execute(@params);
3287  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
3288  ***      0                                  0         @tables = map {
3289  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
3290  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
3291  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
3292  ***      0                                  0            delete $tbl{type};
3293  ***      0                                  0            \%tbl;
3294                                                        } @tables;
3295  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
3296  ***      0                                  0         return @tables;
3297                                                     }
3298  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
3299                                                  }
3300                                                  
3301                                                  sub get_table_list {
3302  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
3303  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
3304  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
3305  ***      0                                  0         my @params;
3306  ***      0      0                           0         if ( $like ) {
3307  ***      0                                  0            $sql .= ' LIKE ?';
3308  ***      0                                  0            push @params, $like;
3309                                                        }
3310  ***      0                                  0         MKDEBUG && _d($sql, @params);
3311  ***      0                                  0         my $sth = $dbh->prepare($sql);
3312  ***      0                                  0         $sth->execute(@params);
3313  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
3314  ***      0      0      0                    0         @tables = map {
3315  ***      0                                  0            my %tbl = (
3316                                                              name   => $_->[0],
3317                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
3318                                                           );
3319  ***      0                                  0            \%tbl;
3320                                                        } @tables;
3321  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
3322  ***      0                                  0         return @tables;
3323                                                     }
3324  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
3325                                                  }
3326                                                  
3327                                                  sub _d {
3328  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3329  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3330  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3331                                                          @_;
3332  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3333                                                  }
3334                                                  
3335                                                  1;
3336                                                  
3337                                                  # ###########################################################################
3338                                                  # End MySQLDump package
3339                                                  # ###########################################################################
3340                                                  
3341                                                  # ###########################################################################
3342                                                  # SchemaIterator package 5473
3343                                                  # This package is a copy without comments from the original.  The original
3344                                                  # with comments and its test file can be found in the SVN repository at,
3345                                                  #   trunk/common/SchemaIterator.pm
3346                                                  #   trunk/common/t/SchemaIterator.t
3347                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3348                                                  # ###########################################################################
3349                                                  package SchemaIterator;
3350                                                  
3351           1                    1             7   use strict;
               1                                  3   
               1                                  5   
3352           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
3353                                                  
3354           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
3355           1                    1             7   use Data::Dumper;
               1                                  2   
               1                                  5   
3356                                                  $Data::Dumper::Indent    = 1;
3357                                                  $Data::Dumper::Sortkeys  = 1;
3358                                                  $Data::Dumper::Quotekeys = 0;
3359                                                  
3360  ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 19   
3361                                                  
3362                                                  sub new {
3363           6                    6            38      my ( $class, %args ) = @_;
3364           6                                 29      foreach my $arg ( qw(Quoter) ) {
3365  ***      6     50                          40         die "I need a $arg argument" unless $args{$arg};
3366                                                     }
3367           6                                 48      my $self = {
3368                                                        %args,
3369                                                        filter => undef,
3370                                                        dbs    => [],
3371                                                     };
3372           6                                 39      return bless $self, $class;
3373                                                  }
3374                                                  
3375                                                  sub make_filter {
3376           6                    6            30      my ( $self, $o ) = @_;
3377           6                                 44      my @lines = (
3378                                                        'sub {',
3379                                                        '   my ( $dbh, $db, $tbl ) = @_;',
3380                                                        '   my $engine = undef;',
3381                                                     );
3382                                                  
3383                                                  
3384  ***      6     50                          31      my @permit_dbs = _make_filter('unless', '$db', $o->get('databases'))
3385                                                        if $o->has('databases');
3386  ***      6     50                          32      my @reject_dbs = _make_filter('if', '$db', $o->get('ignore-databases'))
3387                                                        if $o->has('ignore-databases');
3388           6                                 21      my @dbs_regex;
3389  ***      6     50     33                   27      if ( $o->has('databases-regex') && (my $p = $o->get('databases-regex')) ) {
3390  ***      0                                  0         push @dbs_regex, "      return 0 unless \$db && (\$db =~ m/$p/o);";
3391                                                     }
3392           6                                 20      my @reject_dbs_regex;
3393  ***      6     50     33                   37      if ( $o->has('ignore-databases-regex')
3394                                                          && (my $p = $o->get('ignore-databases-regex')) ) {
3395  ***      0                                  0         push @reject_dbs_regex, "      return 0 if \$db && (\$db =~ m/$p/o);";
3396                                                     }
3397  ***      6     50     33                  133      if ( @permit_dbs || @reject_dbs || @dbs_regex || @reject_dbs_regex ) {
      ***                   33                        
      ***                   33                        
3398  ***      0      0                           0         push @lines,
      ***             0                               
      ***             0                               
      ***             0                               
3399                                                           '   if ( $db ) {',
3400                                                              (@permit_dbs        ? @permit_dbs       : ()),
3401                                                              (@reject_dbs        ? @reject_dbs       : ()),
3402                                                              (@dbs_regex         ? @dbs_regex        : ()),
3403                                                              (@reject_dbs_regex  ? @reject_dbs_regex : ()),
3404                                                           '   }';
3405                                                     }
3406                                                  
3407  ***      6     50     33                   28      if ( $o->has('tables') || $o->has('ignore-tables')
      ***                   33                        
3408                                                          || $o->has('ignore-tables-regex') ) {
3409                                                  
3410  ***      0                                  0         my $have_qtbl       = 0;
3411  ***      0                                  0         my $have_only_qtbls = 0;
3412  ***      0                                  0         my %qtbls;
3413                                                  
3414  ***      0                                  0         my @permit_tbls;
3415  ***      0                                  0         my @permit_qtbls;
3416  ***      0                                  0         my %permit_qtbls;
3417  ***      0      0                           0         if ( $o->get('tables') ) {
3418  ***      0                                  0            my %tbls;
3419                                                           map {
3420  ***      0      0                           0               if ( $_ =~ m/\./ ) {
      ***      0                                  0   
3421  ***      0                                  0                  $permit_qtbls{$_} = 1;
3422                                                              }
3423                                                              else {
3424  ***      0                                  0                  $tbls{$_} = 1;
3425                                                              }
3426  ***      0                                  0            } keys %{ $o->get('tables') };
3427  ***      0                                  0            @permit_tbls  = _make_filter('unless', '$tbl', \%tbls);
3428  ***      0                                  0            @permit_qtbls = _make_filter('unless', '$qtbl', \%permit_qtbls);
3429                                                  
3430  ***      0      0                           0            if ( @permit_qtbls ) {
3431  ***      0                                  0               push @lines,
3432                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
3433  ***      0                                  0               $have_qtbl = 1;
3434                                                           }
3435                                                        }
3436                                                  
3437  ***      0                                  0         my @reject_tbls;
3438  ***      0                                  0         my @reject_qtbls;
3439  ***      0                                  0         my %reject_qtbls;
3440  ***      0      0                           0         if ( $o->get('ignore-tables') ) {
3441  ***      0                                  0            my %tbls;
3442                                                           map {
3443  ***      0      0                           0               if ( $_ =~ m/\./ ) {
      ***      0                                  0   
3444  ***      0                                  0                  $reject_qtbls{$_} = 1;
3445                                                              }
3446                                                              else {
3447  ***      0                                  0                  $tbls{$_} = 1;
3448                                                              }
3449  ***      0                                  0            } keys %{ $o->get('ignore-tables') };
3450  ***      0                                  0            @reject_tbls= _make_filter('if', '$tbl', \%tbls);
3451  ***      0                                  0            @reject_qtbls = _make_filter('if', '$qtbl', \%reject_qtbls);
3452                                                  
3453  ***      0      0      0                    0            if ( @reject_qtbls && !$have_qtbl ) {
3454  ***      0                                  0               push @lines,
3455                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
3456                                                           }
3457                                                        }
3458                                                  
3459  ***      0      0      0                    0         if ( keys %permit_qtbls  && !@permit_dbs ) {
3460  ***      0                                  0            my $dbs = {};
3461  ***      0                                  0            map {
3462  ***      0                                  0               my ($db, undef) = split(/\./, $_);
3463  ***      0                                  0               $dbs->{$db} = 1;
3464                                                           } keys %permit_qtbls;
3465  ***      0                                  0            MKDEBUG && _d('Adding restriction "--databases',
3466                                                                 (join(',', keys %$dbs) . '"'));
3467  ***      0      0                           0            if ( keys %$dbs ) {
3468  ***      0                                  0               $o->set('databases', $dbs);
3469  ***      0                                  0               return $self->make_filter($o);
3470                                                           }
3471                                                        }
3472                                                  
3473  ***      0                                  0         my @tbls_regex;
3474  ***      0      0      0                    0         if ( $o->has('tables-regex') && (my $p = $o->get('tables-regex')) ) {
3475  ***      0                                  0            push @tbls_regex, "      return 0 unless \$tbl && (\$tbl =~ m/$p/o);";
3476                                                        }
3477  ***      0                                  0         my @reject_tbls_regex;
3478  ***      0      0      0                    0         if ( $o->has('ignore-tables-regex')
3479                                                             && (my $p = $o->get('ignore-tables-regex')) ) {
3480  ***      0                                  0            push @reject_tbls_regex,
3481                                                              "      return 0 if \$tbl && (\$tbl =~ m/$p/o);";
3482                                                        }
3483                                                  
3484  ***      0                                  0         my @get_eng;
3485  ***      0                                  0         my @permit_engs;
3486  ***      0                                  0         my @reject_engs;
3487  ***      0      0      0                    0         if ( ($o->has('engines') && $o->get('engines'))
      ***                    0                        
      ***                    0                        
3488                                                             || ($o->has('ignore-engines') && $o->get('ignore-engines')) ) {
3489  ***      0                                  0            push @get_eng,
3490                                                              '      my $sql = "SHOW TABLE STATUS "',
3491                                                              '              . ($db ? "FROM `$db`" : "")',
3492                                                              '              . " LIKE \'$tbl\'";',
3493                                                              '      MKDEBUG && _d($sql);',
3494                                                              '      eval {',
3495                                                              '         $engine = $dbh->selectrow_hashref($sql)->{engine};',
3496                                                              '      };',
3497                                                              '      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);',
3498                                                              '      MKDEBUG && _d($tbl, "uses engine", $engine);',
3499                                                              '      $engine = lc $engine if $engine;',
3500                                                           @permit_engs
3501                                                              = _make_filter('unless', '$engine', $o->get('engines'), 1);
3502                                                           @reject_engs
3503  ***      0                                  0               = _make_filter('if', '$engine', $o->get('ignore-engines'), 1)
3504                                                        }
3505                                                  
3506  ***      0      0      0                    0         if ( @permit_tbls || @reject_tbls || @tbls_regex || @reject_tbls_regex
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
3507                                                             || @permit_engs || @reject_engs ) {
3508  ***      0      0                           0            push @lines,
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
3509                                                              '   if ( $tbl ) {',
3510                                                                 (@permit_tbls       ? @permit_tbls        : ()),
3511                                                                 (@reject_tbls       ? @reject_tbls        : ()),
3512                                                                 (@tbls_regex        ? @tbls_regex         : ()),
3513                                                                 (@reject_tbls_regex ? @reject_tbls_regex  : ()),
3514                                                                 (@permit_qtbls      ? @permit_qtbls       : ()),
3515                                                                 (@reject_qtbls      ? @reject_qtbls       : ()),
3516                                                                 (@get_eng           ? @get_eng            : ()),
3517                                                                 (@permit_engs       ? @permit_engs        : ()),
3518                                                                 (@reject_engs       ? @reject_engs        : ()),
3519                                                              '   }';
3520                                                        }
3521                                                     }
3522                                                  
3523           6                                 32      push @lines,
3524                                                        '   MKDEBUG && _d(\'Passes filters:\', $db, $tbl, $engine, $dbh);',
3525                                                        '   return 1;',  '}';
3526                                                  
3527           6                                 37      my $code = join("\n", @lines);
3528           6                                 14      MKDEBUG && _d('filter sub:', $code);
3529  ***      6     50                         829      my $filter_sub= eval $code
3530                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
3531                                                  
3532           6                                 50      return $filter_sub;
3533                                                  }
3534                                                  
3535                                                  sub set_filter {
3536           6                    6            30      my ( $self, $filter_sub ) = @_;
3537           6                                 24      $self->{filter} = $filter_sub;
3538           6                                 17      MKDEBUG && _d('Set filter sub');
3539           6                                 17      return;
3540                                                  }
3541                                                  
3542                                                  sub get_db_itr {
3543           6                    6            43      my ( $self, %args ) = @_;
3544           6                                 28      my @required_args = qw(dbh);
3545           6                                 36      foreach my $arg ( @required_args ) {
3546  ***      6     50                          44         die "I need a $arg argument" unless $args{$arg};
3547                                                     }
3548           6                                 33      my ($dbh) = @args{@required_args};
3549                                                  
3550           6                                 48      my $filter = $self->{filter};
3551           6                                 18      my @dbs;
3552           6                                 20      eval {
3553           6                                 22         my $sql = 'SHOW DATABASES';
3554           6                                 14         MKDEBUG && _d($sql);
3555  ***     18     50                         138         @dbs =  grep {
3556           6                                 17            my $ok = $filter ? $filter->($dbh, $_, undef) : 1;
3557          18    100                         141            $ok = 0 if $_ =~ m/information_schema|lost\+found/;
3558          18                                 76            $ok;
3559           6                                 21         } @{ $dbh->selectcol_arrayref($sql) };
3560           6                                 24         MKDEBUG && _d('Found', scalar @dbs, 'databases');
3561                                                     };
3562           6                                 16      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3563                                                     return sub {
3564          18                   18           135         return shift @dbs;
3565           6                                 62      };
3566                                                  }
3567                                                  
3568                                                  sub get_tbl_itr {
3569          12                   12           174      my ( $self, %args ) = @_;
3570          12                                 67      my @required_args = qw(dbh db);
3571          12                                 63      foreach my $arg ( @required_args ) {
3572  ***     24     50                         136         die "I need a $arg argument" unless $args{$arg};
3573                                                     }
3574          12                                 76      my ($dbh, $db, $views) = @args{@required_args, 'views'};
3575                                                  
3576          12                                 49      my $filter = $self->{filter};
3577          12                                 35      my @tbls;
3578  ***     12     50                          51      if ( $db ) {
3579          12                                 36         eval {
3580          12                                 84            my $sql = 'SHOW /*!50002 FULL*/ TABLES FROM '
3581                                                                   . $self->{Quoter}->quote($db);
3582          12                                 37            MKDEBUG && _d($sql);
3583         234                               1045            @tbls = map {
3584         276                               8056               $_->[0]
3585                                                           }
3586                                                           grep {
3587          12                                 32               my ($tbl, $type) = @$_;
3588  ***    276     50                        1538               my $ok = $filter ? $filter->($dbh, $db, $tbl) : 1;
3589  ***    276     50                        1162               if ( !$views ) {
3590  ***    276    100     50                 1609                  $ok = 0 if ($type || '') eq 'VIEW';
3591                                                              }
3592         276                                873               $ok;
3593                                                           }
3594          12                                 43            @{ $dbh->selectall_arrayref($sql) };
3595          12                                366            MKDEBUG && _d('Found', scalar @tbls, 'tables in', $db);
3596                                                        };
3597          12                                 38         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3598                                                     }
3599                                                     else {
3600  ***      0                                  0         MKDEBUG && _d('No db given so no tables');
3601                                                     }
3602                                                     return sub {
3603         246                  246          1534         return shift @tbls;
3604          12                                148      };
3605                                                  }
3606                                                  
3607                                                  sub _make_filter {
3608  ***      0                    0             0      my ( $cond, $var_name, $objs, $lc ) = @_;
3609  ***      0                                  0      my @lines;
3610  ***      0      0                           0      if ( scalar keys %$objs ) {
3611  ***      0      0                           0         my $test = join(' || ',
3612  ***      0                                  0            map { "$var_name eq '" . ($lc ? lc $_ : $_) ."'" } keys %$objs);
3613  ***      0                                  0         push @lines, "      return 0 $cond $var_name && ($test);",
3614                                                     }
3615  ***      0                                  0      return @lines;
3616                                                  }
3617                                                  
3618                                                  sub _d {
3619  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3620  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3621  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3622                                                          @_;
3623  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3624                                                  }
3625                                                  
3626                                                  1;
3627                                                  
3628                                                  # ###########################################################################
3629                                                  # End SchemaIterator package
3630                                                  # ###########################################################################
3631                                                  
3632                                                  # ###########################################################################
3633                                                  # FileIterator package 6326
3634                                                  # This package is a copy without comments from the original.  The original
3635                                                  # with comments and its test file can be found in the SVN repository at,
3636                                                  #   trunk/common/FileIterator.pm
3637                                                  #   trunk/common/t/FileIterator.t
3638                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3639                                                  # ###########################################################################
3640                                                  package FileIterator;
3641                                                  
3642           1                    1             7   use strict;
               1                                  3   
               1                                  5   
3643           1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
3644                                                  
3645           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
3646           1                    1             7   use Data::Dumper;
               1                                  2   
               1                                  5   
3647                                                  $Data::Dumper::Indent    = 1;
3648                                                  $Data::Dumper::Sortkeys  = 1;
3649                                                  $Data::Dumper::Quotekeys = 0;
3650                                                  
3651  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 13   
3652                                                  
3653                                                  sub new {
3654           6                    6            33      my ( $class, %args ) = @_;
3655           6                                 29      my $self = {
3656                                                        %args,
3657                                                     };
3658           6                                 38      return bless $self, $class;
3659                                                  }
3660                                                  
3661                                                  sub get_file_itr {
3662           6                    6            42      my ( $self, @filenames ) = @_;
3663                                                  
3664           6                                 19      my @final_filenames;
3665                                                     FILENAME:
3666           6                                 32      foreach my $fn ( @filenames ) {
3667  ***      6     50                          30         if ( !defined $fn ) {
3668  ***      0                                  0            warn "Skipping undefined filename";
3669  ***      0                                  0            next FILENAME;
3670                                                        }
3671  ***      6     50                          30         if ( $fn ne '-' ) {
3672  ***      6     50     33                  184            if ( !-e $fn || !-r $fn ) {
3673  ***      0                                  0               warn "$fn does not exist or is not readable";
3674  ***      0                                  0               next FILENAME;
3675                                                           }
3676                                                        }
3677           6                                 33         push @final_filenames, $fn;
3678                                                     }
3679                                                  
3680  ***      6     50                          30      if ( !@filenames ) {
3681  ***      0                                  0         push @final_filenames, '-';
3682  ***      0                                  0         MKDEBUG && _d('Auto-adding "-" to the list of filenames');
3683                                                     }
3684                                                  
3685           6                                 17      MKDEBUG && _d('Final filenames:', @final_filenames);
3686                                                     return sub {
3687          12                   12            59         while ( @final_filenames ) {
3688           6                                 24            my $fn = shift @final_filenames;
3689           6                                 17            MKDEBUG && _d('Filename:', $fn);
3690  ***      6     50                          30            if ( $fn eq '-' ) { # Magical STDIN filename.
3691  ***      0                                  0               return (*STDIN, undef, undef);
3692                                                           }
3693  ***      6     50                         272            open my $fh, '<', $fn or warn "Cannot open $fn: $OS_ERROR";
3694  ***      6     50                          33            if ( $fh ) {
3695           6                                 87               return ( $fh, $fn, -s $fn );
3696                                                           }
3697                                                        }
3698           6                                 20         return (); # Avoids $f being set to 0 in list context.
3699           6                                 84      };
3700                                                  }
3701                                                  
3702                                                  sub _d {
3703  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3704  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3705  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3706                                                          @_;
3707  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3708                                                  }
3709                                                  
3710                                                  1;
3711                                                  
3712                                                  # ###########################################################################
3713                                                  # End FileIterator package
3714                                                  # ###########################################################################
3715                                                  
3716                                                  # ###########################################################################
3717                                                  # ExplainAnalyzer package 6326
3718                                                  # This package is a copy without comments from the original.  The original
3719                                                  # with comments and its test file can be found in the SVN repository at,
3720                                                  #   trunk/common/ExplainAnalyzer.pm
3721                                                  #   trunk/common/t/ExplainAnalyzer.t
3722                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3723                                                  # ###########################################################################
3724                                                  package ExplainAnalyzer;
3725                                                  
3726  ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 16   
3727           1                    1             7   use strict;
               1                                  3   
               1                                 23   
3728           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
3729                                                  
3730           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
3731           1                    1             6   use Data::Dumper;
               1                                  3   
               1                                  5   
3732                                                  $Data::Dumper::Indent    = 1;
3733                                                  $Data::Dumper::Sortkeys  = 1;
3734                                                  $Data::Dumper::Quotekeys = 0;
3735                                                  
3736                                                  
3737                                                  sub new {
3738           6                    6            46      my ( $class, %args ) = @_;
3739           6                                 29      foreach my $arg ( qw(QueryRewriter QueryParser) ) {
3740  ***     12     50                          72         die "I need a $arg argument" unless defined $args{$arg};
3741                                                     }
3742           6                                 34      my $self = {
3743                                                        %args,
3744                                                     };
3745           6                                 49      return bless $self, $class;
3746                                                  }
3747                                                  
3748                                                  sub explain_query {
3749           6                    6           154      my ( $self, %args ) = @_;
3750           6                                 29      foreach my $arg ( qw(dbh sql) ) {
3751  ***     12     50                          68         die "I need a $arg argument" unless defined $args{$arg};
3752                                                     }
3753           6                                 34      my ($sql, $dbh) = @args{qw(sql dbh)};
3754           6    100                          43      if ( $sql !~ m/^\s*select/i ) {
3755           1                                 11         $sql = $self->{QueryRewriter}->convert_to_select($sql);
3756                                                     }
3757           6                                 85      return $dbh->selectall_arrayref("EXPLAIN $sql", { Slice => {} });
3758                                                  }
3759                                                  
3760                                                  sub normalize {
3761           5                    5            23      my ( $self, $explain ) = @_;
3762           5                                 17      my @result; # Don't modify the input.
3763                                                  
3764           5                                 30      foreach my $row ( @$explain ) {
3765           5                                 58         $row = { %$row }; # Make a copy -- don't modify the input.
3766                                                  
3767           5                                 36         foreach my $col ( qw(key possible_keys key_len ref) ) {
3768          20           100                  190            $row->{$col} = [ split(/,/, $row->{$col} || '') ];
3769                                                        }
3770                                                  
3771           1                                  4         $row->{Extra} = {
3772                                                           map {
3773           5                                 39               my $var = $_;
3774                                                  
3775  ***      1     50                           8               if ( my($key, $vals) = $var =~ m/(Using union)\(([^)]+)\)/ ) {
3776  ***      0                                  0                  $key => [ split(/,/, $vals) ];
3777                                                              }
3778                                                  
3779                                                              else {
3780           1                                  7                  $var => 1;
3781                                                              }
3782                                                           }
3783                                                           split(/; /, $row->{Extra}) # Split on semicolons.
3784                                                        };
3785                                                  
3786           5                                 25         push @result, $row;
3787                                                     }
3788                                                  
3789           5                                 38      return \@result;
3790                                                  }
3791                                                  
3792                                                  sub get_alternate_indexes {
3793           5                    5            31      my ( $self, $keys, $possible_keys ) = @_;
3794           5                                 23      my %used = map { $_ => 1 } @$keys;
               3                                 29   
3795           5                                 32      return [ grep { !$used{$_} } @$possible_keys ];
               3                                 36   
3796                                                  }
3797                                                  
3798                                                  sub get_index_usage {
3799           5                    5            46      my ( $self, %args ) = @_;
3800           5                                 29      foreach my $arg ( qw(sql explain) ) {
3801  ***     10     50                          61         die "I need a $arg argument" unless defined $args{$arg};
3802                                                     }
3803           5                                 34      my ($sql, $explain) = @args{qw(sql explain)};
3804           5                                 11      my @result;
3805                                                  
3806           5                                 61      my $lookup = $self->{QueryParser}->get_aliases($sql);
3807                                                  
3808           5                                 23      foreach my $row ( @$explain ) {
3809                                                  
3810  ***      5     50     33                   78         next if !defined $row->{table}
3811                                                           || $row->{table} =~ m/^<(derived|union)\d/;
3812                                                  
3813  ***      5            33                   34         my $table = $lookup->{TABLE}->{$row->{table}} || $row->{table};
3814  ***      5            66                   46         my $db    = $lookup->{DATABASE}->{$table}     || $args{db};
3815           5                                 47         push @result, {
3816                                                           db  => $db,
3817                                                           tbl => $table,
3818                                                           idx => $row->{key},
3819                                                           alt => $self->get_alternate_indexes(
3820                                                                    $row->{key}, $row->{possible_keys}),
3821                                                        };
3822                                                     }
3823                                                  
3824           5                                 36      return \@result;
3825                                                  }
3826                                                  
3827                                                  sub get_usage_for {
3828           6                    6            35      my ( $self, $checksum, $db ) = @_;
3829  ***      6     50     33                   74      die "I need a checksum and db" unless defined $checksum && defined $db;
3830  ***      6     50     33                   60      if ( exists $self->{usage}->{$db} # Don't auto-vivify
3831                                                       && exists $self->{usage}->{$db}->{$checksum} )
3832                                                     {
3833  ***      0                                  0         return $self->{usage}->{$db}->{$checksum};
3834                                                     }
3835                                                     else {
3836           6                                 29         return undef;
3837                                                     }
3838                                                  }
3839                                                  
3840                                                  sub save_usage_for {
3841           5                    5            30      my ( $self, $checksum, $db, $usage ) = @_;
3842  ***      5     50     33                   60      die "I need a checksum and db" unless defined $checksum && defined $db;
3843           5                                 55      $self->{usage}->{$db}->{$checksum} = $usage;
3844                                                  }
3845                                                  
3846                                                  sub _d {
3847  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3848  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3849  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3850                                                          @_;
3851  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3852                                                  }
3853                                                  
3854                                                  1;
3855                                                  
3856                                                  # ###########################################################################
3857                                                  # End ExplainAnalyzer package
3858                                                  # ###########################################################################
3859                                                  
3860                                                  # ###########################################################################
3861                                                  # IndexUsage package 6331
3862                                                  # This package is a copy without comments from the original.  The original
3863                                                  # with comments and its test file can be found in the SVN repository at,
3864                                                  #   trunk/common/IndexUsage.pm
3865                                                  #   trunk/common/t/IndexUsage.t
3866                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3867                                                  # ###########################################################################
3868                                                  package IndexUsage;
3869                                                  
3870           1                    1             6   use strict;
               1                                  3   
               1                                  4   
3871           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  4   
3872           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
3873  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 13   
3874                                                  
3875                                                  sub new {
3876           6                    6            35      my ( $class, %args ) = @_;
3877           6                                 47      my $self = {
3878                                                        %args,
3879                                                        tables_for  => {}, # Keyed off db
3880                                                        indexes_for => {}, # Keyed off db->tbl
3881                                                     };
3882           6                                 42      return bless $self, $class;
3883                                                  }
3884                                                  
3885                                                  sub add_indexes {
3886         234                  234          2462      my ( $self, %args ) = @_;
3887         234                               1231      my @required_args = qw(db tbl indexes);
3888         234                                889      foreach my $arg ( @required_args ) {
3889  ***    702     50                        3735         die "I need a $arg argument" unless $args{$arg};
3890                                                     }
3891         234                               1220      my ($db, $tbl, $indexes) = @args{@required_args};
3892                                                  
3893         234                               1323      $self->{tables_for}->{$db}->{$tbl}  = 0;
3894         234                               1210      $self->{indexes_for}->{$db}->{$tbl} = $indexes;
3895                                                  
3896         234                               1333      foreach my $index ( keys %$indexes ) {
3897         408                               2058         $indexes->{$index}->{cnt} = 0;
3898                                                     }
3899                                                  
3900         234                               1303      return;
3901                                                  }
3902                                                  
3903                                                  sub add_table_usage {
3904           5                    5            32      my ( $self, $db, $tbl ) = @_;
3905  ***      5     50     33                   50      die "I need a db and table" unless defined $db && defined $tbl;
3906           5                                 32      ++$self->{tables_for}->{$db}->{$tbl};
3907                                                  }
3908                                                  
3909                                                  sub add_index_usage {
3910           5                    5            34      my ( $self, %args ) = @_;
3911           5                                 28      foreach my $arg ( qw(usage) ) {
3912  ***      5     50                          34         die "I need a $arg argument" unless defined $args{$arg};
3913                                                     }
3914           5                                 31      my ($id, $chk, $pos_in_log, $usage) = @args{qw(id chk pos_in_log usage)};
3915           5                                 21      foreach my $access ( @$usage ) {
3916           5                                 18         my ($db, $tbl, $idx, $alt) = @{$access}{qw(db tbl idx alt)};
               5                                 32   
3917           5                                 34         foreach my $index ( @$idx ) {
3918           3                                 45            $self->{indexes_for}->{$db}->{$tbl}->{$index}->{cnt}++;
3919                                                        }
3920                                                     }
3921                                                  }
3922                                                  
3923                                                  sub find_unused_indexes {
3924           6                    6            28      my ( $self, $callback ) = @_;
3925  ***      6     50                          31      die "I need a callback" unless $callback;
3926                                                  
3927           6                                 17      my %indexes_for = %{$self->{indexes_for}};
               6                                 52   
3928           6                                 23      my %tables_for  = %{$self->{tables_for}};
               6                                 56   
3929                                                  
3930           6                                 67      DATABASE:
3931           6                                 23      foreach my $db ( sort keys %{$self->{indexes_for}} ) {
3932          12                                224         TABLE:
3933          12                                 37         foreach my $tbl ( sort keys %{$self->{indexes_for}->{$db}} ) {
3934         234    100                        1397            next TABLE unless $self->{tables_for}->{$db}->{$tbl}; # Skip unused
3935           5                                 26            my $indexes = $self->{indexes_for}->{$db}->{$tbl};
3936           5                                 12            my @unused_indexes;
3937           5                                 34            foreach my $index ( sort keys %$indexes ) {
3938          11    100                          65               if ( !$indexes->{$index}->{cnt} ) { # count of times accessed/used
3939           8                                 37                  push @unused_indexes, $indexes->{$index};
3940                                                              }
3941                                                           }
3942  ***      5     50                          24            if ( @unused_indexes ) {
3943           5                                 37               $callback->(
3944                                                                 {  db  => $db,
3945                                                                    tbl => $tbl,
3946                                                                    idx => \@unused_indexes,
3947                                                                 }
3948                                                              );
3949                                                           }
3950                                                        } # TABLE
3951                                                     } # DATABASE
3952                                                  
3953           6                                 26      return;
3954                                                  }
3955                                                  
3956                                                  sub _d {
3957  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3958  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3959  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3960                                                          @_;
3961  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3962                                                  }
3963                                                  
3964                                                  1;
3965                                                  
3966                                                  # ###########################################################################
3967                                                  # End IndexUsage package
3968                                                  # ###########################################################################
3969                                                  
3970                                                  # ###########################################################################
3971                                                  # Progress package 6326
3972                                                  # This package is a copy without comments from the original.  The original
3973                                                  # with comments and its test file can be found in the SVN repository at,
3974                                                  #   trunk/common/Progress.pm
3975                                                  #   trunk/common/t/Progress.t
3976                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3977                                                  # ###########################################################################
3978                                                  package Progress;
3979                                                  
3980           1                    1             7   use strict;
               1                                  2   
               1                                  9   
3981           1                    1             5   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
3982                                                  
3983           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  4   
3984           1                    1             6   use Data::Dumper;
               1                                  3   
               1                                  4   
3985                                                  $Data::Dumper::Indent    = 1;
3986                                                  $Data::Dumper::Sortkeys  = 1;
3987                                                  $Data::Dumper::Quotekeys = 0;
3988                                                  
3989  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 13   
3990                                                  
3991                                                  sub new {
3992           6                    6            81      my ( $class, %args ) = @_;
3993           6                                 41      foreach my $arg (qw(jobsize)) {
3994  ***      6     50                          43         die "I need a $arg argument" unless defined $args{$arg};
3995                                                     }
3996  ***      6     50     33                   39      if ( (!$args{report} || !$args{interval}) ) {
3997  ***      6     50     33                   39         if ( $args{spec} && @{$args{spec}} == 2 ) {
               6                                 46   
3998           6                                 17            @args{qw(report interval)} = @{$args{spec}};
               6                                 69   
3999                                                        }
4000                                                        else {
4001  ***      0                                  0            die "I need either report and interval arguments, or a spec";
4002                                                        }
4003                                                     }
4004                                                  
4005  ***      6            50                   38      my $name  = $args{name} || "Progress";
4006  ***      6            50                   51      $args{start} ||= time();
4007           6                                 15      my $self;
4008                                                     $self = {
4009                                                        last_reported => $args{start},
4010                                                        fraction      => 0,       # How complete the job is
4011                                                        callback      => sub {
4012  ***      0                    0             0            my ($fraction, $elapsed, $remaining, $eta) = @_;
4013  ***      0                                  0            printf STDERR "$name: %3d%% %s remain\n",
4014                                                              $fraction * 100,
4015                                                              Transformers::secs_to_time($remaining),
4016                                                              Transformers::ts($eta);
4017                                                        },
4018           6                                148         %args,
4019                                                     };
4020           6                                 59      return bless $self, $class;
4021                                                  }
4022                                                  
4023                                                  sub validate_spec {
4024  ***      6     50             6            36      shift @_ if $_[0] eq 'Progress'; # Permit calling as Progress-> or Progress::
4025           6                                 26      my ( $spec ) = @_;
4026  ***      6     50                          32      if ( @$spec != 2 ) {
4027  ***      0                                  0         die "spec array requires a two-part argument\n";
4028                                                     }
4029  ***      6     50                          80      if ( $spec->[0] !~ m/^(?:percentage|time|iterations)$/ ) {
4030  ***      0                                  0         die "spec array's first element must be one of "
4031                                                          . "percentage,time,iterations\n";
4032                                                     }
4033  ***      6     50                          63      if ( $spec->[1] !~ m/^\d+$/ ) {
4034  ***      0                                  0         die "spec array's second element must be an integer\n";
4035                                                     }
4036                                                  }
4037                                                  
4038                                                  sub set_callback {
4039  ***      0                    0             0      my ( $self, $callback ) = @_;
4040  ***      0                                  0      $self->{callback} = $callback;
4041                                                  }
4042                                                  
4043                                                  sub start {
4044  ***      0                    0             0      my ( $self, $start ) = @_;
4045  ***      0             0                    0      $self->{start} = $self->{last_reported} = $start || time();
4046                                                  }
4047                                                  
4048                                                  sub update {
4049           6                    6            29      my ( $self, $callback, $now ) = @_;
4050           6                                 27      my $jobsize   = $self->{jobsize};
4051  ***      6            50                   36      $now        ||= time();
4052           6                                 28      $self->{iterations}++; # How many updates have happened;
4053                                                  
4054  ***      6     50     33                  105      if ( $self->{report} eq 'time'
      ***             0      0                        
4055                                                           && $self->{interval} > $now - $self->{last_reported}
4056                                                     ) {
4057           6                                 33         return;
4058                                                     }
4059                                                     elsif ( $self->{report} eq 'iterations'
4060                                                           && ($self->{iterations} - 1) % $self->{interval} > 0
4061                                                     ) {
4062  ***      0                                  0         return;
4063                                                     }
4064  ***      0                                  0      $self->{last_reported} = $now;
4065                                                  
4066  ***      0                                  0      my $completed = $callback->();
4067  ***      0                                  0      $self->{updates}++; # How many times we have run the update callback
4068                                                  
4069  ***      0      0                           0      return if $completed > $jobsize;
4070                                                  
4071  ***      0      0                           0      my $fraction = $completed > 0 ? $completed / $jobsize : 0;
4072                                                  
4073  ***      0      0      0                    0      if ( $self->{report} eq 'percentage'
4074                                                           && $self->fraction_modulo($self->{fraction})
4075                                                              >= $self->fraction_modulo($fraction)
4076                                                     ) {
4077  ***      0                                  0         $self->{fraction} = $fraction;
4078  ***      0                                  0         return;
4079                                                     }
4080  ***      0                                  0      $self->{fraction} = $fraction;
4081                                                  
4082  ***      0                                  0      my $elapsed   = $now - $self->{start};
4083  ***      0                                  0      my $remaining = 0;
4084  ***      0                                  0      my $eta       = $now;
4085  ***      0      0      0                    0      if ( $completed > 0 && $completed <= $jobsize && $elapsed > 0 ) {
      ***                    0                        
4086  ***      0                                  0         my $rate = $completed / $elapsed;
4087  ***      0      0                           0         if ( $rate > 0 ) {
4088  ***      0                                  0            $remaining = ($jobsize - $completed) / $rate;
4089  ***      0                                  0            $eta       = $now + int($remaining);
4090                                                        }
4091                                                     }
4092  ***      0                                  0      $self->{callback}->($fraction, $elapsed, $remaining, $eta);
4093                                                  }
4094                                                  
4095                                                  sub fraction_modulo {
4096  ***      0                    0             0      my ( $self, $num ) = @_;
4097  ***      0                                  0      $num *= 100; # Convert from fraction to percentage
4098  ***      0                                  0      return sprintf('%d',
4099                                                        sprintf('%d', $num / $self->{interval}) * $self->{interval});
4100                                                  }
4101                                                  
4102                                                  sub _d {
4103  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4104  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4105  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4106                                                          @_;
4107  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4108                                                  }
4109                                                  
4110                                                  1;
4111                                                  
4112                                                  # ###########################################################################
4113                                                  # End Progress package
4114                                                  # ###########################################################################
4115                                                  
4116                                                  # ###########################################################################
4117                                                  # This is a combination of modules and programs in one -- a runnable module.
4118                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
4119                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
4120                                                  #
4121                                                  # Check just above main() for the call to main() which actually runs the
4122                                                  # program.
4123                                                  # ###########################################################################
4124                                                  package mk_index_usage;
4125                                                  
4126           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
4127           1                    1             7   use Data::Dumper;
               1                                  7   
               1                                  5   
4128                                                  $Data::Dumper::Indent = 1;
4129                                                  $OUTPUT_AUTOFLUSH     = 1;
4130                                                  
4131  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 13   
4132                                                  
4133                                                  Transformers->import(qw(make_checksum));
4134                                                  
4135                                                  # Global variables.  Only really essential variables should be here.
4136                                                  my $oktorun = 1;
4137                                                  
4138                                                  if ( !caller ) { exit main(@ARGV); } # Run the program.
4139                                                  sub main {
4140           6                    6         29682      @ARGV = @_;  # set global ARGV for this package
4141                                                  
4142           6                                 56      $oktorun = 1;
4143                                                  
4144                                                     # ##########################################################################
4145                                                     # Get configuration information.
4146                                                     # ##########################################################################
4147           6                                122      my $o = new OptionParser(
4148                                                        strict      => 0,
4149                                                        prompt      => '[OPTION...] [FILE...]',
4150                                                        description => q{reads queries from logs and analyzes how they use }
4151                                                                     . q{indexes.},
4152                                                     );
4153           6                                 48      $o->get_specs();
4154           6                                125      $o->get_opts();
4155           6                                 33      my $dp = $o->DSNParser();
4156           6                                 36      $dp->prop('set-vars', $o->get('set-vars'));
4157  ***      6     50                          31      $o->set('progress', undef) if $o->get('q');
4158  ***      6     50                          28      if ( !$o->got('help') ) {
4159  ***      6     50                          30         if ( $o->get('progress') ) {
4160           6                                 19            eval { Progress->validate_spec($o->get('progress')) };
               6                                 25   
4161  ***      6     50                          28            if ( $EVAL_ERROR ) {
4162  ***      0                                  0               chomp $EVAL_ERROR;
4163  ***      0                                  0               $o->save_error("--progress $EVAL_ERROR");
4164                                                           }
4165                                                        }
4166                                                     }
4167           6                                 55      $o->usage_or_errors();
4168                                                  
4169                                                     # Open the database connection.
4170           6                                 55      my $dbh = get_cxn(
4171                                                        dsn          => $dp->parse_options($o),
4172                                                        OptionParser => $o,
4173                                                        DSNParser    => $dp,
4174                                                     );
4175                                                  
4176                                                     # ##########################################################################
4177                                                     # Make common modules.
4178                                                     # ##########################################################################
4179           6                                109      my $q      = new Quoter();
4180           6                                 77      my $qp     = new QueryParser();
4181           6                                 89      my $qr     = new QueryRewriter(QueryParser => $qp);
4182           6                                115      my $tp     = new TableParser(Quoter => $q);
4183           6                                 98      my $vp     = new VersionParser();
4184           6                                 93      my $parser = new SlowLogParser();
4185           6                                 98      my $fi     = new FileIterator();
4186           6                                 73      my $du     = new MySQLDump();
4187           6                                 92      my $si     = new SchemaIterator(Quoter => $q);
4188           6                                 90      my $iu     = new IndexUsage();
4189           6                                 84      my $exa    = new ExplainAnalyzer(QueryRewriter => $qr, QueryParser => $qp);
4190           6                                 40      my %common_modules = (
4191                                                        OptionParser => $o,
4192                                                        DSNParser    => $dp,
4193                                                        Quoter       => $q,
4194                                                     );
4195                                                  
4196                                                     # ########################################################################
4197                                                     # Populate the IndexUsage object with indexes.  Also get a list of all
4198                                                     # databases and tables before going on to parse the queries.  This will be
4199                                                     # important when we see a query without any default database, and we have to
4200                                                     # guess which database to USE for EXPLAIN-ing it.
4201                                                     # ########################################################################
4202           6                                 53      $si->set_filter($si->make_filter($o));
4203           6                                 16      my $version = $vp->parse($dbh->selectrow_array('SELECT VERSION()'));
4204           6                                136      my $next_db = $si->get_db_itr(dbh => $dbh);
4205                                                     DATABASE:
4206           6                                 29      while ( my $database = $next_db->() ) {
4207          12                                 32         MKDEBUG && _d('Getting tables from', $database);
4208          12                                 84         my $next_tbl = $si->get_tbl_itr(
4209                                                           dbh   => $dbh,
4210                                                           db    => $database,
4211                                                           views => 0,
4212                                                        );
4213                                                        TABLE:
4214          12                                 56         while ( my $table = $next_tbl->() ) {
4215         234                                539            MKDEBUG && _d('Got table', $table);
4216         234                                673            eval {
4217         234                               1193               my $ddl       = $du->get_create_table(
4218                                                                              $dbh, $q, $database, $table)->[1];
4219         234                               1736               my ($indexes) = $tp->get_keys($ddl, {version => $version });
4220         234                               1545               $iu->add_indexes(db=>$database, tbl=>$table, indexes=>$indexes);
4221                                                           };
4222  ***    234     50                        1487            if ( $EVAL_ERROR ) {
4223  ***      0      0                           0               warn $EVAL_ERROR unless $o->get('q');
4224  ***      0                                  0               MKDEBUG && _d($EVAL_ERROR);
4225                                                           }
4226                                                        }
4227                                                     }
4228                                                  
4229                                                     # ########################################################################
4230                                                     # This keeps track of the $dbh's current DB, so we know when to USE a
4231                                                     # different database.
4232                                                     # ########################################################################
4233           6                                 25      my $cur_db = '';
4234                                                  
4235                                                     # ########################################################################
4236                                                     # This keeps track of statements that can't be EXPLAINed for some reason, so
4237                                                     # they are not tried again.
4238                                                     # ########################################################################
4239           6                                 21      my %err_for = ();
4240                                                  
4241                                                     # ########################################################################
4242                                                     # This is the main loop over the input filenames.
4243                                                     # ########################################################################
4244           6                                 52      my $next_file = $fi->get_file_itr(@ARGV);
4245           6                                 30      my ( $fh, $filename, $filesize ) = $next_file->();
4246                                                     FILE:
4247           6                                 34      while ( defined $fh ) {
4248                                                  
4249                                                        # Create a callback to get events from the slow query log file.
4250           6                   13            54         my $next_event = sub { return <$fh>; };
              13                                248   
4251           6                   20            37         my $tell = sub { return tell $fh; };
              20                                101   
4252           6                                 18         my $event;
4253                                                        my $get_event = sub {
4254                                                           return $parser->parse_event(
4255                                                              event      => $event,
4256                                                              next_event => $next_event,
4257                                                              tell       => $tell,
4258           6                                 24               oktorun    => sub { return 1 },
4259          13                   13           174               misc       => {},
4260                                                              stats      => {},
4261                                                           );
4262           6                                 59         };
4263                                                  
4264                                                        # #####################################################################
4265                                                        # Set up a progress reporter.  For right now, we just do one per file.
4266                                                        # Maybe someday we can do a global progress report?
4267                                                        # #####################################################################
4268           6                                 19         my $pr;
4269  ***      6     50     33                   41         if ( $o->get('progress') && $filename && -e $filename ) {
      ***                   33                        
4270           6                                 58            $pr = new Progress(
4271                                                              jobsize => -s $filename,
4272                                                              spec    => $o->get('progress'),
4273                                                              name    => $filename,
4274                                                           );
4275                                                        }
4276                                                  
4277                                                        # #####################################################################
4278                                                        # This is the main loop over the queries in the log.  For each query we
4279                                                        # are going to store what we learn about that query's EXPLAIN plan, keyed
4280                                                        # off its fingerprint.
4281                                                        # #####################################################################
4282                                                        EVENT:
4283           6                                 31         while ( $event = $get_event->() ) {
4284  ***      7     50                          56            my $arg = $event->{arg} or next EVENT; # The arg is the SQL.
4285           7                                 68            my $fingerprint = $event->{fingerprint} = $qr->fingerprint($arg);
4286                                                  
4287                                                           # Skip events that previously had an error.
4288           7    100                          38            next if $err_for{$fingerprint};
4289                                                  
4290           6                                 21            eval {
4291                                                  
4292                                                              # Checksum the query and get the query's ID.
4293           6                                 44               my $chk = make_checksum($arg);
4294           6                                 26               my $id  = make_checksum($fingerprint);
4295                                                  
4296                                                              # Do we need to USE a new database before we EXPLAIN the query?
4297  ***      6            33                   34               my $new_db = $event->{db} || $event->{Schema};
4298  ***      6     50     33                   78               if ( $new_db && $new_db ne $cur_db ) {
4299           6                                 34                  $dbh->do('USE ' . $q->quote($new_db));
4300           6                                 29                  $cur_db = $new_db;
4301                                                              }
4302                                                  
4303                                                              # See if we've EXPLAIN'ed this checksum before.  If so, just
4304                                                              # increment counters with the saved info from $exa.  If not, EXPLAIN
4305                                                              # and increment counters, then save to $exa.
4306           6                                 52               my $access = $exa->get_usage_for($chk, $cur_db);
4307  ***      6     50                          31               if ( !$access ) {
4308                                                  
4309                                                                 # The query might not be explain-able.  If that is so, it will
4310                                                                 # die, and we want that to happen so it gets blacklisted.  We
4311                                                                 # don't want it to return an error or something like that, and we
4312                                                                 # don't want to filter it out and skip it in the first place,
4313                                                                 # because then we will keep burning cycles on it trying to
4314                                                                 # explain it over and over.
4315           6                                 52                  my $explain = $exa->explain_query(
4316                                                                    dbh => $dbh,
4317                                                                    sql => $arg,
4318                                                                 );
4319           5                                 78                  $access = $exa->get_index_usage(
4320                                                                    sql     => $arg,
4321                                                                    db      => $cur_db,
4322                                                                    explain => $exa->normalize($explain),
4323                                                                 );
4324           5                                 34                  $exa->save_usage_for($chk, $cur_db, $access);
4325                                                              }
4326           5                                 27               foreach my $row ( @$access ) {
4327           5                                 40                  $iu->add_table_usage($row->{db}, $row->{tbl});
4328           5                                 32                  $iu->add_index_usage(usage => $access);
4329                                                              }
4330                                                  
4331                                                           };
4332           6    100                          34            if ( $EVAL_ERROR ) {
4333                                                              # Skip statements with this fingerprint in the future.
4334           1                                 11               $err_for{$fingerprint} = { event => $event, error => $EVAL_ERROR };
4335                                                  
4336                                                              # Log the error.
4337           1                                  7               MKDEBUG && _d('Problem on query', $event, $EVAL_ERROR);
4338  ***      1     50                           8               warn $EVAL_ERROR unless $o->get('q');
4339                                                           }
4340  ***      6     50                          64            $pr->update($tell) if $pr;
4341                                                        }
4342                                                  
4343           6                                 60         ( $fh, $filename, $filesize ) = $next_file->();
4344                                                     }
4345                                                  
4346                                                     # ########################################################################
4347                                                     # All done!  Now just print out the unused indexes.
4348                                                     # ########################################################################
4349                                                     $iu->find_unused_indexes(
4350                                                        sub {
4351           5                    5            21            my ( $unused ) = @_;
4352           5                                 36            print_unused_indexes(
4353                                                              unused => $unused,
4354                                                              drop   => $o->get('drop'),
4355                                                              %common_modules,
4356                                                           );
4357                                                        }
4358           6                                246      );
4359                                                  
4360           6                                356      $dbh->disconnect;
4361           6                               2566      return 0;
4362                                                  } # End main().
4363                                                  
4364                                                  # ############################################################################
4365                                                  # Subroutines.
4366                                                  # ############################################################################
4367                                                  sub print_unused_indexes {
4368           5                    5            51      my ( %args ) = @_;
4369           5                                 31      my @required_args = qw(unused drop Quoter);
4370           5                                 20      foreach my $arg ( @required_args ) {
4371  ***     15     50                          78         die "I need a $arg arugment" unless $args{$arg};
4372                                                     }
4373           5                                 43      my ($unused, $drop, $q) = @args{@required_args};
4374                                                  
4375           5                                 31      my $db_tbl = $q->quote($unused->{db}, $unused->{tbl});
4376                                                  
4377                                                     # We must ignore the types that we're not dropping, then group
4378                                                     # indexes of the remaining types together and print them together.
4379           5                                 23      my (@primary, @unique, @nonunique);
4380           5                                 14      foreach my $idx ( @{$unused->{idx}} ) {
               5                                 25   
4381           8    100                          63         if ($idx->{name} =~ m/PRIMARY/i ) {
      ***            50                               
4382           3                                 13            push @primary, $idx;
4383                                                        }
4384                                                        elsif ( $idx->{is_unique} ) {
4385  ***      0                                  0            push @unique, $idx;
4386                                                        }
4387                                                        else {
4388           5                                 25            push @nonunique, $idx;
4389                                                        }
4390                                                     }
4391                                                  
4392                                                     print_alter_drop_key(
4393  ***      5    100     66                   68         db_tbl => $db_tbl,
4394                                                        idx    => \@primary,
4395                                                        type   => 'primary key',
4396                                                        %args
4397                                                     ) if $drop->{primary} || $drop->{all};
4398                                                  
4399  ***      5    100     66                   68      print_alter_drop_key(
4400                                                        db_tbl => $db_tbl,
4401                                                        idx    => \@unique,
4402                                                        type   => 'unique',
4403                                                        %args
4404                                                     ) if $drop->{unique} || $drop->{all};
4405                                                  
4406  ***      5     50     66                   67      print_alter_drop_key(
4407                                                        db_tbl => $db_tbl,
4408                                                        idx    => \@nonunique,
4409                                                        type   => 'non-unique',
4410                                                        %args
4411                                                     ) if $drop->{"non-unique"} || $drop->{all};
4412                                                  
4413           5                                 38      return;
4414                                                  }
4415                                                  
4416                                                  sub print_alter_drop_key {
4417           7                    7            63      my ( %args ) = @_;
4418           7                                 47      my @required_args = qw(db_tbl idx Quoter);
4419           7                                 32      foreach my $arg ( @required_args ) {
4420  ***     21     50                         101         die "I need a $arg arugment" unless $args{$arg};
4421                                                     }
4422           7                                 35      my ($db_tbl, $idx, $q) = @args{@required_args};
4423                                                  
4424           7    100                          32      return unless @$idx;
4425                                                  
4426           6                                 30      print "\nALTER TABLE $db_tbl "
4427  ***      5     50                          27         . join(', ', map { "DROP KEY " . $q->quote($_->{name}) } @$idx)
4428                                                        . ";"
4429                                                        . ($args{type} ? " -- type:$args{type}" : "")
4430                                                        . "\n";
4431                                                  
4432           5                                 29      return;
4433                                                  }
4434                                                  
4435                                                  sub get_cxn {
4436           6                    6            57      my ( %args ) = @_;
4437           6                                 47      my @required_args = qw(dsn OptionParser DSNParser);
4438           6                                 34      foreach my $arg ( @required_args ) {
4439  ***     18     50                          97         die "I need a $arg argument" unless $args{$arg};
4440                                                     }
4441           6                                 35      my ($dsn, $o, $dp) = @args{@required_args};
4442                                                  
4443  ***      6     50                          28      if ( $o->get('ask-pass') ) {
4444  ***      0      0                           0         $dsn->{p} = OptionParser::prompt_noecho("Enter password "
4445                                                           . ($args{for} ? "for $args{for}: " : ": "));
4446                                                     }
4447                                                  
4448           6                                 64      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), $args{opts});
4449           6                                 25      MKDEBUG && _d('Connected dbh', $dbh);
4450           6                                 42      return $dbh;
4451                                                  }
4452                                                  
4453                                                  sub _d {
4454  ***      0                    0                    my ($package, undef, $line) = caller 0;
4455  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4456  ***      0                                              map { defined $_ ? $_ : 'undef' }
4457                                                          @_;
4458  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4459                                                  }
4460                                                  
4461                                                  1; # Because this is a module as well as a script.
4462                                                  
4463                                                  # #############################################################################
4464                                                  # Documentation.
4465                                                  # #############################################################################
4466                                                  
4467                                                  =pod
4468                                                  
4469                                                  =head1 NAME
4470                                                  
4471                                                  mk-index-usage - Read queries from a log and analyze how they use indexes.
4472                                                  
4473                                                  =head1 SYNOPSIS
4474                                                  
4475                                                   mk-index-usage /path/to/slow.log --host localhost
4476                                                  
4477                                                  =head1 RISKS
4478                                                  
4479                                                  The following section is included to inform users about the potential risks,
4480                                                  whether known or unknown, of using this tool.  The two main categories of risks
4481                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
4482                                                  tools) and those created by bugs.
4483                                                  
4484                                                  This tool is read-only.  It tries to read a log of queries and EXPLAIN them.  It
4485                                                  also gathers information about all tables in all databases.  It should be very
4486                                                  low-risk.
4487                                                  
4488                                                  The authoritative source for updated information is always the online issue
4489                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
4490                                                  see a list of such issues at the following URL:
4491                                                  L<http://www.maatkit.org/bugs/mk-index-usage>.
4492                                                  
4493                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
4494                                                  
4495                                                  =head1 DESCRIPTION
4496                                                  
4497                                                  This tool connects to a MySQL database server, reads through a query log, and
4498                                                  asks MySQL how it will use each query.  When it is finished, it prints out a
4499                                                  report on indexes that the queries didn't use.
4500                                                  
4501                                                  The query log needs to be in MySQL's slow query log format.  If you need to
4502                                                  input a different format, you can use L<mk-query-digest> to translate the
4503                                                  formats.  If you don't specify a filename, the tool reads from STDIN.
4504                                                  
4505                                                  The tool runs two stages.  In the first stage, the tool takes inventory of all
4506                                                  the tables and indexes in your database, so it can compare the existing indexes
4507                                                  to those that were actually used by the queries in the log.  In the second
4508                                                  stage, it runs EXPLAIN on each query in the query log.  If the query is not a
4509                                                  SELECT, it tries to transform it to a roughly equivalent SELECT query.  This is
4510                                                  not a perfect process, but it is good enough to be useful.
4511                                                  
4512                                                  The tool skips the EXPLAIN step for queries that are exact duplicates of those
4513                                                  seen before.  It assumes that the same query will generate the same EXPLAIN plan
4514                                                  as it did previously (usually a safe assumption, and generally good for
4515                                                  performance), and simply increments the count of times that the indexes were
4516                                                  used.  However, queries that have the same fingerprint but different checksums
4517                                                  will be re-EXPLAINed.  Queries that have different literal constants can have
4518                                                  different execution plans, and this is important to measure.
4519                                                  
4520                                                  After EXPLAIN-ing the query, it is necessary to try to map aliases in the query
4521                                                  back to the original table names.  For example, consider the EXPLAIN plan for
4522                                                  the following query:
4523                                                  
4524                                                    SELECT * FROM tbl1 AS foo;
4525                                                  
4526                                                  The EXPLAIN output will show access to table C<foo>, and that must be translated
4527                                                  back to C<tbl1>.  This process involves complex parsing.  It is generally very
4528                                                  accurate, but there is some chance that it might not work right.  If you find
4529                                                  cases where it fails, submit a bug report and a reproducible test case.
4530                                                  
4531                                                  Queries that cannot be EXPLAIN'ed will cause all subsequent queries with the
4532                                                  same fingerprint to be blacklisted.  This is to reduce the work they cause, and
4533                                                  prevent them from continuing to print error messages.  However, at least in this
4534                                                  stage of the tool's development, it is my opinion that it's not a good idea to
4535                                                  pre-emtively silence these, or prevent them from being EXPLAIN'ed at all.  I am
4536                                                  looking for lots of feedback on how to improve things like the query parsing.
4537                                                  So please submit your test cases based on the errors the tool prints!
4538                                                  
4539                                                  =head1 OUTPUT
4540                                                  
4541                                                  After it reads all the events in the log, the tool prints out DROP statements
4542                                                  for every index that was not used.  It skips indexes for tables that were never
4543                                                  accessed by any queries in the log, to avoid false-positive results.
4544                                                  
4545                                                  If you don't specify L<"--quiet">, the tool also outputs warnings about
4546                                                  statements that cannot be EXPLAIN'ed and similar.  These go to standard error.
4547                                                  
4548                                                  Progress reports are enabled by default (see L<"--progress">).  These also go to
4549                                                  standard error.
4550                                                  
4551                                                  =head1 OPTIONS
4552                                                  
4553                                                  =over
4554                                                  
4555                                                  =item --ask-pass
4556                                                  
4557                                                  Prompt for a password when connecting to MySQL.
4558                                                  
4559                                                  =item --charset
4560                                                  
4561                                                  short form: -A; type: string
4562                                                  
4563                                                  Default character set.  If the value is utf8, sets Perl's binmode on
4564                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
4565                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
4566                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
4567                                                  connecting to MySQL.
4568                                                  
4569                                                  =item --config
4570                                                  
4571                                                  type: Array
4572                                                  
4573                                                  Read this comma-separated list of config files; if specified, this must be the
4574                                                  first option on the command line.
4575                                                  
4576                                                  =item --defaults-file
4577                                                  
4578                                                  short form: -F; type: string
4579                                                  
4580                                                  Only read mysql options from the given file.  You must give an absolute pathname.
4581                                                  
4582                                                  =item --drop
4583                                                  
4584                                                  type: Hash; default: non-unique
4585                                                  
4586                                                  Suggest dropping only these types of unusued indexes.
4587                                                  
4588                                                  By default mk-index-usage will only suggest to drop unused secondary indexes,
4589                                                  not primary or unique indexes.  You can specify which types of unused indexes
4590                                                  the tool suggests to drop: primary, unique, non-unique, all.
4591                                                  
4592                                                  A separate C<ALTER TABLE> statement for each type is printed.  So if you
4593                                                  specify C<--drop all> and there is a primary key and a non-unique index,
4594                                                  the C<ALTER TABLE ... DROP> for each will be printed on separate lines.
4595                                                  
4596                                                  =item --help
4597                                                  
4598                                                  Show help and exit.
4599                                                  
4600                                                  =item --host
4601                                                  
4602                                                  short form: -h; type: string
4603                                                  
4604                                                  Connect to host.
4605                                                  
4606                                                  =item --password
4607                                                  
4608                                                  short form: -p; type: string
4609                                                  
4610                                                  Password to use when connecting.
4611                                                  
4612                                                  =item --port
4613                                                  
4614                                                  short form: -P; type: int
4615                                                  
4616                                                  Port number to use for connection.
4617                                                  
4618                                                  =item --progress
4619                                                  
4620                                                  type: array; default: time,30
4621                                                  
4622                                                  Print progress reports to STDERR.  The value is a comma-separated list with two
4623                                                  parts.  The first part can be percentage, time, or iterations; the second part
4624                                                  specifies how often an update should be printed, in percentage, seconds, or
4625                                                  number of iterations.
4626                                                  
4627                                                  =item --quiet
4628                                                  
4629                                                  short form: -q
4630                                                  
4631                                                  Do not print any warnings.  Also disables L<"--progress">.
4632                                                  
4633                                                  =item --set-vars
4634                                                  
4635                                                  type: string; default: wait_timeout=10000
4636                                                  
4637                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
4638                                                  string will be appended to SET and executed.
4639                                                  
4640                                                  =item --socket
4641                                                  
4642                                                  short form: -S; type: string
4643                                                  
4644                                                  Socket file to use for connection.
4645                                                  
4646                                                  =item --user
4647                                                  
4648                                                  short form: -u; type: string
4649                                                  
4650                                                  User for login if not current user.
4651                                                  
4652                                                  =item --version
4653                                                  
4654                                                  Show version and exit.
4655                                                  
4656                                                  =back
4657                                                  
4658                                                  =head1 DSN OPTIONS
4659                                                  
4660                                                  These DSN options are used to create a DSN.  Each option is given like
4661                                                  C<option=value>.  The options are case-sensitive, so P and p are not the
4662                                                  same option.  There cannot be whitespace before or after the C<=> and
4663                                                  if the value contains whitespace it must be quoted.  DSN options are
4664                                                  comma-separated.  See the L<maatkit> manpage for full details.
4665                                                  
4666                                                  =over
4667                                                  
4668                                                  =item * A
4669                                                  
4670                                                  dsn: charset; copy: yes
4671                                                  
4672                                                  Default character set.
4673                                                  
4674                                                  =item * D
4675                                                  
4676                                                  dsn: database; copy: yes
4677                                                  
4678                                                  Database to connect to.
4679                                                  
4680                                                  =item * F
4681                                                  
4682                                                  dsn: mysql_read_default_file; copy: yes
4683                                                  
4684                                                  Only read default options from the given file
4685                                                  
4686                                                  =item * h
4687                                                  
4688                                                  dsn: host; copy: yes
4689                                                  
4690                                                  Connect to host.
4691                                                  
4692                                                  =item * p
4693                                                  
4694                                                  dsn: password; copy: yes
4695                                                  
4696                                                  Password to use when connecting.
4697                                                  
4698                                                  =item * P
4699                                                  
4700                                                  dsn: port; copy: yes
4701                                                  
4702                                                  Port number to use for connection.
4703                                                  
4704                                                  =item * S
4705                                                  
4706                                                  dsn: mysql_socket; copy: yes
4707                                                  
4708                                                  Socket file to use for connection.
4709                                                  
4710                                                  =item * u
4711                                                  
4712                                                  dsn: user; copy: yes
4713                                                  
4714                                                  User for login if not current user.
4715                                                  
4716                                                  =back
4717                                                  
4718                                                  =head1 DOWNLOADING
4719                                                  
4720                                                  You can download Maatkit from Google Code at
4721                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
4722                                                  easily with a command like the following:
4723                                                  
4724                                                     wget http://www.maatkit.org/get/toolname
4725                                                     or
4726                                                     wget http://www.maatkit.org/trunk/toolname
4727                                                  
4728                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
4729                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
4730                                                  needed.  The first URL gets the latest released version of the tool, and the
4731                                                  second gets the latest trunk code from Subversion.
4732                                                  
4733                                                  =head1 ENVIRONMENT
4734                                                  
4735                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
4736                                                  the Maatkit tools:
4737                                                  
4738                                                     MKDEBUG=1 mk-....
4739                                                  
4740                                                  =head1 SYSTEM REQUIREMENTS
4741                                                  
4742                                                  You need Perl and some core packages that ought to be installed in any
4743                                                  reasonably new version of Perl.
4744                                                  
4745                                                  =head1 BUGS
4746                                                  
4747                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-index-usage>.
4748                                                  
4749                                                  Please use Google Code Issues and Groups to report bugs or request support:
4750                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
4751                                                  discuss Maatkit.
4752                                                  
4753                                                  Please include the complete command-line used to reproduce the problem you are
4754                                                  seeing, the version of all MySQL servers involved, the complete output of the
4755                                                  tool when run with L<"--version">, and if possible, debugging output produced by
4756                                                  running with the C<MKDEBUG=1> environment variable.
4757                                                  
4758                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
4759                                                  
4760                                                  This program is copyright 2010-@CURRENTYEAR@ Baron Schwartz.
4761                                                  Feedback and improvements are welcome.
4762                                                  
4763                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
4764                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
4765                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
4766                                                  
4767                                                  This program is free software; you can redistribute it and/or modify it under
4768                                                  the terms of the GNU General Public License as published by the Free Software
4769                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
4770                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
4771                                                  licenses.
4772                                                  
4773                                                  You should have received a copy of the GNU General Public License along with
4774                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
4775                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
4776                                                  
4777                                                  =head1 AUTHOR
4778                                                  
4779                                                  Baron Schwartz, Daniel Nichter
4780                                                  
4781                                                  =head1 ABOUT MAATKIT
4782                                                  
4783                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
4784                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
4785                                                  code contributors.  Both are employed by Percona.  Financial support for
4786                                                  Maatkit development is primarily provided by Percona and its clients. 
4787                                                  
4788                                                  =head1 VERSION
4789                                                  
4790                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 6369 $.
4791                                                  
4792                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
54    ***     50      0      7   unless $args{$arg}
60    ***     50      0     57   if (not $$opt{'key'} or not $$opt{'desc'})
80           100      6     27   if (@_ > 2)
89    ***     50      0      7   if (not $dsn)
101   ***     50     10      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
113   ***     50      0     57   if (not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'})
119          100     47     10   if (not defined $final_props{$key})
126   ***     50      0     10   unless exists $$opts{$key}
131   ***     50      0      7   if (my $required = $self->prop('required'))
133   ***      0      0      0   unless $final_props{$key}
145   ***     50      0      6   unless ref $o eq 'OptionParser'
148          100     42      6   if $o->has($_)
158   ***      0      0      0   unless ref $dsn
159   ***      0      0      0   $props ? :
160   ***      0      0      0   $_ eq 'p' ? :
161   ***      0      0      0   if defined $$dsn{$_}
162   ***      0      0      0   unless not $props
175   ***      0      0      0   $opts{$key}{'copy'} ? :
189   ***     50      0      7   if ($driver eq 'Pg') { }
221   ***     50      0      7   $cxn_string =~ /charset=utf8/ ? :
230   ***     50      0      7   if ($$opts{'mysql_use_result'})
234   ***     50      0      7   if (not $have_dbi)
253   ***     50      7      0   if ($cxn_string =~ /mysql/i)
260   ***     50      0      7   $sql_mode ? :
267   ***     50      0      7   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
272   ***      0      0      0   if ($charset eq 'utf8') { }
273   ***      0      0      0   unless binmode STDOUT, ':utf8'
277   ***      0      0      0   unless binmode STDOUT
281          100      6      1   if ($self->prop('set-vars'))
288   ***     50      0      7   if (not $dbh and $EVAL_ERROR)
290   ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
303   ***      0      0      0   if (not $tries)
325   ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
342   ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
352   ***      0      0      0   unless $dsn_1
353   ***      0      0      0   unless $dsn_2
357   ***      0      0      0   if ($args{'overwrite'}) { }
358   ***      0      0      0   defined $$dsn_1{$key} ? :
361   ***      0      0      0   defined $$dsn_2{$key} ? :
370   ***      0      0      0   defined $_ ? :
414   ***      0      0      0   unless defined $val
415   ***      0      0      0   if $val eq ''
416   ***      0      0      0   if $val =~ /^0x[0-9a-fA-F]/
426   ***      0      0      0   if (not $tbl)
435   ***      0      0      0   unless $like
442   ***      0      0      0   unless $db_tbl
444   ***      0      0      0   if (not $tbl)
448   ***      0      0      0   if $db and not $db =~ /^`/
449   ***      0      0      0   if $tbl and not $tbl =~ /^`/
450   ***      0      0      0   $db ? :
483   ***     50      0     12   unless $args{$arg}
553   ***     50      0      6   unless open my $fh, '<', $file
556   ***     50      6      0   if ($contents =~ /^=head1 DSN OPTIONS/m)
566   ***     50     96      0   if ($val)
567   ***     50      0     48   $val eq 'no' ? :
             100     48     48   $val eq 'yes' ? :
615   ***     50      0     12   unless open my $fh, '<', $file
623          100   7338     12   unless $para =~ /^=head1 $$self{'head1'}/
628          100     12      6   if $para =~ /^=over/
629   ***     50      6      0   if $$self{'skip_rules'}
637   ***     50      0     12   unless $para
640          100    138     12   if (my($option) = $para =~ /^=item $$self{'item'}/)
647          100    120     18   if ($para =~ /: /) { }
651   ***     50      0    228   unless $$self{'attributes'}{$attrib}
655          100     48     72   if ($attribs{'short form'})
671   ***     50      0    138   if $para =~ /^=item/
673   ***     50      0    138   if (my($base_option) = $option =~ /^\[no\](.*)/)
678          100     18    120   $attribs{'default'} ? :
      ***     50      0    138   $attribs{'group'} ? :
686   ***     50      0    174   unless $para
687          100     12    162   if ($para =~ /^=head1/)
691          100    138     24   if $para =~ /^=item /
695   ***     50      0     12   unless @specs
706   ***     50     90      0   if (ref $opt) { }
711   ***     50      0     90   if (not $long)
716   ***     50      0     90   if exists $$self{'opts'}{$long}
719   ***     50      0     90   if (length $long == 1)
724          100     48     42   if ($short) { }
725   ***     50      0     48   if exists $$self{'short_opts'}{$short}
734   ***     50      0     90   $$opt{'spec'} =~ /!/ ? :
735   ***     50      0     90   $$opt{'spec'} =~ /\+/ ? :
736   ***     50      0     90   $$opt{'desc'} =~ /required/ ? :
749          100     18     72   if $type and $type =~ /[HhAadzm]/
751          100     18     72   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
752   ***     50     18      0   defined $def ? :
756          100      6     84   if ($long eq 'config')
760   ***     50      0     90   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
773   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
778   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
783   ***      0      0      0   if ($opt =~ /default to/)
788   ***      0      0      0   if ($opt =~ /restricted to option groups/)
798   ***      0      0      0   unless $rule_ok
815   ***      0      0      0   unless exists $$self{'opts'}{$long}
839   ***      0      0      0   unless exists $$self{'opts'}{$long}
859   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50      7      0   exists $$self{'opts'}{$opt} ? :
864   ***     50      0      7   if ($$opt{'is_cumulative'}) { }
879   ***     50      0     66   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     24     66   exists $$self{'defaults'}{$long} ? :
888   ***     50      0      6   if (@ARGV and $ARGV[0] eq '--config')
892   ***     50      6      0   if ($self->has('config'))
898   ***     50     24      0   if ($EVAL_ERROR)
899   ***     50      0     24   $self->got('config') ? :
914   ***     50      0      6   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
917   ***     50      0      6   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
918   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
924   ***     50      0      6   if (@ARGV and $$self{'strict'})
930   ***      0      0      0   if (@set > 1)
941   ***      0      0      0   if (@set == 0)
960   ***     50      0     90   unless $long
962          100      7     83   if ($$opt{'got'}) { }
      ***     50      0     83   elsif ($$opt{'is_required'}) { }
963   ***     50      0      7   if (exists $$self{'disables'}{$long})
970   ***     50      0      7   if (exists $$self{'allowed_groups'}{$long})
982   ***      0      0      0   if $restricted_opt eq $long
983   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
988   ***      0      0      0   if (@restricted_opts)
990   ***      0      0      0   if (@restricted_opts == 1) { }
1011  ***     50     90      0   if ($$opt{'parsed'}) { }
1019  ***     50      0      6   if @long == $long_last
1029  ***     50      0     90   unless $opt
1031         100     24     66   if (not $$opt{'type'})
1038  ***     50      0     66   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0     66   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     66   elsif ($val and $$opt{'type'} eq 'z') { }
             100      6     60   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     12     48   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1041  ***      0      0      0   if (not $suffix)
1047  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1048  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1063  ***      0      0      0   if ($from_key)
1065  ***      0      0      0   if ($$self{'opts'}{$from_key}{'parsed'}) { }
1098         100     55     47   length $opt == 1 ? :
1099  ***     50      0    102   unless $long and exists $$self{'opts'}{$long}
1106  ***     50      0     30   length $opt == 1 ? :
1107  ***     50      0     30   unless $long and exists $$self{'opts'}{$long}
1114         100     48     48   length $opt == 1 ? :
1115         100     90      6   defined $long ? :
1120  ***      0      0      0   length $opt == 1 ? :
1121  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1148  ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
1156  ***     50      0      6   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      6   elsif (scalar @{$$self{'errors'};}) { }
1157  ***      0      0      0   unless print $self->print_usage
1161  ***      0      0      0   unless print $self->print_errors
1170  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1179  ***      0      0      0   unless $$self{'got_opts'}
1182  ***      0      0      0   $$_{'is_negatable'} ? :
1186  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1202  ***      0      0      0   $group eq 'default' ? :
1208  ***      0      0      0   $$opt{'is_negatable'} ? :
1211  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1220  ***      0      0      0   if ($short) { }
1229  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1233  ***      0      0      0   if ($$self{'DSNParser'})
1241  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1253  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1256  ***      0      0      0   unless print $prompt
1264  ***      0      0      0   unless print "\n"
1267  ***      0      0      0   if ($EVAL_ERROR)
1289  ***     50     24      0   unless open my $fh, '<', $filename
1297  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1300  ***      0      0      0   if ($line eq '--')
1305  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1323  ***      0      0      0   unless open my $fh, '<', $file
1327  ***      0      0      0   unless $para =~ /^=pod$/m
1331  ***      0      0      0   unless $para =~ /$regex/
1336  ***      0      0      0   unless close $fh
1350  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1366  ***      0      0      0   if (lc($val || '') eq 'null')
1374  ***      0      0      0   if (defined $num) { }
1375  ***      0      0      0   if ($factor)
1391         100     48     42   $$attribs{'short form'} ? :
      ***     50      0     90   $$attribs{'negatable'} ? :
      ***     50      0     90   $$attribs{'cumulative'} ? :
             100     66     24   $$attribs{'type'} ? :
1400  ***      0      0      0   defined $_ ? :
1452  ***      0      0      0   unless $query
1456  ***      0      0      0   if ($ddl_stmt)
1459  ***      0      0      0   if ($query =~ /$ddl_stmt DATABASE\b/i)
1463  ***      0      0      0   if ($ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i)
1475  ***      0      0      0   if ($query =~ /^\s*LOCK TABLES/i)
1491  ***      0      0      0   if $tbls =~ /\ASELECT\b/i
1496  ***      0      0      0   if (not $tbl =~ /[a-zA-Z]/)
1521  ***     50      0      5   unless $query
1537  ***     50      5      0   if ($tbl_refs) { }
1539  ***     50      0      5   if ($query =~ /^(?:INSERT|REPLACE)/i)
1563  ***     50      0      5   if ($tbl_ref =~ /^AS\s+\w+/i)
1573         100      1      4   if $db
1580  ***     50      0      5   if ($list) { }
1590  ***      0      0      0   unless $query
1599  ***      0      0      0   if (@split_statements == 1) { }
1606  ***      0      0      0   if ($statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i)
1618  ***      0      0      0   unless $query
1628  ***      0      0      0   unless $query
1639  ***      0      0      0   if ($word =~ /^\(?SELECT\b/i) { }
1641  ***      0      0      0   if ($start_pos) { }
1659  ***      0      0      0   unless $sqno
1662  ***      0      0      0   if ($$sq{'done'})
1671  ***      0      0      0   if ($$sq{'lp'} + $lp - ($$sq{'rp'} + $rp) == 0)
1682  ***      0      0      0   unless $sq
1697  ***      0      0      0   if ($type =~ /^SELECT\b/) { }
      ***      0      0      0   elsif ($type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/) { }
1714  ***      0      0      0   unless $query
1717  ***      0      0      0   if ($query =~ /^SELECT/i) { }
      ***      0      0      0   elsif ($query =~ /^(?:INSERT|REPLACE)/i) { }
1740  ***      0      0      0   if ($cols_def)
1755  ***      0      0      0   unless $query
1779  ***      0      0      0   unless $query
1784  ***      0      0      0   unless $db_tbl
1785  ***      0      0      0   if $seen{$db_tbl}++
1794         100      9      6   unless defined $str
1803  ***      0      0      0   defined $_ ? :
1860  ***      0      0      0   unless $query
1863  ***      0      0      0   if ($query =~ /$vlc_rf/i)
1880  ***      0      0      0   unless $query =~ /IN\s*\(\s*(?!select)/i
1906  ***      0      0      0   unless @vals > 20
1918  ***     50      0      7   if $query =~ m[\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `]
1920  ***     50      0      7   if $query =~ m[/\*\w+\.\w+:[0-9]/[0-9]\*/]
1922  ***     50      0      7   if $query =~ /\Aadministrator command: /
1924  ***     50      0      7   if $query =~ /\A\s*(call\s+\S+)\(/i
1926  ***     50      0      7   if (my($beginning) = $query =~ /\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is)
1932  ***     50      0      7   if $query =~ s/\Ause \S+\Z/use ?/i
1960  ***      0      0      0   if $query =~ /\A\s*call\s+(\S+)\(/i
1961  ***      0      0      0   if $query =~ /\A\s*use\s+/
1962  ***      0      0      0   if $query =~ /\A\s*UNLOCK TABLES/i
1963  ***      0      0      0   if $query =~ /\A\s*xa\s+(\S+)/i
1965  ***      0      0      0   if ($query =~ /\Aadministrator command:/)
1973  ***      0      0      0   if ($query =~ /\A\s*SHOW\s+/i)
1991  ***      0      0      0   if ($dds)
1993  ***      0      0      0   if $obj
1998  ***      0      0      0   $obj ? :
2015  ***      0      0      0   unless $qp
2023  ***      0      0      0   if $table
2036  ***      0      0      0   if ($args{'generic'}) { }
2038  ***      0      0      0   unless $cmd
2039  ***      0      0      0   $arg ? :
2044  ***      0      0      0   if ($verbs and $verbs =~ /^SHOW/) { }
2059  ***      0      0      0   if ($args{'trf'})
2068  ***     50      0      1   unless $query
2096  ***     50      1      0   unless $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert(?:\s+ignore)?|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s+duplicate\s+key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx or $query =~ s/
                    \A.*?
                    (?:insert(?:\s+ignore)?|replace)\s+
                    (?:.*?\binto)\b(.*?)\s*
                    set\s+(.*?)\s*
                    (?:\blimit\b|on\s+duplicate\s+key.*)?\s*
                    \Z
                 /__insert_to_select_with_set($1, $2);/eisx
2110  ***      0      0      0   $1 =~ /\*/ ? :
2119  ***      0      0      0   if ($join =~ /\bjoin\b/)
2133  ***      0      0      0   if (@cols == @vals) { }
2150  ***      0      0      0   $where ? :
      ***      0      0      0   $limit ? :
2157  ***      0      0      0   unless $query
2158  ***      0      0      0   $query =~ /\A\s*select/i ? :
2165  ***      0      0      0   defined $_ ? :
2213  ***     50      0     26   unless $args{$arg}
2231  ***     50      0      7   if ($stmt =~ s/$slow_log_hd_line//go)
2233  ***      0      0      0   if (@chunks > 1)
2240         100      1      6   unless $stmt =~ /\A#/
2254         100     24      7   if ($line =~ /^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) { }
2256         100      7     17   if (not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o) { }
             100      3     14   elsif (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o) { }
      ***     50      0     14   elsif (not $got_ac and $line =~ /^# (?:administrator command:.*)$/) { }
             100      7      7   elsif ($line =~ /^# +[A-Z][A-Za-z_]+: \S+/) { }
      ***     50      7      0   elsif (not $got_db and my($db) = $line =~ /^use ([^;]+)/) { }
      ***      0      0      0   elsif (not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/) { }
2260  ***     50      0      7   if (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o)
2304  ***     50      0     24   if (not $found_arg and $pos == $len)
2307  ***      0      0      0   if (defined(my $l = &$next_event())) { }
2325  ***     50      0      7   if ($args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/)
2340  ***     50      6      0   if $args{'oktorun'}
2346  ***      0      0      0   defined $_ ? :
2378  ***     50      0      6   unless $args{$arg}
2387  ***      0      0      0   unless $ddl
2388  ***      0      0      0   if (ref $ddl eq 'ARRAY')
2389  ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
2399  ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
2405  ***      0      0      0   if $name
2423  ***      0      0      0   unless $type
2425  ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
2429  ***      0      0      0   if (not $def =~ /NOT NULL/)
2433  ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
2464  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
2478  ***      0      0      0   if ($index)
2481  ***      0      0      0   if (not $best)
2482  ***      0      0      0   if ($index) { }
2495  ***      0      0      0   unless $where
2501  ***      0      0      0   if ($$expl{'possible_keys'}) { }
2505  ***      0      0      0   if ($$expl{'key'})
2525  ***      0      0      0   unless $args{$arg}
2539  ***      0      0      0   if ($EVAL_ERROR)
2543  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
2549  ***      0      0      0   unless $args{'all_privs'}
2556  ***      0      0      0   if ($EVAL_ERROR)
2560  ***      0      0      0   if (not scalar keys %$row)
2571  ***      0      0      0   $EVAL_ERROR ? :
2576  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
2602  ***     50      0    408   if $key =~ /FOREIGN/
2607  ***     50    408      0   if (not $engine =~ /MEMORY|HEAP/)
2614  ***     50      0    408   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
2621         100    252    156   $key =~ /PRIMARY|UNIQUE/ ? :
2645         100     90    318   if ($engine =~ /InnoDB/i and not $clustered_key)
2647  ***     50     90      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
2671  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
2700  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
2710  ***      0      0      0   unless $key_ddl =~ /,$/
2717  ***      0      0      0   if (@sec_indexes)
2734  ***      0      0      0   defined $_ ? :
2788  ***      0      0      0   defined $args{'p_ms'} ? :
2789  ***      0      0      0   defined $args{'p_s'} ? :
2792  ***      0      0      0   if $t < 0
2794  ***      0      0      0   if $t =~ /e/
2798  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
2819  ***      0      0      0   $p ? :
2826  ***      0      0      0   unless $secs
2828  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
2833  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
2852  ***      0      0      0   unless defined $val
2856  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
2857  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
2862  ***      0      0      0   if $prefix and $prefix eq '-'
2872  ***      0      0      0   defined $args{'p'} ? :
2873  ***      0      0      0   defined $args{'d'} ? :
2880  ***      0      0      0   $num =~ /\./ || $n ? :
2889  ***      0      0      0   $gmt ? :
2895  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
2905  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
2908  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
2917  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
2918  ***      0      0      0   $gmt ? :
2921  ***      0      0      0   if (defined $us)
2933  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif ($val =~ /^\d{9,}/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
2934  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
2948  ***      0      0      0   unless $hms
2953  ***      0      0      0   unless $hms
2958  ***      0      0      0   if $callback and ref $callback eq 'CODE'
2974  ***      0      0      0   defined $_ ? :
3012  ***      0      0      0   if (not $$self{$dbh})
3016  ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
3023  ***      0      0      0   defined $_ ? :
3087  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
3089  ***      0      0      0   unless $ddl
3090  ***      0      0      0   if ($$ddl[0] eq 'table') { }
3104  ***      0      0      0   if ($trgs and @$trgs) { }
3107  ***      0      0      0   if ($$trg{'sql_mode'})
3111  ***      0      0      0   if ($$trg{'definer'})
3143  ***     50      0    234   if (not $new)
3155  ***     50    234      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
3168  ***     50      0    234   if ($EVAL_ERROR)
3178  ***     50    234      0   if ($key) { }
3194  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
3224  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
3237  ***      0      0      0   if ($sth->rows)
3250  ***      0      0      0   if ($tbl)
3258  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
3261  ***      0      0      0   if ($like)
3269  ***      0      0      0   unless $like
3277  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
3280  ***      0      0      0   if ($like)
3295  ***      0      0      0   unless $like
3303  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
3306  ***      0      0      0   if ($like)
3314  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
3321  ***      0      0      0   unless $like
3329  ***      0      0      0   defined $_ ? :
3365  ***     50      0      6   unless $args{$arg}
3384  ***     50      0      6   if $o->has('databases')
3386  ***     50      0      6   if $o->has('ignore-databases')
3389  ***     50      0      6   if ($o->has('databases-regex') and my $p = $o->get('databases-regex'))
3393  ***     50      0      6   if ($o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex'))
3397  ***     50      0      6   if (@permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex)
3398  ***      0      0      0   @permit_dbs ? :
      ***      0      0      0   @reject_dbs ? :
      ***      0      0      0   @dbs_regex ? :
      ***      0      0      0   @reject_dbs_regex ? :
3407  ***     50      0      6   if ($o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex'))
3417  ***      0      0      0   if ($o->get('tables'))
3420  ***      0      0      0   if ($_ =~ /\./) { }
3430  ***      0      0      0   if (@permit_qtbls)
3440  ***      0      0      0   if ($o->get('ignore-tables'))
3443  ***      0      0      0   if ($_ =~ /\./) { }
3453  ***      0      0      0   if (@reject_qtbls and not $have_qtbl)
3459  ***      0      0      0   if (keys %permit_qtbls and not @permit_dbs)
3467  ***      0      0      0   if (keys %$dbs)
3474  ***      0      0      0   if ($o->has('tables-regex') and my $p = $o->get('tables-regex'))
3478  ***      0      0      0   if ($o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex'))
3487  ***      0      0      0   if ($o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines'))
3506  ***      0      0      0   if (@permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs)
3508  ***      0      0      0   @permit_tbls ? :
      ***      0      0      0   @reject_tbls ? :
      ***      0      0      0   @tbls_regex ? :
      ***      0      0      0   @reject_tbls_regex ? :
      ***      0      0      0   @permit_qtbls ? :
      ***      0      0      0   @reject_qtbls ? :
      ***      0      0      0   @get_eng ? :
      ***      0      0      0   @permit_engs ? :
      ***      0      0      0   @reject_engs ? :
3529  ***     50      0      6   unless my $filter_sub = eval $code
3546  ***     50      0      6   unless $args{$arg}
3555  ***     50     18      0   $filter ? :
3557         100      6     12   if $_ =~ /information_schema|lost\+found/
3572  ***     50      0     24   unless $args{$arg}
3578  ***     50     12      0   if ($db) { }
3588  ***     50    276      0   $filter ? :
3589  ***     50    276      0   if (not $views)
3590         100     42    234   if ($type || '') eq 'VIEW'
3610  ***      0      0      0   if (scalar keys %$objs)
3611  ***      0      0      0   $lc ? :
3620  ***      0      0      0   defined $_ ? :
3667  ***     50      0      6   if (not defined $fn)
3671  ***     50      6      0   if ($fn ne '-')
3672  ***     50      0      6   if (not -e $fn or not -r $fn)
3680  ***     50      0      6   if (not @filenames)
3690  ***     50      0      6   if ($fn eq '-')
3693  ***     50      0      6   unless open my $fh, '<', $fn
3694  ***     50      6      0   if ($fh)
3704  ***      0      0      0   defined $_ ? :
3740  ***     50      0     12   unless defined $args{$arg}
3751  ***     50      0     12   unless defined $args{$arg}
3754         100      1      5   if (not $sql =~ /^\s*select/i)
3775  ***     50      0      1   if (my($key, $vals) = $var =~ /(Using union)\(([^)]+)\)/) { }
3801  ***     50      0     10   unless defined $args{$arg}
3810  ***     50      0      5   if not defined $$row{'table'} or $$row{'table'} =~ /^<(derived|union)\d/
3829  ***     50      0      6   unless defined $checksum and defined $db
3830  ***     50      0      6   if (exists $$self{'usage'}{$db} and exists $$self{'usage'}{$db}{$checksum}) { }
3842  ***     50      0      5   unless defined $checksum and defined $db
3848  ***      0      0      0   defined $_ ? :
3889  ***     50      0    702   unless $args{$arg}
3905  ***     50      0      5   unless defined $db and defined $tbl
3912  ***     50      0      5   unless defined $args{$arg}
3925  ***     50      0      6   unless $callback
3934         100    229      5   unless $$self{'tables_for'}{$db}{$tbl}
3938         100      8      3   if (not $$indexes{$index}{'cnt'})
3942  ***     50      5      0   if (@unused_indexes)
3958  ***      0      0      0   defined $_ ? :
3994  ***     50      0      6   unless defined $args{$arg}
3996  ***     50      6      0   if (not $args{'report'} or not $args{'interval'})
3997  ***     50      6      0   if ($args{'spec'} and @{$args{'spec'};} == 2) { }
4024  ***     50      6      0   if $_[0] eq 'Progress'
4026  ***     50      0      6   if (@$spec != 2)
4029  ***     50      0      6   if (not $$spec[0] =~ /^(?:percentage|time|iterations)$/)
4033  ***     50      0      6   if (not $$spec[1] =~ /^\d+$/)
4054  ***     50      6      0   if ($$self{'report'} eq 'time' and $$self{'interval'} > $now - $$self{'last_reported'}) { }
      ***      0      0      0   elsif ($$self{'report'} eq 'iterations' and ($$self{'iterations'} - 1) % $$self{'interval'} > 0) { }
4069  ***      0      0      0   if $completed > $jobsize
4071  ***      0      0      0   $completed > 0 ? :
4073  ***      0      0      0   if ($$self{'report'} eq 'percentage' and $self->fraction_modulo($$self{'fraction'}) >= $self->fraction_modulo($fraction))
4085  ***      0      0      0   if ($completed > 0 and $completed <= $jobsize and $elapsed > 0)
4087  ***      0      0      0   if ($rate > 0)
4104  ***      0      0      0   defined $_ ? :
4157  ***     50      0      6   if $o->get('q')
4158  ***     50      6      0   if (not $o->got('help'))
4159  ***     50      6      0   if ($o->get('progress'))
4161  ***     50      0      6   if ($EVAL_ERROR)
4222  ***     50      0    234   if ($EVAL_ERROR)
4223  ***      0      0      0   unless $o->get('q')
4269  ***     50      6      0   if ($o->get('progress') and $filename and -e $filename)
4284  ***     50      0      7   unless my $arg = $$event{'arg'}
4288         100      1      6   if $err_for{$fingerprint}
4298  ***     50      6      0   if ($new_db and $new_db ne $cur_db)
4307  ***     50      6      0   if (not $access)
4332         100      1      5   if ($EVAL_ERROR)
4338  ***     50      1      0   unless $o->get('q')
4340  ***     50      6      0   if $pr
4371  ***     50      0     15   unless $args{$arg}
4381         100      3      5   if ($$idx{'name'} =~ /PRIMARY/i) { }
      ***     50      0      5   elsif ($$idx{'is_unique'}) { }
4393         100      1      4   if $$drop{'primary'} or $$drop{'all'}
4399         100      1      4   if $$drop{'unique'} or $$drop{'all'}
4406  ***     50      5      0   if $$drop{'non-unique'} or $$drop{'all'}
4420  ***     50      0     21   unless $args{$arg}
4424         100      2      5   unless @$idx
4427  ***     50      5      0   $args{'type'} ? :
4439  ***     50      0     18   unless $args{$arg}
4443  ***     50      0      6   if ($o->get('ask-pass'))
4444  ***      0      0      0   $args{'for'} ? :
4455  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
113   ***     66     10     47      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     57      0      0   not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'}
246   ***     66      7      0      7   not $dbh and $tries--
288   ***     33      7      0      0   not $dbh and $EVAL_ERROR
448   ***      0      0      0      0   $db and not $db =~ /^`/
449   ***      0      0      0      0   $tbl and not $tbl =~ /^`/
749          100     24     48     18   $type and $type =~ /[HhAadzm]/
888   ***     33      0      6      0   @ARGV and $ARGV[0] eq '--config'
917   ***     33      0      6      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
924   ***     33      0      6      0   @ARGV and $$self{'strict'}
1038  ***     66     36     30      0   $val and $$opt{'type'} eq 'm'
      ***     66     36     30      0   $val and $$opt{'type'} eq 'd'
      ***     66     36     30      0   $val and $$opt{'type'} eq 'z'
      ***     66     36     24      0   defined $val and $$opt{'type'} eq 'h'
             100     36     12      6   defined $val and $$opt{'type'} eq 'a'
1099  ***     33      0      0    102   $long and exists $$self{'opts'}{$long}
1107  ***     33      0      0     30   $long and exists $$self{'opts'}{$long}
1121  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1211  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1305  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1463  ***      0      0      0      0   $ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i
1606  ***      0      0      0      0   $statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i
1884  ***      0      0      0      0   $length > 0 and $query_length > $length
      ***      0      0      0      0   $length > 0 and $query_length > $length and $query_length < ($last_length || $query_length + 1)
2044  ***      0      0      0      0   $verbs and $verbs =~ /^SHOW/
2256  ***     66     17      0      7   not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o
             100      6      8      3   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
      ***     33      0     14      0   not $got_ac and $line =~ /^# (?:administrator command:.*)$/
      ***     33      0      0      7   not $got_db and my($db) = $line =~ /^use ([^;]+)/
      ***      0      0      0      0   not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/
2260  ***     33      0      7      0   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
2304  ***     33      0     24      0   not $found_arg and $pos == $len
2325  ***     33      0      7      0   $args{'misc'} and $args{'misc'}{'embed'}
      ***     33      7      0      0   $args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/
2576  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
2614  ***     33    408      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33    408      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
2645         100    174    144     90   $engine =~ /InnoDB/i and not $clustered_key
2647  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
2671  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
2798  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
2862  ***      0      0      0      0   $prefix and $prefix eq '-'
2876  ***      0      0      0      0   $num >= $d and $n < @units - 1
2958  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
3104  ***      0      0      0      0   $trgs and @$trgs
3389  ***     33      6      0      0   $o->has('databases-regex') and my $p = $o->get('databases-regex')
3393  ***     33      6      0      0   $o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex')
3453  ***      0      0      0      0   @reject_qtbls and not $have_qtbl
3459  ***      0      0      0      0   keys %permit_qtbls and not @permit_dbs
3474  ***      0      0      0      0   $o->has('tables-regex') and my $p = $o->get('tables-regex')
3478  ***      0      0      0      0   $o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex')
3487  ***      0      0      0      0   $o->has('engines') and $o->get('engines')
      ***      0      0      0      0   $o->has('ignore-engines') and $o->get('ignore-engines')
3829  ***     33      0      0      6   defined $checksum and defined $db
3830  ***     33      6      0      0   exists $$self{'usage'}{$db} and exists $$self{'usage'}{$db}{$checksum}
3842  ***     33      0      0      5   defined $checksum and defined $db
3905  ***     33      0      0      5   defined $db and defined $tbl
3997  ***     33      0      0      6   $args{'spec'} and @{$args{'spec'};} == 2
4054  ***     33      0      0      6   $$self{'report'} eq 'time' and $$self{'interval'} > $now - $$self{'last_reported'}
      ***      0      0      0      0   $$self{'report'} eq 'iterations' and ($$self{'iterations'} - 1) % $$self{'interval'} > 0
4073  ***      0      0      0      0   $$self{'report'} eq 'percentage' and $self->fraction_modulo($$self{'fraction'}) >= $self->fraction_modulo($fraction)
4085  ***      0      0      0      0   $completed > 0 and $completed <= $jobsize
      ***      0      0      0      0   $completed > 0 and $completed <= $jobsize and $elapsed > 0
4269  ***     33      0      0      6   $o->get('progress') and $filename
      ***     33      0      0      6   $o->get('progress') and $filename and -e $filename
4298  ***     33      0      0      6   $new_db and $new_db ne $cur_db

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
49    ***     50      0      1   $ENV{'MKDEBUG'} || 0
69    ***     50     57      0   $$opt{'copy'} || 0
94    ***     50      0      7   $prev ||= {}
95    ***     50      0      7   $defaults ||= {}
175   ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
188   ***     50      0      7   $self->prop('dbidriver') || ''
192   ***      0      0      0   $$info{'D'} || ''
198   ***     50      0      7   $$info{'D'} || ''
220          100      1      6   $opts ||= {}
325   ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
341   ***      0      0      0   $level ||= 0
342   ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
396   ***     50      0      1   $ENV{'MKDEBUG'} || 0
476   ***     50      0      1   $ENV{'MKDEBUG'} || 0
487   ***     50     12      0   $program_name ||= $PROGRAM_NAME
488   ***     50     12      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
549   ***     50      0      6   $file ||= '/home/daniel/dev/maatkit/mk-index-usage/mk-index-usage'
614   ***     50     12      0   $file ||= '/home/daniel/dev/maatkit/mk-index-usage/mk-index-usage'
738   ***     50     90      0   $$opt{'group'} ||= 'default'
1043  ***      0      0      0   $s || 's'
1052  ***      0      0      0   $prefix || ''
1082  ***     50      6      0   $val || ''
1085  ***     50     12      0   $val || ''
1144  ***      0      0      0   $$self{'description'} || ''
1213  ***      0      0      0   $s ||= 's'
1239  ***      0      0      0   $$opt{'type'} || ''
1366  ***      0      0      0   $val || ''
1380  ***      0      0      0   $pre || ''
1426  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1668  ***      0      0      0   $word =~ tr/(// || 0
1669  ***      0      0      0   $word =~ tr/)// || 0
1830  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2187  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2371  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2590  ***     50    234      0   $engine || undef
2613         100      6    402   $type || $special || 'BTREE'
2700  ***      0      0      0   $$tbl_struct{'engine'} || ''
2702  ***      0      0      0   $clustered_key ||= ''
2763  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2818  ***      0      0      0   $args{'p'} || 0
2820  ***      0      0      0   $of ||= 1
2825  ***      0      0      0   $secs ||= 0
2855  ***      0      0      0   $suffix || $default_suffix || 's'
2996  ***     50      0      1   $ENV{'MKDEBUG'} || 0
3050  ***     50      0      1   $ENV{'MKDEBUG'} || 0
3314  ***      0      0      0   $$_[1] || ''
3360  ***     50      0      1   $ENV{'MKDEBUG'} || 0
3590  ***     50    276      0   $type || ''
3651  ***     50      0      1   $ENV{'MKDEBUG'} || 0
3726  ***     50      0      1   $ENV{'MKDEBUG'} || 0
3768         100     10     10   $$row{$col} || ''
3873  ***     50      0      1   $ENV{'MKDEBUG'} || 0
3989  ***     50      0      1   $ENV{'MKDEBUG'} || 0
4005  ***     50      6      0   $args{'name'} || 'Progress'
4006  ***     50      0      6   $args{'start'} ||= time
4051  ***     50      0      6   $now ||= time
4131  ***     50      0      1   $ENV{'MKDEBUG'} || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
60    ***     33      0      0     57   not $$opt{'key'} or not $$opt{'desc'}
211   ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
212   ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
213   ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
214   ***      0      0      0      0   $$dsn{'u'} ||= $user
215   ***      0      0      0      0   $$dsn{'D'} ||= $db
488   ***     33     12      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     12      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
1038  ***     66      6      0     60   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
             100      6      6     48   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1572  ***     33      0      5      0   $alias or $tbl
1697  ***      0      0      0      0   $type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/
1778  ***      0      0      0      0   $$self{'Quoter'} || $args{'Quoter'}
1787  ***      0      0      0      0   $db || $default_db
1884  ***      0      0      0      0   $last_length || $query_length + 1
2014  ***      0      0      0      0   $args{'QueryParser'} || $$self{'QueryParser'}
2096  ***     33      0      0      1   $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert(?:\s+ignore)?|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s+duplicate\s+key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
      ***     33      0      0      1   $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert(?:\s+ignore)?|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s+duplicate\s+key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx or $query =~ s/
                    \A.*?
                    (?:insert(?:\s+ignore)?|replace)\s+
                    (?:.*?\binto)\b(.*?)\s*
                    set\s+(.*?)\s*
                    (?:\blimit\b|on\s+duplicate\s+key.*)?\s*
                    \Z
                 /__insert_to_select_with_set($1, $2);/eisx
2224  ***     66      0      7      6   defined($stmt = shift @$pending) or defined($stmt = &$next_event())
2464  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
2543  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
2564  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
2613  ***     66      0      6    402   $type || $special
2828  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
2855  ***      0      0      0      0   $suffix || $default_suffix
2880  ***      0      0      0      0   $num =~ /\./ || $n
3155  ***     33    234      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
3194  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
3224  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
3258  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
3277  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
3291  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
3303  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
3397  ***     33      0      0      6   @permit_dbs or @reject_dbs
      ***     33      0      0      6   @permit_dbs or @reject_dbs or @dbs_regex
      ***     33      0      0      6   @permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex
3407  ***     33      0      0      6   $o->has('tables') or $o->has('ignore-tables')
      ***     33      0      0      6   $o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex')
3487  ***      0      0      0      0   $o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines')
3506  ***      0      0      0      0   @permit_tbls or @reject_tbls
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs
3672  ***     33      0      0      6   not -e $fn or not -r $fn
3810  ***     33      0      0      5   not defined $$row{'table'} or $$row{'table'} =~ /^<(derived|union)\d/
3813  ***     33      5      0      0   $$lookup{'TABLE'}{$$row{'table'}} || $$row{'table'}
3814  ***     66      1      4      0   $$lookup{'DATABASE'}{$table} || $args{'db'}
3996  ***     33      6      0      0   not $args{'report'} or not $args{'interval'}
4045  ***      0      0      0      0   $start || time
4297  ***     33      6      0      0   $$event{'db'} || $$event{'Schema'}
4393  ***     66      0      1      4   $$drop{'primary'} or $$drop{'all'}
4399  ***     66      0      1      4   $$drop{'unique'} or $$drop{'all'}
4406  ***     66      4      1      0   $$drop{'non-unique'} or $$drop{'all'}


Covered Subroutines
-------------------

Subroutine                  Count Location                                                   
--------------------------- ----- -----------------------------------------------------------
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1422
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1423
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1424
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1426
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1823
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1824
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1828
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1830
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:20  
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:21  
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2182
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2183
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2184
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2185
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2187
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2363
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2364
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2365
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2366
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2371
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2757
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2758
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2759
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2760
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2761
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2763
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2991
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2992
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2994
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2996
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3045
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3046
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3048
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3050
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3351
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3352
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3354
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3355
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3360
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3642
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3643
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3645
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3646
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3651
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:37  
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3726
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3727
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3728
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3730
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3731
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:38  
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3870
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3871
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3872
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3873
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:39  
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:392 
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:393 
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:394 
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:396 
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3980
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3981
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3983
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3984
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3989
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:40  
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4126
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4127
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4131
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:469 
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:470 
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:472 
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:473 
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:474 
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:476 
BEGIN                           1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:49  
DSNParser                       6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:603 
__ANON__                       18 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3564
__ANON__                      246 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3603
__ANON__                       12 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3687
__ANON__                       13 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4250
__ANON__                       20 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4251
__ANON__                       13 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4259
__ANON__                        5 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4351
__ANON__                       48 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:563 
__ANON__                        7 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:912 
_check_opts                     6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:955 
_parse_attribs                 90 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1389
_parse_specs                    6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:702 
_pod_to_specs                  12 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:613 
_read_config_file              24 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1288
_set_option                     7 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:858 
_use_db                       234 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3142
_validate_type                 90 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1028
add_index_usage                 5 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3910
add_indexes                   234 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3886
add_table_usage                 5 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3904
convert_to_select               1 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2067
explain_query                   6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3749
find_unused_indexes             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3924
fingerprint                     7 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1916
get                           102 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1097
get_aliases                     5 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1515
get_alternate_indexes           5 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3793
get_create_table              234 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3154
get_cxn                         6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4436
get_cxn_params                  7 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:185 
get_db_itr                      6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3543
get_dbh                         7 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:219 
get_defaults_files              6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:608 
get_engine                    234 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2587
get_file_itr                    6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3662
get_index_usage                 5 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3799
get_keys                      234 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2594
get_opts                        6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:875 
get_specs                       6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:548 
get_tbl_itr                    12 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3569
get_usage_for                   6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3828
got                            30 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1105
has                            96 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1113
main                            6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4140
make_checksum                  12 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2966
make_filter                     6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3376
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1446
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1853
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2190
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2375
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2999
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3077
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3363
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3654
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3738
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3876
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:399 
new                             6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3992
new                            12 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:481 
new                             7 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:52  
normalize                       5 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3761
parse                           6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3004
parse                           7 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:88  
parse_event                    13 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2210
parse_options                   6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:144 
print_alter_drop_key            7 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4417
print_unused_indexes            5 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4368
prop                           33 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:79  
quote                         497 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:404 
save_usage_for                  5 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3841
set_filter                      6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3536
trim_identifier                15 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1793
update                          6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4049
usage_or_errors                 6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1155
validate_spec                   6 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4024

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                                   
--------------------------- ----- -----------------------------------------------------------
__ANON__                        0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4012
__delete_to_select              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2118
__distill_tables                0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2013
__insert_to_select              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2126
__insert_to_select_with_set     0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2143
__shorten                       0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1904
__update_to_select              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2149
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1399
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1802
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2164
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2345
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2733
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2973
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3022
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3328
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3619
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:369 
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3703
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3847
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3957
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4103
_d                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4454
_get_participants               0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:812 
_make_filter                    0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3608
_parse_size                     0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1364
any_unix_timestamp              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2931
as_string                       0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:157 
check_table                     0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2522
clean_query                     0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1617
clone                           0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1341
convert_select_list             0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2109
copy                            0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:351 
descr                           0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1143
disconnect                      0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:334 
distill                         0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2034
distill_verbs                   0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1958
dump                            0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3085
errors                          0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1133
extract_tables                  0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1775
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:207 
find_best_index                 0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2476
find_possible_keys              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2494
fraction_modulo                 0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4096
get_columns                     0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1712
get_columns                     0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3192
get_databases                   0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3257
get_defaults                    0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:848 
get_fks                         0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2661
get_groups                      0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:853 
get_hostname                    0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:324 
get_table_list                  0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3302
get_table_status                0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3276
get_tables                      0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1451
get_tmp_table                   0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3212
get_triggers                    0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3223
has_derived_table               0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1508
join_quote                      0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:441 
literal_like                    0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:434 
micro_t                         0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2787
opts                            0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:824 
parse                           0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1754
parse                           0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2386
parse_timestamp                 0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2904
percentage_of                   0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2817
print_active_handles            0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:340 
print_errors                    0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1168
print_usage                     0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1178
prompt                          0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1138
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1253
query_type                      0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1694
quote_val                       0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:412 
read_para_after                 0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1322
remove_auto_increment           0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2690
remove_secondary_indexes        0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2696
save_error                      0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1128
secs_to_time                    0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2824
set                             0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1119
set_callback                    0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4039
set_defaults                    0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:836 
short_opts                      0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:830 
shorten                         0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1870
shorten                         0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2871
sort_indexes                    0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2457
split                           0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1589
split_subquery                  0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1627
split_unquote                   0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:423 
start                           0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:4044
strip_comments                  0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:1859
time_to_secs                    0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2851
ts                              0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2888
unix_timestamp                  0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2916
usage                           0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:168 
version_ge                      0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:3011
wrap_in_derived                 0 /home/daniel/dev/maatkit/mk-index-usage/mk-index-usage:2156


