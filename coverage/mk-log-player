---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...-log-player/mk-log-player   14.5    2.1    6.6   41.7    n/a  100.0   11.8
Total                          14.5    2.1    6.6   41.7    n/a  100.0   11.8
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:23:59 2010
Finish:       Thu Jan 28 22:23:59 2010

Run:          ./101_split.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:00 2010
Finish:       Thu Jan 28 22:24:01 2010

Run:          ./102_play.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:04 2010
Finish:       Thu Jan 28 22:24:05 2010

Run:          ./104_split_random.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:07 2010
Finish:       Thu Jan 28 22:24:08 2010

Run:          ./105_filter.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:10 2010
Finish:       Thu Jan 28 22:24:10 2010

Run:          ./106_option_sanity.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:13 2010
Finish:       Thu Jan 28 22:24:14 2010

Run:          ./107_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:16 2010
Finish:       Thu Jan 28 22:24:16 2010

Run:          ./201_issue_799.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:24:19 2010
Finish:       Thu Jan 28 22:24:19 2010

/home/daniel/dev/maatkit/mk-log-player/mk-log-player

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2008-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             7                    7            45   use strict;
               7                                 17   
               7                                 53   
21             7                    7            45   use warnings FATAL => 'all';
               7                                 23   
               7                                 50   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5458 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # OptionParser package 5266
29                                                    # ###########################################################################
30                                                    package OptionParser;
31                                                    
32             7                    7            44   use strict;
               7                                 21   
               7                                 35   
33             7                    7            42   use warnings FATAL => 'all';
               7                                 19   
               7                                 28   
34                                                    
35             7                    7            66   use Getopt::Long;
               7                                 25   
               7                                 47   
36             7                    7            52   use List::Util qw(max);
               7                                 17   
               7                                 77   
37             7                    7            45   use English qw(-no_match_vars);
               7                                 17   
               7                                 47   
38                                                    
39    ***      7            50      7            46   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 24   
               7                                104   
40                                                    
41                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
42                                                    
43                                                    my %attributes = (
44                                                       'type'       => 1,
45                                                       'short form' => 1,
46                                                       'group'      => 1,
47                                                       'default'    => 1,
48                                                       'cumulative' => 1,
49                                                       'negatable'  => 1,
50                                                    );
51                                                    
52                                                    sub new {
53    ***      0                    0             0      my ( $class, %args ) = @_;
54    ***      0                                  0      foreach my $arg ( qw(description) ) {
55    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
56                                                       }
57    ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
58    ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
59    ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
60                                                    
61    ***      0      0      0                    0      my $self = {
      ***                    0                        
62                                                          description    => $args{description},
63                                                          prompt         => $args{prompt} || '<options>',
64                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
65                                                          dp             => $args{dp}     || undef,
66                                                          program_name   => $program_name,
67                                                          opts           => {},
68                                                          got_opts       => 0,
69                                                          short_opts     => {},
70                                                          defaults       => {},
71                                                          groups         => {},
72                                                          allowed_groups => {},
73                                                          errors         => [],
74                                                          rules          => [],  # desc of rules for --help
75                                                          mutex          => [],  # rule: opts are mutually exclusive
76                                                          atleast1       => [],  # rule: at least one opt is required
77                                                          disables       => {},  # rule: opt disables other opts 
78                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
79                                                          default_files  => [
80                                                             "/etc/maatkit/maatkit.conf",
81                                                             "/etc/maatkit/$program_name.conf",
82                                                             "$home/.maatkit.conf",
83                                                             "$home/.$program_name.conf",
84                                                          ],
85                                                       };
86    ***      0                                  0      return bless $self, $class;
87                                                    }
88                                                    
89                                                    sub get_specs {
90    ***      0                    0             0      my ( $self, $file ) = @_;
91    ***      0                                  0      my @specs = $self->_pod_to_specs($file);
92    ***      0                                  0      $self->_parse_specs(@specs);
93    ***      0                                  0      return;
94                                                    }
95                                                    
96                                                    sub get_defaults_files {
97    ***      0                    0             0      my ( $self ) = @_;
98    ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
99                                                    }
100                                                   
101                                                   sub _pod_to_specs {
102   ***      0                    0             0      my ( $self, $file ) = @_;
103   ***      0             0                    0      $file ||= __FILE__;
104   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
105                                                   
106   ***      0                                  0      my %types = (
107                                                         string => 's', # standard Getopt type
108                                                         'int'  => 'i', # standard Getopt type
109                                                         float  => 'f', # standard Getopt type
110                                                         Hash   => 'H', # hash, formed from a comma-separated list
111                                                         hash   => 'h', # hash as above, but only if a value is given
112                                                         Array  => 'A', # array, similar to Hash
113                                                         array  => 'a', # array, similar to hash
114                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
115                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
116                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
117                                                      );
118   ***      0                                  0      my @specs = ();
119   ***      0                                  0      my @rules = ();
120   ***      0                                  0      my $para;
121                                                   
122   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
123   ***      0                                  0      while ( $para = <$fh> ) {
124   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
125   ***      0                                  0         last;
126                                                      }
127                                                   
128   ***      0                                  0      while ( $para = <$fh> ) {
129   ***      0      0                           0         last if $para =~ m/^=over/;
130   ***      0                                  0         chomp $para;
131   ***      0                                  0         $para =~ s/\s+/ /g;
132   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
133   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
134   ***      0                                  0         push @rules, $para;
135                                                      }
136                                                   
137   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
138                                                   
139   ***      0                                  0      do {
140   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
141   ***      0                                  0            chomp $para;
142   ***      0                                  0            MKDEBUG && _d($para);
143   ***      0                                  0            my %attribs;
144                                                   
145   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
146                                                   
147   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
148   ***      0                                  0               $para =~ s/\s+\Z//g;
149   ***      0                                  0               %attribs = map {
150   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
151   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
152                                                                        unless $attributes{$attrib};
153   ***      0                                  0                     ($attrib, $val);
154                                                                  } split(/; /, $para);
155   ***      0      0                           0               if ( $attribs{'short form'} ) {
156   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
157                                                               }
158   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
159                                                            }
160                                                            else {
161   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
162                                                            }
163                                                   
164   ***      0                                  0            $para =~ s/\s+\Z//g;
165   ***      0                                  0            $para =~ s/\s+/ /g;
166   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
167                                                   
168   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
169   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
170                                                   
171   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
172                                                   
173   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
174   ***      0                                  0               $option = $base_option;
175   ***      0                                  0               $attribs{'negatable'} = 1;
176                                                            }
177                                                   
178   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
179                                                               spec  => $option
180                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
181                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
182                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
183                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
184                                                               desc  => $para
185                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
186                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
187                                                            };
188                                                         }
189   ***      0                                  0         while ( $para = <$fh> ) {
190   ***      0      0                           0            last unless $para;
191                                                   
192                                                   
193   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
194   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
195   ***      0                                  0               last;
196                                                            }
197   ***      0      0                           0            last if $para =~ m/^=item --/;
198                                                         }
199                                                      } while ( $para );
200                                                   
201   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
202                                                   
203   ***      0                                  0      close $fh;
204   ***      0                                  0      return @specs, @rules;
205                                                   }
206                                                   
207                                                   sub _parse_specs {
208   ***      0                    0             0      my ( $self, @specs ) = @_;
209   ***      0                                  0      my %disables; # special rule that requires deferred checking
210                                                   
211   ***      0                                  0      foreach my $opt ( @specs ) {
212   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
213                                                            MKDEBUG && _d('Parsing opt spec:',
214   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
215                                                   
216   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
217   ***      0      0                           0            if ( !$long ) {
218   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
219                                                            }
220   ***      0                                  0            $opt->{long} = $long;
221                                                   
222   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
223   ***      0                                  0            $self->{opts}->{$long} = $opt;
224                                                   
225   ***      0      0                           0            if ( length $long == 1 ) {
226   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
227   ***      0                                  0               $self->{short_opts}->{$long} = $long;
228                                                            }
229                                                   
230   ***      0      0                           0            if ( $short ) {
231   ***      0      0                           0               die "Duplicate short option -$short"
232                                                                  if exists $self->{short_opts}->{$short};
233   ***      0                                  0               $self->{short_opts}->{$short} = $long;
234   ***      0                                  0               $opt->{short} = $short;
235                                                            }
236                                                            else {
237   ***      0                                  0               $opt->{short} = undef;
238                                                            }
239                                                   
240   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
241   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
242   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
243                                                   
244   ***      0             0                    0            $opt->{group} ||= 'default';
245   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
246                                                   
247   ***      0                                  0            $opt->{value} = undef;
248   ***      0                                  0            $opt->{got}   = 0;
249                                                   
250   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
251   ***      0                                  0            $opt->{type} = $type;
252   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
253                                                   
254   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
255   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
256                                                                  . "was given when this OptionParser object was created";
257                                                            }
258                                                   
259   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
260                                                   
261   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
262   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
263   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
264                                                            }
265                                                   
266   ***      0      0                           0            if ( $long eq 'config' ) {
267   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
268                                                            }
269                                                   
270   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
271   ***      0                                  0               $disables{$long} = $dis;
272   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
273                                                            }
274                                                   
275   ***      0                                  0            $self->{opts}->{$long} = $opt;
276                                                         }
277                                                         else { # It's an option rule, not a spec.
278   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
279   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
280   ***      0                                  0            my @participants = $self->_get_participants($opt);
281   ***      0                                  0            my $rule_ok = 0;
282                                                   
283   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
284   ***      0                                  0               $rule_ok = 1;
285   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
286   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
287                                                            }
288   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
289   ***      0                                  0               $rule_ok = 1;
290   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
291   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
292                                                            }
293   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
294   ***      0                                  0               $rule_ok = 1;
295   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
296   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
297                                                            }
298   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
299   ***      0                                  0               $rule_ok = 1;
300   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
301   ***      0                                  0               my @groups = split(',', $groups);
302   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
303   ***      0                                  0                  s/\s+//;
304   ***      0                                  0                  $_ => 1;
305                                                               } @groups;
306                                                            }
307                                                   
308   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
309                                                         }
310                                                      }
311                                                   
312   ***      0                                  0      foreach my $long ( keys %disables ) {
313   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
314   ***      0                                  0         $self->{disables}->{$long} = \@participants;
315   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
316                                                      }
317                                                   
318   ***      0                                  0      return; 
319                                                   }
320                                                   
321                                                   sub _get_participants {
322   ***      0                    0             0      my ( $self, $str ) = @_;
323   ***      0                                  0      my @participants;
324   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
325   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
326                                                            unless exists $self->{opts}->{$long};
327   ***      0                                  0         push @participants, $long;
328                                                      }
329   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
330   ***      0                                  0      return @participants;
331                                                   }
332                                                   
333                                                   sub opts {
334   ***      0                    0             0      my ( $self ) = @_;
335   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
336   ***      0                                  0      return %opts;
337                                                   }
338                                                   
339                                                   sub short_opts {
340   ***      0                    0             0      my ( $self ) = @_;
341   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
342   ***      0                                  0      return %short_opts;
343                                                   }
344                                                   
345                                                   sub set_defaults {
346   ***      0                    0             0      my ( $self, %defaults ) = @_;
347   ***      0                                  0      $self->{defaults} = {};
348   ***      0                                  0      foreach my $long ( keys %defaults ) {
349   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
350                                                            unless exists $self->{opts}->{$long};
351   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
352   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
353                                                      }
354   ***      0                                  0      return;
355                                                   }
356                                                   
357                                                   sub get_defaults {
358   ***      0                    0             0      my ( $self ) = @_;
359   ***      0                                  0      return $self->{defaults};
360                                                   }
361                                                   
362                                                   sub get_groups {
363   ***      0                    0             0      my ( $self ) = @_;
364   ***      0                                  0      return $self->{groups};
365                                                   }
366                                                   
367                                                   sub _set_option {
368   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
369   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
370                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
371                                                               : die "Getopt::Long gave a nonexistent option: $opt";
372                                                   
373   ***      0                                  0      $opt = $self->{opts}->{$long};
374   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
375   ***      0                                  0         $opt->{value}++;
376                                                      }
377                                                      else {
378   ***      0                                  0         $opt->{value} = $val;
379                                                      }
380   ***      0                                  0      $opt->{got} = 1;
381   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
382                                                   }
383                                                   
384                                                   sub get_opts {
385   ***      0                    0             0      my ( $self ) = @_; 
386                                                   
387   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
388   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
389   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
390                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
391                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
392                                                            : undef;
393                                                      }
394   ***      0                                  0      $self->{got_opts} = 0;
395                                                   
396   ***      0                                  0      $self->{errors} = [];
397                                                   
398   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
399   ***      0                                  0         shift @ARGV;
400   ***      0                                  0         $self->_set_option('config', shift @ARGV);
401                                                      }
402   ***      0      0                           0      if ( $self->has('config') ) {
403   ***      0                                  0         my @extra_args;
404   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
405   ***      0                                  0            eval {
406   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
407                                                            };
408   ***      0      0                           0            if ( $EVAL_ERROR ) {
409   ***      0      0                           0               if ( $self->got('config') ) {
410   ***      0                                  0                  die $EVAL_ERROR;
411                                                               }
412                                                               elsif ( MKDEBUG ) {
413                                                                  _d($EVAL_ERROR);
414                                                               }
415                                                            }
416                                                         }
417   ***      0                                  0         unshift @ARGV, @extra_args;
418                                                      }
419                                                   
420   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
421                                                      GetOptions(
422   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
423   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
424   ***      0      0                           0         values %{$self->{opts}}
425                                                      ) or $self->save_error('Error parsing options');
426                                                   
427   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
428   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
429                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
430                                                               or die "Cannot print: $OS_ERROR";
431   ***      0                                  0         exit 0;
432                                                      }
433                                                   
434   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
435   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
436                                                      }
437                                                   
438   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
439   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
440   ***      0      0                           0         if ( @set > 1 ) {
441   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
442   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
443                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
444                                                                    . ' are mutually exclusive.';
445   ***      0                                  0            $self->save_error($err);
446                                                         }
447                                                      }
448                                                   
449   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
450   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
451   ***      0      0                           0         if ( @set == 0 ) {
452   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
453   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
454                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
455   ***      0                                  0            $self->save_error("Specify at least one of $err");
456                                                         }
457                                                      }
458                                                   
459   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
460   ***      0                                  0         my $opt = $self->{opts}->{$long};
461   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
462   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
463   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
464   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
465   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
466                                                                  'because', $long,'disables them');
467                                                            }
468                                                   
469   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
470                                                   
471   ***      0                                  0               my @restricted_groups = grep {
472   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
473   ***      0                                  0               } keys %{$self->{groups}};
474                                                   
475   ***      0                                  0               my @restricted_opts;
476   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
477   ***      0                                  0                  RESTRICTED_OPT:
478   ***      0                                  0                  foreach my $restricted_opt (
479                                                                     keys %{$self->{groups}->{$restricted_group}} )
480                                                                  {
481   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
482   ***      0      0                           0                     push @restricted_opts, $restricted_opt
483                                                                        if $self->{opts}->{$restricted_opt}->{got};
484                                                                  }
485                                                               }
486                                                   
487   ***      0      0                           0               if ( @restricted_opts ) {
488   ***      0                                  0                  my $err;
489   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
490   ***      0                                  0                     $err = "--$restricted_opts[0]";
491                                                                  }
492                                                                  else {
493   ***      0                                  0                     $err = join(', ',
494   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
495   ***      0                                  0                               grep { $_ } 
496                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
497                                                                            )
498                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
499                                                                  }
500   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
501                                                               }
502                                                            }
503                                                   
504                                                         }
505                                                         elsif ( $opt->{is_required} ) { 
506   ***      0                                  0            $self->save_error("Required option --$long must be specified");
507                                                         }
508                                                   
509   ***      0                                  0         $self->_validate_type($opt);
510                                                      }
511                                                   
512   ***      0                                  0      $self->{got_opts} = 1;
513   ***      0                                  0      return;
514                                                   }
515                                                   
516                                                   sub _validate_type {
517   ***      0                    0             0      my ( $self, $opt ) = @_;
518   ***      0      0      0                    0      return unless $opt && $opt->{type};
519   ***      0                                  0      my $val = $opt->{value};
520                                                   
521   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
522   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
523   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
524   ***      0      0                           0         if ( !$suffix ) {
525   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
526   ***      0             0                    0            $suffix = $s || 's';
527   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
528                                                               $opt->{long}, '(value:', $val, ')');
529                                                         }
530   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
531   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
532                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
533                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
534                                                                 :                  $num * 86400;   # Days
535   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
536   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
537                                                         }
538                                                         else {
539   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
540                                                         }
541                                                      }
542                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
543   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
544   ***      0                                  0         my $prev = {};
545   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
546   ***      0      0                           0         if ( $from_key ) {
547   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
548   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
549                                                         }
550   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
551   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
552                                                      }
553                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
554   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
555   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
556   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
557   ***      0      0                           0         if ( defined $num ) {
558   ***      0      0                           0            if ( $factor ) {
559   ***      0                                  0               $num *= $factor_for{$factor};
560   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
561                                                                  'to num', $num, '* factor', $factor);
562                                                            }
563   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
564                                                         }
565                                                         else {
566   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
567                                                         }
568                                                      }
569                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
570   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
571                                                      }
572                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
573   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
574                                                      }
575                                                      else {
576   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
577                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
578                                                      }
579                                                   
580   ***      0                                  0      return;
581                                                   }
582                                                   
583                                                   sub get {
584   ***      0                    0             0      my ( $self, $opt ) = @_;
585   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
586   ***      0      0      0                    0      die "Option $opt does not exist"
587                                                         unless $long && exists $self->{opts}->{$long};
588   ***      0                                  0      return $self->{opts}->{$long}->{value};
589                                                   }
590                                                   
591                                                   sub got {
592   ***      0                    0             0      my ( $self, $opt ) = @_;
593   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
594   ***      0      0      0                    0      die "Option $opt does not exist"
595                                                         unless $long && exists $self->{opts}->{$long};
596   ***      0                                  0      return $self->{opts}->{$long}->{got};
597                                                   }
598                                                   
599                                                   sub has {
600   ***      0                    0             0      my ( $self, $opt ) = @_;
601   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
602   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
603                                                   }
604                                                   
605                                                   sub set {
606   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
607   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
608   ***      0      0      0                    0      die "Option $opt does not exist"
609                                                         unless $long && exists $self->{opts}->{$long};
610   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
611   ***      0                                  0      return;
612                                                   }
613                                                   
614                                                   sub save_error {
615   ***      0                    0             0      my ( $self, $error ) = @_;
616   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
617                                                   }
618                                                   
619                                                   sub errors {
620   ***      0                    0             0      my ( $self ) = @_;
621   ***      0                                  0      return $self->{errors};
622                                                   }
623                                                   
624                                                   sub prompt {
625   ***      0                    0             0      my ( $self ) = @_;
626   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
627                                                   }
628                                                   
629                                                   sub descr {
630   ***      0                    0             0      my ( $self ) = @_;
631   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
632                                                                 . "  For more details, please use the --help option, "
633                                                                 . "or try 'perldoc $PROGRAM_NAME' "
634                                                                 . "for complete documentation.";
635   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
636   ***      0                                  0      $descr =~ s/ +$//mg;
637   ***      0                                  0      return $descr;
638                                                   }
639                                                   
640                                                   sub usage_or_errors {
641   ***      0                    0             0      my ( $self ) = @_;
642   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
643   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
644   ***      0                                  0         exit 0;
645                                                      }
646                                                      elsif ( scalar @{$self->{errors}} ) {
647   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
648   ***      0                                  0         exit 0;
649                                                      }
650   ***      0                                  0      return;
651                                                   }
652                                                   
653                                                   sub print_errors {
654   ***      0                    0             0      my ( $self ) = @_;
655   ***      0                                  0      my $usage = $self->prompt() . "\n";
656   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
657   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
658                                                                 . "\n";
659                                                      }
660   ***      0                                  0      return $usage . "\n" . $self->descr();
661                                                   }
662                                                   
663                                                   sub print_usage {
664   ***      0                    0             0      my ( $self ) = @_;
665   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
666   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
667                                                   
668   ***      0      0                           0      my $maxl = max(
669   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
670                                                         @opts);
671                                                   
672   ***      0      0                           0      my $maxs = max(0,
673   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
674   ***      0                                  0         values %{$self->{short_opts}});
675                                                   
676   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
677   ***      0                                  0      my $rcol = 80 - $lcol - 6;
678   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
679                                                   
680   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
681                                                   
682   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
683                                                   
684   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
685   ***      0                                  0      push @groups, 'default';
686                                                   
687   ***      0                                  0      foreach my $group ( reverse @groups ) {
688   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
689   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
690   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
691                                                            grep { $_->{group} eq $group }
692                                                            @opts )
693                                                         {
694   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
695   ***      0                                  0            my $short = $opt->{short};
696   ***      0                                  0            my $desc  = $opt->{desc};
697   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
698   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
699   ***      0             0                    0               $s    ||= 's';
700   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
701   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
702                                                                      . "d=days; if no suffix, $s is used.";
703                                                            }
704   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
705   ***      0                                  0            $desc =~ s/ +$//mg;
706   ***      0      0                           0            if ( $short ) {
707   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
708                                                            }
709                                                            else {
710   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
711                                                            }
712                                                         }
713                                                      }
714                                                   
715   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
716   ***      0                                  0         $usage .= "\nRules:\n\n";
717   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
718                                                      }
719   ***      0      0                           0      if ( $self->{dp} ) {
720   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
721                                                      }
722   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
723   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
724   ***      0                                  0         my $val   = $opt->{value};
725   ***      0             0                    0         my $type  = $opt->{type} || '';
726   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
727   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
728                                                                   : !defined $val             ? '(No value)'
729                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
730                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
731                                                                   : $type =~ m/A|a/           ? join(',', @$val)
732                                                                   :                             $val;
733   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
734                                                      }
735   ***      0                                  0      return $usage;
736                                                   }
737                                                   
738                                                   sub prompt_noecho {
739   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
740   ***      0                                  0      my ( $prompt ) = @_;
741   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
742   ***      0      0                           0      print $prompt
743                                                         or die "Cannot print: $OS_ERROR";
744   ***      0                                  0      my $response;
745   ***      0                                  0      eval {
746   ***      0                                  0         require Term::ReadKey;
747   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
748   ***      0                                  0         chomp($response = <STDIN>);
749   ***      0                                  0         Term::ReadKey::ReadMode('normal');
750   ***      0      0                           0         print "\n"
751                                                            or die "Cannot print: $OS_ERROR";
752                                                      };
753   ***      0      0                           0      if ( $EVAL_ERROR ) {
754   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
755                                                      }
756   ***      0                                  0      return $response;
757                                                   }
758                                                   
759                                                   if ( MKDEBUG ) {
760                                                      print '# ', $^X, ' ', $], "\n";
761                                                      my $uname = `uname -a`;
762                                                      if ( $uname ) {
763                                                         $uname =~ s/\s+/ /g;
764                                                         print "# $uname\n";
765                                                      }
766                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
767                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
768                                                         ($main::SVN_REV || ''), __LINE__);
769                                                      print('# Arguments: ',
770                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
771                                                   }
772                                                   
773                                                   sub _read_config_file {
774   ***      0                    0             0      my ( $self, $filename ) = @_;
775   ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
776   ***      0                                  0      my @args;
777   ***      0                                  0      my $prefix = '--';
778   ***      0                                  0      my $parse  = 1;
779                                                   
780                                                      LINE:
781   ***      0                                  0      while ( my $line = <$fh> ) {
782   ***      0                                  0         chomp $line;
783   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
784   ***      0                                  0         $line =~ s/\s+#.*$//g;
785   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
786   ***      0      0                           0         if ( $line eq '--' ) {
787   ***      0                                  0            $prefix = '';
788   ***      0                                  0            $parse  = 0;
789   ***      0                                  0            next LINE;
790                                                         }
791   ***      0      0      0                    0         if ( $parse
      ***             0                               
792                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
793                                                         ) {
794   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
795                                                         }
796                                                         elsif ( $line =~ m/./ ) {
797   ***      0                                  0            push @args, $line;
798                                                         }
799                                                         else {
800   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
801                                                         }
802                                                      }
803   ***      0                                  0      close $fh;
804   ***      0                                  0      return @args;
805                                                   }
806                                                   
807                                                   sub read_para_after {
808   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
809   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
810   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
811   ***      0                                  0      my $para;
812   ***      0                                  0      while ( $para = <$fh> ) {
813   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
814   ***      0                                  0         last;
815                                                      }
816   ***      0                                  0      while ( $para = <$fh> ) {
817   ***      0      0                           0         next unless $para =~ m/$regex/;
818   ***      0                                  0         last;
819                                                      }
820   ***      0                                  0      $para = <$fh>;
821   ***      0                                  0      chomp($para);
822   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
823   ***      0                                  0      return $para;
824                                                   }
825                                                   
826                                                   sub clone {
827   ***      0                    0             0      my ( $self ) = @_;
828                                                   
829   ***      0                                  0      my %clone = map {
830   ***      0                                  0         my $hashref  = $self->{$_};
831   ***      0                                  0         my $val_copy = {};
832   ***      0                                  0         foreach my $key ( keys %$hashref ) {
833   ***      0                                  0            my $ref = ref $hashref->{$key};
834   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
835   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
836   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
837                                                                              : $hashref->{$key};
838                                                         }
839   ***      0                                  0         $_ => $val_copy;
840                                                      } qw(opts short_opts defaults);
841                                                   
842   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
843   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
844                                                      }
845                                                   
846   ***      0                                  0      return bless \%clone;     
847                                                   }
848                                                   
849                                                   sub _d {
850   ***      0                    0             0      my ($package, undef, $line) = caller 0;
851   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
852   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
853                                                           @_;
854   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
855                                                   }
856                                                   
857                                                   1;
858                                                   
859                                                   # ###########################################################################
860                                                   # End OptionParser package
861                                                   # ###########################################################################
862                                                   
863                                                   # ###########################################################################
864                                                   # SlowLogParser package 5357
865                                                   # ###########################################################################
866                                                   package SlowLogParser;
867                                                   
868            7                    7            72   use strict;
               7                                 18   
               7                                 58   
869            7                    7            44   use warnings FATAL => 'all';
               7                                 21   
               7                                 59   
870            7                    7            43   use English qw(-no_match_vars);
               7                                 16   
               7                                 44   
871            7                    7            46   use Data::Dumper;
               7                                 19   
               7                                 76   
872                                                   
873   ***      7            50      7            49   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 15   
               7                                116   
874                                                   
875                                                   sub new {
876   ***      0                    0             0      my ( $class ) = @_;
877   ***      0                                  0      my $self = {
878                                                         pending => [],
879                                                      };
880   ***      0                                  0      return bless $self, $class;
881                                                   }
882                                                   
883                                                   my $slow_log_ts_line = qr/^# Time: ([0-9: ]{15})/;
884                                                   my $slow_log_uh_line = qr/# User\@Host: ([^\[]+|\[[^[]+\]).*?@ (\S*) \[(.*)\]/;
885                                                   my $slow_log_hd_line = qr{
886                                                         ^(?:
887                                                         T[cC][pP]\s[pP]ort:\s+\d+ # case differs on windows/unix
888                                                         |
889                                                         [/A-Z].*mysqld,\sVersion.*(?:started\swith:|embedded\slibrary)
890                                                         |
891                                                         Time\s+Id\s+Command
892                                                         ).*\n
893                                                      }xm;
894                                                   
895                                                   sub parse_event {
896   ***      0                    0             0      my ( $self, %args ) = @_;
897   ***      0                                  0      my @required_args = qw(next_event tell);
898   ***      0                                  0      foreach my $arg ( @required_args ) {
899   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
900                                                      }
901   ***      0                                  0      my ($next_event, $tell) = @args{@required_args};
902                                                   
903   ***      0                                  0      my $pending = $self->{pending};
904   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = ";\n#";
905   ***      0                                  0      my $trimlen    = length($INPUT_RECORD_SEPARATOR);
906   ***      0                                  0      my $pos_in_log = $tell->();
907   ***      0                                  0      my $stmt;
908                                                   
909                                                      EVENT:
910   ***      0             0                    0      while (
911                                                            defined($stmt = shift @$pending)
912                                                         or defined($stmt = $next_event->())
913                                                      ) {
914   ***      0                                  0         my @properties = ('cmd', 'Query', 'pos_in_log', $pos_in_log);
915   ***      0                                  0         $pos_in_log = $tell->();
916                                                   
917   ***      0      0                           0         if ( $stmt =~ s/$slow_log_hd_line//go ){ # Throw away header lines in log
918   ***      0                                  0            my @chunks = split(/$INPUT_RECORD_SEPARATOR/o, $stmt);
919   ***      0      0                           0            if ( @chunks > 1 ) {
920   ***      0                                  0               MKDEBUG && _d("Found multiple chunks");
921   ***      0                                  0               $stmt = shift @chunks;
922   ***      0                                  0               unshift @$pending, @chunks;
923                                                            }
924                                                         }
925                                                   
926   ***      0      0                           0         $stmt = '#' . $stmt unless $stmt =~ m/\A#/;
927   ***      0                                  0         $stmt =~ s/;\n#?\Z//;
928                                                   
929                                                   
930   ***      0                                  0         my ($got_ts, $got_uh, $got_ac, $got_db, $got_set, $got_embed);
931   ***      0                                  0         my $pos = 0;
932   ***      0                                  0         my $len = length($stmt);
933   ***      0                                  0         my $found_arg = 0;
934                                                         LINE:
935   ***      0                                  0         while ( $stmt =~ m/^(.*)$/mg ) { # /g is important, requires scalar match.
936   ***      0                                  0            $pos     = pos($stmt);  # Be careful not to mess this up!
937   ***      0                                  0            my $line = $1;          # Necessary for /g and pos() to work.
938   ***      0                                  0            MKDEBUG && _d($line);
939                                                   
940   ***      0      0                           0            if ($line =~ m/^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) {
941                                                   
942   ***      0      0      0                    0               if ( !$got_ts && (my ( $time ) = $line =~ m/$slow_log_ts_line/o)) {
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0                               
943   ***      0                                  0                  MKDEBUG && _d("Got ts", $time);
944   ***      0                                  0                  push @properties, 'ts', $time;
945   ***      0                                  0                  ++$got_ts;
946   ***      0      0      0                    0                  if ( !$got_uh
947                                                                     && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
948                                                                  ) {
949   ***      0                                  0                     MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
950   ***      0                                  0                     push @properties, 'user', $user, 'host', $host, 'ip', $ip;
951   ***      0                                  0                     ++$got_uh;
952                                                                  }
953                                                               }
954                                                   
955                                                               elsif ( !$got_uh
956                                                                     && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
957                                                               ) {
958   ***      0                                  0                  MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
959   ***      0                                  0                  push @properties, 'user', $user, 'host', $host, 'ip', $ip;
960   ***      0                                  0                  ++$got_uh;
961                                                               }
962                                                   
963                                                               elsif (!$got_ac && $line =~ m/^# (?:administrator command:.*)$/) {
964   ***      0                                  0                  MKDEBUG && _d("Got admin command");
965   ***      0                                  0                  push @properties, 'cmd', 'Admin', 'arg', $line;
966   ***      0                                  0                  push @properties, 'bytes', length($properties[-1]);
967   ***      0                                  0                  ++$found_arg;
968   ***      0                                  0                  ++$got_ac;
969                                                               }
970                                                   
971                                                               elsif ( $line =~ m/^# +[A-Z][A-Za-z_]+: \S+/ ) { # Make the test cheap!
972   ***      0                                  0                  MKDEBUG && _d("Got some line with properties");
973   ***      0                                  0                  my @temp = $line =~ m/(\w+):\s+(\S+|\Z)/g;
974   ***      0                                  0                  push @properties, @temp;
975                                                               }
976                                                   
977                                                               elsif ( !$got_db && (my ( $db ) = $line =~ m/^use ([^;]+)/ ) ) {
978   ***      0                                  0                  MKDEBUG && _d("Got a default database:", $db);
979   ***      0                                  0                  push @properties, 'db', $db;
980   ***      0                                  0                  ++$got_db;
981                                                               }
982                                                   
983                                                               elsif (!$got_set && (my ($setting) = $line =~ m/^SET\s+([^;]*)/)) {
984   ***      0                                  0                  MKDEBUG && _d("Got some setting:", $setting);
985   ***      0                                  0                  push @properties, split(/,|\s*=\s*/, $setting);
986   ***      0                                  0                  ++$got_set;
987                                                               }
988                                                   
989   ***      0      0      0                    0               if ( !$found_arg && $pos == $len ) {
990   ***      0                                  0                  MKDEBUG && _d("Did not find arg, looking for special cases");
991   ***      0                                  0                  local $INPUT_RECORD_SEPARATOR = ";\n";
992   ***      0      0                           0                  if ( defined(my $l = $next_event->()) ) {
993   ***      0                                  0                     chomp $l;
994   ***      0                                  0                     MKDEBUG && _d("Found admin statement", $l);
995   ***      0                                  0                     push @properties, 'cmd', 'Admin', 'arg', '#' . $l;
996   ***      0                                  0                     push @properties, 'bytes', length($properties[-1]);
997   ***      0                                  0                     $found_arg++;
998                                                                  }
999                                                                  else {
1000  ***      0                                  0                     MKDEBUG && _d("I can't figure out what to do with this line");
1001  ***      0                                  0                     next EVENT;
1002                                                                 }
1003                                                              }
1004                                                           }
1005                                                           else {
1006  ***      0                                  0               MKDEBUG && _d("Got the query/arg line");
1007  ***      0                                  0               my $arg = substr($stmt, $pos - length($line));
1008  ***      0                                  0               push @properties, 'arg', $arg, 'bytes', length($arg);
1009  ***      0      0      0                    0               if ( $args{misc} && $args{misc}->{embed}
      ***                    0                        
1010                                                                 && ( my ($e) = $arg =~ m/($args{misc}->{embed})/)
1011                                                              ) {
1012  ***      0                                  0                  push @properties, $e =~ m/$args{misc}->{capture}/g;
1013                                                              }
1014  ***      0                                  0               last LINE;
1015                                                           }
1016                                                        }
1017                                                  
1018  ***      0                                  0         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
1019  ***      0                                  0         my $event = { @properties };
1020  ***      0                                  0         return $event;
1021                                                     } # EVENT
1022                                                  
1023  ***      0                                  0      @$pending = ();
1024  ***      0      0                           0      $args{oktorun}->(0) if $args{oktorun};
1025  ***      0                                  0      return;
1026                                                  }
1027                                                  
1028                                                  sub _d {
1029  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1030  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1031  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1032                                                          @_;
1033  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1034                                                  }
1035                                                  
1036                                                  1;
1037                                                  
1038                                                  # ###########################################################################
1039                                                  # End SlowLogParser package
1040                                                  # ###########################################################################
1041                                                  
1042                                                  # ###########################################################################
1043                                                  # BinaryLogParser package 5358
1044                                                  # ###########################################################################
1045                                                  package BinaryLogParser;
1046                                                  
1047           7                    7            54   use strict;
               7                                 16   
               7                                 45   
1048           7                    7            42   use warnings FATAL => 'all';
               7                                 24   
               7                                 32   
1049           7                    7            39   use English qw(-no_match_vars);
               7                                 22   
               7                                 42   
1050                                                  
1051           7                    7            46   use Data::Dumper;
               7                                 17   
               7                                 36   
1052                                                  $Data::Dumper::Indent    = 1;
1053                                                  $Data::Dumper::Sortkeys  = 1;
1054                                                  $Data::Dumper::Quotekeys = 0;
1055                                                  
1056  ***      7            50      7            45   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 17   
               7                                 99   
1057                                                  
1058                                                  sub new {
1059  ***      0                    0             0      my ( $class, %args ) = @_;
1060  ***      0                                  0      my $self = {
1061                                                        delim     => undef,
1062                                                        delim_len => 0,
1063                                                     };
1064  ***      0                                  0      return bless $self, $class;
1065                                                  }
1066                                                  
1067                                                  my $binlog_line_1 = qr/at (\d+)$/m;
1068                                                  my $binlog_line_2 = qr/^#(\d{6}\s+\d{1,2}:\d\d:\d\d)\s+server\s+id\s+(\d+)\s+end_log_pos\s+(\d+)\s+(\S+)\s*([^\n]*)$/m;
1069                                                  my $binlog_line_2_rest = qr/thread_id=(\d+)\s+exec_time=(\d+)\s+error_code=(\d+)/m;
1070                                                  
1071                                                  sub parse_event {
1072  ***      0                    0             0      my ( $self, %args ) = @_;
1073  ***      0                                  0      my @required_args = qw(next_event tell);
1074  ***      0                                  0      foreach my $arg ( @required_args ) {
1075  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1076                                                     }
1077  ***      0                                  0      my ($next_event, $tell) = @args{@required_args};
1078                                                  
1079  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = ";\n#";
1080  ***      0                                  0      my $pos_in_log = $tell->();
1081  ***      0                                  0      my $stmt;
1082  ***      0                                  0      my ($delim, $delim_len) = ($self->{delim}, $self->{delim_len});
1083                                                  
1084                                                     EVENT:
1085  ***      0                                  0      while ( defined($stmt = $next_event->()) ) {
1086  ***      0                                  0         my @properties = ('pos_in_log', $pos_in_log);
1087  ***      0                                  0         my ($ts, $sid, $end, $type, $rest);
1088  ***      0                                  0         $pos_in_log = $tell->();
1089  ***      0                                  0         $stmt =~ s/;\n#?\Z//;
1090                                                  
1091  ***      0                                  0         my ( $got_offset, $got_hdr );
1092  ***      0                                  0         my $pos = 0;
1093  ***      0                                  0         my $len = length($stmt);
1094  ***      0                                  0         my $found_arg = 0;
1095                                                        LINE:
1096  ***      0                                  0         while ( $stmt =~ m/^(.*)$/mg ) { # /g requires scalar match.
1097  ***      0                                  0            $pos     = pos($stmt);  # Be careful not to mess this up!
1098  ***      0                                  0            my $line = $1;          # Necessary for /g and pos() to work.
1099  ***      0      0                           0            $line    =~ s/$delim// if $delim;
1100  ***      0                                  0            MKDEBUG && _d($line);
1101                                                  
1102  ***      0      0                           0            if ( $line =~ m/^\/\*.+\*\/;/ ) {
1103  ***      0                                  0               MKDEBUG && _d('Comment line');
1104  ***      0                                  0               next LINE;
1105                                                           }
1106                                                   
1107  ***      0      0                           0            if ( $line =~ m/^DELIMITER/m ) {
1108  ***      0                                  0               my ( $del ) = $line =~ m/^DELIMITER (\S*)$/m;
1109  ***      0      0                           0               if ( $del ) {
1110  ***      0                                  0                  $self->{delim_len} = $delim_len = length $del;
1111  ***      0                                  0                  $self->{delim}     = $delim     = quotemeta $del;
1112  ***      0                                  0                  MKDEBUG && _d('delimiter:', $delim);
1113                                                              }
1114                                                              else {
1115  ***      0                                  0                  MKDEBUG && _d('Delimiter reset to ;');
1116  ***      0                                  0                  $self->{delim}     = $delim     = undef;
1117  ***      0                                  0                  $self->{delim_len} = $delim_len = 0;
1118                                                              }
1119  ***      0                                  0               next LINE;
1120                                                           }
1121                                                  
1122  ***      0      0                           0            next LINE if $line =~ m/End of log file/;
1123                                                  
1124  ***      0      0      0                    0            if ( !$got_offset && (my ( $offset ) = $line =~ m/$binlog_line_1/m) ) {
      ***             0      0                        
      ***             0                               
1125  ***      0                                  0               MKDEBUG && _d('Got the at offset line');
1126  ***      0                                  0               push @properties, 'offset', $offset;
1127  ***      0                                  0               $got_offset++;
1128                                                           }
1129                                                  
1130                                                           elsif ( !$got_hdr && $line =~ m/^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/ ) {
1131  ***      0                                  0               ($ts, $sid, $end, $type, $rest) = $line =~ m/$binlog_line_2/m;
1132  ***      0                                  0               MKDEBUG && _d('Got the header line; type:', $type, 'rest:', $rest);
1133  ***      0                                  0               push @properties, 'cmd', 'Query', 'ts', $ts, 'server_id', $sid,
1134                                                                 'end_log_pos', $end;
1135  ***      0                                  0               $got_hdr++;
1136                                                           }
1137                                                  
1138                                                           elsif ( $line =~ m/^(?:#|use |SET)/i ) {
1139                                                  
1140  ***      0      0                           0               if ( my ( $db ) = $line =~ m/^use ([^;]+)/ ) {
      ***             0                               
1141  ***      0                                  0                  MKDEBUG && _d("Got a default database:", $db);
1142  ***      0                                  0                  push @properties, 'db', $db;
1143                                                              }
1144                                                  
1145                                                              elsif ( my ($setting) = $line =~ m/^SET\s+([^;]*)/ ) {
1146  ***      0                                  0                  MKDEBUG && _d("Got some setting:", $setting);
1147  ***      0                                  0                  push @properties, map { s/\s+//; lc } split(/,|\s*=\s*/, $setting);
      ***      0                                  0   
      ***      0                                  0   
1148                                                              }
1149                                                  
1150                                                           }
1151                                                           else {
1152  ***      0                                  0               MKDEBUG && _d("Got the query/arg line at pos", $pos);
1153  ***      0                                  0               $found_arg++;
1154  ***      0      0      0                    0               if ( $got_offset && $got_hdr ) {
1155  ***      0      0                           0                  if ( $type eq 'Xid' ) {
      ***             0                               
      ***             0                               
1156  ***      0                                  0                     my ($xid) = $rest =~ m/(\d+)/;
1157  ***      0                                  0                     push @properties, 'Xid', $xid;
1158                                                                 }
1159                                                                 elsif ( $type eq 'Query' ) {
1160  ***      0                                  0                     my ($i, $t, $c) = $rest =~ m/$binlog_line_2_rest/m;
1161  ***      0                                  0                     push @properties, 'Thread_id', $i, 'Query_time', $t,
1162                                                                                      'error_code', $c;
1163                                                                 }
1164                                                                 elsif ( $type eq 'Start:' ) {
1165  ***      0                                  0                     MKDEBUG && _d("Binlog start");
1166                                                                 }
1167                                                                 else {
1168  ***      0                                  0                     MKDEBUG && _d('Unknown event type:', $type);
1169  ***      0                                  0                     next EVENT;
1170                                                                 }
1171                                                              }
1172                                                              else {
1173  ***      0                                  0                  MKDEBUG && _d("It's not a query/arg, it's just some SQL fluff");
1174  ***      0                                  0                  push @properties, 'cmd', 'Query', 'ts', undef;
1175                                                              }
1176                                                  
1177  ***      0      0                           0               my $delim_len = ($pos == length($stmt) ? $delim_len : 0);
1178  ***      0                                  0               my $arg = substr($stmt, $pos - length($line) - $delim_len);
1179                                                  
1180  ***      0      0                           0               $arg =~ s/$delim// if $delim; # Remove the delimiter.
1181                                                  
1182  ***      0      0                           0               if ( $arg =~ m/^DELIMITER/m ) {
1183  ***      0                                  0                  my ( $del ) = $arg =~ m/^DELIMITER (\S*)$/m;
1184  ***      0      0                           0                  if ( $del ) {
1185  ***      0                                  0                     $self->{delim_len} = $delim_len = length $del;
1186  ***      0                                  0                     $self->{delim}     = $delim     = quotemeta $del;
1187  ***      0                                  0                     MKDEBUG && _d('delimiter:', $delim);
1188                                                                 }
1189                                                                 else {
1190  ***      0                                  0                     MKDEBUG && _d('Delimiter reset to ;');
1191  ***      0                                  0                     $del       = ';';
1192  ***      0                                  0                     $self->{delim}     = $delim     = undef;
1193  ***      0                                  0                     $self->{delim_len} = $delim_len = 0;
1194                                                                 }
1195                                                  
1196  ***      0                                  0                  $arg =~ s/^DELIMITER.*$//m;  # Remove DELIMITER from arg.
1197                                                              }
1198                                                  
1199  ***      0                                  0               $arg =~ s/;$//gm;  # Ensure ending ; are gone.
1200  ***      0                                  0               $arg =~ s/\s+$//;  # Remove trailing spaces and newlines.
1201                                                  
1202  ***      0                                  0               push @properties, 'arg', $arg, 'bytes', length($arg);
1203  ***      0                                  0               last LINE;
1204                                                           }
1205                                                        } # LINE
1206                                                  
1207  ***      0      0                           0         if ( $found_arg ) {
1208  ***      0                                  0            MKDEBUG && _d('Properties of event:', Dumper(\@properties));
1209  ***      0                                  0            my $event = { @properties };
1210  ***      0                                  0            return $event;
1211                                                        }
1212                                                        else {
1213  ***      0                                  0            MKDEBUG && _d('Event had no arg');
1214                                                        }
1215                                                     } # EVENT
1216                                                  
1217  ***      0      0                           0      $args{oktorun}->(0) if $args{oktorun};
1218  ***      0                                  0      return;
1219                                                  }
1220                                                  
1221                                                  sub _d {
1222  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1223  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1224  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1225                                                          @_;
1226  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1227                                                  }
1228                                                  
1229                                                  1;
1230                                                  
1231                                                  # ###########################################################################
1232                                                  # End BinaryLogParser package
1233                                                  # ###########################################################################
1234                                                  
1235                                                  # ###########################################################################
1236                                                  # GeneralLogParser package 5359
1237                                                  # ###########################################################################
1238                                                  package GeneralLogParser;
1239                                                  
1240           7                    7            56   use strict;
               7                                 19   
               7                                 41   
1241           7                    7            43   use warnings FATAL => 'all';
               7                                 18   
               7                                505   
1242           7                    7           511   use English qw(-no_match_vars);
               7                                 24   
               7                                 35   
1243                                                  
1244           7                    7            45   use Data::Dumper;
               7                                 16   
               7                                 39   
1245                                                  $Data::Dumper::Indent    = 1;
1246                                                  $Data::Dumper::Sortkeys  = 1;
1247                                                  $Data::Dumper::Quotekeys = 0;
1248                                                  
1249  ***      7            50      7            46   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 14   
               7                                173   
1250                                                  
1251                                                  sub new {
1252  ***      0                    0             0      my ( $class ) = @_;
1253  ***      0                                  0      my $self = {
1254                                                        pending => [],
1255                                                        db_for  => {},
1256                                                     };
1257  ***      0                                  0      return bless $self, $class;
1258                                                  }
1259                                                  
1260                                                  my $genlog_line_1= qr{
1261                                                     \A
1262                                                     (?:(\d{6}\s\d{1,2}:\d\d:\d\d))? # Timestamp
1263                                                     \s+
1264                                                     (?:\s*(\d+))                        # Thread ID
1265                                                     \s
1266                                                     (\w+)                               # Command
1267                                                     \s+
1268                                                     (.*)                                # Argument
1269                                                     \Z
1270                                                  }xs;
1271                                                  
1272                                                  sub parse_event {
1273  ***      0                    0             0      my ( $self, %args ) = @_;
1274  ***      0                                  0      my @required_args = qw(next_event tell);
1275  ***      0                                  0      foreach my $arg ( @required_args ) {
1276  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1277                                                     }
1278  ***      0                                  0      my ($next_event, $tell) = @args{@required_args};
1279                                                  
1280  ***      0                                  0      my $pending = $self->{pending};
1281  ***      0                                  0      my $db_for  = $self->{db_for};
1282  ***      0                                  0      my $line;
1283  ***      0                                  0      my $pos_in_log = $tell->();
1284                                                     LINE:
1285  ***      0             0                    0      while (
1286                                                           defined($line = shift @$pending)
1287                                                        or defined($line = $next_event->())
1288                                                     ) {
1289  ***      0                                  0         MKDEBUG && _d($line);
1290  ***      0                                  0         my ($ts, $thread_id, $cmd, $arg) = $line =~ m/$genlog_line_1/;
1291  ***      0      0      0                    0         if ( !($thread_id && $cmd) ) {
1292  ***      0                                  0            MKDEBUG && _d('Not start of general log event');
1293  ***      0                                  0            next;
1294                                                        }
1295  ***      0                                  0         my @properties = ('pos_in_log', $pos_in_log, 'ts', $ts,
1296                                                           'Thread_id', $thread_id);
1297                                                  
1298  ***      0                                  0         $pos_in_log = $tell->();
1299                                                  
1300  ***      0                                  0         @$pending = ();
1301  ***      0      0                           0         if ( $cmd eq 'Query' ) {
1302  ***      0                                  0            my $done = 0;
1303  ***      0                                  0            do {
1304  ***      0                                  0               $line = $next_event->();
1305  ***      0      0                           0               if ( $line ) {
1306  ***      0                                  0                  ($ts, $thread_id, $cmd, undef) = $line =~ m/$genlog_line_1/;
1307  ***      0      0      0                    0                  if ( $thread_id && $cmd ) {
1308  ***      0                                  0                     MKDEBUG && _d('Event done');
1309  ***      0                                  0                     $done = 1;
1310  ***      0                                  0                     push @$pending, $line;
1311                                                                 }
1312                                                                 else {
1313  ***      0                                  0                     MKDEBUG && _d('More arg:', $line);
1314  ***      0                                  0                     $arg .= $line;
1315                                                                 }
1316                                                              }
1317                                                              else {
1318  ***      0                                  0                  MKDEBUG && _d('No more lines');
1319  ***      0                                  0                  $done = 1;
1320                                                              }
1321                                                           } until ( $done );
1322                                                  
1323  ***      0                                  0            chomp $arg;
1324  ***      0                                  0            push @properties, 'cmd', 'Query', 'arg', $arg;
1325  ***      0                                  0            push @properties, 'bytes', length($properties[-1]);
1326  ***      0      0                           0            push @properties, 'db', $db_for->{$thread_id} if $db_for->{$thread_id};
1327                                                        }
1328                                                        else {
1329  ***      0                                  0            push @properties, 'cmd', 'Admin';
1330                                                  
1331  ***      0      0                           0            if ( $cmd eq 'Connect' ) {
      ***             0                               
1332  ***      0      0                           0               if ( $arg =~ m/^Access denied/ ) {
1333  ***      0                                  0                  $cmd = $arg;
1334                                                              }
1335                                                              else {
1336  ***      0                                  0                  my ($user, undef, $db) = $arg =~ /(\S+)/g;
1337  ***      0                                  0                  my $host;
1338  ***      0                                  0                  ($user, $host) = split(/@/, $user);
1339  ***      0                                  0                  MKDEBUG && _d('Connect', $user, '@', $host, 'on', $db);
1340                                                  
1341  ***      0      0                           0                  push @properties, 'user', $user if $user;
1342  ***      0      0                           0                  push @properties, 'host', $host if $host;
1343  ***      0      0                           0                  push @properties, 'db',   $db   if $db;
1344  ***      0                                  0                  $db_for->{$thread_id} = $db;
1345                                                              }
1346                                                           }
1347                                                           elsif ( $cmd eq 'Init' ) {
1348  ***      0                                  0               $cmd = 'Init DB';
1349  ***      0                                  0               $arg =~ s/^DB\s+//;
1350  ***      0                                  0               my ($db) = $arg =~ /(\S+)/;
1351  ***      0                                  0               MKDEBUG && _d('Init DB:', $db);
1352  ***      0      0                           0               push @properties, 'db',   $db   if $db;
1353  ***      0                                  0               $db_for->{$thread_id} = $db;
1354                                                           }
1355                                                  
1356  ***      0                                  0            push @properties, 'arg', "administrator command: $cmd";
1357  ***      0                                  0            push @properties, 'bytes', length($properties[-1]);
1358                                                        }
1359                                                  
1360  ***      0                                  0         push @properties, 'Query_time', 0;
1361                                                  
1362  ***      0                                  0         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
1363  ***      0                                  0         my $event = { @properties };
1364  ***      0                                  0         return $event;
1365                                                     } # LINE
1366                                                  
1367  ***      0                                  0      @{$self->{pending}} = ();
      ***      0                                  0   
1368  ***      0      0                           0      $args{oktorun}->(0) if $args{oktorun};
1369  ***      0                                  0      return;
1370                                                  }
1371                                                  
1372                                                  sub _d {
1373  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1374  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1375  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1376                                                          @_;
1377  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1378                                                  }
1379                                                  
1380                                                  1;
1381                                                  
1382                                                  # ###########################################################################
1383                                                  # End GeneralLogParser package
1384                                                  # ###########################################################################
1385                                                  
1386                                                  # ###########################################################################
1387                                                  # LogSplitter package 5447
1388                                                  # ###########################################################################
1389                                                  
1390                                                  package LogSplitter;
1391                                                  
1392           7                    7            51   use strict;
               7                                 25   
               7                                 50   
1393           7                    7            40   use warnings FATAL => 'all';
               7                                 16   
               7                                 51   
1394           7                    7            38   use English qw(-no_match_vars);
               7                                 17   
               7                                 48   
1395                                                  
1396           7                    7            44   use Data::Dumper;
               7                                246   
               7                                 37   
1397                                                  $Data::Dumper::Indent    = 1;
1398                                                  $Data::Dumper::Sortkeys  = 1;
1399                                                  $Data::Dumper::Quotekeys = 0;
1400                                                  
1401           7                    7            42   use constant MKDEBUG           => $ENV{MKDEBUG};
               7                                 15   
               7                                 49   
1402           7                    7            42   use constant MAX_OPEN_FILES    => 1000;
               7                                 18   
               7                                 30   
1403           7                    7            42   use constant CLOSE_N_LRU_FILES => 100;
               7                                 29   
               7                                 39   
1404                                                  
1405                                                  my $oktorun = 1;
1406                                                  
1407                                                  sub new {
1408  ***      0                    0             0      my ( $class, %args ) = @_;
1409  ***      0                                  0      foreach my $arg ( qw(attribute base_dir parser session_files) ) {
1410  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1411                                                     }
1412                                                  
1413  ***      0      0                           0      $args{base_dir} .= '/' if substr($args{base_dir}, -1, 1) ne '/';
1414                                                  
1415  ***      0      0                           0      if ( $args{split_random} ) {
1416  ***      0                                  0         MKDEBUG && _d('Split random');
1417  ***      0                                  0         $args{attribute} = '_sessionno';  # set round-robin 1..session_files
1418                                                     }
1419                                                  
1420  ***      0                                  0      my $self = {
1421                                                        base_file_name    => 'session',
1422                                                        max_dirs          => 1_000,
1423                                                        max_files_per_dir => 5_000,
1424                                                        max_sessions      => 5_000_000,  # max_dirs * max_files_per_dir
1425                                                        merge_sessions    => 1,
1426                                                        session_files     => 64,
1427                                                        quiet             => 0,
1428                                                        verbose           => 0,
1429                                                        %args,
1430                                                        n_dirs_total       => 0,  # total number of dirs created
1431                                                        n_files_total      => 0,  # total number of session files created
1432                                                        n_files_this_dir   => -1, # number of session files in current dir
1433                                                        session_fhs        => [], # filehandles for each session
1434                                                        n_open_fhs         => 0,  # current number of open session filehandles
1435                                                        n_events_total     => 0,  # total number of events in log
1436                                                        n_events_saved     => 0,  # total number of events saved
1437                                                        n_sessions_skipped => 0,  # total number of sessions skipped
1438                                                        n_sessions_saved   => 0,  # number of sessions saved
1439                                                        sessions           => {}, # sessions data store
1440                                                        created_dirs       => [],
1441                                                     };
1442                                                  
1443  ***      0                                  0      MKDEBUG && _d('new LogSplitter final args:', Dumper($self));
1444  ***      0                                  0      return bless $self, $class;
1445                                                  }
1446                                                  
1447                                                  sub split {
1448  ***      0                    0             0      my ( $self, @logs ) = @_;
1449  ***      0                                  0      $oktorun = 1; # True as long as we haven't created too many
1450                                                  
1451  ***      0                                  0      my $callbacks = $self->{callbacks};
1452                                                  
1453  ***      0                                  0      my $next_sessionno;
1454  ***      0      0                           0      if ( $self->{split_random} ) {
1455  ***      0                                  0         $next_sessionno = make_rr_iter(1, $self->{session_files});
1456                                                     }
1457                                                  
1458  ***      0      0                           0      if ( @logs == 0 ) {
1459  ***      0                                  0         MKDEBUG && _d('Implicitly reading STDIN because no logs were given');
1460  ***      0                                  0         push @logs, '-';
1461                                                     }
1462                                                  
1463  ***      0                                  0      my $lp = $self->{parser};
1464                                                     LOG:
1465  ***      0                                  0      foreach my $log ( @logs ) {
1466  ***      0      0                           0         last unless $oktorun;
1467  ***      0      0                           0         next unless defined $log;
1468                                                  
1469  ***      0      0      0                    0         if ( !-f $log && $log ne '-' ) {
1470  ***      0                                  0            warn "Skipping $log because it is not a file";
1471  ***      0                                  0            next LOG;
1472                                                        }
1473  ***      0                                  0         my $fh;
1474  ***      0      0                           0         if ( $log eq '-' ) {
1475  ***      0                                  0            $fh = *STDIN;
1476                                                        }
1477                                                        else {
1478  ***      0      0                           0            if ( !open $fh, "<", $log ) {
1479  ***      0                                  0               warn "Cannot open $log: $OS_ERROR\n";
1480  ***      0                                  0               next LOG;
1481                                                           }
1482                                                        }
1483                                                  
1484  ***      0                                  0         MKDEBUG && _d('Splitting', $log);
1485  ***      0                                  0         my $event           = {};
1486  ***      0                                  0         my $more_events     = 1;
1487  ***      0                    0             0         my $more_events_sub = sub { $more_events = $_[0]; };
      ***      0                                  0   
1488                                                        EVENT:
1489  ***      0                                  0         while ( $oktorun ) {
1490                                                           $event = $lp->parse_event(
1491  ***      0                    0             0               next_event => sub { return <$fh>;    },
1492  ***      0                    0             0               tell       => sub { return tell $fh; },
1493  ***      0                                  0               oktorun => $more_events_sub,
1494                                                           );
1495  ***      0      0                           0            if ( $event ) {
1496  ***      0                                  0               $self->{n_events_total}++;
1497  ***      0      0                           0               if ( $self->{split_random} ) {
1498  ***      0                                  0                  $event->{_sessionno} = $next_sessionno->();
1499                                                              }
1500  ***      0      0                           0               if ( $callbacks ) {
1501  ***      0                                  0                  foreach my $callback ( @$callbacks ) {
1502  ***      0                                  0                     $event = $callback->($event);
1503  ***      0      0                           0                     last unless $event;
1504                                                                 }
1505                                                              }
1506  ***      0      0                           0               $self->_save_event($event) if $event;
1507                                                           }
1508  ***      0      0                           0            if ( !$more_events ) {
1509  ***      0                                  0               MKDEBUG && _d('Done parsing', $log);
1510  ***      0                                  0               close $fh;
1511  ***      0                                  0               next LOG;
1512                                                           }
1513  ***      0      0                           0            last LOG unless $oktorun;
1514                                                        }
1515                                                     }
1516                                                  
1517  ***      0                                  0      while ( my $fh = pop @{ $self->{session_fhs} } ) {
      ***      0                                  0   
1518  ***      0                                  0         close $fh->{fh};
1519                                                     }
1520  ***      0                                  0      $self->{n_open_fhs}  = 0;
1521                                                  
1522  ***      0      0                           0      $self->_merge_session_files() if $self->{merge_sessions};
1523  ***      0      0                           0      $self->print_split_summary() unless $self->{quiet};
1524                                                  
1525  ***      0                                  0      return;
1526                                                  }
1527                                                  
1528                                                  sub _save_event {
1529  ***      0                    0             0      my ( $self, $event ) = @_; 
1530  ***      0                                  0      my ($session, $session_id) = $self->_get_session_ds($event);
1531  ***      0      0                           0      return unless $session;
1532                                                  
1533  ***      0      0                           0      if ( !defined $session->{fh} ) {
      ***             0                               
1534  ***      0                                  0         $self->{n_sessions_saved}++;
1535  ***      0                                  0         MKDEBUG && _d('New session:', $session_id, ',',
1536                                                           $self->{n_sessions_saved}, 'of', $self->{max_sessions});
1537                                                  
1538  ***      0                                  0         my $session_file = $self->_get_next_session_file();
1539  ***      0      0                           0         if ( !$session_file ) {
1540  ***      0                                  0            $oktorun = 0;
1541  ***      0                                  0            MKDEBUG && _d('Not oktorun because no _get_next_session_file');
1542  ***      0                                  0            return;
1543                                                        }
1544                                                  
1545  ***      0      0                           0         $self->_close_lru_session() if $self->{n_open_fhs} >= MAX_OPEN_FILES;
1546                                                  
1547  ***      0      0                           0         open my $fh, '>', $session_file
1548                                                           or die "Cannot open session file $session_file: $OS_ERROR";
1549  ***      0                                  0         $session->{fh} = $fh;
1550  ***      0                                  0         $self->{n_open_fhs}++;
1551                                                  
1552  ***      0                                  0         $session->{active}       = 1;
1553  ***      0                                  0         $session->{session_file} = $session_file;
1554                                                  
1555  ***      0                                  0         push @{$self->{session_fhs}}, { fh => $fh, session_id => $session_id };
      ***      0                                  0   
1556                                                  
1557  ***      0                                  0         MKDEBUG && _d('Created', $session_file, 'for session',
1558                                                           $self->{attribute}, '=', $session_id);
1559                                                  
1560  ***      0                                  0         print $fh "-- START SESSION $session_id\n\n";
1561                                                     }
1562                                                     elsif ( !$session->{active} ) {
1563                                                  
1564  ***      0      0                           0         $self->_close_lru_session() if $self->{n_open_fhs} >= MAX_OPEN_FILES;
1565                                                  
1566  ***      0      0                           0          open $session->{fh}, '>>', $session->{session_file}
1567                                                            or die "Cannot reopen session file "
1568                                                              . "$session->{session_file}: $OS_ERROR";
1569                                                  
1570  ***      0                                  0          $session->{active} = 1;
1571  ***      0                                  0          $self->{n_open_fhs}++;
1572                                                  
1573  ***      0                                  0          MKDEBUG && _d('Reopend', $session->{session_file}, 'for session',
1574                                                           $self->{attribute}, '=', $session_id);
1575                                                     }
1576                                                     else {
1577  ***      0                                  0         MKDEBUG && _d('Event belongs to active session', $session_id);
1578                                                     }
1579                                                  
1580  ***      0                                  0      my $session_fh = $session->{fh};
1581                                                  
1582  ***      0             0                    0      my $db = $event->{db} || $event->{Schema};
1583  ***      0      0      0                    0      if ( $db && ( !defined $session->{db} || $session->{db} ne $db ) ) {
      ***                    0                        
1584  ***      0                                  0         print $session_fh "use $db\n\n";
1585  ***      0                                  0         $session->{db} = $db;
1586                                                     }
1587                                                  
1588  ***      0                                  0      print $session_fh flatten($event->{arg}), "\n\n";
1589  ***      0                                  0      $self->{n_events_saved}++;
1590                                                  
1591  ***      0                                  0      return;
1592                                                  }
1593                                                  
1594                                                  sub _get_session_ds {
1595  ***      0                    0             0      my ( $self, $event ) = @_;
1596                                                  
1597  ***      0                                  0      my $attrib = $self->{attribute};
1598  ***      0      0                           0      if ( !$event->{ $attrib } ) {
1599  ***      0                                  0         MKDEBUG && _d('No attribute', $attrib, 'in event:', Dumper($event));
1600  ***      0                                  0         return;
1601                                                     }
1602                                                  
1603  ***      0      0                           0      return unless $event->{arg};
1604                                                  
1605  ***      0      0      0                    0      return if ($event->{cmd} || '') eq 'Admin';
1606                                                  
1607  ***      0                                  0      my $session;
1608  ***      0                                  0      my $session_id = $event->{ $attrib };
1609                                                  
1610  ***      0      0                           0      if ( $self->{n_sessions_saved} < $self->{max_sessions} ) {
      ***             0                               
1611  ***      0             0                    0         $session = $self->{sessions}->{ $session_id } ||= {};
1612                                                     }
1613                                                     elsif ( exists $self->{sessions}->{ $session_id } ) {
1614  ***      0                                  0         $session = $self->{sessions}->{ $session_id };
1615                                                     }
1616                                                     else {
1617  ***      0                                  0         $self->{n_sessions_skipped} += 1;
1618  ***      0                                  0         MKDEBUG && _d('Skipping new session', $session_id,
1619                                                           'because max_sessions is reached');
1620                                                     }
1621                                                  
1622  ***      0                                  0      return $session, $session_id;
1623                                                  }
1624                                                  
1625                                                  sub _close_lru_session {
1626  ***      0                    0             0      my ( $self ) = @_;
1627  ***      0                                  0      my $session_fhs = $self->{session_fhs};
1628  ***      0                                  0      my $lru_n       = $self->{n_sessions_saved} - MAX_OPEN_FILES - 1;
1629  ***      0                                  0      my $close_to_n  = $lru_n + CLOSE_N_LRU_FILES - 1;
1630                                                  
1631  ***      0                                  0      MKDEBUG && _d('Closing session fhs', $lru_n, '..', $close_to_n,
1632                                                        '(',$self->{n_sessions}, 'sessions', $self->{n_open_fhs}, 'open fhs)');
1633                                                  
1634  ***      0                                  0      foreach my $session ( @$session_fhs[ $lru_n..$close_to_n ] ) {
1635  ***      0                                  0         close $session->{fh};
1636  ***      0                                  0         $self->{n_open_fhs}--;
1637  ***      0                                  0         $self->{sessions}->{ $session->{session_id} }->{active} = 0;
1638                                                     }
1639                                                  
1640  ***      0                                  0      return;
1641                                                  }
1642                                                  
1643                                                  sub _get_next_session_file {
1644  ***      0                    0             0      my ( $self, $n ) = @_;
1645  ***      0      0                           0      return if $self->{n_dirs_total} >= $self->{max_dirs};
1646                                                  
1647  ***      0      0      0                    0      if ( ($self->{n_files_this_dir} >= $self->{max_files_per_dir})
1648                                                          || $self->{n_files_this_dir} < 0 ) {
1649  ***      0                                  0         $self->{n_dirs_total}++;
1650  ***      0                                  0         $self->{n_files_this_dir} = 0;
1651  ***      0                                  0         my $new_dir = "$self->{base_dir}$self->{n_dirs_total}";
1652  ***      0      0                           0         if ( !-d $new_dir ) {
1653  ***      0                                  0            my $retval = system("mkdir $new_dir");
1654  ***      0      0                           0            if ( ($retval >> 8) != 0 ) {
1655  ***      0                                  0               die "Cannot create new directory $new_dir: $OS_ERROR";
1656                                                           }
1657  ***      0                                  0            MKDEBUG && _d('Created new base_dir', $new_dir);
1658  ***      0                                  0            push @{$self->{created_dirs}}, $new_dir;
      ***      0                                  0   
1659                                                        }
1660                                                        elsif ( MKDEBUG ) {
1661                                                           _d($new_dir, 'already exists');
1662                                                        }
1663                                                     }
1664                                                     else {
1665  ***      0                                  0         MKDEBUG && _d('No dir created; n_files_this_dir:',
1666                                                           $self->{n_files_this_dir}, 'n_files_total:',
1667                                                           $self->{n_files_total});
1668                                                     }
1669                                                  
1670  ***      0                                  0      $self->{n_files_total}++;
1671  ***      0                                  0      $self->{n_files_this_dir}++;
1672  ***      0                                  0      my $dir_n        = $self->{n_dirs_total} . '/';
1673  ***      0             0                    0      my $session_n    = sprintf '%d', $n || $self->{n_sessions_saved};
1674  ***      0                                  0      my $session_file = $self->{base_dir}
1675                                                                      . $dir_n
1676                                                                      . $self->{base_file_name}."-$session_n.txt";
1677  ***      0                                  0      MKDEBUG && _d('Next session file', $session_file);
1678  ***      0                                  0      return $session_file;
1679                                                  }
1680                                                  
1681                                                  sub flatten {
1682  ***      0                    0             0      my ( $query ) = @_;
1683  ***      0      0                           0      return unless $query;
1684  ***      0                                  0      $query =~ s!/\*.*?\*/! !g;
1685  ***      0                                  0      $query =~ s/^\s+//;
1686  ***      0                                  0      $query =~ s/\s{2,}/ /g;
1687  ***      0                                  0      return $query;
1688                                                  }
1689                                                  
1690                                                  sub _merge_session_files {
1691  ***      0                    0             0      my ( $self ) = @_;
1692                                                  
1693  ***      0      0                           0      print "Merging session files...\n" unless $self->{quiet};
1694                                                  
1695  ***      0                                  0      my @multi_session_files;
1696  ***      0                                  0      for my $i ( 1..$self->{session_files} ) {
1697  ***      0                                  0         push @multi_session_files, $self->{base_dir} ."sessions-$i.txt";
1698                                                     }
1699                                                  
1700  ***      0                                  0      my @single_session_files = map {
1701  ***      0                                  0         $_->{session_file};
1702  ***      0                                  0      } values %{$self->{sessions}};
1703                                                  
1704  ***      0                                  0      my $i = make_rr_iter(0, $#multi_session_files);  # round-robin iterator
1705  ***      0                                  0      foreach my $single_session_file ( @single_session_files ) {
1706  ***      0                                  0         my $multi_session_file = $multi_session_files[ $i->() ];
1707  ***      0                                  0         my $cmd;
1708  ***      0      0                           0         if ( $self->{split_random} ) {
1709  ***      0                                  0            $cmd = "mv $single_session_file $multi_session_file";
1710                                                        }
1711                                                        else {
1712  ***      0                                  0            $cmd = "cat $single_session_file >> $multi_session_file";
1713                                                        }
1714  ***      0                                  0         eval { `$cmd`; };
      ***      0                                  0   
1715  ***      0      0                           0         if ( $EVAL_ERROR ) {
1716  ***      0                                  0            warn "Failed to `$cmd`: $OS_ERROR";
1717                                                        }
1718                                                     }
1719                                                  
1720  ***      0                                  0      foreach my $created_dir ( @{$self->{created_dirs}} ) {
      ***      0                                  0   
1721  ***      0                                  0         my $cmd = "rm -rf $created_dir";
1722  ***      0                                  0         eval { `$cmd`; };
      ***      0                                  0   
1723  ***      0      0                           0         if ( $EVAL_ERROR ) {
1724  ***      0                                  0            warn "Failed to `$cmd`: $OS_ERROR";
1725                                                        }
1726                                                     }
1727                                                  
1728  ***      0                                  0      return;
1729                                                  }
1730                                                  
1731                                                  sub make_rr_iter {
1732  ***      0                    0             0      my ( $start, $end ) = @_;
1733  ***      0                                  0      my $current = $start;
1734                                                     return sub {
1735  ***      0      0             0             0         $current = $start if $current > $end ;
1736  ***      0                                  0         $current++;  # For next iteration.
1737  ***      0                                  0         return $current - 1;
1738  ***      0                                  0      };
1739                                                  }
1740                                                  
1741                                                  sub print_split_summary {
1742  ***      0                    0             0      my ( $self ) = @_;
1743  ***      0                                  0      print "Split summary:\n";
1744  ***      0                                  0      my $fmt = "%-20s %-10s\n";
1745  ***      0                                  0      printf $fmt, 'Total sessions',
1746                                                        $self->{n_sessions_saved} + $self->{n_sessions_skipped};
1747  ***      0                                  0      printf $fmt, 'Sessions saved',
1748                                                        $self->{n_sessions_saved};
1749  ***      0                                  0      printf $fmt, 'Total events', $self->{n_events_total};
1750  ***      0                                  0      printf $fmt, 'Events saved', $self->{n_events_saved};
1751  ***      0                                  0      return;
1752                                                  }
1753                                                  
1754                                                  sub _d {
1755  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1756  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1757  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1758                                                          @_;
1759  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1760                                                  }
1761                                                  
1762                                                  1;
1763                                                  
1764                                                  # ###########################################################################
1765                                                  # End LogSplitter package
1766                                                  # ###########################################################################
1767                                                  
1768                                                  # ###########################################################################
1769                                                  # DSNParser package 5266
1770                                                  # ###########################################################################
1771                                                  package DSNParser;
1772                                                  
1773           7                    7            57   use strict;
               7                                 20   
               7                                278   
1774           7                    7            39   use warnings FATAL => 'all';
               7                                254   
               7                                 41   
1775           7                    7            40   use English qw(-no_match_vars);
               7                                 19   
               7                                 35   
1776           7                    7            44   use Data::Dumper;
               7                                 15   
               7                                 35   
1777                                                  $Data::Dumper::Indent    = 0;
1778                                                  $Data::Dumper::Quotekeys = 0;
1779                                                  
1780                                                  eval {
1781                                                     require DBI;
1782                                                  };
1783                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1784                                                  
1785  ***      7            50      7            49   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 17   
               7                                105   
1786                                                  
1787                                                  sub new {
1788           2                    2            13      my ( $class, @opts ) = @_;
1789           2                                 52      my $self = {
1790                                                        opts => {
1791                                                           A => {
1792                                                              desc => 'Default character set',
1793                                                              dsn  => 'charset',
1794                                                              copy => 1,
1795                                                           },
1796                                                           D => {
1797                                                              desc => 'Database to use',
1798                                                              dsn  => 'database',
1799                                                              copy => 1,
1800                                                           },
1801                                                           F => {
1802                                                              desc => 'Only read default options from the given file',
1803                                                              dsn  => 'mysql_read_default_file',
1804                                                              copy => 1,
1805                                                           },
1806                                                           h => {
1807                                                              desc => 'Connect to host',
1808                                                              dsn  => 'host',
1809                                                              copy => 1,
1810                                                           },
1811                                                           p => {
1812                                                              desc => 'Password to use when connecting',
1813                                                              dsn  => 'password',
1814                                                              copy => 1,
1815                                                           },
1816                                                           P => {
1817                                                              desc => 'Port number to use for connection',
1818                                                              dsn  => 'port',
1819                                                              copy => 1,
1820                                                           },
1821                                                           S => {
1822                                                              desc => 'Socket file to use for connection',
1823                                                              dsn  => 'mysql_socket',
1824                                                              copy => 1,
1825                                                           },
1826                                                           u => {
1827                                                              desc => 'User for login if not current user',
1828                                                              dsn  => 'user',
1829                                                              copy => 1,
1830                                                           },
1831                                                        },
1832                                                     };
1833           2                                 10      foreach my $opt ( @opts ) {
1834  ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
1835  ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1836                                                     }
1837           2                                 26      return bless $self, $class;
1838                                                  }
1839                                                  
1840                                                  sub prop {
1841           6                    6            30      my ( $self, $prop, $value ) = @_;
1842  ***      6     50                          30      if ( @_ > 2 ) {
1843  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1844  ***      0                                  0         $self->{$prop} = $value;
1845                                                     }
1846           6                                 46      return $self->{$prop};
1847                                                  }
1848                                                  
1849                                                  sub parse {
1850           2                    2            79      my ( $self, $dsn, $prev, $defaults ) = @_;
1851  ***      2     50                          10      if ( !$dsn ) {
1852  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1853  ***      0                                  0         return;
1854                                                     }
1855           2                                  4      MKDEBUG && _d('Parsing', $dsn);
1856  ***      2            50                   10      $prev     ||= {};
1857  ***      2            50                    8      $defaults ||= {};
1858           2                                  6      my %given_props;
1859           2                                  4      my %final_props;
1860           2                                  6      my %opts = %{$self->{opts}};
               2                                 18   
1861                                                  
1862           2                                 18      foreach my $dsn_part ( split(/,/, $dsn) ) {
1863  ***      8     50                          73         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1864           8                                 35            $given_props{$prop_key} = $prop_val;
1865                                                        }
1866                                                        else {
1867  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1868  ***      0                                  0            $given_props{h} = $dsn_part;
1869                                                        }
1870                                                     }
1871                                                  
1872           2                                 12      foreach my $key ( keys %opts ) {
1873          16                                 32         MKDEBUG && _d('Finding value for', $key);
1874          16                                 53         $final_props{$key} = $given_props{$key};
1875  ***     16     50     66                  125         if (   !defined $final_props{$key}
      ***                   33                        
1876                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1877                                                        {
1878  ***      0                                  0            $final_props{$key} = $prev->{$key};
1879  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1880                                                        }
1881          16    100                          66         if ( !defined $final_props{$key} ) {
1882           8                                 26            $final_props{$key} = $defaults->{$key};
1883           8                                 22            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1884                                                        }
1885                                                     }
1886                                                  
1887           2                                 10      foreach my $key ( keys %given_props ) {
1888  ***      8     50                          34         die "Unrecognized DSN part '$key' in '$dsn'\n"
1889                                                           unless exists $opts{$key};
1890                                                     }
1891  ***      2     50                          11      if ( (my $required = $self->prop('required')) ) {
1892  ***      0                                  0         foreach my $key ( keys %$required ) {
1893  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1894                                                        }
1895                                                     }
1896                                                  
1897           2                                 14      return \%final_props;
1898                                                  }
1899                                                  
1900                                                  sub parse_options {
1901  ***      0                    0             0      my ( $self, $o ) = @_;
1902  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1903  ***      0                                  0      my $dsn_string
1904                                                        = join(',',
1905  ***      0      0                           0             map  { "$_=".$o->get($_); }
1906  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1907  ***      0                                  0             keys %{$self->{opts}}
1908                                                          );
1909  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1910  ***      0                                  0      return $self->parse($dsn_string);
1911                                                  }
1912                                                  
1913                                                  sub as_string {
1914  ***      0                    0             0      my ( $self, $dsn ) = @_;
1915  ***      0      0                           0      return $dsn unless ref $dsn;
1916  ***      0      0                           0      return join(',',
1917  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1918  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1919                                                        sort keys %$dsn );
1920                                                  }
1921                                                  
1922                                                  sub usage {
1923  ***      0                    0             0      my ( $self ) = @_;
1924  ***      0                                  0      my $usage
1925                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1926                                                        . "  KEY  COPY  MEANING\n"
1927                                                        . "  ===  ====  =============================================\n";
1928  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1929  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1930  ***      0      0      0                    0         $usage .= "  $key    "
1931                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1932                                                               .  ($opts{$key}->{desc} || '[No description]')
1933                                                               . "\n";
1934                                                     }
1935  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1936  ***      0                                  0      return $usage;
1937                                                  }
1938                                                  
1939                                                  sub get_cxn_params {
1940           2                    2            23      my ( $self, $info ) = @_;
1941           2                                  6      my $dsn;
1942           2                                  6      my %opts = %{$self->{opts}};
               2                                 17   
1943  ***      2            50                    9      my $driver = $self->prop('dbidriver') || '';
1944  ***      2     50                          10      if ( $driver eq 'Pg' ) {
1945  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1946  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1947  ***      0             0                    0                        grep { defined $info->{$_} }
1948                                                                       qw(h P));
1949                                                     }
1950                                                     else {
1951           4                                 30         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1952          10                                 37            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1953  ***      2            50                   24                        grep { defined $info->{$_} }
1954                                                                       qw(F h P S A))
1955                                                           . ';mysql_read_default_group=client';
1956                                                     }
1957           2                                  6      MKDEBUG && _d($dsn);
1958           2                                 16      return ($dsn, $info->{u}, $info->{p});
1959                                                  }
1960                                                  
1961                                                  sub fill_in_dsn {
1962  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1963  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1964  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1965  ***      0                                  0      $user =~ s/@.*//;
1966  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1967  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1968  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1969  ***      0             0                    0      $dsn->{u} ||= $user;
1970  ***      0             0                    0      $dsn->{D} ||= $db;
1971                                                  }
1972                                                  
1973                                                  sub get_dbh {
1974           2                    2            12      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1975  ***      2            50                   10      $opts ||= {};
1976  ***      2     50                          21      my $defaults = {
1977                                                        AutoCommit         => 0,
1978                                                        RaiseError         => 1,
1979                                                        PrintError         => 0,
1980                                                        ShowErrorStatement => 1,
1981                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1982                                                     };
1983           2                                 10      @{$defaults}{ keys %$opts } = values %$opts;
               2                                  8   
1984                                                  
1985  ***      2     50                           9      if ( !$have_dbi ) {
1986  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1987                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1988                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1989                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1990                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1991                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1992                                                  
1993                                                     }
1994                                                  
1995           2                                  7      my $dbh;
1996           2                                  5      my $tries = 2;
1997  ***      2            66                   26      while ( !$dbh && $tries-- ) {
1998                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1999           2                                  4            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
2000                                                  
2001           2                                  7         eval {
2002           2                                 13            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
2003                                                  
2004  ***      2     50                          23            if ( $cxn_string =~ m/mysql/i ) {
2005           2                                  6               my $sql;
2006                                                  
2007           2                                  8               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
2008                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
2009           2                                  5               MKDEBUG && _d($dbh, ':', $sql);
2010           2                                285               $dbh->do($sql);
2011                                                  
2012  ***      2     50                          18               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
2013  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
2014  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
2015  ***      0                                  0                  $dbh->do($sql);
2016  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
2017  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
2018  ***      0      0                           0                     binmode(STDOUT, ':utf8')
2019                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
2020                                                                 }
2021                                                                 else {
2022  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
2023                                                                 }
2024                                                              }
2025                                                  
2026  ***      2     50                          14               if ( $self->prop('set-vars') ) {
2027  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
2028  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
2029  ***      0                                  0                  $dbh->do($sql);
2030                                                              }
2031                                                           }
2032                                                        };
2033  ***      2     50     33                   23         if ( !$dbh && $EVAL_ERROR ) {
2034  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
2035  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
2036  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
2037  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
2038                                                           }
2039                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
2040  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
2041                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
2042                                                                 . "the directories that Perl searches for DBD::mysql.  If "
2043                                                                 . "DBD::mysql is not installed, try:\n"
2044                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
2045                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
2046                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
2047                                                           }
2048  ***      0      0                           0            if ( !$tries ) {
2049  ***      0                                  0               die $EVAL_ERROR;
2050                                                           }
2051                                                        }
2052                                                     }
2053                                                  
2054           2                                  5      MKDEBUG && _d('DBH info: ',
2055                                                        $dbh,
2056                                                        Dumper($dbh->selectrow_hashref(
2057                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
2058                                                        'Connection info:',      $dbh->{mysql_hostinfo},
2059                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
2060                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
2061                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
2062                                                        '$DBI::VERSION:',        $DBI::VERSION,
2063                                                     );
2064                                                  
2065           2                                 16      return $dbh;
2066                                                  }
2067                                                  
2068                                                  sub get_hostname {
2069  ***      0                    0                    my ( $self, $dbh ) = @_;
2070  ***      0      0      0                           if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
2071  ***      0                                            return $host;
2072                                                     }
2073  ***      0                                         my ( $hostname, $one ) = $dbh->selectrow_array(
2074                                                        'SELECT /*!50038 @@hostname, */ 1');
2075  ***      0                                         return $hostname;
2076                                                  }
2077                                                  
2078                                                  sub disconnect {
2079  ***      0                    0                    my ( $self, $dbh ) = @_;
2080  ***      0                                         MKDEBUG && $self->print_active_handles($dbh);
2081  ***      0                                         $dbh->disconnect;
2082                                                  }
2083                                                  
2084                                                  sub print_active_handles {
2085  ***      0                    0                    my ( $self, $thing, $level ) = @_;
2086  ***      0             0                           $level ||= 0;
2087  ***      0      0      0                           printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
2088                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
2089                                                        or die "Cannot print: $OS_ERROR";
2090  ***      0                                         foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                      
      ***      0                                      
2091  ***      0                                            $self->print_active_handles( $handle, $level + 1 );
2092                                                     }
2093                                                  }
2094                                                  
2095                                                  sub copy {
2096  ***      0                    0                    my ( $self, $dsn_1, $dsn_2, %args ) = @_;
2097  ***      0      0                                  die 'I need a dsn_1 argument' unless $dsn_1;
2098  ***      0      0                                  die 'I need a dsn_2 argument' unless $dsn_2;
2099  ***      0                                         my %new_dsn = map {
2100  ***      0                                            my $key = $_;
2101  ***      0                                            my $val;
2102  ***      0      0                                     if ( $args{overwrite} ) {
2103  ***      0      0                                        $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
2104                                                        }
2105                                                        else {
2106  ***      0      0                                        $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
2107                                                        }
2108  ***      0                                            $key => $val;
2109  ***      0                                         } keys %{$self->{opts}};
2110  ***      0                                         return \%new_dsn;
2111                                                  }
2112                                                  
2113                                                  sub _d {
2114  ***      0                    0                    my ($package, undef, $line) = caller 0;
2115  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2116  ***      0                                              map { defined $_ ? $_ : 'undef' }
2117                                                          @_;
2118  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2119                                                  }
2120                                                  
2121                                                  1;
2122                                                  
2123                                                  # ###########################################################################
2124                                                  # End DSNParser package
2125                                                  # ###########################################################################
2126                                                  
2127                                                  # ###########################################################################
2128                                                  # MaatkitCommon package 5266
2129                                                  # ###########################################################################
2130                                                  package MaatkitCommon;
2131                                                  
2132                                                  
2133           7                    7            55   use strict;
               7                                 16   
               7                                 48   
2134           7                    7            44   use warnings FATAL => 'all';
               7                                 15   
               7                                 37   
2135                                                  
2136           7                    7            41   use English qw(-no_match_vars);
               7                                 20   
               7                                 35   
2137                                                  
2138                                                  require Exporter;
2139                                                  our @ISA         = qw(Exporter);
2140                                                  our %EXPORT_TAGS = ();
2141                                                  our @EXPORT      = qw();
2142                                                  our @EXPORT_OK   = qw(
2143                                                     _d
2144                                                     get_number_of_cpus
2145                                                  );
2146                                                  
2147  ***      7            50      7            46   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 18   
               7                                119   
2148                                                  
2149                                                  sub _d {
2150  ***      0                    0                    my ($package, undef, $line) = caller 0;
2151  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2152  ***      0                                              map { defined $_ ? $_ : 'undef' }
2153                                                          @_;
2154  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2155                                                  }
2156                                                  
2157                                                  sub get_number_of_cpus {
2158  ***      0                    0                    my ( $sys_info ) = @_;
2159  ***      0                                         my $n_cpus; 
2160                                                  
2161  ***      0                                         my $cpuinfo;
2162  ***      0      0      0                           if ( $sys_info || (open $cpuinfo, "<", "/proc/cpuinfo") ) {
2163  ***      0                                            local $INPUT_RECORD_SEPARATOR = undef;
2164  ***      0             0                              my $contents = $sys_info || <$cpuinfo>;
2165  ***      0                                            MKDEBUG && _d('sys info:', $contents);
2166  ***      0      0                                     close $cpuinfo if $cpuinfo;
2167  ***      0                                            $n_cpus = scalar( map { $_ } $contents =~ m/(processor)/g );
      ***      0                                      
2168  ***      0                                            MKDEBUG && _d('Got', $n_cpus, 'cpus from /proc/cpuinfo');
2169  ***      0      0                                     return $n_cpus if $n_cpus;
2170                                                     }
2171                                                  
2172                                                  
2173  ***      0      0      0                           if ( $sys_info || ($OSNAME =~ m/freebsd/i) || ($OSNAME =~ m/darwin/i) ) { 
      ***                    0                        
2174  ***      0             0                              my $contents = $sys_info || `sysctl hw.ncpu`;
2175  ***      0                                            MKDEBUG && _d('sys info:', $contents);
2176  ***      0      0                                     ($n_cpus) = $contents =~ m/(\d)/ if $contents;
2177  ***      0                                            MKDEBUG && _d('Got', $n_cpus, 'cpus from sysctl hw.ncpu');
2178  ***      0      0                                     return $n_cpus if $n_cpus;
2179                                                     } 
2180                                                  
2181  ***      0             0                           $n_cpus ||= $ENV{NUMBER_OF_PROCESSORS};
2182                                                  
2183  ***      0             0                           return $n_cpus || 1; # There has to be at least 1 CPU.
2184                                                  }
2185                                                  
2186                                                  1;
2187                                                  
2188                                                  # ###########################################################################
2189                                                  # End MaatkitCommon package
2190                                                  # ###########################################################################
2191                                                  
2192                                                  # ###########################################################################
2193                                                  # Daemon package 5266
2194                                                  # ###########################################################################
2195                                                  
2196                                                  package Daemon;
2197                                                  
2198           7                    7            50   use strict;
               7                                 20   
               7                                 34   
2199           7                    7            41   use warnings FATAL => 'all';
               7                                 17   
               7                                 33   
2200                                                  
2201           7                    7            43   use POSIX qw(setsid);
               7                                 14   
               7                                 67   
2202           7                    7            41   use English qw(-no_match_vars);
               7                                 17   
               7                                 38   
2203                                                  
2204  ***      7            50      7            47   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 18   
               7                                 92   
2205                                                  
2206                                                  sub new {
2207  ***      0                    0                    my ( $class, %args ) = @_;
2208  ***      0                                         foreach my $arg ( qw(o) ) {
2209  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2210                                                     }
2211  ***      0                                         my $o = $args{o};
2212  ***      0      0                                  my $self = {
      ***             0                               
2213                                                        o        => $o,
2214                                                        log_file => $o->has('log') ? $o->get('log') : undef,
2215                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
2216                                                     };
2217                                                  
2218  ***      0                                         check_PID_file(undef, $self->{PID_file});
2219                                                  
2220  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
2221  ***      0                                         return bless $self, $class;
2222                                                  }
2223                                                  
2224                                                  sub daemonize {
2225  ***      0                    0                    my ( $self ) = @_;
2226                                                  
2227  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
2228  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
2229  ***      0      0                                  if ( $pid ) {
2230  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
2231  ***      0                                            exit;
2232                                                     }
2233                                                  
2234  ***      0                                         $self->{child} = 1;
2235                                                  
2236  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2237  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
2238                                                  
2239  ***      0                                         $self->_make_PID_file();
2240                                                  
2241  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
2242                                                  
2243  ***      0      0                                  if ( -t STDIN ) {
2244  ***      0                                            close STDIN;
2245  ***      0      0                                     open  STDIN, '/dev/null'
2246                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
2247                                                     }
2248                                                  
2249  ***      0      0                                  if ( $self->{log_file} ) {
2250  ***      0                                            close STDOUT;
2251  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
2252                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
2253                                                  
2254  ***      0                                            close STDERR;
2255  ***      0      0                                     open  STDERR, ">&STDOUT"
2256                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
2257                                                     }
2258                                                     else {
2259  ***      0      0                                     if ( -t STDOUT ) {
2260  ***      0                                               close STDOUT;
2261  ***      0      0                                        open  STDOUT, '>', '/dev/null'
2262                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
2263                                                        }
2264  ***      0      0                                     if ( -t STDERR ) {
2265  ***      0                                               close STDERR;
2266  ***      0      0                                        open  STDERR, '>', '/dev/null'
2267                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
2268                                                        }
2269                                                     }
2270                                                  
2271  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
2272  ***      0                                         return;
2273                                                  }
2274                                                  
2275                                                  sub check_PID_file {
2276  ***      0                    0                    my ( $self, $file ) = @_;
2277  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
2278  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
2279  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
2280  ***      0                                            my $pid;
2281  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
2282  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
2283  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
2284  ***      0      0                                     if ( $pid ) {
2285  ***      0                                               my $pid_is_alive = kill 0, $pid;
2286  ***      0      0                                        if ( $pid_is_alive ) {
2287  ***      0                                                  die "The PID file $PID_file already exists "
2288                                                                 . " and the PID that it contains, $pid, is running";
2289                                                           }
2290                                                           else {
2291  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
2292                                                                 . "contains, $pid, is not running";
2293                                                           }
2294                                                        }
2295                                                        else {
2296  ***      0                                               die "The PID file $PID_file already exists but it does not "
2297                                                              . "contain a PID";
2298                                                        }
2299                                                     }
2300                                                     else {
2301  ***      0                                            MKDEBUG && _d('No PID file');
2302                                                     }
2303  ***      0                                         return;
2304                                                  }
2305                                                  
2306                                                  sub make_PID_file {
2307  ***      0                    0                    my ( $self ) = @_;
2308  ***      0      0                                  if ( exists $self->{child} ) {
2309  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
2310                                                     }
2311  ***      0                                         $self->_make_PID_file();
2312  ***      0                                         $self->{rm_PID_file} = 1;
2313  ***      0                                         return;
2314                                                  }
2315                                                  
2316                                                  sub _make_PID_file {
2317  ***      0                    0                    my ( $self ) = @_;
2318                                                  
2319  ***      0                                         my $PID_file = $self->{PID_file};
2320  ***      0      0                                  if ( !$PID_file ) {
2321  ***      0                                            MKDEBUG && _d('No PID file to create');
2322  ***      0                                            return;
2323                                                     }
2324                                                  
2325  ***      0                                         $self->check_PID_file();
2326                                                  
2327  ***      0      0                                  open my $PID_FH, '>', $PID_file
2328                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
2329  ***      0      0                                  print $PID_FH $PID
2330                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
2331  ***      0      0                                  close $PID_FH
2332                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
2333                                                  
2334  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
2335  ***      0                                         return;
2336                                                  }
2337                                                  
2338                                                  sub _remove_PID_file {
2339  ***      0                    0                    my ( $self ) = @_;
2340  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
2341  ***      0      0                                     unlink $self->{PID_file}
2342                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
2343  ***      0                                            MKDEBUG && _d('Removed PID file');
2344                                                     }
2345                                                     else {
2346  ***      0                                            MKDEBUG && _d('No PID to remove');
2347                                                     }
2348  ***      0                                         return;
2349                                                  }
2350                                                  
2351                                                  sub DESTROY {
2352  ***      0                    0                    my ( $self ) = @_;
2353  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
2354  ***      0                                         return;
2355                                                  }
2356                                                  
2357                                                  sub _d {
2358  ***      0                    0                    my ($package, undef, $line) = caller 0;
2359  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2360  ***      0                                              map { defined $_ ? $_ : 'undef' }
2361                                                          @_;
2362  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2363                                                  }
2364                                                  
2365                                                  1;
2366                                                  
2367                                                  # ###########################################################################
2368                                                  # End Daemon package
2369                                                  # ###########################################################################
2370                                                  
2371                                                  # ###########################################################################
2372                                                  # This is a combination of modules and programs in one -- a runnable module.
2373                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2374                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2375                                                  #
2376                                                  # Check at the end of this package for the call to main() which actually runs
2377                                                  # the program.
2378                                                  # ###########################################################################
2379                                                  package mk_log_player;
2380                                                  
2381           7                    7            57   use POSIX;
               7                                 23   
               7                                 41   
2382           7                    7            61   use Time::HiRes qw(time usleep);
               7                                 19   
               7                                 52   
2383           7                    7            49   use File::Basename qw(dirname);
               7                                 16   
               7                                 84   
2384           7                    7            45   use File::Find;
               7                                 18   
               7                                 61   
2385           7                    7            43   use File::Spec;
               7                                 18   
               7                                 65   
2386           7                    7            42   use List::Util qw(max);
               7                                 15   
               7                                 38   
2387           7                    7            43   use Data::Dumper;
               7                                 21   
               7                                 39   
2388                                                  $Data::Dumper::Indent    = 1;
2389                                                  $Data::Dumper::Sortkeys  = 1;
2390                                                  $Data::Dumper::Quotekeys = 0;
2391                                                  
2392           7                    7            41   use English qw(-no_match_vars);
               7                                 16   
               7                                 45   
2393                                                  
2394  ***      7            50      7            46   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 18   
               7                                 96   
2395                                                  
2396                                                  my $o;
2397                                                  my $dp;
2398                                                  
2399                                                  
2400                                                  
2401                                                  sub main {
2402  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
2403                                                  
2404                                                     # #########################################################################
2405                                                     # Get configuration information.
2406                                                     # #########################################################################
2407  ***      0                                         $dp = new DSNParser(); 
2408  ***      0                                         $o  = new OptionParser(
2409                                                        strict      => 0,
2410                                                        prompt      => '[OPTIONS]... [DSN]',
2411                                                        description => q{splits and plays slow log files.},
2412                                                        dp          => $dp,
2413                                                     );
2414  ***      0                                         $o->get_specs();
2415  ***      0                                         $o->get_opts();
2416                                                  
2417  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
2418                                                  
2419                                                     # LogSplitter will override the split attribute if split_random is true.
2420                                                     # Set --split to some arbitrary value so we don't have to check for both
2421                                                     # and --play will not be invoked.
2422  ***      0      0                                  $o->set('split', 'random') if $o->get('split-random');
2423                                                  
2424                                                     # If not --split then the remaining arg should be a DSN for --play.
2425  ***      0                                         my $dsn;
2426  ***      0      0      0                           if ( !$o->get('split') && !$o->get('print') ) {
2427  ***      0                                            my $dsn_defaults = $dp->parse_options($o);
2428  ***      0      0                                     $dsn = @ARGV ? $dp->parse(shift @ARGV, $dsn_defaults) : $dsn_defaults;
2429  ***      0      0                                     if ( !$dsn ) {
2430  ***      0                                               $o->save_error('Missing or invalid host');
2431                                                        }
2432                                                     }
2433                                                  
2434  ***      0      0                                  if ( !-d $o->get('base-dir') ) {
2435  ***      0                                            $o->save_error('Invalid --base-dir: '
2436                                                           . $o->get('base-dir') . ' is not a directory');
2437                                                     }
2438                                                  
2439  ***      0      0                                  $o->set('threads', max(2, MaatkitCommon::get_number_of_cpus()))
2440                                                        unless $o->got('threads');
2441                                                  
2442  ***      0                                         $o->usage_or_errors();
2443                                                  
2444                                                     # ########################################################################
2445                                                     # If --pid, check it first since we'll die if it already exits.
2446                                                     # ########################################################################
2447  ***      0                                         my $daemon;
2448  ***      0      0                                  if ( $o->get('pid') ) {
2449                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
2450                                                        # in the the scope of main() because when it's destroyed it automatically
2451                                                        # removes the PID file.
2452  ***      0                                            $daemon = new Daemon(o=>$o);
2453  ***      0                                            $daemon->make_PID_file();
2454                                                     }
2455                                                  
2456                                                     # #########################################################################
2457                                                     # Split the logs into session files and exit.
2458                                                     # #########################################################################
2459  ***      0                                         my $split  = $o->get('split');
2460  ***      0                                         my $base_dir = $o->get('base-dir');
2461  ***      0      0                                  if ( $split ) {
2462  ***      0      0                                     die "$base_dir is not a directory" if !-d $base_dir;
2463                                                  
2464                                                        # It's sad because I wrote this script but I still frequently forget
2465                                                        # to specify the split attribute (Thread_id, etc.). So the log file
2466                                                        # is taken to be the split attrib and then LogSplitter tries to read
2467                                                        # from STDIN. This is my self-reminder.
2468  ***      0      0                                     warn "The --split attribute $split does not appear valid"
2469                                                           if $split !~ m/^[\w]+$/;
2470                                                  
2471  ***      0      0                                     $ARGV[0] = '-' if scalar @ARGV == 0; # causes LogSplitter to read STDIN
2472                                                  
2473  ***      0                                            my @callbacks;
2474  ***      0      0                                     if ( $o->get('filter') ) {
2475  ***      0                                               my $filter = $o->get('filter');
2476  ***      0      0      0                                 if ( -f $filter && -r $filter ) {
2477  ***      0                                                  MKDEBUG && _d('Reading file', $filter, 'for --filter code');
2478  ***      0      0                                           open my $fh, "<", $filter or die "Cannot open $filter: $OS_ERROR";
2479  ***      0                                                  $filter = do { local $/ = undef; <$fh> };
      ***      0                                      
      ***      0                                      
2480  ***      0                                                  close $fh;
2481                                                           }
2482                                                           else {
2483  ***      0                                                  $filter = "( $filter )";  # issue 565
2484                                                           }
2485  ***      0                                               my $code   = "sub { MKDEBUG && _d('callback: filter');  my(\$event) = shift; $filter && return \$event; };";
2486  ***      0                                               MKDEBUG && _d('--filter code:', $code);
2487  ***      0      0                                        my $sub = eval $code
2488                                                              or die "Error compiling --filter code: $code\n$EVAL_ERROR";
2489  ***      0                                               push @callbacks, $sub;
2490                                                        }
2491                                                  
2492  ***      0      0                                     my $parser = $o->get('type') eq 'slowlog' ? new SlowLogParser()
      ***             0                               
      ***             0                               
2493                                                                   : $o->get('type') eq 'binlog'  ? new BinaryLogParser()
2494                                                                   : $o->get('type') eq 'genlog'  ? new GeneralLogParser()
2495                                                                   : die("Unknown type " . $o->get('type'));
2496  ***      0                                            my $ls = new LogSplitter(
2497                                                           attribute      => $split,
2498                                                           split_random   => $o->get('split-random'),
2499                                                           base_dir       => $base_dir,
2500                                                           base_file_name => $o->get('base-file-name'),
2501                                                           max_sessions   => $o->get('max-sessions'),
2502                                                           session_files  => $o->get('session-files'),
2503                                                           quiet          => $o->get('quiet'),
2504                                                           verbose        => $o->get('verbose'),
2505                                                           parser         => $parser,
2506                                                           callbacks      => \@callbacks,
2507                                                        );
2508  ***      0                                            $ls->split(@ARGV);
2509                                                  
2510  ***      0                                            return 0;
2511                                                     }
2512                                                  
2513                                                     # #########################################################################
2514                                                     # Make list of session files to play. If playing a whole, the log is
2515                                                     # treated as one big session file.
2516                                                     # ######################################################################### 
2517  ***      0                                         my @session_files;
2518  ***      0                                         foreach my $session_file ( split ',', $o->get('play') ) {
2519                                                        # The session "file" might actually be a dir, in which case we
2520                                                        # read ALL files in that dir.
2521  ***      0      0                                     if ( -d $session_file ) {
2522  ***      0                                               MKDEBUG && _d('Reading all session log files in', $session_file);
2523  ***      0      0                                        opendir my $dir, $session_file
2524                                                              or die "Cannot open directory $session_file: $OS_ERROR";
2525  ***      0                                               push @session_files,
2526  ***      0                                                  map     { "$session_file/$_"    } # 3. Save full dir/file
2527  ***      0                                                  grep    { -f "$session_file/$_" } # 2. If it's a file
2528                                                              readdir $dir;                     # 1. Each file in dir
2529  ***      0                                               closedir $dir;
2530                                                        }
2531                                                        else {
2532  ***      0      0                                        if ( !-f $session_file ) {
2533  ***      0                                                  warn "$session_file is not a file";
2534                                                           }
2535                                                           else {
2536  ***      0                                                  push @session_files, $session_file;
2537                                                           }
2538                                                        }
2539                                                     }
2540                                                  
2541  ***      0                                         MKDEBUG && _d('Session files:', @session_files);
2542                                                  
2543  ***      0      0                                  if ( @session_files == 0 ) {
2544  ***      0                                            warn 'No valid session files';
2545  ***      0                                            return 0;
2546                                                     }
2547                                                  
2548  ***      0                                         my $n_session_files = scalar @session_files;
2549  ***      0      0                                  print "Found $n_session_files session files.\n" unless $o->get('quiet');
2550                                                  
2551  ***      0      0                                  if ( $o->get('threads') > $n_session_files ) {
2552  ***      0                                            warn "--threads is greater than the number of session files.  "
2553                                                           . "Only $n_session_files concurrent process will be ran";
2554  ***      0                                            $o->set('threads', $n_session_files);
2555                                                     }
2556  ***      0                                         my $threads = $o->get('threads');
2557                                                  
2558  ***      0                                         my $files_per_child  = int( $n_session_files / $threads );
2559  ***      0      0                                  print "Each process will play $files_per_child multi-session files.\n"
2560                                                        unless $o->get('quiet');
2561                                                  
2562  ***      0                                         my @child_tasks;
2563  ***      0                                         my $n = 0;
2564  ***      0                                         for my $childno ( 0..($threads-1) ) {
2565  ***      0                                            my $i = 0;
2566  ***      0             0                              while ( $i++ < $files_per_child
2567                                                                && (my $session_file = pop @session_files) ) {
2568  ***      0                                               push @{$child_tasks[$childno]}, $session_file;
      ***      0                                      
2569  ***      0                                               $n++;
2570  ***      0      0      0                                 print "Process ", $childno+1, " assigned $session_file ($n)\n"
2571                                                              if $o->get('verbose') && !$o->get('quiet');
2572                                                        }
2573                                                     }
2574                                                  
2575                                                     # Shouldn't happen...
2576  ***      0      0                                  warn "There are unassigned session files" if @session_files > 0;
2577                                                  
2578                                                     # #########################################################################
2579                                                     # Connect parent to MySQL.
2580                                                     # #########################################################################
2581  ***      0                                         my $parent_dbh;
2582  ***      0      0                                  if ( !$o->get('print') ) {
2583  ***      0      0                                     if ( $o->get('ask-pass') ) {
2584  ***      0                                               $o->set('password', OptionParser::prompt_noecho("Enter password: "));
2585                                                        }
2586  ***      0                                            $parent_dbh = get_cxn($dsn);
2587  ***      0                                            $parent_dbh->{InactiveDestroy} = 1; # Don't die on fork().
2588                                                     }
2589                                                  
2590                                                     # #########################################################################
2591                                                     # Assign sessions to child processes.
2592                                                     # #########################################################################
2593  ***      0                                         my %children;
2594  ***      0                                         my %exited_children;
2595                                                     # This signal handler will do nothing but wake up the sleeping parent process
2596                                                     # and record the exit status and time of the child that exited (as a side
2597                                                     # effect of not discarding the signal).
2598                                                     # -- Presently, however, we do not use this information.
2599                                                     $SIG{CHLD} = sub {
2600  ***      0                    0                       my $pid;
2601  ***      0                                            while (($pid = waitpid(-1, POSIX::WNOHANG)) > 0) {
2602                                                           # Must right-shift to get the actual exit status of the child.
2603  ***      0                                               $exited_children{$pid}->{exit_status} = $CHILD_ERROR >> 8;
2604  ***      0                                               $exited_children{$pid}->{exit_time}   = time;
2605                                                        }
2606  ***      0                                         };
2607                                                  
2608                                                     # Fork the child processes.
2609  ***      0      0                                  print "Running processes...\n" unless $o->get('quiet');
2610  ***      0                                         for my $childno ( 0..($threads-1) ) {
2611  ***      0                                            my $child_tasks = $child_tasks[$childno];
2612                                                  
2613  ***      0                                            my $pid = fork();
2614  ***      0      0                                     die "Cannot fork process $childno: $OS_ERROR" unless defined $pid;
2615  ***      0      0                                     if ( $pid ) {              # I'm the parent.
2616  ***      0                                               $children{$pid} = $childno + 1;
2617                                                        }
2618                                                        else {                     # I'm the child.
2619  ***      0                                               $SIG{CHLD} = 'DEFAULT'; # See bug #1886444
2620  ***      0                                               MKDEBUG && _d('Child PID', $PID, 'started');
2621  ***      0                                               play_session($dsn, ($childno + 1), $child_tasks);
2622  ***      0                                               MKDEBUG && _d('Child PID', $PID, 'finished');
2623  ***      0                                               return 0;
2624                                                        }
2625                                                     } 
2626  ***      0      0                                  print "All processes are running; waiting for them to finish...\n"
2627                                                        unless $o->get('quiet');
2628                                                  
2629                                                     # Wait for and reap the child processes.
2630  ***      0                                         do {
2631                                                        # Possibly wait for child.
2632  ***      0                                            my $reaped = 0;
2633  ***      0                                            foreach my $pid ( keys %exited_children ) { 
2634  ***      0                                               $reaped = 1;
2635  ***      0      0                                        print "Process ", $children{$pid}, " finished with exit status ",
2636                                                              $exited_children{$pid}->{exit_status}, ".\n"
2637                                                              unless $o->get('quiet');
2638  ***      0                                               MKDEBUG && _d('Reaped child PID', $pid);
2639  ***      0                                               delete $children{$pid};
2640  ***      0                                               delete $exited_children{$pid};
2641                                                        }
2642                                                  
2643  ***      0      0      0                              if ( keys %children && !$reaped ) {
2644                                                           # Don't busy-wait.  But don't wait forever either, as a child may exit
2645                                                           # and signal while we're not sleeping, so if we sleep forever we may
2646                                                           # not get the signal.
2647  ***      0                                               MKDEBUG && _d('Sleeping to wait for children');
2648  ***      0                                               sleep 1;
2649                                                        }
2650  ***      0                                            MKDEBUG && _d(scalar keys %children, 'children are still working');
2651                                                  
2652                                                     } while ( keys %children );
2653                                                  
2654  ***      0      0                                  print "All processes have finished.\n" unless $o->get('quiet');
2655  ***      0                                         return 0;
2656                                                  }
2657                                                  
2658                                                  # #############################################################################
2659                                                  # Subroutines.
2660                                                  # #############################################################################
2661                                                  sub play_session {
2662  ***      0                    0                    my ( $dsn, $childno, $session_files ) = @_;
2663                                                  
2664  ***      0                                         my $query_time;
2665  ***      0                                         my $slowlog_fmt = "# Thread_id: %s  Query_time: %.6f  Schema: %s\n%s;\n";
2666  ***      0                                         my $only_select = $o->get('only-select');
2667  ***      0                                         my $warnings    = $o->get('warnings');
2668  ***      0                                         my $print       = $o->get('print');
2669  ***      0                                         my $results     = $o->get('results');
2670  ***      0      0                                  my $dbh         = get_cxn($dsn) unless $print;
2671                                                  
2672                                                     # Each thread writes to its own file because contention will not allow
2673                                                     # them all to write correctly to STDOUT at once.
2674  ***      0                                         my $base_dir    = $o->get('base-dir');
2675  ***      0                                         my $output_file = $o->get('base-dir')
2676                                                                     . '/'
2677                                                                     . $o->get('base-file-name') . "-results-$PID.txt";
2678  ***      0                                         my $output_fh;
2679  ***      0      0      0                           if ( $results || $print ) {
2680  ***      0      0                                     open $output_fh, '>', $output_file
2681                                                           or die "Cannot open $output_file for writing: $OS_ERROR";
2682  ***      0                                            MKDEBUG && _d('Proc', $childno, 'writing to', $output_file);
2683                                                     }
2684                                                     else {
2685  ***      0                                            MKDEBUG && _d('Proc', $childno, 'not writing results');
2686                                                     }
2687                                                  
2688  ***      0                                         local $INPUT_RECORD_SEPARATOR = '';
2689                                                  
2690                                                     ITERATION:
2691  ***      0                                         for my $iteration_n ( 1..$o->get('iterations') ) {
2692  ***      0                                            MKDEBUG && _d('Proc', $childno, 'starting iteration', $iteration_n);
2693                                                  
2694                                                        SESSION_FILE:
2695  ***      0                                            foreach my $session_file ( @$session_files ) {
2696  ***      0                                               my $session_fh;
2697  ***      0                                               my $session_n;
2698  ***      0      0                                        if ( !open $session_fh, '<', $session_file ) {
2699  ***      0                                                  warn "Cannot open session file $session_file: $OS_ERROR";
2700  ***      0                                                  next SESSION_FILE;
2701                                                           }
2702                                                  
2703  ***      0                                               my $db;
2704                                                           QUERY:
2705  ***      0                                               while ( my $query = <$session_fh> ) {
2706  ***      0      0                                           if ( $print ) {
2707  ***      0                                                     print $output_fh $query;
2708  ***      0                                                     next QUERY;
2709                                                              }
2710                                                  
2711  ***      0      0                                           if ( $query =~ m/^-- START SESSION (\S+)/ ) {
2712  ***      0                                                     $session_n = $1;
2713  ***      0                                                     next QUERY;
2714                                                              }
2715                                                  
2716  ***      0      0      0                                    if ( $only_select && $query !~ m/^(?:SELECT|USE) /i ) {
2717  ***      0                                                     MKDEBUG && _d('Skipping query for --only-select:', $query);
2718  ***      0                                                     next QUERY;
2719                                                              }
2720                                                  
2721  ***      0      0                                           if ( $query =~ m/^use (\S+)/ ) {
2722  ***      0                                                     $db = $1;
2723  ***      0                                                     eval { $dbh->do($query); };
      ***      0                                      
2724  ***      0      0      0                                       if ( $EVAL_ERROR && $warnings ) {
2725  ***      0                                                        warn_error($childno, $session_n, $query,$dbh->errstr());
2726                                                                 }
2727  ***      0                                                     next QUERY;
2728                                                              }
2729                                                  
2730  ***      0                                                  $query_time = time;
2731  ***      0                                                  eval { $dbh->do($query); };
      ***      0                                      
2732  ***      0      0      0                                    if ( $EVAL_ERROR && $warnings ) {
2733  ***      0                                                     warn_error($childno, $session_n, $query, $dbh->errstr());
2734  ***      0                                                     next QUERY;
2735                                                              }
2736                                                  
2737  ***      0      0                                           if ( $results ) {
2738  ***      0                                                     chomp $query;
2739  ***      0             0                                       printf $output_fh $slowlog_fmt,
2740                                                                    "$childno$session_n",
2741                                                                    time - $query_time,
2742                                                                    ($db || ''),
2743                                                                    $query;
2744                                                              }
2745                                                           } # QUERY
2746                                                  
2747  ***      0                                               MKDEBUG && _d('No more sessions in', $session_file);
2748  ***      0                                               close $session_fh;
2749                                                        } # SESSION_FILE
2750                                                     } # ITERATION
2751                                                  
2752  ***      0      0                                  close $output_fh if $output_fh;
2753  ***      0      0                                  $dbh->disconnect() if $dbh;
2754  ***      0                                         return;
2755                                                  }
2756                                                  
2757                                                  sub get_delay {
2758  ***      0                    0                    my ( $delay ) = @_;
2759  ***      0      0      0                           return 0 if !defined $delay || scalar @$delay == 0;
2760  ***      0                                         my $t = 0;
2761                                                  
2762  ***      0                                         my ( $from, $to ) = @$delay[0..1];
2763  ***      0      0                                  if ( defined $to ) {
2764  ***      0                                            $t = rand($to) + $from;
2765                                                     }
2766                                                     else {
2767  ***      0                                            $t = $from;
2768                                                     }
2769                                                  
2770                                                     # Return time is expressed in microseconds because this value
2771                                                     # is used with usleep() which takes a microsecond time value.
2772  ***      0                                         return $t *= 1_000_000;
2773                                                  }
2774                                                  
2775                                                  sub get_cxn {
2776  ***      0                    0                    my ( $dsn ) = @_;
2777  ***      0                                         return $dp->get_dbh( $dp->get_cxn_params($dsn) );
2778                                                  }
2779                                                  
2780                                                  sub warn_error {
2781  ***      0                    0                    my ( $childno, $session_n, $query, $warning ) = @_;
2782  ***      0                                         warn "Query '$query' in proc $childno session $session_n caused an error: "
2783                                                        . "$warning\n";
2784  ***      0                                         return;
2785                                                  }
2786                                                   
2787                                                  sub _d {
2788  ***      0                    0                    my ($package, undef, $line) = caller 0;
2789  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2790  ***      0                                              map { defined $_ ? $_ : 'undef' }
2791                                                          @_;
2792  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2793                                                  }
2794                                                  
2795                                                  # ############################################################################
2796                                                  # Run the program.
2797                                                  # ############################################################################
2798                                                  if ( !caller ) { exit main(@ARGV); }
2799                                                  
2800                                                  1; # Because this is a module as well as a script.
2801                                                  
2802                                                  # ############################################################################
2803                                                  # Documentation.
2804                                                  # ############################################################################
2805                                                  
2806                                                  =pod
2807                                                  
2808                                                  =head1 NAME
2809                                                  
2810                                                  mk-log-player - Split and play MySQL slow logs.
2811                                                  
2812                                                  =head1 SYNOPSIS
2813                                                  
2814                                                  Split slow.log on Thread_id into 16 session files, save in ./sessions:
2815                                                  
2816                                                    mk-log-player --split Thread_id --session-files 16 --base-dir ./sessions slow.log
2817                                                  
2818                                                  Play all those sessions on host1, save results in ./results:
2819                                                  
2820                                                    mk-log-player --play ./sessions --base-dir ./results h=host1
2821                                                  
2822                                                  Use L<mk-query-digest> to summarize the results:
2823                                                  
2824                                                    mk-query-digest ./results/*
2825                                                  
2826                                                  =head1 RISKS
2827                                                  
2828                                                  The following section is included to inform users about the potential risks,
2829                                                  whether known or unknown, of using this tool.  The two main categories of risks
2830                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2831                                                  tools) and those created by bugs.
2832                                                  
2833                                                  L<"--play"> is meant to load a server as much as possible, for stress-testing
2834                                                  purposes.  It is not designed to be used on production servers.
2835                                                  
2836                                                  At the time of this release, we know of no bugs that could cause serious harm to
2837                                                  users.
2838                                                  
2839                                                  The authoritative source for updated information is always the online issue
2840                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2841                                                  see a list of such issues at the following URL:
2842                                                  L<http://www.maatkit.org/bugs/mk-log-player>.
2843                                                  
2844                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2845                                                  
2846                                                  =head1 DESCRIPTION
2847                                                  
2848                                                  mk-log-player does two things: it splits MySQL slow logs into session files
2849                                                  and it plays (executes) queries in session files on a MySQL server.  Only
2850                                                  session files can be played; slow logs cannot be played directly without
2851                                                  being split.
2852                                                  
2853                                                  A session is a group of queries from the slow log that all share a common
2854                                                  attribute, usually Thead_id.  The common attribute is specified with
2855                                                  L<"--split">.  Multiple sessions are saved into a single sesssion file.
2856                                                  See L<"--session-files">, L<"--max-sessions">, L<"--base-file-name"> and
2857                                                  L<"--base-dir">.  These session files are played with L<"--play">.
2858                                                  
2859                                                  mk-log-player will L<"--play"> session files in parallel using N number of
2860                                                  L<"--threads">.  (They're not technically threads, but we call them that
2861                                                  anyway.)  Each thread will play all the sessions in its given session files.
2862                                                  The sessions are played as fast as possible--there are no delays--because the
2863                                                  goal is to stress-test and load-test the server.  So be careful using this
2864                                                  script on a production server!
2865                                                  
2866                                                  Each L<"--play"> thread writes its results to a separate file.  These result
2867                                                  files are in slow log format so they can be aggregated and summarized with
2868                                                  L<mk-query-digest>.  See L<"OUTPUT">.
2869                                                  
2870                                                  =head1 OUTPUT
2871                                                  
2872                                                  Both L<"--split"> and L<"--play"> have two outputs: status messages printed to
2873                                                  STDOUT to let you know what the script is doing, and session or result files
2874                                                  written to separate files saved in L<"--base-dir">.  You can suppress all
2875                                                  output to STDOUT for each with L<"--quiet">, or increase output with
2876                                                  L<"--verbose">.
2877                                                  
2878                                                  The session files written by L<"--split"> are simple text files containing
2879                                                  queries grouped into sessions.  For example:
2880                                                  
2881                                                    -- START SESSION 10
2882                                                  
2883                                                    use foo
2884                                                  
2885                                                    SELECT col FROM foo_tbl
2886                                                  
2887                                                  The format of these session files is important: each query must be a single
2888                                                  line separated by a single blank line.  And the "-- START SESSION" comment
2889                                                  tells mk-log-player where individual sessions begin and end so that L<"--play">
2890                                                  can correctly fake Thread_id in its result files.
2891                                                  
2892                                                  The result files written by L<"--play"> are in slow log format with a minimal
2893                                                  header: the only attributes printed are Thread_id, Query_time and Schema.
2894                                                  
2895                                                  =head1 OPTIONS
2896                                                  
2897                                                  Specify at least one of L<"--play">, L<"--split"> or L<"--split-random">.
2898                                                  
2899                                                  L<"--play"> and L<"--split"> are mutually exclusive.
2900                                                  
2901                                                  =over
2902                                                  
2903                                                  =item --ask-pass
2904                                                  
2905                                                  group: Play
2906                                                  
2907                                                  Prompt for a password when connecting to MySQL.
2908                                                  
2909                                                  =item --base-dir
2910                                                  
2911                                                  type: string; default: ./
2912                                                  
2913                                                  Base directory for L<"--split"> session files and L<"--play"> result file.
2914                                                  
2915                                                  =item --base-file-name
2916                                                  
2917                                                  type: string; default: session
2918                                                  
2919                                                  Base file name for L<"--split"> session files and L<"--play"> result file.
2920                                                  
2921                                                  Each L<"--split"> session file will be saved as <base-file-name>-N.txt, where
2922                                                  N is a four digit, zero-padded session ID.  For example: session-0003.txt.
2923                                                  
2924                                                  Each L<"--play"> result file will be saved as <base-file-name>-results-PID.txt,
2925                                                  where PID is the process ID of the executing thread.
2926                                                  
2927                                                  All files are saved in L<"--base-dir">.
2928                                                  
2929                                                  =item --charset
2930                                                  
2931                                                  group: Play
2932                                                  
2933                                                  short form: -A; type: string
2934                                                  
2935                                                  Default character set.  If the value is utf8, sets Perl's binmode on STDOUT to
2936                                                  utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET NAMES UTF8
2937                                                  after connecting to MySQL.  Any other value sets binmode on STDOUT without the
2938                                                  utf8 layer, and runs SET NAMES after connecting to MySQL.
2939                                                  
2940                                                  =item --config
2941                                                  
2942                                                  type: Array
2943                                                  
2944                                                  Read this comma-separated list of config files; if specified, this must be the
2945                                                  first option on the command line.
2946                                                  
2947                                                  =item --defaults-file
2948                                                  
2949                                                  short form: -F; type: string
2950                                                  
2951                                                  Only read mysql options from the given file.
2952                                                  
2953                                                  =item --filter
2954                                                  
2955                                                  type: string; group: Split
2956                                                  
2957                                                  Discard events for which this Perl code doesn't return true.
2958                                                  
2959                                                  This option is a string of Perl code or a file containing Perl code that gets
2960                                                  compiled into a subroutine with one argument: $event.  This is a hashref.
2961                                                  If the given value is a readable file, then mk-log-player reads the entire
2962                                                  file and uses its contents as the code.  The file should not contain
2963                                                  a shebang (#!/usr/bin/perl) line.
2964                                                  
2965                                                  If the code returns true, the query is split; otherwise it is discarded.
2966                                                  The code is the last statement in the subroutine other than C<return $event>. 
2967                                                  The subroutine template is:
2968                                                  
2969                                                    sub { $event = shift; filter && return $event; }
2970                                                  
2971                                                  Filters given on the command line are wrapped inside parentheses like like
2972                                                  C<( filter )>.  For complex, multi-line filters, you must put the code inside
2973                                                  a file so it will not be wrapped inside parentheses.  Either way, the filter
2974                                                  must produce syntactically valid code given the template.  For example, an
2975                                                  if-else branch given on the command line would not be valid:
2976                                                  
2977                                                    --filter 'if () { } else { }'  # WRONG
2978                                                  
2979                                                  Since it's given on the command line, the if-else branch would be wrapped inside
2980                                                  parentheses which is not syntactically valid.  So to accomplish something more
2981                                                  complex like this would require putting the code in a file, for example
2982                                                  filter.txt:
2983                                                  
2984                                                    my $event_ok; if (...) { $event_ok=1; } else { $event_ok=0; } $event_ok
2985                                                  
2986                                                  Then specify C<--filter filter.txt> to read the code from filter.txt.
2987                                                  
2988                                                  If the filter code won't compile, mk-log-player will die with an error.
2989                                                  If the filter code does compile, an error may still occur at runtime if the
2990                                                  code tries to do something wrong (like pattern match an undefined value).
2991                                                  mk-log-player does not provide any safeguards so code carefully!
2992                                                  
2993                                                  An example filter that discards everything but SELECT statements:
2994                                                  
2995                                                    --filter '$event->{arg} =~ m/^select/i'
2996                                                  
2997                                                  This is compiled into a subroutine like the following:
2998                                                  
2999                                                    sub { $event = shift; ( $event->{arg} =~ m/^select/i ) && return $event; }
3000                                                  
3001                                                  You can find an explanation of the structure of $event at
3002                                                  L<http://code.google.com/p/maatkit/wiki/EventAttributes>.
3003                                                  
3004                                                  =item --help
3005                                                  
3006                                                  Show help and exit.
3007                                                  
3008                                                  =item --host
3009                                                  
3010                                                  short form: -h; type: string; group: Play
3011                                                  
3012                                                  Connect to host.
3013                                                  
3014                                                  =item --iterations
3015                                                  
3016                                                  type: int; default: 1; group: Play
3017                                                  
3018                                                  How many times each thread should play all its session files.
3019                                                  
3020                                                  =item --max-sessions
3021                                                  
3022                                                  type: int; default: 5000000; group: Split
3023                                                  
3024                                                  Maximum number of sessions to L<"--split">.
3025                                                  
3026                                                  By default, C<mk-log-player> tries to split every session from the log file.
3027                                                  For huge logs, however, this can result in millions of sessions.  This
3028                                                  option causes only the first N number of sessions to be saved.  All sessions
3029                                                  after this number are ignored, but sessions split before this number will
3030                                                  continue to have their queries split even if those queries appear near the end
3031                                                  of the log and after this number has been reached.
3032                                                  
3033                                                  =item --only-select
3034                                                  
3035                                                  group: Play
3036                                                  
3037                                                  Play only SELECT and USE queries; ignore all others.
3038                                                  
3039                                                  =item --password
3040                                                  
3041                                                  short form: -p; type: string; group: Play
3042                                                  
3043                                                  Password to use when connecting.
3044                                                  
3045                                                  =item --pid
3046                                                  
3047                                                  type: string
3048                                                  
3049                                                  Create the given PID file.  The file contains the process ID of the script.
3050                                                  The PID file is removed when the script exits.  Before starting, the script
3051                                                  checks if the PID file already exists.  If it does not, then the script creates
3052                                                  and writes its own PID to it.  If it does, then the script checks the following:
3053                                                  if the file contains a PID and a process is running with that PID, then
3054                                                  the script dies; or, if there is no process running with that PID, then the
3055                                                  script overwrites the file with its own PID and starts; else, if the file
3056                                                  contains no PID, then the script dies.
3057                                                  
3058                                                  =item --play
3059                                                  
3060                                                  type: string; group: Play
3061                                                  
3062                                                  Play (execute) session files created by L<"--split">.
3063                                                  
3064                                                  The argument to play must be a commaxn-separated list of session files
3065                                                  created by L<"--split"> or a directory.  If the argument is a directory,
3066                                                  ALL files in that directory will be played.
3067                                                  
3068                                                  =item --port
3069                                                  
3070                                                  short form: -P; type: int; group: Play
3071                                                  
3072                                                  Port number to use for connection.
3073                                                  
3074                                                  =item --print
3075                                                  
3076                                                  group: Play
3077                                                  
3078                                                  Print queries instead of playing them; requires L<"--play">.
3079                                                  
3080                                                  You must also specify L<"--play"> with L<"--print">.  Although the queries
3081                                                  will not be executed, L<"--play"> is required to specify which session files to
3082                                                  read.
3083                                                  
3084                                                  =item --quiet
3085                                                  
3086                                                  Do not print anything.
3087                                                  
3088                                                  =item --[no]results
3089                                                  
3090                                                  default: yes
3091                                                  
3092                                                  Print L<"--play"> results to files in L<"--base-dir">.
3093                                                  
3094                                                  =item --session-files
3095                                                  
3096                                                  type: int; default: 8; group: Split
3097                                                  
3098                                                  Number of session files to create with L<"--split">.
3099                                                  
3100                                                  The number of session files should either be equal to the number of
3101                                                  L<"--threads"> you intend to L<"--play"> or be an even multiple of
3102                                                  L<"--threads">.  This number is important for maximum performance because it:
3103                                                    * allows each thread to have roughly the same amount of sessions to play
3104                                                    * avoids having to open/close many session files
3105                                                    * avoids disk IO overhead by doing large sequential reads
3106                                                  
3107                                                  You may want to increase this number beyond L<"--threads"> if each session
3108                                                  file becomes too large.  For example, splitting a 20G log into 8 sessions
3109                                                  files may yield roughly eight 2G session files.
3110                                                  
3111                                                  See also L<"--max-sessions">.
3112                                                  
3113                                                  
3114                                                  =item --set-vars
3115                                                  
3116                                                  type: string; group: Play; default: wait_timeout=10000
3117                                                  
3118                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
3119                                                  will be appended to SET and executed.
3120                                                  
3121                                                  =item --socket
3122                                                  
3123                                                  short form: -S; type: string; group: Play
3124                                                  
3125                                                  Socket file to use for connection.
3126                                                  
3127                                                  =item --split
3128                                                  
3129                                                  type: string; group: Split
3130                                                  
3131                                                  Split log by given attribute to create session files.
3132                                                  
3133                                                  Valid attributes are any which appear in the log: Thread_id, Schema,
3134                                                  etc.
3135                                                  
3136                                                  =item --split-random
3137                                                  
3138                                                  group: Split
3139                                                  
3140                                                  Split log without an attribute, write queries round-robin to session files.
3141                                                  
3142                                                  This option, if specified, overrides L<"--split"> and causes the log to be
3143                                                  split query-by-query, writing each query to the next session file in round-robin
3144                                                  style.  If you don't care about "sessions" and just want to split a lot into
3145                                                  N many session files and the relation or order of the queries does not matter,
3146                                                  then use this option.
3147                                                  
3148                                                  =item --threads
3149                                                  
3150                                                  type: int; default: 2; group: Play
3151                                                  
3152                                                  Number of threads used to play sessions concurrently.
3153                                                  
3154                                                  Specifies the number of parallel processes to run.  The default is 2.  On
3155                                                  GNU/Linux machines, the default is the number of times 'processor' appears in
3156                                                  F</proc/cpuinfo>.  On Windows, the default is read from the environment.
3157                                                  In any case, the default is at least 2, even when there's only a single
3158                                                  processor.
3159                                                  
3160                                                  See also L<"--session-files">.
3161                                                  
3162                                                  =item --type
3163                                                  
3164                                                  type: string; group: Split
3165                                                  
3166                                                  The type of log to L<"--split"> (default slowlog).  The permitted types are
3167                                                  
3168                                                  =over
3169                                                  
3170                                                  =item binlog
3171                                                  
3172                                                  Split a binary log file.
3173                                                  
3174                                                  =item genlog
3175                                                  
3176                                                  Split a general log file.
3177                                                  
3178                                                  =item slowlog
3179                                                  
3180                                                  Split a log file in any varation of MySQL slow-log format.
3181                                                  
3182                                                  =back
3183                                                  
3184                                                  =item --user
3185                                                  
3186                                                  short form: -u; type: string; group: Play
3187                                                  
3188                                                  User for login if not current user.
3189                                                  
3190                                                  =item --verbose
3191                                                  
3192                                                  short form: -v; cumulative: yes; default: 0
3193                                                  
3194                                                  Increase verbosity; can specifiy multiple times.
3195                                                  
3196                                                  =item --version
3197                                                  
3198                                                  Show version and exit.
3199                                                  
3200                                                  =item --wait-between-sessions
3201                                                  
3202                                                  type: array; default: 0; group: Play
3203                                                  
3204                                                  Not implemented yet.
3205                                                  
3206                                                  The wait time is given in seconds with microsecond precision and can be either
3207                                                  a single value or a range.  A single value causes an exact wait; example:
3208                                                  0.010 = wait 10 milliseconds.  A range causes a random wait between
3209                                                  the given value times; example: 0.001,1 = random wait from 1 millisecond to
3210                                                  1 second.
3211                                                  
3212                                                  =item --[no]warnings
3213                                                  
3214                                                  default: no; group: Play
3215                                                  
3216                                                  Print warnings about SQL errors such as invalid queries to STDERR.
3217                                                  
3218                                                  =back
3219                                                  
3220                                                  =head1 DOWNLOADING
3221                                                  
3222                                                  You can download Maatkit from Google Code at
3223                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
3224                                                  easily with a command like the following:
3225                                                  
3226                                                     wget http://www.maatkit.org/get/toolname
3227                                                     or
3228                                                     wget http://www.maatkit.org/trunk/toolname
3229                                                  
3230                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
3231                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
3232                                                  needed.  The first URL gets the latest released version of the tool, and the
3233                                                  second gets the latest trunk code from Subversion.
3234                                                  
3235                                                  =head1 ENVIRONMENT
3236                                                  
3237                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
3238                                                  the Maatkit tools:
3239                                                  
3240                                                     MKDEBUG=1 mk-....
3241                                                  
3242                                                  =head1 SYSTEM REQUIREMENTS
3243                                                  
3244                                                  You need Perl and some core packages that ought to be installed in any
3245                                                  reasonably new version of Perl.
3246                                                  
3247                                                  =head1 BUGS
3248                                                  
3249                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-log-player>.
3250                                                  
3251                                                  Please use Google Code Issues and Groups to report bugs or request support:
3252                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
3253                                                  discuss Maatkit.
3254                                                  
3255                                                  Please include the complete command-line used to reproduce the problem you are
3256                                                  seeing, the version of all MySQL servers involved, the complete output of the
3257                                                  tool when run with L<"--version">, and if possible, debugging output produced by
3258                                                  running with the C<MKDEBUG=1> environment variable.
3259                                                  
3260                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
3261                                                  
3262                                                  This program is copyright 2008-@CURRENTYEAR@ Percona Inc.
3263                                                  Feedback and improvements are welcome.
3264                                                  
3265                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
3266                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
3267                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
3268                                                  
3269                                                  This program is free software; you can redistribute it and/or modify it under
3270                                                  the terms of the GNU General Public License as published by the Free Software
3271                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
3272                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
3273                                                  licenses.
3274                                                  
3275                                                  You should have received a copy of the GNU General Public License along with
3276                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
3277                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
3278                                                  
3279                                                  =head1 AUTHOR
3280                                                  
3281                                                  Daniel Nichter
3282                                                  
3283                                                  =head1 ABOUT MAATKIT
3284                                                  
3285                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
3286                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
3287                                                  code contributors.  Both are employed by Percona.  Financial support for
3288                                                  Maatkit development is primarily provided by Percona and its clients. 
3289                                                  
3290                                                  =head1 VERSION
3291                                                  
3292                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5458 $.
3293                                                  
3294                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
55    ***      0      0      0   unless $args{$arg}
61    ***      0      0      0   exists $args{'strict'} ? :
104   ***      0      0      0   unless open my $fh, '<', $file
124   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
129   ***      0      0      0   if $para =~ /^=over/
137   ***      0      0      0   unless $para
140   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
147   ***      0      0      0   if ($para =~ /: /) { }
151   ***      0      0      0   unless $attributes{$attrib}
155   ***      0      0      0   if ($attribs{'short form'})
171   ***      0      0      0   if $para =~ /^=item/
173   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
178   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
190   ***      0      0      0   unless $para
193   ***      0      0      0   if ($para =~ /^=head1/)
197   ***      0      0      0   if $para =~ /^=item --/
201   ***      0      0      0   unless @specs
212   ***      0      0      0   if (ref $opt) { }
217   ***      0      0      0   if (not $long)
222   ***      0      0      0   if exists $$self{'opts'}{$long}
225   ***      0      0      0   if (length $long == 1)
230   ***      0      0      0   if ($short) { }
231   ***      0      0      0   if exists $$self{'short_opts'}{$short}
240   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
241   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
242   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
254   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
259   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
261   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
262   ***      0      0      0   defined $def ? :
266   ***      0      0      0   if ($long eq 'config')
270   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
283   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
288   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
293   ***      0      0      0   if ($opt =~ /default to/)
298   ***      0      0      0   if ($opt =~ /restricted to option groups/)
308   ***      0      0      0   unless $rule_ok
325   ***      0      0      0   unless exists $$self{'opts'}{$long}
349   ***      0      0      0   unless exists $$self{'opts'}{$long}
369   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
374   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
389   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
398   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
402   ***      0      0      0   if ($self->has('config'))
408   ***      0      0      0   if ($EVAL_ERROR)
409   ***      0      0      0   $self->got('config') ? :
424   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
427   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
428   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
434   ***      0      0      0   if (@ARGV and $$self{'strict'})
440   ***      0      0      0   if (@set > 1)
451   ***      0      0      0   if (@set == 0)
461   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
462   ***      0      0      0   if (exists $$self{'disables'}{$long})
469   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
481   ***      0      0      0   if $restricted_opt eq $long
482   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
487   ***      0      0      0   if (@restricted_opts)
489   ***      0      0      0   if (@restricted_opts == 1) { }
518   ***      0      0      0   unless $opt and $$opt{'type'}
521   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
524   ***      0      0      0   if (not $suffix)
530   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
531   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
546   ***      0      0      0   if ($from_key)
557   ***      0      0      0   if (defined $num) { }
558   ***      0      0      0   if ($factor)
585   ***      0      0      0   length $opt == 1 ? :
586   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
593   ***      0      0      0   length $opt == 1 ? :
594   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
601   ***      0      0      0   length $opt == 1 ? :
602   ***      0      0      0   defined $long ? :
607   ***      0      0      0   length $opt == 1 ? :
608   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
642   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
643   ***      0      0      0   unless print $self->print_usage
647   ***      0      0      0   unless print $self->print_errors
656   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
665   ***      0      0      0   unless $$self{'got_opts'}
668   ***      0      0      0   $$_{'is_negatable'} ? :
672   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
688   ***      0      0      0   $group eq 'default' ? :
694   ***      0      0      0   $$opt{'is_negatable'} ? :
697   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
706   ***      0      0      0   if ($short) { }
715   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
719   ***      0      0      0   if ($$self{'dp'})
727   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
739   ***      0      0      0   if ref $_[0] eq 'OptionParser'
742   ***      0      0      0   unless print $prompt
750   ***      0      0      0   unless print "\n"
753   ***      0      0      0   if ($EVAL_ERROR)
775   ***      0      0      0   unless open my $fh, '<', $filename
783   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
786   ***      0      0      0   if ($line eq '--')
791   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
809   ***      0      0      0   unless open my $fh, '<', $file
813   ***      0      0      0   unless $para =~ /^=pod$/m
817   ***      0      0      0   unless $para =~ /$regex/
822   ***      0      0      0   unless close $fh
836   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
851   ***      0      0      0   defined $_ ? :
899   ***      0      0      0   unless $args{$arg}
917   ***      0      0      0   if ($stmt =~ s/$slow_log_hd_line//go)
919   ***      0      0      0   if (@chunks > 1)
926   ***      0      0      0   unless $stmt =~ /\A#/
940   ***      0      0      0   if ($line =~ /^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) { }
942   ***      0      0      0   if (not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o) { }
      ***      0      0      0   elsif (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o) { }
      ***      0      0      0   elsif (not $got_ac and $line =~ /^# (?:administrator command:.*)$/) { }
      ***      0      0      0   elsif ($line =~ /^# +[A-Z][A-Za-z_]+: \S+/) { }
      ***      0      0      0   elsif (not $got_db and my($db) = $line =~ /^use ([^;]+)/) { }
      ***      0      0      0   elsif (not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/) { }
946   ***      0      0      0   if (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o)
989   ***      0      0      0   if (not $found_arg and $pos == $len)
992   ***      0      0      0   if (defined(my $l = &$next_event())) { }
1009  ***      0      0      0   if ($args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/)
1024  ***      0      0      0   if $args{'oktorun'}
1030  ***      0      0      0   defined $_ ? :
1075  ***      0      0      0   unless $args{$arg}
1099  ***      0      0      0   if $delim
1102  ***      0      0      0   if ($line =~ m[^/\*.+\*/;])
1107  ***      0      0      0   if ($line =~ /^DELIMITER/m)
1109  ***      0      0      0   if ($del) { }
1122  ***      0      0      0   if $line =~ /End of log file/
1124  ***      0      0      0   if (not $got_offset and my($offset) = $line =~ /$binlog_line_1/m) { }
      ***      0      0      0   elsif (not $got_hdr and $line =~ /^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/) { }
      ***      0      0      0   elsif ($line =~ /^(?:#|use |SET)/i) { }
1140  ***      0      0      0   if (my($db) = $line =~ /^use ([^;]+)/) { }
      ***      0      0      0   elsif (my($setting) = $line =~ /^SET\s+([^;]*)/) { }
1154  ***      0      0      0   if ($got_offset and $got_hdr) { }
1155  ***      0      0      0   if ($type eq 'Xid') { }
      ***      0      0      0   elsif ($type eq 'Query') { }
      ***      0      0      0   elsif ($type eq 'Start:') { }
1177  ***      0      0      0   $pos == length $stmt ? :
1180  ***      0      0      0   if $delim
1182  ***      0      0      0   if ($arg =~ /^DELIMITER/m)
1184  ***      0      0      0   if ($del) { }
1207  ***      0      0      0   if ($found_arg) { }
1217  ***      0      0      0   if $args{'oktorun'}
1223  ***      0      0      0   defined $_ ? :
1276  ***      0      0      0   unless $args{$arg}
1291  ***      0      0      0   if (not $thread_id && $cmd)
1301  ***      0      0      0   if ($cmd eq 'Query') { }
1305  ***      0      0      0   if ($line) { }
1307  ***      0      0      0   if ($thread_id and $cmd) { }
1326  ***      0      0      0   if $$db_for{$thread_id}
1331  ***      0      0      0   if ($cmd eq 'Connect') { }
      ***      0      0      0   elsif ($cmd eq 'Init') { }
1332  ***      0      0      0   if ($arg =~ /^Access denied/) { }
1341  ***      0      0      0   if $user
1342  ***      0      0      0   if $host
1343  ***      0      0      0   if $db
1352  ***      0      0      0   if $db
1368  ***      0      0      0   if $args{'oktorun'}
1374  ***      0      0      0   defined $_ ? :
1410  ***      0      0      0   unless $args{$arg}
1413  ***      0      0      0   if substr($args{'base_dir'}, -1, 1) ne '/'
1415  ***      0      0      0   if ($args{'split_random'})
1454  ***      0      0      0   if ($$self{'split_random'})
1458  ***      0      0      0   if (@logs == 0)
1466  ***      0      0      0   unless $oktorun
1467  ***      0      0      0   unless defined $log
1469  ***      0      0      0   if (not -f $log and $log ne '-')
1474  ***      0      0      0   if ($log eq '-') { }
1478  ***      0      0      0   if (not open $fh, '<', $log)
1495  ***      0      0      0   if ($event)
1497  ***      0      0      0   if ($$self{'split_random'})
1500  ***      0      0      0   if ($callbacks)
1503  ***      0      0      0   unless $event
1506  ***      0      0      0   if $event
1508  ***      0      0      0   if (not $more_events)
1513  ***      0      0      0   unless $oktorun
1522  ***      0      0      0   if $$self{'merge_sessions'}
1523  ***      0      0      0   unless $$self{'quiet'}
1531  ***      0      0      0   unless $session
1533  ***      0      0      0   if (not defined $$session{'fh'}) { }
      ***      0      0      0   elsif (not $$session{'active'}) { }
1539  ***      0      0      0   if (not $session_file)
1545  ***      0      0      0   if $$self{'n_open_fhs'} >= 1000
1547  ***      0      0      0   unless open my $fh, '>', $session_file
1564  ***      0      0      0   if $$self{'n_open_fhs'} >= 1000
1566  ***      0      0      0   unless open $$session{'fh'}, '>>', $$session{'session_file'}
1583  ***      0      0      0   if ($db and !defined($$session{'db'}) || $$session{'db'} ne $db)
1598  ***      0      0      0   if (not $$event{$attrib})
1603  ***      0      0      0   unless $$event{'arg'}
1605  ***      0      0      0   if ($$event{'cmd'} || '') eq 'Admin'
1610  ***      0      0      0   if ($$self{'n_sessions_saved'} < $$self{'max_sessions'}) { }
      ***      0      0      0   elsif (exists $$self{'sessions'}{$session_id}) { }
1645  ***      0      0      0   if $$self{'n_dirs_total'} >= $$self{'max_dirs'}
1647  ***      0      0      0   if ($$self{'n_files_this_dir'} >= $$self{'max_files_per_dir'} or $$self{'n_files_this_dir'} < 0) { }
1652  ***      0      0      0   !-d($new_dir) ? :
1654  ***      0      0      0   if ($retval >> 8 != 0)
1683  ***      0      0      0   unless $query
1693  ***      0      0      0   unless $$self{'quiet'}
1708  ***      0      0      0   if ($$self{'split_random'}) { }
1715  ***      0      0      0   if ($EVAL_ERROR)
1723  ***      0      0      0   if ($EVAL_ERROR)
1735  ***      0      0      0   if $current > $end
1756  ***      0      0      0   defined $_ ? :
1842  ***     50      0      6   if (@_ > 2)
1851  ***     50      0      2   if (not $dsn)
1863  ***     50      8      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1875  ***     50      0     16   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1881         100      8      8   if (not defined $final_props{$key})
1888  ***     50      0      8   unless exists $opts{$key}
1891  ***     50      0      2   if (my $required = $self->prop('required'))
1893  ***      0      0      0   unless $final_props{$key}
1902  ***      0      0      0   unless ref $o eq 'OptionParser'
1905  ***      0      0      0   if $o->has($_)
1915  ***      0      0      0   unless ref $dsn
1916  ***      0      0      0   $_ eq 'p' ? :
1917  ***      0      0      0   if defined $$dsn{$_}
1930  ***      0      0      0   $opts{$key}{'copy'} ? :
1944  ***     50      0      2   if ($driver eq 'Pg') { }
1976  ***     50      0      2   $cxn_string =~ /charset=utf8/ ? :
1985  ***     50      0      2   if (not $have_dbi)
2004  ***     50      2      0   if ($cxn_string =~ /mysql/i)
2012  ***     50      0      2   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
2017  ***      0      0      0   if ($charset eq 'utf8') { }
2018  ***      0      0      0   unless binmode STDOUT, ':utf8'
2022  ***      0      0      0   unless binmode STDOUT
2026  ***     50      0      2   if ($self->prop('set-vars'))
2033  ***     50      0      2   if (not $dbh and $EVAL_ERROR)
2035  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
2048  ***      0      0      0   if (not $tries)
2070  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
2087  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
2097  ***      0      0      0   unless $dsn_1
2098  ***      0      0      0   unless $dsn_2
2102  ***      0      0      0   if ($args{'overwrite'}) { }
2103  ***      0      0      0   defined $$dsn_1{$key} ? :
2106  ***      0      0      0   defined $$dsn_2{$key} ? :
2115  ***      0      0      0   defined $_ ? :
2151  ***      0      0      0   defined $_ ? :
2162  ***      0      0      0   if ($sys_info or open $cpuinfo, '<', '/proc/cpuinfo')
2166  ***      0      0      0   if $cpuinfo
2169  ***      0      0      0   if $n_cpus
2173  ***      0      0      0   if ($sys_info or $OSNAME =~ /freebsd/i or $OSNAME =~ /darwin/i)
2176  ***      0      0      0   if $contents
2178  ***      0      0      0   if $n_cpus
2209  ***      0      0      0   unless $args{$arg}
2212  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
2228  ***      0      0      0   unless defined(my $pid = fork)
2229  ***      0      0      0   if ($pid)
2236  ***      0      0      0   unless POSIX::setsid()
2237  ***      0      0      0   unless chdir '/'
2243  ***      0      0      0   if (-t STDIN)
2245  ***      0      0      0   unless open STDIN, '/dev/null'
2249  ***      0      0      0   if ($$self{'log_file'}) { }
2251  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
2255  ***      0      0      0   unless open STDERR, '>&STDOUT'
2259  ***      0      0      0   if (-t STDOUT)
2261  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
2264  ***      0      0      0   if (-t STDERR)
2266  ***      0      0      0   unless open STDERR, '>', '/dev/null'
2277  ***      0      0      0   $self ? :
2279  ***      0      0      0   if ($PID_file and -f $PID_file) { }
2282  ***      0      0      0   if $EVAL_ERROR
2284  ***      0      0      0   if ($pid) { }
2286  ***      0      0      0   if ($pid_is_alive) { }
2308  ***      0      0      0   if (exists $$self{'child'})
2320  ***      0      0      0   if (not $PID_file)
2327  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
2329  ***      0      0      0   unless print $PID_FH $PID
2331  ***      0      0      0   unless close $PID_FH
2340  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
2341  ***      0      0      0   unless unlink $$self{'PID_file'}
2353  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
2359  ***      0      0      0   defined $_ ? :
2422  ***      0      0      0   if $o->get('split-random')
2426  ***      0      0      0   if (not $o->get('split') and not $o->get('print'))
2428  ***      0      0      0   @ARGV ? :
2429  ***      0      0      0   if (not $dsn)
2434  ***      0      0      0   if (not -d $o->get('base-dir'))
2439  ***      0      0      0   unless $o->got('threads')
2448  ***      0      0      0   if ($o->get('pid'))
2461  ***      0      0      0   if ($split)
2462  ***      0      0      0   if not -d $base_dir
2468  ***      0      0      0   if not $split =~ /^[\w]+$/
2471  ***      0      0      0   if scalar @ARGV == 0
2474  ***      0      0      0   if ($o->get('filter'))
2476  ***      0      0      0   if (-f $filter and -r $filter) { }
2478  ***      0      0      0   unless open my $fh, '<', $filter
2487  ***      0      0      0   unless my $sub = eval $code
2492  ***      0      0      0   $o->get('type') eq 'genlog' ? :
      ***      0      0      0   $o->get('type') eq 'binlog' ? :
      ***      0      0      0   $o->get('type') eq 'slowlog' ? :
2521  ***      0      0      0   if (-d $session_file) { }
2523  ***      0      0      0   unless opendir my $dir, $session_file
2532  ***      0      0      0   if (not -f $session_file) { }
2543  ***      0      0      0   if (@session_files == 0)
2549  ***      0      0      0   unless $o->get('quiet')
2551  ***      0      0      0   if ($o->get('threads') > $n_session_files)
2559  ***      0      0      0   unless $o->get('quiet')
2570  ***      0      0      0   if $o->get('verbose') and not $o->get('quiet')
2576  ***      0      0      0   if @session_files > 0
2582  ***      0      0      0   if (not $o->get('print'))
2583  ***      0      0      0   if ($o->get('ask-pass'))
2609  ***      0      0      0   unless $o->get('quiet')
2614  ***      0      0      0   unless defined $pid
2615  ***      0      0      0   if ($pid) { }
2626  ***      0      0      0   unless $o->get('quiet')
2635  ***      0      0      0   unless $o->get('quiet')
2643  ***      0      0      0   if (keys %children and not $reaped)
2654  ***      0      0      0   unless $o->get('quiet')
2670  ***      0      0      0   unless $print
2679  ***      0      0      0   if ($results or $print) { }
2680  ***      0      0      0   unless open $output_fh, '>', $output_file
2698  ***      0      0      0   if (not open $session_fh, '<', $session_file)
2706  ***      0      0      0   if ($print)
2711  ***      0      0      0   if ($query =~ /^-- START SESSION (\S+)/)
2716  ***      0      0      0   if ($only_select and not $query =~ /^(?:SELECT|USE) /i)
2721  ***      0      0      0   if ($query =~ /^use (\S+)/)
2724  ***      0      0      0   if ($EVAL_ERROR and $warnings)
2732  ***      0      0      0   if ($EVAL_ERROR and $warnings)
2737  ***      0      0      0   if ($results)
2752  ***      0      0      0   if $output_fh
2753  ***      0      0      0   if $dbh
2759  ***      0      0      0   if not defined $delay or scalar @$delay == 0
2763  ***      0      0      0   if (defined $to) { }
2789  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
254   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
259   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
398   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
427   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
434   ***      0      0      0      0   @ARGV and $$self{'strict'}
518   ***      0      0      0      0   $opt and $$opt{'type'}
521   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
586   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
594   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
608   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
697   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
791   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
942   ***      0      0      0      0   not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o
      ***      0      0      0      0   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
      ***      0      0      0      0   not $got_ac and $line =~ /^# (?:administrator command:.*)$/
      ***      0      0      0      0   not $got_db and my($db) = $line =~ /^use ([^;]+)/
      ***      0      0      0      0   not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/
946   ***      0      0      0      0   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
989   ***      0      0      0      0   not $found_arg and $pos == $len
1009  ***      0      0      0      0   $args{'misc'} and $args{'misc'}{'embed'}
      ***      0      0      0      0   $args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/
1124  ***      0      0      0      0   not $got_offset and my($offset) = $line =~ /$binlog_line_1/m
      ***      0      0      0      0   not $got_hdr and $line =~ /^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/
1154  ***      0      0      0      0   $got_offset and $got_hdr
1291  ***      0      0      0      0   $thread_id && $cmd
1307  ***      0      0      0      0   $thread_id and $cmd
1469  ***      0      0      0      0   not -f $log and $log ne '-'
1583  ***      0      0      0      0   $db and !defined($$session{'db'}) || $$session{'db'} ne $db
1875  ***     66      8      8      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     16      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1997  ***     66      2      0      2   not $dbh and $tries--
2033  ***     33      2      0      0   not $dbh and $EVAL_ERROR
2279  ***      0      0      0      0   $PID_file and -f $PID_file
2340  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2426  ***      0      0      0      0   not $o->get('split') and not $o->get('print')
2476  ***      0      0      0      0   -f $filter and -r $filter
2566  ***      0      0      0      0   $i++ < $files_per_child and my $session_file = pop @session_files
2570  ***      0      0      0      0   $o->get('verbose') and not $o->get('quiet')
2643  ***      0      0      0      0   keys %children and not $reaped
2716  ***      0      0      0      0   $only_select and not $query =~ /^(?:SELECT|USE) /i
2724  ***      0      0      0      0   $EVAL_ERROR and $warnings
2732  ***      0      0      0      0   $EVAL_ERROR and $warnings

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
39    ***     50      0      7   $ENV{'MKDEBUG'} || 0
59    ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
61    ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
103   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-log-player/mk-log-player'
244   ***      0      0      0   $$opt{'group'} ||= 'default'
526   ***      0      0      0   $s || 's'
535   ***      0      0      0   $prefix || ''
563   ***      0      0      0   $pre || ''
570   ***      0      0      0   $val || ''
573   ***      0      0      0   $val || ''
631   ***      0      0      0   $$self{'description'} || ''
699   ***      0      0      0   $s ||= 's'
725   ***      0      0      0   $$opt{'type'} || ''
873   ***     50      0      7   $ENV{'MKDEBUG'} || 0
1056  ***     50      0      7   $ENV{'MKDEBUG'} || 0
1249  ***     50      0      7   $ENV{'MKDEBUG'} || 0
1605  ***      0      0      0   $$event{'cmd'} || ''
1611  ***      0      0      0   $$self{'sessions'}{$session_id} ||= {}
1785  ***     50      0      7   $ENV{'MKDEBUG'} || 0
1856  ***     50      0      2   $prev ||= {}
1857  ***     50      0      2   $defaults ||= {}
1930  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1943  ***     50      0      2   $self->prop('dbidriver') || ''
1947  ***      0      0      0   $$info{'D'} || ''
1953  ***     50      0      2   $$info{'D'} || ''
1975  ***     50      2      0   $opts ||= {}
2070  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
2086  ***      0      0      0   $level ||= 0
2087  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
2147  ***     50      0      7   $ENV{'MKDEBUG'} || 0
2183  ***      0      0      0   $n_cpus || 1
2204  ***     50      0      7   $ENV{'MKDEBUG'} || 0
2394  ***     50      0      7   $ENV{'MKDEBUG'} || 0
2739  ***      0      0      0   $db || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
58    ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
59    ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
521   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
910   ***      0      0      0      0   defined($stmt = shift @$pending) or defined($stmt = &$next_event())
1285  ***      0      0      0      0   defined($line = shift @$pending) or defined($line = &$next_event())
1582  ***      0      0      0      0   $$event{'db'} || $$event{'Schema'}
1583  ***      0      0      0      0   !defined($$session{'db'}) || $$session{'db'} ne $db
1647  ***      0      0      0      0   $$self{'n_files_this_dir'} >= $$self{'max_files_per_dir'} or $$self{'n_files_this_dir'} < 0
1673  ***      0      0      0      0   $n || $$self{'n_sessions_saved'}
1966  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1967  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1968  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1969  ***      0      0      0      0   $$dsn{'u'} ||= $user
1970  ***      0      0      0      0   $$dsn{'D'} ||= $db
2162  ***      0      0      0      0   $sys_info or open $cpuinfo, '<', '/proc/cpuinfo'
2164  ***      0      0      0      0   $sys_info || <$cpuinfo>
2173  ***      0      0      0      0   $sys_info or $OSNAME =~ /freebsd/i
      ***      0      0      0      0   $sys_info or $OSNAME =~ /freebsd/i or $OSNAME =~ /darwin/i
2174  ***      0      0      0      0   $sys_info || `sysctl hw.ncpu`
2181  ***      0      0      0      0   $n_cpus ||= $ENV{'NUMBER_OF_PROCESSORS'}
2353  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2679  ***      0      0      0      0   $results or $print
2759  ***      0      0      0      0   not defined $delay or scalar @$delay == 0


Covered Subroutines
-------------------

Subroutine             Count Location                                                 
---------------------- ----- ---------------------------------------------------------
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1047
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1048
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1049
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1051
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1056
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1240
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1241
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1242
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1244
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1249
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1392
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1393
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1394
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1396
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1401
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1402
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1403
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1773
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1774
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1775
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1776
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1785
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:20  
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:21  
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2133
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2134
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2136
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2147
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2198
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2199
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2201
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2202
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2204
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2381
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2382
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2383
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2384
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2385
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2386
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2387
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2392
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2394
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:32  
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:33  
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:35  
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:36  
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:37  
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:39  
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:868 
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:869 
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:870 
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:871 
BEGIN                      7 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:873 
get_cxn_params             2 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1940
get_dbh                    2 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1974
new                        2 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1788
parse                      2 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1850
prop                       6 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1841

Uncovered Subroutines
---------------------

Subroutine             Count Location                                                 
---------------------- ----- ---------------------------------------------------------
DESTROY                    0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2352
__ANON__                   0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1487
__ANON__                   0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1491
__ANON__                   0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1492
__ANON__                   0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1735
__ANON__                   0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2600
__ANON__                   0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:422 
_close_lru_session         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1626
_d                         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1029
_d                         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1222
_d                         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1373
_d                         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1755
_d                         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2114
_d                         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2150
_d                         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2358
_d                         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2788
_d                         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:850 
_get_next_session_file     0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1644
_get_participants          0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:322 
_get_session_ds            0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1595
_make_PID_file             0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2317
_merge_session_files       0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1691
_parse_specs               0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:208 
_pod_to_specs              0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:102 
_read_config_file          0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:774 
_remove_PID_file           0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2339
_save_event                0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1529
_set_option                0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:368 
_validate_type             0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:517 
as_string                  0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1914
check_PID_file             0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2276
clone                      0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:827 
copy                       0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2096
daemonize                  0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2225
descr                      0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:630 
disconnect                 0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2079
errors                     0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:620 
fill_in_dsn                0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1962
flatten                    0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1682
get                        0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:584 
get_cxn                    0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2776
get_defaults               0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:358 
get_defaults_files         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:97  
get_delay                  0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2758
get_groups                 0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:363 
get_hostname               0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2069
get_number_of_cpus         0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2158
get_opts                   0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:385 
get_specs                  0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:90  
got                        0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:592 
has                        0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:600 
main                       0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2402
make_PID_file              0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2307
make_rr_iter               0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1732
new                        0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1059
new                        0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1252
new                        0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1408
new                        0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2207
new                        0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:53  
new                        0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:876 
opts                       0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:334 
parse_event                0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1072
parse_event                0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1273
parse_event                0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:896 
parse_options              0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1901
play_session               0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2662
print_active_handles       0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2085
print_errors               0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:654 
print_split_summary        0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1742
print_usage                0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:664 
prompt                     0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:625 
prompt_noecho              0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:739 
read_para_after            0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:808 
save_error                 0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:615 
set                        0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:606 
set_defaults               0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:346 
short_opts                 0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:340 
split                      0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1448
usage                      0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:1923
usage_or_errors            0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:641 
warn_error                 0 /home/daniel/dev/maatkit/mk-log-player/mk-log-player:2781


