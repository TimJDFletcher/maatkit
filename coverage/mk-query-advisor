---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...-advisor/mk-query-advisor   35.4   22.2   21.4   53.8    n/a  100.0   31.5
Total                          35.4   22.2   21.4   53.8    n/a  100.0   31.5
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb 15 20:43:16 2010
Finish:       Mon Feb 15 20:43:16 2010

Run:          ./001_parse_check.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb 15 20:43:17 2010
Finish:       Mon Feb 15 20:43:17 2010

Run:          ./002_parse_check_rules.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb 15 20:43:20 2010
Finish:       Mon Feb 15 20:43:20 2010

Run:          ./003_check_query.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb 15 20:43:23 2010
Finish:       Mon Feb 15 20:43:23 2010

Run:          ./004_filter_checks.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb 15 20:43:25 2010
Finish:       Mon Feb 15 20:43:25 2010

Run:          ./101_checks.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Feb 15 20:43:28 2010
Finish:       Mon Feb 15 20:43:28 2010

/home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2010-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             5                    5            31   use strict;
               5                                 11   
               5                                 32   
21             5                    5            32   use warnings FATAL => 'all';
               5                                 12   
               5                                 34   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5782 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # OptionParser package 5770
29                                                    # ###########################################################################
30                                                    package OptionParser;
31                                                    
32             5                    5            34   use strict;
               5                                 16   
               5                                 21   
33             5                    5            33   use warnings FATAL => 'all';
               5                                 11   
               5                                 24   
34                                                    
35             5                    5            44   use Getopt::Long;
               5                                 16   
               5                                 35   
36             5                    5            38   use List::Util qw(max);
               5                                 14   
               5                                 56   
37             5                    5            31   use English qw(-no_match_vars);
               5                                 13   
               5                                 31   
38                                                    
39    ***      5            50      5            34   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 41   
               5                                 87   
40                                                    
41                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
42                                                    
43                                                    my %attributes = (
44                                                       'type'       => 1,
45                                                       'short form' => 1,
46                                                       'group'      => 1,
47                                                       'default'    => 1,
48                                                       'cumulative' => 1,
49                                                       'negatable'  => 1,
50                                                    );
51                                                    
52                                                    sub new {
53             9                    9           169      my ( $class, %args ) = @_;
54             9                                 85      foreach my $arg ( qw(description) ) {
55    ***      9     50                          97         die "I need a $arg argument" unless $args{$arg};
56                                                       }
57             9                                172      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
58    ***      9            33                   77      $program_name ||= $PROGRAM_NAME;
59    ***      9            33                  124      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
60                                                    
61    ***      9     50     50                  623      my $self = {
      ***                   50                        
62                                                          description    => $args{description},
63                                                          prompt         => $args{prompt} || '<options>',
64                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
65                                                          dp             => $args{dp}     || undef,
66                                                          program_name   => $program_name,
67                                                          opts           => {},
68                                                          got_opts       => 0,
69                                                          short_opts     => {},
70                                                          defaults       => {},
71                                                          groups         => {},
72                                                          allowed_groups => {},
73                                                          errors         => [],
74                                                          rules          => [],  # desc of rules for --help
75                                                          mutex          => [],  # rule: opts are mutually exclusive
76                                                          atleast1       => [],  # rule: at least one opt is required
77                                                          disables       => {},  # rule: opt disables other opts 
78                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
79                                                          default_files  => [
80                                                             "/etc/maatkit/maatkit.conf",
81                                                             "/etc/maatkit/$program_name.conf",
82                                                             "$home/.maatkit.conf",
83                                                             "$home/.$program_name.conf",
84                                                          ],
85                                                       };
86             9                                 80      return bless $self, $class;
87                                                    }
88                                                    
89                                                    sub get_specs {
90             9                    9            52      my ( $self, $file ) = @_;
91             9                                 83      my @specs = $self->_pod_to_specs($file);
92             9                                174      $self->_parse_specs(@specs);
93             9                                 36      return;
94                                                    }
95                                                    
96                                                    sub get_defaults_files {
97             9                    9            32      my ( $self ) = @_;
98             9                                 30      return @{$self->{default_files}};
               9                                 82   
99                                                    }
100                                                   
101                                                   sub _pod_to_specs {
102            9                    9            39      my ( $self, $file ) = @_;
103   ***      9            50                   52      $file ||= __FILE__;
104   ***      9     50                         323      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
105                                                   
106            9                                181      my %types = (
107                                                         string => 's', # standard Getopt type
108                                                         'int'  => 'i', # standard Getopt type
109                                                         float  => 'f', # standard Getopt type
110                                                         Hash   => 'H', # hash, formed from a comma-separated list
111                                                         hash   => 'h', # hash as above, but only if a value is given
112                                                         Array  => 'A', # array, similar to Hash
113                                                         array  => 'a', # array, similar to hash
114                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
115                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
116                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
117                                                      );
118            9                                110      my @specs = ();
119            9                                 40      my @rules = ();
120            9                                 24      my $para;
121                                                   
122            9                                 54      local $INPUT_RECORD_SEPARATOR = '';
123            9                                176      while ( $para = <$fh> ) {
124         3789    100                       23793         next unless $para =~ m/^=head1 OPTIONS/;
125            9                                 34         last;
126                                                      }
127                                                   
128            9                                 47      while ( $para = <$fh> ) {
129   ***      9     50                          72         last if $para =~ m/^=over/;
130   ***      0                                  0         chomp $para;
131   ***      0                                  0         $para =~ s/\s+/ /g;
132   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
133   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
134   ***      0                                  0         push @rules, $para;
135                                                      }
136                                                   
137   ***      9     50                          43      die 'POD has no OPTIONS section' unless $para;
138                                                   
139            9                                 29      do {
140          207    100                        1316         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
141          198                                528            chomp $para;
142          198                                414            MKDEBUG && _d($para);
143          198                                439            my %attribs;
144                                                   
145          198                                687            $para = <$fh>; # read next paragraph, possibly attributes
146                                                   
147          198    100                         741            if ( $para =~ m/: / ) { # attributes
148          135                                611               $para =~ s/\s+\Z//g;
149          234                               1074               %attribs = map {
150          135                                638                     my ( $attrib, $val) = split(/: /, $_);
151   ***    234     50                         998                     die "Unrecognized attribute for --$option: $attrib"
152                                                                        unless $attributes{$attrib};
153          234                               1196                     ($attrib, $val);
154                                                                  } split(/; /, $para);
155          135    100                         679               if ( $attribs{'short form'} ) {
156           72                                334                  $attribs{'short form'} =~ s/-//;
157                                                               }
158          135                                540               $para = <$fh>; # read next paragraph, probably short help desc
159                                                            }
160                                                            else {
161           63                                149               MKDEBUG && _d('Option has no attributes');
162                                                            }
163                                                   
164          198                               1218            $para =~ s/\s+\Z//g;
165          198                               1256            $para =~ s/\s+/ /g;
166          198                                660            $para =~ s/$POD_link_re/$1/go;
167                                                   
168          198                                743            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
169          198                                455            MKDEBUG && _d('Short help:', $para);
170                                                   
171   ***    198     50                        1279            die "No description after option spec $option" if $para =~ m/^=item/;
172                                                   
173   ***    198     50                         887            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
174   ***      0                                  0               $option = $base_option;
175   ***      0                                  0               $attribs{'negatable'} = 1;
176                                                            }
177                                                   
178          198    100                        3154            push @specs, {
      ***            50                               
                    100                               
                    100                               
                    100                               
      ***            50                               
179                                                               spec  => $option
180                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
181                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
182                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
183                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
184                                                               desc  => $para
185                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
186                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
187                                                            };
188                                                         }
189          207                               1156         while ( $para = <$fh> ) {
190   ***    243     50                         804            last unless $para;
191                                                   
192                                                   
193          243    100                         934            if ( $para =~ m/^=head1/ ) {
194            9                                 28               $para = undef; # Can't 'last' out of a do {} block.
195            9                                 44               last;
196                                                            }
197          234    100                        1462            last if $para =~ m/^=item --/;
198                                                         }
199                                                      } while ( $para );
200                                                   
201   ***      9     50                          43      die 'No valid specs in POD OPTIONS' unless @specs;
202                                                   
203            9                                 99      close $fh;
204            9                                 29      return @specs, @rules;
205                                                   }
206                                                   
207                                                   sub _parse_specs {
208            9                    9            56      my ( $self, @specs ) = @_;
209            9                                 32      my %disables; # special rule that requires deferred checking
210                                                   
211            9                                 47      foreach my $opt ( @specs ) {
212   ***    198     50                         691         if ( ref $opt ) { # It's an option spec, not a rule.
213                                                            MKDEBUG && _d('Parsing opt spec:',
214          198                                419               map { ($_, '=>', $opt->{$_}) } keys %$opt);
215                                                   
216          198                               1323            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
217   ***    198     50                         794            if ( !$long ) {
218   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
219                                                            }
220          198                                690            $opt->{long} = $long;
221                                                   
222   ***    198     50                         858            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
223          198                                898            $self->{opts}->{$long} = $opt;
224                                                   
225   ***    198     50                         743            if ( length $long == 1 ) {
226   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
227   ***      0                                  0               $self->{short_opts}->{$long} = $long;
228                                                            }
229                                                   
230          198    100                         614            if ( $short ) {
231   ***     72     50                         319               die "Duplicate short option -$short"
232                                                                  if exists $self->{short_opts}->{$short};
233           72                                317               $self->{short_opts}->{$short} = $long;
234           72                                246               $opt->{short} = $short;
235                                                            }
236                                                            else {
237          126                                417               $opt->{short} = undef;
238                                                            }
239                                                   
240   ***    198     50                         991            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
241          198    100                         928            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
242   ***    198     50                        1100            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
243                                                   
244   ***    198            50                  781            $opt->{group} ||= 'default';
245          198                                930            $self->{groups}->{ $opt->{group} }->{$long} = 1;
246                                                   
247          198                                645            $opt->{value} = undef;
248          198                                650            $opt->{got}   = 0;
249                                                   
250          198                               1024            my ( $type ) = $opt->{spec} =~ m/=(.)/;
251          198                                667            $opt->{type} = $type;
252          198                                415            MKDEBUG && _d($long, 'type:', $type);
253                                                   
254   ***    198     50     66                 1600            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
255   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
256                                                                  . "was given when this OptionParser object was created";
257                                                            }
258                                                   
259          198    100    100                 1372            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
260                                                   
261          198    100                        1129            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
262   ***     36     50                         184               $self->{defaults}->{$long} = defined $def ? $def : 1;
263           36                                 79               MKDEBUG && _d($long, 'default:', $def);
264                                                            }
265                                                   
266          198    100                         745            if ( $long eq 'config' ) {
267            9                                 48               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
268                                                            }
269                                                   
270   ***    198     50                         960            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
271   ***      0                                  0               $disables{$long} = $dis;
272   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
273                                                            }
274                                                   
275          198                                900            $self->{opts}->{$long} = $opt;
276                                                         }
277                                                         else { # It's an option rule, not a spec.
278   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
279   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
280   ***      0                                  0            my @participants = $self->_get_participants($opt);
281   ***      0                                  0            my $rule_ok = 0;
282                                                   
283   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
284   ***      0                                  0               $rule_ok = 1;
285   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
286   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
287                                                            }
288   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
289   ***      0                                  0               $rule_ok = 1;
290   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
291   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
292                                                            }
293   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
294   ***      0                                  0               $rule_ok = 1;
295   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
296   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
297                                                            }
298   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
299   ***      0                                  0               $rule_ok = 1;
300   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
301   ***      0                                  0               my @groups = split(',', $groups);
302   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
303   ***      0                                  0                  s/\s+//;
304   ***      0                                  0                  $_ => 1;
305                                                               } @groups;
306                                                            }
307                                                   
308   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
309                                                         }
310                                                      }
311                                                   
312            9                                 57      foreach my $long ( keys %disables ) {
313   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
314   ***      0                                  0         $self->{disables}->{$long} = \@participants;
315   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
316                                                      }
317                                                   
318            9                                 41      return; 
319                                                   }
320                                                   
321                                                   sub _get_participants {
322   ***      0                    0             0      my ( $self, $str ) = @_;
323   ***      0                                  0      my @participants;
324   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
325   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
326                                                            unless exists $self->{opts}->{$long};
327   ***      0                                  0         push @participants, $long;
328                                                      }
329   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
330   ***      0                                  0      return @participants;
331                                                   }
332                                                   
333                                                   sub opts {
334   ***      0                    0             0      my ( $self ) = @_;
335   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
336   ***      0                                  0      return %opts;
337                                                   }
338                                                   
339                                                   sub short_opts {
340   ***      0                    0             0      my ( $self ) = @_;
341   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
342   ***      0                                  0      return %short_opts;
343                                                   }
344                                                   
345                                                   sub set_defaults {
346   ***      0                    0             0      my ( $self, %defaults ) = @_;
347   ***      0                                  0      $self->{defaults} = {};
348   ***      0                                  0      foreach my $long ( keys %defaults ) {
349   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
350                                                            unless exists $self->{opts}->{$long};
351   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
352   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
353                                                      }
354   ***      0                                  0      return;
355                                                   }
356                                                   
357                                                   sub get_defaults {
358   ***      0                    0             0      my ( $self ) = @_;
359   ***      0                                  0      return $self->{defaults};
360                                                   }
361                                                   
362                                                   sub get_groups {
363   ***      0                    0             0      my ( $self ) = @_;
364   ***      0                                  0      return $self->{groups};
365                                                   }
366                                                   
367                                                   sub _set_option {
368           27                   27           112      my ( $self, $opt, $val ) = @_;
369   ***     27      0                          56      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
370                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
371                                                               : die "Getopt::Long gave a nonexistent option: $opt";
372                                                   
373           27                                 54      $opt = $self->{opts}->{$long};
374   ***     27     50                         137      if ( $opt->{is_cumulative} ) {
375   ***      0                                  0         $opt->{value}++;
376                                                      }
377                                                      else {
378           27                                 99         $opt->{value} = $val;
379                                                      }
380           27                                 79      $opt->{got} = 1;
381           27                                109      MKDEBUG && _d('Got option', $long, '=', $val);
382                                                   }
383                                                   
384                                                   sub get_opts {
385            9                    9            49      my ( $self ) = @_; 
386                                                   
387            9                                 31      foreach my $long ( keys %{$self->{opts}} ) {
               9                                 90   
388          198                                745         $self->{opts}->{$long}->{got} = 0;
389   ***    198     50                        1503         $self->{opts}->{$long}->{value}
                    100                               
390                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
391                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
392                                                            : undef;
393                                                      }
394            9                                 45      $self->{got_opts} = 0;
395                                                   
396            9                                 37      $self->{errors} = [];
397                                                   
398   ***      9     50     33                  125      if ( @ARGV && $ARGV[0] eq "--config" ) {
399   ***      0                                  0         shift @ARGV;
400   ***      0                                  0         $self->_set_option('config', shift @ARGV);
401                                                      }
402   ***      9     50                          70      if ( $self->has('config') ) {
403            9                                 21         my @extra_args;
404            9                                 66         foreach my $filename ( split(',', $self->get('config')) ) {
405           36                                 87            eval {
406           36                                220               push @extra_args, $self->_read_config_file($filename);
407                                                            };
408   ***     36     50                         180            if ( $EVAL_ERROR ) {
409   ***     36     50                         156               if ( $self->got('config') ) {
410   ***      0                                  0                  die $EVAL_ERROR;
411                                                               }
412                                                               elsif ( MKDEBUG ) {
413                                                                  _d($EVAL_ERROR);
414                                                               }
415                                                            }
416                                                         }
417            9                                 44         unshift @ARGV, @extra_args;
418                                                      }
419                                                   
420            9                                100      Getopt::Long::Configure('no_ignore_case', 'bundling');
421                                                      GetOptions(
422          189                   27          1305         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              27                                138   
             198                                760   
423            9                                 57         grep   { $_->{long} ne 'config' } # --config is handled specially above.
424   ***      9     50                          32         values %{$self->{opts}}
425                                                      ) or $self->save_error('Error parsing options');
426                                                   
427   ***      9     50     33                  345      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
428   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
429                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
430                                                               or die "Cannot print: $OS_ERROR";
431   ***      0                                  0         exit 0;
432                                                      }
433                                                   
434   ***      9     50     33                   45      if ( @ARGV && $self->{strict} ) {
435   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
436                                                      }
437                                                   
438            9                                 28      foreach my $mutex ( @{$self->{mutex}} ) {
               9                                 50   
439   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
440   ***      0      0                           0         if ( @set > 1 ) {
441   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
442   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
443                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
444                                                                    . ' are mutually exclusive.';
445   ***      0                                  0            $self->save_error($err);
446                                                         }
447                                                      }
448                                                   
449            9                                 28      foreach my $required ( @{$self->{atleast1}} ) {
               9                                 56   
450   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
451   ***      0      0                           0         if ( @set == 0 ) {
452   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
453   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
454                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
455   ***      0                                  0            $self->save_error("Specify at least one of $err");
456                                                         }
457                                                      }
458                                                   
459            9                                 27      foreach my $long ( keys %{$self->{opts}} ) {
               9                                 69   
460          198                                716         my $opt = $self->{opts}->{$long};
461          198    100                         994         if ( $opt->{got} ) {
      ***            50                               
462   ***     27     50                         117            if ( exists $self->{disables}->{$long} ) {
463   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
464   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
465   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
466                                                                  'because', $long,'disables them');
467                                                            }
468                                                   
469   ***     27     50                         123            if ( exists $self->{allowed_groups}->{$long} ) {
470                                                   
471   ***      0                                  0               my @restricted_groups = grep {
472   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
473   ***      0                                  0               } keys %{$self->{groups}};
474                                                   
475   ***      0                                  0               my @restricted_opts;
476   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
477   ***      0                                  0                  RESTRICTED_OPT:
478   ***      0                                  0                  foreach my $restricted_opt (
479                                                                     keys %{$self->{groups}->{$restricted_group}} )
480                                                                  {
481   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
482   ***      0      0                           0                     push @restricted_opts, $restricted_opt
483                                                                        if $self->{opts}->{$restricted_opt}->{got};
484                                                                  }
485                                                               }
486                                                   
487   ***      0      0                           0               if ( @restricted_opts ) {
488   ***      0                                  0                  my $err;
489   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
490   ***      0                                  0                     $err = "--$restricted_opts[0]";
491                                                                  }
492                                                                  else {
493   ***      0                                  0                     $err = join(', ',
494   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
495   ***      0                                  0                               grep { $_ } 
496                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
497                                                                            )
498                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
499                                                                  }
500   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
501                                                               }
502                                                            }
503                                                   
504                                                         }
505                                                         elsif ( $opt->{is_required} ) { 
506   ***      0                                  0            $self->save_error("Required option --$long must be specified");
507                                                         }
508                                                   
509          198                                736         $self->_validate_type($opt);
510                                                      }
511                                                   
512            9                                 46      $self->{got_opts} = 1;
513            9                                 27      return;
514                                                   }
515                                                   
516                                                   sub _validate_type {
517          198                  198           661      my ( $self, $opt ) = @_;
518   ***    198    100     66                 1654      return unless $opt && $opt->{type};
519          126                                384      my $val = $opt->{value};
520                                                   
521   ***    126     50     66                 3032      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
522   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
523   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
524   ***      0      0                           0         if ( !$suffix ) {
525   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
526   ***      0             0                    0            $suffix = $s || 's';
527   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
528                                                               $opt->{long}, '(value:', $val, ')');
529                                                         }
530   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
531   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
532                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
533                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
534                                                                 :                  $num * 86400;   # Days
535   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
536   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
537                                                         }
538                                                         else {
539   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
540                                                         }
541                                                      }
542                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
543   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
544   ***      0                                  0         my $prev = {};
545   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
546   ***      0      0                           0         if ( $from_key ) {
547   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
548   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
549                                                         }
550   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
551   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
552                                                      }
553                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
554   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
555   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
556   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
557   ***      0      0                           0         if ( defined $num ) {
558   ***      0      0                           0            if ( $factor ) {
559   ***      0                                  0               $num *= $factor_for{$factor};
560   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
561                                                                  'to num', $num, '* factor', $factor);
562                                                            }
563   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
564                                                         }
565                                                         else {
566   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
567                                                         }
568                                                      }
569                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
570   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
571                                                      }
572                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
573   ***     18            50                  188         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
574                                                      }
575                                                      else {
576          108                                257         MKDEBUG && _d('Nothing to validate for option',
577                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
578                                                      }
579                                                   
580          126                                412      return;
581                                                   }
582                                                   
583                                                   sub get {
584           81                   81           311      my ( $self, $opt ) = @_;
585   ***     81     50                         342      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
586   ***     81     50     33                  700      die "Option $opt does not exist"
587                                                         unless $long && exists $self->{opts}->{$long};
588           81                                566      return $self->{opts}->{$long}->{value};
589                                                   }
590                                                   
591                                                   sub got {
592           36                   36           153      my ( $self, $opt ) = @_;
593   ***     36     50                         153      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
594   ***     36     50     33                  318      die "Option $opt does not exist"
595                                                         unless $long && exists $self->{opts}->{$long};
596           36                                218      return $self->{opts}->{$long}->{got};
597                                                   }
598                                                   
599                                                   sub has {
600            9                    9            55      my ( $self, $opt ) = @_;
601   ***      9     50                          48      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
602   ***      9     50                          79      return defined $long ? exists $self->{opts}->{$long} : 0;
603                                                   }
604                                                   
605                                                   sub set {
606   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
607   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
608   ***      0      0      0                    0      die "Option $opt does not exist"
609                                                         unless $long && exists $self->{opts}->{$long};
610   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
611   ***      0                                  0      return;
612                                                   }
613                                                   
614                                                   sub save_error {
615   ***      0                    0             0      my ( $self, $error ) = @_;
616   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
617                                                   }
618                                                   
619                                                   sub errors {
620   ***      0                    0             0      my ( $self ) = @_;
621   ***      0                                  0      return $self->{errors};
622                                                   }
623                                                   
624                                                   sub prompt {
625   ***      0                    0             0      my ( $self ) = @_;
626   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
627                                                   }
628                                                   
629                                                   sub descr {
630   ***      0                    0             0      my ( $self ) = @_;
631   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
632                                                                 . "  For more details, please use the --help option, "
633                                                                 . "or try 'perldoc $PROGRAM_NAME' "
634                                                                 . "for complete documentation.";
635   ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
636                                                         unless $ENV{DONT_BREAK_LINES};
637   ***      0                                  0      $descr =~ s/ +$//mg;
638   ***      0                                  0      return $descr;
639                                                   }
640                                                   
641                                                   sub usage_or_errors {
642            9                    9            37      my ( $self ) = @_;
643   ***      9     50                          48      if ( $self->{opts}->{help}->{got} ) {
      ***      9     50                          44   
644   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
645   ***      0                                  0         exit 0;
646                                                      }
647                                                      elsif ( scalar @{$self->{errors}} ) {
648   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
649   ***      0                                  0         exit 0;
650                                                      }
651            9                                 27      return;
652                                                   }
653                                                   
654                                                   sub print_errors {
655   ***      0                    0             0      my ( $self ) = @_;
656   ***      0                                  0      my $usage = $self->prompt() . "\n";
657   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
658   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
659                                                                 . "\n";
660                                                      }
661   ***      0                                  0      return $usage . "\n" . $self->descr();
662                                                   }
663                                                   
664                                                   sub print_usage {
665   ***      0                    0             0      my ( $self ) = @_;
666   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
667   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
668                                                   
669   ***      0      0                           0      my $maxl = max(
670   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
671                                                         @opts);
672                                                   
673   ***      0      0                           0      my $maxs = max(0,
674   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
675   ***      0                                  0         values %{$self->{short_opts}});
676                                                   
677   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
678   ***      0                                  0      my $rcol = 80 - $lcol - 6;
679   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
680                                                   
681   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
682                                                   
683   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
684                                                   
685   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
686   ***      0                                  0      push @groups, 'default';
687                                                   
688   ***      0                                  0      foreach my $group ( reverse @groups ) {
689   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
690   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
691   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
692                                                            grep { $_->{group} eq $group }
693                                                            @opts )
694                                                         {
695   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
696   ***      0                                  0            my $short = $opt->{short};
697   ***      0                                  0            my $desc  = $opt->{desc};
698   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
699   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
700   ***      0             0                    0               $s    ||= 's';
701   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
702   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
703                                                                      . "d=days; if no suffix, $s is used.";
704                                                            }
705   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
706   ***      0                                  0            $desc =~ s/ +$//mg;
707   ***      0      0                           0            if ( $short ) {
708   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
709                                                            }
710                                                            else {
711   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
712                                                            }
713                                                         }
714                                                      }
715                                                   
716   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
717   ***      0                                  0         $usage .= "\nRules:\n\n";
718   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
719                                                      }
720   ***      0      0                           0      if ( $self->{dp} ) {
721   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
722                                                      }
723   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
724   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
725   ***      0                                  0         my $val   = $opt->{value};
726   ***      0             0                    0         my $type  = $opt->{type} || '';
727   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
728   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
729                                                                   : !defined $val             ? '(No value)'
730                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
731                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
732                                                                   : $type =~ m/A|a/           ? join(',', @$val)
733                                                                   :                             $val;
734   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
735                                                      }
736   ***      0                                  0      return $usage;
737                                                   }
738                                                   
739                                                   sub prompt_noecho {
740   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
741   ***      0                                  0      my ( $prompt ) = @_;
742   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
743   ***      0      0                           0      print $prompt
744                                                         or die "Cannot print: $OS_ERROR";
745   ***      0                                  0      my $response;
746   ***      0                                  0      eval {
747   ***      0                                  0         require Term::ReadKey;
748   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
749   ***      0                                  0         chomp($response = <STDIN>);
750   ***      0                                  0         Term::ReadKey::ReadMode('normal');
751   ***      0      0                           0         print "\n"
752                                                            or die "Cannot print: $OS_ERROR";
753                                                      };
754   ***      0      0                           0      if ( $EVAL_ERROR ) {
755   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
756                                                      }
757   ***      0                                  0      return $response;
758                                                   }
759                                                   
760                                                   if ( MKDEBUG ) {
761                                                      print '# ', $^X, ' ', $], "\n";
762                                                      my $uname = `uname -a`;
763                                                      if ( $uname ) {
764                                                         $uname =~ s/\s+/ /g;
765                                                         print "# $uname\n";
766                                                      }
767                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
768                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
769                                                         ($main::SVN_REV || ''), __LINE__);
770                                                      print('# Arguments: ',
771                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
772                                                   }
773                                                   
774                                                   sub _read_config_file {
775           36                   36           163      my ( $self, $filename ) = @_;
776   ***     36     50                          92      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
777   ***      0                                  0      my @args;
778   ***      0                                  0      my $prefix = '--';
779   ***      0                                  0      my $parse  = 1;
780                                                   
781                                                      LINE:
782   ***      0                                  0      while ( my $line = <$fh> ) {
783   ***      0                                  0         chomp $line;
784   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
785   ***      0                                  0         $line =~ s/\s+#.*$//g;
786   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
787   ***      0      0                           0         if ( $line eq '--' ) {
788   ***      0                                  0            $prefix = '';
789   ***      0                                  0            $parse  = 0;
790   ***      0                                  0            next LINE;
791                                                         }
792   ***      0      0      0                    0         if ( $parse
      ***             0                               
793                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
794                                                         ) {
795   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
796                                                         }
797                                                         elsif ( $line =~ m/./ ) {
798   ***      0                                  0            push @args, $line;
799                                                         }
800                                                         else {
801   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
802                                                         }
803                                                      }
804   ***      0                                  0      close $fh;
805   ***      0                                  0      return @args;
806                                                   }
807                                                   
808                                                   sub read_para_after {
809   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
810   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
811   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
812   ***      0                                  0      my $para;
813   ***      0                                  0      while ( $para = <$fh> ) {
814   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
815   ***      0                                  0         last;
816                                                      }
817   ***      0                                  0      while ( $para = <$fh> ) {
818   ***      0      0                           0         next unless $para =~ m/$regex/;
819   ***      0                                  0         last;
820                                                      }
821   ***      0                                  0      $para = <$fh>;
822   ***      0                                  0      chomp($para);
823   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
824   ***      0                                  0      return $para;
825                                                   }
826                                                   
827                                                   sub clone {
828   ***      0                    0             0      my ( $self ) = @_;
829                                                   
830   ***      0                                  0      my %clone = map {
831   ***      0                                  0         my $hashref  = $self->{$_};
832   ***      0                                  0         my $val_copy = {};
833   ***      0                                  0         foreach my $key ( keys %$hashref ) {
834   ***      0                                  0            my $ref = ref $hashref->{$key};
835   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
836   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
837   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
838                                                                              : $hashref->{$key};
839                                                         }
840   ***      0                                  0         $_ => $val_copy;
841                                                      } qw(opts short_opts defaults);
842                                                   
843   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
844   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
845                                                      }
846                                                   
847   ***      0                                  0      return bless \%clone;     
848                                                   }
849                                                   
850                                                   sub parse_section {
851            9                    9            87      my ( $self, %args ) = @_;
852            9                                 66      my ($file, $section, $subsection, $trf)
853                                                         = @args{qw(file section subsection trf)};
854                                                   
855   ***      9            50                   38      $file ||= __FILE__;
856   ***      9     50                         287      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
857                                                      
858            9                                 53      local $INPUT_RECORD_SEPARATOR = '';
859                                                   
860            9                                 27      my $para;
861            9                                178      while ( $para = <$fh> ) {
862         3582    100                       24926         next unless $para =~ m/^=head1 $section/o;
863            9                                 26         last;
864                                                      }
865                                                   
866   ***      9     50                          34      if ( $subsection ) {
867   ***      0                                  0         while ( $para = <$fh> ) {
868   ***      0      0                           0            next unless $para =~ m/^=head2 $subsection/o;
869                                                            last
870   ***      0                                  0         }
871                                                      }
872                                                   
873            9                                 24      my @chunks;
874            9                                 54      while ( $para = <$fh> ) {
875   ***    117     50                         577         last if ($subsection ? $para =~ m/^=head[12]/ : $para =~ m/^=head1/);
                    100                               
876          108    100                         546         next if $para =~ m/=head/;
877           81                                224         chomp $para;
878           81                                404         $para =~ s/$POD_link_re/$1/go;
879   ***     81     50                         287         if ( $trf ) {
880           81                                310            $para = $trf->($para);
881           81    100                         363            next unless $para;
882                                                         }
883           72                                585         push @chunks, $para;
884                                                      }
885                                                   
886            9                                 28      return @chunks;
887                                                   }
888                                                   
889                                                   sub _d {
890   ***      0                    0             0      my ($package, undef, $line) = caller 0;
891   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
892   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
893                                                           @_;
894   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
895                                                   }
896                                                   
897                                                   1;
898                                                   
899                                                   # ###########################################################################
900                                                   # End OptionParser package
901                                                   # ###########################################################################
902                                                   
903                                                   # ###########################################################################
904                                                   # SlowLogParser package 5357
905                                                   # ###########################################################################
906                                                   package SlowLogParser;
907                                                   
908            5                    5            56   use strict;
               5                                 15   
               5                                 43   
909            5                    5            35   use warnings FATAL => 'all';
               5                                 14   
               5                                 37   
910            5                    5            33   use English qw(-no_match_vars);
               5                                 17   
               5                                 32   
911            5                    5            31   use Data::Dumper;
               5                                 13   
               5                                 43   
912                                                   
913   ***      5            50      5            30   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 12   
               5                                 78   
914                                                   
915                                                   sub new {
916   ***      0                    0             0      my ( $class ) = @_;
917   ***      0                                  0      my $self = {
918                                                         pending => [],
919                                                      };
920   ***      0                                  0      return bless $self, $class;
921                                                   }
922                                                   
923                                                   my $slow_log_ts_line = qr/^# Time: ([0-9: ]{15})/;
924                                                   my $slow_log_uh_line = qr/# User\@Host: ([^\[]+|\[[^[]+\]).*?@ (\S*) \[(.*)\]/;
925                                                   my $slow_log_hd_line = qr{
926                                                         ^(?:
927                                                         T[cC][pP]\s[pP]ort:\s+\d+ # case differs on windows/unix
928                                                         |
929                                                         [/A-Z].*mysqld,\sVersion.*(?:started\swith:|embedded\slibrary)
930                                                         |
931                                                         Time\s+Id\s+Command
932                                                         ).*\n
933                                                      }xm;
934                                                   
935                                                   sub parse_event {
936   ***      0                    0             0      my ( $self, %args ) = @_;
937   ***      0                                  0      my @required_args = qw(next_event tell);
938   ***      0                                  0      foreach my $arg ( @required_args ) {
939   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
940                                                      }
941   ***      0                                  0      my ($next_event, $tell) = @args{@required_args};
942                                                   
943   ***      0                                  0      my $pending = $self->{pending};
944   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = ";\n#";
945   ***      0                                  0      my $trimlen    = length($INPUT_RECORD_SEPARATOR);
946   ***      0                                  0      my $pos_in_log = $tell->();
947   ***      0                                  0      my $stmt;
948                                                   
949                                                      EVENT:
950   ***      0             0                    0      while (
951                                                            defined($stmt = shift @$pending)
952                                                         or defined($stmt = $next_event->())
953                                                      ) {
954   ***      0                                  0         my @properties = ('cmd', 'Query', 'pos_in_log', $pos_in_log);
955   ***      0                                  0         $pos_in_log = $tell->();
956                                                   
957   ***      0      0                           0         if ( $stmt =~ s/$slow_log_hd_line//go ){ # Throw away header lines in log
958   ***      0                                  0            my @chunks = split(/$INPUT_RECORD_SEPARATOR/o, $stmt);
959   ***      0      0                           0            if ( @chunks > 1 ) {
960   ***      0                                  0               MKDEBUG && _d("Found multiple chunks");
961   ***      0                                  0               $stmt = shift @chunks;
962   ***      0                                  0               unshift @$pending, @chunks;
963                                                            }
964                                                         }
965                                                   
966   ***      0      0                           0         $stmt = '#' . $stmt unless $stmt =~ m/\A#/;
967   ***      0                                  0         $stmt =~ s/;\n#?\Z//;
968                                                   
969                                                   
970   ***      0                                  0         my ($got_ts, $got_uh, $got_ac, $got_db, $got_set, $got_embed);
971   ***      0                                  0         my $pos = 0;
972   ***      0                                  0         my $len = length($stmt);
973   ***      0                                  0         my $found_arg = 0;
974                                                         LINE:
975   ***      0                                  0         while ( $stmt =~ m/^(.*)$/mg ) { # /g is important, requires scalar match.
976   ***      0                                  0            $pos     = pos($stmt);  # Be careful not to mess this up!
977   ***      0                                  0            my $line = $1;          # Necessary for /g and pos() to work.
978   ***      0                                  0            MKDEBUG && _d($line);
979                                                   
980   ***      0      0                           0            if ($line =~ m/^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) {
981                                                   
982   ***      0      0      0                    0               if ( !$got_ts && (my ( $time ) = $line =~ m/$slow_log_ts_line/o)) {
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0                               
983   ***      0                                  0                  MKDEBUG && _d("Got ts", $time);
984   ***      0                                  0                  push @properties, 'ts', $time;
985   ***      0                                  0                  ++$got_ts;
986   ***      0      0      0                    0                  if ( !$got_uh
987                                                                     && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
988                                                                  ) {
989   ***      0                                  0                     MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
990   ***      0                                  0                     push @properties, 'user', $user, 'host', $host, 'ip', $ip;
991   ***      0                                  0                     ++$got_uh;
992                                                                  }
993                                                               }
994                                                   
995                                                               elsif ( !$got_uh
996                                                                     && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
997                                                               ) {
998   ***      0                                  0                  MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
999   ***      0                                  0                  push @properties, 'user', $user, 'host', $host, 'ip', $ip;
1000  ***      0                                  0                  ++$got_uh;
1001                                                              }
1002                                                  
1003                                                              elsif (!$got_ac && $line =~ m/^# (?:administrator command:.*)$/) {
1004  ***      0                                  0                  MKDEBUG && _d("Got admin command");
1005  ***      0                                  0                  push @properties, 'cmd', 'Admin', 'arg', $line;
1006  ***      0                                  0                  push @properties, 'bytes', length($properties[-1]);
1007  ***      0                                  0                  ++$found_arg;
1008  ***      0                                  0                  ++$got_ac;
1009                                                              }
1010                                                  
1011                                                              elsif ( $line =~ m/^# +[A-Z][A-Za-z_]+: \S+/ ) { # Make the test cheap!
1012  ***      0                                  0                  MKDEBUG && _d("Got some line with properties");
1013  ***      0                                  0                  my @temp = $line =~ m/(\w+):\s+(\S+|\Z)/g;
1014  ***      0                                  0                  push @properties, @temp;
1015                                                              }
1016                                                  
1017                                                              elsif ( !$got_db && (my ( $db ) = $line =~ m/^use ([^;]+)/ ) ) {
1018  ***      0                                  0                  MKDEBUG && _d("Got a default database:", $db);
1019  ***      0                                  0                  push @properties, 'db', $db;
1020  ***      0                                  0                  ++$got_db;
1021                                                              }
1022                                                  
1023                                                              elsif (!$got_set && (my ($setting) = $line =~ m/^SET\s+([^;]*)/)) {
1024  ***      0                                  0                  MKDEBUG && _d("Got some setting:", $setting);
1025  ***      0                                  0                  push @properties, split(/,|\s*=\s*/, $setting);
1026  ***      0                                  0                  ++$got_set;
1027                                                              }
1028                                                  
1029  ***      0      0      0                    0               if ( !$found_arg && $pos == $len ) {
1030  ***      0                                  0                  MKDEBUG && _d("Did not find arg, looking for special cases");
1031  ***      0                                  0                  local $INPUT_RECORD_SEPARATOR = ";\n";
1032  ***      0      0                           0                  if ( defined(my $l = $next_event->()) ) {
1033  ***      0                                  0                     chomp $l;
1034  ***      0                                  0                     MKDEBUG && _d("Found admin statement", $l);
1035  ***      0                                  0                     push @properties, 'cmd', 'Admin', 'arg', '#' . $l;
1036  ***      0                                  0                     push @properties, 'bytes', length($properties[-1]);
1037  ***      0                                  0                     $found_arg++;
1038                                                                 }
1039                                                                 else {
1040  ***      0                                  0                     MKDEBUG && _d("I can't figure out what to do with this line");
1041  ***      0                                  0                     next EVENT;
1042                                                                 }
1043                                                              }
1044                                                           }
1045                                                           else {
1046  ***      0                                  0               MKDEBUG && _d("Got the query/arg line");
1047  ***      0                                  0               my $arg = substr($stmt, $pos - length($line));
1048  ***      0                                  0               push @properties, 'arg', $arg, 'bytes', length($arg);
1049  ***      0      0      0                    0               if ( $args{misc} && $args{misc}->{embed}
      ***                    0                        
1050                                                                 && ( my ($e) = $arg =~ m/($args{misc}->{embed})/)
1051                                                              ) {
1052  ***      0                                  0                  push @properties, $e =~ m/$args{misc}->{capture}/g;
1053                                                              }
1054  ***      0                                  0               last LINE;
1055                                                           }
1056                                                        }
1057                                                  
1058  ***      0                                  0         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
1059  ***      0                                  0         my $event = { @properties };
1060  ***      0                                  0         return $event;
1061                                                     } # EVENT
1062                                                  
1063  ***      0                                  0      @$pending = ();
1064  ***      0      0                           0      $args{oktorun}->(0) if $args{oktorun};
1065  ***      0                                  0      return;
1066                                                  }
1067                                                  
1068                                                  sub _d {
1069  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1070  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1071  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1072                                                          @_;
1073  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1074                                                  }
1075                                                  
1076                                                  1;
1077                                                  
1078                                                  # ###########################################################################
1079                                                  # End SlowLogParser package
1080                                                  # ###########################################################################
1081                                                  
1082                                                  # ###########################################################################
1083                                                  # BinaryLogParser package 5358
1084                                                  # ###########################################################################
1085                                                  package BinaryLogParser;
1086                                                  
1087           5                    5            41   use strict;
               5                                 10   
               5                                 28   
1088           5                    5            29   use warnings FATAL => 'all';
               5                                 13   
               5                                 25   
1089           5                    5            30   use English qw(-no_match_vars);
               5                                 22   
               5                                 24   
1090                                                  
1091           5                    5            33   use Data::Dumper;
               5                                 13   
               5                                 26   
1092                                                  $Data::Dumper::Indent    = 1;
1093                                                  $Data::Dumper::Sortkeys  = 1;
1094                                                  $Data::Dumper::Quotekeys = 0;
1095                                                  
1096  ***      5            50      5            33   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 14   
               5                                 70   
1097                                                  
1098                                                  sub new {
1099  ***      0                    0             0      my ( $class, %args ) = @_;
1100  ***      0                                  0      my $self = {
1101                                                        delim     => undef,
1102                                                        delim_len => 0,
1103                                                     };
1104  ***      0                                  0      return bless $self, $class;
1105                                                  }
1106                                                  
1107                                                  my $binlog_line_1 = qr/at (\d+)$/m;
1108                                                  my $binlog_line_2 = qr/^#(\d{6}\s+\d{1,2}:\d\d:\d\d)\s+server\s+id\s+(\d+)\s+end_log_pos\s+(\d+)\s+(\S+)\s*([^\n]*)$/m;
1109                                                  my $binlog_line_2_rest = qr/thread_id=(\d+)\s+exec_time=(\d+)\s+error_code=(\d+)/m;
1110                                                  
1111                                                  sub parse_event {
1112  ***      0                    0             0      my ( $self, %args ) = @_;
1113  ***      0                                  0      my @required_args = qw(next_event tell);
1114  ***      0                                  0      foreach my $arg ( @required_args ) {
1115  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1116                                                     }
1117  ***      0                                  0      my ($next_event, $tell) = @args{@required_args};
1118                                                  
1119  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = ";\n#";
1120  ***      0                                  0      my $pos_in_log = $tell->();
1121  ***      0                                  0      my $stmt;
1122  ***      0                                  0      my ($delim, $delim_len) = ($self->{delim}, $self->{delim_len});
1123                                                  
1124                                                     EVENT:
1125  ***      0                                  0      while ( defined($stmt = $next_event->()) ) {
1126  ***      0                                  0         my @properties = ('pos_in_log', $pos_in_log);
1127  ***      0                                  0         my ($ts, $sid, $end, $type, $rest);
1128  ***      0                                  0         $pos_in_log = $tell->();
1129  ***      0                                  0         $stmt =~ s/;\n#?\Z//;
1130                                                  
1131  ***      0                                  0         my ( $got_offset, $got_hdr );
1132  ***      0                                  0         my $pos = 0;
1133  ***      0                                  0         my $len = length($stmt);
1134  ***      0                                  0         my $found_arg = 0;
1135                                                        LINE:
1136  ***      0                                  0         while ( $stmt =~ m/^(.*)$/mg ) { # /g requires scalar match.
1137  ***      0                                  0            $pos     = pos($stmt);  # Be careful not to mess this up!
1138  ***      0                                  0            my $line = $1;          # Necessary for /g and pos() to work.
1139  ***      0      0                           0            $line    =~ s/$delim// if $delim;
1140  ***      0                                  0            MKDEBUG && _d($line);
1141                                                  
1142  ***      0      0                           0            if ( $line =~ m/^\/\*.+\*\/;/ ) {
1143  ***      0                                  0               MKDEBUG && _d('Comment line');
1144  ***      0                                  0               next LINE;
1145                                                           }
1146                                                   
1147  ***      0      0                           0            if ( $line =~ m/^DELIMITER/m ) {
1148  ***      0                                  0               my ( $del ) = $line =~ m/^DELIMITER (\S*)$/m;
1149  ***      0      0                           0               if ( $del ) {
1150  ***      0                                  0                  $self->{delim_len} = $delim_len = length $del;
1151  ***      0                                  0                  $self->{delim}     = $delim     = quotemeta $del;
1152  ***      0                                  0                  MKDEBUG && _d('delimiter:', $delim);
1153                                                              }
1154                                                              else {
1155  ***      0                                  0                  MKDEBUG && _d('Delimiter reset to ;');
1156  ***      0                                  0                  $self->{delim}     = $delim     = undef;
1157  ***      0                                  0                  $self->{delim_len} = $delim_len = 0;
1158                                                              }
1159  ***      0                                  0               next LINE;
1160                                                           }
1161                                                  
1162  ***      0      0                           0            next LINE if $line =~ m/End of log file/;
1163                                                  
1164  ***      0      0      0                    0            if ( !$got_offset && (my ( $offset ) = $line =~ m/$binlog_line_1/m) ) {
      ***             0      0                        
      ***             0                               
1165  ***      0                                  0               MKDEBUG && _d('Got the at offset line');
1166  ***      0                                  0               push @properties, 'offset', $offset;
1167  ***      0                                  0               $got_offset++;
1168                                                           }
1169                                                  
1170                                                           elsif ( !$got_hdr && $line =~ m/^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/ ) {
1171  ***      0                                  0               ($ts, $sid, $end, $type, $rest) = $line =~ m/$binlog_line_2/m;
1172  ***      0                                  0               MKDEBUG && _d('Got the header line; type:', $type, 'rest:', $rest);
1173  ***      0                                  0               push @properties, 'cmd', 'Query', 'ts', $ts, 'server_id', $sid,
1174                                                                 'end_log_pos', $end;
1175  ***      0                                  0               $got_hdr++;
1176                                                           }
1177                                                  
1178                                                           elsif ( $line =~ m/^(?:#|use |SET)/i ) {
1179                                                  
1180  ***      0      0                           0               if ( my ( $db ) = $line =~ m/^use ([^;]+)/ ) {
      ***             0                               
1181  ***      0                                  0                  MKDEBUG && _d("Got a default database:", $db);
1182  ***      0                                  0                  push @properties, 'db', $db;
1183                                                              }
1184                                                  
1185                                                              elsif ( my ($setting) = $line =~ m/^SET\s+([^;]*)/ ) {
1186  ***      0                                  0                  MKDEBUG && _d("Got some setting:", $setting);
1187  ***      0                                  0                  push @properties, map { s/\s+//; lc } split(/,|\s*=\s*/, $setting);
      ***      0                                  0   
      ***      0                                  0   
1188                                                              }
1189                                                  
1190                                                           }
1191                                                           else {
1192  ***      0                                  0               MKDEBUG && _d("Got the query/arg line at pos", $pos);
1193  ***      0                                  0               $found_arg++;
1194  ***      0      0      0                    0               if ( $got_offset && $got_hdr ) {
1195  ***      0      0                           0                  if ( $type eq 'Xid' ) {
      ***             0                               
      ***             0                               
1196  ***      0                                  0                     my ($xid) = $rest =~ m/(\d+)/;
1197  ***      0                                  0                     push @properties, 'Xid', $xid;
1198                                                                 }
1199                                                                 elsif ( $type eq 'Query' ) {
1200  ***      0                                  0                     my ($i, $t, $c) = $rest =~ m/$binlog_line_2_rest/m;
1201  ***      0                                  0                     push @properties, 'Thread_id', $i, 'Query_time', $t,
1202                                                                                      'error_code', $c;
1203                                                                 }
1204                                                                 elsif ( $type eq 'Start:' ) {
1205  ***      0                                  0                     MKDEBUG && _d("Binlog start");
1206                                                                 }
1207                                                                 else {
1208  ***      0                                  0                     MKDEBUG && _d('Unknown event type:', $type);
1209  ***      0                                  0                     next EVENT;
1210                                                                 }
1211                                                              }
1212                                                              else {
1213  ***      0                                  0                  MKDEBUG && _d("It's not a query/arg, it's just some SQL fluff");
1214  ***      0                                  0                  push @properties, 'cmd', 'Query', 'ts', undef;
1215                                                              }
1216                                                  
1217  ***      0      0                           0               my $delim_len = ($pos == length($stmt) ? $delim_len : 0);
1218  ***      0                                  0               my $arg = substr($stmt, $pos - length($line) - $delim_len);
1219                                                  
1220  ***      0      0                           0               $arg =~ s/$delim// if $delim; # Remove the delimiter.
1221                                                  
1222  ***      0      0                           0               if ( $arg =~ m/^DELIMITER/m ) {
1223  ***      0                                  0                  my ( $del ) = $arg =~ m/^DELIMITER (\S*)$/m;
1224  ***      0      0                           0                  if ( $del ) {
1225  ***      0                                  0                     $self->{delim_len} = $delim_len = length $del;
1226  ***      0                                  0                     $self->{delim}     = $delim     = quotemeta $del;
1227  ***      0                                  0                     MKDEBUG && _d('delimiter:', $delim);
1228                                                                 }
1229                                                                 else {
1230  ***      0                                  0                     MKDEBUG && _d('Delimiter reset to ;');
1231  ***      0                                  0                     $del       = ';';
1232  ***      0                                  0                     $self->{delim}     = $delim     = undef;
1233  ***      0                                  0                     $self->{delim_len} = $delim_len = 0;
1234                                                                 }
1235                                                  
1236  ***      0                                  0                  $arg =~ s/^DELIMITER.*$//m;  # Remove DELIMITER from arg.
1237                                                              }
1238                                                  
1239  ***      0                                  0               $arg =~ s/;$//gm;  # Ensure ending ; are gone.
1240  ***      0                                  0               $arg =~ s/\s+$//;  # Remove trailing spaces and newlines.
1241                                                  
1242  ***      0                                  0               push @properties, 'arg', $arg, 'bytes', length($arg);
1243  ***      0                                  0               last LINE;
1244                                                           }
1245                                                        } # LINE
1246                                                  
1247  ***      0      0                           0         if ( $found_arg ) {
1248  ***      0                                  0            MKDEBUG && _d('Properties of event:', Dumper(\@properties));
1249  ***      0                                  0            my $event = { @properties };
1250  ***      0                                  0            return $event;
1251                                                        }
1252                                                        else {
1253  ***      0                                  0            MKDEBUG && _d('Event had no arg');
1254                                                        }
1255                                                     } # EVENT
1256                                                  
1257  ***      0      0                           0      $args{oktorun}->(0) if $args{oktorun};
1258  ***      0                                  0      return;
1259                                                  }
1260                                                  
1261                                                  sub _d {
1262  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1263  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1264  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1265                                                          @_;
1266  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1267                                                  }
1268                                                  
1269                                                  1;
1270                                                  
1271                                                  # ###########################################################################
1272                                                  # End BinaryLogParser package
1273                                                  # ###########################################################################
1274                                                  
1275                                                  # ###########################################################################
1276                                                  # QueryParser package 5783
1277                                                  # ###########################################################################
1278                                                  package QueryParser;
1279                                                  
1280           5                    5            39   use strict;
               5                                 13   
               5                                 31   
1281           5                    5            32   use warnings FATAL => 'all';
               5                                 19   
               5                                 27   
1282           5                    5            29   use English qw(-no_match_vars);
               5                                 13   
               5                                 27   
1283                                                  
1284  ***      5            50      5            34   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 12   
               5                                 67   
1285                                                  our $tbl_ident = qr/(?:`[^`]+`|\w+)(?:\.(?:`[^`]+`|\w+))?/;
1286                                                  our $tbl_regex = qr{
1287                                                           \b(?:FROM|JOIN|(?<!KEY\s)UPDATE|INTO) # Words that precede table names
1288                                                           \b\s*
1289                                                           \(?                                   # Optional paren around tables
1290                                                           ($tbl_ident
1291                                                              (?: (?:\s+ (?:AS\s+)? \w+)?, \s*$tbl_ident )*
1292                                                           )
1293                                                        }xio;
1294                                                  our $has_derived = qr{
1295                                                        \b(?:FROM|JOIN|,)
1296                                                        \s*\(\s*SELECT
1297                                                     }xi;
1298                                                  
1299                                                  our $data_def_stmts = qr/(?:CREATE|ALTER|TRUNCATE|DROP|RENAME)/i;
1300                                                  
1301                                                  our $data_manip_stmts = qr/(?:INSERT|UPDATE|DELETE|REPLACE)/i;
1302                                                  
1303                                                  sub new {
1304           9                    9            46      my ( $class ) = @_;
1305           9                                 73      bless {}, $class;
1306                                                  }
1307                                                  
1308                                                  sub get_tables {
1309  ***      0                    0             0      my ( $self, $query ) = @_;
1310  ***      0      0                           0      return unless $query;
1311  ***      0                                  0      MKDEBUG && _d('Getting tables for', $query);
1312                                                  
1313  ***      0                                  0      my ( $ddl_stmt ) = $query =~ m/^\s*($data_def_stmts)\b/i;
1314  ***      0      0                           0      if ( $ddl_stmt ) {
1315  ***      0                                  0         MKDEBUG && _d('Special table type:', $ddl_stmt);
1316  ***      0                                  0         $query =~ s/IF NOT EXISTS//i;
1317  ***      0      0                           0         if ( $query =~ m/$ddl_stmt DATABASE\b/i ) {
1318  ***      0                                  0            MKDEBUG && _d('Query alters a database, not a table');
1319  ***      0                                  0            return ();
1320                                                        }
1321  ***      0      0      0                    0         if ( $ddl_stmt =~ m/CREATE/i && $query =~ m/$ddl_stmt\b.+?\bSELECT\b/i ) {
1322  ***      0                                  0            my ($select) = $query =~ m/\b(SELECT\b.+)/is;
1323  ***      0                                  0            MKDEBUG && _d('CREATE TABLE ... SELECT:', $select);
1324  ***      0                                  0            return $self->get_tables($select);
1325                                                        }
1326  ***      0                                  0         my ($tbl) = $query =~ m/TABLE\s+($tbl_ident)(\s+.*)?/i;
1327  ***      0                                  0         MKDEBUG && _d('Matches table:', $tbl);
1328  ***      0                                  0         return ($tbl);
1329                                                     }
1330                                                  
1331  ***      0                                  0      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
1332                                                  
1333  ***      0      0                           0      if ( $query =~ /^\s*LOCK TABLES/i ) {
1334  ***      0                                  0         MKDEBUG && _d('Special table type: LOCK TABLES');
1335  ***      0                                  0         $query =~ s/^(\s*LOCK TABLES\s+)//;
1336  ***      0                                  0         $query =~ s/\s+(?:READ|WRITE|LOCAL)+\s*//g;
1337  ***      0                                  0         MKDEBUG && _d('Locked tables:', $query);
1338  ***      0                                  0         $query = "FROM $query";
1339                                                     }
1340                                                  
1341  ***      0                                  0      $query =~ s/\\["']//g;                # quoted strings
1342  ***      0                                  0      $query =~ s/".*?"/?/sg;               # quoted strings
1343  ***      0                                  0      $query =~ s/'.*?'/?/sg;               # quoted strings
1344                                                  
1345  ***      0                                  0      my @tables;
1346  ***      0                                  0      foreach my $tbls ( $query =~ m/$tbl_regex/gio ) {
1347  ***      0                                  0         MKDEBUG && _d('Match tables:', $tbls);
1348                                                  
1349  ***      0      0                           0         next if $tbls =~ m/\ASELECT\b/i;
1350                                                  
1351  ***      0                                  0         foreach my $tbl ( split(',', $tbls) ) {
1352  ***      0                                  0            $tbl =~ s/\s*($tbl_ident)(\s+.*)?/$1/gio;
1353                                                  
1354  ***      0      0                           0            if ( $tbl !~ m/[a-zA-Z]/ ) {
1355  ***      0                                  0               MKDEBUG && _d('Skipping suspicious table name:', $tbl);
1356  ***      0                                  0               next;
1357                                                           }
1358                                                  
1359  ***      0                                  0            push @tables, $tbl;
1360                                                        }
1361                                                     }
1362  ***      0                                  0      return @tables;
1363                                                  }
1364                                                  
1365                                                  sub has_derived_table {
1366  ***      0                    0             0      my ( $self, $query ) = @_;
1367  ***      0                                  0      my $match = $query =~ m/$has_derived/;
1368  ***      0                                  0      MKDEBUG && _d($query, 'has ' . ($match ? 'a' : 'no') . ' derived table');
1369  ***      0                                  0      return $match;
1370                                                  }
1371                                                  
1372                                                  sub get_aliases {
1373           9                    9            43      my ( $self, $query, $list ) = @_;
1374  ***      9     50                          37      return unless $query;
1375           9                                 19      my $aliases;
1376                                                  
1377           9                                 53      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
1378                                                  
1379           9                                 58      $query =~ s/ (?:INNER|OUTER|CROSS|LEFT|RIGHT|NATURAL)//ig;
1380                                                  
1381           9                                129      my ($tbl_refs, $from) = $query =~ m{
1382                                                        (
1383                                                           (FROM|INTO|UPDATE)\b\s*   # Keyword before table refs
1384                                                           .+?                       # Table refs
1385                                                        )
1386                                                        (?:\s+|\z)                   # If the query does not end with the table
1387                                                        (?:WHERE|ORDER|LIMIT|HAVING|SET|VALUES|\z) # Keyword after table refs
1388                                                     }ix;
1389                                                  
1390  ***      9     50                          40      if ( !$tbl_refs ) {
1391  ***      0                                  0         MKDEBUG && _d("No tables ref in", $query);
1392  ***      0      0                           0         return $list ? [] : {};
1393                                                     }
1394                                                  
1395           9    100                          55      if ( $query =~ m/^(?:INSERT|REPLACE)/i ) {
1396           2                                 15         $tbl_refs =~ s/\([^\)]+\)\s*//;
1397                                                     }
1398                                                  
1399           9                                 23      MKDEBUG && _d('tbl refs:', $tbl_refs);
1400                                                  
1401           9                                104      my $before_tbl = qr/(?:,|JOIN|\s|$from)+/i;
1402                                                  
1403           9                                 36      my $after_tbl  = qr/(?:,|JOIN|ON|USING|\z)/i;
1404                                                  
1405           9                                 32      $tbl_refs =~ s/ = /=/g;
1406                                                  
1407           9                                162      while (
1408                                                        $tbl_refs =~ m{
1409                                                           $before_tbl\b\s*
1410                                                              ( ($tbl_ident) (?:\s+ (?:AS\s+)? (\w+))? )
1411                                                           \s*$after_tbl
1412                                                        }xgio )
1413                                                     {
1414           9                                 71         my ( $tbl_ref, $db_tbl, $alias ) = ($1, $2, $3);
1415           9                                 26         MKDEBUG && _d('Match table:', $tbl_ref);
1416                                                  
1417  ***      9     50                          48         if ( $tbl_ref =~ m/^AS\s+\w+/i ) {
1418  ***      0                                  0            MKDEBUG && _d('Subquery', $tbl_ref);
1419  ***      0      0                           0            $aliases->{$alias} = undef unless $list;
1420  ***      0                                  0            next;
1421                                                        }
1422                                                  
1423  ***      9     50                          34         if ( $list ) {
1424           9                                 50            $tbl_ref =~ s/^\s+//g;
1425           9                                 34            $tbl_ref =~ s/\s+$//g;
1426           9                                 81            push @$aliases, $tbl_ref;
1427                                                        }
1428                                                        else {
1429  ***      0                                  0            my ( $db, $tbl ) = $db_tbl =~ m/^(?:(.*?)\.)?(.*)/;
1430  ***      0             0                    0            $aliases->{$alias || $tbl} = $tbl;
1431  ***      0      0                           0            $aliases->{DATABASE}->{$tbl} = $db if $db;
1432                                                        }
1433                                                     }
1434           9                                 77      return $aliases;
1435                                                  }
1436                                                  
1437                                                  sub split {
1438  ***      0                    0             0      my ( $self, $query ) = @_;
1439  ***      0      0                           0      return unless $query;
1440  ***      0                                  0      $query = $self->clean_query($query);
1441  ***      0                                  0      MKDEBUG && _d('Splitting', $query);
1442                                                  
1443  ***      0                                  0      my $verbs = qr{SELECT|INSERT|UPDATE|DELETE|REPLACE|UNION|CREATE}i;
1444                                                  
1445  ***      0                                  0      my @split_statements = grep { $_ } split(m/\b($verbs\b(?!(?:\s*\()))/io, $query);
      ***      0                                  0   
1446                                                  
1447  ***      0                                  0      my @statements;
1448  ***      0      0                           0      if ( @split_statements == 1 ) {
1449  ***      0                                  0         push @statements, $query;
1450                                                     }
1451                                                     else {
1452                                                        for ( my $i = 0; $i <= $#split_statements; $i += 2 ) {
1453  ***      0                                  0            push @statements, $split_statements[$i].$split_statements[$i+1];
1454                                                  
1455  ***      0      0      0                    0            if ( $statements[-2] && $statements[-2] =~ m/on duplicate key\s+$/i ) {
1456  ***      0                                  0               $statements[-2] .= pop @statements;
1457                                                           }
1458  ***      0                                  0         }
1459                                                     }
1460                                                  
1461  ***      0                                  0      MKDEBUG && _d('statements:', map { $_ ? "<$_>" : 'none' } @statements);
1462  ***      0                                  0      return @statements;
1463                                                  }
1464                                                  
1465                                                  sub clean_query {
1466           9                    9            41      my ( $self, $query ) = @_;
1467  ***      9     50                          35      return unless $query;
1468           9                                 40      $query =~ s!/\*.*?\*/! !g;  # Remove /* comment blocks */
1469           9                                 48      $query =~ s/^\s+//;         # Remove leading spaces
1470           9                                 45      $query =~ s/\s+$//;         # Remove trailing spaces
1471           9                                 35      $query =~ s/\s{2,}/ /g;     # Remove extra spaces
1472           9                                 36      return $query;
1473                                                  }
1474                                                  
1475                                                  sub split_subquery {
1476  ***      0                    0             0      my ( $self, $query ) = @_;
1477  ***      0      0                           0      return unless $query;
1478  ***      0                                  0      $query = $self->clean_query($query);
1479  ***      0                                  0      $query =~ s/;$//;
1480                                                  
1481  ***      0                                  0      my @subqueries;
1482  ***      0                                  0      my $sqno = 0;  # subquery number
1483  ***      0                                  0      my $pos  = 0;
1484  ***      0                                  0      while ( $query =~ m/(\S+)(?:\s+|\Z)/g ) {
1485  ***      0                                  0         $pos = pos($query);
1486  ***      0                                  0         my $word = $1;
1487  ***      0                                  0         MKDEBUG && _d($word, $sqno);
1488  ***      0      0                           0         if ( $word =~ m/^\(?SELECT\b/i ) {
1489  ***      0                                  0            my $start_pos = $pos - length($word) - 1;
1490  ***      0      0                           0            if ( $start_pos ) {
1491  ***      0                                  0               $sqno++;
1492  ***      0                                  0               MKDEBUG && _d('Subquery', $sqno, 'starts at', $start_pos);
1493  ***      0                                  0               $subqueries[$sqno] = {
1494                                                                 start_pos => $start_pos,
1495                                                                 end_pos   => 0,
1496                                                                 len       => 0,
1497                                                                 words     => [$word],
1498                                                                 lp        => 1, # left parentheses
1499                                                                 rp        => 0, # right parentheses
1500                                                                 done      => 0,
1501                                                              };
1502                                                           }
1503                                                           else {
1504  ***      0                                  0               MKDEBUG && _d('Main SELECT at pos 0');
1505                                                           }
1506                                                        }
1507                                                        else {
1508  ***      0      0                           0            next unless $sqno;  # next unless we're in a subquery
1509  ***      0                                  0            MKDEBUG && _d('In subquery', $sqno);
1510  ***      0                                  0            my $sq = $subqueries[$sqno];
1511  ***      0      0                           0            if ( $sq->{done} ) {
1512  ***      0                                  0               MKDEBUG && _d('This subquery is done; SQL is for',
1513                                                                 ($sqno - 1 ? "subquery $sqno" : "the main SELECT"));
1514  ***      0                                  0               next;
1515                                                           }
1516  ***      0                                  0            push @{$sq->{words}}, $word;
      ***      0                                  0   
1517  ***      0             0                    0            my $lp = ($word =~ tr/\(//) || 0;
1518  ***      0             0                    0            my $rp = ($word =~ tr/\)//) || 0;
1519  ***      0                                  0            MKDEBUG && _d('parentheses left', $lp, 'right', $rp);
1520  ***      0      0                           0            if ( ($sq->{lp} + $lp) - ($sq->{rp} + $rp) == 0 ) {
1521  ***      0                                  0               my $end_pos = $pos - 1;
1522  ***      0                                  0               MKDEBUG && _d('Subquery', $sqno, 'ends at', $end_pos);
1523  ***      0                                  0               $sq->{end_pos} = $end_pos;
1524  ***      0                                  0               $sq->{len}     = $end_pos - $sq->{start_pos};
1525                                                           }
1526                                                        }
1527                                                     }
1528                                                  
1529  ***      0                                  0      for my $i ( 1..$#subqueries ) {
1530  ***      0                                  0         my $sq = $subqueries[$i];
1531  ***      0      0                           0         next unless $sq;
1532  ***      0                                  0         $sq->{sql} = join(' ', @{$sq->{words}});
      ***      0                                  0   
1533  ***      0                                  0         substr $query,
1534                                                           $sq->{start_pos} + 1,  # +1 for (
1535                                                           $sq->{len} - 1,        # -1 for )
1536                                                           "__subquery_$i";
1537                                                     }
1538                                                  
1539  ***      0                                  0      return $query, map { $_->{sql} } grep { defined $_ } @subqueries;
      ***      0                                  0   
      ***      0                                  0   
1540                                                  }
1541                                                  
1542                                                  sub query_type {
1543  ***      0                    0             0      my ( $self, $query, $qr ) = @_;
1544  ***      0                                  0      my ($type, undef) = $qr->distill_verbs($query);
1545  ***      0                                  0      my $rw;
1546  ***      0      0      0                    0      if ( $type =~ m/^SELECT\b/ ) {
      ***             0                               
1547  ***      0                                  0         $rw = 'read';
1548                                                     }
1549                                                     elsif ( $type =~ m/^$data_manip_stmts\b/
1550                                                             || $type =~ m/^$data_def_stmts\b/  ) {
1551  ***      0                                  0         $rw = 'write'
1552                                                     }
1553                                                  
1554                                                     return {
1555  ***      0                                  0         type => $type,
1556                                                        rw   => $rw,
1557                                                     }
1558                                                  }
1559                                                  
1560                                                  sub get_columns {
1561           9                    9            40      my ( $self, $query ) = @_;
1562           9                                 33      my $cols = [];
1563  ***      9     50                          34      return $cols unless $query;
1564           9                                 20      my $cols_def;
1565                                                  
1566           9    100                          54      if ( $query =~ m/^SELECT/i ) {
      ***            50                               
1567           7                                 25         $query =~ s/
1568                                                           ^SELECT\s+
1569                                                             (?:ALL
1570                                                                |DISTINCT
1571                                                                |DISTINCTROW
1572                                                                |HIGH_PRIORITY
1573                                                                |STRAIGHT_JOIN
1574                                                                |SQL_SMALL_RESULT
1575                                                                |SQL_BIG_RESULT
1576                                                                |SQL_BUFFER_RESULT
1577                                                                |SQL_CACHE
1578                                                                |SQL_NO_CACHE
1579                                                                |SQL_CALC_FOUND_ROWS
1580                                                             )\s+
1581                                                        /SELECT /xgi;
1582           7                                 49         ($cols_def) = $query =~ m/^SELECT\s+(.+?)\s+FROM/i;
1583                                                     }
1584                                                     elsif ( $query =~ m/^(?:INSERT|REPLACE)/i ) {
1585           2                                 18         ($cols_def) = $query =~ m/\(([^\)]+)\)\s*VALUE/i;
1586                                                     }
1587                                                  
1588           9                                 22      MKDEBUG && _d('Columns:', $cols_def);
1589           9    100                          37      if ( $cols_def ) {
1590           7                                 48         @$cols = split(',', $cols_def);
1591           9                                 24         map {
1592           7                                 29            my $col = $_;
1593           9                                 42            $col = s/^\s+//g;
1594           9                                 33            $col = s/\s+$//g;
1595           9                                 29            $col;
1596                                                        } @$cols;
1597                                                     }
1598                                                  
1599           9                                 41      return $cols;
1600                                                  }
1601                                                  
1602                                                  sub parse {
1603           9                    9            41      my ( $self, $query ) = @_;
1604  ***      9     50                          39      return unless $query;
1605           9                                 28      my $parsed = {};
1606                                                  
1607           9                                 33      $query =~ s/\n/ /g;
1608           9                                 70      $query = $self->clean_query($query);
1609                                                  
1610           9                                 44      $parsed->{query}   = [ $query ];
1611           9                                 72      $parsed->{tables}  = $self->get_aliases($query, 1);
1612           9                                 59      $parsed->{columns} = $self->get_columns($query);
1613                                                  
1614           9                                 62      my ($dms) = $query =~ m/^(\w+)/;
1615           9                                 65      $parsed->{dms} = [ lc $dms ],
1616                                                  
1617                                                  
1618                                                     return $parsed;
1619                                                  }
1620                                                  
1621                                                  sub _d {
1622  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1623  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1624  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1625                                                          @_;
1626  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1627                                                  }
1628                                                  
1629                                                  1;
1630                                                  
1631                                                  # ###########################################################################
1632                                                  # End QueryParser package
1633                                                  # ###########################################################################
1634                                                  
1635                                                  # ###########################################################################
1636                                                  # QueryRewriter package 5563
1637                                                  # ###########################################################################
1638           5                    5            41   use strict;
               5                                 16   
               5                                 29   
1639           5                    5            29   use warnings FATAL => 'all';
               5                                 13   
               5                                 28   
1640                                                  
1641                                                  package QueryRewriter;
1642                                                  
1643           5                    5            32   use English qw(-no_match_vars);
               5                                 11   
               5                                 29   
1644                                                  
1645  ***      5            50      5            34   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 13   
               5                                 72   
1646                                                  
1647                                                  our $verbs   = qr{^SHOW|^FLUSH|^COMMIT|^ROLLBACK|^BEGIN|SELECT|INSERT
1648                                                                    |UPDATE|DELETE|REPLACE|^SET|UNION|^START|^LOCK}xi;
1649                                                  my $quote_re = qr/"(?:(?!(?<!\\)").)*"|'(?:(?!(?<!\\)').)*'/; # Costly!
1650                                                  my $bal;
1651                                                  $bal         = qr/
1652                                                                    \(
1653                                                                    (?:
1654                                                                       (?> [^()]+ )    # Non-parens without backtracking
1655                                                                       |
1656                                                                       (??{ $bal })    # Group with matching parens
1657                                                                    )*
1658                                                                    \)
1659                                                                   /x;
1660                                                  
1661                                                  my $olc_re = qr/(?:--|#)[^'"\r\n]*(?=[\r\n]|\Z)/;  # One-line comments
1662                                                  my $mlc_re = qr#/\*[^!].*?\*/#sm;                  # But not /*!version */
1663                                                  my $vlc_re = qr#/\*.*?[0-9+].*?\*/#sm;             # For SHOW + /*!version */
1664                                                  my $vlc_rf = qr#^(SHOW).*?/\*![0-9+].*?\*/#sm;     # Variation for SHOW
1665                                                  
1666                                                  
1667                                                  sub new {
1668           9                    9            48      my ( $class, %args ) = @_;
1669           9                                 47      my $self = { %args };
1670           9                                 64      return bless $self, $class;
1671                                                  }
1672                                                  
1673                                                  sub strip_comments {
1674  ***      0                    0             0      my ( $self, $query ) = @_;
1675  ***      0      0                           0      return unless $query;
1676  ***      0                                  0      $query =~ s/$olc_re//go;
1677  ***      0                                  0      $query =~ s/$mlc_re//go;
1678  ***      0      0                           0      if ( $query =~ m/$vlc_rf/i ) { # contains show + version
1679  ***      0                                  0         $query =~ s/$vlc_re//go;
1680                                                     }
1681  ***      0                                  0      return $query;
1682                                                  }
1683                                                  
1684                                                  sub shorten {
1685  ***      0                    0             0      my ( $self, $query, $length ) = @_;
1686  ***      0                                  0      $query =~ s{
1687                                                        \A(
1688                                                           (?:INSERT|REPLACE)
1689                                                           (?:\s+LOW_PRIORITY|DELAYED|HIGH_PRIORITY|IGNORE)?
1690                                                           (?:\s\w+)*\s+\S+\s+VALUES\s*\(.*?\)
1691                                                        )
1692                                                        \s*,\s*\(.*?(ON\s+DUPLICATE|\Z)}
1693                                                        {$1 /*... omitted ...*/$2}xsi;
1694                                                  
1695  ***      0      0                           0      return $query unless $query =~ m/IN\s*\(\s*(?!select)/i;
1696                                                  
1697  ***      0                                  0      my $last_length  = 0;
1698  ***      0                                  0      my $query_length = length($query);
1699  ***      0             0                    0      while (
      ***                    0                        
      ***                    0                        
1700                                                        $length          > 0
1701                                                        && $query_length > $length
1702                                                        && $query_length < ( $last_length || $query_length + 1 )
1703                                                     ) {
1704  ***      0                                  0         $last_length = $query_length;
1705  ***      0                                  0         $query =~ s{
1706  ***      0                                  0            (\bIN\s*\()    # The opening of an IN list
1707                                                           ([^\)]+)       # Contents of the list, assuming no item contains paren
1708                                                           (?=\))           # Close of the list
1709                                                        }
1710                                                        {
1711                                                           $1 . __shorten($2)
1712                                                        }gexsi;
1713                                                     }
1714                                                  
1715  ***      0                                  0      return $query;
1716                                                  }
1717                                                  
1718                                                  sub __shorten {
1719  ***      0                    0             0      my ( $snippet ) = @_;
1720  ***      0                                  0      my @vals = split(/,/, $snippet);
1721  ***      0      0                           0      return $snippet unless @vals > 20;
1722  ***      0                                  0      my @keep = splice(@vals, 0, 20);  # Remove and save the first 20 items
1723                                                     return
1724  ***      0                                  0         join(',', @keep)
1725                                                        . "/*... omitted "
1726                                                        . scalar(@vals)
1727                                                        . " items ...*/";
1728                                                  }
1729                                                  
1730                                                  sub fingerprint {
1731  ***      0                    0             0      my ( $self, $query ) = @_;
1732                                                  
1733  ***      0      0                           0      $query =~ m#\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `# # mysqldump query
1734                                                        && return 'mysqldump';
1735  ***      0      0                           0      $query =~ m#/\*\w+\.\w+:[0-9]/[0-9]\*/#     # mk-table-checksum, etc query
1736                                                        && return 'maatkit';
1737  ***      0      0                           0      $query =~ m/\A# administrator command: /
1738                                                        && return $query;
1739  ***      0      0                           0      $query =~ m/\A\s*(call\s+\S+)\(/i
1740                                                        && return lc($1); # Warning! $1 used, be careful.
1741  ***      0      0                           0      if ( my ($beginning) = $query =~ m/\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is ) {
1742  ***      0                                  0         $query = $beginning; # Shorten multi-value INSERT statements ASAP
1743                                                     }
1744                                                  
1745  ***      0                                  0      $query =~ s/$olc_re//go;
1746  ***      0                                  0      $query =~ s/$mlc_re//go;
1747  ***      0      0                           0      $query =~ s/\Ause \S+\Z/use ?/i       # Abstract the DB in USE
1748                                                        && return $query;
1749                                                  
1750  ***      0                                  0      $query =~ s/\\["']//g;                # quoted strings
1751  ***      0                                  0      $query =~ s/".*?"/?/sg;               # quoted strings
1752  ***      0                                  0      $query =~ s/'.*?'/?/sg;               # quoted strings
1753  ***      0                                  0      $query =~ s/[0-9+-][0-9a-f.xb+-]*/?/g;# Anything vaguely resembling numbers
1754  ***      0                                  0      $query =~ s/[xb.+-]\?/?/g;            # Clean up leftovers
1755  ***      0                                  0      $query =~ s/\A\s+//;                  # Chop off leading whitespace
1756  ***      0                                  0      chomp $query;                         # Kill trailing whitespace
1757  ***      0                                  0      $query =~ tr[ \n\t\r\f][ ]s;          # Collapse whitespace
1758  ***      0                                  0      $query = lc $query;
1759  ***      0                                  0      $query =~ s/\bnull\b/?/g;             # Get rid of NULLs
1760  ***      0                                  0      $query =~ s{                          # Collapse IN and VALUES lists
1761                                                                 \b(in|values?)(?:[\s,]*\([\s?,]*\))+
1762                                                                }
1763                                                                {$1(?+)}gx;
1764  ***      0                                  0      $query =~ s{                          # Collapse UNION
1765                                                                 \b(select\s.*?)(?:(\sunion(?:\sall)?)\s\1)+
1766                                                                }
1767                                                                {$1 /*repeat$2*/}xg;
1768  ***      0                                  0      $query =~ s/\blimit \?(?:, ?\?| offset \?)?/limit ?/; # LIMIT
1769  ***      0                                  0      return $query;
1770                                                  }
1771                                                  
1772                                                  sub distill_verbs {
1773  ***      0                    0             0      my ( $self, $query ) = @_;
1774                                                  
1775  ***      0      0                           0      $query =~ m/\A\s*call\s+(\S+)\(/i && return "CALL $1";
1776  ***      0      0                           0      $query =~ m/\A\s*use\s+/          && return "USE";
1777  ***      0      0                           0      $query =~ m/\A\s*UNLOCK TABLES/i  && return "UNLOCK";
1778  ***      0      0                           0      $query =~ m/\A\s*xa\s+(\S+)/i     && return "XA_$1";
1779                                                  
1780  ***      0      0                           0      if ( $query =~ m/\A# administrator command:/ ) {
1781  ***      0                                  0         $query =~ s/# administrator command:/ADMIN/go;
1782  ***      0                                  0         $query = uc $query;
1783  ***      0                                  0         return $query;
1784                                                     }
1785                                                  
1786  ***      0                                  0      $query = $self->strip_comments($query);
1787                                                  
1788  ***      0      0                           0      if ( $query =~ m/\A\s*SHOW\s+/i ) {
1789  ***      0                                  0         MKDEBUG && _d($query);
1790                                                  
1791  ***      0                                  0         $query = uc $query;
1792  ***      0                                  0         $query =~ s/\s+(?:GLOBAL|SESSION|FULL|STORAGE|ENGINE)\b/ /g;
1793  ***      0                                  0         $query =~ s/\s+COUNT[^)]+\)//g;
1794                                                  
1795  ***      0                                  0         $query =~ s/\s+(?:FOR|FROM|LIKE|WHERE|LIMIT|IN)\b.+//ms;
1796                                                  
1797  ***      0                                  0         $query =~ s/\A(SHOW(?:\s+\S+){1,2}).*\Z/$1/s;
1798  ***      0                                  0         $query =~ s/\s+/ /g;
1799  ***      0                                  0         MKDEBUG && _d($query);
1800  ***      0                                  0         return $query;
1801                                                     }
1802                                                  
1803  ***      0                                  0      eval $QueryParser::data_def_stmts;
1804  ***      0                                  0      eval $QueryParser::tbl_ident;
1805  ***      0                                  0      my ( $dds ) = $query =~ /^\s*($QueryParser::data_def_stmts)\b/i;
1806  ***      0      0                           0      if ( $dds) {
1807  ***      0                                  0         my ( $obj ) = $query =~ m/$dds.+(DATABASE|TABLE)\b/i;
1808  ***      0      0                           0         $obj = uc $obj if $obj;
1809  ***      0                                  0         MKDEBUG && _d('Data def statment:', $dds, 'obj:', $obj);
1810  ***      0                                  0         my ($db_or_tbl)
1811                                                           = $query =~ m/(?:TABLE|DATABASE)\s+($QueryParser::tbl_ident)(\s+.*)?/i;
1812  ***      0                                  0         MKDEBUG && _d('Matches db or table:', $db_or_tbl);
1813  ***      0      0                           0         return uc($dds . ($obj ? " $obj" : '')), $db_or_tbl;
1814                                                     }
1815                                                  
1816  ***      0                                  0      my @verbs = $query =~ m/\b($verbs)\b/gio;
1817  ***      0                                  0      @verbs    = do {
1818  ***      0                                  0         my $last = '';
1819  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } map { uc } @verbs;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
1820                                                     };
1821  ***      0                                  0      my $verbs = join(q{ }, @verbs);
1822  ***      0                                  0      $verbs =~ s/( UNION SELECT)+/ UNION/g;
1823                                                  
1824  ***      0                                  0      return $verbs;
1825                                                  }
1826                                                  
1827                                                  sub __distill_tables {
1828  ***      0                    0             0      my ( $self, $query, $table, %args ) = @_;
1829  ***      0             0                    0      my $qp = $args{QueryParser} || $self->{QueryParser};
1830  ***      0      0                           0      die "I need a QueryParser argument" unless $qp;
1831                                                  
1832  ***      0                                  0      my @tables = map {
1833  ***      0                                  0         $_ =~ s/`//g;
1834  ***      0                                  0         $_ =~ s/(_?)[0-9]+/$1?/g;
1835  ***      0                                  0         $_;
1836  ***      0                                  0      } grep { defined $_ } $qp->get_tables($query);
1837                                                  
1838  ***      0      0                           0      push @tables, $table if $table;
1839                                                  
1840  ***      0                                  0      @tables = do {
1841  ***      0                                  0         my $last = '';
1842  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } @tables;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
1843                                                     };
1844                                                  
1845  ***      0                                  0      return @tables;
1846                                                  }
1847                                                  
1848                                                  sub distill {
1849  ***      0                    0             0      my ( $self, $query, %args ) = @_;
1850                                                  
1851  ***      0      0                           0      if ( $args{generic} ) {
1852  ***      0                                  0         my ($cmd, $arg) = $query =~ m/^(\S+)\s+(\S+)/;
1853  ***      0      0                           0         return '' unless $cmd;
1854  ***      0      0                           0         $query = (uc $cmd) . ($arg ? " $arg" : '');
1855                                                     }
1856                                                     else {
1857  ***      0                                  0         my ($verbs, $table)  = $self->distill_verbs($query, %args);
1858                                                  
1859  ***      0      0      0                    0         if ( $verbs && $verbs =~ m/^SHOW/ ) {
1860  ***      0                                  0            my %alias_for = qw(
1861                                                              SCHEMA   DATABASE
1862                                                              KEYS     INDEX
1863                                                              INDEXES  INDEX
1864                                                           );
1865  ***      0                                  0            map { $verbs =~ s/$_/$alias_for{$_}/ } keys %alias_for;
      ***      0                                  0   
1866  ***      0                                  0            $query = $verbs;
1867                                                        }
1868                                                        else {
1869  ***      0                                  0            my @tables = $self->__distill_tables($query, $table, %args);
1870  ***      0                                  0            $query     = join(q{ }, $verbs, @tables); 
1871                                                        } 
1872                                                     }
1873                                                  
1874  ***      0      0                           0      if ( $args{trf} ) {
1875  ***      0                                  0         $query = $args{trf}->($query, %args);
1876                                                     }
1877                                                  
1878  ***      0                                  0      return $query;
1879                                                  }
1880                                                  
1881                                                  sub convert_to_select {
1882  ***      0                    0             0      my ( $self, $query ) = @_;
1883  ***      0      0                           0      return unless $query;
1884  ***      0                                  0      $query =~ s{
      ***      0                                  0   
1885                                                                   \A.*?
1886                                                                   update\s+(.*?)
1887                                                                   \s+set\b(.*?)
1888                                                                   (?:\s*where\b(.*?))?
1889                                                                   (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
1890                                                                   \Z
1891                                                                }
1892                                                                {__update_to_select($1, $2, $3, $4)}exsi
1893  ***      0                                  0         || $query =~ s{
1894                                                                      \A.*?
1895                                                                      (?:insert|replace)\s+
1896                                                                      .*?\binto\b(.*?)\(([^\)]+)\)\s*
1897                                                                      values?\s*(\(.*?\))\s*
1898                                                                      (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
1899                                                                      \Z
1900                                                                   }
1901                                                                   {__insert_to_select($1, $2, $3)}exsi
1902  ***      0      0      0                    0         || $query =~ s{
1903                                                                      \A.*?
1904                                                                      delete\s+(.*?)
1905                                                                      \bfrom\b(.*)
1906                                                                      \Z
1907                                                                   }
1908                                                                   {__delete_to_select($1, $2)}exsi;
1909  ***      0                                  0      $query =~ s/\s*on\s+duplicate\s+key\s+update.*\Z//si;
1910  ***      0                                  0      $query =~ s/\A.*?(?=\bSELECT\s*\b)//ism;
1911  ***      0                                  0      return $query;
1912                                                  }
1913                                                  
1914                                                  sub convert_select_list {
1915  ***      0                    0             0      my ( $self, $query ) = @_;
1916  ***      0      0                           0      $query =~ s{
      ***      0                                  0   
1917                                                                 \A\s*select(.*?)\bfrom\b
1918                                                                }
1919                                                                {$1 =~ m/\*/ ? "select 1 from" : "select isnull(coalesce($1)) from"}exi;
1920  ***      0                                  0      return $query;
1921                                                  }
1922                                                  
1923                                                  sub __delete_to_select {
1924  ***      0                    0             0      my ( $delete, $join ) = @_;
1925  ***      0      0                           0      if ( $join =~ m/\bjoin\b/ ) {
1926  ***      0                                  0         return "select 1 from $join";
1927                                                     }
1928  ***      0                                  0      return "select * from $join";
1929                                                  }
1930                                                  
1931                                                  sub __insert_to_select {
1932  ***      0                    0             0      my ( $tbl, $cols, $vals ) = @_;
1933  ***      0                                  0      MKDEBUG && _d('Args:', @_);
1934  ***      0                                  0      my @cols = split(/,/, $cols);
1935  ***      0                                  0      MKDEBUG && _d('Cols:', @cols);
1936  ***      0                                  0      $vals =~ s/^\(|\)$//g; # Strip leading/trailing parens
1937  ***      0                                  0      my @vals = $vals =~ m/($quote_re|[^,]*${bal}[^,]*|[^,]+)/g;
1938  ***      0                                  0      MKDEBUG && _d('Vals:', @vals);
1939  ***      0      0                           0      if ( @cols == @vals ) {
1940  ***      0                                  0         return "select * from $tbl where "
1941  ***      0                                  0            . join(' and ', map { "$cols[$_]=$vals[$_]" } (0..$#cols));
1942                                                     }
1943                                                     else {
1944  ***      0                                  0         return "select * from $tbl limit 1";
1945                                                     }
1946                                                  }
1947                                                  
1948                                                  sub __update_to_select {
1949  ***      0                    0             0      my ( $from, $set, $where, $limit ) = @_;
1950  ***      0      0                           0      return "select $set from $from "
      ***             0                               
1951                                                        . ( $where ? "where $where" : '' )
1952                                                        . ( $limit ? " $limit "      : '' );
1953                                                  }
1954                                                  
1955                                                  sub wrap_in_derived {
1956  ***      0                    0             0      my ( $self, $query ) = @_;
1957  ***      0      0                           0      return unless $query;
1958  ***      0      0                           0      return $query =~ m/\A\s*select/i
1959                                                        ? "select 1 from ($query) as x limit 1"
1960                                                        : $query;
1961                                                  }
1962                                                  
1963                                                  sub _d {
1964  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1965  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1966  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1967                                                          @_;
1968  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1969                                                  }
1970                                                  
1971                                                  1;
1972                                                  
1973                                                  # ###########################################################################
1974                                                  # End QueryRewriter package
1975                                                  # ###########################################################################
1976                                                  
1977                                                  # ###########################################################################
1978                                                  # Transformers package 5715
1979                                                  # ###########################################################################
1980                                                  
1981                                                  package Transformers;
1982                                                  
1983           5                    5            53   use strict;
               5                               1030   
               5                                274   
1984           5                    5            30   use warnings FATAL => 'all';
               5                                 12   
               5                                 29   
1985           5                    5            30   use English qw(-no_match_vars);
               5                                 11   
               5                                 24   
1986           5                    5            59   use Time::Local qw(timegm timelocal);
               5                                 13   
               5                                 51   
1987           5                    5            33   use Digest::MD5 qw(md5_hex);
               5                                 12   
               5                                 35   
1988                                                  
1989  ***      5            50      5            30   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 13   
               5                                 68   
1990                                                  
1991                                                  require Exporter;
1992                                                  our @ISA         = qw(Exporter);
1993                                                  our %EXPORT_TAGS = ();
1994                                                  our @EXPORT      = ();
1995                                                  our @EXPORT_OK   = qw(
1996                                                     micro_t
1997                                                     percentage_of
1998                                                     secs_to_time
1999                                                     time_to_secs
2000                                                     shorten
2001                                                     ts
2002                                                     parse_timestamp
2003                                                     unix_timestamp
2004                                                     any_unix_timestamp
2005                                                     make_checksum
2006                                                  );
2007                                                  
2008                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
2009                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
2010                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
2011                                                  
2012                                                  sub micro_t {
2013  ***      0                    0             0      my ( $t, %args ) = @_;
2014  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
2015  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
2016  ***      0                                  0      my $f;
2017                                                  
2018  ***      0      0                           0      $t = 0 if $t < 0;
2019                                                  
2020  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
2021                                                  
2022  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
2023                                                  
2024  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
2025  ***      0                                  0         $f = ($t * 1000000) . 'us';
2026                                                     }
2027                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
2028  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
2029  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
2030                                                     }
2031                                                     elsif ($t >= 1) {
2032  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
2033  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
2034                                                     }
2035                                                     else {
2036  ***      0                                  0         $f = 0;  # $t should = 0 at this point
2037                                                     }
2038                                                  
2039  ***      0                                  0      return $f;
2040                                                  }
2041                                                  
2042                                                  sub percentage_of {
2043  ***      0                    0             0      my ( $is, $of, %args ) = @_;
2044  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
2045  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
2046  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
2047                                                  }
2048                                                  
2049                                                  sub secs_to_time {
2050  ***      0                    0             0      my ( $secs, $fmt ) = @_;
2051  ***      0             0                    0      $secs ||= 0;
2052  ***      0      0                           0      return '00:00' unless $secs;
2053                                                  
2054  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
2055                                                            : $secs >= 3_600  ? 'h'
2056                                                            :                   'm';
2057                                                  
2058                                                     return
2059  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
2060                                                           "%d+%02d:%02d:%02d",
2061                                                           int($secs / 86_400),
2062                                                           int(($secs % 86_400) / 3_600),
2063                                                           int(($secs % 3_600) / 60),
2064                                                           $secs % 60)
2065                                                        : $fmt eq 'h' ? sprintf(
2066                                                           "%02d:%02d:%02d",
2067                                                           int(($secs % 86_400) / 3_600),
2068                                                           int(($secs % 3_600) / 60),
2069                                                           $secs % 60)
2070                                                        : sprintf(
2071                                                           "%02d:%02d",
2072                                                           int(($secs % 3_600) / 60),
2073                                                           $secs % 60);
2074                                                  }
2075                                                  
2076                                                  sub time_to_secs {
2077  ***      0                    0             0      my ( $val, $default_suffix ) = @_;
2078  ***      0      0                           0      die "I need a val argument" unless defined $val;
2079  ***      0                                  0      my $t = 0;
2080  ***      0                                  0      my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
2081  ***      0             0                    0      $suffix = $suffix || $default_suffix || 's';
      ***                    0                        
2082  ***      0      0                           0      if ( $suffix =~ m/[smhd]/ ) {
2083  ***      0      0                           0         $t = $suffix eq 's' ? $num * 1        # Seconds
      ***             0                               
      ***             0                               
2084                                                           : $suffix eq 'm' ? $num * 60       # Minutes
2085                                                           : $suffix eq 'h' ? $num * 3600     # Hours
2086                                                           :                  $num * 86400;   # Days
2087                                                  
2088  ***      0      0      0                    0         $t *= -1 if $prefix && $prefix eq '-';
2089                                                     }
2090                                                     else {
2091  ***      0                                  0         die "Invalid suffix for $val: $suffix";
2092                                                     }
2093  ***      0                                  0      return $t;
2094                                                  }
2095                                                  
2096                                                  sub shorten {
2097  ***      0                    0             0      my ( $num, %args ) = @_;
2098  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
2099  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
2100  ***      0                                  0      my $n = 0;
2101  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
2102  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
2103  ***      0                                  0         $num /= $d;
2104  ***      0                                  0         ++$n;
2105                                                     }
2106  ***      0      0      0                    0      return sprintf(
2107                                                        $num =~ m/\./ || $n
2108                                                           ? "%.${p}f%s"
2109                                                           : '%d',
2110                                                        $num, $units[$n]);
2111                                                  }
2112                                                  
2113                                                  sub ts {
2114  ***      0                    0             0      my ( $time, $gmt ) = @_;
2115  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
2116                                                        = $gmt ? gmtime($time) : localtime($time);
2117  ***      0                                  0      $mon  += 1;
2118  ***      0                                  0      $year += 1900;
2119  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
2120                                                        $year, $mon, $mday, $hour, $min, $sec);
2121  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
2122  ***      0                                  0         $us = sprintf("%.6f", $us);
2123  ***      0                                  0         $us =~ s/^0\././;
2124  ***      0                                  0         $val .= $us;
2125                                                     }
2126  ***      0                                  0      return $val;
2127                                                  }
2128                                                  
2129                                                  sub parse_timestamp {
2130  ***      0                    0             0      my ( $val ) = @_;
2131  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
2132                                                           = $val =~ m/^$mysql_ts$/ )
2133                                                     {
2134  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
2135                                                                       . (defined $f ? '%02.6f' : '%02d'),
2136                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
2137                                                     }
2138  ***      0                                  0      return $val;
2139                                                  }
2140                                                  
2141                                                  sub unix_timestamp {
2142  ***      0                    0             0      my ( $val, $gmt ) = @_;
2143  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
2144  ***      0      0                           0         $val = $gmt
2145                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
2146                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
2147  ***      0      0                           0         if ( defined $us ) {
2148  ***      0                                  0            $us = sprintf('%.6f', $us);
2149  ***      0                                  0            $us =~ s/^0\././;
2150  ***      0                                  0            $val .= $us;
2151                                                        }
2152                                                     }
2153  ***      0                                  0      return $val;
2154                                                  }
2155                                                  
2156                                                  sub any_unix_timestamp {
2157  ***      0                    0             0      my ( $val, $callback ) = @_;
2158                                                  
2159  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
2160  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
2161                                                           : $suffix eq 'm' ? $n * 60       # Minutes
2162                                                           : $suffix eq 'h' ? $n * 3600     # Hours
2163                                                           : $suffix eq 'd' ? $n * 86400    # Days
2164                                                           :                  $n;           # default: Seconds
2165  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
2166  ***      0                                  0         return time - $n;
2167                                                     }
2168                                                     elsif ( $val =~ m/^\d{9,}/ ) {
2169  ***      0                                  0         MKDEBUG && _d('ts is already a unix timestamp');
2170  ***      0                                  0         return $val;
2171                                                     }
2172                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
2173  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
2174  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2175  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
2176                                                     }
2177                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
2178  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
2179  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2180  ***      0                                  0         return unix_timestamp($val);
2181                                                     }
2182                                                     else {
2183  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
2184  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
2185                                                     }
2186                                                  
2187  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
2188  ***      0                                  0      return;
2189                                                  }
2190                                                  
2191                                                  sub make_checksum {
2192           9                    9            40      my ( $val ) = @_;
2193           9                                114      my $checksum = uc substr(md5_hex($val), -16);
2194           9                                 22      MKDEBUG && _d($checksum, 'checksum for', $val);
2195           9                                 34      return $checksum;
2196                                                  }
2197                                                  
2198                                                  sub _d {
2199  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2200  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2201  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2202                                                          @_;
2203  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2204                                                  }
2205                                                  
2206                                                  1;
2207                                                  
2208                                                  # ###########################################################################
2209                                                  # End Transformers package
2210                                                  # ###########################################################################
2211                                                  
2212                                                  # ###########################################################################
2213                                                  # Daemon package 5266
2214                                                  # ###########################################################################
2215                                                  
2216                                                  package Daemon;
2217                                                  
2218           5                    5            37   use strict;
               5                                 13   
               5                                 35   
2219           5                    5            30   use warnings FATAL => 'all';
               5                                 19   
               5                                 30   
2220                                                  
2221           5                    5            30   use POSIX qw(setsid);
               5                                 13   
               5                                 31   
2222           5                    5            29   use English qw(-no_match_vars);
               5                                 10   
               5                                 29   
2223                                                  
2224  ***      5            50      5            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 13   
               5                                 72   
2225                                                  
2226                                                  sub new {
2227  ***      0                    0             0      my ( $class, %args ) = @_;
2228  ***      0                                  0      foreach my $arg ( qw(o) ) {
2229  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2230                                                     }
2231  ***      0                                  0      my $o = $args{o};
2232  ***      0      0                           0      my $self = {
      ***             0                               
2233                                                        o        => $o,
2234                                                        log_file => $o->has('log') ? $o->get('log') : undef,
2235                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
2236                                                     };
2237                                                  
2238  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
2239                                                  
2240  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
2241  ***      0                                  0      return bless $self, $class;
2242                                                  }
2243                                                  
2244                                                  sub daemonize {
2245  ***      0                    0             0      my ( $self ) = @_;
2246                                                  
2247  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
2248  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
2249  ***      0      0                           0      if ( $pid ) {
2250  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
2251  ***      0                                  0         exit;
2252                                                     }
2253                                                  
2254  ***      0                                  0      $self->{child} = 1;
2255                                                  
2256  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2257  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
2258                                                  
2259  ***      0                                  0      $self->_make_PID_file();
2260                                                  
2261  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
2262                                                  
2263  ***      0      0                           0      if ( -t STDIN ) {
2264  ***      0                                  0         close STDIN;
2265  ***      0      0                           0         open  STDIN, '/dev/null'
2266                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
2267                                                     }
2268                                                  
2269  ***      0      0                           0      if ( $self->{log_file} ) {
2270  ***      0                                  0         close STDOUT;
2271  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
2272                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
2273                                                  
2274  ***      0                                  0         close STDERR;
2275  ***      0      0                           0         open  STDERR, ">&STDOUT"
2276                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
2277                                                     }
2278                                                     else {
2279  ***      0      0                           0         if ( -t STDOUT ) {
2280  ***      0                                  0            close STDOUT;
2281  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
2282                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
2283                                                        }
2284  ***      0      0                           0         if ( -t STDERR ) {
2285  ***      0                                  0            close STDERR;
2286  ***      0      0                           0            open  STDERR, '>', '/dev/null'
2287                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
2288                                                        }
2289                                                     }
2290                                                  
2291  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
2292  ***      0                                  0      return;
2293                                                  }
2294                                                  
2295                                                  sub check_PID_file {
2296  ***      0                    0             0      my ( $self, $file ) = @_;
2297  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
2298  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
2299  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
2300  ***      0                                  0         my $pid;
2301  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
2302  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
2303  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
2304  ***      0      0                           0         if ( $pid ) {
2305  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
2306  ***      0      0                           0            if ( $pid_is_alive ) {
2307  ***      0                                  0               die "The PID file $PID_file already exists "
2308                                                                 . " and the PID that it contains, $pid, is running";
2309                                                           }
2310                                                           else {
2311  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
2312                                                                 . "contains, $pid, is not running";
2313                                                           }
2314                                                        }
2315                                                        else {
2316  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
2317                                                              . "contain a PID";
2318                                                        }
2319                                                     }
2320                                                     else {
2321  ***      0                                  0         MKDEBUG && _d('No PID file');
2322                                                     }
2323  ***      0                                  0      return;
2324                                                  }
2325                                                  
2326                                                  sub make_PID_file {
2327  ***      0                    0             0      my ( $self ) = @_;
2328  ***      0      0                           0      if ( exists $self->{child} ) {
2329  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
2330                                                     }
2331  ***      0                                  0      $self->_make_PID_file();
2332  ***      0                                  0      $self->{rm_PID_file} = 1;
2333  ***      0                                  0      return;
2334                                                  }
2335                                                  
2336                                                  sub _make_PID_file {
2337  ***      0                    0             0      my ( $self ) = @_;
2338                                                  
2339  ***      0                                  0      my $PID_file = $self->{PID_file};
2340  ***      0      0                           0      if ( !$PID_file ) {
2341  ***      0                                  0         MKDEBUG && _d('No PID file to create');
2342  ***      0                                  0         return;
2343                                                     }
2344                                                  
2345  ***      0                                  0      $self->check_PID_file();
2346                                                  
2347  ***      0      0                           0      open my $PID_FH, '>', $PID_file
2348                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
2349  ***      0      0                           0      print $PID_FH $PID
2350                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
2351  ***      0      0                           0      close $PID_FH
2352                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
2353                                                  
2354  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
2355  ***      0                                  0      return;
2356                                                  }
2357                                                  
2358                                                  sub _remove_PID_file {
2359  ***      0                    0             0      my ( $self ) = @_;
2360  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
2361  ***      0      0                           0         unlink $self->{PID_file}
2362                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
2363  ***      0                                  0         MKDEBUG && _d('Removed PID file');
2364                                                     }
2365                                                     else {
2366  ***      0                                  0         MKDEBUG && _d('No PID to remove');
2367                                                     }
2368  ***      0                                  0      return;
2369                                                  }
2370                                                  
2371                                                  sub DESTROY {
2372  ***      0                    0             0      my ( $self ) = @_;
2373  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
2374  ***      0                                  0      return;
2375                                                  }
2376                                                  
2377                                                  sub _d {
2378  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2379  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2380  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2381                                                          @_;
2382  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2383                                                  }
2384                                                  
2385                                                  1;
2386                                                  
2387                                                  # ###########################################################################
2388                                                  # End Daemon package
2389                                                  # ###########################################################################
2390                                                  
2391                                                  # ###########################################################################
2392                                                  # This is a combination of modules and programs in one -- a runnable module.
2393                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2394                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2395                                                  #
2396                                                  # Check at the end of this package for the call to main() which actually runs
2397                                                  # the program.
2398                                                  # ###########################################################################
2399                                                  package mk_query_advisor;
2400                                                  
2401           5                    5            51   use strict;
               5                                 14   
               5                                 29   
2402           5                    5            31   use warnings FATAL => 'all';
               5                                 10   
               5                                 26   
2403           5                    5            41   use English qw(-no_match_vars);
               5                                 16   
               5                                 21   
2404           5                    5            36   use Data::Dumper;
               5                                 11   
               5                                 32   
2405                                                  $Data::Dumper::Indent    = 1;
2406                                                  $Data::Dumper::Sortkeys  = 1;
2407                                                  $Data::Dumper::Quotekeys = 0;
2408                                                  
2409                                                  Transformers->import(qw(make_checksum));
2410                                                  
2411  ***      5            50      5            33   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 14   
               5                                 66   
2412                                                  
2413           5                    5            52   use sigtrap 'handler', \&sig_int, 'normal-signals';
               5                                 18   
               5                                 71   
2414                                                  
2415                                                  my $oktorun = 1;  # global for sig handler
2416                                                  my %seen_id;      # already printed check ID descriptions
2417                                                  
2418                                                  sub main {
2419           9                    9          1764      @ARGV = @_;  # set global ARGV for this package
2420                                                  
2421                                                     # ########################################################################
2422                                                     # Get configuration information.
2423                                                     # ########################################################################
2424           9                                238      my $o  = new OptionParser(
2425                                                        strict      => 0,
2426                                                        prompt      => '[OPTION...] FILE',
2427                                                        description => q{examines MySQL queries for inefficiencies.},
2428                                                     );
2429           9                                 82      $o->get_specs();
2430           9                                 72      $o->get_opts();
2431                                                  
2432           9                                 68      $o->usage_or_errors();
2433                                                  
2434                                                     # #########################################################################
2435                                                     # Parse checks from POD.
2436                                                     # #########################################################################
2437           9                                 36      my $ignore_checks = $o->get('ignore-checks');
2438                                                     my @checks        = $o->parse_section(
2439                                                        file        => __FILE__,
2440                                                        section     => 'CHECKS',
2441                                                        trf         => sub {
2442          81                   81           337            return filter_checks( parse_check(@_), $ignore_checks );
2443                                                        },
2444           9                                138      );
2445                                                  
2446                                                     # #########################################################################
2447                                                     # Make common modules.
2448                                                     # #########################################################################
2449           9                                332      my $qp = new QueryParser();
2450           9                                100      my $qr = new QueryRewriter( QueryParser => $qp );
2451           9                                 52      my %common_modules = (
2452                                                        OptionParser  => $o,
2453                                                        QueryParser   => $qp,
2454                                                        QueryRewriter => $qr,
2455                                                     );
2456                                                  
2457                                                     # #########################################################################
2458                                                     # Make pipeline.
2459                                                     # #########################################################################
2460           9                                 24      my @pipeline;
2461                                                  
2462  ***      9     50                          41      if ( my $query = $o->get('query') ) {
2463                                                        push @pipeline, sub {
2464           9                    9           108            my ( %args ) = @_;
2465           9                                 42            MKDEBUG && _d('callback: query:', $query);
2466  ***      9     50                          55            $args{oktorun}->(0) if $args{oktorun};
2467                                                           return {
2468           9                                 71               cmd        => 'Query',
2469                                                              arg        => $query,
2470                                                              pos_in_log => 0,  # for compatibility
2471                                                           };
2472           9                                 95         };
2473                                                     }
2474                                                     else {
2475                                                        # This is straight from mk-query-digest but only slowlog and genlog
2476                                                        # are used in mk-query-advisor.
2477  ***      0                                  0         my %alias_for = (
2478                                                           slowlog   => ['SlowLogParser'],
2479                                                           binlog    => ['BinaryLogParser'],
2480                                                           genlog    => ['GeneralLogParser'],
2481                                                           tcpdump   => ['TcpdumpParser','MySQLProtocolParser'],
2482                                                           memcached => ['TcpdumpParser','MemcachedProtocolParser',
2483                                                                         'MemcachedEvent'],
2484                                                           http      => ['TcpdumpParser','HTTPProtocolParser'],
2485                                                        );
2486  ***      0                                  0         my $type = $o->get('type');
2487  ***      0      0                           0         $type    = $alias_for{$type->[0]} if $alias_for{$type->[0]};
2488                                                  
2489  ***      0                                  0         foreach my $module ( @$type ) {
2490  ***      0                                  0            my $parser;
2491  ***      0                                  0            eval {
2492  ***      0                                  0               $parser = $module->new(
2493                                                                 # server => $o->get('watch-server'),
2494                                                                 o      => $o,
2495                                                              );
2496                                                           };
2497  ***      0      0                           0            if ( $EVAL_ERROR ) {
2498  ***      0                                  0               die "Failed to load $module module: $EVAL_ERROR";
2499                                                           }
2500                                                           push @pipeline, sub {
2501  ***      0                    0             0               my ( %args ) = @_;
2502  ***      0                                  0               return $parser->parse_event(%args);
2503  ***      0                                  0            };
2504  ***      0                                  0            MKDEBUG && _d('Added', $module, 'module to callbacks');
2505                                                        }
2506                                                     }
2507                                                  
2508                                                     push @pipeline, sub {
2509           9                    9            63         my ( %args ) = @_;
2510           9                                 30         MKDEBUG && _d('callback: check cmd and arg');
2511           9                                 29         my $event = $args{event};
2512  ***      9     50     50                   53         if ( ($event->{cmd} || '') ne 'Query' ) {
2513  ***      0                                  0            MKDEBUG && _d('Skipping non-Query cmd');
2514  ***      0                                  0            return;
2515                                                        }
2516  ***      9     50                          38         if ( !$event->{arg} ) {
2517  ***      0                                  0            MKDEBUG && _d('Skipping empty arg');
2518  ***      0                                  0            return;
2519                                                        }
2520           9                                 38         return $event;
2521           9                                 77      };
2522                                                  
2523  ***      9     50                          38      if ( $o->get('fingerprint') ) {
2524  ***      0                                  0         my %seen_fingerprint;
2525                                                        push @pipeline, sub {
2526  ***      0                    0             0            my ( %args ) = @_;
2527  ***      0                                  0            MKDEBUG && _d('callback: fingerprint');
2528  ***      0                                  0            my $event = $args{event};
2529  ***      0                                  0            $event->{fingerprint} = $qr->fingerprint($event->{arg});
2530  ***      0      0                           0            if ( $seen_fingerprint{ $event->{fingerprint} }++ ) {
2531  ***      0                                  0               MKDEBUG && _d('Skipping already seen fingerprint');
2532  ***      0                                  0               return;
2533                                                           }
2534  ***      0                                  0            return $event;
2535  ***      0                                  0         };
2536                                                     }
2537                                                  
2538                                                     # Parser the query.  The query struct is a hashref with keys
2539                                                     # to various parts of the query.  These keys are the subjects
2540                                                     # of checks.
2541                                                     push @pipeline, sub {
2542           9                    9            56         my ( %args ) = @_;
2543           9                                 29         MKDEBUG && _d('callback: parse query');
2544           9                                 32         my $event        = $args{event};
2545           9                                 80         my $query_struct = $qp->parse($event->{arg});
2546  ***      9     50                          38         return unless $query_struct;
2547           9                                 28         $event->{query_struct} = $query_struct;
2548           9                                 46         return $event;
2549           9                                 80      };
2550                                                  
2551                                                     # Check the query and get a list of checks that failed (flags).
2552                                                     push @pipeline, sub {
2553           9                    9            74         my ( %args ) = @_;
2554           9                                 29         MKDEBUG && _d('callback: check query');
2555           9                                 31         my $event = $args{event};
2556           9                                 64         my $flags = check_query(
2557                                                           checks       => \@checks,
2558                                                           query_struct => $event->{query_struct},
2559                                                        );
2560           9                                 51         $event->{flags} = $flags;
2561           9                                 44         return $event;
2562           9                                 71      };
2563                                                  
2564                                                     push @pipeline, sub {
2565           9                    9            73         my ( %args ) = @_;
2566           9                                 29         MKDEBUG && _d('callback: print flags');
2567           9                                 31         my $event = $args{event};
2568           9                                 55         print_flags(
2569                                                           %args,
2570                                                           verbose       => $o->get('verbose'),
2571                                                           print_all     => $o->get('print-all'),
2572                                                           report_format => $o->get('report-format'),
2573                                                        );
2574           9                                 45         return $event;
2575           9                                 62      };
2576                                                  
2577                                                     # ##########################################################################
2578                                                     # Get ready to do the main work.
2579                                                     # ##########################################################################
2580           9                                 25      my $fh;
2581  ***      9     50                          41      if ( @ARGV == 0 ) {
2582           9                                 33         push @ARGV, '-'; # Magical STDIN filename.
2583                                                     }
2584                                                  
2585                                                     # ########################################################################
2586                                                     # Daemonize now that everything is setup and ready to work.
2587                                                     # ########################################################################
2588           9                                 21      my $daemon;
2589  ***      9     50                          30      if ( $o->get('daemonize') ) {
      ***            50                               
2590  ***      0                                  0         $daemon = new Daemon(o=>$o);
2591  ***      0                                  0         $daemon->daemonize();
2592  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
2593                                                     }
2594                                                     elsif ( $o->get('pid') ) {
2595                                                        # We're not daemoninzing, it just handles PID stuff.
2596  ***      0                                  0         $daemon = new Daemon(o=>$o);
2597  ***      0                                  0         $daemon->make_PID_file();
2598                                                     }
2599                                                  
2600                                                     # #########################################################################
2601                                                     # Do it!
2602                                                     # #########################################################################
2603                                                     EVENT:
2604           9                                 43      while ( $oktorun ) {
2605  ***     18     50                          74         if ( !$fh ) {
2606          18                                 57            my $file = shift @ARGV;
2607          18    100                          68            if ( !$file ) {
2608           9                                 19               MKDEBUG && _d('No more files to parse');
2609           9                                 25               last EVENT;
2610                                                           }
2611  ***      9     50                          36            if ( $file eq '-' ) {
2612           9                                 57               $fh = *STDIN;
2613           9                                 27               MKDEBUG && _d('Reading STDIN');
2614                                                           }
2615                                                           else {
2616  ***      0      0                           0               if ( !open $fh, "<", $file ) {
2617  ***      0                                  0                  $fh = undef;
2618  ***      0                                  0                  warn "Cannot open $file: $OS_ERROR\n";
2619  ***      0                                  0                  next EVENT;
2620                                                              }
2621  ***      0                                  0               MKDEBUG && _d('Reading', $file);
2622                                                           }
2623                                                        }
2624                                                  
2625           9                                 28         my $event       = {};
2626  ***      9                    0            63         my $next_event  = sub { return <$fh>; };
      ***      0                                  0   
2627  ***      9                    0            57         my $tell        = sub { return tell $fh; };
      ***      0                                  0   
2628           9                                 27         my $more_events = 1;
2629           9                    9            53         my $oktorun_sub = sub { $more_events = $_[0]; };
               9                                 28   
2630           9                                 29         eval {
2631           9                                 42            foreach my $proc ( @pipeline ) {
2632  ***     45     50                         150               last unless $oktorun;  # the global oktorun var
2633          45                                229               $event = $proc->(
2634                                                                 event      => $event,
2635                                                                 fh         => $fh,
2636                                                                 next_event => $next_event,
2637                                                                 tell       => $tell,
2638                                                                 oktorun    => $oktorun_sub,
2639                                                              );
2640  ***     45     50                         202               last unless $event;
2641                                                           }
2642                                                        };
2643  ***      9     50                          33         if ( $EVAL_ERROR ) {
2644  ***      0                                  0            _d($EVAL_ERROR);
2645  ***      0      0                           0            last EVENT unless $o->get('continue-on-error');
2646                                                        }
2647  ***      9     50                          40         if ( !$more_events ) {
2648           9                                 21            MKDEBUG && _d('No more events');
2649  ***      9     50     33                   99            close $fh if $fh and $fh ne *STDIN;
2650           9                                116            $fh = undef;
2651                                                        }
2652                                                     }  # EVENT
2653                                                  
2654           9                                921      return 0;
2655                                                  }
2656                                                  
2657                                                  # ##########################################################################
2658                                                  # Subroutines
2659                                                  # ##########################################################################
2660                                                  
2661                                                  # Callback (trf) to parse_section().  Translates a check paragraph
2662                                                  # from the POD into a hashref of its key: values (e.g. id: LIT.001
2663                                                  # becomes id => 'LIT.001').  See CHECK SYNTAX for how these paragraphs
2664                                                  # are formatted.
2665                                                  sub parse_check {
2666          83                   83           342      my ( $para ) = @_;
2667          83    100                         482      return unless $para =~ m/^id:/;
2668          74                                218      my $check = {};
2669          74                                512      my @lines = split("\n", $para);
2670                                                  
2671                                                     # First 2 lines should be id and level.
2672          74                                303      for ( 1..2 ) {
2673         148                                414         my $line = shift @lines;
2674         148                                325         MKDEBUG && _d($line);
2675         148                                632         $line =~ m/(\w+):\s*(.+)/;
2676         148                                840         $check->{$1} = $2;
2677                                                     }
2678                                                  
2679                                                     # First line of rules;
2680          74                                221      my $rule = shift @lines;
2681          74                                293      $rule =~ s/^rules:\s+//;
2682          74                                171      my @rules;
2683          74                                234      push @rules, $rule;
2684                                                  
2685                                                     # Second and subsequent rules
2686          74                                203      my $line = shift @lines;
2687          74                                362      while ( $line !~ /^desc/ ) {
2688          18                                 55         push @rules, $line;
2689          18                                 97         $line = shift @lines;
2690                                                     }
2691                                                  
2692                                                     # Skip this check and return unless its rule is valid.      
2693          74                                264      my $rules = parse_check_rules(@rules);
2694  ***     74     50                         265      return unless $rules;
2695          74                                242      $check->{rules} = $rules;
2696                                                  
2697                                                     # First line of desc.
2698          74                                161      MKDEBUG && _d($line);
2699          74                                385      $line =~ m/(\w+):\s*(.+)/;
2700          74                                251      my $desc = $1;
2701          74                                323      $check->{$1} = $2;
2702                                                     # Rest of desc.
2703          74                                345      while ( my $d = shift @lines ) {
2704          63                                383         $check->{$desc} .= $d;
2705                                                     }
2706          74                                629      $check->{$desc} =~ s/\s+/ /g;
2707                                                  
2708          74                                160      MKDEBUG && _d('Parsed check:', Dumper($check));
2709          74                                358      return $check;
2710                                                  }
2711                                                  
2712                                                  # Parse, verify and translate check rules.  Returns an arrayref of
2713                                                  # the compiled check rules that check_query() can use.
2714                                                  sub parse_check_rules {
2715          85                   85           373      my ( @rules ) = @_;
2716          85                                219      my @compiled;
2717          85                                287      foreach my $rule ( @rules ) {
2718         108                                239         MKDEBUG && _d('Rule:', $rule);
2719         108                                919         my ($obj, $m, $pat)
2720                                                           = $rule =~ m/^\s*(\S+)\s+((?:does not )?(?:match|matches))\s+(.+)/;
2721         108                                287         MKDEBUG && _d('Rule parsed:', $obj, $m, $pat);
2722  ***    108     50     33                 1242         if ( !$obj || !$m || !$pat ) {
      ***                   33                        
2723  ***      0                                  0            warn "Invalid rule: $rule";
2724  ***      0                                  0            next;
2725                                                        }
2726         108    100                        2065         push @compiled, {
2727                                                           obj            => lc $obj,
2728                                                           positive_match => $m =~ m/not/ ? 0 : 1,
2729                                                           pattern        => qr/$pat/i,
2730                                                        };
2731                                                     }
2732          85                                395      return \@compiled;
2733                                                  }
2734                                                  
2735                                                  sub filter_checks {
2736          86                   86           300      my ( $check, $ignore_checks ) = @_;
2737          86    100                         451      return $check unless $ignore_checks;
2738           4    100                          25      return if $ignore_checks->{ $check->{id} };
2739           3    100                          16      return if $ignore_checks->{ $check->{level} };
2740           2                                 10      return $check;
2741                                                  }
2742                                                  
2743                                                  # Run each check against the query.  Each check has 1 or more rules,
2744                                                  # all of which must match the query to flag the check.  An arrayref
2745                                                  # of flagged checks are returned.  The rules' objects are parts of
2746                                                  # query: "query" for the query itself, "column" for its column values,
2747                                                  # "table" for its tables.  Each obj is an arrayref of those things
2748                                                  # because rules match any one of an object (i.e. any table, column,
2749                                                  # etc.). Even though there's only 1 query obj, it's an arrayref too
2750                                                  # to keep the code simple.
2751                                                  sub check_query {
2752          19                   19           102      my ( %args ) = @_;
2753          19                                104      my $checks        = $args{checks};
2754          19                                 57      my $query_struct  = $args{query_struct};
2755          19                                 48      my @flags;
2756                                                  
2757          19                                 83      foreach my $check ( @$checks ) {
2758          82                                259         my $rules   = $check->{rules};
2759          82                                197         my $matches = 0;
2760                                                  
2761                                                        RULE:
2762          82                                257         foreach my $rule ( @$rules ) {
2763          95                                292            my $pat  = $rule->{pattern};
2764          95                                359            my $objs = $query_struct->{ $rule->{obj} };
2765                                                  
2766                                                           OBJ:
2767          95                                285            foreach my $obj ( @$objs ) {
2768          91    100                         750               $matches = $rule->{positive_match} ? ($obj =~ m/$pat/ ? 1 : 0)
                    100                               
                    100                               
2769                                                                       :                           ($obj !~ m/$pat/ ? 1 : 0);
2770                                                  
2771                                                              # Only one object needs to match so we can stop once one does.
2772          91    100                         380               last OBJ if $matches;
2773                                                           }
2774                                                  
2775                                                           # All rules must match so we can stop early if one does not.
2776          95    100                         395            last RULE unless $matches;
2777                                                        }
2778                                                  
2779          82    100                         316         if ( $matches ) {
2780          16                                 33            MKDEBUG && _d('Flag', $check->{id});
2781          16                                 63            push @flags, $check;
2782                                                        }
2783                                                     }
2784                                                  
2785          19                                 97      return \@flags;
2786                                                  }
2787                                                  
2788                                                  sub print_flags {
2789           9                    9           131      my ( %args ) = @_;
2790           9                                 59      my $event   = $args{event};
2791  ***      9            50                   40      my $verbose = $args{verbose} || 0;
2792           9                                 27      my $format  = $args{report_format};
2793                                                  
2794           9                                 30      my $flags   = $event->{flags};
2795           9                                 24      my $n_flags = scalar @$flags;
2796           9                                 24      my @seen_ids;
2797                                                  
2798  ***      9     50     33                   45      return unless $n_flags || $args{print_all};
2799                                                  
2800                                                     # Header
2801  ***      9            33                  143      my $id = make_checksum($event->{fingerprint} || $event->{arg});
2802  ***      9            50                  171      print "\n# Query ID 0x$id at byte " . ($event->{pos_in_log} || 0) . "\n";
2803                                                  
2804                                                     # New check IDs and their descriptions
2805           9                                 54      foreach my $i ( 1..$n_flags ) {
2806          11                                 50         my $c = $flags->[$i - 1];
2807  ***     11     50     33                   58         if ( $format eq 'compact' && $seen_id{ $c->{id} }++ ) {
2808  ***      0                                  0            push @seen_ids, $c->{id};
2809                                                        }
2810                                                        else {
2811                                                           # Haven't seen the description for this check ID yet so print it.
2812          25    100                         118            my @desc = map {
2813          11                                107                  $_ .= '.' unless m/\.$/;
2814          25                                109                  $_;
2815                                                              } split(/\.\s{1,2}/, $c->{desc});
2816  ***     11      0                          67            my $desc = $verbose == 1 ? $desc[0]             # terse
      ***             0                               
      ***            50                               
2817                                                                    : $verbose == 2 ? "$desc[0] $desc[1]"  # fuller
2818                                                                    : $verbose >  2 ? $c->{desc}           # complete
2819                                                                    :                 '';                  # none
2820          11                                 94            print "# $c->{level} $c->{id} $desc\n";
2821                                                        }
2822                                                     }
2823                                                  
2824                                                     # Already seen check IDs
2825  ***      9     50                          40      print "# Also: @seen_ids\n" if scalar @seen_ids;
2826                                                  
2827                                                     # The query
2828           9                                 36      print "$event->{arg}\n";
2829                                                  
2830           9                                 45      return;
2831                                                  }
2832                                                  
2833                                                  # Catches signals so we can exit gracefully.
2834                                                  sub sig_int {
2835  ***      0                    0                    my ( $signal ) = @_;
2836  ***      0      0                                  if ( $oktorun ) {
2837  ***      0                                            print STDERR "# Caught SIG$signal.\n";
2838  ***      0                                            $oktorun = 0;
2839                                                     }
2840                                                     else {
2841  ***      0                                            print STDERR "# Exiting on SIG$signal.\n";
2842  ***      0                                            exit 1;
2843                                                     }
2844                                                  }
2845                                                  
2846                                                  sub _d {
2847  ***      0                    0                    my ($package, undef, $line) = caller 0;
2848  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2849  ***      0                                              map { defined $_ ? $_ : 'undef' }
2850                                                          @_;
2851  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2852                                                  }
2853                                                  
2854                                                  # ############################################################################
2855                                                  # Run the program.
2856                                                  # ############################################################################
2857                                                  if ( !caller ) { exit main(@ARGV); }
2858                                                  
2859                                                  1; # Because this is a module as well as a script.
2860                                                  
2861                                                  # ############################################################################
2862                                                  # Documentation
2863                                                  # ############################################################################
2864                                                  
2865                                                  =pod
2866                                                  
2867                                                  =head1 NAME
2868                                                  
2869                                                  mk-query-advisor - Analyze queries and find inefficiencies.
2870                                                  
2871                                                  =head1 SYNOPSIS
2872                                                  
2873                                                     mk-query-advisor
2874                                                  
2875                                                  =head1 RISKS
2876                                                  
2877                                                  The following section is included to inform users about the potential risks,
2878                                                  whether known or unknown, of using this tool.  The two main categories of risks
2879                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2880                                                  tools) and those created by bugs.
2881                                                  
2882                                                  mk-query-advisor merely reads schema information and should be very low-risk.
2883                                                  
2884                                                  At the time of this release, we know of no bugs that could cause serious harm to
2885                                                  users.
2886                                                  
2887                                                  The authoritative source for updated information is always the online issue
2888                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2889                                                  see a list of such issues at the following URL:
2890                                                  L<http://www.maatkit.org/bugs/mk-query-advisor>.
2891                                                  
2892                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2893                                                  
2894                                                  =head1 DESCRIPTION
2895                                                  
2896                                                  mk-query-advisor advises about queries.
2897                                                  
2898                                                  =head1 CHECKS
2899                                                  
2900                                                  These are the check that mk-advisor can perform on a query.  There are several
2901                                                  classes of checks, each described in its own seciton.  You can add new checks
2902                                                  by adding new entires like the ones below.  Read L<"CHECK SYNTAX"> to learn
2903                                                  the structure of these checks.
2904                                                  
2905                                                  =head2 Literals
2906                                                  
2907                                                  id:    LIT.001
2908                                                  level: note
2909                                                  rules: query matches ['"]\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
2910                                                  desc:  IP address used as string.  The string literal looks like an IP address
2911                                                         but is not used inside INET_ATON().  WHERE ip='127.0.0.1' is better as
2912                                                         ip=INET_ATON('127.0.0.1') if the column is numeric.
2913                                                  
2914                                                  id:    LIT.002
2915                                                  level: warn
2916                                                  rules: query matches [^'"](?:\d{2,4}-\d{1,2}-\d{1,2}|\d{4,6})
2917                                                  desc:  Date literal is not quoted.  WHERE col<2010-02-12 is valid but wrong;
2918                                                         the date should be quoted.
2919                                                  
2920                                                  =head2 Table List
2921                                                  
2922                                                  id:    TBL.001
2923                                                  level: note
2924                                                  rules: columns match \*
2925                                                  desc:  All columns.  Selecting specific columns is preferable to SELECT *.
2926                                                  
2927                                                  id:    TBL.002
2928                                                  level: note
2929                                                  rules: columns match [\w`-]+\.\*\s+(?:AS\s+)?[[\w`-]+
2930                                                  desc:  Alaised all columns.  Aliasing an all columns reference like "tbl.* foo"
2931                                                         is confusing.
2932                                                  
2933                                                  =head2 Query
2934                                                  
2935                                                  id:    QRY.001
2936                                                  level: note
2937                                                  rules: query matches ^INSERT|REPLACE
2938                                                         query does not match INTO\s+\S+\s+\([^\)]\)
2939                                                  desc:  Blind INSERT/REPLACE.  The INSERT/REPLACE does not specify columns. 
2940                                                         "INSERT INTO tbl (col1,col2) VALUES" is preferred to "INSERT INTO tbl
2941                                                         VALUES".
2942                                                  
2943                                                  id:    QRY.002
2944                                                  level: note
2945                                                  rules: query matches SQL_CALC_FOUND_ROWS
2946                                                  desc:  SQL_CALC_FOUND_ROWS does not scale.  SQL_CALC_FOUND_ROWS can cause
2947                                                         performance problems because it does not scale well.
2948                                                  
2949                                                  id:    QRY.003
2950                                                  level: note
2951                                                  rules: query matches ^SELECT
2952                                                         query does not match \bWHERE\b
2953                                                  desc:  SELECT without WHERE.  The SELECT statement has no WHERE clause.
2954                                                  
2955                                                  id:    QRY.004;
2956                                                  level: note
2957                                                  rules: query matches ORDER BY RAND
2958                                                  desc:  ORDER BY RAND().  ORDER BY RAND() is not preferred.
2959                                                  
2960                                                  =head1 CHECK SYNTAX
2961                                                  
2962                                                  Each check is a single paragraph (blank line before and after) with the
2963                                                  following attributes:
2964                                                  
2965                                                    * id     A unique ID used by the tool to identify the check
2966                                                    * level  note, warn, or crit
2967                                                    * rules  A special syntax telling the tool how to perform the check
2968                                                    * desc   A terse, fuller and complete description of the check.
2969                                                  
2970                                                  The check is two parts: CCC.NNN where CCC is the class abbreviation and NNN
2971                                                  is the next avaiable number.  The classes are shown above, LIT for Literals,
2972                                                  TBL for Table List, etc.  The numbers should never overlap or change.
2973                                                  
2974                                                  The level is either note, warn or crit (for "critical").
2975                                                  
2976                                                  Each rule, one per line, is a simple sentence of the form:
2977                                                  
2978                                                    OBJECT matches|does not match PATTERN
2979                                                  
2980                                                  PATTERN is any Perl regular expression.  OBJECT is one of:
2981                                                  
2982                                                    OBJECT     REFERS TO
2983                                                    ========   =======================================================
2984                                                    query      The entire SQL text of the query
2985                                                    tables     Any table and its optional alias (e.g. pine AS tree)
2986                                                    columns    Columns from SELECT and, optionally, INSERT and REPLACE
2987                                                  
2988                                                  The description (desc) should have at least two period-terminate sentences.
2989                                                  The first sentece should be the terse definition of the check.  The second
2990                                                  sentence should be the fuller defintion.  Any more sentences are the complete
2991                                                  defintion of the check.
2992                                                  
2993                                                  =head1 OPTIONS
2994                                                  
2995                                                  =over
2996                                                  
2997                                                  =item --ask-pass
2998                                                  
2999                                                  Prompt for a password when connecting to MySQL.
3000                                                  
3001                                                  =item --charset
3002                                                  
3003                                                  short form: -A; type: string
3004                                                  
3005                                                  Default character set.  If the value is utf8, sets Perl's binmode on
3006                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
3007                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
3008                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
3009                                                  connecting to MySQL.
3010                                                  
3011                                                  =item --config
3012                                                  
3013                                                  type: Array
3014                                                  
3015                                                  Read this comma-separated list of config files; if specified, this must be the
3016                                                  first option on the command line.
3017                                                  
3018                                                  =item --continue-on-error
3019                                                  
3020                                                  Continue working even if there is an error.
3021                                                  
3022                                                  =item --daemonize
3023                                                  
3024                                                  Fork to the background and detach from the shell.  POSIX
3025                                                  operating systems only.
3026                                                  
3027                                                  =item --defaults-file
3028                                                  
3029                                                  short form: -F; type: string
3030                                                  
3031                                                  Only read mysql options from the given file.  You must give an absolute
3032                                                  pathname.
3033                                                  
3034                                                  =item --fingerprint
3035                                                  
3036                                                  Fingerprint and analyze only one sample of each unique query.
3037                                                  
3038                                                  =item --help
3039                                                  
3040                                                  Show help and exit.
3041                                                  
3042                                                  =item --host
3043                                                  
3044                                                  short form: -h; type: string
3045                                                  
3046                                                  Connect to host.
3047                                                  
3048                                                  =item --ignore-checks
3049                                                  
3050                                                  type: hash
3051                                                  
3052                                                  Ignore these check IDs or levels.
3053                                                  
3054                                                  Specify a comma-separated list of check IDs (e.g. LIT.001) or levels
3055                                                  (e.g. warn) to ignore.
3056                                                  
3057                                                  =item --password
3058                                                  
3059                                                  short form: -p; type: string
3060                                                  
3061                                                  Password to use when connecting.
3062                                                  
3063                                                  =item --pid
3064                                                  
3065                                                  type: string
3066                                                  
3067                                                  Create the given PID file when daemonized.  The file contains the process
3068                                                  ID of the daemonized instance.  The PID file is removed when the
3069                                                  daemonized instance exits.  The program checks for the existence of the
3070                                                  PID file when starting; if it exists and the process with the matching PID
3071                                                  exists, the program exits.
3072                                                  
3073                                                  =item --port
3074                                                  
3075                                                  short form: -P; type: int
3076                                                  
3077                                                  Port number to use for connection.
3078                                                  
3079                                                  =item --print-all
3080                                                  
3081                                                  Print all queries, even those with no flagged checks.
3082                                                  
3083                                                  =item --query
3084                                                  
3085                                                  type: string
3086                                                  
3087                                                  Analyze this single query; ignores files on command line.
3088                                                  
3089                                                  This option allows you to supply a single query on the command line.  Any
3090                                                  logs also specified on the command line are ignored.
3091                                                  
3092                                                  =item --report-format
3093                                                  
3094                                                  type: string; default: compact
3095                                                  
3096                                                  Type of report format: full or compact;
3097                                                  
3098                                                  A full report lists the check description for every query even if the check
3099                                                  has been seen before in another query.  A compact report only lists the
3100                                                  description for new checks and lists the check IDs for already seen checks.
3101                                                  
3102                                                  =item --type
3103                                                  
3104                                                  type: Array
3105                                                  
3106                                                  The type of input to parse (default slowlog).  The permitted types are
3107                                                  either slowlog or genlog.
3108                                                  
3109                                                  =item --set-vars
3110                                                  
3111                                                  type: string; default: wait_timeout=10000
3112                                                  
3113                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
3114                                                  will be appended to SET and executed.
3115                                                  
3116                                                  =item --socket
3117                                                  
3118                                                  short form: -S; type: string
3119                                                  
3120                                                  Socket file to use for connection.
3121                                                  
3122                                                  =item --user
3123                                                  
3124                                                  short form: -u; type: string
3125                                                  
3126                                                  User for login if not current user.
3127                                                  
3128                                                  =item --verbose
3129                                                  
3130                                                  short form: -v; cumulative: yes; default: 1
3131                                                  
3132                                                  Increase verbosity of output.
3133                                                  
3134                                                  =item --version
3135                                                  
3136                                                  Show version and exit.
3137                                                  
3138                                                  =back
3139                                                  
3140                                                  =head1 DOWNLOADING
3141                                                  
3142                                                  You can download Maatkit from Google Code at
3143                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
3144                                                  easily with a command like the following:
3145                                                  
3146                                                     wget http://www.maatkit.org/get/toolname
3147                                                     or
3148                                                     wget http://www.maatkit.org/trunk/toolname
3149                                                  
3150                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
3151                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
3152                                                  needed.  The first URL gets the latest released version of the tool, and the
3153                                                  second gets the latest trunk code from Subversion.
3154                                                  
3155                                                  =head1 ENVIRONMENT
3156                                                  
3157                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
3158                                                  the Maatkit tools:
3159                                                  
3160                                                     MKDEBUG=1 mk-....
3161                                                  
3162                                                  =head1 SYSTEM REQUIREMENTS
3163                                                  
3164                                                  You need the following Perl modules: DBI and DBD::mysql.
3165                                                  
3166                                                  =head1 BUGS
3167                                                  
3168                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-query-advisor>.
3169                                                  
3170                                                  Please use Google Code Issues and Groups to report bugs or request support:
3171                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
3172                                                  discuss Maatkit.
3173                                                  
3174                                                  Please include the complete command-line used to reproduce the problem you are
3175                                                  seeing, the version of all MySQL servers involved, the complete output of the
3176                                                  tool when run with L<"--version">, and if possible, debugging output produced by
3177                                                  running with the C<MKDEBUG=1> environment variable.
3178                                                  
3179                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
3180                                                  
3181                                                  This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
3182                                                  Feedback and improvements are welcome.
3183                                                  
3184                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
3185                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
3186                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
3187                                                  
3188                                                  This program is free software; you can redistribute it and/or modify it under
3189                                                  the terms of the GNU General Public License as published by the Free Software
3190                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
3191                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
3192                                                  licenses.
3193                                                  
3194                                                  You should have received a copy of the GNU General Public License along with
3195                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
3196                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
3197                                                  
3198                                                  =head1 AUTHOR
3199                                                  
3200                                                  Baron Schwartz, Daniel Nichter
3201                                                  
3202                                                  =head1 ABOUT MAATKIT
3203                                                  
3204                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
3205                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
3206                                                  code contributors.  Both are employed by Percona.  Financial support for
3207                                                  Maatkit development is primarily provided by Percona and its clients. 
3208                                                  
3209                                                  =head1 VERSION
3210                                                  
3211                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5782 $.
3212                                                  
3213                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
55    ***     50      0      9   unless $args{$arg}
61    ***     50      9      0   exists $args{'strict'} ? :
104   ***     50      0      9   unless open my $fh, '<', $file
124          100   3780      9   unless $para =~ /^=head1 OPTIONS/
129   ***     50      9      0   if $para =~ /^=over/
137   ***     50      0      9   unless $para
140          100    198      9   if (my($option) = $para =~ /^=item --(.*)/)
147          100    135     63   if ($para =~ /: /) { }
151   ***     50      0    234   unless $attributes{$attrib}
155          100     72     63   if ($attribs{'short form'})
171   ***     50      0    198   if $para =~ /^=item/
173   ***     50      0    198   if (my($base_option) = $option =~ /^\[no\](.*)/)
178          100     72    126   $attribs{'short form'} ? :
      ***     50      0    198   $attribs{'negatable'} ? :
             100      9    189   $attribs{'cumulative'} ? :
             100    126     72   $attribs{'type'} ? :
             100     27    171   $attribs{'default'} ? :
      ***     50      0    198   $attribs{'group'} ? :
190   ***     50      0    243   unless $para
193          100      9    234   if ($para =~ /^=head1/)
197          100    198     36   if $para =~ /^=item --/
201   ***     50      0      9   unless @specs
212   ***     50    198      0   if (ref $opt) { }
217   ***     50      0    198   if (not $long)
222   ***     50      0    198   if exists $$self{'opts'}{$long}
225   ***     50      0    198   if (length $long == 1)
230          100     72    126   if ($short) { }
231   ***     50      0     72   if exists $$self{'short_opts'}{$short}
240   ***     50      0    198   $$opt{'spec'} =~ /!/ ? :
241          100      9    189   $$opt{'spec'} =~ /\+/ ? :
242   ***     50      0    198   $$opt{'desc'} =~ /required/ ? :
254   ***     50      0    198   if ($type and $type eq 'd' and not $$self{'dp'})
259          100     27    171   if $type and $type =~ /[HhAadzm]/
261          100     36    162   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
262   ***     50     36      0   defined $def ? :
266          100      9    189   if ($long eq 'config')
270   ***     50      0    198   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
283   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
288   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
293   ***      0      0      0   if ($opt =~ /default to/)
298   ***      0      0      0   if ($opt =~ /restricted to option groups/)
308   ***      0      0      0   unless $rule_ok
325   ***      0      0      0   unless exists $$self{'opts'}{$long}
349   ***      0      0      0   unless exists $$self{'opts'}{$long}
369   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     27      0   exists $$self{'opts'}{$opt} ? :
374   ***     50      0     27   if ($$opt{'is_cumulative'}) { }
389   ***     50      0    153   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     45    153   exists $$self{'defaults'}{$long} ? :
398   ***     50      0      9   if (@ARGV and $ARGV[0] eq '--config')
402   ***     50      9      0   if ($self->has('config'))
408   ***     50     36      0   if ($EVAL_ERROR)
409   ***     50      0     36   $self->got('config') ? :
424   ***     50      0      9   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
427   ***     50      0      9   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
428   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
434   ***     50      0      9   if (@ARGV and $$self{'strict'})
440   ***      0      0      0   if (@set > 1)
451   ***      0      0      0   if (@set == 0)
461          100     27    171   if ($$opt{'got'}) { }
      ***     50      0    171   elsif ($$opt{'is_required'}) { }
462   ***     50      0     27   if (exists $$self{'disables'}{$long})
469   ***     50      0     27   if (exists $$self{'allowed_groups'}{$long})
481   ***      0      0      0   if $restricted_opt eq $long
482   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
487   ***      0      0      0   if (@restricted_opts)
489   ***      0      0      0   if (@restricted_opts == 1) { }
518          100     72    126   unless $opt and $$opt{'type'}
521   ***     50      0    126   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    126   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    126   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0    126   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     18    108   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
524   ***      0      0      0   if (not $suffix)
530   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
531   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
546   ***      0      0      0   if ($from_key)
557   ***      0      0      0   if (defined $num) { }
558   ***      0      0      0   if ($factor)
585   ***     50      0     81   length $opt == 1 ? :
586   ***     50      0     81   unless $long and exists $$self{'opts'}{$long}
593   ***     50      0     36   length $opt == 1 ? :
594   ***     50      0     36   unless $long and exists $$self{'opts'}{$long}
601   ***     50      0      9   length $opt == 1 ? :
602   ***     50      9      0   defined $long ? :
607   ***      0      0      0   length $opt == 1 ? :
608   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
635   ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
643   ***     50      0      9   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      9   elsif (scalar @{$$self{'errors'};}) { }
644   ***      0      0      0   unless print $self->print_usage
648   ***      0      0      0   unless print $self->print_errors
657   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
666   ***      0      0      0   unless $$self{'got_opts'}
669   ***      0      0      0   $$_{'is_negatable'} ? :
673   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
689   ***      0      0      0   $group eq 'default' ? :
695   ***      0      0      0   $$opt{'is_negatable'} ? :
698   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
707   ***      0      0      0   if ($short) { }
716   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
720   ***      0      0      0   if ($$self{'dp'})
728   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
740   ***      0      0      0   if ref $_[0] eq 'OptionParser'
743   ***      0      0      0   unless print $prompt
751   ***      0      0      0   unless print "\n"
754   ***      0      0      0   if ($EVAL_ERROR)
776   ***     50     36      0   unless open my $fh, '<', $filename
784   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
787   ***      0      0      0   if ($line eq '--')
792   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
810   ***      0      0      0   unless open my $fh, '<', $file
814   ***      0      0      0   unless $para =~ /^=pod$/m
818   ***      0      0      0   unless $para =~ /$regex/
823   ***      0      0      0   unless close $fh
837   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
856   ***     50      0      9   unless open my $fh, '<', $file
862          100   3573      9   unless $para =~ /^=head1 $section/o
866   ***     50      0      9   if ($subsection)
868   ***      0      0      0   unless $para =~ /^=head2 $subsection/o
875   ***     50      0    117   $subsection ? :
             100      9    108   if $subsection ? $para =~ /^=head[12]/ : $para =~ /^=head1/
876          100     27     81   if $para =~ /=head/
879   ***     50     81      0   if ($trf)
881          100      9     72   unless $para
891   ***      0      0      0   defined $_ ? :
939   ***      0      0      0   unless $args{$arg}
957   ***      0      0      0   if ($stmt =~ s/$slow_log_hd_line//go)
959   ***      0      0      0   if (@chunks > 1)
966   ***      0      0      0   unless $stmt =~ /\A#/
980   ***      0      0      0   if ($line =~ /^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) { }
982   ***      0      0      0   if (not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o) { }
      ***      0      0      0   elsif (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o) { }
      ***      0      0      0   elsif (not $got_ac and $line =~ /^# (?:administrator command:.*)$/) { }
      ***      0      0      0   elsif ($line =~ /^# +[A-Z][A-Za-z_]+: \S+/) { }
      ***      0      0      0   elsif (not $got_db and my($db) = $line =~ /^use ([^;]+)/) { }
      ***      0      0      0   elsif (not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/) { }
986   ***      0      0      0   if (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o)
1029  ***      0      0      0   if (not $found_arg and $pos == $len)
1032  ***      0      0      0   if (defined(my $l = &$next_event())) { }
1049  ***      0      0      0   if ($args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/)
1064  ***      0      0      0   if $args{'oktorun'}
1070  ***      0      0      0   defined $_ ? :
1115  ***      0      0      0   unless $args{$arg}
1139  ***      0      0      0   if $delim
1142  ***      0      0      0   if ($line =~ m[^/\*.+\*/;])
1147  ***      0      0      0   if ($line =~ /^DELIMITER/m)
1149  ***      0      0      0   if ($del) { }
1162  ***      0      0      0   if $line =~ /End of log file/
1164  ***      0      0      0   if (not $got_offset and my($offset) = $line =~ /$binlog_line_1/m) { }
      ***      0      0      0   elsif (not $got_hdr and $line =~ /^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/) { }
      ***      0      0      0   elsif ($line =~ /^(?:#|use |SET)/i) { }
1180  ***      0      0      0   if (my($db) = $line =~ /^use ([^;]+)/) { }
      ***      0      0      0   elsif (my($setting) = $line =~ /^SET\s+([^;]*)/) { }
1194  ***      0      0      0   if ($got_offset and $got_hdr) { }
1195  ***      0      0      0   if ($type eq 'Xid') { }
      ***      0      0      0   elsif ($type eq 'Query') { }
      ***      0      0      0   elsif ($type eq 'Start:') { }
1217  ***      0      0      0   $pos == length $stmt ? :
1220  ***      0      0      0   if $delim
1222  ***      0      0      0   if ($arg =~ /^DELIMITER/m)
1224  ***      0      0      0   if ($del) { }
1247  ***      0      0      0   if ($found_arg) { }
1257  ***      0      0      0   if $args{'oktorun'}
1263  ***      0      0      0   defined $_ ? :
1310  ***      0      0      0   unless $query
1314  ***      0      0      0   if ($ddl_stmt)
1317  ***      0      0      0   if ($query =~ /$ddl_stmt DATABASE\b/i)
1321  ***      0      0      0   if ($ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i)
1333  ***      0      0      0   if ($query =~ /^\s*LOCK TABLES/i)
1349  ***      0      0      0   if $tbls =~ /\ASELECT\b/i
1354  ***      0      0      0   if (not $tbl =~ /[a-zA-Z]/)
1374  ***     50      0      9   unless $query
1390  ***     50      0      9   if (not $tbl_refs)
1392  ***      0      0      0   $list ? :
1395         100      2      7   if ($query =~ /^(?:INSERT|REPLACE)/i)
1417  ***     50      0      9   if ($tbl_ref =~ /^AS\s+\w+/i)
1419  ***      0      0      0   unless $list
1423  ***     50      9      0   if ($list) { }
1431  ***      0      0      0   if $db
1439  ***      0      0      0   unless $query
1448  ***      0      0      0   if (@split_statements == 1) { }
1455  ***      0      0      0   if ($statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i)
1467  ***     50      0      9   unless $query
1477  ***      0      0      0   unless $query
1488  ***      0      0      0   if ($word =~ /^\(?SELECT\b/i) { }
1490  ***      0      0      0   if ($start_pos) { }
1508  ***      0      0      0   unless $sqno
1511  ***      0      0      0   if ($$sq{'done'})
1520  ***      0      0      0   if ($$sq{'lp'} + $lp - ($$sq{'rp'} + $rp) == 0)
1531  ***      0      0      0   unless $sq
1546  ***      0      0      0   if ($type =~ /^SELECT\b/) { }
      ***      0      0      0   elsif ($type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/) { }
1563  ***     50      0      9   unless $query
1566         100      7      2   if ($query =~ /^SELECT/i) { }
      ***     50      2      0   elsif ($query =~ /^(?:INSERT|REPLACE)/i) { }
1589         100      7      2   if ($cols_def)
1604  ***     50      0      9   unless $query
1623  ***      0      0      0   defined $_ ? :
1675  ***      0      0      0   unless $query
1678  ***      0      0      0   if ($query =~ /$vlc_rf/i)
1695  ***      0      0      0   unless $query =~ /IN\s*\(\s*(?!select)/i
1721  ***      0      0      0   unless @vals > 20
1733  ***      0      0      0   if $query =~ m[\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `]
1735  ***      0      0      0   if $query =~ m[/\*\w+\.\w+:[0-9]/[0-9]\*/]
1737  ***      0      0      0   if $query =~ /\A# administrator command: /
1739  ***      0      0      0   if $query =~ /\A\s*(call\s+\S+)\(/i
1741  ***      0      0      0   if (my($beginning) = $query =~ /\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is)
1747  ***      0      0      0   if $query =~ s/\Ause \S+\Z/use ?/i
1775  ***      0      0      0   if $query =~ /\A\s*call\s+(\S+)\(/i
1776  ***      0      0      0   if $query =~ /\A\s*use\s+/
1777  ***      0      0      0   if $query =~ /\A\s*UNLOCK TABLES/i
1778  ***      0      0      0   if $query =~ /\A\s*xa\s+(\S+)/i
1780  ***      0      0      0   if ($query =~ /\A# administrator command:/)
1788  ***      0      0      0   if ($query =~ /\A\s*SHOW\s+/i)
1806  ***      0      0      0   if ($dds)
1808  ***      0      0      0   if $obj
1813  ***      0      0      0   $obj ? :
1830  ***      0      0      0   unless $qp
1838  ***      0      0      0   if $table
1851  ***      0      0      0   if ($args{'generic'}) { }
1853  ***      0      0      0   unless $cmd
1854  ***      0      0      0   $arg ? :
1859  ***      0      0      0   if ($verbs and $verbs =~ /^SHOW/) { }
1874  ***      0      0      0   if ($args{'trf'})
1883  ***      0      0      0   unless $query
1902  ***      0      0      0   unless $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
1916  ***      0      0      0   $1 =~ /\*/ ? :
1925  ***      0      0      0   if ($join =~ /\bjoin\b/)
1939  ***      0      0      0   if (@cols == @vals) { }
1950  ***      0      0      0   $where ? :
      ***      0      0      0   $limit ? :
1957  ***      0      0      0   unless $query
1958  ***      0      0      0   $query =~ /\A\s*select/i ? :
1965  ***      0      0      0   defined $_ ? :
2014  ***      0      0      0   defined $args{'p_ms'} ? :
2015  ***      0      0      0   defined $args{'p_s'} ? :
2018  ***      0      0      0   if $t < 0
2020  ***      0      0      0   if $t =~ /e/
2024  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
2045  ***      0      0      0   $p ? :
2052  ***      0      0      0   unless $secs
2054  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
2059  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
2078  ***      0      0      0   unless defined $val
2082  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
2083  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
2088  ***      0      0      0   if $prefix and $prefix eq '-'
2098  ***      0      0      0   defined $args{'p'} ? :
2099  ***      0      0      0   defined $args{'d'} ? :
2106  ***      0      0      0   $num =~ /\./ || $n ? :
2115  ***      0      0      0   $gmt ? :
2121  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
2131  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
2134  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
2143  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
2144  ***      0      0      0   $gmt ? :
2147  ***      0      0      0   if (defined $us)
2159  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif ($val =~ /^\d{9,}/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
2160  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
2174  ***      0      0      0   unless $hms
2179  ***      0      0      0   unless $hms
2184  ***      0      0      0   if $callback and ref $callback eq 'CODE'
2200  ***      0      0      0   defined $_ ? :
2229  ***      0      0      0   unless $args{$arg}
2232  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
2248  ***      0      0      0   unless defined(my $pid = fork)
2249  ***      0      0      0   if ($pid)
2256  ***      0      0      0   unless POSIX::setsid()
2257  ***      0      0      0   unless chdir '/'
2263  ***      0      0      0   if (-t STDIN)
2265  ***      0      0      0   unless open STDIN, '/dev/null'
2269  ***      0      0      0   if ($$self{'log_file'}) { }
2271  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
2275  ***      0      0      0   unless open STDERR, '>&STDOUT'
2279  ***      0      0      0   if (-t STDOUT)
2281  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
2284  ***      0      0      0   if (-t STDERR)
2286  ***      0      0      0   unless open STDERR, '>', '/dev/null'
2297  ***      0      0      0   $self ? :
2299  ***      0      0      0   if ($PID_file and -f $PID_file) { }
2302  ***      0      0      0   if $EVAL_ERROR
2304  ***      0      0      0   if ($pid) { }
2306  ***      0      0      0   if ($pid_is_alive) { }
2328  ***      0      0      0   if (exists $$self{'child'})
2340  ***      0      0      0   if (not $PID_file)
2347  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
2349  ***      0      0      0   unless print $PID_FH $PID
2351  ***      0      0      0   unless close $PID_FH
2360  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
2361  ***      0      0      0   unless unlink $$self{'PID_file'}
2373  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
2379  ***      0      0      0   defined $_ ? :
2462  ***     50      9      0   if (my $query = $o->get('query')) { }
2466  ***     50      9      0   if $args{'oktorun'}
2487  ***      0      0      0   if $alias_for{$$type[0]}
2497  ***      0      0      0   if ($EVAL_ERROR)
2512  ***     50      0      9   if (($$event{'cmd'} || '') ne 'Query')
2516  ***     50      0      9   if (not $$event{'arg'})
2523  ***     50      0      9   if ($o->get('fingerprint'))
2530  ***      0      0      0   if ($seen_fingerprint{$$event{'fingerprint'}}++)
2546  ***     50      0      9   unless $query_struct
2581  ***     50      9      0   if (@ARGV == 0)
2589  ***     50      0      9   if ($o->get('daemonize')) { }
      ***     50      0      9   elsif ($o->get('pid')) { }
2605  ***     50     18      0   if (not $fh)
2607         100      9      9   if (not $file)
2611  ***     50      9      0   if ($file eq '-') { }
2616  ***      0      0      0   if (not open $fh, '<', $file)
2632  ***     50      0     45   unless $oktorun
2640  ***     50      0     45   unless $event
2643  ***     50      0      9   if ($EVAL_ERROR)
2645  ***      0      0      0   unless $o->get('continue-on-error')
2647  ***     50      9      0   if (not $more_events)
2649  ***     50      0      9   if $fh and $fh ne *STDIN
2667         100      9     74   unless $para =~ /^id:/
2694  ***     50      0     74   unless $rules
2722  ***     50      0    108   if (not $obj or not $m or not $pat)
2726         100     23     85   $m =~ /not/ ? :
2737         100     82      4   unless $ignore_checks
2738         100      1      3   if $$ignore_checks{$$check{'id'}}
2739         100      1      2   if $$ignore_checks{$$check{'level'}}
2768         100     25     53   $obj =~ /$pat/ ? :
             100      4      9   !($obj =~ /$pat/) ? :
             100     78     13   $$rule{'positive_match'} ? :
2772         100     29     62   if $matches
2776         100     66     29   unless $matches
2779         100     16     66   if ($matches)
2798  ***     50      0      9   unless $n_flags or $args{'print_all'}
2807  ***     50      0     11   if ($format eq 'compact' and $seen_id{$$c{'id'}}++) { }
2812         100     14     11   unless /\.$/
2816  ***      0      0      0   $verbose > 2 ? :
      ***      0      0      0   $verbose == 2 ? :
      ***     50     11      0   $verbose == 1 ? :
2825  ***     50      0      9   if scalar @seen_ids
2836  ***      0      0      0   if ($oktorun) { }
2848  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
254   ***     66     72    126      0   $type and $type eq 'd'
      ***     33    198      0      0   $type and $type eq 'd' and not $$self{'dp'}
259          100     72     99     27   $type and $type =~ /[HhAadzm]/
398   ***     33      0      9      0   @ARGV and $ARGV[0] eq '--config'
427   ***     33      0      9      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
434   ***     33      9      0      0   @ARGV and $$self{'strict'}
518   ***     66      0     72    126   $opt and $$opt{'type'}
521   ***     66     81     45      0   $val and $$opt{'type'} eq 'm'
      ***     66     81     45      0   $val and $$opt{'type'} eq 'd'
      ***     66     81     45      0   $val and $$opt{'type'} eq 'z'
      ***     66     81     45      0   defined $val and $$opt{'type'} eq 'h'
      ***     66     81     27      0   defined $val and $$opt{'type'} eq 'a'
586   ***     33      0      0     81   $long and exists $$self{'opts'}{$long}
594   ***     33      0      0     36   $long and exists $$self{'opts'}{$long}
608   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
698   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
792   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
982   ***      0      0      0      0   not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o
      ***      0      0      0      0   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
      ***      0      0      0      0   not $got_ac and $line =~ /^# (?:administrator command:.*)$/
      ***      0      0      0      0   not $got_db and my($db) = $line =~ /^use ([^;]+)/
      ***      0      0      0      0   not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/
986   ***      0      0      0      0   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
1029  ***      0      0      0      0   not $found_arg and $pos == $len
1049  ***      0      0      0      0   $args{'misc'} and $args{'misc'}{'embed'}
      ***      0      0      0      0   $args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/
1164  ***      0      0      0      0   not $got_offset and my($offset) = $line =~ /$binlog_line_1/m
      ***      0      0      0      0   not $got_hdr and $line =~ /^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/
1194  ***      0      0      0      0   $got_offset and $got_hdr
1321  ***      0      0      0      0   $ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i
1455  ***      0      0      0      0   $statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i
1699  ***      0      0      0      0   $length > 0 and $query_length > $length
      ***      0      0      0      0   $length > 0 and $query_length > $length and $query_length < ($last_length || $query_length + 1)
1859  ***      0      0      0      0   $verbs and $verbs =~ /^SHOW/
2024  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
2088  ***      0      0      0      0   $prefix and $prefix eq '-'
2102  ***      0      0      0      0   $num >= $d and $n < @units - 1
2184  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
2299  ***      0      0      0      0   $PID_file and -f $PID_file
2360  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2649  ***     33      0      9      0   $fh and $fh ne *STDIN
2807  ***     33     11      0      0   $format eq 'compact' and $seen_id{$$c{'id'}}++

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
39    ***     50      0      5   $ENV{'MKDEBUG'} || 0
59    ***     50      9      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
61    ***     50      9      0   $args{'prompt'} || '<options>'
      ***     50      0      9   $args{'dp'} || undef
103   ***     50      0      9   $file ||= '/home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor'
244   ***     50    198      0   $$opt{'group'} ||= 'default'
526   ***      0      0      0   $s || 's'
535   ***      0      0      0   $prefix || ''
563   ***      0      0      0   $pre || ''
570   ***      0      0      0   $val || ''
573   ***     50     18      0   $val || ''
631   ***      0      0      0   $$self{'description'} || ''
700   ***      0      0      0   $s ||= 's'
726   ***      0      0      0   $$opt{'type'} || ''
855   ***     50      9      0   $file ||= '/home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor'
913   ***     50      0      5   $ENV{'MKDEBUG'} || 0
1096  ***     50      0      5   $ENV{'MKDEBUG'} || 0
1284  ***     50      0      5   $ENV{'MKDEBUG'} || 0
1517  ***      0      0      0   $word =~ tr/(// || 0
1518  ***      0      0      0   $word =~ tr/)// || 0
1645  ***     50      0      5   $ENV{'MKDEBUG'} || 0
1989  ***     50      0      5   $ENV{'MKDEBUG'} || 0
2044  ***      0      0      0   $args{'p'} || 0
2046  ***      0      0      0   $of ||= 1
2051  ***      0      0      0   $secs ||= 0
2081  ***      0      0      0   $suffix || $default_suffix || 's'
2224  ***     50      0      5   $ENV{'MKDEBUG'} || 0
2411  ***     50      0      5   $ENV{'MKDEBUG'} || 0
2512  ***     50      9      0   $$event{'cmd'} || ''
2791  ***     50      9      0   $args{'verbose'} || 0
2802  ***     50      0      9   $$event{'pos_in_log'} || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
58    ***     33      9      0      0   $program_name ||= $PROGRAM_NAME
59    ***     33      9      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33      9      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
521   ***     33      0      0    126   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66     18      0    108   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
950   ***      0      0      0      0   defined($stmt = shift @$pending) or defined($stmt = &$next_event())
1430  ***      0      0      0      0   $alias or $tbl
1546  ***      0      0      0      0   $type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/
1699  ***      0      0      0      0   $last_length || $query_length + 1
1829  ***      0      0      0      0   $args{'QueryParser'} || $$self{'QueryParser'}
1902  ***      0      0      0      0   $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
2054  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
2081  ***      0      0      0      0   $suffix || $default_suffix
2106  ***      0      0      0      0   $num =~ /\./ || $n
2373  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2722  ***     33      0      0    108   not $obj or not $m
      ***     33      0      0    108   not $obj or not $m or not $pat
2798  ***     33      9      0      0   $n_flags or $args{'print_all'}
2801  ***     33      0      9      0   $$event{'fingerprint'} || $$event{'arg'}


Covered Subroutines
-------------------

Subroutine          Count Location                                                       
------------------- ----- ---------------------------------------------------------------
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1087
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1088
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1089
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1091
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1096
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1280
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1281
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1282
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1284
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1638
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1639
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1643
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1645
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1983
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1984
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1985
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1986
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1987
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1989
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:20  
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:21  
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2218
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2219
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2221
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2222
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2224
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2401
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2402
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2403
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2404
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2411
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2413
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:32  
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:33  
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:35  
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:36  
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:37  
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:39  
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:908 
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:909 
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:910 
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:911 
BEGIN                   5 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:913 
__ANON__               81 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2442
__ANON__                9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2464
__ANON__                9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2509
__ANON__                9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2542
__ANON__                9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2553
__ANON__                9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2565
__ANON__                9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2629
__ANON__               27 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:422 
_parse_specs            9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:208 
_pod_to_specs           9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:102 
_read_config_file      36 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:775 
_set_option            27 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:368 
_validate_type        198 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:517 
check_query            19 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2752
clean_query             9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1466
filter_checks          86 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2736
get                    81 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:584 
get_aliases             9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1373
get_columns             9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1561
get_defaults_files      9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:97  
get_opts                9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:385 
get_specs               9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:90  
got                    36 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:592 
has                     9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:600 
main                    9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2419
make_checksum           9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2192
new                     9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1304
new                     9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1668
new                     9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:53  
parse                   9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1603
parse_check            83 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2666
parse_check_rules      85 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2715
parse_section           9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:851 
print_flags             9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2789
usage_or_errors         9 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:642 

Uncovered Subroutines
---------------------

Subroutine          Count Location                                                       
------------------- ----- ---------------------------------------------------------------
DESTROY                 0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2372
__ANON__                0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2501
__ANON__                0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2526
__ANON__                0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2626
__ANON__                0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2627
__delete_to_select      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1924
__distill_tables        0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1828
__insert_to_select      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1932
__shorten               0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1719
__update_to_select      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1949
_d                      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1069
_d                      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1262
_d                      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1622
_d                      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1964
_d                      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2199
_d                      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2378
_d                      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2847
_d                      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:890 
_get_participants       0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:322 
_make_PID_file          0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2337
_remove_PID_file        0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2359
any_unix_timestamp      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2157
check_PID_file          0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2296
clone                   0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:828 
convert_select_list     0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1915
convert_to_select       0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1882
daemonize               0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2245
descr                   0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:630 
distill                 0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1849
distill_verbs           0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1773
errors                  0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:620 
fingerprint             0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1731
get_defaults            0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:358 
get_groups              0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:363 
get_tables              0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1309
has_derived_table       0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1366
make_PID_file           0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2327
micro_t                 0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2013
new                     0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1099
new                     0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2227
new                     0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:916 
opts                    0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:334 
parse_event             0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1112
parse_event             0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:936 
parse_timestamp         0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2130
percentage_of           0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2043
print_errors            0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:655 
print_usage             0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:665 
prompt                  0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:625 
prompt_noecho           0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:740 
query_type              0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1543
read_para_after         0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:809 
save_error              0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:615 
secs_to_time            0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2050
set                     0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:606 
set_defaults            0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:346 
short_opts              0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:340 
shorten                 0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1685
shorten                 0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2097
sig_int                 0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2835
split                   0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1438
split_subquery          0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1476
strip_comments          0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1674
time_to_secs            0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2077
ts                      0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2114
unix_timestamp          0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:2142
wrap_in_derived         0 /home/daniel/dev/maatkit/mk-query-advisor/mk-query-advisor:1956


