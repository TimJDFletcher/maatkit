---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...-restart/mk-slave-restart   13.1    2.4    5.7   30.9    n/a    0.0   10.4
mk-slave-restart.t             95.1   40.0   40.0  100.0    n/a  100.0   87.6
Total                          17.8    3.0    6.2   34.7    n/a  100.0   13.6
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:40:11 2010
Finish:       Thu Jan 28 22:40:11 2010

Run:          ./mk-slave-restart.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:40:12 2010
Finish:       Thu Jan 28 22:40:20 2010

/home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-slave-restart, a program to watch replication and try to
4                                                     # restart slaves on errors.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             1                    1            10   use strict;
               1                                  4   
               1                                 11   
24             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  7   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # Quoter package 5266
32                                                    # ###########################################################################
33             1                    1             6   use strict;
               1                                  2   
               1                                  5   
34             1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                 15   
35                                                    
36                                                    package Quoter;
37                                                    
38             1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
39                                                    
40    ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 15   
41                                                    
42                                                    sub new {
43    ***      0                    0             0      my ( $class ) = @_;
44    ***      0                                  0      bless {}, $class;
45                                                    }
46                                                    
47                                                    sub quote {
48    ***      0                    0             0      my ( $self, @vals ) = @_;
49    ***      0                                  0      foreach my $val ( @vals ) {
50    ***      0                                  0         $val =~ s/`/``/g;
51                                                       }
52    ***      0                                  0      return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                  0   
53                                                    }
54                                                    
55                                                    sub quote_val {
56    ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
57                                                    
58    ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
59    ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
60                                                    
61    ***      0      0                           0      if ( !defined $is_numeric ) {
62    ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
63                                                       }
64                                                    
65    ***      0      0                           0      return $val if $is_numeric;
66                                                    
67    ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
68    ***      0                                  0      return "'$val'";
69                                                    }
70                                                    
71                                                    sub split_unquote {
72    ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
73    ***      0                                  0      $db_tbl =~ s/`//g;
74    ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
75    ***      0      0                           0      if ( !$tbl ) {
76    ***      0                                  0         $tbl = $db;
77    ***      0                                  0         $db  = $default_db;
78                                                       }
79    ***      0                                  0      return ($db, $tbl);
80                                                    }
81                                                    
82                                                    sub literal_like {
83    ***      0                    0             0      my ( $self, $like ) = @_;
84    ***      0      0                           0      return unless $like;
85    ***      0                                  0      $like =~ s/([%_])/\\$1/g;
86    ***      0                                  0      return "'$like'";
87                                                    }
88                                                    
89                                                    1;
90                                                    
91                                                    # ###########################################################################
92                                                    # End Quoter package
93                                                    # ###########################################################################
94                                                    
95                                                    # ###########################################################################
96                                                    # OptionParser package 5266
97                                                    # ###########################################################################
98                                                    package OptionParser;
99                                                    
100            1                    1             7   use strict;
               1                                  2   
               1                                  6   
101            1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  4   
102                                                   
103            1                    1            10   use Getopt::Long;
               1                                  3   
               1                                  7   
104            1                    1             7   use List::Util qw(max);
               1                                  3   
               1                                 11   
105            1                    1             7   use English qw(-no_match_vars);
               1                                  8   
               1                                  6   
106                                                   
107   ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 15   
108                                                   
109                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
110                                                   
111                                                   my %attributes = (
112                                                      'type'       => 1,
113                                                      'short form' => 1,
114                                                      'group'      => 1,
115                                                      'default'    => 1,
116                                                      'cumulative' => 1,
117                                                      'negatable'  => 1,
118                                                   );
119                                                   
120                                                   sub new {
121   ***      0                    0             0      my ( $class, %args ) = @_;
122   ***      0                                  0      foreach my $arg ( qw(description) ) {
123   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
124                                                      }
125   ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
126   ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
127   ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
128                                                   
129   ***      0      0      0                    0      my $self = {
      ***                    0                        
130                                                         description    => $args{description},
131                                                         prompt         => $args{prompt} || '<options>',
132                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
133                                                         dp             => $args{dp}     || undef,
134                                                         program_name   => $program_name,
135                                                         opts           => {},
136                                                         got_opts       => 0,
137                                                         short_opts     => {},
138                                                         defaults       => {},
139                                                         groups         => {},
140                                                         allowed_groups => {},
141                                                         errors         => [],
142                                                         rules          => [],  # desc of rules for --help
143                                                         mutex          => [],  # rule: opts are mutually exclusive
144                                                         atleast1       => [],  # rule: at least one opt is required
145                                                         disables       => {},  # rule: opt disables other opts 
146                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
147                                                         default_files  => [
148                                                            "/etc/maatkit/maatkit.conf",
149                                                            "/etc/maatkit/$program_name.conf",
150                                                            "$home/.maatkit.conf",
151                                                            "$home/.$program_name.conf",
152                                                         ],
153                                                      };
154   ***      0                                  0      return bless $self, $class;
155                                                   }
156                                                   
157                                                   sub get_specs {
158   ***      0                    0             0      my ( $self, $file ) = @_;
159   ***      0                                  0      my @specs = $self->_pod_to_specs($file);
160   ***      0                                  0      $self->_parse_specs(@specs);
161   ***      0                                  0      return;
162                                                   }
163                                                   
164                                                   sub get_defaults_files {
165   ***      0                    0             0      my ( $self ) = @_;
166   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
167                                                   }
168                                                   
169                                                   sub _pod_to_specs {
170   ***      0                    0             0      my ( $self, $file ) = @_;
171   ***      0             0                    0      $file ||= __FILE__;
172   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
173                                                   
174   ***      0                                  0      my %types = (
175                                                         string => 's', # standard Getopt type
176                                                         'int'  => 'i', # standard Getopt type
177                                                         float  => 'f', # standard Getopt type
178                                                         Hash   => 'H', # hash, formed from a comma-separated list
179                                                         hash   => 'h', # hash as above, but only if a value is given
180                                                         Array  => 'A', # array, similar to Hash
181                                                         array  => 'a', # array, similar to hash
182                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
183                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
184                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
185                                                      );
186   ***      0                                  0      my @specs = ();
187   ***      0                                  0      my @rules = ();
188   ***      0                                  0      my $para;
189                                                   
190   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
191   ***      0                                  0      while ( $para = <$fh> ) {
192   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
193   ***      0                                  0         last;
194                                                      }
195                                                   
196   ***      0                                  0      while ( $para = <$fh> ) {
197   ***      0      0                           0         last if $para =~ m/^=over/;
198   ***      0                                  0         chomp $para;
199   ***      0                                  0         $para =~ s/\s+/ /g;
200   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
201   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
202   ***      0                                  0         push @rules, $para;
203                                                      }
204                                                   
205   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
206                                                   
207   ***      0                                  0      do {
208   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
209   ***      0                                  0            chomp $para;
210   ***      0                                  0            MKDEBUG && _d($para);
211   ***      0                                  0            my %attribs;
212                                                   
213   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
214                                                   
215   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
216   ***      0                                  0               $para =~ s/\s+\Z//g;
217   ***      0                                  0               %attribs = map {
218   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
219   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
220                                                                        unless $attributes{$attrib};
221   ***      0                                  0                     ($attrib, $val);
222                                                                  } split(/; /, $para);
223   ***      0      0                           0               if ( $attribs{'short form'} ) {
224   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
225                                                               }
226   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
227                                                            }
228                                                            else {
229   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
230                                                            }
231                                                   
232   ***      0                                  0            $para =~ s/\s+\Z//g;
233   ***      0                                  0            $para =~ s/\s+/ /g;
234   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
235                                                   
236   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
237   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
238                                                   
239   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
240                                                   
241   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
242   ***      0                                  0               $option = $base_option;
243   ***      0                                  0               $attribs{'negatable'} = 1;
244                                                            }
245                                                   
246   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
247                                                               spec  => $option
248                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
249                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
250                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
251                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
252                                                               desc  => $para
253                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
254                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
255                                                            };
256                                                         }
257   ***      0                                  0         while ( $para = <$fh> ) {
258   ***      0      0                           0            last unless $para;
259                                                   
260                                                   
261   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
262   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
263   ***      0                                  0               last;
264                                                            }
265   ***      0      0                           0            last if $para =~ m/^=item --/;
266                                                         }
267                                                      } while ( $para );
268                                                   
269   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
270                                                   
271   ***      0                                  0      close $fh;
272   ***      0                                  0      return @specs, @rules;
273                                                   }
274                                                   
275                                                   sub _parse_specs {
276   ***      0                    0             0      my ( $self, @specs ) = @_;
277   ***      0                                  0      my %disables; # special rule that requires deferred checking
278                                                   
279   ***      0                                  0      foreach my $opt ( @specs ) {
280   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
281                                                            MKDEBUG && _d('Parsing opt spec:',
282   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
283                                                   
284   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
285   ***      0      0                           0            if ( !$long ) {
286   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
287                                                            }
288   ***      0                                  0            $opt->{long} = $long;
289                                                   
290   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
291   ***      0                                  0            $self->{opts}->{$long} = $opt;
292                                                   
293   ***      0      0                           0            if ( length $long == 1 ) {
294   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
295   ***      0                                  0               $self->{short_opts}->{$long} = $long;
296                                                            }
297                                                   
298   ***      0      0                           0            if ( $short ) {
299   ***      0      0                           0               die "Duplicate short option -$short"
300                                                                  if exists $self->{short_opts}->{$short};
301   ***      0                                  0               $self->{short_opts}->{$short} = $long;
302   ***      0                                  0               $opt->{short} = $short;
303                                                            }
304                                                            else {
305   ***      0                                  0               $opt->{short} = undef;
306                                                            }
307                                                   
308   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
309   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
310   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
311                                                   
312   ***      0             0                    0            $opt->{group} ||= 'default';
313   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
314                                                   
315   ***      0                                  0            $opt->{value} = undef;
316   ***      0                                  0            $opt->{got}   = 0;
317                                                   
318   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
319   ***      0                                  0            $opt->{type} = $type;
320   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
321                                                   
322   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
323   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
324                                                                  . "was given when this OptionParser object was created";
325                                                            }
326                                                   
327   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
328                                                   
329   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
330   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
331   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
332                                                            }
333                                                   
334   ***      0      0                           0            if ( $long eq 'config' ) {
335   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
336                                                            }
337                                                   
338   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
339   ***      0                                  0               $disables{$long} = $dis;
340   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
341                                                            }
342                                                   
343   ***      0                                  0            $self->{opts}->{$long} = $opt;
344                                                         }
345                                                         else { # It's an option rule, not a spec.
346   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
347   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
348   ***      0                                  0            my @participants = $self->_get_participants($opt);
349   ***      0                                  0            my $rule_ok = 0;
350                                                   
351   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
352   ***      0                                  0               $rule_ok = 1;
353   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
354   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
355                                                            }
356   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
357   ***      0                                  0               $rule_ok = 1;
358   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
359   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
360                                                            }
361   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
362   ***      0                                  0               $rule_ok = 1;
363   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
364   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
365                                                            }
366   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
367   ***      0                                  0               $rule_ok = 1;
368   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
369   ***      0                                  0               my @groups = split(',', $groups);
370   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
371   ***      0                                  0                  s/\s+//;
372   ***      0                                  0                  $_ => 1;
373                                                               } @groups;
374                                                            }
375                                                   
376   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
377                                                         }
378                                                      }
379                                                   
380   ***      0                                  0      foreach my $long ( keys %disables ) {
381   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
382   ***      0                                  0         $self->{disables}->{$long} = \@participants;
383   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
384                                                      }
385                                                   
386   ***      0                                  0      return; 
387                                                   }
388                                                   
389                                                   sub _get_participants {
390   ***      0                    0             0      my ( $self, $str ) = @_;
391   ***      0                                  0      my @participants;
392   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
393   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
394                                                            unless exists $self->{opts}->{$long};
395   ***      0                                  0         push @participants, $long;
396                                                      }
397   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
398   ***      0                                  0      return @participants;
399                                                   }
400                                                   
401                                                   sub opts {
402   ***      0                    0             0      my ( $self ) = @_;
403   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
404   ***      0                                  0      return %opts;
405                                                   }
406                                                   
407                                                   sub short_opts {
408   ***      0                    0             0      my ( $self ) = @_;
409   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
410   ***      0                                  0      return %short_opts;
411                                                   }
412                                                   
413                                                   sub set_defaults {
414   ***      0                    0             0      my ( $self, %defaults ) = @_;
415   ***      0                                  0      $self->{defaults} = {};
416   ***      0                                  0      foreach my $long ( keys %defaults ) {
417   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
418                                                            unless exists $self->{opts}->{$long};
419   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
420   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
421                                                      }
422   ***      0                                  0      return;
423                                                   }
424                                                   
425                                                   sub get_defaults {
426   ***      0                    0             0      my ( $self ) = @_;
427   ***      0                                  0      return $self->{defaults};
428                                                   }
429                                                   
430                                                   sub get_groups {
431   ***      0                    0             0      my ( $self ) = @_;
432   ***      0                                  0      return $self->{groups};
433                                                   }
434                                                   
435                                                   sub _set_option {
436   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
437   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
438                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
439                                                               : die "Getopt::Long gave a nonexistent option: $opt";
440                                                   
441   ***      0                                  0      $opt = $self->{opts}->{$long};
442   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
443   ***      0                                  0         $opt->{value}++;
444                                                      }
445                                                      else {
446   ***      0                                  0         $opt->{value} = $val;
447                                                      }
448   ***      0                                  0      $opt->{got} = 1;
449   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
450                                                   }
451                                                   
452                                                   sub get_opts {
453   ***      0                    0             0      my ( $self ) = @_; 
454                                                   
455   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
456   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
457   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
458                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
459                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
460                                                            : undef;
461                                                      }
462   ***      0                                  0      $self->{got_opts} = 0;
463                                                   
464   ***      0                                  0      $self->{errors} = [];
465                                                   
466   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
467   ***      0                                  0         shift @ARGV;
468   ***      0                                  0         $self->_set_option('config', shift @ARGV);
469                                                      }
470   ***      0      0                           0      if ( $self->has('config') ) {
471   ***      0                                  0         my @extra_args;
472   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
473   ***      0                                  0            eval {
474   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
475                                                            };
476   ***      0      0                           0            if ( $EVAL_ERROR ) {
477   ***      0      0                           0               if ( $self->got('config') ) {
478   ***      0                                  0                  die $EVAL_ERROR;
479                                                               }
480                                                               elsif ( MKDEBUG ) {
481                                                                  _d($EVAL_ERROR);
482                                                               }
483                                                            }
484                                                         }
485   ***      0                                  0         unshift @ARGV, @extra_args;
486                                                      }
487                                                   
488   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
489                                                      GetOptions(
490   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
491   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
492   ***      0      0                           0         values %{$self->{opts}}
493                                                      ) or $self->save_error('Error parsing options');
494                                                   
495   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
496   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
497                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
498                                                               or die "Cannot print: $OS_ERROR";
499   ***      0                                  0         exit 0;
500                                                      }
501                                                   
502   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
503   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
504                                                      }
505                                                   
506   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
507   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
508   ***      0      0                           0         if ( @set > 1 ) {
509   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
510   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
511                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
512                                                                    . ' are mutually exclusive.';
513   ***      0                                  0            $self->save_error($err);
514                                                         }
515                                                      }
516                                                   
517   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
518   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
519   ***      0      0                           0         if ( @set == 0 ) {
520   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
521   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
522                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
523   ***      0                                  0            $self->save_error("Specify at least one of $err");
524                                                         }
525                                                      }
526                                                   
527   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
528   ***      0                                  0         my $opt = $self->{opts}->{$long};
529   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
530   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
531   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
532   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
533   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
534                                                                  'because', $long,'disables them');
535                                                            }
536                                                   
537   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
538                                                   
539   ***      0                                  0               my @restricted_groups = grep {
540   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
541   ***      0                                  0               } keys %{$self->{groups}};
542                                                   
543   ***      0                                  0               my @restricted_opts;
544   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
545   ***      0                                  0                  RESTRICTED_OPT:
546   ***      0                                  0                  foreach my $restricted_opt (
547                                                                     keys %{$self->{groups}->{$restricted_group}} )
548                                                                  {
549   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
550   ***      0      0                           0                     push @restricted_opts, $restricted_opt
551                                                                        if $self->{opts}->{$restricted_opt}->{got};
552                                                                  }
553                                                               }
554                                                   
555   ***      0      0                           0               if ( @restricted_opts ) {
556   ***      0                                  0                  my $err;
557   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
558   ***      0                                  0                     $err = "--$restricted_opts[0]";
559                                                                  }
560                                                                  else {
561   ***      0                                  0                     $err = join(', ',
562   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
563   ***      0                                  0                               grep { $_ } 
564                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
565                                                                            )
566                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
567                                                                  }
568   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
569                                                               }
570                                                            }
571                                                   
572                                                         }
573                                                         elsif ( $opt->{is_required} ) { 
574   ***      0                                  0            $self->save_error("Required option --$long must be specified");
575                                                         }
576                                                   
577   ***      0                                  0         $self->_validate_type($opt);
578                                                      }
579                                                   
580   ***      0                                  0      $self->{got_opts} = 1;
581   ***      0                                  0      return;
582                                                   }
583                                                   
584                                                   sub _validate_type {
585   ***      0                    0             0      my ( $self, $opt ) = @_;
586   ***      0      0      0                    0      return unless $opt && $opt->{type};
587   ***      0                                  0      my $val = $opt->{value};
588                                                   
589   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
590   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
591   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
592   ***      0      0                           0         if ( !$suffix ) {
593   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
594   ***      0             0                    0            $suffix = $s || 's';
595   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
596                                                               $opt->{long}, '(value:', $val, ')');
597                                                         }
598   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
599   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
600                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
601                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
602                                                                 :                  $num * 86400;   # Days
603   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
604   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
605                                                         }
606                                                         else {
607   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
608                                                         }
609                                                      }
610                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
611   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
612   ***      0                                  0         my $prev = {};
613   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
614   ***      0      0                           0         if ( $from_key ) {
615   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
616   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
617                                                         }
618   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
619   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
620                                                      }
621                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
622   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
623   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
624   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
625   ***      0      0                           0         if ( defined $num ) {
626   ***      0      0                           0            if ( $factor ) {
627   ***      0                                  0               $num *= $factor_for{$factor};
628   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
629                                                                  'to num', $num, '* factor', $factor);
630                                                            }
631   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
632                                                         }
633                                                         else {
634   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
635                                                         }
636                                                      }
637                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
638   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
639                                                      }
640                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
641   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
642                                                      }
643                                                      else {
644   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
645                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
646                                                      }
647                                                   
648   ***      0                                  0      return;
649                                                   }
650                                                   
651                                                   sub get {
652   ***      0                    0             0      my ( $self, $opt ) = @_;
653   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
654   ***      0      0      0                    0      die "Option $opt does not exist"
655                                                         unless $long && exists $self->{opts}->{$long};
656   ***      0                                  0      return $self->{opts}->{$long}->{value};
657                                                   }
658                                                   
659                                                   sub got {
660   ***      0                    0             0      my ( $self, $opt ) = @_;
661   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
662   ***      0      0      0                    0      die "Option $opt does not exist"
663                                                         unless $long && exists $self->{opts}->{$long};
664   ***      0                                  0      return $self->{opts}->{$long}->{got};
665                                                   }
666                                                   
667                                                   sub has {
668   ***      0                    0             0      my ( $self, $opt ) = @_;
669   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
670   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
671                                                   }
672                                                   
673                                                   sub set {
674   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
675   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
676   ***      0      0      0                    0      die "Option $opt does not exist"
677                                                         unless $long && exists $self->{opts}->{$long};
678   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
679   ***      0                                  0      return;
680                                                   }
681                                                   
682                                                   sub save_error {
683   ***      0                    0             0      my ( $self, $error ) = @_;
684   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
685                                                   }
686                                                   
687                                                   sub errors {
688   ***      0                    0             0      my ( $self ) = @_;
689   ***      0                                  0      return $self->{errors};
690                                                   }
691                                                   
692                                                   sub prompt {
693   ***      0                    0             0      my ( $self ) = @_;
694   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
695                                                   }
696                                                   
697                                                   sub descr {
698   ***      0                    0             0      my ( $self ) = @_;
699   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
700                                                                 . "  For more details, please use the --help option, "
701                                                                 . "or try 'perldoc $PROGRAM_NAME' "
702                                                                 . "for complete documentation.";
703   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
704   ***      0                                  0      $descr =~ s/ +$//mg;
705   ***      0                                  0      return $descr;
706                                                   }
707                                                   
708                                                   sub usage_or_errors {
709   ***      0                    0             0      my ( $self ) = @_;
710   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
711   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
712   ***      0                                  0         exit 0;
713                                                      }
714                                                      elsif ( scalar @{$self->{errors}} ) {
715   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
716   ***      0                                  0         exit 0;
717                                                      }
718   ***      0                                  0      return;
719                                                   }
720                                                   
721                                                   sub print_errors {
722   ***      0                    0             0      my ( $self ) = @_;
723   ***      0                                  0      my $usage = $self->prompt() . "\n";
724   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
725   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
726                                                                 . "\n";
727                                                      }
728   ***      0                                  0      return $usage . "\n" . $self->descr();
729                                                   }
730                                                   
731                                                   sub print_usage {
732   ***      0                    0             0      my ( $self ) = @_;
733   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
734   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
735                                                   
736   ***      0      0                           0      my $maxl = max(
737   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
738                                                         @opts);
739                                                   
740   ***      0      0                           0      my $maxs = max(0,
741   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
742   ***      0                                  0         values %{$self->{short_opts}});
743                                                   
744   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
745   ***      0                                  0      my $rcol = 80 - $lcol - 6;
746   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
747                                                   
748   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
749                                                   
750   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
751                                                   
752   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
753   ***      0                                  0      push @groups, 'default';
754                                                   
755   ***      0                                  0      foreach my $group ( reverse @groups ) {
756   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
757   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
758   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
759                                                            grep { $_->{group} eq $group }
760                                                            @opts )
761                                                         {
762   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
763   ***      0                                  0            my $short = $opt->{short};
764   ***      0                                  0            my $desc  = $opt->{desc};
765   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
766   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
767   ***      0             0                    0               $s    ||= 's';
768   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
769   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
770                                                                      . "d=days; if no suffix, $s is used.";
771                                                            }
772   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
773   ***      0                                  0            $desc =~ s/ +$//mg;
774   ***      0      0                           0            if ( $short ) {
775   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
776                                                            }
777                                                            else {
778   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
779                                                            }
780                                                         }
781                                                      }
782                                                   
783   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
784   ***      0                                  0         $usage .= "\nRules:\n\n";
785   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
786                                                      }
787   ***      0      0                           0      if ( $self->{dp} ) {
788   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
789                                                      }
790   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
791   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
792   ***      0                                  0         my $val   = $opt->{value};
793   ***      0             0                    0         my $type  = $opt->{type} || '';
794   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
795   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
796                                                                   : !defined $val             ? '(No value)'
797                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
798                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
799                                                                   : $type =~ m/A|a/           ? join(',', @$val)
800                                                                   :                             $val;
801   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
802                                                      }
803   ***      0                                  0      return $usage;
804                                                   }
805                                                   
806                                                   sub prompt_noecho {
807   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
808   ***      0                                  0      my ( $prompt ) = @_;
809   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
810   ***      0      0                           0      print $prompt
811                                                         or die "Cannot print: $OS_ERROR";
812   ***      0                                  0      my $response;
813   ***      0                                  0      eval {
814   ***      0                                  0         require Term::ReadKey;
815   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
816   ***      0                                  0         chomp($response = <STDIN>);
817   ***      0                                  0         Term::ReadKey::ReadMode('normal');
818   ***      0      0                           0         print "\n"
819                                                            or die "Cannot print: $OS_ERROR";
820                                                      };
821   ***      0      0                           0      if ( $EVAL_ERROR ) {
822   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
823                                                      }
824   ***      0                                  0      return $response;
825                                                   }
826                                                   
827                                                   if ( MKDEBUG ) {
828                                                      print '# ', $^X, ' ', $], "\n";
829                                                      my $uname = `uname -a`;
830                                                      if ( $uname ) {
831                                                         $uname =~ s/\s+/ /g;
832                                                         print "# $uname\n";
833                                                      }
834                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
835                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
836                                                         ($main::SVN_REV || ''), __LINE__);
837                                                      print('# Arguments: ',
838                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
839                                                   }
840                                                   
841                                                   sub _read_config_file {
842   ***      0                    0             0      my ( $self, $filename ) = @_;
843   ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
844   ***      0                                  0      my @args;
845   ***      0                                  0      my $prefix = '--';
846   ***      0                                  0      my $parse  = 1;
847                                                   
848                                                      LINE:
849   ***      0                                  0      while ( my $line = <$fh> ) {
850   ***      0                                  0         chomp $line;
851   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
852   ***      0                                  0         $line =~ s/\s+#.*$//g;
853   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
854   ***      0      0                           0         if ( $line eq '--' ) {
855   ***      0                                  0            $prefix = '';
856   ***      0                                  0            $parse  = 0;
857   ***      0                                  0            next LINE;
858                                                         }
859   ***      0      0      0                    0         if ( $parse
      ***             0                               
860                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
861                                                         ) {
862   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
863                                                         }
864                                                         elsif ( $line =~ m/./ ) {
865   ***      0                                  0            push @args, $line;
866                                                         }
867                                                         else {
868   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
869                                                         }
870                                                      }
871   ***      0                                  0      close $fh;
872   ***      0                                  0      return @args;
873                                                   }
874                                                   
875                                                   sub read_para_after {
876   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
877   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
878   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
879   ***      0                                  0      my $para;
880   ***      0                                  0      while ( $para = <$fh> ) {
881   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
882   ***      0                                  0         last;
883                                                      }
884   ***      0                                  0      while ( $para = <$fh> ) {
885   ***      0      0                           0         next unless $para =~ m/$regex/;
886   ***      0                                  0         last;
887                                                      }
888   ***      0                                  0      $para = <$fh>;
889   ***      0                                  0      chomp($para);
890   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
891   ***      0                                  0      return $para;
892                                                   }
893                                                   
894                                                   sub clone {
895   ***      0                    0             0      my ( $self ) = @_;
896                                                   
897   ***      0                                  0      my %clone = map {
898   ***      0                                  0         my $hashref  = $self->{$_};
899   ***      0                                  0         my $val_copy = {};
900   ***      0                                  0         foreach my $key ( keys %$hashref ) {
901   ***      0                                  0            my $ref = ref $hashref->{$key};
902   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
903   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
904   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
905                                                                              : $hashref->{$key};
906                                                         }
907   ***      0                                  0         $_ => $val_copy;
908                                                      } qw(opts short_opts defaults);
909                                                   
910   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
911   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
912                                                      }
913                                                   
914   ***      0                                  0      return bless \%clone;     
915                                                   }
916                                                   
917                                                   sub _d {
918   ***      0                    0             0      my ($package, undef, $line) = caller 0;
919   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
920   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
921                                                           @_;
922   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
923                                                   }
924                                                   
925                                                   1;
926                                                   
927                                                   # ###########################################################################
928                                                   # End OptionParser package
929                                                   # ###########################################################################
930                                                   
931                                                   # ###########################################################################
932                                                   # VersionParser package 5266
933                                                   # ###########################################################################
934                                                   package VersionParser;
935                                                   
936            1                    1            10   use strict;
               1                                  2   
               1                                  9   
937            1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
938                                                   
939            1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
940                                                   
941   ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 14   
942                                                   
943                                                   sub new {
944   ***      0                    0             0      my ( $class ) = @_;
945   ***      0                                  0      bless {}, $class;
946                                                   }
947                                                   
948                                                   sub parse {
949   ***      0                    0             0      my ( $self, $str ) = @_;
950   ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
951   ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
952   ***      0                                  0      return $result;
953                                                   }
954                                                   
955                                                   sub version_ge {
956   ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
957   ***      0      0                           0      if ( !$self->{$dbh} ) {
958   ***      0                                  0         $self->{$dbh} = $self->parse(
959                                                            $dbh->selectrow_array('SELECT VERSION()'));
960                                                      }
961   ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
962   ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
963   ***      0                                  0      return $result;
964                                                   }
965                                                   
966                                                   sub _d {
967   ***      0                    0             0      my ($package, undef, $line) = caller 0;
968   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
969   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
970                                                           @_;
971   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
972                                                   }
973                                                   
974                                                   1;
975                                                   
976                                                   # ###########################################################################
977                                                   # End VersionParser package
978                                                   # ###########################################################################
979                                                   
980                                                   # ###########################################################################
981                                                   # DSNParser package 5266
982                                                   # ###########################################################################
983                                                   package DSNParser;
984                                                   
985            1                    1             7   use strict;
               1                                  3   
               1                                  8   
986            1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
987            1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
988            1                    1             7   use Data::Dumper;
               1                                  3   
               1                                  8   
989                                                   $Data::Dumper::Indent    = 0;
990                                                   $Data::Dumper::Quotekeys = 0;
991                                                   
992                                                   eval {
993                                                      require DBI;
994                                                   };
995                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
996                                                   
997   ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 18   
998                                                   
999                                                   sub new {
1000           1                    1             4      my ( $class, @opts ) = @_;
1001           1                                 26      my $self = {
1002                                                        opts => {
1003                                                           A => {
1004                                                              desc => 'Default character set',
1005                                                              dsn  => 'charset',
1006                                                              copy => 1,
1007                                                           },
1008                                                           D => {
1009                                                              desc => 'Database to use',
1010                                                              dsn  => 'database',
1011                                                              copy => 1,
1012                                                           },
1013                                                           F => {
1014                                                              desc => 'Only read default options from the given file',
1015                                                              dsn  => 'mysql_read_default_file',
1016                                                              copy => 1,
1017                                                           },
1018                                                           h => {
1019                                                              desc => 'Connect to host',
1020                                                              dsn  => 'host',
1021                                                              copy => 1,
1022                                                           },
1023                                                           p => {
1024                                                              desc => 'Password to use when connecting',
1025                                                              dsn  => 'password',
1026                                                              copy => 1,
1027                                                           },
1028                                                           P => {
1029                                                              desc => 'Port number to use for connection',
1030                                                              dsn  => 'port',
1031                                                              copy => 1,
1032                                                           },
1033                                                           S => {
1034                                                              desc => 'Socket file to use for connection',
1035                                                              dsn  => 'mysql_socket',
1036                                                              copy => 1,
1037                                                           },
1038                                                           u => {
1039                                                              desc => 'User for login if not current user',
1040                                                              dsn  => 'user',
1041                                                              copy => 1,
1042                                                           },
1043                                                        },
1044                                                     };
1045           1                                  4      foreach my $opt ( @opts ) {
1046  ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
1047  ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1048                                                     }
1049           1                                 15      return bless $self, $class;
1050                                                  }
1051                                                  
1052                                                  sub prop {
1053           6                    6            28      my ( $self, $prop, $value ) = @_;
1054  ***      6     50                          27      if ( @_ > 2 ) {
1055  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1056  ***      0                                  0         $self->{$prop} = $value;
1057                                                     }
1058           6                                 42      return $self->{$prop};
1059                                                  }
1060                                                  
1061                                                  sub parse {
1062           2                    2            88      my ( $self, $dsn, $prev, $defaults ) = @_;
1063  ***      2     50                          10      if ( !$dsn ) {
1064  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1065  ***      0                                  0         return;
1066                                                     }
1067           2                                  4      MKDEBUG && _d('Parsing', $dsn);
1068  ***      2            50                   10      $prev     ||= {};
1069  ***      2            50                    9      $defaults ||= {};
1070           2                                  5      my %given_props;
1071           2                                  6      my %final_props;
1072           2                                  6      my %opts = %{$self->{opts}};
               2                                 22   
1073                                                  
1074           2                                 18      foreach my $dsn_part ( split(/,/, $dsn) ) {
1075  ***      8     50                          68         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1076           8                                 36            $given_props{$prop_key} = $prop_val;
1077                                                        }
1078                                                        else {
1079  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1080  ***      0                                  0            $given_props{h} = $dsn_part;
1081                                                        }
1082                                                     }
1083                                                  
1084           2                                 11      foreach my $key ( keys %opts ) {
1085          16                                 33         MKDEBUG && _d('Finding value for', $key);
1086          16                                 54         $final_props{$key} = $given_props{$key};
1087  ***     16     50     66                  124         if (   !defined $final_props{$key}
      ***                   33                        
1088                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1089                                                        {
1090  ***      0                                  0            $final_props{$key} = $prev->{$key};
1091  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1092                                                        }
1093          16    100                          67         if ( !defined $final_props{$key} ) {
1094           8                                 25            $final_props{$key} = $defaults->{$key};
1095           8                                 22            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1096                                                        }
1097                                                     }
1098                                                  
1099           2                                 10      foreach my $key ( keys %given_props ) {
1100  ***      8     50                          34         die "Unrecognized DSN part '$key' in '$dsn'\n"
1101                                                           unless exists $opts{$key};
1102                                                     }
1103  ***      2     50                          11      if ( (my $required = $self->prop('required')) ) {
1104  ***      0                                  0         foreach my $key ( keys %$required ) {
1105  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1106                                                        }
1107                                                     }
1108                                                  
1109           2                                 14      return \%final_props;
1110                                                  }
1111                                                  
1112                                                  sub parse_options {
1113  ***      0                    0             0      my ( $self, $o ) = @_;
1114  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1115  ***      0                                  0      my $dsn_string
1116                                                        = join(',',
1117  ***      0      0                           0             map  { "$_=".$o->get($_); }
1118  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1119  ***      0                                  0             keys %{$self->{opts}}
1120                                                          );
1121  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1122  ***      0                                  0      return $self->parse($dsn_string);
1123                                                  }
1124                                                  
1125                                                  sub as_string {
1126  ***      0                    0             0      my ( $self, $dsn ) = @_;
1127  ***      0      0                           0      return $dsn unless ref $dsn;
1128  ***      0      0                           0      return join(',',
1129  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1130  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1131                                                        sort keys %$dsn );
1132                                                  }
1133                                                  
1134                                                  sub usage {
1135  ***      0                    0             0      my ( $self ) = @_;
1136  ***      0                                  0      my $usage
1137                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1138                                                        . "  KEY  COPY  MEANING\n"
1139                                                        . "  ===  ====  =============================================\n";
1140  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1141  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1142  ***      0      0      0                    0         $usage .= "  $key    "
1143                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1144                                                               .  ($opts{$key}->{desc} || '[No description]')
1145                                                               . "\n";
1146                                                     }
1147  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1148  ***      0                                  0      return $usage;
1149                                                  }
1150                                                  
1151                                                  sub get_cxn_params {
1152           2                    2            24      my ( $self, $info ) = @_;
1153           2                                  6      my $dsn;
1154           2                                  5      my %opts = %{$self->{opts}};
               2                                 16   
1155  ***      2            50                    9      my $driver = $self->prop('dbidriver') || '';
1156  ***      2     50                          11      if ( $driver eq 'Pg' ) {
1157  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1158  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1159  ***      0             0                    0                        grep { defined $info->{$_} }
1160                                                                       qw(h P));
1161                                                     }
1162                                                     else {
1163           4                                 29         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1164          10                                 38            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1165  ***      2            50                   24                        grep { defined $info->{$_} }
1166                                                                       qw(F h P S A))
1167                                                           . ';mysql_read_default_group=client';
1168                                                     }
1169           2                                  6      MKDEBUG && _d($dsn);
1170           2                                 17      return ($dsn, $info->{u}, $info->{p});
1171                                                  }
1172                                                  
1173                                                  sub fill_in_dsn {
1174  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1175  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1176  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1177  ***      0                                  0      $user =~ s/@.*//;
1178  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1179  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1180  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1181  ***      0             0                    0      $dsn->{u} ||= $user;
1182  ***      0             0                    0      $dsn->{D} ||= $db;
1183                                                  }
1184                                                  
1185                                                  sub get_dbh {
1186           2                    2            12      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1187  ***      2            50                    9      $opts ||= {};
1188  ***      2     50                          20      my $defaults = {
1189                                                        AutoCommit         => 0,
1190                                                        RaiseError         => 1,
1191                                                        PrintError         => 0,
1192                                                        ShowErrorStatement => 1,
1193                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1194                                                     };
1195           2                                 10      @{$defaults}{ keys %$opts } = values %$opts;
               2                                  8   
1196                                                  
1197  ***      2     50                          10      if ( !$have_dbi ) {
1198  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1199                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1200                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1201                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1202                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1203                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1204                                                  
1205                                                     }
1206                                                  
1207           2                                  4      my $dbh;
1208           2                                  6      my $tries = 2;
1209  ***      2            66                   18      while ( !$dbh && $tries-- ) {
1210                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1211           2                                  4            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1212                                                  
1213           2                                  7         eval {
1214           2                                 12            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1215                                                  
1216  ***      2     50                          20            if ( $cxn_string =~ m/mysql/i ) {
1217           2                                  6               my $sql;
1218                                                  
1219           2                                 10               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1220                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1221           2                                  4               MKDEBUG && _d($dbh, ':', $sql);
1222           2                                233               $dbh->do($sql);
1223                                                  
1224  ***      2     50                          17               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1225  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1226  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1227  ***      0                                  0                  $dbh->do($sql);
1228  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1229  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1230  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1231                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1232                                                                 }
1233                                                                 else {
1234  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1235                                                                 }
1236                                                              }
1237                                                  
1238  ***      2     50                          14               if ( $self->prop('set-vars') ) {
1239  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1240  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1241  ***      0                                  0                  $dbh->do($sql);
1242                                                              }
1243                                                           }
1244                                                        };
1245  ***      2     50     33                   20         if ( !$dbh && $EVAL_ERROR ) {
1246  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1247  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1248  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1249  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1250                                                           }
1251                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1252  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1253                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1254                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1255                                                                 . "DBD::mysql is not installed, try:\n"
1256                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1257                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1258                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1259                                                           }
1260  ***      0      0                           0            if ( !$tries ) {
1261  ***      0                                  0               die $EVAL_ERROR;
1262                                                           }
1263                                                        }
1264                                                     }
1265                                                  
1266           2                                  5      MKDEBUG && _d('DBH info: ',
1267                                                        $dbh,
1268                                                        Dumper($dbh->selectrow_hashref(
1269                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1270                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1271                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1272                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1273                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1274                                                        '$DBI::VERSION:',        $DBI::VERSION,
1275                                                     );
1276                                                  
1277           2                                 13      return $dbh;
1278                                                  }
1279                                                  
1280                                                  sub get_hostname {
1281  ***      0                    0                    my ( $self, $dbh ) = @_;
1282  ***      0      0      0                           if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1283  ***      0                                            return $host;
1284                                                     }
1285  ***      0                                         my ( $hostname, $one ) = $dbh->selectrow_array(
1286                                                        'SELECT /*!50038 @@hostname, */ 1');
1287  ***      0                                         return $hostname;
1288                                                  }
1289                                                  
1290                                                  sub disconnect {
1291  ***      0                    0                    my ( $self, $dbh ) = @_;
1292  ***      0                                         MKDEBUG && $self->print_active_handles($dbh);
1293  ***      0                                         $dbh->disconnect;
1294                                                  }
1295                                                  
1296                                                  sub print_active_handles {
1297  ***      0                    0                    my ( $self, $thing, $level ) = @_;
1298  ***      0             0                           $level ||= 0;
1299  ***      0      0      0                           printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1300                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1301                                                        or die "Cannot print: $OS_ERROR";
1302  ***      0                                         foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                      
      ***      0                                      
1303  ***      0                                            $self->print_active_handles( $handle, $level + 1 );
1304                                                     }
1305                                                  }
1306                                                  
1307                                                  sub copy {
1308  ***      0                    0                    my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1309  ***      0      0                                  die 'I need a dsn_1 argument' unless $dsn_1;
1310  ***      0      0                                  die 'I need a dsn_2 argument' unless $dsn_2;
1311  ***      0                                         my %new_dsn = map {
1312  ***      0                                            my $key = $_;
1313  ***      0                                            my $val;
1314  ***      0      0                                     if ( $args{overwrite} ) {
1315  ***      0      0                                        $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1316                                                        }
1317                                                        else {
1318  ***      0      0                                        $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1319                                                        }
1320  ***      0                                            $key => $val;
1321  ***      0                                         } keys %{$self->{opts}};
1322  ***      0                                         return \%new_dsn;
1323                                                  }
1324                                                  
1325                                                  sub _d {
1326  ***      0                    0                    my ($package, undef, $line) = caller 0;
1327  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1328  ***      0                                              map { defined $_ ? $_ : 'undef' }
1329                                                          @_;
1330  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1331                                                  }
1332                                                  
1333                                                  1;
1334                                                  
1335                                                  # ###########################################################################
1336                                                  # End DSNParser package
1337                                                  # ###########################################################################
1338                                                  
1339                                                  # ###########################################################################
1340                                                  # MasterSlave package 5362
1341                                                  # ###########################################################################
1342           1                    1             9   use strict;
               1                                  2   
               1                                  6   
1343           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  4   
1344                                                  
1345                                                  package MasterSlave;
1346                                                  
1347           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
1348           1                    1             7   use List::Util qw(min max);
               1                                244   
               1                                  7   
1349           1                    1             7   use Data::Dumper;
               1                                  2   
               1                                  4   
1350                                                  $Data::Dumper::Quotekeys = 0;
1351                                                  $Data::Dumper::Indent    = 0;
1352                                                  
1353  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 15   
1354                                                  
1355                                                  sub new {
1356  ***      0                    0                    bless {}, shift;
1357                                                  }
1358                                                  
1359                                                  sub recurse_to_slaves {
1360  ***      0                    0                    my ( $self, $args, $level ) = @_;
1361  ***      0             0                           $level ||= 0;
1362  ***      0                                         my $dp   = $args->{dsn_parser};
1363  ***      0                                         my $dsn  = $args->{dsn};
1364                                                  
1365  ***      0                                         my $dbh;
1366  ***      0                                         eval {
1367  ***      0             0                              $dbh = $args->{dbh} || $dp->get_dbh(
1368                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
1369  ***      0                                            MKDEBUG && _d('Connected to', $dp->as_string($dsn));
1370                                                     };
1371  ***      0      0                                  if ( $EVAL_ERROR ) {
1372  ***      0      0                                     print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
1373                                                           or die "Cannot print: $OS_ERROR";
1374  ***      0                                            return;
1375                                                     }
1376                                                  
1377  ***      0                                         my $sql  = 'SELECT @@SERVER_ID';
1378  ***      0                                         MKDEBUG && _d($sql);
1379  ***      0                                         my ($id) = $dbh->selectrow_array($sql);
1380  ***      0                                         MKDEBUG && _d('Working on server ID', $id);
1381  ***      0                                         my $master_thinks_i_am = $dsn->{server_id};
1382  ***      0      0      0                           if ( !defined $id
      ***                    0                        
      ***                    0                        
1383                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
1384                                                         || $args->{server_ids_seen}->{$id}++
1385                                                     ) {
1386  ***      0                                            MKDEBUG && _d('Server ID seen, or not what master said');
1387  ***      0      0                                     if ( $args->{skip_callback} ) {
1388  ***      0                                               $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
1389                                                        }
1390  ***      0                                            return;
1391                                                     }
1392                                                  
1393  ***      0                                         $args->{callback}->($dsn, $dbh, $level, $args->{parent});
1394                                                  
1395  ***      0      0      0                           if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
1396                                                  
1397  ***      0      0                                     my @slaves =
1398  ***      0                                               grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
1399                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
1400                                                  
1401  ***      0                                            foreach my $slave ( @slaves ) {
1402  ***      0                                               MKDEBUG && _d('Recursing from',
1403                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
1404  ***      0                                               $self->recurse_to_slaves(
1405                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
1406                                                        }
1407                                                     }
1408                                                  }
1409                                                  
1410                                                  sub find_slave_hosts {
1411  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
1412                                                  
1413  ***      0                                         my @methods = qw(processlist hosts);
1414  ***      0      0                                  if ( $method ) {
1415  ***      0                                            @methods = grep { $_ ne $method } @methods;
      ***      0                                      
1416  ***      0                                            unshift @methods, $method;
1417                                                     }
1418                                                     else {
1419  ***      0      0      0                              if ( ($dsn->{P} || 3306) != 3306 ) {
1420  ***      0                                               MKDEBUG && _d('Port number is non-standard; using only hosts method');
1421  ***      0                                               @methods = qw(hosts);
1422                                                        }
1423                                                     }
1424  ***      0                                         MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
1425                                                        'using methods', @methods);
1426                                                  
1427  ***      0                                         my @slaves;
1428                                                     METHOD:
1429  ***      0                                         foreach my $method ( @methods ) {
1430  ***      0                                            my $find_slaves = "_find_slaves_by_$method";
1431  ***      0                                            MKDEBUG && _d('Finding slaves with', $find_slaves);
1432  ***      0                                            @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
1433  ***      0      0                                     last METHOD if @slaves;
1434                                                     }
1435                                                  
1436  ***      0                                         MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
1437  ***      0                                         return @slaves;
1438                                                  }
1439                                                  
1440                                                  sub _find_slaves_by_processlist {
1441  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
1442                                                  
1443  ***      0                                         my @slaves = map  {
1444  ***      0                                            my $slave        = $dsn_parser->parse("h=$_", $dsn);
1445  ***      0                                            $slave->{source} = 'processlist';
1446  ***      0                                            $slave;
1447                                                     }
1448  ***      0                                         grep { $_ }
1449                                                     map  {
1450  ***      0                                            my ( $host ) = $_->{host} =~ m/^([^:]+):/;
1451  ***      0      0                                     if ( $host eq 'localhost' ) {
1452  ***      0                                               $host = '127.0.0.1'; # Replication never uses sockets.
1453                                                        }
1454  ***      0                                            $host;
1455                                                     } $self->get_connected_slaves($dbh);
1456                                                  
1457  ***      0                                         return @slaves;
1458                                                  }
1459                                                  
1460                                                  sub _find_slaves_by_hosts {
1461  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
1462                                                  
1463  ***      0                                         my @slaves;
1464  ***      0                                         my $sql = 'SHOW SLAVE HOSTS';
1465  ***      0                                         MKDEBUG && _d($dbh, $sql);
1466  ***      0                                         @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                      
1467                                                  
1468  ***      0      0                                  if ( @slaves ) {
1469  ***      0                                            MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
1470  ***      0                                            @slaves = map {
1471  ***      0                                               my %hash;
1472  ***      0                                               @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
1473  ***      0      0                                        my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
1474                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
1475                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
1476  ***      0                                               my $dsn           = $dsn_parser->parse($spec, $dsn);
1477  ***      0                                               $dsn->{server_id} = $hash{server_id};
1478  ***      0                                               $dsn->{master_id} = $hash{master_id};
1479  ***      0                                               $dsn->{source}    = 'hosts';
1480  ***      0                                               $dsn;
1481                                                        } @slaves;
1482                                                     }
1483                                                  
1484  ***      0                                         return @slaves;
1485                                                  }
1486                                                  
1487                                                  sub get_connected_slaves {
1488  ***      0                    0                    my ( $self, $dbh ) = @_;
1489                                                  
1490  ***      0                                         my $proc =
1491  ***      0                                            grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
1492  ***      0                                            @{$dbh->selectcol_arrayref('SHOW GRANTS')};
1493  ***      0      0                                  if ( !$proc ) {
1494  ***      0                                            die "You do not have the PROCESS privilege";
1495                                                     }
1496                                                  
1497  ***      0                                         my $sql = 'SHOW PROCESSLIST';
1498  ***      0                                         MKDEBUG && _d($dbh, $sql);
1499  ***      0                                         grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                      
1500                                                     map  { # Lowercase the column names
1501  ***      0                                            my %hash;
1502  ***      0                                            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
1503  ***      0                                            \%hash;
1504                                                     }
1505  ***      0                                         @{$dbh->selectall_arrayref($sql, { Slice => {} })};
1506                                                  }
1507                                                  
1508                                                  sub is_master_of {
1509  ***      0                    0                    my ( $self, $master, $slave ) = @_;
1510  ***      0      0                                  my $master_status = $self->get_master_status($master)
1511                                                        or die "The server specified as a master is not a master";
1512  ***      0      0                                  my $slave_status  = $self->get_slave_status($slave)
1513                                                        or die "The server specified as a slave is not a slave";
1514  ***      0      0                                  my @connected     = $self->get_connected_slaves($master)
1515                                                        or die "The server specified as a master has no connected slaves";
1516  ***      0                                         my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
1517                                                  
1518  ***      0      0                                  if ( $port != $slave_status->{master_port} ) {
1519  ***      0                                            die "The slave is connected to $slave_status->{master_port} "
1520                                                           . "but the master's port is $port";
1521                                                     }
1522                                                  
1523  ***      0      0                                  if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                      
1524  ***      0                                            die "I don't see any slave I/O thread connected with user "
1525                                                           . $slave_status->{master_user};
1526                                                     }
1527                                                  
1528  ***      0      0      0                           if ( ($slave_status->{slave_io_state} || '')
1529                                                        eq 'Waiting for master to send event' )
1530                                                     {
1531  ***      0                                            my ( $master_log_name, $master_log_num )
1532                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
1533  ***      0                                            my ( $slave_log_name, $slave_log_num )
1534                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
1535  ***      0      0      0                              if ( $master_log_name ne $slave_log_name
1536                                                           || abs($master_log_num - $slave_log_num) > 1 )
1537                                                        {
1538  ***      0                                               die "The slave thinks it is reading from "
1539                                                              . "$slave_status->{master_log_file},  but the "
1540                                                              . "master is writing to $master_status->{file}";
1541                                                        }
1542                                                     }
1543  ***      0                                         return 1;
1544                                                  }
1545                                                  
1546                                                  sub get_master_dsn {
1547  ***      0                    0                    my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
1548  ***      0      0                                  my $master = $self->get_slave_status($dbh) or return undef;
1549  ***      0                                         my $spec   = "h=$master->{master_host},P=$master->{master_port}";
1550  ***      0                                         return       $dsn_parser->parse($spec, $dsn);
1551                                                  }
1552                                                  
1553                                                  sub get_slave_status {
1554  ***      0                    0                    my ( $self, $dbh ) = @_;
1555  ***      0      0                                  if ( !$self->{not_a_slave}->{$dbh} ) {
1556  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
1557                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
1558  ***      0                                            MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
1559  ***      0                                            $sth->execute();
1560  ***      0                                            my ($ss) = @{$sth->fetchall_arrayref({})};
      ***      0                                      
1561                                                  
1562  ***      0      0      0                              if ( $ss && %$ss ) {
1563  ***      0                                               $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
      ***      0                                      
1564  ***      0                                               return $ss;
1565                                                        }
1566                                                  
1567  ***      0                                            MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
1568  ***      0                                            $self->{not_a_slave}->{$dbh}++;
1569                                                     }
1570                                                  }
1571                                                  
1572                                                  sub get_master_status {
1573  ***      0                    0                    my ( $self, $dbh ) = @_;
1574  ***      0      0                                  if ( !$self->{not_a_master}->{$dbh} ) {
1575  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
1576                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
1577  ***      0                                            MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
1578  ***      0                                            $sth->execute();
1579  ***      0                                            my ($ms) = @{$sth->fetchall_arrayref({})};
      ***      0                                      
1580                                                  
1581  ***      0      0      0                              if ( $ms && %$ms ) {
1582  ***      0                                               $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
      ***      0                                      
1583  ***      0      0      0                                 if ( $ms->{file} && $ms->{position} ) {
1584  ***      0                                                  return $ms;
1585                                                           }
1586                                                        }
1587                                                  
1588  ***      0                                            MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
1589  ***      0                                            $self->{not_a_master}->{$dbh}++;
1590                                                     }
1591                                                  }
1592                                                  
1593                                                  sub wait_for_master {
1594  ***      0                    0                    my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
1595  ***      0                                         my $result;
1596  ***      0      0                                  $time = 60 unless defined $time;
1597  ***      0                                         MKDEBUG && _d('Waiting for slave to catch up to master timeout ok:',
1598                                                        $timeoutok);
1599  ***      0             0                           $ms ||= $self->get_master_status($master);
1600  ***      0      0                                  if ( $ms ) {
1601  ***      0                                            my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
1602  ***      0                                            MKDEBUG && _d($slave, $query);
1603  ***      0                                            ($result) = $slave->selectrow_array($query);
1604  ***      0      0                                     my $stat = defined $result ? $result : 'NULL';
1605  ***      0                                            MKDEBUG && _d('Result of waiting:', $stat);
1606  ***      0      0      0                              if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                    0                        
1607  ***      0                                               die "MASTER_POS_WAIT returned $stat";
1608                                                        }
1609                                                     }
1610                                                     else {
1611  ***      0                                            MKDEBUG && _d('Not waiting: this server is not a master');
1612                                                     }
1613  ***      0                                         return $result;
1614                                                  }
1615                                                  
1616                                                  sub stop_slave {
1617  ***      0                    0                    my ( $self, $dbh ) = @_;
1618  ***      0             0                           my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
1619                                                           ||= $dbh->prepare('STOP SLAVE');
1620  ***      0                                         MKDEBUG && _d($dbh, $sth->{Statement});
1621  ***      0                                         $sth->execute();
1622                                                  }
1623                                                  
1624                                                  sub start_slave {
1625  ***      0                    0                    my ( $self, $dbh, $pos ) = @_;
1626  ***      0      0                                  if ( $pos ) {
1627  ***      0                                            my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
1628                                                                . "MASTER_LOG_POS=$pos->{position}";
1629  ***      0                                            MKDEBUG && _d($dbh, $sql);
1630  ***      0                                            $dbh->do($sql);
1631                                                     }
1632                                                     else {
1633  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
1634                                                              ||= $dbh->prepare('START SLAVE');
1635  ***      0                                            MKDEBUG && _d($dbh, $sth->{Statement});
1636  ***      0                                            $sth->execute();
1637                                                     }
1638                                                  }
1639                                                  
1640                                                  sub catchup_to_master {
1641  ***      0                    0                    my ( $self, $slave, $master, $time ) = @_;
1642  ***      0                                         $self->stop_slave($master);
1643  ***      0                                         $self->stop_slave($slave);
1644  ***      0                                         my $slave_status  = $self->get_slave_status($slave);
1645  ***      0                                         my $slave_pos     = $self->repl_posn($slave_status);
1646  ***      0                                         my $master_status = $self->get_master_status($master);
1647  ***      0                                         my $master_pos    = $self->repl_posn($master_status);
1648  ***      0                                         MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
1649                                                        'Slave position:', $self->pos_to_string($slave_pos));
1650  ***      0      0                                  if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
1651  ***      0                                            MKDEBUG && _d('Waiting for slave to catch up to master');
1652  ***      0                                            $self->start_slave($slave, $master_pos);
1653  ***      0                                            eval {
1654  ***      0                                               $self->wait_for_master($master, $slave, $time, 0, $master_status);
1655                                                        };
1656  ***      0      0                                     if ( $EVAL_ERROR ) {
1657  ***      0                                               MKDEBUG && _d($EVAL_ERROR);
1658  ***      0      0                                        if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
1659  ***      0                                                  $slave_status = $self->get_slave_status($slave);
1660  ***      0      0                                           if ( !$self->slave_is_running($slave_status) ) {
1661  ***      0                                                     MKDEBUG && _d('Master position:',
1662                                                                    $self->pos_to_string($master_pos),
1663                                                                    'Slave position:', $self->pos_to_string($slave_pos));
1664  ***      0                                                     $slave_pos = $self->repl_posn($slave_status);
1665  ***      0      0                                              if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
1666  ***      0                                                        die "$EVAL_ERROR but slave has not caught up to master";
1667                                                                 }
1668  ***      0                                                     MKDEBUG && _d('Slave is caught up to master and stopped');
1669                                                              }
1670                                                              else {
1671  ***      0                                                     die "$EVAL_ERROR but slave was still running";
1672                                                              }
1673                                                           }
1674                                                           else {
1675  ***      0                                                  die $EVAL_ERROR;
1676                                                           }
1677                                                        }
1678                                                     }
1679                                                  }
1680                                                  
1681                                                  sub catchup_to_same_pos {
1682  ***      0                    0                    my ( $self, $s1_dbh, $s2_dbh ) = @_;
1683  ***      0                                         $self->stop_slave($s1_dbh);
1684  ***      0                                         $self->stop_slave($s2_dbh);
1685  ***      0                                         my $s1_status = $self->get_slave_status($s1_dbh);
1686  ***      0                                         my $s2_status = $self->get_slave_status($s2_dbh);
1687  ***      0                                         my $s1_pos    = $self->repl_posn($s1_status);
1688  ***      0                                         my $s2_pos    = $self->repl_posn($s2_status);
1689  ***      0      0                                  if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
1690  ***      0                                            $self->start_slave($s1_dbh, $s2_pos);
1691                                                     }
1692                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
1693  ***      0                                            $self->start_slave($s2_dbh, $s1_pos);
1694                                                     }
1695                                                  
1696  ***      0                                         $s1_status = $self->get_slave_status($s1_dbh);
1697  ***      0                                         $s2_status = $self->get_slave_status($s2_dbh);
1698  ***      0                                         $s1_pos    = $self->repl_posn($s1_status);
1699  ***      0                                         $s2_pos    = $self->repl_posn($s2_status);
1700                                                  
1701  ***      0      0      0                           if ( $self->slave_is_running($s1_status)
      ***                    0                        
1702                                                       || $self->slave_is_running($s2_status)
1703                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
1704                                                     {
1705  ***      0                                            die "The servers aren't both stopped at the same position";
1706                                                     }
1707                                                  
1708                                                  }
1709                                                  
1710                                                  sub change_master_to {
1711  ***      0                    0                    my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
1712  ***      0                                         $self->stop_slave($dbh);
1713  ***      0                                         MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
1714  ***      0                                         my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
1715                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
1716                                                        . "MASTER_LOG_POS=$master_pos->{position}";
1717  ***      0                                         MKDEBUG && _d($dbh, $sql);
1718  ***      0                                         $dbh->do($sql);
1719                                                  }
1720                                                  
1721                                                  sub make_sibling_of_master {
1722  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
1723                                                  
1724  ***      0      0                                  my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1725                                                        or die "This server is not a slave";
1726  ***      0                                         my $master_dbh  = $dsn_parser->get_dbh(
1727                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
1728  ***      0      0                                  my $gmaster_dsn
1729                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1730                                                        or die "This server's master is not a slave";
1731  ***      0                                         my $gmaster_dbh = $dsn_parser->get_dbh(
1732                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
1733  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
1734  ***      0                                            die "The slave's master's master is the slave: master-master replication";
1735                                                     }
1736                                                  
1737  ***      0                                         $self->stop_slave($master_dbh);
1738  ***      0                                         $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
1739  ***      0                                         $self->stop_slave($slave_dbh);
1740                                                  
1741  ***      0                                         my $master_status = $self->get_master_status($master_dbh);
1742  ***      0                                         my $mslave_status = $self->get_slave_status($master_dbh);
1743  ***      0                                         my $slave_status  = $self->get_slave_status($slave_dbh);
1744  ***      0                                         my $master_pos    = $self->repl_posn($master_status);
1745  ***      0                                         my $slave_pos     = $self->repl_posn($slave_status);
1746                                                  
1747  ***      0      0      0                           if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
1748                                                       && !$self->slave_is_running($slave_status)
1749                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
1750                                                     {
1751  ***      0                                            $self->change_master_to($slave_dbh, $gmaster_dsn,
1752                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
1753                                                     }
1754                                                     else {
1755  ***      0                                            die "The servers aren't both stopped at the same position";
1756                                                     }
1757                                                  
1758  ***      0                                         $mslave_status = $self->get_slave_status($master_dbh);
1759  ***      0                                         $slave_status  = $self->get_slave_status($slave_dbh);
1760  ***      0                                         my $mslave_pos = $self->repl_posn($mslave_status);
1761  ***      0                                         $slave_pos     = $self->repl_posn($slave_status);
1762  ***      0      0      0                           if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
1763                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
1764                                                     {
1765  ***      0                                            die "The servers don't have the same master/position after the change";
1766                                                     }
1767                                                  }
1768                                                  
1769                                                  sub make_slave_of_sibling {
1770  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
1771                                                          $dsn_parser, $timeout) = @_;
1772                                                  
1773  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
1774  ***      0                                            die "You are trying to make the slave a slave of itself";
1775                                                     }
1776                                                  
1777  ***      0      0                                  my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1778                                                        or die "This server is not a slave";
1779  ***      0                                         my $master_dbh1 = $dsn_parser->get_dbh(
1780                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
1781  ***      0      0                                  my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1782                                                        or die "The sibling is not a slave";
1783  ***      0      0                                  if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
1784  ***      0                                            die "This server isn't a sibling of the slave";
1785                                                     }
1786  ***      0      0                                  my $sib_master_stat = $self->get_master_status($sib_dbh)
1787                                                        or die "Binary logging is not enabled on the sibling";
1788  ***      0      0                                  die "The log_slave_updates option is not enabled on the sibling"
1789                                                        unless $self->has_slave_updates($sib_dbh);
1790                                                  
1791  ***      0                                         $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
1792                                                  
1793  ***      0                                         $sib_master_stat = $self->get_master_status($sib_dbh);
1794  ***      0                                         $self->change_master_to($slave_dbh, $sib_dsn,
1795                                                           $self->repl_posn($sib_master_stat));
1796                                                  
1797  ***      0                                         my $slave_status = $self->get_slave_status($slave_dbh);
1798  ***      0                                         my $slave_pos    = $self->repl_posn($slave_status);
1799  ***      0                                         $sib_master_stat = $self->get_master_status($sib_dbh);
1800  ***      0      0      0                           if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
1801                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
1802                                                     {
1803  ***      0                                            die "After changing the slave's master, it isn't a slave of the sibling, "
1804                                                           . "or it has a different replication position than the sibling";
1805                                                     }
1806                                                  }
1807                                                  
1808                                                  sub make_slave_of_uncle {
1809  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
1810                                                          $dsn_parser, $timeout) = @_;
1811                                                  
1812  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
1813  ***      0                                            die "You are trying to make the slave a slave of itself";
1814                                                     }
1815                                                  
1816  ***      0      0                                  my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1817                                                        or die "This server is not a slave";
1818  ***      0                                         my $master_dbh = $dsn_parser->get_dbh(
1819                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
1820  ***      0      0                                  my $gmaster_dsn
1821                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1822                                                        or die "The master is not a slave";
1823  ***      0      0                                  my $unc_master_dsn
1824                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
1825                                                        or die "The uncle is not a slave";
1826  ***      0      0                                  if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
1827  ***      0                                            die "The uncle isn't really the slave's uncle";
1828                                                     }
1829                                                  
1830  ***      0      0                                  my $unc_master_stat = $self->get_master_status($unc_dbh)
1831                                                        or die "Binary logging is not enabled on the uncle";
1832  ***      0      0                                  die "The log_slave_updates option is not enabled on the uncle"
1833                                                        unless $self->has_slave_updates($unc_dbh);
1834                                                  
1835  ***      0                                         $self->catchup_to_same_pos($master_dbh, $unc_dbh);
1836  ***      0                                         $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
1837                                                  
1838  ***      0                                         my $slave_status  = $self->get_slave_status($slave_dbh);
1839  ***      0                                         my $master_status = $self->get_master_status($master_dbh);
1840  ***      0      0                                  if ( $self->pos_cmp(
1841                                                           $self->repl_posn($slave_status),
1842                                                           $self->repl_posn($master_status)) != 0 )
1843                                                     {
1844  ***      0                                            die "The slave is not caught up to its master";
1845                                                     }
1846                                                  
1847  ***      0                                         $unc_master_stat = $self->get_master_status($unc_dbh);
1848  ***      0                                         $self->change_master_to($slave_dbh, $unc_dsn,
1849                                                        $self->repl_posn($unc_master_stat));
1850                                                  
1851                                                  
1852  ***      0                                         $slave_status    = $self->get_slave_status($slave_dbh);
1853  ***      0                                         my $slave_pos    = $self->repl_posn($slave_status);
1854  ***      0      0      0                           if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
1855                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
1856                                                     {
1857  ***      0                                            die "After changing the slave's master, it isn't a slave of the uncle, "
1858                                                           . "or it has a different replication position than the uncle";
1859                                                     }
1860                                                  }
1861                                                  
1862                                                  sub detach_slave {
1863  ***      0                    0                    my ( $self, $dbh ) = @_;
1864  ***      0                                         $self->stop_slave($dbh);
1865  ***      0      0                                  my $stat = $self->get_slave_status($dbh)
1866                                                        or die "This server is not a slave";
1867  ***      0                                         $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
1868  ***      0                                         $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
1869  ***      0                                         return $stat;
1870                                                  }
1871                                                  
1872                                                  sub slave_is_running {
1873  ***      0                    0                    my ( $self, $slave_status ) = @_;
1874  ***      0             0                           return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
1875                                                  }
1876                                                  
1877                                                  sub has_slave_updates {
1878  ***      0                    0                    my ( $self, $dbh ) = @_;
1879  ***      0                                         my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
1880  ***      0                                         MKDEBUG && _d($dbh, $sql);
1881  ***      0                                         my ($name, $value) = $dbh->selectrow_array($sql);
1882  ***      0             0                           return $value && $value =~ m/^(1|ON)$/;
1883                                                  }
1884                                                  
1885                                                  sub repl_posn {
1886  ***      0                    0                    my ( $self, $status ) = @_;
1887  ***      0      0      0                           if ( exists $status->{file} && exists $status->{position} ) {
1888                                                        return {
1889  ***      0                                               file     => $status->{file},
1890                                                           position => $status->{position},
1891                                                        };
1892                                                     }
1893                                                     else {
1894                                                        return {
1895  ***      0                                               file     => $status->{relay_master_log_file},
1896                                                           position => $status->{exec_master_log_pos},
1897                                                        };
1898                                                     }
1899                                                  }
1900                                                  
1901                                                  sub get_slave_lag {
1902  ***      0                    0                    my ( $self, $dbh ) = @_;
1903  ***      0                                         my $stat = $self->get_slave_status($dbh);
1904  ***      0                                         return $stat->{seconds_behind_master};
1905                                                  }
1906                                                  
1907                                                  sub pos_cmp {
1908  ***      0                    0                    my ( $self, $a, $b ) = @_;
1909  ***      0                                         return $self->pos_to_string($a) cmp $self->pos_to_string($b);
1910                                                  }
1911                                                  
1912                                                  sub short_host {
1913  ***      0                    0                    my ( $self, $dsn ) = @_;
1914  ***      0                                         my ($host, $port);
1915  ***      0      0                                  if ( $dsn->{master_host} ) {
1916  ***      0                                            $host = $dsn->{master_host};
1917  ***      0                                            $port = $dsn->{master_port};
1918                                                     }
1919                                                     else {
1920  ***      0                                            $host = $dsn->{h};
1921  ***      0                                            $port = $dsn->{P};
1922                                                     }
1923  ***      0      0      0                           return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
1924                                                  }
1925                                                  
1926                                                  sub pos_to_string {
1927  ***      0                    0                    my ( $self, $pos ) = @_;
1928  ***      0                                         my $fmt  = '%s/%020d';
1929  ***      0                                         return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                      
1930                                                  }
1931                                                  
1932                                                  sub _d {
1933  ***      0                    0                    my ($package, undef, $line) = caller 0;
1934  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1935  ***      0                                              map { defined $_ ? $_ : 'undef' }
1936                                                          @_;
1937  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1938                                                  }
1939                                                  
1940                                                  1;
1941                                                  
1942                                                  # ###########################################################################
1943                                                  # End MasterSlave package
1944                                                  # ###########################################################################
1945                                                  
1946                                                  # ###########################################################################
1947                                                  # Daemon package 5266
1948                                                  # ###########################################################################
1949                                                  
1950                                                  package Daemon;
1951                                                  
1952           1                    1             8   use strict;
               1                                  3   
               1                                  5   
1953           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
1954                                                  
1955           1                    1             5   use POSIX qw(setsid);
               1                                  2   
               1                                  7   
1956           1                    1             5   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
1957                                                  
1958  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 14   
1959                                                  
1960                                                  sub new {
1961  ***      0                    0                    my ( $class, %args ) = @_;
1962  ***      0                                         foreach my $arg ( qw(o) ) {
1963  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1964                                                     }
1965  ***      0                                         my $o = $args{o};
1966  ***      0      0                                  my $self = {
      ***             0                               
1967                                                        o        => $o,
1968                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1969                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1970                                                     };
1971                                                  
1972  ***      0                                         check_PID_file(undef, $self->{PID_file});
1973                                                  
1974  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1975  ***      0                                         return bless $self, $class;
1976                                                  }
1977                                                  
1978                                                  sub daemonize {
1979  ***      0                    0                    my ( $self ) = @_;
1980                                                  
1981  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
1982  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1983  ***      0      0                                  if ( $pid ) {
1984  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
1985  ***      0                                            exit;
1986                                                     }
1987                                                  
1988  ***      0                                         $self->{child} = 1;
1989                                                  
1990  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1991  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1992                                                  
1993  ***      0                                         $self->_make_PID_file();
1994                                                  
1995  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
1996                                                  
1997  ***      0      0                                  if ( -t STDIN ) {
1998  ***      0                                            close STDIN;
1999  ***      0      0                                     open  STDIN, '/dev/null'
2000                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
2001                                                     }
2002                                                  
2003  ***      0      0                                  if ( $self->{log_file} ) {
2004  ***      0                                            close STDOUT;
2005  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
2006                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
2007                                                  
2008  ***      0                                            close STDERR;
2009  ***      0      0                                     open  STDERR, ">&STDOUT"
2010                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
2011                                                     }
2012                                                     else {
2013  ***      0      0                                     if ( -t STDOUT ) {
2014  ***      0                                               close STDOUT;
2015  ***      0      0                                        open  STDOUT, '>', '/dev/null'
2016                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
2017                                                        }
2018  ***      0      0                                     if ( -t STDERR ) {
2019  ***      0                                               close STDERR;
2020  ***      0      0                                        open  STDERR, '>', '/dev/null'
2021                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
2022                                                        }
2023                                                     }
2024                                                  
2025  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
2026  ***      0                                         return;
2027                                                  }
2028                                                  
2029                                                  sub check_PID_file {
2030  ***      0                    0                    my ( $self, $file ) = @_;
2031  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
2032  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
2033  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
2034  ***      0                                            my $pid;
2035  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
2036  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
2037  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
2038  ***      0      0                                     if ( $pid ) {
2039  ***      0                                               my $pid_is_alive = kill 0, $pid;
2040  ***      0      0                                        if ( $pid_is_alive ) {
2041  ***      0                                                  die "The PID file $PID_file already exists "
2042                                                                 . " and the PID that it contains, $pid, is running";
2043                                                           }
2044                                                           else {
2045  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
2046                                                                 . "contains, $pid, is not running";
2047                                                           }
2048                                                        }
2049                                                        else {
2050  ***      0                                               die "The PID file $PID_file already exists but it does not "
2051                                                              . "contain a PID";
2052                                                        }
2053                                                     }
2054                                                     else {
2055  ***      0                                            MKDEBUG && _d('No PID file');
2056                                                     }
2057  ***      0                                         return;
2058                                                  }
2059                                                  
2060                                                  sub make_PID_file {
2061  ***      0                    0                    my ( $self ) = @_;
2062  ***      0      0                                  if ( exists $self->{child} ) {
2063  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
2064                                                     }
2065  ***      0                                         $self->_make_PID_file();
2066  ***      0                                         $self->{rm_PID_file} = 1;
2067  ***      0                                         return;
2068                                                  }
2069                                                  
2070                                                  sub _make_PID_file {
2071  ***      0                    0                    my ( $self ) = @_;
2072                                                  
2073  ***      0                                         my $PID_file = $self->{PID_file};
2074  ***      0      0                                  if ( !$PID_file ) {
2075  ***      0                                            MKDEBUG && _d('No PID file to create');
2076  ***      0                                            return;
2077                                                     }
2078                                                  
2079  ***      0                                         $self->check_PID_file();
2080                                                  
2081  ***      0      0                                  open my $PID_FH, '>', $PID_file
2082                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
2083  ***      0      0                                  print $PID_FH $PID
2084                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
2085  ***      0      0                                  close $PID_FH
2086                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
2087                                                  
2088  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
2089  ***      0                                         return;
2090                                                  }
2091                                                  
2092                                                  sub _remove_PID_file {
2093  ***      0                    0                    my ( $self ) = @_;
2094  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
2095  ***      0      0                                     unlink $self->{PID_file}
2096                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
2097  ***      0                                            MKDEBUG && _d('Removed PID file');
2098                                                     }
2099                                                     else {
2100  ***      0                                            MKDEBUG && _d('No PID to remove');
2101                                                     }
2102  ***      0                                         return;
2103                                                  }
2104                                                  
2105                                                  sub DESTROY {
2106  ***      0                    0                    my ( $self ) = @_;
2107  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
2108  ***      0                                         return;
2109                                                  }
2110                                                  
2111                                                  sub _d {
2112  ***      0                    0                    my ($package, undef, $line) = caller 0;
2113  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2114  ***      0                                              map { defined $_ ? $_ : 'undef' }
2115                                                          @_;
2116  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2117                                                  }
2118                                                  
2119                                                  1;
2120                                                  
2121                                                  # ###########################################################################
2122                                                  # End Daemon package
2123                                                  # ###########################################################################
2124                                                  
2125                                                  # ###########################################################################
2126                                                  # This is a combination of modules and programs in one -- a runnable module.
2127                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2128                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2129                                                  #
2130                                                  # Check at the end of this package for the call to main() which actually runs
2131                                                  # the program.
2132                                                  # ###########################################################################
2133                                                  package mk_slave_restart;
2134                                                  
2135           1                    1             7   use English qw(-no_match_vars);
               1                                  3   
               1                                  9   
2136           1                    1             6   use IO::File;
               1                                  3   
               1                                 13   
2137           1                    1             6   use List::Util qw(min max);
               1                                  3   
               1                                  5   
2138           1                    1             6   use Time::HiRes qw(sleep);
               1                                  3   
               1                                  7   
2139           1                    1            13   use sigtrap qw(handler finish untrapped normal-signals);
               1                                  3   
               1                                  8   
2140                                                  
2141  ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 13   
2142                                                  
2143                                                  $OUTPUT_AUTOFLUSH = 1;
2144                                                  
2145                                                  my $o;
2146                                                  my $dp;
2147                                                  my %children;
2148                                                  
2149                                                  sub main {
2150  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
2151                                                  
2152                                                     # ########################################################################
2153                                                     # Get configuration information.
2154                                                     # ########################################################################
2155  ***      0                                         $dp = new DSNParser(); 
2156  ***      0                                         $o  = new OptionParser(
2157                                                        prompt      => '<options>',
2158                                                        description => 'watches one or more MySQL replication slaves for '
2159                                                                     . 'errors, and tries to restart replication if it stops.',
2160                                                     );
2161  ***      0                                         $o->get_specs();
2162  ***      0                                         $o->get_opts();
2163                                                  
2164  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
2165                                                  
2166  ***      0      0                                  $o->set('verbose', 0) if $o->get('quiet');
2167                                                  
2168  ***      0      0                                  if ( !$o->get('help') ) {
2169  ***      0      0                                     if ( $o->get('until-master') ) {
2170  ***      0      0                                        if ( $o->get('until-master') !~ m/^[.\w-]+,\d+$/ ) {
2171  ***      0                                                  $o->save_error("Invalid --until-master argument, must be file,pos");
2172                                                           }
2173                                                        }
2174  ***      0      0                                     if ( $o->get('until-relay') ) {
2175  ***      0      0                                        if ( $o->get('until-relay') !~ m/^[.\w-]+,\d+$/ ) {
2176  ***      0                                                  $o->save_error("Invalid --until-relay argument, must be file,pos");
2177                                                           }
2178                                                        }
2179                                                     }
2180                                                  
2181  ***      0                                         $o->usage_or_errors();
2182                                                  
2183                                                     # ########################################################################
2184                                                     # First things first: if --stop was given, create the sentinel file.
2185                                                     # ########################################################################
2186  ***      0                                         my $sentinel = $o->get('sentinel');
2187  ***      0      0                                  if ( $o->get('stop') ) {
2188  ***      0                                            MKDEBUG && _d('Creating sentinel file', $sentinel);
2189  ***      0      0                                     my $file = IO::File->new($sentinel, ">>")
2190                                                           or die "Cannot open $sentinel: $OS_ERROR\n";
2191  ***      0      0                                     print $file "Remove this file to permit mk-slave-restart to run\n"
2192                                                           or die "Cannot write to $sentinel: $OS_ERROR\n";
2193  ***      0      0                                     close $file
2194                                                           or die "Cannot close $sentinel: $OS_ERROR\n";
2195  ***      0      0                                     print STDOUT "Successfully created file $sentinel\n"
2196                                                           unless $o->get('quiet');
2197                                                        # Exit unlesss --monitor is given.
2198  ***      0      0                                     if ( !$o->got('monitor') ) {
2199  ***      0                                               MKDEBUG && _d('Nothing more to do, quitting');
2200  ***      0                                               return 0;
2201                                                        }
2202                                                        else {
2203                                                           # Wait for all other running instances to quit, assuming they have the
2204                                                           # same --interval as this invocation.  Then remove the file and
2205                                                           # continue.
2206  ***      0                                               MKDEBUG && _d('Waiting for other instances to quit');
2207  ***      0                                               sleep $o->get('max-sleep');
2208  ***      0                                               MKDEBUG && _d('Unlinking', $sentinel);
2209  ***      0      0                                        unlink $sentinel
2210                                                              or die "Cannot unlink $sentinel: $OS_ERROR";
2211                                                        }
2212                                                     }
2213                                                  
2214                                                     # ########################################################################
2215                                                     # Connect and go to work.
2216                                                     # ########################################################################
2217  ***      0      0                                  if ( $o->get('ask-pass') ) {
2218  ***      0                                            $o->set('password', OptionParser::prompt_noecho("Enter password: "));
2219                                                     }
2220  ***      0                                         my $dsn = $dp->parse_options($o);
2221  ***      0                                         my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1, });
2222                                                  
2223  ***      0                                         $dbh->{InactiveDestroy}  = 1;         # Don't disconnect on fork/daemonize
2224                                                  
2225                                                     # Daemonize only after connecting and doing --ask-pass.
2226  ***      0                                         my $daemon;
2227  ***      0      0                                  if ( $o->get('daemonize') ) {
      ***             0                               
2228  ***      0                                            $daemon = new Daemon(o=>$o);
2229  ***      0                                            $daemon->daemonize();
2230  ***      0                                            MKDEBUG && _d('I am a daemon now');
2231                                                     }
2232                                                     elsif ( $o->get('pid') ) {
2233                                                        # We're not daemoninzing, it just handles PID stuff.
2234  ***      0                                            $daemon = new Daemon(o=>$o);
2235  ***      0                                            $daemon->make_PID_file();
2236                                                     }
2237                                                  
2238  ***      0                                         my $exit_status = 0; 
2239  ***      0                                         my @servers_to_watch; 
2240                                                  
2241                                                     # Despite the name, recursing to slaves actually begins at the specified
2242                                                     # server, so the named server may also be watched, if it's a slave.
2243  ***      0                                         my $ms = new MasterSlave();
2244                                                     $ms->recurse_to_slaves(
2245                                                        {  dbh        => $dbh,
2246                                                           dsn        => $dsn,
2247                                                           dsn_parser => $dp,
2248                                                           recurse    => $o->get('recurse') || 0,
2249                                                           callback   => sub {
2250  ***      0                    0                             my ( $dsn, $dbh, $level ) = @_;
2251                                                              # Test whether we want to watch this server.
2252  ***      0                                                  eval {
2253  ***      0                                                     my $stat = $ms->get_slave_status($dbh);
2254  ***      0      0                                              if ( $stat ) {
2255  ***      0                                                        push @servers_to_watch, { dsn => $dsn, dbh => $dbh };
2256                                                                 }
2257                                                                 else {
2258  ***      0                                                        die "could not find slave status on this server\n";
2259                                                                 }
2260                                                              };
2261  ***      0      0                                           if ( $EVAL_ERROR ) {
2262  ***      0                                                     chomp $EVAL_ERROR;
2263  ***      0                                                     MKDEBUG && _d('Not watching', $dp->as_string($dsn),
2264                                                                    'because', $EVAL_ERROR);
2265                                                              }
2266                                                           },
2267                                                           skip_callback => sub {
2268  ***      0                    0                             my ( $dsn, $dbh, $level ) = @_;
2269  ***      0                                                  print STDERR "Skipping ", $dp->as_string($dsn), "\n";
2270                                                           },
2271  ***      0             0                                 method => $o->get('recursion-method'),
2272                                                        }
2273                                                     );
2274                                                  
2275                                                     # Watch each server found.
2276  ***      0                                         my $must_fork = @servers_to_watch > 1;
2277  ***      0                                         foreach my $host ( @servers_to_watch ) {
2278                                                  
2279  ***      0                                            $host->{dbh}->{InactiveDestroy}  = 1;         # Don't disconnect on fork
2280                                                  
2281                                                        # Fork, but only if there might be more than one host to watch.
2282  ***      0      0                                     my $pid = $must_fork ? fork() : undef;
2283  ***      0      0      0                              if ( !$must_fork || (defined($pid) && $pid == 0) ) {
      ***             0      0                        
      ***                    0                        
2284                                                           # I either forked and I'm a child, or I didn't fork... confusing, eh?
2285  ***      0                                               watch_server($host->{dsn}, $host->{dbh}, $must_fork, $ms);
2286                                                        }
2287                                                        elsif ( $must_fork && !defined($pid) ) {
2288  ***      0                                               die("Unable to fork!");
2289                                                        }
2290                                                        # I already exited if I'm a child, so I'm the parent.  (Or maybe I never
2291                                                        # forked).
2292  ***      0      0                                     $children{$dp->as_string($host->{dsn})} = $pid if $must_fork;
2293                                                     }
2294                                                  
2295  ***      0                                         MKDEBUG && _d('Child PIDs:', values %children);
2296                                                     # Wait for the children to exit.
2297  ***      0                                         foreach my $host ( keys %children ) {
2298  ***      0                                            MKDEBUG && _d('Waiting to reap', $host);
2299  ***      0                                            my $pid = waitpid($children{$host}, 0);
2300  ***      0             0                              $exit_status ||= $CHILD_ERROR >> 8;
2301                                                     }
2302                                                  
2303  ***      0                                         $dp->disconnect($dbh);
2304  ***      0                                         return $exit_status;
2305                                                  }
2306                                                  
2307                                                  # ############################################################################
2308                                                  # Subroutines.
2309                                                  # ############################################################################
2310                                                  
2311                                                  # Actually watch a server.  If many instances are being watched, this is
2312                                                  # fork()ed.
2313                                                  sub watch_server {
2314  ***      0                    0                    my ( $dsn, $dbh, $was_forked, $ms ) = @_;
2315  ***      0                                         my $q  = new Quoter();
2316  ***      0                                         my $vp = new VersionParser();
2317                                                  
2318  ***      0                                         MKDEBUG && _d('Watching server', $dp->as_string($dsn),
2319                                                        'forked:', $was_forked);
2320                                                  
2321  ***      0      0                                  my $start_sql = $vp->version_ge($dbh, '4.0.5')
2322                                                                   ? 'START SLAVE' : 'SLAVE START';
2323  ***      0      0                                  if ( $o->get('until-master') ) {
      ***             0                               
2324  ***      0                                            my ( $file, $pos ) = split(',', $o->get('until-master'));
2325  ***      0                                            $start_sql .= " UNTIL MASTER_LOG_FILE = '$file', MASTER_LOG_POS = $pos";
2326                                                     }
2327                                                     elsif ( $o->get('until-relay') ) {
2328  ***      0                                            my ( $file, $pos ) = split(',', $o->get('until-relay'));
2329  ***      0                                            $start_sql .= " UNTIL RELAY_LOG_FILE = '$file', RELAY_LOG_POS = $pos";
2330                                                     }
2331                                                  
2332  ***      0                                         my $set_skip   = $dbh->prepare("SET GLOBAL SQL_SLAVE_SKIP_COUNTER = "
2333                                                                      . $o->get('skip-count'));
2334  ***      0                                         my $start      = $dbh->prepare($start_sql);
2335  ***      0                                         my $stop       = $dbh->prepare('STOP SLAVE');
2336  ***      0                                         my $chmt       = $dbh->prepare(
2337                                                                      'CHANGE MASTER TO MASTER_LOG_FILE=?, MASTER_LOG_POS=?');
2338                                                  
2339                                                  
2340                                                     # ########################################################################
2341                                                     # Lookup tables of things to do when a problem is detected.
2342                                                     # ########################################################################
2343  ***      0                                         my @error_patterns = (
2344                                                        [ qr/You have an error in your SQL/         => 'refetch_relay_log' ],
2345                                                        [ qr/Could not parse relay log event entry/ => 'refetch_relay_log' ],
2346                                                        [ qr/Incorrect key file for table/          => 'repair_table'      ],
2347                                                        # This must be the last one.  It's a catch-all rule: skip and restart.
2348                                                        [ qr/./                                     => 'skip'              ],
2349                                                     );
2350                                                  
2351                                                     # ########################################################################
2352                                                     # These are actions to take when an error is found.
2353                                                     # ########################################################################
2354                                                     my %actions = (
2355                                                        refetch_relay_log => sub {
2356  ***      0                    0                          my ( $stat, $dbh ) = @_;
2357  ***      0                                               MKDEBUG && _d('Found relay log corruption');
2358                                                           # Can't do CHANGE MASTER TO with a running slave.
2359  ***      0                                               $stop->execute();
2360  ***      0                                               $chmt->execute(
2361  ***      0                                                  @{$stat}{qw(relay_master_log_file exec_master_log_pos)});
2362                                                        },
2363                                                        skip => sub {
2364  ***      0                    0                          my ( $stat, $dbh ) = @_;
2365  ***      0                                               MKDEBUG && _d('Found non-relay-log error');
2366  ***      0                                               $set_skip->execute();
2367                                                        },
2368                                                        repair_table => sub {
2369  ***      0                    0                          my ( $stat, $dbh ) = @_;
2370  ***      0                                               MKDEBUG && _d('Found corrupt table');
2371                                                           # [ qr/Incorrect key file for table './foo/bar.MYI'
2372  ***      0                                               my ( $db, $tbl ) = $stat->{last_error} =~ m!([^/]+)/(.*?)\.MYI!;
2373  ***      0      0      0                                 if ( $db && $tbl ) {
2374  ***      0                                                  my $sql = "REPAIR TABLE " . $q->quote($db, $tbl);
2375  ***      0                                                  MKDEBUG && _d($sql);
2376  ***      0                                                  $dbh->do($sql);
2377                                                           }
2378                                                        },
2379  ***      0                                         );
2380                                                  
2381  ***      0                                         my $err_text  = $o->get('error-text');
2382  ***      0             0                           my $exit_time = time() + ($o->get('run-time') || 0);
2383  ***      0                                         my $sleep     = $o->get('sleep');
2384  ***      0                                         my ($last_log, $last_pos);
2385                                                  
2386  ***      0                                         my $stat = {}; # Will hold SHOW SLAVE STATUS
2387                                                     STAT:
2388  ***      0             0                           while ( $stat
      ***                    0                        
      ***                    0                        
2389                                                             && (!$o->get('run-time') || time() < $exit_time)
2390                                                             && !-f $o->get('sentinel') ) {
2391  ***      0                                            my $increase_sleep = 1;
2392  ***      0                                            $stat = $ms->get_slave_status($dbh);
2393  ***      0      0                                     if ( !$stat ) {
2394  ***      0                                               print STDERR "No SLAVE STATUS output found on ",
2395                                                              $dp->as_string($dsn), "\n";
2396  ***      0                                               next STAT;
2397                                                        }
2398                                                  
2399  ***      0      0      0                              if ( !$last_log
      ***                    0                        
2400                                                             || $last_log ne $stat->{relay_log_file}   # Avoid infinite loops
2401                                                             || $last_pos != $stat->{relay_log_pos}
2402                                                        ) {
2403  ***      0             0                                 $stat->{slave_sql_running} ||= 'No';
2404  ***      0             0                                 $stat->{last_error}        ||= '';
2405  ***      0             0                                 $stat->{last_errno}        ||= 0;
2406                                                  
2407  ***      0      0      0                                 if ( $o->get('until-master') && pos_ge($stat, 'master') ) {
      ***             0      0                        
2408  ***      0                                                  die "Slave has advanced past " . $o->get('until-master')
2409                                                                 . " on master.\n";
2410                                                           }
2411                                                           elsif ( $o->get('until-relay') && pos_ge($stat, 'relay') ) {
2412  ***      0                                                  die "Slave has advanced past " . $o->get('until-relay')
2413                                                                 . " in relay logs.\n";
2414                                                           }
2415                                                  
2416  ***      0      0                                        if ( $stat->{slave_sql_running} eq 'No' ) {
      ***             0                               
2417                                                              # Print the time, error, etc
2418  ***      0      0                                           if ( $o->get('verbose') ) {
2419  ***      0                                                     my $err = '';
2420  ***      0      0                                              if ( $o->get('verbose') > 1 ) {
2421  ***      0             0                                          ($err = $stat->{last_error} || '' ) =~ s/\s+/ /g;
2422  ***      0      0                                                 if ( $o->get('error-length') ) {
2423  ***      0                                                           $err = substr($err, 0, $o->get('error-length'));
2424                                                                    }
2425                                                                 }
2426  ***      0             0                                       printf("%s %s %s %11d %d %s\n",
2427                                                                    ts(time),
2428                                                                    $dp->as_string($dsn),
2429                                                                    $stat->{relay_log_file},
2430                                                                    $stat->{relay_log_pos},
2431                                                                    $stat->{last_errno} || 0,
2432                                                                    $err
2433                                                                 );
2434                                                              }
2435                                                  
2436  ***      0      0      0                                    if ( $o->got('error-numbers') 
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
2437                                                                   && !exists($o->get('error-numbers')->{$stat->{last_errno}}) ) {
2438  ***      0                                                     die "Error $stat->{last_errno} is not in --error-numbers.\n";
2439                                                              }
2440                                                              elsif ( $err_text
2441                                                                      && $stat->{last_error}
2442                                                                      && $stat->{last_error} !~ m/$err_text/ ) {
2443  ***      0                                                     die "Error does not match --error-text.\n";
2444                                                              }
2445                                                              elsif ( $stat->{last_error} || $o->get('always') ) {
2446                                                  
2447                                                                 # What kind of error is it?
2448  ***      0                                                     foreach my $pat ( @error_patterns ) {
2449  ***      0      0                                                 if ( $stat->{last_error} =~ m/$pat->[0]/ ) {
2450  ***      0                                                           $actions{$pat->[1]}->($stat, $dbh);
2451  ***      0                                                           last;
2452                                                                    }
2453                                                                 }
2454                                                  
2455  ***      0                                                     $start->execute();
2456  ***      0                                                     $increase_sleep = 0;
2457                                                  
2458                                                                 # Only set this on events I tried to restart.  Otherwise there
2459                                                                 # could be a race condition: I see it, I record it, but it hasn't
2460                                                                 # caused an error yet; so I won't try to restart it when it does.
2461                                                                 # (The point of this is to avoid trying to restart the same event
2462                                                                 # twice in case another race condition happens -- I restart it,
2463                                                                 # then check the server and it hasn't yet cleared the error
2464                                                                 # message and restarted the SQL thread).
2465  ***      0                                                     $last_log = $stat->{relay_log_file};
2466  ***      0                                                     $last_pos = $stat->{relay_log_pos};
2467                                                              }
2468                                                              else {
2469  ***      0                                                     MKDEBUG && _d('The slave is stopped, but without error');
2470  ***      0                                                     $increase_sleep = 1;
2471                                                              }
2472                                                           }
2473                                                           elsif ( $o->get('verbose') > 2 ) {
2474  ***      0      0                                           printf("%s delayed %s sec\n", $dp->as_string($dsn),
2475                                                                 (defined $stat->{seconds_behind_master} ?
2476                                                                 $stat->{seconds_behind_master} : 'NULL'));
2477                                                           }
2478                                                        }
2479                                                  
2480                                                        # Adjust sleep time.
2481  ***      0      0                                     if ( $increase_sleep ) {
2482  ***      0                                               $sleep = min($o->get('max-sleep'), $sleep * 2);
2483                                                        }
2484                                                        else {
2485  ***      0                                               $sleep = max($o->get('min-sleep'), $sleep / 2);
2486                                                        }
2487                                                  
2488                                                        # Errors are very likely to follow each other in quick succession.  NOTE:
2489                                                        # this policy has a side effect with respect to $sleep.  Suppose $sleep is
2490                                                        # 512 and mk-slave-restart finds an error; now $sleep is 256, but
2491                                                        # mk-slave-restart sleeps only 1 (the initial value of --sleep).  Suppose
2492                                                        # there is no error when it wakes up after 1 second, because 1 was too
2493                                                        # short.  Now it doubles $sleep, back to 512.  $sleep has the same value
2494                                                        # it did before the error was ever found.
2495  ***      0      0                                     if ( $o->get('verbose') > 2 ) {
2496  ***      0                                               printf("%s sleeping %f\n", $dp->as_string($dsn), $sleep);
2497                                                        }
2498  ***      0      0                                     sleep($increase_sleep ? $sleep : min($sleep, $o->get('sleep')));
2499                                                     }
2500                                                  
2501  ***      0                                         MKDEBUG && _d('All done with server', $dp->as_string($dsn));
2502  ***      0      0                                  if ( $was_forked ) {
2503  ***      0                                            $dp->disconnect($dbh);
2504  ***      0                                            exit(0);
2505                                                     }
2506                                                  }
2507                                                  
2508                                                  # Determines if the $stat's log coordinates are greater than or equal to the
2509                                                  # desired coordinates. $which is 'master' or 'relay'
2510                                                  sub pos_ge {
2511  ***      0                    0                    my ( $stat, $which ) = @_;
2512  ***      0                                         my $fmt  = '%s/%020d';
2513  ***      0                                         my $curr = $which eq 'master'
2514  ***      0                                            ? sprintf($fmt, @{$stat}{qw(relay_master_log_file exec_master_log_pos)})
2515  ***      0      0                                     : sprintf($fmt, @{$stat}{qw(relay_log_file relay_log_pos)});
2516  ***      0                                         my $stop = sprintf($fmt, split(',', $o->get("until-$which")));
2517  ***      0                                         return $curr ge $stop;
2518                                                  }
2519                                                  
2520                                                  sub ts {
2521  ***      0                    0                    my ( $time ) = @_;
2522  ***      0                                         my ( $sec, $min, $hour, $mday, $mon, $year )
2523                                                        = localtime($time);
2524  ***      0                                         $mon  += 1;
2525  ***      0                                         $year += 1900;
2526  ***      0                                         return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
2527                                                        $year, $mon, $mday, $hour, $min, $sec);
2528                                                  }
2529                                                  
2530                                                  # Catches signals for exiting gracefully.
2531                                                  sub finish {
2532  ***      0                    0                    my ($signal) = @_;
2533  ***      0                                         print STDERR "Exiting on SIG$signal.\n";
2534  ***      0      0                                  if ( %children ) {
2535  ***      0                                            kill 9, values %children;
2536  ***      0                                            print STDERR "Signaled ", join(', ', values %children), "\n";
2537                                                     }
2538  ***      0                                         exit(1);
2539                                                  }
2540                                                  
2541                                                  sub _d {
2542  ***      0                    0                    my ($package, undef, $line) = caller 0;
2543  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2544  ***      0                                              map { defined $_ ? $_ : 'undef' }
2545                                                          @_;
2546  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2547                                                  }
2548                                                  
2549                                                  # ############################################################################
2550                                                  # Run the program.
2551                                                  # ############################################################################
2552                                                  if ( !caller ) { exit main(@ARGV); }
2553                                                  
2554                                                  1; # Because this is a module as well as a script.
2555                                                  
2556                                                  # ############################################################################
2557                                                  # Documentation.
2558                                                  # ############################################################################
2559                                                  
2560                                                  =pod
2561                                                  
2562                                                  =head1 NAME
2563                                                  
2564                                                  mk-slave-restart - Watch and restart MySQL replication after errors.
2565                                                  
2566                                                  =head1 SYNOPSIS
2567                                                  
2568                                                   mk-slave-restart --verbose
2569                                                  
2570                                                  =head1 RISKS
2571                                                  
2572                                                  The following section is included to inform users about the potential risks,
2573                                                  whether known or unknown, of using this tool.  The two main categories of risks
2574                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2575                                                  tools) and those created by bugs.
2576                                                  
2577                                                  mk-slave-restart is a brute-force way to try to keep a slave server running when
2578                                                  it is having problems with replication.  Don't be too hasty to use it unless you
2579                                                  need to.  If you use this tool carelessly, you might miss the chance to really
2580                                                  solve the slave server's problems.
2581                                                  
2582                                                  At the time of this release, we know of no bugs that could cause serious harm to
2583                                                  users.
2584                                                  
2585                                                  The authoritative source for updated information is always the online issue
2586                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2587                                                  see a list of such issues at the following URL:
2588                                                  L<http://www.maatkit.org/bugs/mk-slave-restart>.
2589                                                  
2590                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2591                                                  
2592                                                  =head1 DESCRIPTION
2593                                                  
2594                                                  mk-slave-restart watches one or more MySQL replication slaves and tries to skip
2595                                                  statements that cause errors.  It polls slaves intelligently with an
2596                                                  exponentially varying sleep time.  You can specify errors to skip and run the
2597                                                  slaves until a certain binlog position.
2598                                                  
2599                                                  Note: it has come to my attention that Yahoo! had or has an internal tool
2600                                                  called fix_repl, described to me by a past Yahoo! employee and mentioned in
2601                                                  the first edition of High Performance MySQL.  Apparently this tool does the
2602                                                  same thing.  Make no mistake, though: this is not a way to "fix replication."
2603                                                  In fact I would not even encourage its use on a regular basis; I use it only
2604                                                  when I have an error I know I just need to skip past.
2605                                                  
2606                                                  =head1 OUTPUT
2607                                                  
2608                                                  If you specify L<"--verbose">, mk-slave-restart prints a line every time it sees
2609                                                  the slave has an error.  See L<"--verbose"> for details.
2610                                                  
2611                                                  =head1 SLEEP
2612                                                  
2613                                                  mk-slave-restart sleeps intelligently between polling the slave.  The current
2614                                                  sleep time varies.
2615                                                  
2616                                                  =over
2617                                                  
2618                                                  =item *
2619                                                  
2620                                                  The initial sleep time is given by L<"--sleep">.
2621                                                  
2622                                                  =item *
2623                                                  
2624                                                  If it checks and finds an error, it halves the previous sleep time.
2625                                                  
2626                                                  =item *
2627                                                  
2628                                                  If it finds no error, it doubles the previous sleep time.
2629                                                  
2630                                                  =item *
2631                                                  
2632                                                  The sleep time is bounded below by L<"--min-sleep"> and above by
2633                                                  L<"--max-sleep">.
2634                                                  
2635                                                  =item *
2636                                                  
2637                                                  Immediately after finding an error, mk-slave-restart assumes another error is
2638                                                  very likely to happen next, so it sleeps the current sleep time or the initial
2639                                                  sleep time, whichever is less.
2640                                                  
2641                                                  =back
2642                                                  
2643                                                  =head1 EXIT STATUS
2644                                                  
2645                                                  Successful exit status is 0.  Any other value represents the exit status of
2646                                                  the Perl process itself, or of the last forked process that exited if there
2647                                                  were multiple servers to monitor.
2648                                                  
2649                                                  =head1 COMPATIBILITY
2650                                                  
2651                                                  mk-slave-restart should work on many versions of MySQL.  Lettercase of many
2652                                                  output columns from SHOW SLAVE STATUS has changed over time, so it treats them
2653                                                  all as lowercase.
2654                                                  
2655                                                  =head1 OPTIONS
2656                                                  
2657                                                  =over
2658                                                  
2659                                                  =item --always
2660                                                  
2661                                                  Start slaves even when there is no error.  With this option enabled,
2662                                                  mk-slave-restart will not let you stop the slave manually if you want to!
2663                                                  
2664                                                  =item --ask-pass
2665                                                  
2666                                                  Prompt for a password when connecting to MySQL.
2667                                                  
2668                                                  =item --charset
2669                                                  
2670                                                  short form: -A; type: string
2671                                                  
2672                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2673                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
2674                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
2675                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
2676                                                  connecting to MySQL.
2677                                                  
2678                                                  =item --config
2679                                                  
2680                                                  type: Array
2681                                                  
2682                                                  Read this comma-separated list of config files; if specified, this must be the
2683                                                  first option on the command line.
2684                                                  
2685                                                  =item --daemonize
2686                                                  
2687                                                  Fork to the background and detach from the shell.  POSIX
2688                                                  operating systems only.
2689                                                  
2690                                                  =item --database
2691                                                  
2692                                                  short form: -D; type: string
2693                                                  
2694                                                  Database to use.
2695                                                  
2696                                                  =item --defaults-file
2697                                                  
2698                                                  short form: -F; type: string
2699                                                  
2700                                                  Only read mysql options from the given file.  You must give an absolute
2701                                                  pathname.
2702                                                  
2703                                                  =item --error-length
2704                                                  
2705                                                  type: int
2706                                                  
2707                                                  Max length of error message to print.  When L<"--verbose"> is set high enough to
2708                                                  print the error, this option will truncate the error text to the specified
2709                                                  length.  This can be useful to prevent wrapping on the terminal.
2710                                                  
2711                                                  =item --error-numbers
2712                                                  
2713                                                  type: hash
2714                                                  
2715                                                  Only restart this comma-separated list of errors.  Makes mk-slave-restart only
2716                                                  try to restart if the error number is in this comma-separated list of errors.
2717                                                  If it sees an error not in the list, it will exit.
2718                                                  
2719                                                  The error number is in the C<last_errno> column of C<SHOW SLAVE STATUS>.
2720                                                  
2721                                                  =item --error-text
2722                                                  
2723                                                  type: string
2724                                                  
2725                                                  Only restart errors that match this pattern.  A Perl regular expression against
2726                                                  which the error text, if any, is matched.  If the error text exists and matches,
2727                                                  mk-slave-restart will try to restart the slave.  If it exists but doesn't match,
2728                                                  mk-slave-restart will exit.
2729                                                  
2730                                                  The error text is in the C<last_error> column of C<SHOW SLAVE STATUS>.
2731                                                  
2732                                                  =item --help
2733                                                  
2734                                                  Show help and exit.
2735                                                  
2736                                                  =item --host
2737                                                  
2738                                                  short form: -h; type: string
2739                                                  
2740                                                  Connect to host.
2741                                                  
2742                                                  =item --log
2743                                                  
2744                                                  type: string
2745                                                  
2746                                                  Print all output to this file when daemonized.
2747                                                  
2748                                                  =item --max-sleep
2749                                                  
2750                                                  type: float; default: 64
2751                                                  
2752                                                  Maximum sleep seconds.
2753                                                  
2754                                                  The maximum time mk-slave-restart will sleep before polling the slave again.
2755                                                  This is also the time that mk-slave-restart will wait for all other running
2756                                                  instances to quit if both L<"--stop"> and L<"--monitor"> are specified.
2757                                                  
2758                                                  See L<"SLEEP">.
2759                                                  
2760                                                  =item --min-sleep
2761                                                  
2762                                                  type: float; default: 0.015625
2763                                                  
2764                                                  The minimum time mk-slave-restart will sleep before polling the slave again.
2765                                                  See L<"SLEEP">.
2766                                                  
2767                                                  =item --monitor
2768                                                  
2769                                                  Whether to monitor the slave (default).  Unless you specify --monitor
2770                                                  explicitly, L<"--stop"> will disable it.
2771                                                  
2772                                                  =item --password
2773                                                  
2774                                                  short form: -p; type: string
2775                                                  
2776                                                  Password to use when connecting.
2777                                                  
2778                                                  =item --pid
2779                                                  
2780                                                  type: string
2781                                                  
2782                                                  Create the given PID file when daemonized.  The file contains the process
2783                                                  ID of the daemonized instance.  The PID file is removed when the
2784                                                  daemonized instance exits.  The program checks for the existence of the
2785                                                  PID file when starting; if it exists and the process with the matching PID
2786                                                  exists, the program exits.
2787                                                  
2788                                                  =item --port
2789                                                  
2790                                                  short form: -P; type: int
2791                                                  
2792                                                  Port number to use for connection.
2793                                                  
2794                                                  =item --quiet
2795                                                  
2796                                                  short form: -q
2797                                                  
2798                                                  Suppresses normal output (disables L<"--verbose">).
2799                                                  
2800                                                  =item --recurse
2801                                                  
2802                                                  type: int; default: 0
2803                                                  
2804                                                  Watch slaves of the specified server, up to the specified number of servers deep
2805                                                  in the hierarchy.  The default depth of 0 means "just watch the slave
2806                                                  specified."
2807                                                  
2808                                                  mk-slave-restart examines C<SHOW PROCESSLIST> and tries to determine which
2809                                                  connections are from slaves, then connect to them.  See L<"--recursion-method">.
2810                                                  
2811                                                  Recursion works by finding all slaves when the program starts, then watching
2812                                                  them.  If there is more than one slave, C<mk-slave-restart> uses C<fork()> to
2813                                                  monitor them.
2814                                                  
2815                                                  This also works if you have configured your slaves to show up in C<SHOW SLAVE
2816                                                  HOSTS>.  The minimal configuration for this is the C<report_host> parameter, but
2817                                                  there are other "report" parameters as well for the port, username, and
2818                                                  password.
2819                                                  
2820                                                  =item --recursion-method
2821                                                  
2822                                                  type: string
2823                                                  
2824                                                  Preferred recursion method used to find slaves.
2825                                                  
2826                                                  Possible methods are:
2827                                                  
2828                                                    METHOD       USES
2829                                                    ===========  ================
2830                                                    processlist  SHOW PROCESSLIST
2831                                                    hosts        SHOW SLAVE HOSTS
2832                                                  
2833                                                  The processlist method is preferred because SHOW SLAVE HOSTS is not reliable.
2834                                                  However, the hosts method is required if the server uses a non-standard
2835                                                  port (not 3306).  Usually mk-slave-restart does the right thing and finds
2836                                                  the slaves, but you may give a preferred method and it will be used first.
2837                                                  If it doesn't find any slaves, the other methods will be tried.
2838                                                  
2839                                                  =item --run-time
2840                                                  
2841                                                  type: time
2842                                                  
2843                                                  Time to run before exiting.  Causes mk-slave-restart to stop after the specified
2844                                                  time has elapsed.  Optional suffix: s=seconds, m=minutes, h=hours, d=days; if no
2845                                                  suffix, s is used.
2846                                                  
2847                                                  =item --sentinel
2848                                                  
2849                                                  type: string; default: /tmp/mk-slave-restart-sentinel
2850                                                  
2851                                                  Exit if this file exists.
2852                                                  
2853                                                  =item --set-vars
2854                                                  
2855                                                  type: string; default: wait_timeout=10000
2856                                                  
2857                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2858                                                  will be appended to SET and executed.
2859                                                  
2860                                                  =item --skip-count
2861                                                  
2862                                                  type: int; default: 1
2863                                                  
2864                                                  Number of statements to skip when restarting the slave.
2865                                                  
2866                                                  =item --sleep
2867                                                  
2868                                                  type: int; default: 1
2869                                                  
2870                                                  Initial sleep seconds between checking the slave.
2871                                                  
2872                                                  See L<"SLEEP">.
2873                                                  
2874                                                  =item --socket
2875                                                  
2876                                                  short form: -S; type: string
2877                                                  
2878                                                  Socket file to use for connection.
2879                                                  
2880                                                  =item --stop
2881                                                  
2882                                                  Stop running instances by creating the sentinel file.
2883                                                  
2884                                                  Causes C<mk-slave-restart> to create the sentinel file specified by
2885                                                  L<"--sentinel">.  This should have the effect of stopping all running
2886                                                  instances which are watching the same sentinel file.  If L<"--monitor"> isn't
2887                                                  specified, C<mk-slave-restart> will exit after creating the file.  If it is
2888                                                  specified, C<mk-slave-restart> will wait the interval given by
2889                                                  L<"--max-sleep">, then remove the file and continue working.
2890                                                  
2891                                                  You might find this handy to stop cron jobs gracefully if necessary, or to
2892                                                  replace one running instance with another.  For example, if you want to stop
2893                                                  and restart C<mk-slave-restart> every hour (just to make sure that it is
2894                                                  restarted every hour, in case of a server crash or some other problem), you
2895                                                  could use a C<crontab> line like this:
2896                                                  
2897                                                   0 * * * * mk-slave-restart --monitor --stop --sentinel /tmp/mk-slave-restartup
2898                                                  
2899                                                  The non-default L<"--sentinel"> will make sure the hourly C<cron> job stops
2900                                                  only instances previously started with the same options (that is, from the
2901                                                  same C<cron> job).
2902                                                  
2903                                                  See also L<"--sentinel">.
2904                                                  
2905                                                  =item --until-master
2906                                                  
2907                                                  type: string
2908                                                  
2909                                                  Run until this master log file and position.  Start the slave, and retry if it
2910                                                  fails, until it reaches the given replication coordinates.  The coordinates are
2911                                                  the logfile and position on the master, given by relay_master_log_file,
2912                                                  exec_master_log_pos.  The argument must be in the format "file,pos".  Separate
2913                                                  the filename and position with a single comma and no space.
2914                                                  
2915                                                  This will also cause an UNTIL clause to be given to START SLAVE.
2916                                                  
2917                                                  After reaching this point, the slave should be stopped and mk-slave-restart
2918                                                  will exit.
2919                                                  
2920                                                  =item --until-relay
2921                                                  
2922                                                  type: string
2923                                                  
2924                                                  Run until this relay log file and position.  Like L<"--until-master">, but in
2925                                                  the slave's relay logs instead.  The coordinates are given by relay_log_file,
2926                                                  relay_log_pos.
2927                                                  
2928                                                  =item --user
2929                                                  
2930                                                  short form: -u; type: string
2931                                                  
2932                                                  User for login if not current user.
2933                                                  
2934                                                  =item --verbose
2935                                                  
2936                                                  short form: -v; cumulative: yes; default: 1
2937                                                  
2938                                                  Be verbose; can specify multiple times.  Verbosity 1 outputs connection
2939                                                  information, a timestamp, relay_log_file, relay_log_pos, and last_errno.
2940                                                  Verbosity 2 adds last_error.  See also L<"--error-length">.  Verbosity 3 prints
2941                                                  the current sleep time each time mk-slave-restart sleeps.
2942                                                  
2943                                                  =item --version
2944                                                  
2945                                                  Show version and exit.
2946                                                  
2947                                                  =back
2948                                                  
2949                                                  =head1 DOWNLOADING
2950                                                  
2951                                                  You can download Maatkit from Google Code at
2952                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2953                                                  easily with a command like the following:
2954                                                  
2955                                                     wget http://www.maatkit.org/get/toolname
2956                                                     or
2957                                                     wget http://www.maatkit.org/trunk/toolname
2958                                                  
2959                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2960                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2961                                                  needed.  The first URL gets the latest released version of the tool, and the
2962                                                  second gets the latest trunk code from Subversion.
2963                                                  
2964                                                  =head1 ENVIRONMENT
2965                                                  
2966                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2967                                                  the Maatkit tools:
2968                                                  
2969                                                     MKDEBUG=1 mk-....
2970                                                  
2971                                                  When L<"--daemonize"> is given and this variable is set, output is directed to a
2972                                                  debug file in C</tmp>.
2973                                                  
2974                                                  =head1 SYSTEM REQUIREMENTS
2975                                                  
2976                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2977                                                  installed in any reasonably new version of Perl.
2978                                                  
2979                                                  =head1 BUGS
2980                                                  
2981                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-slave-restart>.
2982                                                  
2983                                                  Please use Google Code Issues and Groups to report bugs or request support:
2984                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2985                                                  discuss Maatkit.
2986                                                  
2987                                                  Please include the complete command-line used to reproduce the problem you are
2988                                                  seeing, the version of all MySQL servers involved, the complete output of the
2989                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2990                                                  running with the C<MKDEBUG=1> environment variable.
2991                                                  
2992                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2993                                                  
2994                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
2995                                                  Feedback and improvements are welcome.
2996                                                  
2997                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2998                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2999                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
3000                                                  
3001                                                  This program is free software; you can redistribute it and/or modify it under
3002                                                  the terms of the GNU General Public License as published by the Free Software
3003                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
3004                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
3005                                                  licenses.
3006                                                  
3007                                                  You should have received a copy of the GNU General Public License along with
3008                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
3009                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
3010                                                  
3011                                                  =head1 SEE ALSO
3012                                                  
3013                                                  See also L<mk-table-checksum>, L<mk-table-sync>, L<mk-slave-delay>.
3014                                                  
3015                                                  =head1 AUTHOR
3016                                                  
3017                                                  Baron Schwartz
3018                                                  
3019                                                  =head1 ABOUT MAATKIT
3020                                                  
3021                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
3022                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
3023                                                  code contributors.  Both are employed by Percona.  Financial support for
3024                                                  Maatkit development is primarily provided by Percona and its clients. 
3025                                                  
3026                                                  =head1 VERSION
3027                                                  
3028                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
3029                                                  
3030                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
58    ***      0      0      0   unless defined $val
59    ***      0      0      0   if $val eq ''
61    ***      0      0      0   if (not defined $is_numeric)
62    ***      0      0      0   $val =~ /^0|\D/ ? :
65    ***      0      0      0   if $is_numeric
75    ***      0      0      0   if (not $tbl)
84    ***      0      0      0   unless $like
123   ***      0      0      0   unless $args{$arg}
129   ***      0      0      0   exists $args{'strict'} ? :
172   ***      0      0      0   unless open my $fh, '<', $file
192   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
197   ***      0      0      0   if $para =~ /^=over/
205   ***      0      0      0   unless $para
208   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
215   ***      0      0      0   if ($para =~ /: /) { }
219   ***      0      0      0   unless $attributes{$attrib}
223   ***      0      0      0   if ($attribs{'short form'})
239   ***      0      0      0   if $para =~ /^=item/
241   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
246   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
258   ***      0      0      0   unless $para
261   ***      0      0      0   if ($para =~ /^=head1/)
265   ***      0      0      0   if $para =~ /^=item --/
269   ***      0      0      0   unless @specs
280   ***      0      0      0   if (ref $opt) { }
285   ***      0      0      0   if (not $long)
290   ***      0      0      0   if exists $$self{'opts'}{$long}
293   ***      0      0      0   if (length $long == 1)
298   ***      0      0      0   if ($short) { }
299   ***      0      0      0   if exists $$self{'short_opts'}{$short}
308   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
309   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
310   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
322   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
327   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
329   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
330   ***      0      0      0   defined $def ? :
334   ***      0      0      0   if ($long eq 'config')
338   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
351   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
356   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
361   ***      0      0      0   if ($opt =~ /default to/)
366   ***      0      0      0   if ($opt =~ /restricted to option groups/)
376   ***      0      0      0   unless $rule_ok
393   ***      0      0      0   unless exists $$self{'opts'}{$long}
417   ***      0      0      0   unless exists $$self{'opts'}{$long}
437   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
442   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
457   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
466   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
470   ***      0      0      0   if ($self->has('config'))
476   ***      0      0      0   if ($EVAL_ERROR)
477   ***      0      0      0   $self->got('config') ? :
492   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
495   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
496   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
502   ***      0      0      0   if (@ARGV and $$self{'strict'})
508   ***      0      0      0   if (@set > 1)
519   ***      0      0      0   if (@set == 0)
529   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
530   ***      0      0      0   if (exists $$self{'disables'}{$long})
537   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
549   ***      0      0      0   if $restricted_opt eq $long
550   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
555   ***      0      0      0   if (@restricted_opts)
557   ***      0      0      0   if (@restricted_opts == 1) { }
586   ***      0      0      0   unless $opt and $$opt{'type'}
589   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
592   ***      0      0      0   if (not $suffix)
598   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
599   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
614   ***      0      0      0   if ($from_key)
625   ***      0      0      0   if (defined $num) { }
626   ***      0      0      0   if ($factor)
653   ***      0      0      0   length $opt == 1 ? :
654   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
661   ***      0      0      0   length $opt == 1 ? :
662   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
669   ***      0      0      0   length $opt == 1 ? :
670   ***      0      0      0   defined $long ? :
675   ***      0      0      0   length $opt == 1 ? :
676   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
710   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
711   ***      0      0      0   unless print $self->print_usage
715   ***      0      0      0   unless print $self->print_errors
724   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
733   ***      0      0      0   unless $$self{'got_opts'}
736   ***      0      0      0   $$_{'is_negatable'} ? :
740   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
756   ***      0      0      0   $group eq 'default' ? :
762   ***      0      0      0   $$opt{'is_negatable'} ? :
765   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
774   ***      0      0      0   if ($short) { }
783   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
787   ***      0      0      0   if ($$self{'dp'})
795   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
807   ***      0      0      0   if ref $_[0] eq 'OptionParser'
810   ***      0      0      0   unless print $prompt
818   ***      0      0      0   unless print "\n"
821   ***      0      0      0   if ($EVAL_ERROR)
843   ***      0      0      0   unless open my $fh, '<', $filename
851   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
854   ***      0      0      0   if ($line eq '--')
859   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
877   ***      0      0      0   unless open my $fh, '<', $file
881   ***      0      0      0   unless $para =~ /^=pod$/m
885   ***      0      0      0   unless $para =~ /$regex/
890   ***      0      0      0   unless close $fh
904   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
919   ***      0      0      0   defined $_ ? :
957   ***      0      0      0   if (not $$self{$dbh})
961   ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
968   ***      0      0      0   defined $_ ? :
1054  ***     50      0      6   if (@_ > 2)
1063  ***     50      0      2   if (not $dsn)
1075  ***     50      8      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1087  ***     50      0     16   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1093         100      8      8   if (not defined $final_props{$key})
1100  ***     50      0      8   unless exists $opts{$key}
1103  ***     50      0      2   if (my $required = $self->prop('required'))
1105  ***      0      0      0   unless $final_props{$key}
1114  ***      0      0      0   unless ref $o eq 'OptionParser'
1117  ***      0      0      0   if $o->has($_)
1127  ***      0      0      0   unless ref $dsn
1128  ***      0      0      0   $_ eq 'p' ? :
1129  ***      0      0      0   if defined $$dsn{$_}
1142  ***      0      0      0   $opts{$key}{'copy'} ? :
1156  ***     50      0      2   if ($driver eq 'Pg') { }
1188  ***     50      0      2   $cxn_string =~ /charset=utf8/ ? :
1197  ***     50      0      2   if (not $have_dbi)
1216  ***     50      2      0   if ($cxn_string =~ /mysql/i)
1224  ***     50      0      2   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1229  ***      0      0      0   if ($charset eq 'utf8') { }
1230  ***      0      0      0   unless binmode STDOUT, ':utf8'
1234  ***      0      0      0   unless binmode STDOUT
1238  ***     50      0      2   if ($self->prop('set-vars'))
1245  ***     50      0      2   if (not $dbh and $EVAL_ERROR)
1247  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1260  ***      0      0      0   if (not $tries)
1282  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1299  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1309  ***      0      0      0   unless $dsn_1
1310  ***      0      0      0   unless $dsn_2
1314  ***      0      0      0   if ($args{'overwrite'}) { }
1315  ***      0      0      0   defined $$dsn_1{$key} ? :
1318  ***      0      0      0   defined $$dsn_2{$key} ? :
1327  ***      0      0      0   defined $_ ? :
1371  ***      0      0      0   if ($EVAL_ERROR)
1372  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
1382  ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
1387  ***      0      0      0   if ($$args{'skip_callback'})
1395  ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
1397  ***      0      0      0   unless not $$_{'master_id'}
1414  ***      0      0      0   if ($method) { }
1419  ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
1433  ***      0      0      0   if @slaves
1451  ***      0      0      0   if ($host eq 'localhost')
1468  ***      0      0      0   if (@slaves)
1473  ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
1493  ***      0      0      0   if (not $proc)
1510  ***      0      0      0   unless my $master_status = $self->get_master_status($master)
1512  ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
1514  ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
1518  ***      0      0      0   if ($port != $$slave_status{'master_port'})
1523  ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
1528  ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
1535  ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
1548  ***      0      0      0   unless my $master = $self->get_slave_status($dbh)
1555  ***      0      0      0   if (not $$self{'not_a_slave'}{$dbh})
1562  ***      0      0      0   if ($ss and %$ss)
1574  ***      0      0      0   if (not $$self{'not_a_master'}{$dbh})
1581  ***      0      0      0   if ($ms and %$ms)
1583  ***      0      0      0   if ($$ms{'file'} and $$ms{'position'})
1596  ***      0      0      0   unless defined $time
1600  ***      0      0      0   if ($ms) { }
1604  ***      0      0      0   defined $result ? :
1606  ***      0      0      0   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
1626  ***      0      0      0   if ($pos) { }
1650  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
1656  ***      0      0      0   if ($EVAL_ERROR)
1658  ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
1660  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
1665  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
1689  ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
1701  ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
1724  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1728  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1733  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
1747  ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
1762  ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
1773  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
1777  ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1781  ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1783  ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
1786  ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
1788  ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
1800  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
1812  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
1816  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1820  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1823  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
1826  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
1830  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
1832  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
1840  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
1854  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
1865  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
1887  ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
1915  ***      0      0      0   if ($$dsn{'master_host'}) { }
1923  ***      0      0      0   ($port || 3306) == 3306 ? :
1934  ***      0      0      0   defined $_ ? :
1963  ***      0      0      0   unless $args{$arg}
1966  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1982  ***      0      0      0   unless defined(my $pid = fork)
1983  ***      0      0      0   if ($pid)
1990  ***      0      0      0   unless POSIX::setsid()
1991  ***      0      0      0   unless chdir '/'
1997  ***      0      0      0   if (-t STDIN)
1999  ***      0      0      0   unless open STDIN, '/dev/null'
2003  ***      0      0      0   if ($$self{'log_file'}) { }
2005  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
2009  ***      0      0      0   unless open STDERR, '>&STDOUT'
2013  ***      0      0      0   if (-t STDOUT)
2015  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
2018  ***      0      0      0   if (-t STDERR)
2020  ***      0      0      0   unless open STDERR, '>', '/dev/null'
2031  ***      0      0      0   $self ? :
2033  ***      0      0      0   if ($PID_file and -f $PID_file) { }
2036  ***      0      0      0   if $EVAL_ERROR
2038  ***      0      0      0   if ($pid) { }
2040  ***      0      0      0   if ($pid_is_alive) { }
2062  ***      0      0      0   if (exists $$self{'child'})
2074  ***      0      0      0   if (not $PID_file)
2081  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
2083  ***      0      0      0   unless print $PID_FH $PID
2085  ***      0      0      0   unless close $PID_FH
2094  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
2095  ***      0      0      0   unless unlink $$self{'PID_file'}
2107  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
2113  ***      0      0      0   defined $_ ? :
2166  ***      0      0      0   if $o->get('quiet')
2168  ***      0      0      0   if (not $o->get('help'))
2169  ***      0      0      0   if ($o->get('until-master'))
2170  ***      0      0      0   if (not $o->get('until-master') =~ /^[.\w-]+,\d+$/)
2174  ***      0      0      0   if ($o->get('until-relay'))
2175  ***      0      0      0   if (not $o->get('until-relay') =~ /^[.\w-]+,\d+$/)
2187  ***      0      0      0   if ($o->get('stop'))
2189  ***      0      0      0   unless my $file = 'IO::File'->new($sentinel, '>>')
2191  ***      0      0      0   unless print $file "Remove this file to permit mk-slave-restart to run\n"
2193  ***      0      0      0   unless close $file
2195  ***      0      0      0   unless $o->get('quiet')
2198  ***      0      0      0   if (not $o->got('monitor')) { }
2209  ***      0      0      0   unless unlink $sentinel
2217  ***      0      0      0   if ($o->get('ask-pass'))
2227  ***      0      0      0   if ($o->get('daemonize')) { }
      ***      0      0      0   elsif ($o->get('pid')) { }
2254  ***      0      0      0   if ($stat) { }
2261  ***      0      0      0   if ($EVAL_ERROR)
2282  ***      0      0      0   $must_fork ? :
2283  ***      0      0      0   if (not $must_fork or defined $pid and $pid == 0) { }
      ***      0      0      0   elsif ($must_fork and not defined $pid) { }
2292  ***      0      0      0   if $must_fork
2321  ***      0      0      0   $vp->version_ge($dbh, '4.0.5') ? :
2323  ***      0      0      0   if ($o->get('until-master')) { }
      ***      0      0      0   elsif ($o->get('until-relay')) { }
2373  ***      0      0      0   if ($db and $tbl)
2393  ***      0      0      0   if (not $stat)
2399  ***      0      0      0   if (not $last_log or $last_log ne $$stat{'relay_log_file'} or $last_pos != $$stat{'relay_log_pos'})
2407  ***      0      0      0   if ($o->get('until-master') and pos_ge($stat, 'master')) { }
      ***      0      0      0   elsif ($o->get('until-relay') and pos_ge($stat, 'relay')) { }
2416  ***      0      0      0   if ($$stat{'slave_sql_running'} eq 'No') { }
      ***      0      0      0   elsif ($o->get('verbose') > 2) { }
2418  ***      0      0      0   if ($o->get('verbose'))
2420  ***      0      0      0   if ($o->get('verbose') > 1)
2422  ***      0      0      0   if ($o->get('error-length'))
2436  ***      0      0      0   if ($o->got('error-numbers') and not exists $o->get('error-numbers')->{$$stat{'last_errno'}}) { }
      ***      0      0      0   elsif ($err_text and $$stat{'last_error'} and not $$stat{'last_error'} =~ /$err_text/) { }
      ***      0      0      0   elsif ($$stat{'last_error'} or $o->get('always')) { }
2449  ***      0      0      0   if ($$stat{'last_error'} =~ /$$pat[0]/)
2474  ***      0      0      0   defined $$stat{'seconds_behind_master'} ? :
2481  ***      0      0      0   if ($increase_sleep) { }
2495  ***      0      0      0   if ($o->get('verbose') > 2)
2498  ***      0      0      0   $increase_sleep ? :
2502  ***      0      0      0   if ($was_forked)
2515  ***      0      0      0   $which eq 'master' ? :
2534  ***      0      0      0   if (%children)
2543  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
322   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
327   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
466   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
495   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
502   ***      0      0      0      0   @ARGV and $$self{'strict'}
586   ***      0      0      0      0   $opt and $$opt{'type'}
589   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
654   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
662   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
676   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
765   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
859   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1087  ***     66      8      8      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     16      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1209  ***     66      2      0      2   not $dbh and $tries--
1245  ***     33      2      0      0   not $dbh and $EVAL_ERROR
1382  ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
1562  ***      0      0      0      0   $ss and %$ss
1581  ***      0      0      0      0   $ms and %$ms
1583  ***      0      0      0      0   $$ms{'file'} and $$ms{'position'}
1606  ***      0      0      0      0   $stat < 0 and not $timeoutok
1747  ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
1882  ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
1887  ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
2033  ***      0      0      0      0   $PID_file and -f $PID_file
2094  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2283  ***      0      0      0      0   defined $pid and $pid == 0
      ***      0      0      0      0   $must_fork and not defined $pid
2373  ***      0      0      0      0   $db and $tbl
2388  ***      0      0      0      0   $stat and !$o->get('run-time') || time < $exit_time
      ***      0      0      0      0   $stat and !$o->get('run-time') || time < $exit_time and not -f $o->get('sentinel')
2407  ***      0      0      0      0   $o->get('until-master') and pos_ge($stat, 'master')
      ***      0      0      0      0   $o->get('until-relay') and pos_ge($stat, 'relay')
2436  ***      0      0      0      0   $o->got('error-numbers') and not exists $o->get('error-numbers')->{$$stat{'last_errno'}}
      ***      0      0      0      0   $err_text and $$stat{'last_error'}
      ***      0      0      0      0   $err_text and $$stat{'last_error'} and not $$stat{'last_error'} =~ /$err_text/

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
40    ***     50      0      1   $ENV{'MKDEBUG'} || 0
107   ***     50      0      1   $ENV{'MKDEBUG'} || 0
127   ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
129   ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
171   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart'
312   ***      0      0      0   $$opt{'group'} ||= 'default'
594   ***      0      0      0   $s || 's'
603   ***      0      0      0   $prefix || ''
631   ***      0      0      0   $pre || ''
638   ***      0      0      0   $val || ''
641   ***      0      0      0   $val || ''
699   ***      0      0      0   $$self{'description'} || ''
767   ***      0      0      0   $s ||= 's'
793   ***      0      0      0   $$opt{'type'} || ''
941   ***     50      0      1   $ENV{'MKDEBUG'} || 0
997   ***     50      0      1   $ENV{'MKDEBUG'} || 0
1068  ***     50      0      2   $prev ||= {}
1069  ***     50      0      2   $defaults ||= {}
1142  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1155  ***     50      0      2   $self->prop('dbidriver') || ''
1159  ***      0      0      0   $$info{'D'} || ''
1165  ***     50      0      2   $$info{'D'} || ''
1187  ***     50      2      0   $opts ||= {}
1282  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1298  ***      0      0      0   $level ||= 0
1299  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1353  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1361  ***      0      0      0   $level ||= 0
1419  ***      0      0      0   $$dsn{'P'} || 3306
1528  ***      0      0      0   $$slave_status{'slave_io_state'} || ''
1874  ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
1923  ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
1958  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2141  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2271  ***      0      0      0   $o->get('recurse') || 0
2382  ***      0      0      0   $o->get('run-time') || 0
2403  ***      0      0      0   $$stat{'slave_sql_running'} ||= 'No'
2404  ***      0      0      0   $$stat{'last_error'} ||= ''
2405  ***      0      0      0   $$stat{'last_errno'} ||= 0
2421  ***      0      0      0   $$stat{'last_error'} || ''
2426  ***      0      0      0   $$stat{'last_errno'} || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
126   ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
127   ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
589   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1178  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1179  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1180  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1181  ***      0      0      0      0   $$dsn{'u'} ||= $user
1182  ***      0      0      0      0   $$dsn{'D'} ||= $db
1367  ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
1382  ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
1395  ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
1535  ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
1556  ***      0      0      0      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
1575  ***      0      0      0      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
1599  ***      0      0      0      0   $ms ||= $self->get_master_status($master)
1606  ***      0      0      0      0   $stat eq 'NULL' or $stat < 0 and not $timeoutok
1618  ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
1633  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
1701  ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
1762  ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
1800  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
1854  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
2107  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2283  ***      0      0      0      0   not $must_fork or defined $pid and $pid == 0
2300  ***      0      0      0      0   $exit_status ||= $CHILD_ERROR >> 8
2388  ***      0      0      0      0   !$o->get('run-time') || time < $exit_time
2399  ***      0      0      0      0   not $last_log or $last_log ne $$stat{'relay_log_file'}
      ***      0      0      0      0   not $last_log or $last_log ne $$stat{'relay_log_file'} or $last_pos != $$stat{'relay_log_pos'}
2436  ***      0      0      0      0   $$stat{'last_error'} or $o->get('always')


Covered Subroutines
-------------------

Subroutine                  Count Location                                                       
--------------------------- ----- ---------------------------------------------------------------
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:100 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:101 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:103 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:104 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:105 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:107 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1342
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1343
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1347
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1348
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1349
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1353
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1952
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1953
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1955
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1956
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1958
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2135
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2136
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2137
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2138
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2139
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2141
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:23  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:24  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:33  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:34  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:38  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:40  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:936 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:937 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:939 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:941 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:985 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:986 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:987 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:988 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:997 
get_cxn_params                  2 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1152
get_dbh                         2 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1186
new                             1 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1000
parse                           2 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1062
prop                            6 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1053

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                                       
--------------------------- ----- ---------------------------------------------------------------
DESTROY                         0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2106
__ANON__                        0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2250
__ANON__                        0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2268
__ANON__                        0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2356
__ANON__                        0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2364
__ANON__                        0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2369
__ANON__                        0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:490 
_d                              0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1326
_d                              0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1933
_d                              0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2112
_d                              0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2542
_d                              0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:918 
_d                              0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:967 
_find_slaves_by_hosts           0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1461
_find_slaves_by_processlist     0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1441
_get_participants               0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:390 
_make_PID_file                  0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2071
_parse_specs                    0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:276 
_pod_to_specs                   0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:170 
_read_config_file               0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:842 
_remove_PID_file                0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2093
_set_option                     0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:436 
_validate_type                  0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:585 
as_string                       0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1126
catchup_to_master               0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1641
catchup_to_same_pos             0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1682
change_master_to                0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1711
check_PID_file                  0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2030
clone                           0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:895 
copy                            0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1308
daemonize                       0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1979
descr                           0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:698 
detach_slave                    0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1863
disconnect                      0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1291
errors                          0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:688 
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1174
find_slave_hosts                0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1411
finish                          0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2532
get                             0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:652 
get_connected_slaves            0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1488
get_defaults                    0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:426 
get_defaults_files              0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:165 
get_groups                      0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:431 
get_hostname                    0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1281
get_master_dsn                  0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1547
get_master_status               0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1573
get_opts                        0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:453 
get_slave_lag                   0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1902
get_slave_status                0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1554
get_specs                       0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:158 
got                             0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:660 
has                             0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:668 
has_slave_updates               0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1878
is_master_of                    0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1509
literal_like                    0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:83  
main                            0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2150
make_PID_file                   0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2061
make_sibling_of_master          0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1722
make_slave_of_sibling           0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1770
make_slave_of_uncle             0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1809
new                             0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:121 
new                             0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1356
new                             0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1961
new                             0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:43  
new                             0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:944 
opts                            0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:402 
parse                           0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:949 
parse_options                   0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1113
pos_cmp                         0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1908
pos_ge                          0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2511
pos_to_string                   0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1927
print_active_handles            0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1297
print_errors                    0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:722 
print_usage                     0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:732 
prompt                          0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:693 
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:807 
quote                           0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:48  
quote_val                       0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:56  
read_para_after                 0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:876 
recurse_to_slaves               0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1360
repl_posn                       0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1886
save_error                      0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:683 
set                             0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:674 
set_defaults                    0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:414 
short_host                      0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1913
short_opts                      0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:408 
slave_is_running                0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1873
split_unquote                   0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:72  
start_slave                     0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1625
stop_slave                      0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1617
ts                              0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2521
usage                           0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1135
usage_or_errors                 0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:709 
version_ge                      0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:956 
wait_for_master                 0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:1594
watch_server                    0 /home/daniel/dev/maatkit/mk-slave-restart/mk-slave-restart:2314


mk-slave-restart.t

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     BEGIN {
4     ***      1     50     33      1            32      die "The MAATKIT_TRUNK environment variable is not set.  See http://code.google.com/p/maatkit/wiki/Testing"
5                                                           unless $ENV{MAATKIT_TRUNK} && -d $ENV{MAATKIT_TRUNK};
6              1                                  7      unshift @INC, "$ENV{MAATKIT_TRUNK}/common";
7                                                     };
8                                                     
9              1                    1            11   use strict;
               1                                  3   
               1                                  5   
10             1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
11             1                    1            12   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
12             1                    1            10   use Test::More;
               1                                  3   
               1                                 10   
13                                                    
14             1                    1            11   use MaatkitTest;
               1                                  3   
               1                                 12   
15             1                    1            12   use Sandbox;
               1                                  3   
               1                                 11   
16             1                                 24   require "$trunk/mk-slave-restart/mk-slave-restart";
17                                                    
18             1                                 12   my $dp = new DSNParser();
19             1                                 10   my $sb = new Sandbox(basedir => '/tmp', DSNParser => $dp);
20             1                                106   my $master_dbh = $sb->get_dbh_for('master');
21             1                                 39   my $slave_dbh  = $sb->get_dbh_for('slave1');
22                                                    
23    ***      1     50                          18   if ( !$master_dbh ) {
      ***            50                               
24    ***      0                                  0      plan skip_all => 'Cannot connect to sandbox master';
25                                                    }
26                                                    elsif ( !$slave_dbh ) {
27    ***      0                                  0      plan skip_all => 'Cannot connect to sandbox slave';
28                                                    }
29                                                    else {
30             1                                  8      plan tests => 14;
31                                                    }
32                                                    
33             1                                431   $sb->create_dbs($master_dbh, ['test']);
34             1                              73261   $master_dbh->do('CREATE TABLE test.t (a INT)');
35             1                                 11   my $i = 0;
36                                                    MaatkitTest::wait_until(
37                                                       sub {
38             1                    1            39         my $r;
39             1                                  4         eval {
40             1                                  3            $r = $slave_dbh->selectrow_arrayref('SHOW TABLES FROM test LIKE "t"');
41                                                          };
42    ***      1     50     50                  345         return 1 if ($r->[0] || '') eq 't';
43    ***      0      0                           0         diag('Waiting for CREATE TABLE to replicate...') unless $i++;
44    ***      0                                  0         return 0;
45                                                       },
46             1                                 21      0.5,
47                                                       30,
48                                                    );
49                                                    
50                                                    # Bust replication
51             1                              78609   $slave_dbh->do('DROP TABLE test.t');
52             1                                659   $master_dbh->do('INSERT INTO test.t SELECT 1');
53             1                              20384   my $output = `/tmp/12346/use -e 'show slave status'`;
54             1                                115   like($output, qr/Table 'test.t' doesn't exist'/, 'It is busted');
55                                                    
56                                                    # Start an instance
57             1                             198146   diag(`$trunk/mk-slave-restart/mk-slave-restart --max-sleep .25 -h 127.0.0.1 -P 12346 -u msandbox -p msandbox --daemonize --pid /tmp/mk-slave-restart.pid --log /tmp/mk-slave-restart.log`);
58             1                              19488   $output = `ps -eaf | grep 'mk-slave-restart \-\-max\-sleep ' | grep -v grep | grep -v mk-slave-restart.t`;
59             1                                 57   like($output, qr/mk-slave-restart --max/, 'It lives');
60                                                    
61             1                                558   unlike($output, qr/Table 'test.t' doesn't exist'/, 'It is not busted');
62                                                    
63             1                                456   ok(-f '/tmp/mk-slave-restart.pid', 'PID file created');
64             1                                395   ok(-f '/tmp/mk-slave-restart.log', 'Log file created');
65                                                    
66             1                                408   my ($pid) = $output =~ /\s+(\d+)\s+/;
67             1                               3921   $output = `cat /tmp/mk-slave-restart.pid`;
68             1                                 35   is($output, $pid, 'PID file has correct PID');
69                                                    
70             1                             103530   diag(`$trunk/mk-slave-restart/mk-slave-restart --stop -q`);
71             1                             1000362   sleep 1;
72             1                              35002   $output = `ps -eaf | grep mk-slave-restart | grep -v grep`;
73             1                                 89   unlike($output, qr/mk-slave-restart --max/, 'It is dead');
74                                                    
75             1                              13568   diag(`rm -f /tmp/mk-slave-re*`);
76             1                                238   ok(! -f '/tmp/mk-slave-restart.pid', 'PID file removed');
77                                                    
78                                                    # #############################################################################
79                                                    # Issue 118: mk-slave-restart --error-numbers option is broken
80                                                    # #############################################################################
81             1                             171366   $output = `$trunk/mk-slave-restart/mk-slave-restart --stop --sentinel /tmp/mk-slave-restartup --error-numbers=1205,1317`;
82             1                                 54   like($output, qr{Successfully created file /tmp/mk-slave-restartup}, '--error-numbers works (issue 118)');
83                                                    
84             1                               7515   diag(`rm -f /tmp/mk-slave-re*`);
85                                                    
86                                                    # #############################################################################
87                                                    # Issue 459: mk-slave-restart --error-text is broken
88                                                    # #############################################################################
89                                                    # Bust replication again.  At this point, the master has test.t but
90                                                    # the slave does not.
91             1                                534   $master_dbh->do('DROP TABLE IF EXISTS test.t');
92             1                              99995   $master_dbh->do('CREATE TABLE test.t (a INT)');
93             1                             1000269   sleep 1;
94             1                                688   $slave_dbh->do('DROP TABLE test.t');
95             1                                617   $master_dbh->do('INSERT INTO test.t SELECT 1');
96             1                              19769   $output = `/tmp/12346/use -e 'show slave status'`;
97             1                                 92   like(
98                                                       $output,
99                                                       qr/Table 'test.t' doesn't exist'/,
100                                                      'It is busted again'
101                                                   );
102                                                   
103                                                   # Start an instance
104            1                             683655   $output = `$trunk/mk-slave-restart/mk-slave-restart --max-sleep .25 -h 127.0.0.1 -P 12346 -u msandbox -p msandbox --error-text "doesn't exist" --run-time 1s 2>&1`;
105            1                                 89   unlike(
106                                                      $output,
107                                                      qr/Error does not match/,
108                                                      '--error-text works (issue 459)'
109                                                   );
110                                                   
111                                                   # ###########################################################################
112                                                   # Issue 391: Add --pid option to all scripts
113                                                   # ###########################################################################
114            1                               7835   `touch /tmp/mk-script.pid`;
115            1                             191850   $output = `$trunk/mk-slave-restart/mk-slave-restart --max-sleep .25 -h 127.0.0.1 -P 12346 -u msandbox -p msandbox --pid /tmp/mk-script.pid 2>&1`;
116            1                                 56   like(
117                                                      $output,
118                                                      qr{PID file /tmp/mk-script.pid already exists},
119                                                      'Dies if PID file already exists (--pid without --daemonize) (issue 391)'
120                                                   );
121            1                               4438   `rm -rf /tmp/mk-script.pid`;
122                                                   
123                                                   # #############################################################################
124                                                   # Issue 662: Option maxlength does not exist
125                                                   # #############################################################################
126            1                             2139200   my $ret = system("$trunk/mk-slave-restart/mk-slave-restart -h 127.0.0.1 -P 12346 -u msandbox -p msandbox --monitor --stop --max-sleep 1 --run-time 1 >/dev/null 2>&1");
127            1                                 76   is(
128                                                      $ret >> 8,
129                                                      0,
130                                                      "--monitor --stop doesn't cause error"
131                                                   );
132                                                   
133                                                   # #############################################################################
134                                                   #  Issue 673: Use of uninitialized value in numeric gt (>)
135                                                   # #############################################################################
136            1                             2182871   $output = `$trunk/mk-slave-restart/mk-slave-restart --monitor  --error-numbers 1205,1317 --quiet -F /tmp/12346/my.sandbox.cnf  --run-time 1 2>&1`;
137            1                                 66   is(
138                                                      $output,
139                                                      '',
140                                                      'No error with --quiet (issue 673)'
141                                                   );
142                                                   
143                                                   # #############################################################################
144                                                   # Done.
145                                                   # #############################################################################
146            1                              13315   diag(`rm -f /tmp/mk-slave-re*`);
147            1                                224   $sb->wipe_clean($master_dbh);
148            1                                837   $sb->wipe_clean($slave_dbh);
149            1                                  7   exit;


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
4     ***     50      0      1   unless $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}
23    ***     50      0      1   if (not $master_dbh) { }
      ***     50      0      1   elsif (not $slave_dbh) { }
42    ***     50      1      0   if ($$r[0] || '') eq 't'
43    ***      0      0      0   unless $i++


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
4     ***     33      0      0      1   $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      1      0   $$r[0] || ''


Covered Subroutines
-------------------

Subroutine Count Location             
---------- ----- ---------------------
BEGIN          1 mk-slave-restart.t:10
BEGIN          1 mk-slave-restart.t:11
BEGIN          1 mk-slave-restart.t:12
BEGIN          1 mk-slave-restart.t:14
BEGIN          1 mk-slave-restart.t:15
BEGIN          1 mk-slave-restart.t:4 
BEGIN          1 mk-slave-restart.t:9 
__ANON__       1 mk-slave-restart.t:38


