---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...-table-sync/mk-table-sync   48.3   32.6   29.0   57.9    n/a  100.0   42.7
Total                          48.3   32.6   29.0   57.9    n/a  100.0   42.7
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:09:15 2010
Finish:       Fri Feb  5 22:09:15 2010

Run:          ./001_compare_conflict_col.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:09:17 2010
Finish:       Fri Feb  5 22:09:17 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:09:21 2010
Finish:       Fri Feb  5 22:09:29 2010

Run:          ./102_triggers.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:09:33 2010
Finish:       Fri Feb  5 22:09:36 2010

Run:          ./103_force_index.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:09:40 2010
Finish:       Fri Feb  5 22:09:41 2010

Run:          ./104_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:09:45 2010
Finish:       Fri Feb  5 22:09:46 2010

Run:          ./105_master_master.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:09:50 2010
Finish:       Fri Feb  5 22:10:04 2010

Run:          ./106_lock_and_rename.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:10:08 2010
Finish:       Fri Feb  5 22:10:10 2010

Run:          ./107_option_sanity.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:10:14 2010
Finish:       Fri Feb  5 22:10:15 2010

Run:          ./108_sync_to_differnt_db.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:10:19 2010
Finish:       Fri Feb  5 22:10:27 2010

Run:          ./109_columns.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:10:31 2010
Finish:       Fri Feb  5 22:10:33 2010

Run:          ./110_replicate_do_db.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:10:37 2010
Finish:       Fri Feb  5 22:10:47 2010

Run:          ./111_lock_level.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:10:51 2010
Finish:       Fri Feb  5 22:10:52 2010

Run:          ./112_float_precision.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:10:56 2010
Finish:       Fri Feb  5 22:10:58 2010

Run:          ./113_specify_column_or_index.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:11:02 2010
Finish:       Fri Feb  5 22:11:04 2010

Run:          ./114_filters.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:11:08 2010
Finish:       Fri Feb  5 22:11:09 2010

Run:          ./115_bidirectional.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:11:13 2010
Finish:       Fri Feb  5 22:11:23 2010

Run:          ./201_issue_22.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:11:28 2010
Finish:       Fri Feb  5 22:11:29 2010

Run:          ./202_issue_79.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:11:33 2010
Finish:       Fri Feb  5 22:11:37 2010

Run:          ./203_issue_96.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:11:41 2010
Finish:       Fri Feb  5 22:11:43 2010

Run:          ./204_issue_262.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:11:48 2010
Finish:       Fri Feb  5 22:11:48 2010

Run:          ./205_issue_218.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:11:53 2010
Finish:       Fri Feb  5 22:11:53 2010

Run:          ./206_issue_408.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:11:58 2010
Finish:       Fri Feb  5 22:12:04 2010

Run:          ./207_issue_616.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:12:09 2010
Finish:       Fri Feb  5 22:12:10 2010

Run:          ./208_issue_627.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:12:15 2010
Finish:       Fri Feb  5 22:12:16 2010

Run:          ./209_issue_631.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:12:21 2010
Finish:       Fri Feb  5 22:12:21 2010

Run:          ./210_issue_560.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:12:26 2010
Finish:       Fri Feb  5 22:12:29 2010

Run:          ./211_issue_634.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:12:34 2010
Finish:       Fri Feb  5 22:12:34 2010

Run:          ./212_issue_644.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:12:39 2010
Finish:       Fri Feb  5 22:12:40 2010

Run:          ./213_issue_804.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb  5 22:12:45 2010
Finish:       Fri Feb  5 22:12:46 2010

/home/daniel/dev/maatkit/mk-table-sync/mk-table-sync

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program synchronizes data efficiently between two MySQL tables, which
4                                                     # can be on different servers.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23            29                   29           176   use strict;
              29                                 79   
              29                                204   
24            29                   29           184   use warnings FATAL => 'all';
              29                                 73   
              29                                193   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5713 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 5568
32                                                    # ###########################################################################
33                                                    package OptionParser;
34                                                    
35            29                   29           187   use strict;
              29                                 81   
              29                                139   
36            29                   29           177   use warnings FATAL => 'all';
              29                                 76   
              29                                136   
37                                                    
38            29                   29           275   use Getopt::Long;
              29                                 99   
              29                                198   
39            29                   29           220   use List::Util qw(max);
              29                                 74   
              29                                333   
40            29                   29           191   use English qw(-no_match_vars);
              29                                 79   
              29                                197   
41                                                    
42    ***     29            50     29           210   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 84   
              29                                472   
43                                                    
44                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
45                                                    
46                                                    my %attributes = (
47                                                       'type'       => 1,
48                                                       'short form' => 1,
49                                                       'group'      => 1,
50                                                       'default'    => 1,
51                                                       'cumulative' => 1,
52                                                       'negatable'  => 1,
53                                                    );
54                                                    
55                                                    sub new {
56             5                    5           153      my ( $class, %args ) = @_;
57             5                                 54      foreach my $arg ( qw(description) ) {
58    ***      5     50                          55         die "I need a $arg argument" unless $args{$arg};
59                                                       }
60             5                                148      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
61    ***      5            33                   43      $program_name ||= $PROGRAM_NAME;
62    ***      5            33                   84      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
63                                                    
64    ***      5     50     50                  492      my $self = {
      ***                   50                        
65                                                          description    => $args{description},
66                                                          prompt         => $args{prompt} || '<options>',
67                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
68                                                          dp             => $args{dp}     || undef,
69                                                          program_name   => $program_name,
70                                                          opts           => {},
71                                                          got_opts       => 0,
72                                                          short_opts     => {},
73                                                          defaults       => {},
74                                                          groups         => {},
75                                                          allowed_groups => {},
76                                                          errors         => [],
77                                                          rules          => [],  # desc of rules for --help
78                                                          mutex          => [],  # rule: opts are mutually exclusive
79                                                          atleast1       => [],  # rule: at least one opt is required
80                                                          disables       => {},  # rule: opt disables other opts 
81                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
82                                                          default_files  => [
83                                                             "/etc/maatkit/maatkit.conf",
84                                                             "/etc/maatkit/$program_name.conf",
85                                                             "$home/.maatkit.conf",
86                                                             "$home/.$program_name.conf",
87                                                          ],
88                                                       };
89             5                                 98      return bless $self, $class;
90                                                    }
91                                                    
92                                                    sub get_specs {
93             5                    5            35      my ( $self, $file ) = @_;
94             5                                 57      my @specs = $self->_pod_to_specs($file);
95             5                                261      $self->_parse_specs(@specs);
96             5                                 47      return;
97                                                    }
98                                                    
99                                                    sub get_defaults_files {
100            5                    5            28      my ( $self ) = @_;
101            5                                 22      return @{$self->{default_files}};
               5                                 76   
102                                                   }
103                                                   
104                                                   sub _pod_to_specs {
105            5                    5            31      my ( $self, $file ) = @_;
106   ***      5            50                   45      $file ||= __FILE__;
107   ***      5     50                         299      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
108                                                   
109            5                                206      my %types = (
110                                                         string => 's', # standard Getopt type
111                                                         'int'  => 'i', # standard Getopt type
112                                                         float  => 'f', # standard Getopt type
113                                                         Hash   => 'H', # hash, formed from a comma-separated list
114                                                         hash   => 'h', # hash as above, but only if a value is given
115                                                         Array  => 'A', # array, similar to Hash
116                                                         array  => 'a', # array, similar to hash
117                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
118                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
119                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
120                                                      );
121            5                                 29      my @specs = ();
122            5                                 21      my @rules = ();
123            5                                 19      my $para;
124                                                   
125            5                                 62      local $INPUT_RECORD_SEPARATOR = '';
126            5                               1155      while ( $para = <$fh> ) {
127         5055    100                       53530         next unless $para =~ m/^=head1 OPTIONS/;
128            5                                 26         last;
129                                                      }
130                                                   
131            5                                 51      while ( $para = <$fh> ) {
132           15    100                         125         last if $para =~ m/^=over/;
133           10                                 43         chomp $para;
134           10                                130         $para =~ s/\s+/ /g;
135           10                                410         $para =~ s/$POD_link_re/$1/go;
136           10                                 36         MKDEBUG && _d('Option rule:', $para);
137           10                                136         push @rules, $para;
138                                                      }
139                                                   
140   ***      5     50                          34      die 'POD has no OPTIONS section' unless $para;
141                                                   
142            5                                 22      do {
143          300    100                        3229         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
144          295                               1219            chomp $para;
145          295                                839            MKDEBUG && _d($para);
146          295                               1012            my %attribs;
147                                                   
148          295                               1635            $para = <$fh>; # read next paragraph, possibly attributes
149                                                   
150          295    100                        1670            if ( $para =~ m/: / ) { # attributes
151          220                               1558               $para =~ s/\s+\Z//g;
152          310                               2350               %attribs = map {
153          220                               1540                     my ( $attrib, $val) = split(/: /, $_);
154   ***    310     50                        2049                     die "Unrecognized attribute for --$option: $attrib"
155                                                                        unless $attributes{$attrib};
156          310                               2496                     ($attrib, $val);
157                                                                  } split(/; /, $para);
158          220    100                        1526               if ( $attribs{'short form'} ) {
159           65                                482                  $attribs{'short form'} =~ s/-//;
160                                                               }
161          220                               1411               $para = <$fh>; # read next paragraph, probably short help desc
162                                                            }
163                                                            else {
164           75                                269               MKDEBUG && _d('Option has no attributes');
165                                                            }
166                                                   
167          295                               2903            $para =~ s/\s+\Z//g;
168          295                               2966            $para =~ s/\s+/ /g;
169          295                               2408            $para =~ s/$POD_link_re/$1/go;
170                                                   
171          295                               2404            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
172          295                                915            MKDEBUG && _d('Short help:', $para);
173                                                   
174   ***    295     50                        1748            die "No description after option spec $option" if $para =~ m/^=item/;
175                                                   
176          295    100                        2390            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
177           50                                198               $option = $base_option;
178           50                                285               $attribs{'negatable'} = 1;
179                                                            }
180                                                   
181          295    100                        8085            push @specs, {
                    100                               
                    100                               
                    100                               
                    100                               
      ***            50                               
182                                                               spec  => $option
183                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
184                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
185                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
186                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
187                                                               desc  => $para
188                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
189                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
190                                                            };
191                                                         }
192          300                               5068         while ( $para = <$fh> ) {
193   ***    620     50                        3256            last unless $para;
194                                                   
195                                                   
196          620    100                        4888            if ( $para =~ m/^=head1/ ) {
197            5                                 26               $para = undef; # Can't 'last' out of a do {} block.
198            5                                 39               last;
199                                                            }
200          615    100                        6368            last if $para =~ m/^=item --/;
201                                                         }
202                                                      } while ( $para );
203                                                   
204   ***      5     50                          39      die 'No valid specs in POD OPTIONS' unless @specs;
205                                                   
206            5                                103      close $fh;
207            5                                 27      return @specs, @rules;
208                                                   }
209                                                   
210                                                   sub _parse_specs {
211            5                    5            98      my ( $self, @specs ) = @_;
212            5                                 42      my %disables; # special rule that requires deferred checking
213                                                   
214            5                                 47      foreach my $opt ( @specs ) {
215          305    100                        1482         if ( ref $opt ) { # It's an option spec, not a rule.
216                                                            MKDEBUG && _d('Parsing opt spec:',
217          295                                846               map { ($_, '=>', $opt->{$_}) } keys %$opt);
218                                                   
219          295                               3034            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
220   ***    295     50                        1707            if ( !$long ) {
221   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
222                                                            }
223          295                               1442            $opt->{long} = $long;
224                                                   
225   ***    295     50                        1855            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
226          295                               1913            $self->{opts}->{$long} = $opt;
227                                                   
228   ***    295     50                        1618            if ( length $long == 1 ) {
229   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
230   ***      0                                  0               $self->{short_opts}->{$long} = $long;
231                                                            }
232                                                   
233          295    100                        1569            if ( $short ) {
234   ***     65     50                         404               die "Duplicate short option -$short"
235                                                                  if exists $self->{short_opts}->{$short};
236           65                                371               $self->{short_opts}->{$short} = $long;
237           65                                320               $opt->{short} = $short;
238                                                            }
239                                                            else {
240          230                               1086               $opt->{short} = undef;
241                                                            }
242                                                   
243          295    100                        2147            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
244          295    100                        2047            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
245   ***    295     50                        2429            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
246                                                   
247   ***    295            50                 1733            $opt->{group} ||= 'default';
248          295                               2053            $self->{groups}->{ $opt->{group} }->{$long} = 1;
249                                                   
250          295                               4979            $opt->{value} = undef;
251          295                               1358            $opt->{got}   = 0;
252                                                   
253          295                               2200            my ( $type ) = $opt->{spec} =~ m/=(.)/;
254          295                               1440            $opt->{type} = $type;
255          295                                825            MKDEBUG && _d($long, 'type:', $type);
256                                                   
257   ***    295     50     66                 3449            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
258   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
259                                                                  . "was given when this OptionParser object was created";
260                                                            }
261                                                   
262          295    100    100                 3020            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
263                                                   
264          295    100                        2573            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
265   ***     70     50                         558               $self->{defaults}->{$long} = defined $def ? $def : 1;
266           70                                221               MKDEBUG && _d($long, 'default:', $def);
267                                                            }
268                                                   
269          295    100                        1538            if ( $long eq 'config' ) {
270            5                                 56               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
271                                                            }
272                                                   
273   ***    295     50                        2144            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
274   ***      0                                  0               $disables{$long} = $dis;
275   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
276                                                            }
277                                                   
278          295                               1950            $self->{opts}->{$long} = $opt;
279                                                         }
280                                                         else { # It's an option rule, not a spec.
281           10                                 30            MKDEBUG && _d('Parsing rule:', $opt); 
282           10                                 37            push @{$self->{rules}}, $opt;
              10                                 84   
283           10                                 76            my @participants = $self->_get_participants($opt);
284           10                                 46            my $rule_ok = 0;
285                                                   
286           10    100                         178            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
287            5                                 23               $rule_ok = 1;
288            5                                 22               push @{$self->{mutex}}, \@participants;
               5                                 44   
289            5                                 20               MKDEBUG && _d(@participants, 'are mutually exclusive');
290                                                            }
291           10    100                         123            if ( $opt =~ m/at least one|one and only one/ ) {
292            5                                 20               $rule_ok = 1;
293            5                                 18               push @{$self->{atleast1}}, \@participants;
               5                                 38   
294            5                                 20               MKDEBUG && _d(@participants, 'require at least one');
295                                                            }
296   ***     10     50                          73            if ( $opt =~ m/default to/ ) {
297   ***      0                                  0               $rule_ok = 1;
298   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
299   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
300                                                            }
301   ***     10     50                          63            if ( $opt =~ m/restricted to option groups/ ) {
302   ***      0                                  0               $rule_ok = 1;
303   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
304   ***      0                                  0               my @groups = split(',', $groups);
305   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
306   ***      0                                  0                  s/\s+//;
307   ***      0                                  0                  $_ => 1;
308                                                               } @groups;
309                                                            }
310                                                   
311   ***     10     50                          90            die "Unrecognized option rule: $opt" unless $rule_ok;
312                                                         }
313                                                      }
314                                                   
315            5                                 52      foreach my $long ( keys %disables ) {
316   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
317   ***      0                                  0         $self->{disables}->{$long} = \@participants;
318   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
319                                                      }
320                                                   
321            5                                 55      return; 
322                                                   }
323                                                   
324                                                   sub _get_participants {
325           10                   10            60      my ( $self, $str ) = @_;
326           10                                 39      my @participants;
327           10                                162      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
328   ***     25     50                         169         die "Option --$long does not exist while processing rule $str"
329                                                            unless exists $self->{opts}->{$long};
330           25                                150         push @participants, $long;
331                                                      }
332           10                                 37      MKDEBUG && _d('Participants for', $str, ':', @participants);
333           10                                 91      return @participants;
334                                                   }
335                                                   
336                                                   sub opts {
337   ***      0                    0             0      my ( $self ) = @_;
338   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
339   ***      0                                  0      return %opts;
340                                                   }
341                                                   
342                                                   sub short_opts {
343   ***      0                    0             0      my ( $self ) = @_;
344   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
345   ***      0                                  0      return %short_opts;
346                                                   }
347                                                   
348                                                   sub set_defaults {
349   ***      0                    0             0      my ( $self, %defaults ) = @_;
350   ***      0                                  0      $self->{defaults} = {};
351   ***      0                                  0      foreach my $long ( keys %defaults ) {
352   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
353                                                            unless exists $self->{opts}->{$long};
354   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
355   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
356                                                      }
357   ***      0                                  0      return;
358                                                   }
359                                                   
360                                                   sub get_defaults {
361   ***      0                    0             0      my ( $self ) = @_;
362   ***      0                                  0      return $self->{defaults};
363                                                   }
364                                                   
365                                                   sub get_groups {
366   ***      0                    0             0      my ( $self ) = @_;
367   ***      0                                  0      return $self->{groups};
368                                                   }
369                                                   
370                                                   sub _set_option {
371           40                   40           236      my ( $self, $opt, $val ) = @_;
372   ***     40      0                         108      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
373                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
374                                                               : die "Getopt::Long gave a nonexistent option: $opt";
375                                                   
376           40                                100      $opt = $self->{opts}->{$long};
377   ***     40     50                         306      if ( $opt->{is_cumulative} ) {
378   ***      0                                  0         $opt->{value}++;
379                                                      }
380                                                      else {
381           40                                197         $opt->{value} = $val;
382                                                      }
383           40                                172      $opt->{got} = 1;
384           40                                195      MKDEBUG && _d('Got option', $long, '=', $val);
385                                                   }
386                                                   
387                                                   sub get_opts {
388            5                    5            31      my ( $self ) = @_; 
389                                                   
390            5                                 20      foreach my $long ( keys %{$self->{opts}} ) {
               5                                142   
391          295                               1652         $self->{opts}->{$long}->{got} = 0;
392          295    100                        3347         $self->{opts}->{$long}->{value}
                    100                               
393                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
394                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
395                                                            : undef;
396                                                      }
397            5                                 52      $self->{got_opts} = 0;
398                                                   
399            5                                 34      $self->{errors} = [];
400                                                   
401   ***      5     50     33                   92      if ( @ARGV && $ARGV[0] eq "--config" ) {
402   ***      0                                  0         shift @ARGV;
403   ***      0                                  0         $self->_set_option('config', shift @ARGV);
404                                                      }
405   ***      5     50                          77      if ( $self->has('config') ) {
406            5                                 31         my @extra_args;
407            5                                 50         foreach my $filename ( split(',', $self->get('config')) ) {
408           20                                 74            eval {
409           20                                139               push @extra_args, $self->_read_config_file($filename);
410                                                            };
411   ***     20     50                         151            if ( $EVAL_ERROR ) {
412   ***     20     50                         119               if ( $self->got('config') ) {
413   ***      0                                  0                  die $EVAL_ERROR;
414                                                               }
415                                                               elsif ( MKDEBUG ) {
416                                                                  _d($EVAL_ERROR);
417                                                               }
418                                                            }
419                                                         }
420            5                                 36         unshift @ARGV, @extra_args;
421                                                      }
422                                                   
423            5                                 94      Getopt::Long::Configure('no_ignore_case', 'bundling');
424                                                      GetOptions(
425          290                   40          2981         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              40                                254   
             295                               1546   
426            5                                 58         grep   { $_->{long} ne 'config' } # --config is handled specially above.
427   ***      5     50                          22         values %{$self->{opts}}
428                                                      ) or $self->save_error('Error parsing options');
429                                                   
430   ***      5     50     33                  707      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
431   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
432                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
433                                                               or die "Cannot print: $OS_ERROR";
434   ***      0                                  0         exit 0;
435                                                      }
436                                                   
437   ***      5     50     33                   75      if ( @ARGV && $self->{strict} ) {
438   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
439                                                      }
440                                                   
441            5                                 20      foreach my $mutex ( @{$self->{mutex}} ) {
               5                                 42   
442            5                                 37         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
              10                                 74   
443   ***      5     50                          46         if ( @set > 1 ) {
444   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
445   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
446                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
447                                                                    . ' are mutually exclusive.';
448   ***      0                                  0            $self->save_error($err);
449                                                         }
450                                                      }
451                                                   
452            5                                 22      foreach my $required ( @{$self->{atleast1}} ) {
               5                                 45   
453            5                                 28         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
              15                                109   
454   ***      5     50                          45         if ( @set == 0 ) {
455   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
456   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
457                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
458   ***      0                                  0            $self->save_error("Specify at least one of $err");
459                                                         }
460                                                      }
461                                                   
462            5                                 20      foreach my $long ( keys %{$self->{opts}} ) {
               5                                 95   
463          295                               1504         my $opt = $self->{opts}->{$long};
464          295    100                        2162         if ( $opt->{got} ) {
      ***            50                               
465   ***     40     50                         260            if ( exists $self->{disables}->{$long} ) {
466   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
467   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
468   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
469                                                                  'because', $long,'disables them');
470                                                            }
471                                                   
472   ***     40     50                         267            if ( exists $self->{allowed_groups}->{$long} ) {
473                                                   
474   ***      0                                  0               my @restricted_groups = grep {
475   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
476   ***      0                                  0               } keys %{$self->{groups}};
477                                                   
478   ***      0                                  0               my @restricted_opts;
479   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
480   ***      0                                  0                  RESTRICTED_OPT:
481   ***      0                                  0                  foreach my $restricted_opt (
482                                                                     keys %{$self->{groups}->{$restricted_group}} )
483                                                                  {
484   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
485   ***      0      0                           0                     push @restricted_opts, $restricted_opt
486                                                                        if $self->{opts}->{$restricted_opt}->{got};
487                                                                  }
488                                                               }
489                                                   
490   ***      0      0                           0               if ( @restricted_opts ) {
491   ***      0                                  0                  my $err;
492   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
493   ***      0                                  0                     $err = "--$restricted_opts[0]";
494                                                                  }
495                                                                  else {
496   ***      0                                  0                     $err = join(', ',
497   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
498   ***      0                                  0                               grep { $_ } 
499                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
500                                                                            )
501                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
502                                                                  }
503   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
504                                                               }
505                                                            }
506                                                   
507                                                         }
508                                                         elsif ( $opt->{is_required} ) { 
509   ***      0                                  0            $self->save_error("Required option --$long must be specified");
510                                                         }
511                                                   
512          295                               1467         $self->_validate_type($opt);
513                                                      }
514                                                   
515            5                                 55      $self->{got_opts} = 1;
516            5                                 32      return;
517                                                   }
518                                                   
519                                                   sub _validate_type {
520          295                  295          1386      my ( $self, $opt ) = @_;
521   ***    295    100     66                 3754      return unless $opt && $opt->{type};
522          170                                792      my $val = $opt->{value};
523                                                   
524   ***    170     50     66                 6171      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
                    100    100                        
                    100    100                        
      ***                   66                        
      ***                   66                        
525   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
526   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
527   ***      0      0                           0         if ( !$suffix ) {
528   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
529   ***      0             0                    0            $suffix = $s || 's';
530   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
531                                                               $opt->{long}, '(value:', $val, ')');
532                                                         }
533   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
534   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
535                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
536                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
537                                                                 :                  $num * 86400;   # Days
538   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
539   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
540                                                         }
541                                                         else {
542   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
543                                                         }
544                                                      }
545                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
546   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
547   ***      0                                  0         my $prev = {};
548   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
549   ***      0      0                           0         if ( $from_key ) {
550   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
551   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
552                                                         }
553   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
554   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
555                                                      }
556                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
557   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
558   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
559   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
560   ***      0      0                           0         if ( defined $num ) {
561   ***      0      0                           0            if ( $factor ) {
562   ***      0                                  0               $num *= $factor_for{$factor};
563   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
564                                                                  'to num', $num, '* factor', $factor);
565                                                            }
566   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
567                                                         }
568                                                         else {
569   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
570                                                         }
571                                                      }
572                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
573           25           100                  318         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
              15                                120   
574                                                      }
575                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
576   ***      5            50                  108         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
577                                                      }
578                                                      else {
579          140                                424         MKDEBUG && _d('Nothing to validate for option',
580                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
581                                                      }
582                                                   
583          170                                791      return;
584                                                   }
585                                                   
586                                                   sub get {
587          600                  600          4173      my ( $self, $opt ) = @_;
588          600    100                        3797      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
589   ***    600     50     33                 8165      die "Option $opt does not exist"
590                                                         unless $long && exists $self->{opts}->{$long};
591          600                               7353      return $self->{opts}->{$long}->{value};
592                                                   }
593                                                   
594                                                   sub got {
595           27                   27           184      my ( $self, $opt ) = @_;
596   ***     27     50                         183      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
597   ***     27     50     33                  402      die "Option $opt does not exist"
598                                                         unless $long && exists $self->{opts}->{$long};
599           27                                293      return $self->{opts}->{$long}->{got};
600                                                   }
601                                                   
602                                                   sub has {
603           95                   95           523      my ( $self, $opt ) = @_;
604           95    100                         641      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
605           95    100                        1211      return defined $long ? exists $self->{opts}->{$long} : 0;
606                                                   }
607                                                   
608                                                   sub set {
609           10                   10            76      my ( $self, $opt, $val ) = @_;
610   ***     10     50                          67      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
611   ***     10     50     33                  155      die "Option $opt does not exist"
612                                                         unless $long && exists $self->{opts}->{$long};
613           10                                 67      $self->{opts}->{$long}->{value} = $val;
614           10                                 44      return;
615                                                   }
616                                                   
617                                                   sub save_error {
618   ***      0                    0             0      my ( $self, $error ) = @_;
619   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
620                                                   }
621                                                   
622                                                   sub errors {
623   ***      0                    0             0      my ( $self ) = @_;
624   ***      0                                  0      return $self->{errors};
625                                                   }
626                                                   
627                                                   sub prompt {
628   ***      0                    0             0      my ( $self ) = @_;
629   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
630                                                   }
631                                                   
632                                                   sub descr {
633   ***      0                    0             0      my ( $self ) = @_;
634   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
635                                                                 . "  For more details, please use the --help option, "
636                                                                 . "or try 'perldoc $PROGRAM_NAME' "
637                                                                 . "for complete documentation.";
638   ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
639                                                         unless $ENV{DONT_BREAK_LINES};
640   ***      0                                  0      $descr =~ s/ +$//mg;
641   ***      0                                  0      return $descr;
642                                                   }
643                                                   
644                                                   sub usage_or_errors {
645            5                    5            28      my ( $self ) = @_;
646   ***      5     50                          44      if ( $self->{opts}->{help}->{got} ) {
      ***      5     50                          42   
647   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
648   ***      0                                  0         exit 0;
649                                                      }
650                                                      elsif ( scalar @{$self->{errors}} ) {
651   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
652   ***      0                                  0         exit 0;
653                                                      }
654            5                                 22      return;
655                                                   }
656                                                   
657                                                   sub print_errors {
658   ***      0                    0             0      my ( $self ) = @_;
659   ***      0                                  0      my $usage = $self->prompt() . "\n";
660   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
661   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
662                                                                 . "\n";
663                                                      }
664   ***      0                                  0      return $usage . "\n" . $self->descr();
665                                                   }
666                                                   
667                                                   sub print_usage {
668   ***      0                    0             0      my ( $self ) = @_;
669   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
670   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
671                                                   
672   ***      0      0                           0      my $maxl = max(
673   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
674                                                         @opts);
675                                                   
676   ***      0      0                           0      my $maxs = max(0,
677   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
678   ***      0                                  0         values %{$self->{short_opts}});
679                                                   
680   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
681   ***      0                                  0      my $rcol = 80 - $lcol - 6;
682   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
683                                                   
684   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
685                                                   
686   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
687                                                   
688   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
689   ***      0                                  0      push @groups, 'default';
690                                                   
691   ***      0                                  0      foreach my $group ( reverse @groups ) {
692   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
693   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
694   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
695                                                            grep { $_->{group} eq $group }
696                                                            @opts )
697                                                         {
698   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
699   ***      0                                  0            my $short = $opt->{short};
700   ***      0                                  0            my $desc  = $opt->{desc};
701   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
702   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
703   ***      0             0                    0               $s    ||= 's';
704   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
705   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
706                                                                      . "d=days; if no suffix, $s is used.";
707                                                            }
708   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
709   ***      0                                  0            $desc =~ s/ +$//mg;
710   ***      0      0                           0            if ( $short ) {
711   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
712                                                            }
713                                                            else {
714   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
715                                                            }
716                                                         }
717                                                      }
718                                                   
719   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
720   ***      0                                  0         $usage .= "\nRules:\n\n";
721   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
722                                                      }
723   ***      0      0                           0      if ( $self->{dp} ) {
724   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
725                                                      }
726   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
727   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
728   ***      0                                  0         my $val   = $opt->{value};
729   ***      0             0                    0         my $type  = $opt->{type} || '';
730   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
731   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
732                                                                   : !defined $val             ? '(No value)'
733                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
734                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
735                                                                   : $type =~ m/A|a/           ? join(',', @$val)
736                                                                   :                             $val;
737   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
738                                                      }
739   ***      0                                  0      return $usage;
740                                                   }
741                                                   
742                                                   sub prompt_noecho {
743   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
744   ***      0                                  0      my ( $prompt ) = @_;
745   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
746   ***      0      0                           0      print $prompt
747                                                         or die "Cannot print: $OS_ERROR";
748   ***      0                                  0      my $response;
749   ***      0                                  0      eval {
750   ***      0                                  0         require Term::ReadKey;
751   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
752   ***      0                                  0         chomp($response = <STDIN>);
753   ***      0                                  0         Term::ReadKey::ReadMode('normal');
754   ***      0      0                           0         print "\n"
755                                                            or die "Cannot print: $OS_ERROR";
756                                                      };
757   ***      0      0                           0      if ( $EVAL_ERROR ) {
758   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
759                                                      }
760   ***      0                                  0      return $response;
761                                                   }
762                                                   
763                                                   if ( MKDEBUG ) {
764                                                      print '# ', $^X, ' ', $], "\n";
765                                                      my $uname = `uname -a`;
766                                                      if ( $uname ) {
767                                                         $uname =~ s/\s+/ /g;
768                                                         print "# $uname\n";
769                                                      }
770                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
771                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
772                                                         ($main::SVN_REV || ''), __LINE__);
773                                                      print('# Arguments: ',
774                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
775                                                   }
776                                                   
777                                                   sub _read_config_file {
778           20                   20           114      my ( $self, $filename ) = @_;
779   ***     20     50                          74      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
780   ***      0                                  0      my @args;
781   ***      0                                  0      my $prefix = '--';
782   ***      0                                  0      my $parse  = 1;
783                                                   
784                                                      LINE:
785   ***      0                                  0      while ( my $line = <$fh> ) {
786   ***      0                                  0         chomp $line;
787   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
788   ***      0                                  0         $line =~ s/\s+#.*$//g;
789   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
790   ***      0      0                           0         if ( $line eq '--' ) {
791   ***      0                                  0            $prefix = '';
792   ***      0                                  0            $parse  = 0;
793   ***      0                                  0            next LINE;
794                                                         }
795   ***      0      0      0                    0         if ( $parse
      ***             0                               
796                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
797                                                         ) {
798   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
799                                                         }
800                                                         elsif ( $line =~ m/./ ) {
801   ***      0                                  0            push @args, $line;
802                                                         }
803                                                         else {
804   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
805                                                         }
806                                                      }
807   ***      0                                  0      close $fh;
808   ***      0                                  0      return @args;
809                                                   }
810                                                   
811                                                   sub read_para_after {
812            5                    5            35      my ( $self, $file, $regex ) = @_;
813   ***      5     50                         298      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
814            5                                 49      local $INPUT_RECORD_SEPARATOR = '';
815            5                                 19      my $para;
816            5                                159      while ( $para = <$fh> ) {
817         4630    100                       46954         next unless $para =~ m/^=pod$/m;
818            5                                 30         last;
819                                                      }
820            5                                 48      while ( $para = <$fh> ) {
821          755    100                        7844         next unless $para =~ m/$regex/;
822            5                                 17         last;
823                                                      }
824            5                                 24      $para = <$fh>;
825            5                                 23      chomp($para);
826   ***      5     50                          94      close $fh or die "Can't close $file: $OS_ERROR";
827            5                                 22      return $para;
828                                                   }
829                                                   
830                                                   sub clone {
831   ***      0                    0             0      my ( $self ) = @_;
832                                                   
833   ***      0                                  0      my %clone = map {
834   ***      0                                  0         my $hashref  = $self->{$_};
835   ***      0                                  0         my $val_copy = {};
836   ***      0                                  0         foreach my $key ( keys %$hashref ) {
837   ***      0                                  0            my $ref = ref $hashref->{$key};
838   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
839   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
840   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
841                                                                              : $hashref->{$key};
842                                                         }
843   ***      0                                  0         $_ => $val_copy;
844                                                      } qw(opts short_opts defaults);
845                                                   
846   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
847   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
848                                                      }
849                                                   
850   ***      0                                  0      return bless \%clone;     
851                                                   }
852                                                   
853                                                   sub _d {
854   ***      0                    0             0      my ($package, undef, $line) = caller 0;
855   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
856   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
857                                                           @_;
858   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
859                                                   }
860                                                   
861                                                   1;
862                                                   
863                                                   # ###########################################################################
864                                                   # End OptionParser package
865                                                   # ###########################################################################
866                                                   
867                                                   # ###########################################################################
868                                                   # Quoter package 5697
869                                                   # ###########################################################################
870                                                   package Quoter;
871                                                   
872           29                   29           292   use strict;
              29                                 94   
              29                                251   
873           29                   29           186   use warnings FATAL => 'all';
              29                                 79   
              29                                216   
874           29                   29           178   use English qw(-no_match_vars);
              29                                 73   
              29                                181   
875                                                   
876   ***     29            50     29           199   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 77   
              29                                602   
877                                                   
878                                                   sub new {
879            5                    5            37      my ( $class ) = @_;
880            5                                 69      return bless {}, $class;
881                                                   }
882                                                   
883                                                   sub quote {
884          470                  470          2919      my ( $self, @vals ) = @_;
885          470                               2376      foreach my $val ( @vals ) {
886          628                               3578         $val =~ s/`/``/g;
887                                                      }
888          470                               2438      return join('.', map { '`' . $_ . '`' } @vals);
             628                               6113   
889                                                   }
890                                                   
891                                                   sub quote_val {
892          162                  162           929      my ( $self, $val, $is_numeric ) = @_;
893                                                   
894          162    100                         950      return 'NULL' unless defined $val;  # undef = NULL
895          154    100                         846      return "''" if $val eq '';          # blank string = ''
896                                                   
897   ***    152     50                         847      if ( !defined $is_numeric ) {
898          152    100                        1356         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
899                                                      }
900                                                   
901          152    100                        1035      return $val if $is_numeric;
902                                                   
903           77                                332      $val =~ s/(['\\])/\\$1/g;
904           77                                869      return "'$val'";
905                                                   }
906                                                   
907                                                   sub split_unquote {
908            7                    7            49      my ( $self, $db_tbl, $default_db ) = @_;
909            7                                 74      $db_tbl =~ s/`//g;
910            7                                 64      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
911   ***      7     50                          46      if ( !$tbl ) {
912            7                                 28         $tbl = $db;
913            7                                 31         $db  = $default_db;
914                                                      }
915            7                                 50      return ($db, $tbl);
916                                                   }
917                                                   
918                                                   sub literal_like {
919   ***      0                    0             0      my ( $self, $like ) = @_;
920   ***      0      0                           0      return unless $like;
921   ***      0                                  0      $like =~ s/([%_])/\\$1/g;
922   ***      0                                  0      return "'$like'";
923                                                   }
924                                                   
925                                                   1;
926                                                   
927                                                   # ###########################################################################
928                                                   # End Quoter package
929                                                   # ###########################################################################
930                                                   
931                                                   # ###########################################################################
932                                                   # DSNParser package 5266
933                                                   # ###########################################################################
934                                                   package DSNParser;
935                                                   
936           29                   29           211   use strict;
              29                                 74   
              29                                163   
937           29                   29           188   use warnings FATAL => 'all';
              29                                 72   
              29                                162   
938           29                   29           212   use English qw(-no_match_vars);
              29                                 76   
              29                                144   
939           29                   29           248   use Data::Dumper;
              29                                 67   
              29                                275   
940                                                   $Data::Dumper::Indent    = 0;
941                                                   $Data::Dumper::Quotekeys = 0;
942                                                   
943                                                   eval {
944                                                      require DBI;
945                                                   };
946                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
947                                                   
948   ***     29            50     29           190   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                302   
              29                                383   
949                                                   
950                                                   sub new {
951           30                   30           244      my ( $class, @opts ) = @_;
952           30                               1780      my $self = {
953                                                         opts => {
954                                                            A => {
955                                                               desc => 'Default character set',
956                                                               dsn  => 'charset',
957                                                               copy => 1,
958                                                            },
959                                                            D => {
960                                                               desc => 'Database to use',
961                                                               dsn  => 'database',
962                                                               copy => 1,
963                                                            },
964                                                            F => {
965                                                               desc => 'Only read default options from the given file',
966                                                               dsn  => 'mysql_read_default_file',
967                                                               copy => 1,
968                                                            },
969                                                            h => {
970                                                               desc => 'Connect to host',
971                                                               dsn  => 'host',
972                                                               copy => 1,
973                                                            },
974                                                            p => {
975                                                               desc => 'Password to use when connecting',
976                                                               dsn  => 'password',
977                                                               copy => 1,
978                                                            },
979                                                            P => {
980                                                               desc => 'Port number to use for connection',
981                                                               dsn  => 'port',
982                                                               copy => 1,
983                                                            },
984                                                            S => {
985                                                               desc => 'Socket file to use for connection',
986                                                               dsn  => 'mysql_socket',
987                                                               copy => 1,
988                                                            },
989                                                            u => {
990                                                               desc => 'User for login if not current user',
991                                                               dsn  => 'user',
992                                                               copy => 1,
993                                                            },
994                                                         },
995                                                      };
996           30                                194      foreach my $opt ( @opts ) {
997           10                                 40         MKDEBUG && _d('Adding extra property', $opt->{key});
998           10                                182         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
999                                                      }
1000          30                                388      return bless $self, $class;
1001                                                  }
1002                                                  
1003                                                  sub prop {
1004         241                  241          1488      my ( $self, $prop, $value ) = @_;
1005         241    100                        1384      if ( @_ > 2 ) {
1006           5                                 14         MKDEBUG && _d('Setting', $prop, 'property');
1007           5                                 31         $self->{$prop} = $value;
1008                                                     }
1009         241                               2115      return $self->{$prop};
1010                                                  }
1011                                                  
1012                                                  sub parse {
1013          66                   66        10334262      my ( $self, $dsn, $prev, $defaults ) = @_;
1014  ***     66     50                         443      if ( !$dsn ) {
1015  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1016  ***      0                                  0         return;
1017                                                     }
1018          66                                206      MKDEBUG && _d('Parsing', $dsn);
1019          66           100                  441      $prev     ||= {};
1020          66           100                  380      $defaults ||= {};
1021          66                                207      my %given_props;
1022          66                                237      my %final_props;
1023          66                                253      my %opts = %{$self->{opts}};
              66                               1163   
1024                                                  
1025          66                                717      foreach my $dsn_part ( split(/,/, $dsn) ) {
1026  ***    220     50                        2131         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1027         220                               1178            $given_props{$prop_key} = $prop_val;
1028                                                        }
1029                                                        else {
1030  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1031  ***      0                                  0            $given_props{h} = $dsn_part;
1032                                                        }
1033                                                     }
1034                                                  
1035          66                                449      foreach my $key ( keys %opts ) {
1036         545                               1314         MKDEBUG && _d('Finding value for', $key);
1037         545                               2117         $final_props{$key} = $given_props{$key};
1038         545    100    100                 5465         if (   !defined $final_props{$key}
      ***                   66                        
1039                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1040                                                        {
1041          12                                 58            $final_props{$key} = $prev->{$key};
1042          12                                 42            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1043                                                        }
1044         545    100                        2666         if ( !defined $final_props{$key} ) {
1045         313                               1199            $final_props{$key} = $defaults->{$key};
1046         313                               1058            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1047                                                        }
1048                                                     }
1049                                                  
1050          66                                400      foreach my $key ( keys %given_props ) {
1051  ***    220     50                        1081         die "Unrecognized DSN part '$key' in '$dsn'\n"
1052                                                           unless exists $opts{$key};
1053                                                     }
1054  ***     66     50                         395      if ( (my $required = $self->prop('required')) ) {
1055  ***      0                                  0         foreach my $key ( keys %$required ) {
1056  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1057                                                        }
1058                                                     }
1059                                                  
1060          66                                522      return \%final_props;
1061                                                  }
1062                                                  
1063                                                  sub parse_options {
1064           5                    5            26      my ( $self, $o ) = @_;
1065  ***      5     50                         141      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1066           5                                 42      my $dsn_string
1067                                                        = join(',',
1068          45    100                         228             map  { "$_=".$o->get($_); }
1069           5                                 56             grep { $o->has($_) && $o->get($_) }
1070           5                                 22             keys %{$self->{opts}}
1071                                                          );
1072           5                                 29      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1073           5                                 49      return $self->parse($dsn_string);
1074                                                  }
1075                                                  
1076                                                  sub as_string {
1077  ***      0                    0             0      my ( $self, $dsn ) = @_;
1078  ***      0      0                           0      return $dsn unless ref $dsn;
1079  ***      0      0                           0      return join(',',
1080  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1081  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1082                                                        sort keys %$dsn );
1083                                                  }
1084                                                  
1085                                                  sub usage {
1086  ***      0                    0             0      my ( $self ) = @_;
1087  ***      0                                  0      my $usage
1088                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1089                                                        . "  KEY  COPY  MEANING\n"
1090                                                        . "  ===  ====  =============================================\n";
1091  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1092  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1093  ***      0      0      0                    0         $usage .= "  $key    "
1094                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1095                                                               .  ($opts{$key}->{desc} || '[No description]')
1096                                                               . "\n";
1097                                                     }
1098  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1099  ***      0                                  0      return $usage;
1100                                                  }
1101                                                  
1102                                                  sub get_cxn_params {
1103          73                   73           949      my ( $self, $info ) = @_;
1104          73                                255      my $dsn;
1105          73                                247      my %opts = %{$self->{opts}};
              73                                889   
1106  ***     73            50                  488      my $driver = $self->prop('dbidriver') || '';
1107  ***     73     50                         402      if ( $driver eq 'Pg' ) {
1108  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1109  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1110  ***      0             0                    0                        grep { defined $info->{$_} }
1111                                                                       qw(h P));
1112                                                     }
1113                                                     else {
1114         170                               1521         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1115         365                               1665            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1116  ***     73            50                 1124                        grep { defined $info->{$_} }
1117                                                                       qw(F h P S A))
1118                                                           . ';mysql_read_default_group=client';
1119                                                     }
1120          73                                278      MKDEBUG && _d($dsn);
1121          73                                804      return ($dsn, $info->{u}, $info->{p});
1122                                                  }
1123                                                  
1124                                                  sub fill_in_dsn {
1125  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1126  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1127  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1128  ***      0                                  0      $user =~ s/@.*//;
1129  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1130  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1131  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1132  ***      0             0                    0      $dsn->{u} ||= $user;
1133  ***      0             0                    0      $dsn->{D} ||= $db;
1134                                                  }
1135                                                  
1136                                                  sub get_dbh {
1137          73                   73           600      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1138          73           100                  441      $opts ||= {};
1139  ***     73     50                         936      my $defaults = {
1140                                                        AutoCommit         => 0,
1141                                                        RaiseError         => 1,
1142                                                        PrintError         => 0,
1143                                                        ShowErrorStatement => 1,
1144                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1145                                                     };
1146          73                                521      @{$defaults}{ keys %$opts } = values %$opts;
              73                                358   
1147                                                  
1148  ***     73     50                         381      if ( !$have_dbi ) {
1149  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1150                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1151                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1152                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1153                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1154                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1155                                                  
1156                                                     }
1157                                                  
1158          73                                229      my $dbh;
1159          73                                285      my $tries = 2;
1160  ***     73            66                  937      while ( !$dbh && $tries-- ) {
1161                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1162          73                                215            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1163                                                  
1164          73                                240         eval {
1165          73                                737            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1166                                                  
1167  ***     73     50                         849            if ( $cxn_string =~ m/mysql/i ) {
1168          73                                250               my $sql;
1169                                                  
1170          73                                326               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1171                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1172          73                                193               MKDEBUG && _d($dbh, ':', $sql);
1173          73                              11839               $dbh->do($sql);
1174                                                  
1175  ***     73     50                         714               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1176  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1177  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1178  ***      0                                  0                  $dbh->do($sql);
1179  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1180  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1181  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1182                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1183                                                                 }
1184                                                                 else {
1185  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1186                                                                 }
1187                                                              }
1188                                                  
1189          73    100                         526               if ( $self->prop('set-vars') ) {
1190          24                                136                  $sql = "SET " . $self->prop('set-vars');
1191          24                                 73                  MKDEBUG && _d($dbh, ':', $sql);
1192          24                               2870                  $dbh->do($sql);
1193                                                              }
1194                                                           }
1195                                                        };
1196  ***     73     50     33                  943         if ( !$dbh && $EVAL_ERROR ) {
1197  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1198  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1199  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1200  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1201                                                           }
1202                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1203  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1204                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1205                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1206                                                                 . "DBD::mysql is not installed, try:\n"
1207                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1208                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1209                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1210                                                           }
1211  ***      0      0                           0            if ( !$tries ) {
1212  ***      0                                  0               die $EVAL_ERROR;
1213                                                           }
1214                                                        }
1215                                                     }
1216                                                  
1217          73                                210      MKDEBUG && _d('DBH info: ',
1218                                                        $dbh,
1219                                                        Dumper($dbh->selectrow_hashref(
1220                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1221                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1222                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1223                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1224                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1225                                                        '$DBI::VERSION:',        $DBI::VERSION,
1226                                                     );
1227                                                  
1228          73                                537      return $dbh;
1229                                                  }
1230                                                  
1231                                                  sub get_hostname {
1232  ***      0                    0             0      my ( $self, $dbh ) = @_;
1233  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1234  ***      0                                  0         return $host;
1235                                                     }
1236  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1237                                                        'SELECT /*!50038 @@hostname, */ 1');
1238  ***      0                                  0      return $hostname;
1239                                                  }
1240                                                  
1241                                                  sub disconnect {
1242  ***      0                    0             0      my ( $self, $dbh ) = @_;
1243  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1244  ***      0                                  0      $dbh->disconnect;
1245                                                  }
1246                                                  
1247                                                  sub print_active_handles {
1248  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1249  ***      0             0                    0      $level ||= 0;
1250  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1251                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1252                                                        or die "Cannot print: $OS_ERROR";
1253  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1254  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1255                                                     }
1256                                                  }
1257                                                  
1258                                                  sub copy {
1259  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1260  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1261  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1262  ***      0                                  0      my %new_dsn = map {
1263  ***      0                                  0         my $key = $_;
1264  ***      0                                  0         my $val;
1265  ***      0      0                           0         if ( $args{overwrite} ) {
1266  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1267                                                        }
1268                                                        else {
1269  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1270                                                        }
1271  ***      0                                  0         $key => $val;
1272  ***      0                                  0      } keys %{$self->{opts}};
1273  ***      0                                  0      return \%new_dsn;
1274                                                  }
1275                                                  
1276                                                  sub _d {
1277  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1278  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1279  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1280                                                          @_;
1281  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1282                                                  }
1283                                                  
1284                                                  1;
1285                                                  
1286                                                  # ###########################################################################
1287                                                  # End DSNParser package
1288                                                  # ###########################################################################
1289                                                  
1290                                                  # ###########################################################################
1291                                                  # VersionParser package 5266
1292                                                  # ###########################################################################
1293                                                  package VersionParser;
1294                                                  
1295          29                   29           231   use strict;
              29                                 91   
              29                                199   
1296          29                   29           184   use warnings FATAL => 'all';
              29                                 76   
              29                                177   
1297                                                  
1298          29                   29           200   use English qw(-no_match_vars);
              29                                 80   
              29                                625   
1299                                                  
1300  ***     29            50     29           191   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 73   
              29                                413   
1301                                                  
1302                                                  sub new {
1303          16                   16           147      my ( $class ) = @_;
1304          16                                199      bless {}, $class;
1305                                                  }
1306                                                  
1307                                                  sub parse {
1308          49                   49          2610      my ( $self, $str ) = @_;
1309          49                                778      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1310          49                                183      MKDEBUG && _d($str, 'parses to', $result);
1311          49                                415      return $result;
1312                                                  }
1313                                                  
1314                                                  sub version_ge {
1315          36                   36           259      my ( $self, $dbh, $target ) = @_;
1316          36    100                         326      if ( !$self->{$dbh} ) {
1317          13                                 49         $self->{$dbh} = $self->parse(
1318                                                           $dbh->selectrow_array('SELECT VERSION()'));
1319                                                     }
1320  ***     36     50                         501      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1321          36                                112      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
1322          36                                360      return $result;
1323                                                  }
1324                                                  
1325                                                  sub _d {
1326  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1327  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1328  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1329                                                          @_;
1330  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1331                                                  }
1332                                                  
1333                                                  1;
1334                                                  
1335                                                  # ###########################################################################
1336                                                  # End VersionParser package
1337                                                  # ###########################################################################
1338                                                  
1339                                                  # ###########################################################################
1340                                                  # TableSyncStream package 5697
1341                                                  # ###########################################################################
1342                                                  package TableSyncStream;
1343                                                  
1344          29                   29           201   use strict;
              29                                 74   
              29                                160   
1345          29                   29           189   use warnings FATAL => 'all';
              29                                 75   
              29                                153   
1346                                                  
1347          29                   29           181   use English qw(-no_match_vars);
              29                                 77   
              29                                147   
1348                                                  
1349  ***     29            50     29           240   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 81   
              29                                379   
1350                                                  
1351                                                  sub new {
1352  ***      0                    0             0      my ( $class, %args ) = @_;
1353  ***      0                                  0      foreach my $arg ( qw(Quoter) ) {
1354  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1355                                                     }
1356  ***      0                                  0      my $self = { %args };
1357  ***      0                                  0      return bless $self, $class;
1358                                                  }
1359                                                  
1360                                                  sub name {
1361  ***      0                    0             0      return 'Stream';
1362                                                  }
1363                                                  
1364                                                  sub can_sync {
1365  ***      0                    0             0      return 1;  # We can sync anything.
1366                                                  }
1367                                                  
1368                                                  sub prepare_to_sync {
1369  ***      0                    0             0      my ( $self, %args ) = @_;
1370  ***      0                                  0      my @required_args = qw(cols ChangeHandler);
1371  ***      0                                  0      foreach my $arg ( @required_args ) {
1372  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1373                                                     }
1374  ***      0                                  0      $self->{cols}            = $args{cols};
1375  ***      0                                  0      $self->{buffer_in_mysql} = $args{buffer_in_mysql};
1376  ***      0                                  0      $self->{ChangeHandler}   = $args{ChangeHandler};
1377                                                  
1378  ***      0                                  0      $self->{done}  = 0;
1379                                                  
1380  ***      0                                  0      return;
1381                                                  }
1382                                                  
1383                                                  sub uses_checksum {
1384  ***      0                    0             0      return 0;  # We don't need checksum queries.
1385                                                  }
1386                                                  
1387                                                  sub set_checksum_queries {
1388  ***      0                    0             0      return;  # This shouldn't be called, but just in case.
1389                                                  }
1390                                                  
1391                                                  sub prepare_sync_cycle {
1392  ***      0                    0             0      my ( $self, $host ) = @_;
1393  ***      0                                  0      return;
1394                                                  }
1395                                                  
1396                                                  sub get_sql {
1397  ***      0                    0             0      my ( $self, %args ) = @_;
1398  ***      0                                  0      return "SELECT "
1399                                                        . ($self->{buffer_in_mysql} ? 'SQL_BUFFER_RESULT ' : '')
1400  ***      0      0      0                    0         . join(', ', map { $self->{Quoter}->quote($_) } @{$self->{cols}})
      ***      0                                  0   
1401                                                        . ' FROM ' . $self->{Quoter}->quote(@args{qw(database table)})
1402                                                        . ' WHERE ' . ( $args{where} || '1=1' );
1403                                                  }
1404                                                  
1405                                                  sub same_row {
1406  ***      0                    0             0      my ( $self, %args ) = @_;
1407  ***      0                                  0      return;
1408                                                  }
1409                                                  
1410                                                  sub not_in_right {
1411  ***      0                    0             0      my ( $self, %args ) = @_;
1412  ***      0                                  0      $self->{ChangeHandler}->change('INSERT', $args{lr}, $self->key_cols());
1413                                                  }
1414                                                  
1415                                                  sub not_in_left {
1416  ***      0                    0             0      my ( $self, %args ) = @_;
1417  ***      0                                  0      $self->{ChangeHandler}->change('DELETE', $args{rr}, $self->key_cols());
1418                                                  }
1419                                                  
1420                                                  sub done_with_rows {
1421  ***      0                    0             0      my ( $self ) = @_;
1422  ***      0                                  0      $self->{done} = 1;
1423                                                  }
1424                                                  
1425                                                  sub done {
1426  ***      0                    0             0      my ( $self ) = @_;
1427  ***      0                                  0      return $self->{done};
1428                                                  }
1429                                                  
1430                                                  sub key_cols {
1431  ***      0                    0             0      my ( $self ) = @_;
1432  ***      0                                  0      return $self->{cols};
1433                                                  }
1434                                                  
1435                                                  sub pending_changes {
1436  ***      0                    0             0      my ( $self ) = @_;
1437  ***      0                                  0      return;
1438                                                  }
1439                                                  
1440                                                  sub _d {
1441  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1442  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1443  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1444                                                          @_;
1445  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1446                                                  }
1447                                                  
1448                                                  1;
1449                                                  
1450                                                  # ###########################################################################
1451                                                  # End TableSyncStream package
1452                                                  # ###########################################################################
1453                                                  
1454                                                  # ###########################################################################
1455                                                  # TableParser package 5693
1456                                                  # ###########################################################################
1457                                                  package TableParser;
1458                                                  
1459          29                   29           211   use strict;
              29                                 92   
              29                                157   
1460          29                   29           175   use warnings FATAL => 'all';
              29                                316   
              29                                160   
1461          29                   29           177   use English qw(-no_match_vars);
              29                                107   
              29                                140   
1462          29                   29           207   use Data::Dumper;
              29                                 81   
              29                                166   
1463                                                  $Data::Dumper::Indent    = 1;
1464                                                  $Data::Dumper::Sortkeys  = 1;
1465                                                  $Data::Dumper::Quotekeys = 0;
1466                                                  
1467  ***     29            50     29           197   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 70   
              29                                413   
1468                                                  
1469                                                  
1470                                                  sub new {
1471           5                    5            57      my ( $class, %args ) = @_;
1472           5                                 33      my @required_args = qw(Quoter);
1473           5                                 38      foreach my $arg ( @required_args ) {
1474  ***      5     50                          47         die "I need a $arg argument" unless $args{$arg};
1475                                                     }
1476           5                                 49      my $self = { %args };
1477           5                                 61      return bless $self, $class;
1478                                                  }
1479                                                  
1480                                                  
1481                                                  sub parse {
1482           7                    7            50      my ( $self, $ddl, $opts ) = @_;
1483  ***      7     50                          51      return unless $ddl;
1484  ***      7     50                          54      if ( ref $ddl eq 'ARRAY' ) {
1485  ***      7     50                          60         if ( lc $ddl->[0] eq 'table' ) {
1486           7                                 48            $ddl = $ddl->[1];
1487                                                        }
1488                                                        else {
1489                                                           return {
1490  ***      0                                  0               engine => 'VIEW',
1491                                                           };
1492                                                        }
1493                                                     }
1494                                                  
1495  ***      7     50                          97      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
1496  ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
1497                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
1498                                                     }
1499                                                  
1500           7                                150      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
1501  ***      7     50                          95      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
1502                                                  
1503           7                                297      $ddl =~ s/(`[^`]+`)/\L$1/g;
1504                                                  
1505           7                                 87      my $engine = $self->get_engine($ddl);
1506                                                  
1507           7                                390      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
1508           7                                 46      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
              28                                289   
1509           7                                 31      MKDEBUG && _d('Columns:', join(', ', @cols));
1510                                                  
1511           7                                 25      my %def_for;
1512           7                                 99      @def_for{@cols} = @defs;
1513                                                  
1514           7                                 36      my (@nums, @null);
1515           7                                 38      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
1516           7                                 40      foreach my $col ( @cols ) {
1517          28                                129         my $def = $def_for{$col};
1518          28                                266         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
1519  ***     28     50                         164         die "Can't determine column type for $def" unless $type;
1520          28                                134         $type_for{$col} = $type;
1521          28    100                         280         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
1522          14                                 64            push @nums, $col;
1523          14                                 81            $is_numeric{$col} = 1;
1524                                                        }
1525          28    100                         175         if ( $def !~ m/NOT NULL/ ) {
1526           7                                 34            push @null, $col;
1527           7                                 37            $is_nullable{$col} = 1;
1528                                                        }
1529          28    100                         245         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
1530                                                     }
1531                                                  
1532           7                                 95      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
1533                                                  
1534                                                     return {
1535          28                                192         name           => $name,
1536                                                        cols           => \@cols,
1537          28                                329         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
1538           7                                113         is_col         => { map { $_ => 1 } @cols },
1539                                                        null_cols      => \@null,
1540                                                        is_nullable    => \%is_nullable,
1541                                                        is_autoinc     => \%is_autoinc,
1542                                                        clustered_key  => $clustered_key,
1543                                                        keys           => $keys,
1544                                                        defs           => \%def_for,
1545                                                        numeric_cols   => \@nums,
1546                                                        is_numeric     => \%is_numeric,
1547                                                        engine         => $engine,
1548                                                        type_for       => \%type_for,
1549                                                     };
1550                                                  }
1551                                                  
1552                                                  sub sort_indexes {
1553  ***      0                    0             0      my ( $self, $tbl ) = @_;
1554                                                  
1555                                                     my @indexes
1556  ***      0                                  0         = sort {
1557  ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
1558                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
1559                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
1560  ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
1561                                                        }
1562                                                        grep {
1563  ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
1564                                                        }
1565  ***      0                                  0         sort keys %{$tbl->{keys}};
1566                                                  
1567  ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
1568  ***      0                                  0      return @indexes;
1569                                                  }
1570                                                  
1571                                                  sub find_best_index {
1572  ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
1573  ***      0                                  0      my $best;
1574  ***      0      0                           0      if ( $index ) {
1575  ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
1576                                                     }
1577  ***      0      0                           0      if ( !$best ) {
1578  ***      0      0                           0         if ( $index ) {
1579  ***      0                                  0            die "Index '$index' does not exist in table";
1580                                                        }
1581                                                        else {
1582  ***      0                                  0            ($best) = $self->sort_indexes($tbl);
1583                                                        }
1584                                                     }
1585  ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
1586  ***      0                                  0      return $best;
1587                                                  }
1588                                                  
1589                                                  sub find_possible_keys {
1590  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
1591  ***      0      0                           0      return () unless $where;
1592  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
1593                                                        . ' WHERE ' . $where;
1594  ***      0                                  0      MKDEBUG && _d($sql);
1595  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
1596  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
1597  ***      0      0                           0      if ( $expl->{possible_keys} ) {
1598  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
1599  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
1600  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
1601  ***      0      0                           0         if ( $expl->{key} ) {
1602  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
1603  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
1604  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
1605  ***      0                                  0            my %seen;
1606  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
1607                                                        }
1608  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
1609  ***      0                                  0         return @candidates;
1610                                                     }
1611                                                     else {
1612  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
1613  ***      0                                  0         return ();
1614                                                     }
1615                                                  }
1616                                                  
1617                                                  sub check_table {
1618  ***      0                    0             0      my ( $self, %args ) = @_;
1619  ***      0                                  0      my @required_args = qw(dbh db tbl);
1620  ***      0                                  0      foreach my $arg ( @required_args ) {
1621  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1622                                                     }
1623  ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
1624  ***      0                                  0      my $q      = $self->{Quoter};
1625  ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
1626  ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
1627                                                  
1628  ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
1629                                                             . ' LIKE ' . $q->literal_like($tbl);
1630  ***      0                                  0      MKDEBUG && _d($sql);
1631  ***      0                                  0      my $row;
1632  ***      0                                  0      eval {
1633  ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
1634                                                     };
1635  ***      0      0                           0      if ( $EVAL_ERROR ) {
1636  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1637  ***      0                                  0         return 0;
1638                                                     }
1639  ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
1640  ***      0                                  0         MKDEBUG && _d('Table does not exist');
1641  ***      0                                  0         return 0;
1642                                                     }
1643                                                  
1644  ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
1645  ***      0      0                           0      return 1 unless $args{all_privs};
1646                                                  
1647  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
1648  ***      0                                  0      MKDEBUG && _d($sql);
1649  ***      0                                  0      eval {
1650  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
1651                                                     };
1652  ***      0      0                           0      if ( $EVAL_ERROR ) {
1653  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1654  ***      0                                  0         return 0;
1655                                                     }
1656  ***      0      0                           0      if ( !scalar keys %$row ) {
1657  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
1658  ***      0                                  0         return 0;
1659                                                     }
1660  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
1661                                                  
1662  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
1663  ***      0                                  0      MKDEBUG && _d($sql);
1664  ***      0                                  0      eval {
1665  ***      0                                  0         $dbh->do($sql);
1666                                                     };
1667  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
1668                                                  
1669  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
1670                                                        ($can_delete ? 'delete' : ''));
1671                                                  
1672  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
1673                                                            && $can_delete) ) {
1674  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
1675  ***      0                                  0         return 0;
1676                                                     }
1677                                                  
1678  ***      0                                  0      MKDEBUG && _d('User has all privs');
1679  ***      0                                  0      return 1;
1680                                                  }
1681                                                  
1682                                                  sub get_engine {
1683          14                   14           104      my ( $self, $ddl, $opts ) = @_;
1684          14                                361      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
1685          14                                 52      MKDEBUG && _d('Storage engine:', $engine);
1686  ***     14            50                  113      return $engine || undef;
1687                                                  }
1688                                                  
1689                                                  sub get_keys {
1690           7                    7            57      my ( $self, $ddl, $opts, $is_nullable ) = @_;
1691           7                                177      my $engine        = $self->get_engine($ddl);
1692           7                                 44      my $keys          = {};
1693           7                                 28      my $clustered_key = undef;
1694                                                  
1695                                                     KEY:
1696           7                                181      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
1697                                                  
1698  ***     14     50                          90         next KEY if $key =~ m/FOREIGN/;
1699                                                  
1700          14                                 61         my $key_ddl = $key;
1701          14                                 40         MKDEBUG && _d('Parsed key:', $key_ddl);
1702                                                  
1703  ***     14     50                         121         if ( $engine !~ m/MEMORY|HEAP/ ) {
1704          14                                 75            $key =~ s/USING HASH/USING BTREE/;
1705                                                        }
1706                                                  
1707          14                                177         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
1708          14                                 93         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
1709  ***     14            33                  257         $type = $type || $special || 'BTREE';
      ***                   50                        
1710  ***     14     50     33                  142         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
1711                                                           && $engine =~ m/HEAP|MEMORY/i )
1712                                                        {
1713  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
1714                                                        }
1715                                                  
1716          14                                145         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
1717          14    100                         131         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
1718          14                                 51         my @cols;
1719          14                                 45         my @col_prefixes;
1720          14                                 93         foreach my $col_def ( split(',', $cols) ) {
1721          14                                150            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
1722          14                                 75            push @cols, $name;
1723          14                                 93            push @col_prefixes, $prefix;
1724                                                        }
1725          14                                100         $name =~ s/`//g;
1726                                                  
1727          14                                 42         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
1728                                                  
1729          14                                102         $keys->{$name} = {
1730                                                           name         => $name,
1731                                                           type         => $type,
1732                                                           colnames     => $cols,
1733                                                           cols         => \@cols,
1734                                                           col_prefixes => \@col_prefixes,
1735                                                           is_unique    => $unique,
1736          14                                265            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
1737          14                                131            is_col       => { map { $_ => 1 } @cols },
1738                                                           ddl          => $key_ddl,
1739                                                        };
1740                                                  
1741  ***     14    100     66                  267         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
1742           7                                 36            my $this_key = $keys->{$name};
1743  ***      7     50      0                   47            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
1744           7                                 33               $clustered_key = 'PRIMARY';
1745                                                           }
1746                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
1747  ***      0                                  0               $clustered_key = $this_key->{name};
1748                                                           }
1749           7                                 36            MKDEBUG && $clustered_key && _d('This key is the clustered key');
1750                                                        }
1751                                                     }
1752                                                  
1753           7                                 63      return $keys, $clustered_key;
1754                                                  }
1755                                                  
1756                                                  sub get_fks {
1757  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
1758  ***      0                                  0      my $fks = {};
1759                                                  
1760  ***      0                                  0      foreach my $fk (
1761                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
1762                                                     {
1763  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
1764  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
1765  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
1766                                                  
1767  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
1768  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
1769                                                        }
1770                                                  
1771  ***      0                                  0         $fks->{$name} = {
1772                                                           name           => $name,
1773                                                           colnames       => $cols,
1774  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
1775                                                           parent_tbl     => $parent,
1776                                                           parent_colnames=> $parent_cols,
1777  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
1778                                                           ddl            => $fk,
1779                                                        };
1780                                                     }
1781                                                  
1782  ***      0                                  0      return $fks;
1783                                                  }
1784                                                  
1785                                                  sub remove_auto_increment {
1786  ***      0                    0             0      my ( $self, $ddl ) = @_;
1787  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
1788  ***      0                                  0      return $ddl;
1789                                                  }
1790                                                  
1791                                                  sub remove_secondary_indexes {
1792  ***      0                    0             0      my ( $self, $ddl ) = @_;
1793  ***      0                                  0      my $sec_indexes_ddl;
1794  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
1795                                                  
1796  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
1797  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
1798  ***      0             0                    0         $clustered_key  ||= '';
1799                                                  
1800  ***      0                                  0         my @sec_indexes   = map {
1801  ***      0                                  0            my $key_def = $_->{ddl};
1802  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
1803  ***      0                                  0            $ddl =~ s/\s+$key_def//;
1804                                                  
1805  ***      0                                  0            my $key_ddl = "ADD $_->{ddl}";
1806  ***      0      0                           0            $key_ddl   .= ',' unless $key_ddl =~ m/,$/;
1807  ***      0                                  0            $key_ddl;
1808                                                        }
1809  ***      0                                  0         grep { $_->{name} ne $clustered_key }
1810  ***      0                                  0         values %{$tbl_struct->{keys}};
1811  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
1812                                                  
1813  ***      0      0                           0         if ( @sec_indexes ) {
1814  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
1815  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
1816                                                        }
1817                                                  
1818  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
1819                                                     }
1820                                                     else {
1821  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
1822                                                           $tbl_struct->{engine}, 'table');
1823                                                     }
1824                                                  
1825  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
1826                                                  }
1827                                                  
1828                                                  sub _d {
1829  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1830  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1831  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1832                                                          @_;
1833  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1834                                                  }
1835                                                  
1836                                                  1;
1837                                                  
1838                                                  # ###########################################################################
1839                                                  # End TableParser package
1840                                                  # ###########################################################################
1841                                                  
1842                                                  # ###########################################################################
1843                                                  # RowDiff package 5697
1844                                                  # ###########################################################################
1845                                                  package RowDiff;
1846                                                  
1847          29                   29           502   use strict;
              29                                 86   
              29                               2853   
1848          29                   29          1893   use warnings FATAL => 'all';
              29                               1484   
              29                                174   
1849          29                   29           181   use English qw(-no_match_vars);
              29                                 59   
              29                                157   
1850                                                  
1851  ***     29            50     29           181   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 71   
              29                                421   
1852                                                  
1853                                                  sub new {
1854           7                    7            69      my ( $class, %args ) = @_;
1855  ***      7     50                          59      die "I need a dbh" unless $args{dbh};
1856           7                                 49      my $self = { %args };
1857           7                                 78      return bless $self, $class;
1858                                                  }
1859                                                  
1860                                                  sub compare_sets {
1861          51                   51           799      my ( $self, %args ) = @_;
1862          51                                435      my @required_args = qw(left_sth right_sth syncer tbl_struct);
1863          51                                292      foreach my $arg ( @required_args ) {
1864  ***    204     50                        1307         die "I need a $arg argument" unless defined $args{$arg};
1865                                                     }
1866          51                                227      my $left_sth   = $args{left_sth};
1867          51                                236      my $right_sth  = $args{right_sth};
1868          51                                203      my $syncer     = $args{syncer};
1869          51                                195      my $tbl_struct = $args{tbl_struct};
1870                                                  
1871          51                                183      my ($lr, $rr);    # Current row from the left/right sths.
1872          51                                328      $args{key_cols} = $syncer->key_cols();  # for key_cmp()
1873                                                  
1874          51                                190      my $left_done  = 0;
1875          51                                177      my $right_done = 0;
1876          51                                227      my $done       = $self->{done};
1877                                                  
1878          51           100                  183      do {
1879         161    100    100                 1964         if ( !$lr && !$left_done ) {
1880         154                                455            MKDEBUG && _d('Fetching row from left');
1881         154                                562            eval { $lr = $left_sth->fetchrow_hashref(); };
             154                               1653   
1882         154                               2828            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
1883  ***    154    100     66                 1745            $left_done = !$lr || $EVAL_ERROR ? 1 : 0;
1884                                                        }
1885                                                        elsif ( MKDEBUG ) {
1886                                                           _d('Left still has rows');
1887                                                        }
1888                                                  
1889         161    100    100                 1725         if ( !$rr && !$right_done ) {
1890         154                                450            MKDEBUG && _d('Fetching row from right');
1891         154                                523            eval { $rr = $right_sth->fetchrow_hashref(); };
             154                               1367   
1892         154                               2389            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
1893  ***    154    100     66                 1651            $right_done = !$rr || $EVAL_ERROR ? 1 : 0;
1894                                                        }
1895                                                        elsif ( MKDEBUG ) {
1896                                                           _d('Right still has rows');
1897                                                        }
1898                                                  
1899         161                                503         my $cmp;
1900         161    100    100                 1603         if ( $lr && $rr ) {
1901         105                               1010            $cmp = $self->key_cmp(%args, lr => $lr, rr => $rr);
1902         105                                434            MKDEBUG && _d('Key comparison on left and right:', $cmp);
1903                                                        }
1904         161    100    100                 1384         if ( $lr || $rr ) {
1905         111    100    100                 2707            if ( $lr && $rr && defined $cmp && $cmp == 0 ) {
      ***           100     66                        
                           100                        
                           100                        
                           100                        
1906          97                                289               MKDEBUG && _d('Left and right have the same key');
1907          97                                850               $syncer->same_row(%args, lr => $lr, rr => $rr);
1908  ***     96     50                         736               $self->{same_row}->(%args, lr => $lr, rr => $rr)
1909                                                                 if $self->{same_row};
1910          96                                481               $lr = $rr = undef; # Fetch another row from each side.
1911                                                           }
1912                                                           elsif ( !$rr || ( defined $cmp && $cmp < 0 ) ) {
1913           7                                 25               MKDEBUG && _d('Left is not in right');
1914           7                                 84               $syncer->not_in_right(%args, lr => $lr, rr => $rr);
1915  ***      7     50                          60               $self->{not_in_right}->(%args, lr => $lr, rr => $rr)
1916                                                                 if $self->{not_in_right};
1917           7                                 33               $lr = undef;
1918                                                           }
1919                                                           else {
1920           7                                 25               MKDEBUG && _d('Right is not in left');
1921           7                                 84               $syncer->not_in_left(%args, lr => $lr, rr => $rr);
1922  ***      7     50                          62               $self->{not_in_left}->(%args, lr => $lr, rr => $rr)
1923                                                                 if $self->{not_in_left};
1924           7                                 35               $rr = undef;
1925                                                           }
1926                                                        }
1927  ***    160     50     33                 2634         $left_done = $right_done = 1 if $done && $done->(%args);
1928                                                     } while ( !($left_done && $right_done) );
1929          50                                144      MKDEBUG && _d('No more rows');
1930          50                                298      $syncer->done_with_rows();
1931                                                  }
1932                                                  
1933                                                  sub key_cmp {
1934         105                  105          1231      my ( $self, %args ) = @_;
1935         105                                902      my @required_args = qw(lr rr key_cols tbl_struct);
1936         105                                497      foreach my $arg ( @required_args ) {
1937  ***    420     50                        2649         die "I need a $arg argument" unless exists $args{$arg};
1938                                                     }
1939         105                                729      my ($lr, $rr, $key_cols, $tbl_struct) = @args{@required_args};
1940         105                                313      MKDEBUG && _d('Comparing keys using columns:', join(',', @$key_cols));
1941                                                  
1942         105                                524      my $callback = $self->{key_cmp};
1943         105                                467      my $trf      = $self->{trf};
1944                                                  
1945         105                                485      foreach my $col ( @$key_cols ) {
1946         105                                477         my $l = $lr->{$col};
1947         105                                470         my $r = $rr->{$col};
1948  ***    105     50     33                 1269         if ( !defined $l || !defined $r ) {
1949  ***      0                                  0            MKDEBUG && _d($col, 'is not defined in both rows');
1950  ***      0      0                           0            return defined $l ? 1 : defined $r ? -1 : 0;
      ***             0                               
1951                                                        }
1952                                                        else {
1953         105    100                         918            if ( $tbl_struct->{is_numeric}->{$col} ) {   # Numeric column
      ***            50                               
1954          74                                221               MKDEBUG && _d($col, 'is numeric');
1955  ***     74     50                         397               ($l, $r) = $trf->($l, $r, $tbl_struct, $col) if $trf;
1956          74                                531               my $cmp = $l <=> $r;
1957          74    100                         565               if ( $cmp ) {
1958           8                                 26                  MKDEBUG && _d('Column', $col, 'differs:', $l, '!=', $r);
1959  ***      8     50                          46                  $callback->($col, $l, $r) if $callback;
1960           8                                 74                  return $cmp;
1961                                                              }
1962                                                           }
1963                                                           elsif ( $l ne $r ) {
1964  ***      0                                  0               my $cmp;
1965  ***      0                                  0               my $coll = $tbl_struct->{collation_for}->{$col};
1966  ***      0      0      0                    0               if ( $coll && ( $coll ne 'latin1_swedish_ci'
      ***                    0                        
      ***                    0                        
1967                                                                             || $l =~ m/[^\040-\177]/ || $r =~ m/[^\040-\177]/) )
1968                                                              {
1969  ***      0                                  0                  MKDEBUG && _d('Comparing', $col, 'via MySQL');
1970  ***      0                                  0                  $cmp = $self->db_cmp($coll, $l, $r);
1971                                                              }
1972                                                              else {
1973  ***      0                                  0                  MKDEBUG && _d('Comparing', $col, 'in lowercase');
1974  ***      0                                  0                  $cmp = lc $l cmp lc $r;
1975                                                              }
1976  ***      0      0                           0               if ( $cmp ) {
1977  ***      0                                  0                  MKDEBUG && _d('Column', $col, 'differs:', $l, 'ne', $r);
1978  ***      0      0                           0                  $callback->($col, $l, $r) if $callback;
1979  ***      0                                  0                  return $cmp;
1980                                                              }
1981                                                           }
1982                                                        }
1983                                                     }
1984          97                                795      return 0;
1985                                                  }
1986                                                  
1987                                                  sub db_cmp {
1988  ***      0                    0             0      my ( $self, $collation, $l, $r ) = @_;
1989  ***      0      0                           0      if ( !$self->{sth}->{$collation} ) {
1990  ***      0      0                           0         if ( !$self->{charset_for} ) {
1991  ***      0                                  0            MKDEBUG && _d('Fetching collations from MySQL');
1992  ***      0                                  0            my @collations = @{$self->{dbh}->selectall_arrayref(
      ***      0                                  0   
1993                                                              'SHOW COLLATION', {Slice => { collation => 1, charset => 1 }})};
1994  ***      0                                  0            foreach my $collation ( @collations ) {
1995  ***      0                                  0               $self->{charset_for}->{$collation->{collation}}
1996                                                                 = $collation->{charset};
1997                                                           }
1998                                                        }
1999  ***      0                                  0         my $sql = "SELECT STRCMP(_$self->{charset_for}->{$collation}? COLLATE $collation, "
2000                                                           . "_$self->{charset_for}->{$collation}? COLLATE $collation) AS res";
2001  ***      0                                  0         MKDEBUG && _d($sql);
2002  ***      0                                  0         $self->{sth}->{$collation} = $self->{dbh}->prepare($sql);
2003                                                     }
2004  ***      0                                  0      my $sth = $self->{sth}->{$collation};
2005  ***      0                                  0      $sth->execute($l, $r);
2006  ***      0                                  0      return $sth->fetchall_arrayref()->[0]->[0];
2007                                                  }
2008                                                  
2009                                                  sub _d {
2010  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2011  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2012  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2013                                                          @_;
2014  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2015                                                  }
2016                                                  
2017                                                  1;
2018                                                  
2019                                                  # ###########################################################################
2020                                                  # End RowDiff package
2021                                                  # ###########################################################################
2022                                                  
2023                                                  # ###########################################################################
2024                                                  # MySQLDump package 5266
2025                                                  # ###########################################################################
2026                                                  package MySQLDump;
2027                                                  
2028          29                   29           215   use strict;
              29                                 79   
              29                                155   
2029          29                   29           169   use warnings FATAL => 'all';
              29                                 81   
              29                                164   
2030                                                  
2031          29                   29           175   use English qw(-no_match_vars);
              29                                 92   
              29                                144   
2032                                                  
2033  ***     29            50     29           196   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 69   
              29                                397   
2034                                                  
2035                                                  ( our $before = <<'EOF') =~ s/^   //gm;
2036                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
2037                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
2038                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
2039                                                     /*!40101 SET NAMES utf8 */;
2040                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
2041                                                     /*!40103 SET TIME_ZONE='+00:00' */;
2042                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
2043                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2044                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2045                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2046                                                  EOF
2047                                                  
2048                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2049                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2050                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2051                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2052                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2053                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2054                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2055                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2056                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2057                                                  EOF
2058                                                  
2059                                                  sub new {
2060           5                    5            55      my ( $class, %args ) = @_;
2061  ***      5     50                          41      $args{cache} = 1 unless defined $args{cache};
2062           5                                 45      my $self = bless \%args, $class;
2063           5                                 28      return $self;
2064                                                  }
2065                                                  
2066                                                  sub dump {
2067  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2068                                                  
2069  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2070  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2071  ***      0      0                           0         return unless $ddl;
2072  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
2073  ***      0                                  0            return $before
2074                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2075                                                              . $ddl->[1] . ";\n";
2076                                                        }
2077                                                        else {
2078  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2079                                                              . '/*!50001 DROP VIEW IF EXISTS '
2080                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2081                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2082                                                        }
2083                                                     }
2084                                                     elsif ( $what eq 'triggers' ) {
2085  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2086  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
2087  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
2088  ***      0                                  0            foreach my $trg ( @$trgs ) {
2089  ***      0      0                           0               if ( $trg->{sql_mode} ) {
2090  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2091                                                              }
2092  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
2093  ***      0      0                           0               if ( $trg->{definer} ) {
2094  ***      0                                  0                  my ( $user, $host )
2095  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
2096                                                                      split('@', $trg->{definer}, 2);
2097  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
2098                                                              }
2099  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2100                                                                 $quoter->quote($trg->{trigger}),
2101  ***      0                                  0                  @{$trg}{qw(timing event)},
2102                                                                 $quoter->quote($trg->{table}),
2103                                                                 $trg->{statement});
2104                                                           }
2105  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2106  ***      0                                  0            return $result;
2107                                                        }
2108                                                        else {
2109  ***      0                                  0            return undef;
2110                                                        }
2111                                                     }
2112                                                     elsif ( $what eq 'view' ) {
2113  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2114  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2115                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2116                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2117                                                     }
2118                                                     else {
2119  ***      0                                  0         die "You didn't say what to dump.";
2120                                                     }
2121                                                  }
2122                                                  
2123                                                  sub _use_db {
2124          28                   28           208      my ( $self, $dbh, $quoter, $new ) = @_;
2125  ***     28     50                         180      if ( !$new ) {
2126  ***      0                                  0         MKDEBUG && _d('No new DB to use');
2127  ***      0                                  0         return;
2128                                                     }
2129          28                                106      my $sql = 'SELECT DATABASE()';
2130          28                                 88      MKDEBUG && _d($sql);
2131          28                                 92      my $curr = $dbh->selectrow_array($sql);
2132  ***     28     50     33                 5839      if ( $curr && $new && $curr eq $new ) {
      ***                   33                        
2133          28                                108         MKDEBUG && _d('Current and new DB are the same');
2134          28                                177         return $curr;
2135                                                     }
2136  ***      0                                  0      $sql = 'USE ' . $quoter->quote($new);
2137  ***      0                                  0      MKDEBUG && _d($sql);
2138  ***      0                                  0      $dbh->do($sql);
2139  ***      0                                  0      return $curr;
2140                                                  }
2141                                                  
2142                                                  sub get_create_table {
2143          14                   14           126      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2144  ***     14     50     33                  161      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2145          14                                 74         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2146                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2147                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2148                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2149          14                                 43         MKDEBUG && _d($sql);
2150          14                                 49         eval { $dbh->do($sql); };
              14                               2437   
2151          14                                 59         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2152          14                                131         my $curr_db = $self->_use_db($dbh, $quoter, $db);
2153          14                                111         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2154          14                                 48         MKDEBUG && _d($sql);
2155          14                                 53         my $href;
2156          14                                 52         eval { $href = $dbh->selectrow_hashref($sql); };
              14                                 42   
2157  ***     14     50                         144         if ( $EVAL_ERROR ) {
2158  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2159  ***      0                                  0            return;
2160                                                        }
2161          14                                100         $self->_use_db($dbh, $quoter, $curr_db);
2162          14                                 70         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2163                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2164          14                                 43         MKDEBUG && _d($sql);
2165          14                               2048         $dbh->do($sql);
2166          14                                134         my ($key) = grep { m/create table/i } keys %$href;
              28                                252   
2167  ***     14     50                          93         if ( $key ) {
2168          14                                 45            MKDEBUG && _d('This table is a base table');
2169          14                                222            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2170                                                        }
2171                                                        else {
2172  ***      0                                  0            MKDEBUG && _d('This table is a view');
2173  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
2174  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2175                                                        }
2176                                                     }
2177          14                                138      return $self->{tables}->{$db}->{$tbl};
2178                                                  }
2179                                                  
2180                                                  sub get_columns {
2181  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2182  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
2183  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2184  ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
2185  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2186  ***      0                                  0         MKDEBUG && _d($sql);
2187  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2188  ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
2189  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
2190                                                           map {
2191  ***      0                                  0               my %row;
2192  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2193  ***      0                                  0               \%row;
2194                                                           } @$cols
2195                                                        ];
2196                                                     }
2197  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
2198                                                  }
2199                                                  
2200                                                  sub get_tmp_table {
2201  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2202  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2203  ***      0                                  0      $result .= join(",\n",
2204  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2205  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2206  ***      0                                  0      $result .= "\n)";
2207  ***      0                                  0      MKDEBUG && _d($result);
2208  ***      0                                  0      return $result;
2209                                                  }
2210                                                  
2211                                                  sub get_triggers {
2212           7                    7            63      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2213  ***      7     50     33                   80      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2214           7                                 59         $self->{triggers}->{$db} = {};
2215           7                                 33         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2216                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2217                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2218                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2219           7                                 22         MKDEBUG && _d($sql);
2220           7                                 28         eval { $dbh->do($sql); };
               7                               1341   
2221           7                                 30         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2222           7                                 54         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2223           7                                 26         MKDEBUG && _d($sql);
2224           7                                 21         my $sth = $dbh->prepare($sql);
2225           7                               4016         $sth->execute();
2226  ***      7     50                         172         if ( $sth->rows ) {
2227  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
2228  ***      0                                  0            foreach my $trg (@$trgs) {
2229  ***      0                                  0               my %trg;
2230  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
2231  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
2232                                                           }
2233                                                        }
2234           7                                 40         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2235                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2236           7                                 24         MKDEBUG && _d($sql);
2237           7                               1215         $dbh->do($sql);
2238                                                     }
2239  ***      7     50                          57      if ( $tbl ) {
2240           7                                141         return $self->{triggers}->{$db}->{$tbl};
2241                                                     }
2242  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
2243                                                  }
2244                                                  
2245                                                  sub get_databases {
2246  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
2247  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2248  ***      0                                  0         my $sql = 'SHOW DATABASES';
2249  ***      0                                  0         my @params;
2250  ***      0      0                           0         if ( $like ) {
2251  ***      0                                  0            $sql .= ' LIKE ?';
2252  ***      0                                  0            push @params, $like;
2253                                                        }
2254  ***      0                                  0         my $sth = $dbh->prepare($sql);
2255  ***      0                                  0         MKDEBUG && _d($sql, @params);
2256  ***      0                                  0         $sth->execute( @params );
2257  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
2258  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
2259  ***      0                                  0         return @dbs;
2260                                                     }
2261  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
2262                                                  }
2263                                                  
2264                                                  sub get_table_status {
2265  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2266  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2267  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2268  ***      0                                  0         my @params;
2269  ***      0      0                           0         if ( $like ) {
2270  ***      0                                  0            $sql .= ' LIKE ?';
2271  ***      0                                  0            push @params, $like;
2272                                                        }
2273  ***      0                                  0         MKDEBUG && _d($sql, @params);
2274  ***      0                                  0         my $sth = $dbh->prepare($sql);
2275  ***      0                                  0         $sth->execute(@params);
2276  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2277  ***      0                                  0         @tables = map {
2278  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
2279  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2280  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2281  ***      0                                  0            delete $tbl{type};
2282  ***      0                                  0            \%tbl;
2283                                                        } @tables;
2284  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
2285  ***      0                                  0         return @tables;
2286                                                     }
2287  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
2288                                                  }
2289                                                  
2290                                                  sub get_table_list {
2291  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2292  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2293  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2294  ***      0                                  0         my @params;
2295  ***      0      0                           0         if ( $like ) {
2296  ***      0                                  0            $sql .= ' LIKE ?';
2297  ***      0                                  0            push @params, $like;
2298                                                        }
2299  ***      0                                  0         MKDEBUG && _d($sql, @params);
2300  ***      0                                  0         my $sth = $dbh->prepare($sql);
2301  ***      0                                  0         $sth->execute(@params);
2302  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
2303  ***      0      0      0                    0         @tables = map {
2304  ***      0                                  0            my %tbl = (
2305                                                              name   => $_->[0],
2306                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2307                                                           );
2308  ***      0                                  0            \%tbl;
2309                                                        } @tables;
2310  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
2311  ***      0                                  0         return @tables;
2312                                                     }
2313  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
2314                                                  }
2315                                                  
2316                                                  sub _d {
2317  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2318  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2319  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2320                                                          @_;
2321  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2322                                                  }
2323                                                  
2324                                                  1;
2325                                                  
2326                                                  # ###########################################################################
2327                                                  # End MySQLDump package
2328                                                  # ###########################################################################
2329                                                  
2330                                                  # ###########################################################################
2331                                                  # ChangeHandler package 5714
2332                                                  # ###########################################################################
2333                                                  package ChangeHandler;
2334                                                  
2335          29                   29           235   use strict;
              29                                 76   
              29                                179   
2336          29                   29           184   use warnings FATAL => 'all';
              29                                 68   
              29                                174   
2337          29                   29           165   use English qw(-no_match_vars);
              29                                 78   
              29                                152   
2338                                                  
2339                                                  my $DUPE_KEY  = qr/Duplicate entry/;
2340                                                  our @ACTIONS  = qw(DELETE REPLACE INSERT UPDATE);
2341                                                  
2342  ***     29            50     29           204   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 73   
              29                                423   
2343                                                  
2344                                                  sub new {
2345           7                    7           136      my ( $class, %args ) = @_;
2346           7                                 64      foreach my $arg ( qw(Quoter left_db left_tbl right_db right_tbl
2347                                                                          replace queue) ) {
2348  ***     49     50                         343         die "I need a $arg argument" unless defined $args{$arg};
2349                                                     }
2350           7                                 37      my $q = $args{Quoter};
2351                                                  
2352           7                                 81      my $self = {
2353                                                        %args,
2354                                                        left_db_tbl  => $q->quote(@args{qw(left_db left_tbl)}),
2355                                                        right_db_tbl => $q->quote(@args{qw(right_db right_tbl)}),
2356                                                     };
2357                                                  
2358           7                                 62      $self->{src_db_tbl} = $self->{left_db_tbl};
2359           7                                 41      $self->{dst_db_tbl} = $self->{right_db_tbl};
2360                                                  
2361           7                                 41      map { $self->{$_} = [] } @ACTIONS;
              28                                201   
2362           7                                 42      $self->{changes} = { map { $_ => 0 } @ACTIONS };
              28                                170   
2363                                                  
2364           7                                 92      return bless $self, $class;
2365                                                  }
2366                                                  
2367                                                  sub fetch_back {
2368          43                   43           234      my ( $self, $dbh ) = @_;
2369          43                                216      $self->{fetch_back} = $dbh;
2370          43                                126      MKDEBUG && _d('Set fetch back dbh', $dbh);
2371          43                                175      return;
2372                                                  }
2373                                                  
2374                                                  sub set_src {
2375          36                   36           234      my ( $self, $src, $dbh ) = @_;
2376  ***     36     50                         217      die "I need a src argument" unless $src;
2377          36    100                         271      if ( lc $src eq 'left' ) {
      ***            50                               
2378          16                                 94         $self->{src_db_tbl} = $self->{left_db_tbl};
2379          16                                 99         $self->{dst_db_tbl} = $self->{right_db_tbl};
2380                                                     }
2381                                                     elsif ( lc $src eq 'right' ) {
2382          20                                135         $self->{src_db_tbl} = $self->{right_db_tbl};
2383          20                                132         $self->{dst_db_tbl} = $self->{left_db_tbl}; 
2384                                                     }
2385                                                     else {
2386  ***      0                                  0         die "src argument must be either 'left' or 'right'"
2387                                                     }
2388          36                                112      MKDEBUG && _d('Set src to', $src);
2389  ***     36     50                         293      $self->fetch_back($dbh) if $dbh;
2390          36                                126      return;
2391                                                  }
2392                                                  
2393                                                  sub src {
2394  ***      0                    0             0      my ( $self ) = @_;
2395  ***      0                                  0      return $self->{src_db_tbl};
2396                                                  }
2397                                                  
2398                                                  sub dst {
2399  ***      0                    0             0      my ( $self ) = @_;
2400  ***      0                                  0      return $self->{dst_db_tbl};
2401                                                  }
2402                                                  
2403                                                  sub _take_action {
2404          36                   36           240      my ( $self, $sql, $dbh ) = @_;
2405          36                                126      MKDEBUG && _d('Calling subroutines on', $dbh, $sql);
2406          36                                125      foreach my $action ( @{$self->{actions}} ) {
              36                                243   
2407          72                                449         $action->($sql, $dbh);
2408                                                     }
2409          36                                219      return;
2410                                                  }
2411                                                  
2412                                                  sub change {
2413          39                   39           285      my ( $self, $action, $row, $cols, $dbh ) = @_;
2414          39                                135      MKDEBUG && _d($dbh, $action, 'where', $self->make_where_clause($row, $cols));
2415                                                  
2416          39    100                         224      return unless $action;
2417                                                  
2418                                                     $self->{changes}->{
2419  ***     36     50     33                  398         $self->{replace} && $action ne 'DELETE' ? 'REPLACE' : $action
2420                                                     }++;
2421  ***     36     50                         197      if ( $self->{queue} ) {
2422  ***      0                                  0         $self->__queue($action, $row, $cols, $dbh);
2423                                                     }
2424                                                     else {
2425          36                                132         eval {
2426          36                                171            my $func = "make_$action";
2427          36                                292            $self->_take_action($self->$func($row, $cols), $dbh);
2428                                                        };
2429  ***     36     50                         516         if ( $EVAL_ERROR =~ m/$DUPE_KEY/ ) {
      ***            50                               
2430  ***      0                                  0            MKDEBUG && _d('Duplicate key violation; will queue and rewrite');
2431  ***      0                                  0            $self->{queue}++;
2432  ***      0                                  0            $self->{replace} = 1;
2433  ***      0                                  0            $self->__queue($action, $row, $cols, $dbh);
2434                                                        }
2435                                                        elsif ( $EVAL_ERROR ) {
2436  ***      0                                  0            die $EVAL_ERROR;
2437                                                        }
2438                                                     }
2439          36                                288      return;
2440                                                  }
2441                                                  
2442                                                  sub __queue {
2443  ***      0                    0             0      my ( $self, $action, $row, $cols, $dbh ) = @_;
2444  ***      0                                  0      MKDEBUG && _d('Queueing change for later');
2445  ***      0      0                           0      if ( $self->{replace} ) {
2446  ***      0      0                           0         $action = $action eq 'DELETE' ? $action : 'REPLACE';
2447                                                     }
2448  ***      0                                  0      push @{$self->{$action}}, [ $row, $cols, $dbh ];
      ***      0                                  0   
2449                                                  }
2450                                                  
2451                                                  sub process_rows {
2452          56                   56           292      my ( $self, $queue_level ) = @_;
2453          56                                245      my $error_count = 0;
2454                                                     TRY: {
2455  ***     56     50     66                  189         if ( $queue_level && $queue_level < $self->{queue} ) { # see redo below!
              56                                706   
2456  ***      0                                  0            MKDEBUG && _d('Not processing now', $queue_level, '<', $self->{queue});
2457  ***      0                                  0            return;
2458                                                        }
2459          56                                167         MKDEBUG && _d('Processing rows:');
2460          56                                210         my ($row, $cur_act);
2461          56                                178         eval {
2462          56                                298            foreach my $action ( @ACTIONS ) {
2463         224                                957               my $func = "make_$action";
2464         224                                945               my $rows = $self->{$action};
2465         224                                601               MKDEBUG && _d(scalar(@$rows), 'to', $action);
2466         224                                743               $cur_act = $action;
2467         224                               1414               while ( @$rows ) {
2468  ***      0                                  0                  $row    = shift @$rows;
2469  ***      0      0                           0                  my $dbh = $row->[2] if $row->[2];  # dbh is optional
2470  ***      0                                  0                  $self->_take_action($self->$func(@$row), $dbh);
2471                                                              }
2472                                                           }
2473          56                                240            $error_count = 0;
2474                                                        };
2475  ***     56     50     33                  960         if ( !$error_count++ && $EVAL_ERROR =~ m/$DUPE_KEY/ ) {
      ***            50                               
2476  ***      0                                  0            MKDEBUG && _d('Duplicate key violation; re-queueing and rewriting');
2477  ***      0                                  0            $self->{queue}++; # Defer rows to the very end
2478  ***      0                                  0            $self->{replace} = 1;
2479  ***      0                                  0            $self->__queue($cur_act, @$row);
2480  ***      0                                  0            redo TRY;
2481                                                        }
2482                                                        elsif ( $EVAL_ERROR ) {
2483  ***      0                                  0            die $EVAL_ERROR;
2484                                                        }
2485                                                     }
2486                                                  }
2487                                                  
2488                                                  sub make_DELETE {
2489  ***      0                    0             0      my ( $self, $row, $cols ) = @_;
2490  ***      0                                  0      MKDEBUG && _d('Make DELETE');
2491  ***      0                                  0      return "DELETE FROM $self->{dst_db_tbl} WHERE "
2492                                                        . $self->make_where_clause($row, $cols)
2493                                                        . ' LIMIT 1';
2494                                                  }
2495                                                  
2496                                                  sub make_UPDATE {
2497          22                   22           124      my ( $self, $row, $cols ) = @_;
2498          22                                 67      MKDEBUG && _d('Make UPDATE');
2499  ***     22     50                         134      if ( $self->{replace} ) {
2500  ***      0                                  0         return $self->make_row('REPLACE', $row, $cols);
2501                                                     }
2502          22                                117      my %in_where = map { $_ => 1 } @$cols;
              22                                177   
2503          22                                160      my $where = $self->make_where_clause($row, $cols);
2504          22                                 71      my @cols;
2505  ***     22     50                         164      if ( my $dbh = $self->{fetch_back} ) {
2506          22                                156         my $sql = "SELECT * FROM $self->{src_db_tbl} WHERE $where LIMIT 1";
2507          22                                 60         MKDEBUG && _d('Fetching data on dbh', $dbh, 'for UPDATE:', $sql);
2508          22                                 71         my $res = $dbh->selectrow_hashref($sql);
2509          22                                293         @{$row}{keys %$res} = values %$res;
              22                                176   
2510          22                                195         @cols = $self->sort_cols($res);
2511                                                     }
2512                                                     else {
2513  ***      0                                  0         @cols = $self->sort_cols($row);
2514                                                     }
2515          66                                420      return "UPDATE $self->{dst_db_tbl} SET "
2516                                                        . join(', ', map {
2517          88                                448               $self->{Quoter}->quote($_)
2518                                                              . '=' .  $self->{Quoter}->quote_val($row->{$_})
2519          22                                203            } grep { !$in_where{$_} } @cols)
2520                                                        . " WHERE $where LIMIT 1";
2521                                                  }
2522                                                  
2523                                                  sub make_INSERT {
2524          14                   14            85      my ( $self, $row, $cols ) = @_;
2525          14                                 47      MKDEBUG && _d('Make INSERT');
2526  ***     14     50                          91      if ( $self->{replace} ) {
2527  ***      0                                  0         return $self->make_row('REPLACE', $row, $cols);
2528                                                     }
2529          14                                100      return $self->make_row('INSERT', $row, $cols);
2530                                                  }
2531                                                  
2532                                                  sub make_REPLACE {
2533  ***      0                    0             0      my ( $self, $row, $cols ) = @_;
2534  ***      0                                  0      MKDEBUG && _d('Make REPLACE');
2535  ***      0                                  0      return $self->make_row('REPLACE', $row, $cols);
2536                                                  }
2537                                                  
2538                                                  sub make_row {
2539          14                   14            97      my ( $self, $verb, $row, $cols ) = @_;
2540          14                                 54      my @cols; 
2541  ***     14     50                          91      if ( my $dbh = $self->{fetch_back} ) {
2542          14                                 84         my $where = $self->make_where_clause($row, $cols);
2543          14                                114         my $sql = "SELECT * FROM $self->{src_db_tbl} WHERE $where LIMIT 1";
2544          14                                 39         MKDEBUG && _d('Fetching data on dbh', $dbh, 'for', $verb, ':', $sql);
2545          14                                 50         my $res = $dbh->selectrow_hashref($sql);
2546          14                                193         @{$row}{keys %$res} = values %$res;
              14                                113   
2547          14                                144         @cols = $self->sort_cols($res);
2548                                                     }
2549                                                     else {
2550  ***      0                                  0         @cols = $self->sort_cols($row);
2551                                                     }
2552          14                                 88      my $q = $self->{Quoter};
2553          56                                308      return "$verb INTO $self->{dst_db_tbl}("
2554          56                                282         . join(', ', map { $q->quote($_) } @cols)
2555                                                        . ') VALUES ('
2556          14                                142         . join(', ', map { $q->quote_val($_) } @{$row}{@cols} )
              14                                 79   
2557                                                        . ')';
2558                                                  }
2559                                                  
2560                                                  sub make_where_clause {
2561          40                   40           243      my ( $self, $row, $cols ) = @_;
2562          40                                199      my @clauses = map {
2563          40                                229         my $val = $row->{$_};
2564  ***     40     50                         222         my $sep = defined $val ? '=' : ' IS ';
2565          40                                281         $self->{Quoter}->quote($_) . $sep . $self->{Quoter}->quote_val($val);
2566                                                     } @$cols;
2567          40                                293      return join(' AND ', @clauses);
2568                                                  }
2569                                                  
2570                                                  sub get_changes {
2571           6                    6            32      my ( $self ) = @_;
2572           6                                 23      return %{$self->{changes}};
               6                                 74   
2573                                                  }
2574                                                  
2575                                                  sub sort_cols {
2576          36                   36           199      my ( $self, $row ) = @_;
2577          36                                141      my @cols;
2578  ***     36     50                         243      if ( $self->{tbl_struct} ) { 
2579          36                                232         my $pos = $self->{tbl_struct}->{col_posn};
2580          36                                116         my @not_in_tbl;
2581         180                                847         @cols = sort {
2582                                                              $pos->{$a} <=> $pos->{$b}
2583                                                           }
2584                                                           grep {
2585  ***     36     50                         223               if ( !defined $pos->{$_} ) {
             144                                800   
2586  ***      0                                  0                  push @not_in_tbl, $_;
2587  ***      0                                  0                  0;
2588                                                              }
2589                                                              else {
2590         144                                506                  1;
2591                                                              }
2592                                                           }
2593                                                           keys %$row;
2594  ***     36     50                         431         push @cols, @not_in_tbl if @not_in_tbl;
2595                                                     }
2596                                                     else {
2597  ***      0                                  0         @cols = sort keys %$row;
2598                                                     }
2599          36                                432      return @cols;
2600                                                  }
2601                                                  
2602                                                  sub _d {
2603  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2604  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2605  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2606                                                          @_;
2607  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2608                                                  }
2609                                                  
2610                                                  1;
2611                                                  
2612                                                  # ###########################################################################
2613                                                  # End ChangeHandler package
2614                                                  # ###########################################################################
2615                                                  
2616                                                  # ###########################################################################
2617                                                  # TableChunker package 5266
2618                                                  # ###########################################################################
2619          29                   29           243   use strict;
              29                                 92   
              29                                178   
2620          29                   29           179   use warnings FATAL => 'all';
              29                                 74   
              29                                170   
2621                                                  
2622                                                  package TableChunker;
2623                                                  
2624          29                   29           178   use English qw(-no_match_vars);
              29                                 70   
              29                                155   
2625          29                   29           211   use POSIX qw(ceil);
              29                                 70   
              29                                207   
2626          29                   29           205   use List::Util qw(min max);
              29                                 69   
              29                                164   
2627          29                   29           192   use Data::Dumper;
              29                                203   
              29                                164   
2628                                                  $Data::Dumper::Indent    = 1;
2629                                                  $Data::Dumper::Sortkeys  = 1;
2630                                                  $Data::Dumper::Quotekeys = 0;
2631                                                  
2632  ***     29            50     29           197   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 72   
              29                                418   
2633                                                  
2634                                                  sub new {
2635           5                    5            50      my ( $class, %args ) = @_;
2636           5                                 33      foreach my $arg ( qw(Quoter MySQLDump) ) {
2637  ***     10     50                          79         die "I need a $arg argument" unless $args{$arg};
2638                                                     }
2639           5                                 36      my $self = { %args };
2640           5                                 65      return bless $self, $class;
2641                                                  }
2642                                                  
2643                                                  my $EPOCH      = '1970-01-01';
2644                                                  my %int_types  = map { $_ => 1 }
2645                                                     qw(bigint date datetime int mediumint smallint time timestamp tinyint year);
2646                                                  my %real_types = map { $_ => 1 }
2647                                                     qw(decimal double float);
2648                                                  
2649                                                  sub find_chunk_columns {
2650           7                    7           223      my ( $self, %args ) = @_;
2651           7                                 93      foreach my $arg ( qw(tbl_struct) ) {
2652  ***      7     50                          63         die "I need a $arg argument" unless $args{$arg};
2653                                                     }
2654           7                                 33      my $tbl_struct = $args{tbl_struct};
2655                                                  
2656           7                                 26      my @possible_indexes;
2657           7                                 28      foreach my $index ( values %{ $tbl_struct->{keys} } ) {
               7                                 62   
2658                                                  
2659  ***     14     50                         111         next unless $index->{type} eq 'BTREE';
2660                                                  
2661  ***     14            33                   39         defined $_ && next for @{ $index->{col_prefixes} };
              14                                 49   
              14                                152   
2662                                                  
2663  ***     14     50                          94         if ( $args{exact} ) {
2664  ***     14    100     66                  140            next unless $index->{is_unique} && @{$index->{cols}} == 1;
               7                                 93   
2665                                                        }
2666                                                  
2667           7                                 50         push @possible_indexes, $index;
2668                                                     }
2669                                                     MKDEBUG && _d('Possible chunk indexes in order:',
2670           7                                 25         join(', ', map { $_->{name} } @possible_indexes));
2671                                                  
2672           7                                 29      my $can_chunk_exact = 0;
2673           7                                 26      my @candidate_cols;
2674           7                                 37      foreach my $index ( @possible_indexes ) { 
2675           7                                 48         my $col = $index->{cols}->[0];
2676                                                  
2677  ***      7     50     33                   91         next unless ( $int_types{$tbl_struct->{type_for}->{$col}}
2678                                                                      || $real_types{$tbl_struct->{type_for}->{$col}} );
2679                                                  
2680           7                                 98         push @candidate_cols, { column => $col, index => $index->{name} };
2681                                                     }
2682                                                  
2683  ***      7     50     50                  123      $can_chunk_exact = 1 if $args{exact} && scalar @candidate_cols;
2684                                                  
2685           7                                 27      if ( MKDEBUG ) {
2686                                                        my $chunk_type = $args{exact} ? 'Exact' : 'Inexact';
2687                                                        _d($chunk_type, 'chunkable:',
2688                                                           join(', ', map { "$_->{column} on $_->{index}" } @candidate_cols));
2689                                                     }
2690                                                  
2691           7                                 25      my @result;
2692           7                                 21      MKDEBUG && _d('Ordering columns by order in tbl, PK first');
2693  ***      7     50                          59      if ( $tbl_struct->{keys}->{PRIMARY} ) {
2694           7                                 57         my $pk_first_col = $tbl_struct->{keys}->{PRIMARY}->{cols}->[0];
2695           7                                 33         @result          = grep { $_->{column} eq $pk_first_col } @candidate_cols;
               7                                 56   
2696           7                                 44         @candidate_cols  = grep { $_->{column} ne $pk_first_col } @candidate_cols;
               7                                 53   
2697                                                     }
2698           7                                 30      my $i = 0;
2699           7                                 28      my %col_pos = map { $_ => $i++ } @{$tbl_struct->{cols}};
              28                                181   
               7                                 49   
2700           7                                 68      push @result, sort { $col_pos{$a->{column}} <=> $col_pos{$b->{column}} }
      ***      0                                  0   
2701                                                                      @candidate_cols;
2702                                                  
2703           7                                 22      if ( MKDEBUG ) {
2704                                                        _d('Chunkable columns:',
2705                                                           join(', ', map { "$_->{column} on $_->{index}" } @result));
2706                                                        _d('Can chunk exactly:', $can_chunk_exact);
2707                                                     }
2708                                                  
2709           7                                112      return ($can_chunk_exact, @result);
2710                                                  }
2711                                                  
2712                                                  sub calculate_chunks {
2713           7                    7           233      my ( $self, %args ) = @_;
2714           7                                109      foreach my $arg ( qw(dbh tbl_struct chunk_col min max rows_in_range
2715                                                                          chunk_size dbh) ) {
2716  ***     56     50                         360         die "I need a $arg argument" unless defined $args{$arg};
2717                                                     }
2718           7                                 24      MKDEBUG && _d('Calculate chunks for', Dumper(\%args));
2719           7                                 35      my $dbh = $args{dbh};
2720                                                  
2721           7                                 25      my @chunks;
2722           7                                 32      my ($range_func, $start_point, $end_point);
2723           7                                 60      my $col_type = $args{tbl_struct}->{type_for}->{$args{chunk_col}};
2724           7                                 23      MKDEBUG && _d('chunk col type:', $col_type);
2725                                                  
2726                                                  
2727  ***      7     50                          98      if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
2728           7                                 36         $start_point = $args{min};
2729           7                                 30         $end_point   = $args{max};
2730           7                                 30         $range_func  = 'range_num';
2731                                                     }
2732                                                     elsif ( $col_type eq 'timestamp' ) {
2733  ***      0                                  0         my $sql = "SELECT UNIX_TIMESTAMP('$args{min}'), UNIX_TIMESTAMP('$args{max}')";
2734  ***      0                                  0         MKDEBUG && _d($sql);
2735  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2736  ***      0                                  0         $range_func  = 'range_timestamp';
2737                                                     }
2738                                                     elsif ( $col_type eq 'date' ) {
2739  ***      0                                  0         my $sql = "SELECT TO_DAYS('$args{min}'), TO_DAYS('$args{max}')";
2740  ***      0                                  0         MKDEBUG && _d($sql);
2741  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2742  ***      0                                  0         $range_func  = 'range_date';
2743                                                     }
2744                                                     elsif ( $col_type eq 'time' ) {
2745  ***      0                                  0         my $sql = "SELECT TIME_TO_SEC('$args{min}'), TIME_TO_SEC('$args{max}')";
2746  ***      0                                  0         MKDEBUG && _d($sql);
2747  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2748  ***      0                                  0         $range_func  = 'range_time';
2749                                                     }
2750                                                     elsif ( $col_type eq 'datetime' ) {
2751  ***      0                                  0         $start_point = $self->timestampdiff($dbh, $args{min});
2752  ***      0                                  0         $end_point   = $self->timestampdiff($dbh, $args{max});
2753  ***      0                                  0         $range_func  = 'range_datetime';
2754                                                     }
2755                                                     else {
2756  ***      0                                  0         die "I don't know how to chunk $col_type\n";
2757                                                     }
2758                                                  
2759  ***      7     50                          43      if ( !defined $start_point ) {
2760  ***      0                                  0         MKDEBUG && _d('Start point is undefined');
2761  ***      0                                  0         $start_point = 0;
2762                                                     }
2763  ***      7     50     33                  126      if ( !defined $end_point || $end_point < $start_point ) {
2764  ***      0                                  0         MKDEBUG && _d('End point is undefined or before start point');
2765  ***      0                                  0         $end_point = 0;
2766                                                     }
2767           7                                 21      MKDEBUG && _d('Start and end of chunk range:',$start_point,',', $end_point);
2768                                                  
2769           7                                 78      my $interval = $args{chunk_size}
2770                                                                  * ($end_point - $start_point)
2771                                                                  / $args{rows_in_range};
2772  ***      7     50                          53      if ( $int_types{$col_type} ) {
2773           7                                 94         $interval = ceil($interval);
2774                                                     }
2775  ***      7            33                   42      $interval ||= $args{chunk_size};
2776  ***      7     50                          43      if ( $args{exact} ) {
2777  ***      0                                  0         $interval = $args{chunk_size};
2778                                                     }
2779           7                                 21      MKDEBUG && _d('Chunk interval:', $interval, 'units');
2780                                                  
2781           7                                 56      my $col = $self->{Quoter}->quote($args{chunk_col});
2782  ***      7     50                          49      if ( $start_point < $end_point ) {
2783           7                                 34         my ( $beg, $end );
2784           7                                 32         my $iter = 0;
2785                                                        for ( my $i = $start_point; $i < $end_point; $i += $interval ) {
2786          31                                223            ( $beg, $end ) = $self->$range_func($dbh, $i, $interval, $end_point);
2787                                                  
2788          31    100                         170            if ( $iter++ == 0 ) {
2789           7                                 63               push @chunks, "$col < " . $self->quote($end);
2790                                                           }
2791                                                           else {
2792          24                                142               push @chunks, "$col >= " . $self->quote($beg) . " AND $col < " . $self->quote($end);
2793                                                           }
2794           7                                 30         }
2795                                                  
2796           7                                 67         my $nullable = $args{tbl_struct}->{is_nullable}->{$args{chunk_col}};
2797           7                                 26         pop @chunks;
2798           7    100                          46         if ( @chunks ) {
2799           4                                 28            push @chunks, "$col >= " . $self->quote($beg);
2800                                                        }
2801                                                        else {
2802  ***      3     50                          24            push @chunks, $nullable ? "$col IS NOT NULL" : '1=1';
2803                                                        }
2804  ***      7     50                          47         if ( $nullable ) {
2805  ***      0                                  0            push @chunks, "$col IS NULL";
2806                                                        }
2807                                                  
2808                                                     }
2809                                                     else {
2810  ***      0                                  0         MKDEBUG && _d('No chunks; using single chunk 1=1');
2811  ***      0                                  0         push @chunks, '1=1';
2812                                                     }
2813                                                  
2814           7                                135      return @chunks;
2815                                                  }
2816                                                  
2817                                                  sub get_first_chunkable_column {
2818  ***      0                    0             0      my ( $self, %args ) = @_;
2819  ***      0                                  0      foreach my $arg ( qw(tbl_struct) ) {
2820  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2821                                                     }
2822  ***      0                                  0      my ($exact, @cols) = $self->find_chunk_columns(%args);
2823  ***      0                                  0      return ( $cols[0]->{column}, $cols[0]->{index} );
2824                                                  }
2825                                                  
2826                                                  sub size_to_rows {
2827           7                    7           246      my ( $self, %args ) = @_;
2828           7                                109      my @required_args = qw(dbh db tbl chunk_size);
2829           7                                 49      foreach my $arg ( @required_args ) {
2830  ***     28     50                         193         die "I need a $arg argument" unless $args{$arg};
2831                                                     }
2832           7                                 58      my ($dbh, $db, $tbl, $chunk_size) = @args{@required_args};
2833           7                                 34      my $q  = $self->{Quoter};
2834           7                                 33      my $du = $self->{MySQLDump};
2835                                                  
2836           7                                 40      my ($n_rows, $avg_row_length);
2837                                                  
2838           7                                121      my ( $num, $suffix ) = $chunk_size =~ m/^(\d+)([MGk])?$/;
2839  ***      7     50                          60      if ( $suffix ) { # Convert to bytes.
      ***            50                               
2840  ***      0      0                           0         $chunk_size = $suffix eq 'k' ? $num * 1_024
      ***             0                               
2841                                                                    : $suffix eq 'M' ? $num * 1_024 * 1_024
2842                                                                    :                  $num * 1_024 * 1_024 * 1_024;
2843                                                     }
2844                                                     elsif ( $num ) {
2845           7                                 35         $n_rows = $num;
2846                                                     }
2847                                                     else {
2848  ***      0                                  0         die "Invalid chunk size $chunk_size; must be an integer "
2849                                                           . "with optional suffix kMG";
2850                                                     }
2851                                                  
2852  ***      7     50     33                  113      if ( $suffix || $args{avg_row_length} ) {
2853  ***      0                                  0         my ($status) = $du->get_table_status($dbh, $q, $db, $tbl);
2854  ***      0                                  0         $avg_row_length = $status->{avg_row_length};
2855  ***      0      0                           0         if ( !defined $n_rows ) {
2856  ***      0      0                           0            $n_rows = $avg_row_length ? ceil($chunk_size / $avg_row_length) : undef;
2857                                                        }
2858                                                     }
2859                                                  
2860  ***      7     50                         112      return wantarray ? ($n_rows, $avg_row_length) : $n_rows;
2861                                                  }
2862                                                  
2863                                                  sub get_range_statistics {
2864           7                    7           258      my ( $self, %args ) = @_;
2865           7                                113      my @required_args = qw(dbh db tbl chunk_col);
2866           7                                 43      foreach my $arg ( @required_args ) {
2867  ***     28     50                         190         die "I need a $arg argument" unless $args{$arg};
2868                                                     }
2869           7                                 62      my ($dbh, $db, $tbl, $col) = @args{@required_args};
2870           7                                 32      my $where = $args{where};
2871           7                                 37      my $q = $self->{Quoter};
2872  ***      7     50                          40      my $sql = "SELECT MIN(" . $q->quote($col) . "), MAX(" . $q->quote($col)
2873                                                        . ") FROM " . $q->quote($db, $tbl)
2874                                                        . ($where ? " WHERE $where" : '');
2875           7                                 28      MKDEBUG && _d($sql);
2876           7                                 28      my ( $min, $max );
2877           7                                 29      eval {
2878           7                                 26         ( $min, $max ) = $dbh->selectrow_array($sql);
2879                                                     };
2880  ***      7     50                        2684      if ( $EVAL_ERROR ) {
2881  ***      0                                  0         chomp $EVAL_ERROR;
2882  ***      0      0                           0         if ( $EVAL_ERROR =~ m/in your SQL syntax/ ) {
2883  ***      0                                  0            die "$EVAL_ERROR (WHERE clause: $where)";
2884                                                        }
2885                                                        else {
2886  ***      0                                  0            die $EVAL_ERROR;
2887                                                        }
2888                                                     }
2889  ***      7     50                          59      $sql = "EXPLAIN SELECT * FROM " . $q->quote($db, $tbl)
2890                                                        . ($where ? " WHERE $where" : '');
2891           7                                 29      MKDEBUG && _d($sql);
2892           7                                 23      my $expl = $dbh->selectrow_hashref($sql);
2893                                                     return (
2894           7                                256         min           => $min,
2895                                                        max           => $max,
2896                                                        rows_in_range => $expl->{rows},
2897                                                     );
2898                                                  }
2899                                                  
2900                                                  sub quote {
2901          59                   59           281      my ( $self, $val ) = @_;
2902  ***     59     50                         687      return $val =~ m/\d[:-]/ ? qq{"$val"} : $val;
2903                                                  }
2904                                                  
2905                                                  sub inject_chunks {
2906          62                   62           744      my ( $self, %args ) = @_;
2907          62                                432      foreach my $arg ( qw(database table chunks chunk_num query) ) {
2908  ***    310     50                        1884         die "I need a $arg argument" unless defined $args{$arg};
2909                                                     }
2910          62                                188      MKDEBUG && _d('Injecting chunk', $args{chunk_num});
2911          62                                287      my $query   = $args{query};
2912          62                                530      my $comment = sprintf("/*%s.%s:%d/%d*/",
2913                                                        $args{database}, $args{table},
2914          62                                410         $args{chunk_num} + 1, scalar @{$args{chunks}});
2915          62                                543      $query =~ s!/\*PROGRESS_COMMENT\*/!$comment!;
2916          62                                446      my $where = "WHERE (" . $args{chunks}->[$args{chunk_num}] . ')';
2917  ***     62     50     33                  494      if ( $args{where} && grep { $_ } @{$args{where}} ) {
              62                                554   
              62                                321   
2918  ***      0                                  0         $where .= " AND ("
2919  ***      0                                  0            . join(" AND ", map { "($_)" } grep { $_ } @{$args{where}} )
      ***      0                                  0   
      ***      0                                  0   
2920                                                           . ")";
2921                                                     }
2922          62                                525      my $db_tbl     = $self->{Quoter}->quote(@args{qw(database table)});
2923  ***     62            50                  414      my $index_hint = $args{index_hint} || '';
2924                                                  
2925          62                                170      MKDEBUG && _d('Parameters:',
2926                                                        Dumper({WHERE => $where, DB_TBL => $db_tbl, INDEX_HINT => $index_hint}));
2927          62                                594      $query =~ s!/\*WHERE\*/! $where!;
2928          62                                329      $query =~ s!/\*DB_TBL\*/!$db_tbl!;
2929          62                                443      $query =~ s!/\*INDEX_HINT\*/! $index_hint!;
2930          62                                618      $query =~ s!/\*CHUNK_NUM\*/! $args{chunk_num} AS chunk_num,!;
2931                                                  
2932          62                                567      return $query;
2933                                                  }
2934                                                  
2935                                                  sub range_num {
2936          31                   31           208      my ( $self, $dbh, $start, $interval, $max ) = @_;
2937          31                                225      my $end = min($max, $start + $interval);
2938                                                  
2939                                                  
2940  ***     31     50                         181      $start = sprintf('%.17f', $start) if $start =~ /e/;
2941  ***     31     50                         177      $end   = sprintf('%.17f', $end)   if $end   =~ /e/;
2942                                                  
2943          31                                110      $start =~ s/\.(\d{5}).*$/.$1/;
2944          31                                 95      $end   =~ s/\.(\d{5}).*$/.$1/;
2945                                                  
2946  ***     31     50                         147      if ( $end > $start ) {
2947          31                                204         return ( $start, $end );
2948                                                     }
2949                                                     else {
2950  ***      0                                  0         die "Chunk size is too small: $end !> $start\n";
2951                                                     }
2952                                                  }
2953                                                  
2954                                                  sub range_time {
2955  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2956  ***      0                                  0      my $sql = "SELECT SEC_TO_TIME($start), SEC_TO_TIME(LEAST($max, $start + $interval))";
2957  ***      0                                  0      MKDEBUG && _d($sql);
2958  ***      0                                  0      return $dbh->selectrow_array($sql);
2959                                                  }
2960                                                  
2961                                                  sub range_date {
2962  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2963  ***      0                                  0      my $sql = "SELECT FROM_DAYS($start), FROM_DAYS(LEAST($max, $start + $interval))";
2964  ***      0                                  0      MKDEBUG && _d($sql);
2965  ***      0                                  0      return $dbh->selectrow_array($sql);
2966                                                  }
2967                                                  
2968                                                  sub range_datetime {
2969  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2970  ***      0                                  0      my $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $start SECOND), "
2971                                                         . "DATE_ADD('$EPOCH', INTERVAL LEAST($max, $start + $interval) SECOND)";
2972  ***      0                                  0      MKDEBUG && _d($sql);
2973  ***      0                                  0      return $dbh->selectrow_array($sql);
2974                                                  }
2975                                                  
2976                                                  sub range_timestamp {
2977  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2978  ***      0                                  0      my $sql = "SELECT FROM_UNIXTIME($start), FROM_UNIXTIME(LEAST($max, $start + $interval))";
2979  ***      0                                  0      MKDEBUG && _d($sql);
2980  ***      0                                  0      return $dbh->selectrow_array($sql);
2981                                                  }
2982                                                  
2983                                                  sub timestampdiff {
2984  ***      0                    0             0      my ( $self, $dbh, $time ) = @_;
2985  ***      0                                  0      my $sql = "SELECT (COALESCE(TO_DAYS('$time'), 0) * 86400 + TIME_TO_SEC('$time')) "
2986                                                        . "- TO_DAYS('$EPOCH 00:00:00') * 86400";
2987  ***      0                                  0      MKDEBUG && _d($sql);
2988  ***      0                                  0      my ( $diff ) = $dbh->selectrow_array($sql);
2989  ***      0                                  0      $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $diff SECOND)";
2990  ***      0                                  0      MKDEBUG && _d($sql);
2991  ***      0                                  0      my ( $check ) = $dbh->selectrow_array($sql);
2992  ***      0      0                           0      die <<"   EOF"
2993                                                     Incorrect datetime math: given $time, calculated $diff but checked to $check.
2994                                                     This is probably because you are using a version of MySQL that overflows on
2995                                                     large interval values to DATE_ADD().  If not, please report this as a bug.
2996                                                     EOF
2997                                                        unless $check eq $time;
2998  ***      0                                  0      return $diff;
2999                                                  }
3000                                                  
3001                                                  sub _d {
3002  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3003  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3004  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3005                                                          @_;
3006  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3007                                                  }
3008                                                  
3009                                                  1;
3010                                                  
3011                                                  # ###########################################################################
3012                                                  # End TableChunker package
3013                                                  # ###########################################################################
3014                                                  
3015                                                  # ###########################################################################
3016                                                  # TableChecksum package 5712
3017                                                  # ###########################################################################
3018                                                  package TableChecksum;
3019                                                  
3020          29                   29           252   use strict;
              29                                 99   
              29                                191   
3021          29                   29           194   use warnings FATAL => 'all';
              29                                 90   
              29                                176   
3022          29                   29           174   use English qw(-no_match_vars);
              29                                 77   
              29                                173   
3023          29                   29           202   use List::Util qw(max);
              29                                 72   
              29                                158   
3024                                                  
3025  ***     29            50     29           192   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 80   
              29                                436   
3026                                                  
3027                                                  our %ALGOS = (
3028                                                     CHECKSUM => { pref => 0, hash => 0 },
3029                                                     BIT_XOR  => { pref => 2, hash => 1 },
3030                                                     ACCUM    => { pref => 3, hash => 1 },
3031                                                  );
3032                                                  
3033                                                  sub new {
3034           5                    5            53      my ( $class, %args ) = @_;
3035           5                                 38      foreach my $arg ( qw(Quoter VersionParser) ) {
3036  ***     10     50                          72         die "I need a $arg argument" unless defined $args{$arg};
3037                                                     }
3038           5                                 35      my $self = { %args };
3039           5                                 63      return bless $self, $class;
3040                                                  }
3041                                                  
3042                                                  sub crc32 {
3043  ***      0                    0             0      my ( $self, $string ) = @_;
3044  ***      0                                  0      my $poly = 0xEDB88320;
3045  ***      0                                  0      my $crc  = 0xFFFFFFFF;
3046  ***      0                                  0      foreach my $char ( split(//, $string) ) {
3047  ***      0                                  0         my $comp = ($crc ^ ord($char)) & 0xFF;
3048  ***      0                                  0         for ( 1 .. 8 ) {
3049  ***      0      0                           0            $comp = $comp & 1 ? $poly ^ ($comp >> 1) : $comp >> 1;
3050                                                        }
3051  ***      0                                  0         $crc = (($crc >> 8) & 0x00FFFFFF) ^ $comp;
3052                                                     }
3053  ***      0                                  0      return $crc ^ 0xFFFFFFFF;
3054                                                  }
3055                                                  
3056                                                  sub get_crc_wid {
3057           7                    7            54      my ( $self, $dbh, $func ) = @_;
3058           7                                 33      my $crc_wid = 16;
3059  ***      7     50     33                  112      if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
3060           7                                 25         eval {
3061           7                                 29            my ($val) = $dbh->selectrow_array("SELECT $func('a')");
3062           7                               1173            $crc_wid = max(16, length($val));
3063                                                        };
3064                                                     }
3065           7                                 42      return $crc_wid;
3066                                                  }
3067                                                  
3068                                                  sub get_crc_type {
3069           7                    7            49      my ( $self, $dbh, $func ) = @_;
3070           7                                 32      my $type   = '';
3071           7                                 52      my $length = 0;
3072           7                                 41      my $sql    = "SELECT $func('a')";
3073           7                                 22      my $sth    = $dbh->prepare($sql);
3074           7                                 52      eval {
3075           7                                931         $sth->execute();
3076           7                                 98         $type   = $sth->{mysql_type_name}->[0];
3077           7                                 68         $length = $sth->{mysql_length}->[0];
3078           7                                 48         MKDEBUG && _d($sql, $type, $length);
3079  ***      7     50     33                  127         if ( $type eq 'bigint' && $length < 20 ) {
3080           7                                 40            $type = 'int';
3081                                                        }
3082                                                     };
3083           7                                 93      $sth->finish;
3084           7                                 21      MKDEBUG && _d('crc_type:', $type, 'length:', $length);
3085           7                                178      return ($type, $length);
3086                                                  }
3087                                                  
3088                                                  sub best_algorithm {
3089          14                   14           154      my ( $self, %args ) = @_;
3090          14                                107      my ( $alg, $dbh ) = @args{ qw(algorithm dbh) };
3091          14                                 68      my $vp = $self->{VersionParser};
3092          14                                 32      my @choices = sort { $ALGOS{$a}->{pref} <=> $ALGOS{$b}->{pref} } keys %ALGOS;
              42                                282   
3093  ***     14     50     33                  278      die "Invalid checksum algorithm $alg"
3094                                                        if $alg && !$ALGOS{$alg};
3095                                                  
3096  ***     14     50     33                  173      if (
      ***                   33                        
      ***                   33                        
3097                                                        $args{where} || $args{chunk}        # CHECKSUM does whole table
3098                                                        || $args{replicate}                 # CHECKSUM can't do INSERT.. SELECT
3099                                                        || !$vp->version_ge($dbh, '4.1.1')) # CHECKSUM doesn't exist
3100                                                     {
3101          14                                 42         MKDEBUG && _d('Cannot use CHECKSUM algorithm');
3102          14                                 64         @choices = grep { $_ ne 'CHECKSUM' } @choices;
              42                                241   
3103                                                     }
3104                                                  
3105  ***     14     50                          98      if ( !$vp->version_ge($dbh, '4.1.1') ) {
3106  ***      0                                  0         MKDEBUG && _d('Cannot use BIT_XOR algorithm because MySQL < 4.1.1');
3107  ***      0                                  0         @choices = grep { $_ ne 'BIT_XOR' } @choices;
      ***      0                                  0   
3108                                                     }
3109                                                  
3110  ***     14     50     33                  128      if ( $alg && grep { $_ eq $alg } @choices ) {
              28                                210   
3111          14                                 41         MKDEBUG && _d('User requested', $alg, 'algorithm');
3112          14                                109         return $alg;
3113                                                     }
3114                                                  
3115  ***      0      0      0                    0      if ( $args{count} && grep { $_ ne 'CHECKSUM' } @choices ) {
      ***      0                                  0   
3116  ***      0                                  0         MKDEBUG && _d('Not using CHECKSUM algorithm because COUNT desired');
3117  ***      0                                  0         @choices = grep { $_ ne 'CHECKSUM' } @choices;
      ***      0                                  0   
3118                                                     }
3119                                                  
3120  ***      0                                  0      MKDEBUG && _d('Algorithms, in order:', @choices);
3121  ***      0                                  0      return $choices[0];
3122                                                  }
3123                                                  
3124                                                  sub is_hash_algorithm {
3125  ***      0                    0             0      my ( $self, $algorithm ) = @_;
3126  ***      0             0                    0      return $ALGOS{$algorithm} && $ALGOS{$algorithm}->{hash};
3127                                                  }
3128                                                  
3129                                                  sub choose_hash_func {
3130          14                   14           398      my ( $self, %args ) = @_;
3131          14                                203      my @funcs = qw(CRC32 FNV1A_64 FNV_64 MD5 SHA1);
3132  ***     14     50                          89      if ( $args{function} ) {
3133  ***      0                                  0         unshift @funcs, $args{function};
3134                                                     }
3135          14                                 52      my ($result, $error);
3136  ***     14            33                   56      do {
3137          14                                 44         my $func;
3138          14                                 54         eval {
3139          14                                 67            $func = shift(@funcs);
3140          14                                 83            my $sql = "SELECT $func('test-string')";
3141          14                                 41            MKDEBUG && _d($sql);
3142          14                               2330            $args{dbh}->do($sql);
3143          14                                 97            $result = $func;
3144                                                        };
3145  ***     14     50     33                  288         if ( $EVAL_ERROR && $EVAL_ERROR =~ m/failed: (.*?) at \S+ line/ ) {
3146  ***      0                                  0            $error .= qq{$func cannot be used because "$1"\n};
3147  ***      0                                  0            MKDEBUG && _d($func, 'cannot be used because', $1);
3148                                                        }
3149                                                     } while ( @funcs && !$result );
3150                                                  
3151  ***     14     50                          78      die $error unless $result;
3152          14                                 42      MKDEBUG && _d('Chosen hash func:', $result);
3153          14                                206      return $result;
3154                                                  }
3155                                                  
3156                                                  sub optimize_xor {
3157  ***      0                    0             0      my ( $self, %args ) = @_;
3158  ***      0                                  0      my ($dbh, $func) = @args{qw(dbh function)};
3159                                                  
3160  ***      0      0                           0      die "$func never needs the BIT_XOR optimization"
3161                                                        if $func =~ m/^(?:FNV1A_64|FNV_64|CRC32)$/i;
3162                                                  
3163  ***      0                                  0      my $opt_slice = 0;
3164  ***      0                                  0      my $unsliced  = uc $dbh->selectall_arrayref("SELECT $func('a')")->[0]->[0];
3165  ***      0                                  0      my $sliced    = '';
3166  ***      0                                  0      my $start     = 1;
3167  ***      0      0                           0      my $crc_wid   = length($unsliced) < 16 ? 16 : length($unsliced);
3168                                                  
3169  ***      0             0                    0      do { # Try different positions till sliced result equals non-sliced.
3170  ***      0                                  0         MKDEBUG && _d('Trying slice', $opt_slice);
3171  ***      0                                  0         $dbh->do('SET @crc := "", @cnt := 0');
3172  ***      0                                  0         my $slices = $self->make_xor_slices(
3173                                                           query     => "\@crc := $func('a')",
3174                                                           crc_wid   => $crc_wid,
3175                                                           opt_slice => $opt_slice,
3176                                                        );
3177                                                  
3178  ***      0                                  0         my $sql = "SELECT CONCAT($slices) AS TEST FROM (SELECT NULL) AS x";
3179  ***      0                                  0         $sliced = ($dbh->selectrow_array($sql))[0];
3180  ***      0      0                           0         if ( $sliced ne $unsliced ) {
3181  ***      0                                  0            MKDEBUG && _d('Slice', $opt_slice, 'does not work');
3182  ***      0                                  0            $start += 16;
3183  ***      0                                  0            ++$opt_slice;
3184                                                        }
3185                                                     } while ( $start < $crc_wid && $sliced ne $unsliced );
3186                                                  
3187  ***      0      0                           0      if ( $sliced eq $unsliced ) {
3188  ***      0                                  0         MKDEBUG && _d('Slice', $opt_slice, 'works');
3189  ***      0                                  0         return $opt_slice;
3190                                                     }
3191                                                     else {
3192  ***      0                                  0         MKDEBUG && _d('No slice works');
3193  ***      0                                  0         return undef;
3194                                                     }
3195                                                  }
3196                                                  
3197                                                  sub make_xor_slices {
3198  ***      0                    0             0      my ( $self, %args ) = @_;
3199  ***      0                                  0      foreach my $arg ( qw(query crc_wid) ) {
3200  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
3201                                                     }
3202  ***      0                                  0      my ( $query, $crc_wid, $opt_slice ) = @args{qw(query crc_wid opt_slice)};
3203                                                  
3204  ***      0                                  0      my @slices;
3205                                                     for ( my $start = 1; $start <= $crc_wid; $start += 16 ) {
3206  ***      0                                  0         my $len = $crc_wid - $start + 1;
3207  ***      0      0                           0         if ( $len > 16 ) {
3208  ***      0                                  0            $len = 16;
3209                                                        }
3210  ***      0                                  0         push @slices,
3211                                                           "LPAD(CONV(BIT_XOR("
3212                                                           . "CAST(CONV(SUBSTRING(\@crc, $start, $len), 16, 10) AS UNSIGNED))"
3213                                                           . ", 10, 16), $len, '0')";
3214  ***      0                                  0      }
3215                                                  
3216  ***      0      0      0                    0      if ( defined $opt_slice && $opt_slice < @slices ) {
3217  ***      0                                  0         $slices[$opt_slice] =~ s/\@crc/\@crc := $query/;
3218                                                     }
3219                                                     else {
3220  ***      0                                  0         map { s/\@crc/$query/ } @slices;
      ***      0                                  0   
3221                                                     }
3222                                                  
3223  ***      0                                  0      return join(', ', @slices);
3224                                                  }
3225                                                  
3226                                                  sub make_row_checksum {
3227          14                   14           438      my ( $self, %args ) = @_;
3228          14                                196      my ( $tbl_struct, $func ) = @args{ qw(tbl_struct function) };
3229          14                                 63      my $q = $self->{Quoter};
3230                                                  
3231  ***     14            50                  169      my $sep = $args{sep} || '#';
3232          14                                 92      $sep =~ s/'//g;
3233  ***     14            50                   72      $sep ||= '#';
3234                                                  
3235          14                                 56      my %ignorecols = map { $_ => 1 } @{$args{ignorecols}};
      ***      0                                  0   
              14                                108   
3236                                                  
3237          70                                439      my %cols = map { lc($_) => 1 }
              70                                340   
3238          14                                 78                 grep { !exists $ignorecols{$_} }
3239  ***     14     50                          96                 ($args{cols} ? @{$args{cols}} : @{$tbl_struct->{cols}});
      ***      0                                  0   
3240          14                                 82      my %seen;
3241          56                                319      my @cols =
3242                                                        map {
3243  ***     56     50                         684            my $type = $tbl_struct->{type_for}->{$_};
3244          56                                296            my $result = $q->quote($_);
3245  ***     56    100     33                  789            if ( $type eq 'timestamp' ) {
      ***            50     66                        
      ***            50                               
3246          14                                 63               $result .= ' + 0';
3247                                                           }
3248                                                           elsif ( $type =~ m/float|double/ && $args{float_precision} ) {
3249  ***      0                                  0               $result = "ROUND($result, $args{float_precision})";
3250                                                           }
3251                                                           elsif ( $type =~ m/varchar/ && $args{trim} ) {
3252  ***      0                                  0               $result = "TRIM($result)";
3253                                                           }
3254          56                                304            $result;
3255                                                        }
3256                                                        grep {
3257          14                                 92            $cols{$_} && !$seen{$_}++
3258                                                        }
3259          14                                 55         @{$tbl_struct->{cols}};
3260                                                  
3261          14                                 66      my $query;
3262          14    100                          94      if ( !$args{no_cols} ) {
3263          28                                 99         $query = join(', ',
3264                                                                    map { 
3265           7                                 38                        my $col = $_;
3266          28    100                         169                        if ( $col =~ m/\+ 0/ ) {
3267           7                                 73                           my ($real_col) = /^(\S+)/;
3268           7                                 38                           $col .= " AS $real_col";
3269                                                                       }
3270          28                                136                        $col;
3271                                                                    } @cols)
3272                                                               . ', ';
3273                                                     }
3274                                                  
3275  ***     14     50     33                  197      if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
3276          14                                 54         my @nulls = grep { $cols{$_} } @{$tbl_struct->{null_cols}};
              14                                 88   
              14                                 87   
3277  ***     14     50                          88         if ( @nulls ) {
3278          14                                 81            my $bitmap = "CONCAT("
3279          14                                 65               . join(', ', map { 'ISNULL(' . $q->quote($_) . ')' } @nulls)
3280                                                              . ")";
3281          14                                 76            push @cols, $bitmap;
3282                                                        }
3283                                                  
3284  ***     14     50                         163         $query .= @cols > 1
3285                                                                ? "$func(CONCAT_WS('$sep', " . join(', ', @cols) . '))'
3286                                                                : "$func($cols[0])";
3287                                                     }
3288                                                     else {
3289  ***      0                                  0         my $fnv_func = uc $func;
3290  ***      0                                  0         $query .= "$fnv_func(" . join(', ', @cols) . ')';
3291                                                     }
3292                                                  
3293          14                                219      return $query;
3294                                                  }
3295                                                  
3296                                                  sub make_checksum_query {
3297           7                    7           302      my ( $self, %args ) = @_;
3298           7                                119      my @required_args = qw(db tbl tbl_struct algorithm crc_wid crc_type);
3299           7                                 50      foreach my $arg( @required_args ) {
3300  ***     42     50                         310         die "I need a $arg argument" unless $args{$arg};
3301                                                     }
3302           7                                 65      my ( $db, $tbl, $tbl_struct, $algorithm,
3303                                                          $crc_wid, $crc_type) = @args{@required_args};
3304           7                                 44      my $func = $args{function};
3305           7                                 34      my $q = $self->{Quoter};
3306           7                                 26      my $result;
3307                                                  
3308  ***      7     50     33                  112      die "Invalid or missing checksum algorithm"
3309                                                        unless $algorithm && $ALGOS{$algorithm};
3310                                                  
3311  ***      7     50                          46      if ( $algorithm eq 'CHECKSUM' ) {
3312  ***      0                                  0         return "CHECKSUM TABLE " . $q->quote($db, $tbl);
3313                                                     }
3314                                                  
3315           7                                134      my $expr = $self->make_row_checksum(%args, no_cols=>1);
3316                                                  
3317  ***      7     50                          78      if ( $algorithm eq 'BIT_XOR' ) {
3318  ***      7     50                          68         if ( $crc_type =~ m/int$/ ) {
3319           7                                 49            $result = "LOWER(CONV(BIT_XOR(CAST($expr AS UNSIGNED)), 10, 16)) AS crc ";
3320                                                        }
3321                                                        else {
3322  ***      0                                  0            my $slices = $self->make_xor_slices( query => $expr, %args );
3323  ***      0                                  0            $result = "LOWER(CONCAT($slices)) AS crc ";
3324                                                        }
3325                                                     }
3326                                                     else {
3327  ***      0      0                           0         if ( $crc_type =~ m/int$/ ) {
3328  ***      0                                  0            $result = "RIGHT(MAX("
3329                                                              . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
3330                                                              . "CONV(CAST($func(CONCAT(\@crc, $expr)) AS UNSIGNED), 10, 16))"
3331                                                              . "), $crc_wid) AS crc ";
3332                                                        }
3333                                                        else {
3334  ***      0                                  0            $result = "RIGHT(MAX("
3335                                                              . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
3336                                                              . "$func(CONCAT(\@crc, $expr)))"
3337                                                              . "), $crc_wid) AS crc ";
3338                                                        }
3339                                                     }
3340  ***      7     50                          41      if ( $args{replicate} ) {
3341  ***      0                                  0         $result = "REPLACE /*PROGRESS_COMMENT*/ INTO $args{replicate} "
3342                                                           . "(db, tbl, chunk, boundaries, this_cnt, this_crc) "
3343                                                           . "SELECT ?, ?, /*CHUNK_NUM*/ ?, COUNT(*) AS cnt, $result";
3344                                                     }
3345                                                     else {
3346  ***      7     50                          65         $result = "SELECT "
3347                                                           . ($args{buffer} ? 'SQL_BUFFER_RESULT ' : '')
3348                                                           . "/*PROGRESS_COMMENT*//*CHUNK_NUM*/ COUNT(*) AS cnt, $result";
3349                                                     }
3350           7                                112      return $result . "FROM /*DB_TBL*//*INDEX_HINT*//*WHERE*/";
3351                                                  }
3352                                                  
3353                                                  sub find_replication_differences {
3354  ***      0                    0             0      my ( $self, $dbh, $table ) = @_;
3355                                                  
3356  ***      0                                  0      (my $sql = <<"   EOF") =~ s/\s+/ /gm;
3357                                                        SELECT db, tbl, chunk, boundaries,
3358                                                           COALESCE(this_cnt-master_cnt, 0) AS cnt_diff,
3359                                                           COALESCE(
3360                                                              this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc),
3361                                                              0
3362                                                           ) AS crc_diff,
3363                                                           this_cnt, master_cnt, this_crc, master_crc
3364                                                        FROM $table
3365                                                        WHERE master_cnt <> this_cnt OR master_crc <> this_crc
3366                                                        OR ISNULL(master_crc) <> ISNULL(this_crc)
3367                                                     EOF
3368                                                  
3369  ***      0                                  0      MKDEBUG && _d($sql);
3370  ***      0                                  0      my $diffs = $dbh->selectall_arrayref($sql, { Slice => {} });
3371  ***      0                                  0      return @$diffs;
3372                                                  }
3373                                                  
3374                                                  sub _d {
3375  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3376  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3377  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3378                                                          @_;
3379  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3380                                                  }
3381                                                  
3382                                                  1;
3383                                                  
3384                                                  # ###########################################################################
3385                                                  # End TableChecksum package
3386                                                  # ###########################################################################
3387                                                  
3388                                                  # ###########################################################################
3389                                                  # TableSyncChunk package 5712
3390                                                  # ###########################################################################
3391                                                  package TableSyncChunk;
3392                                                  
3393          29                   29           268   use strict;
              29                                 84   
              29                                198   
3394          29                   29           181   use warnings FATAL => 'all';
              29                                 74   
              29                                178   
3395                                                  
3396          29                   29           176   use English qw(-no_match_vars);
              29                                 82   
              29                                169   
3397          29                   29           218   use List::Util qw(max);
              29                                 82   
              29                                174   
3398          29                   29           184   use Data::Dumper;
              29                                 75   
              29                                155   
3399                                                  $Data::Dumper::Indent    = 1;
3400                                                  $Data::Dumper::Sortkeys  = 1;
3401                                                  $Data::Dumper::Quotekeys = 0;
3402                                                  
3403  ***     29            50     29           186   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 99   
              29                                442   
3404                                                  
3405                                                  sub new {
3406           5                    5            77      my ( $class, %args ) = @_;
3407           5                                 46      foreach my $arg ( qw(TableChunker Quoter) ) {
3408  ***     10     50                          73         die "I need a $arg argument" unless defined $args{$arg};
3409                                                     }
3410           5                                 66      my $self = { %args };
3411           5                                 79      return bless $self, $class;
3412                                                  }
3413                                                  
3414                                                  sub name {
3415           6                    6           142      return 'Chunk';
3416                                                  }
3417                                                  
3418                                                  sub set_callback {
3419          15                   15            98      my ( $self, $callback, $code ) = @_;
3420          15                                104      $self->{$callback} = $code;
3421          15                                 56      return;
3422                                                  }
3423                                                  
3424                                                  sub can_sync {
3425           7                    7           223      my ( $self, %args ) = @_;
3426           7                                 89      foreach my $arg ( qw(tbl_struct) ) {
3427  ***      7     50                          71         die "I need a $arg argument" unless defined $args{$arg};
3428                                                     }
3429                                                  
3430           7                                145      my ($exact, @chunkable_cols) = $self->{TableChunker}->find_chunk_columns(
3431                                                        %args,
3432                                                        exact => 1,
3433                                                     );
3434  ***      7     50                          62      return unless $exact;
3435                                                  
3436           7                                 28      my $colno;
3437  ***      7     50     33                  104      if ( $args{chunk_col} || $args{chunk_index} ) {
3438  ***      0                                  0         MKDEBUG && _d('Checking requested col', $args{chunk_col},
3439                                                           'and/or index', $args{chunk_index});
3440  ***      0                                  0         for my $i ( 0..$#chunkable_cols ) {
3441  ***      0      0                           0            if ( $args{chunk_col} ) {
3442  ***      0      0                           0               next unless $chunkable_cols[$i]->{column} eq $args{chunk_col};
3443                                                           }
3444  ***      0      0                           0            if ( $args{chunk_index} ) {
3445  ***      0      0                           0               next unless $chunkable_cols[$i]->{index} eq $args{chunk_index};
3446                                                           }
3447  ***      0                                  0            $colno = $i;
3448  ***      0                                  0            last;
3449                                                        }
3450                                                  
3451  ***      0      0                           0         if ( !$colno ) {
3452  ***      0                                  0            MKDEBUG && _d('Cannot chunk on column', $args{chunk_col},
3453                                                              'and/or using index', $args{chunk_index});
3454  ***      0                                  0            return;
3455                                                        }
3456                                                     }
3457                                                     else {
3458           7                                 33         $colno = 0;  # First, best chunkable column/index.
3459                                                     }
3460                                                  
3461           7                                 24      MKDEBUG && _d('Can chunk on column', $chunkable_cols[$colno]->{column},
3462                                                        'using index', $chunkable_cols[$colno]->{index});
3463                                                     return (
3464           7                                145         1,
3465                                                        chunk_col   => $chunkable_cols[$colno]->{column},
3466                                                        chunk_index => $chunkable_cols[$colno]->{index},
3467                                                     ),
3468                                                  }
3469                                                  
3470                                                  sub prepare_to_sync {
3471           7                    7           261      my ( $self, %args ) = @_;
3472           7                                118      my @required_args = qw(dbh db tbl tbl_struct cols chunk_col
3473                                                                            chunk_size crc_col ChangeHandler);
3474           7                                 47      foreach my $arg ( @required_args ) {
3475  ***     63     50                         406         die "I need a $arg argument" unless defined $args{$arg};
3476                                                     }
3477           7                                 41      my $chunker  = $self->{TableChunker};
3478                                                  
3479           7                                 47      $self->{chunk_col}       = $args{chunk_col};
3480           7                                 51      $self->{crc_col}         = $args{crc_col};
3481           7                                 41      $self->{index_hint}      = $args{index_hint};
3482           7                                 36      $self->{buffer_in_mysql} = $args{buffer_in_mysql};
3483           7                                 43      $self->{ChangeHandler}   = $args{ChangeHandler};
3484                                                  
3485           7                                197      $self->{ChangeHandler}->fetch_back($args{dbh});
3486                                                  
3487           7                                 27      push @{$args{cols}}, $args{chunk_col};
               7                                 46   
3488                                                  
3489           7                                 26      my @chunks;
3490  ***      7     50                          53      if ( !$args{replicate} ) {
3491           7                                137         my %range_params = $chunker->get_range_statistics(%args);
3492  ***      7     50                          80         if ( !grep { !defined $range_params{$_} } qw(min max rows_in_range) ) {
              21                                133   
3493           7                                131            $args{chunk_size} = $chunker->size_to_rows(%args);
3494           7                                150            @chunks = $chunker->calculate_chunks(%args, %range_params);
3495                                                        }
3496                                                        else {
3497  ***      0                                  0            MKDEBUG && _d('No range statistics; using single chunk 1=1');
3498  ***      0                                  0            @chunks = '1=1';
3499                                                        }
3500                                                     }
3501                                                     else {
3502  ***      0                                  0         MKDEBUG && _d('Using --replicate boundary instead of chunks');
3503  ***      0                                  0         @chunks = '1=1';
3504                                                     }
3505                                                  
3506           7                                 85      $self->{chunks}    = \@chunks;
3507           7                                 41      $self->{chunk_num} = 0;
3508           7                                 38      $self->{state}     = 0;
3509                                                  
3510           7                                 94      return;
3511                                                  }
3512                                                  
3513                                                  sub uses_checksum {
3514           7                    7            46      return 1;
3515                                                  }
3516                                                  
3517                                                  sub set_checksum_queries {
3518           7                    7            56      my ( $self, $chunk_sql, $row_sql ) = @_;
3519  ***      7     50                          44      die "I need a chunk_sql argument" unless $chunk_sql;
3520  ***      7     50                          41      die "I need a row_sql argument" unless $row_sql;
3521           7                                 42      $self->{chunk_sql} = $chunk_sql;
3522           7                                 35      $self->{row_sql}   = $row_sql;
3523           7                                 34      return;
3524                                                  }
3525                                                  
3526                                                  sub prepare_sync_cycle {
3527         102                  102           527      my ( $self, $host ) = @_;
3528         102                                427      my $sql = 'SET @crc := "", @cnt := 0';
3529         102                                307      MKDEBUG && _d($sql);
3530         102                              14325      $host->{dbh}->do($sql);
3531         102                                527      return;
3532                                                  }
3533                                                  
3534                                                  sub get_sql {
3535         102                  102           887      my ( $self, %args ) = @_;
3536         102    100                         631      if ( $self->{state} ) {  # select rows in a chunk
3537          40                                180         my $q = $self->{Quoter};
3538          40                                189         return 'SELECT /*rows in chunk*/ '
3539                                                           . ($self->{buffer_in_mysql} ? 'SQL_BUFFER_RESULT ' : '')
3540                                                           . $self->{row_sql} . " AS $self->{crc_col}"
3541                                                           . ' FROM ' . $self->{Quoter}->quote(@args{qw(database table)})
3542                                                           . ' '. ($self->{index_hint} || '')
3543                                                           . ' WHERE (' . $self->{chunks}->[$self->{chunk_num}] . ')'
3544                                                           . ($args{where} ? " AND ($args{where})" : '')
3545  ***     40     50     50                  654            . ' ORDER BY ' . join(', ', map {$q->quote($_) } @{$self->key_cols()});
      ***     40     50                         188   
3546                                                     }
3547                                                     else {  # select a chunk of rows
3548          62                                939         return $self->{TableChunker}->inject_chunks(
3549                                                           database   => $args{database},
3550                                                           table      => $args{table},
3551                                                           chunks     => $self->{chunks},
3552                                                           chunk_num  => $self->{chunk_num},
3553                                                           query      => $self->{chunk_sql},
3554                                                           index_hint => $self->{index_hint},
3555                                                           where      => [ $args{where} ],
3556                                                        );
3557                                                     }
3558                                                  }
3559                                                  
3560                                                  sub same_row {
3561          97                   97          1035      my ( $self, %args ) = @_;
3562          97                                796      my ($lr, $rr) = @args{qw(lr rr)};
3563                                                  
3564          97    100    100                 1024      if ( $self->{state} ) {  # checksumming rows
                    100                               
3565          66    100                         772         if ( $lr->{$self->{crc_col}} ne $rr->{$self->{crc_col}} ) {
3566          26                                108            my $action   = 'UPDATE';
3567          26                                 93            my $auth_row = $lr;
3568          26                                 79            my $change_dbh;
3569                                                  
3570  ***     26     50                         177            if ( $self->{same_row} ) {
3571          26                                260               ($action, $auth_row, $change_dbh) = $self->{same_row}->(%args);
3572                                                           }
3573                                                  
3574          25                                217            $self->{ChangeHandler}->change(
3575                                                              $action,            # Execute the action
3576                                                              $auth_row,          # with these row values
3577                                                              $self->key_cols(),  # identified by these key cols
3578                                                              $change_dbh,        # on this dbh
3579                                                           );
3580                                                        }
3581                                                     }
3582                                                     elsif ( $lr->{cnt} != $rr->{cnt} || $lr->{crc} ne $rr->{crc} ) {
3583          20                                 63         MKDEBUG && _d('Rows:', Dumper($lr, $rr));
3584          20                                 60         MKDEBUG && _d('Will examine this chunk before moving to next');
3585          20                                147         $self->{state} = 1; # Must examine this chunk row-by-row
3586                                                     }
3587                                                  }
3588                                                  
3589                                                  sub not_in_right {
3590           7                    7            91      my ( $self, %args ) = @_;
3591  ***      7     50                          66      die "Called not_in_right in state 0" unless $self->{state};
3592                                                  
3593           7                                 31      my $action   = 'INSERT';
3594           7                                 29      my $auth_row = $args{lr};
3595           7                                 25      my $change_dbh;
3596                                                  
3597  ***      7     50                          52      if ( $self->{not_in_right} ) {
3598           7                                 74         ($action, $auth_row, $change_dbh) = $self->{not_in_right}->(%args);
3599                                                     }
3600                                                  
3601           7                                 62      $self->{ChangeHandler}->change(
3602                                                        $action,            # Execute the action
3603                                                        $auth_row,          # with these row values
3604                                                        $self->key_cols(),  # identified by these key cols
3605                                                        $change_dbh,        # on this dbh
3606                                                     );
3607           7                                 65      return;
3608                                                  }
3609                                                  
3610                                                  sub not_in_left {
3611           7                    7            86      my ( $self, %args ) = @_;
3612  ***      7     50                          59      die "Called not_in_left in state 0" unless $self->{state};
3613                                                  
3614           7                                 30      my $action   = 'DELETE';
3615           7                                 29      my $auth_row = $args{rr};
3616           7                                 30      my $change_dbh;
3617                                                  
3618  ***      7     50                          52      if ( $self->{not_in_left} ) {
3619           7                                 70         ($action, $auth_row, $change_dbh) = $self->{not_in_left}->(%args);
3620                                                     }
3621                                                  
3622           7                                 61      $self->{ChangeHandler}->change(
3623                                                        $action,            # Execute the action
3624                                                        $auth_row,          # with these row values
3625                                                        $self->key_cols(),  # identified by these key cols
3626                                                        $change_dbh,        # on this dbh
3627                                                     );
3628           7                                 64      return;
3629                                                  }
3630                                                  
3631                                                  sub done_with_rows {
3632          50                   50           244      my ( $self ) = @_;
3633          50    100                         356      if ( $self->{state} == 1 ) {
3634          20                                 87         $self->{state} = 2;
3635          20                                 62         MKDEBUG && _d('Setting state =', $self->{state});
3636                                                     }
3637                                                     else {
3638          30                                148         $self->{state} = 0;
3639          30                                131         $self->{chunk_num}++;
3640          30                                 95         MKDEBUG && _d('Setting state =', $self->{state},
3641                                                           'chunk_num =', $self->{chunk_num});
3642                                                     }
3643          50                                474      return;
3644                                                  }
3645                                                  
3646                                                  sub done {
3647          57                   57           310      my ( $self ) = @_;
3648                                                     MKDEBUG && _d('Done with', $self->{chunk_num}, 'of',
3649          57                                175         scalar(@{$self->{chunks}}), 'chunks');
3650          57                                176      MKDEBUG && $self->{state} && _d('Chunk differs; must examine rows');
3651          37                                439      return $self->{state} == 0
3652          57           100                  645         && $self->{chunk_num} >= scalar(@{$self->{chunks}})
3653                                                  }
3654                                                  
3655                                                  sub pending_changes {
3656          44                   44           208      my ( $self ) = @_;
3657          44    100                         249      if ( $self->{state} ) {
3658          20                                 56         MKDEBUG && _d('There are pending changes');
3659          20                                200         return 1;
3660                                                     }
3661                                                     else {
3662          24                                 82         MKDEBUG && _d('No pending changes');
3663          24                                261         return 0;
3664                                                     }
3665                                                  }
3666                                                  
3667                                                  sub key_cols {
3668         134                  134           616      my ( $self ) = @_;
3669         134                                460      my @cols;
3670         134    100                         814      if ( $self->{state} == 0 ) {
3671          31                                170         @cols = qw(chunk_num);
3672                                                     }
3673                                                     else {
3674         103                                656         @cols = $self->{chunk_col};
3675                                                     }
3676         134                                398      MKDEBUG && _d('State', $self->{state},',', 'key cols', join(', ', @cols));
3677         134                               1037      return \@cols;
3678                                                  }
3679                                                  
3680                                                  sub _d {
3681  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3682  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3683  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3684                                                          @_;
3685  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3686                                                  }
3687                                                  
3688                                                  1;
3689                                                  
3690                                                  # ###########################################################################
3691                                                  # End TableSyncChunk package
3692                                                  # ###########################################################################
3693                                                  
3694                                                  # ###########################################################################
3695                                                  # TableSyncNibble package 5712
3696                                                  # ###########################################################################
3697                                                  package TableSyncNibble;
3698                                                  
3699          29                   29           240   use strict;
              29                                 84   
              29                                182   
3700          29                   29           182   use warnings FATAL => 'all';
              29                                 83   
              29                                163   
3701                                                  
3702          29                   29           186   use English qw(-no_match_vars);
              29                                 70   
              29                                157   
3703          29                   29           210   use List::Util qw(max);
              29                                 77   
              29                                159   
3704          29                   29           193   use Data::Dumper;
              29                                 72   
              29                                157   
3705                                                  $Data::Dumper::Indent    = 1;
3706                                                  $Data::Dumper::Sortkeys  = 1;
3707                                                  $Data::Dumper::Quotekeys = 0;
3708                                                  
3709  ***     29            50     29           187   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 76   
              29                                416   
3710                                                  
3711                                                  sub new {
3712  ***      0                    0             0      my ( $class, %args ) = @_;
3713  ***      0                                  0      foreach my $arg ( qw(TableNibbler TableChunker TableParser Quoter) ) {
3714  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
3715                                                     }
3716  ***      0                                  0      my $self = { %args };
3717  ***      0                                  0      return bless $self, $class;
3718                                                  }
3719                                                  
3720                                                  sub name {
3721  ***      0                    0             0      return 'Nibble';
3722                                                  }
3723                                                  
3724                                                  sub can_sync {
3725  ***      0                    0             0      my ( $self, %args ) = @_;
3726  ***      0                                  0      foreach my $arg ( qw(tbl_struct) ) {
3727  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
3728                                                     }
3729                                                  
3730  ***      0                                  0      my $nibble_index = $self->{TableParser}->find_best_index($args{tbl_struct});
3731  ***      0      0                           0      if ( $nibble_index ) {
3732  ***      0                                  0         MKDEBUG && _d('Best nibble index:', Dumper($nibble_index));
3733  ***      0      0                           0         if ( !$args{tbl_struct}->{keys}->{$nibble_index}->{is_unique} ) {
3734  ***      0                                  0            MKDEBUG && _d('Best nibble index is not unique');
3735  ***      0                                  0            return;
3736                                                        }
3737  ***      0      0      0                    0         if ( $args{chunk_index} && $args{chunk_index} ne $nibble_index ) {
3738  ***      0                                  0            MKDEBUG && _d('Best nibble index is not requested index',
3739                                                              $args{chunk_index});
3740  ***      0                                  0            return;
3741                                                        }
3742                                                     }
3743                                                     else {
3744  ***      0                                  0         MKDEBUG && _d('No best nibble index returned');
3745  ***      0                                  0         return;
3746                                                     }
3747                                                  
3748  ***      0                                  0      my $small_table = 0;
3749  ***      0      0      0                    0      if ( $args{src} && $args{src}->{dbh} ) {
3750  ***      0                                  0         my $dbh = $args{src}->{dbh};
3751  ***      0                                  0         my $db  = $args{src}->{db};
3752  ***      0                                  0         my $tbl = $args{src}->{tbl};
3753  ***      0                                  0         my $table_status;
3754  ***      0                                  0         eval {
3755  ***      0                                  0            my $sql = "SHOW TABLE STATUS FROM `$db` LIKE "
3756                                                                   . $self->{Quoter}->literal_like($tbl);
3757  ***      0                                  0            MKDEBUG && _d($sql);
3758  ***      0                                  0            $table_status = $dbh->selectrow_hashref($sql);
3759                                                        };
3760  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3761  ***      0      0                           0         if ( $table_status ) {
3762  ***      0      0                           0            my $n_rows   = defined $table_status->{Rows} ? $table_status->{Rows}
      ***             0                               
3763                                                                        : defined $table_status->{rows} ? $table_status->{rows}
3764                                                                        : undef;
3765  ***      0      0      0                    0            $small_table = 1 if defined $n_rows && $n_rows <= 100;
3766                                                        }
3767                                                     }
3768  ***      0                                  0      MKDEBUG && _d('Small table:', $small_table);
3769                                                  
3770  ***      0                                  0      MKDEBUG && _d('Can nibble using index', $nibble_index);
3771                                                     return (
3772  ***      0                                  0         1,
3773                                                        chunk_index => $nibble_index,
3774                                                        key_cols    => $args{tbl_struct}->{keys}->{$nibble_index}->{cols},
3775                                                        small_table => $small_table,
3776                                                     );
3777                                                  }
3778                                                  
3779                                                  sub prepare_to_sync {
3780  ***      0                    0             0      my ( $self, %args ) = @_;
3781  ***      0                                  0      my @required_args = qw(dbh db tbl tbl_struct chunk_index key_cols chunk_size
3782                                                                            crc_col ChangeHandler);
3783  ***      0                                  0      foreach my $arg ( @required_args ) {
3784  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
3785                                                     }
3786                                                  
3787  ***      0                                  0      $self->{dbh}             = $args{dbh};
3788  ***      0                                  0      $self->{tbl_struct}      = $args{tbl_struct};
3789  ***      0                                  0      $self->{crc_col}         = $args{crc_col};
3790  ***      0                                  0      $self->{index_hint}      = $args{index_hint};
3791  ***      0                                  0      $self->{key_cols}        = $args{key_cols};
3792  ***      0                                  0      $self->{chunk_size}      = $self->{TableChunker}->size_to_rows(%args);
3793  ***      0                                  0      $self->{buffer_in_mysql} = $args{buffer_in_mysql};
3794  ***      0                                  0      $self->{small_table}     = $args{small_table};
3795  ***      0                                  0      $self->{ChangeHandler}   = $args{ChangeHandler};
3796                                                  
3797  ***      0                                  0      $self->{ChangeHandler}->fetch_back($args{dbh});
3798                                                  
3799  ***      0                                  0      my %seen;
3800  ***      0                                  0      my @ucols = grep { !$seen{$_}++ } @{$args{cols}}, @{$args{key_cols}};
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
3801  ***      0                                  0      $args{cols} = \@ucols;
3802                                                  
3803  ***      0      0                           0      if ( !$args{replicate} ) {
3804  ***      0                                  0         $self->{sel_stmt} = $self->{TableNibbler}->generate_asc_stmt(
3805                                                           %args,
3806                                                           index    => $args{chunk_index}, # expects an index arg, not chunk_index
3807                                                           asc_only => 1,
3808                                                        );
3809                                                     }
3810                                                     else {
3811  ***      0                                  0         MKDEBUG && _d('Using --replicate boundary instead of nibble boundaries');
3812  ***      0                                  0         $self->{sel_stmt} = undef;
3813                                                     }
3814                                                  
3815  ***      0                                  0      $self->{nibble}            = 0;
3816  ***      0                                  0      $self->{cached_row}        = undef;
3817  ***      0                                  0      $self->{cached_nibble}     = undef;
3818  ***      0                                  0      $self->{cached_boundaries} = undef;
3819  ***      0                                  0      $self->{state}             = 0;
3820                                                  
3821  ***      0                                  0      return;
3822                                                  }
3823                                                  
3824                                                  sub uses_checksum {
3825  ***      0                    0             0      return 1;
3826                                                  }
3827                                                  
3828                                                  sub set_checksum_queries {
3829  ***      0                    0             0      my ( $self, $nibble_sql, $row_sql ) = @_;
3830  ***      0      0                           0      die "I need a nibble_sql argument" unless $nibble_sql;
3831  ***      0      0                           0      die "I need a row_sql argument" unless $row_sql;
3832  ***      0                                  0      $self->{nibble_sql} = $nibble_sql;
3833  ***      0                                  0      $self->{row_sql} = $row_sql;
3834  ***      0                                  0      return;
3835                                                  }
3836                                                  
3837                                                  sub prepare_sync_cycle {
3838  ***      0                    0             0      my ( $self, $host ) = @_;
3839  ***      0                                  0      my $sql = 'SET @crc := "", @cnt := 0';
3840  ***      0                                  0      MKDEBUG && _d($sql);
3841  ***      0                                  0      $host->{dbh}->do($sql);
3842  ***      0                                  0      return;
3843                                                  }
3844                                                  
3845                                                  sub get_sql {
3846  ***      0                    0             0      my ( $self, %args ) = @_;
3847  ***      0      0                           0      if ( $self->{state} ) {
3848  ***      0                                  0         my $q = $self->{Quoter};
3849  ***      0                                  0         return 'SELECT /*rows in nibble*/ '
3850                                                           . ($self->{buffer_in_mysql} ? 'SQL_BUFFER_RESULT ' : '')
3851                                                           . $self->{row_sql} . " AS $self->{crc_col}"
3852                                                           . ' FROM ' . $q->quote(@args{qw(database table)})
3853                                                           . ' ' . ($self->{index_hint} ? $self->{index_hint} : '')
3854                                                           . ' WHERE (' . $self->__get_boundaries(%args) . ')'
3855                                                           . ($args{where} ? " AND ($args{where})" : '')
3856  ***      0      0                           0            . ' ORDER BY ' . join(', ', map {$q->quote($_) } @{$self->key_cols()});
      ***      0      0                           0   
      ***             0                               
3857                                                     }
3858                                                     else {
3859  ***      0                                  0         my $where = $self->__get_boundaries(%args);
3860  ***      0                                  0         return $self->{TableChunker}->inject_chunks(
3861                                                           database   => $args{database},
3862                                                           table      => $args{table},
3863                                                           chunks     => [ $where ],
3864                                                           chunk_num  => 0,
3865                                                           query      => $self->{nibble_sql},
3866                                                           index_hint => $self->{index_hint},
3867                                                           where      => [ $args{where} ],
3868                                                        );
3869                                                     }
3870                                                  }
3871                                                  
3872                                                  sub __get_boundaries {
3873  ***      0                    0             0      my ( $self, %args ) = @_;
3874  ***      0                                  0      my $q = $self->{Quoter};
3875  ***      0                                  0      my $s = $self->{sel_stmt};
3876                                                  
3877  ***      0      0                           0      if ( !$s ) {
3878  ***      0                                  0         MKDEBUG && _d('No sel_stmt so WHERE clause 1=1 (for --replicate)');
3879  ***      0                                  0         return '1=1';
3880                                                     }
3881                                                  
3882  ***      0                                  0      my $lb;   # Lower boundary part of WHERE
3883  ***      0                                  0      my $ub;   # Upper boundary part of WHERE
3884  ***      0                                  0      my $row;  # Next upper boundary row or cached_row
3885                                                  
3886  ***      0      0                           0      if ( $self->{cached_boundaries} ) {
3887  ***      0                                  0         MKDEBUG && _d('Using cached boundaries');
3888  ***      0                                  0         return $self->{cached_boundaries};
3889                                                     }
3890                                                  
3891  ***      0      0      0                    0      if ( $self->{cached_row} && $self->{cached_nibble} == $self->{nibble} ) {
3892  ***      0                                  0         MKDEBUG && _d('Using cached row for boundaries');
3893  ***      0                                  0         $row = $self->{cached_row};
3894                                                     }
3895                                                     else {
3896  ***      0                                  0         MKDEBUG && _d('Getting next upper boundary row');
3897  ***      0                                  0         my $sql;
3898  ***      0                                  0         ($sql, $lb) = $self->__make_boundary_sql(%args);  # $lb from outer scope!
3899                                                  
3900  ***      0      0      0                    0         if ( $self->{nibble} == 0 && !$self->{small_table} ) {
3901  ***      0                                  0            my $explain_index = $self->__get_explain_index($sql);
3902  ***      0      0      0                    0            if ( lc($explain_index || '') ne lc($s->{index}) ) {
3903  ***      0      0                           0               die 'Cannot nibble table '.$q->quote($args{database}, $args{table})
3904                                                                 . " because MySQL chose "
3905                                                                 . ($explain_index ? "the `$explain_index`" : 'no') . ' index'
3906                                                                 . " instead of the `$s->{index}` index";
3907                                                           }
3908                                                        }
3909                                                  
3910  ***      0                                  0         $row = $self->{dbh}->selectrow_hashref($sql);
3911  ***      0                                  0         MKDEBUG && _d($row ? 'Got a row' : "Didn't get a row");
3912                                                     }
3913                                                  
3914  ***      0      0                           0      if ( $row ) {
3915  ***      0                                  0         my $i = 0;
3916  ***      0                                  0         $ub   = $s->{boundaries}->{'<='};
3917  ***      0             0                    0         $ub   =~ s/\?/$q->quote_val($row->{$s->{scols}->[$i]}, $self->{tbl_struct}->{is_numeric}->{$s->{scols}->[$i++]} || 0)/eg;
      ***      0                                  0   
3918                                                     }
3919                                                     else {
3920  ***      0                                  0         MKDEBUG && _d('No upper boundary');
3921  ***      0                                  0         $ub = '1=1';
3922                                                     }
3923                                                  
3924  ***      0      0                           0      my $where = $lb ? "($lb AND $ub)" : $ub;
3925                                                  
3926  ***      0                                  0      $self->{cached_row}        = $row;
3927  ***      0                                  0      $self->{cached_nibble}     = $self->{nibble};
3928  ***      0                                  0      $self->{cached_boundaries} = $where;
3929                                                  
3930  ***      0                                  0      MKDEBUG && _d('WHERE clause:', $where);
3931  ***      0                                  0      return $where;
3932                                                  }
3933                                                  
3934                                                  sub __make_boundary_sql {
3935  ***      0                    0             0      my ( $self, %args ) = @_;
3936  ***      0                                  0      my $lb;
3937  ***      0                                  0      my $q   = $self->{Quoter};
3938  ***      0                                  0      my $s   = $self->{sel_stmt};
3939  ***      0                                  0      my $sql = "SELECT /*nibble boundary $self->{nibble}*/ "
3940  ***      0             0                    0         . join(',', map { $q->quote($_) } @{$s->{cols}})
      ***      0                                  0   
3941                                                        . " FROM " . $q->quote($args{database}, $args{table})
3942                                                        . ' ' . ($self->{index_hint} || '');
3943                                                  
3944  ***      0      0                           0      if ( $self->{nibble} ) {
3945  ***      0                                  0         my $tmp = $self->{cached_row};
3946  ***      0                                  0         my $i   = 0;
3947  ***      0                                  0         $lb     = $s->{boundaries}->{'>'};
3948  ***      0             0                    0         $lb     =~ s/\?/$q->quote_val($tmp->{$s->{scols}->[$i]}, $self->{tbl_struct}->{is_numeric}->{$s->{scols}->[$i++]} || 0)/eg;
      ***      0                                  0   
3949  ***      0                                  0         $sql   .= ' WHERE ' . $lb;
3950                                                     }
3951  ***      0                                  0      $sql .= " ORDER BY " . join(',', map { $q->quote($_) } @{$self->{key_cols}})
      ***      0                                  0   
      ***      0                                  0   
3952                                                           . ' LIMIT ' . ($self->{chunk_size} - 1) . ', 1';
3953  ***      0                                  0      MKDEBUG && _d('Lower boundary:', $lb);
3954  ***      0                                  0      MKDEBUG && _d('Next boundary sql:', $sql);
3955  ***      0                                  0      return $sql, $lb;
3956                                                  }
3957                                                  
3958                                                  sub __get_explain_index {
3959  ***      0                    0             0      my ( $self, $sql ) = @_;
3960  ***      0      0                           0      return unless $sql;
3961  ***      0                                  0      my $explain;
3962  ***      0                                  0      eval {
3963  ***      0                                  0         $explain = $self->{dbh}->selectall_arrayref("EXPLAIN $sql",{Slice => {}});
3964                                                     };
3965  ***      0      0                           0      if ( $EVAL_ERROR ) {
3966  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
3967  ***      0                                  0         return;
3968                                                     }
3969  ***      0                                  0      MKDEBUG && _d('EXPLAIN key:', $explain->[0]->{key}); 
3970  ***      0                                  0      return $explain->[0]->{key};
3971                                                  }
3972                                                  
3973                                                  sub same_row {
3974  ***      0                    0             0      my ( $self, %args ) = @_;
3975  ***      0                                  0      my ($lr, $rr) = @args{qw(lr rr)};
3976  ***      0      0      0                    0      if ( $self->{state} ) {
      ***             0      0                        
      ***                    0                        
3977  ***      0      0                           0         if ( $lr->{$self->{crc_col}} ne $rr->{$self->{crc_col}} ) {
3978  ***      0                                  0            $self->{ChangeHandler}->change('UPDATE', $lr, $self->key_cols());
3979                                                        }
3980                                                     }
3981                                                     elsif ( $lr->{cnt} != $rr->{cnt} || ($lr->{crc} || 0) ne ($rr->{crc} || 0) ) 
3982                                                     {
3983  ***      0                                  0         MKDEBUG && _d('Rows:', Dumper($lr, $rr));
3984  ***      0                                  0         MKDEBUG && _d('Will examine this nibble before moving to next');
3985  ***      0                                  0         $self->{state} = 1; # Must examine this nibble row-by-row
3986                                                     }
3987                                                  }
3988                                                  
3989                                                  sub not_in_right {
3990  ***      0                    0             0      my ( $self, %args ) = @_;
3991  ***      0      0                           0      die "Called not_in_right in state 0" unless $self->{state};
3992  ***      0                                  0      $self->{ChangeHandler}->change('INSERT', $args{lr}, $self->key_cols());
3993                                                  }
3994                                                  
3995                                                  sub not_in_left {
3996  ***      0                    0             0      my ( $self, %args ) = @_;
3997  ***      0      0                           0      die "Called not_in_left in state 0" unless $self->{state};
3998  ***      0                                  0      $self->{ChangeHandler}->change('DELETE', $args{rr}, $self->key_cols());
3999                                                  }
4000                                                  
4001                                                  sub done_with_rows {
4002  ***      0                    0             0      my ( $self ) = @_;
4003  ***      0      0                           0      if ( $self->{state} == 1 ) {
4004  ***      0                                  0         $self->{state} = 2;
4005  ***      0                                  0         MKDEBUG && _d('Setting state =', $self->{state});
4006                                                     }
4007                                                     else {
4008  ***      0                                  0         $self->{state} = 0;
4009  ***      0                                  0         $self->{nibble}++;
4010  ***      0                                  0         delete $self->{cached_boundaries};
4011  ***      0                                  0         MKDEBUG && _d('Setting state =', $self->{state},
4012                                                           ', nibble =', $self->{nibble});
4013                                                     }
4014                                                  }
4015                                                  
4016                                                  sub done {
4017  ***      0                    0             0      my ( $self ) = @_;
4018  ***      0                                  0      MKDEBUG && _d('Done with nibble', $self->{nibble});
4019  ***      0                                  0      MKDEBUG && $self->{state} && _d('Nibble differs; must examine rows');
4020  ***      0             0                    0      return $self->{state} == 0 && $self->{nibble} && !$self->{cached_row};
      ***                    0                        
4021                                                  }
4022                                                  
4023                                                  sub pending_changes {
4024  ***      0                    0             0      my ( $self ) = @_;
4025  ***      0      0                           0      if ( $self->{state} ) {
4026  ***      0                                  0         MKDEBUG && _d('There are pending changes');
4027  ***      0                                  0         return 1;
4028                                                     }
4029                                                     else {
4030  ***      0                                  0         MKDEBUG && _d('No pending changes');
4031  ***      0                                  0         return 0;
4032                                                     }
4033                                                  }
4034                                                  
4035                                                  sub key_cols {
4036  ***      0                    0             0      my ( $self ) = @_;
4037  ***      0                                  0      my @cols;
4038  ***      0      0                           0      if ( $self->{state} == 0 ) {
4039  ***      0                                  0         @cols = qw(chunk_num);
4040                                                     }
4041                                                     else {
4042  ***      0                                  0         @cols = @{$self->{key_cols}};
      ***      0                                  0   
4043                                                     }
4044  ***      0                                  0      MKDEBUG && _d('State', $self->{state},',', 'key cols', join(', ', @cols));
4045  ***      0                                  0      return \@cols;
4046                                                  }
4047                                                  
4048                                                  sub _d {
4049  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4050  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4051  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4052                                                          @_;
4053  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4054                                                  }
4055                                                  
4056                                                  1;
4057                                                  
4058                                                  # ###########################################################################
4059                                                  # End TableSyncNibble package
4060                                                  # ###########################################################################
4061                                                  
4062                                                  # ###########################################################################
4063                                                  # TableSyncGroupBy package 5697
4064                                                  # ###########################################################################
4065                                                  package TableSyncGroupBy;
4066                                                  
4067          29                   29           251   use strict;
              29                                 88   
              29                                208   
4068          29                   29           182   use warnings FATAL => 'all';
              29                                 73   
              29                                166   
4069                                                  
4070          29                   29           175   use English qw(-no_match_vars);
              29                                 70   
              29                                169   
4071                                                  
4072  ***     29            50     29           197   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 81   
              29                                633   
4073                                                  
4074                                                  sub new {
4075  ***      0                    0             0      my ( $class, %args ) = @_;
4076  ***      0                                  0      foreach my $arg ( qw(Quoter) ) {
4077  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
4078                                                     }
4079  ***      0                                  0      my $self = { %args };
4080  ***      0                                  0      return bless $self, $class;
4081                                                  }
4082                                                  
4083                                                  sub name {
4084  ***      0                    0             0      return 'GroupBy';
4085                                                  }
4086                                                  
4087                                                  sub can_sync {
4088  ***      0                    0             0      return 1;  # We can sync anything.
4089                                                  }
4090                                                  
4091                                                  sub prepare_to_sync {
4092  ***      0                    0             0      my ( $self, %args ) = @_;
4093  ***      0                                  0      my @required_args = qw(tbl_struct cols ChangeHandler);
4094  ***      0                                  0      foreach my $arg ( @required_args ) {
4095  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
4096                                                     }
4097                                                  
4098  ***      0                                  0      $self->{cols}            = $args{cols};
4099  ***      0                                  0      $self->{buffer_in_mysql} = $args{buffer_in_mysql};
4100  ***      0                                  0      $self->{ChangeHandler}   = $args{ChangeHandler};
4101                                                  
4102  ***      0                                  0      $self->{count_col} = '__maatkit_count';
4103  ***      0                                  0      while ( $args{tbl_struct}->{is_col}->{$self->{count_col}} ) {
4104  ***      0                                  0         $self->{count_col} = "_$self->{count_col}";
4105                                                     }
4106  ***      0                                  0      MKDEBUG && _d('COUNT column will be named', $self->{count_col});
4107                                                  
4108  ***      0                                  0      $self->{done} = 0;
4109                                                  
4110  ***      0                                  0      return;
4111                                                  }
4112                                                  
4113                                                  sub uses_checksum {
4114  ***      0                    0             0      return 0;  # We don't need checksum queries.
4115                                                  }
4116                                                  
4117                                                  sub set_checksum_queries {
4118  ***      0                    0             0      return;  # This shouldn't be called, but just in case.
4119                                                  }
4120                                                  
4121                                                  sub prepare_sync_cycle {
4122  ***      0                    0             0      my ( $self, $host ) = @_;
4123  ***      0                                  0      return;
4124                                                  }
4125                                                  
4126                                                  sub get_sql {
4127  ***      0                    0             0      my ( $self, %args ) = @_;
4128  ***      0                                  0      my $cols = join(', ', map { $self->{Quoter}->quote($_) } @{$self->{cols}});
      ***      0                                  0   
      ***      0                                  0   
4129  ***      0      0      0                    0      return "SELECT"
4130                                                        . ($self->{buffer_in_mysql} ? ' SQL_BUFFER_RESULT' : '')
4131                                                        . " $cols, COUNT(*) AS $self->{count_col}"
4132                                                        . ' FROM ' . $self->{Quoter}->quote(@args{qw(database table)})
4133                                                        . ' WHERE ' . ( $args{where} || '1=1' )
4134                                                        . " GROUP BY $cols ORDER BY $cols";
4135                                                  }
4136                                                  
4137                                                  sub same_row {
4138  ***      0                    0             0      my ( $self, %args ) = @_;
4139  ***      0                                  0      my ($lr, $rr) = @args{qw(lr rr)};
4140  ***      0                                  0      my $cc   = $self->{count_col};
4141  ***      0                                  0      my $lc   = $lr->{$cc};
4142  ***      0                                  0      my $rc   = $rr->{$cc};
4143  ***      0                                  0      my $diff = abs($lc - $rc);
4144  ***      0      0                           0      return unless $diff;
4145  ***      0                                  0      $lr = { %$lr };
4146  ***      0                                  0      delete $lr->{$cc};
4147  ***      0                                  0      $rr = { %$rr };
4148  ***      0                                  0      delete $rr->{$cc};
4149  ***      0                                  0      foreach my $i ( 1 .. $diff ) {
4150  ***      0      0                           0         if ( $lc > $rc ) {
4151  ***      0                                  0            $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
4152                                                        }
4153                                                        else {
4154  ***      0                                  0            $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
4155                                                        }
4156                                                     }
4157                                                  }
4158                                                  
4159                                                  sub not_in_right {
4160  ***      0                    0             0      my ( $self, %args ) = @_;
4161  ***      0                                  0      my $lr = $args{lr};
4162  ***      0                                  0      $lr = { %$lr };
4163  ***      0                                  0      my $cnt = delete $lr->{$self->{count_col}};
4164  ***      0                                  0      foreach my $i ( 1 .. $cnt ) {
4165  ***      0                                  0         $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
4166                                                     }
4167                                                  }
4168                                                  
4169                                                  sub not_in_left {
4170  ***      0                    0             0      my ( $self, %args ) = @_;
4171  ***      0                                  0      my $rr = $args{rr};
4172  ***      0                                  0      $rr = { %$rr };
4173  ***      0                                  0      my $cnt = delete $rr->{$self->{count_col}};
4174  ***      0                                  0      foreach my $i ( 1 .. $cnt ) {
4175  ***      0                                  0         $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
4176                                                     }
4177                                                  }
4178                                                  
4179                                                  sub done_with_rows {
4180  ***      0                    0             0      my ( $self ) = @_;
4181  ***      0                                  0      $self->{done} = 1;
4182                                                  }
4183                                                  
4184                                                  sub done {
4185  ***      0                    0             0      my ( $self ) = @_;
4186  ***      0                                  0      return $self->{done};
4187                                                  }
4188                                                  
4189                                                  sub key_cols {
4190  ***      0                    0             0      my ( $self ) = @_;
4191  ***      0                                  0      return $self->{cols};
4192                                                  }
4193                                                  
4194                                                  sub pending_changes {
4195  ***      0                    0             0      my ( $self ) = @_;
4196  ***      0                                  0      return;
4197                                                  }
4198                                                  
4199                                                  sub _d {
4200  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4201  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4202  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4203                                                          @_;
4204  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4205                                                  }
4206                                                  
4207                                                  1;
4208                                                  
4209                                                  # ###########################################################################
4210                                                  # End TableSyncGroupBy package
4211                                                  # ###########################################################################
4212                                                  
4213                                                  # ###########################################################################
4214                                                  # TableSyncer package 5700
4215                                                  # ###########################################################################
4216                                                  package TableSyncer;
4217                                                  
4218          29                   29           220   use strict;
              29                                 84   
              29                                209   
4219          29                   29           179   use warnings FATAL => 'all';
              29                                 73   
              29                                257   
4220                                                  
4221          29                   29           175   use English qw(-no_match_vars);
              29                                 78   
              29                                149   
4222          29                   29           201   use Data::Dumper;
              29                                 77   
              29                                188   
4223                                                  $Data::Dumper::Indent    = 1;
4224                                                  $Data::Dumper::Sortkeys  = 1;
4225                                                  $Data::Dumper::Quotekeys = 0;
4226                                                  
4227  ***     29            50     29           189   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 87   
              29                                760   
4228                                                  
4229                                                  sub new {
4230           5                    5            53      my ( $class, %args ) = @_;
4231           5                                 52      my @required_args = qw(MasterSlave Quoter VersionParser TableChecksum);
4232           5                                 35      foreach my $arg ( @required_args ) {
4233  ***     20     50                         132         die "I need a $arg argument" unless defined $args{$arg};
4234                                                     }
4235           5                                 46      my $self = { %args };
4236           5                                 66      return bless $self, $class;
4237                                                  }
4238                                                  
4239                                                  sub get_best_plugin {
4240           7                    7           263      my ( $self, %args ) = @_;
4241           7                                 95      foreach my $arg ( qw(plugins tbl_struct) ) {
4242  ***     14     50                         106         die "I need a $arg argument" unless $args{$arg};
4243                                                     }
4244           7                                 24      MKDEBUG && _d('Getting best plugin');
4245           7                                 25      foreach my $plugin ( @{$args{plugins}} ) {
               7                                 49   
4246           7                                 22         MKDEBUG && _d('Trying plugin', $plugin->name);
4247           7                                114         my ($can_sync, %plugin_args) = $plugin->can_sync(%args);
4248  ***      7     50                          68         if ( $can_sync ) {
4249           7                                 22           MKDEBUG && _d('Can sync with', $plugin->name, Dumper(\%plugin_args));
4250           7                                127           return $plugin, %plugin_args;
4251                                                        }
4252                                                     }
4253  ***      0                                  0      MKDEBUG && _d('No plugin can sync the table');
4254  ***      0                                  0      return;
4255                                                  }
4256                                                  
4257                                                  sub sync_table {
4258           7                    7           330      my ( $self, %args ) = @_;
4259           7                                118      my @required_args = qw(plugins src dst tbl_struct cols chunk_size
4260                                                                            RowDiff ChangeHandler);
4261           7                                 46      foreach my $arg ( @required_args ) {
4262  ***     56     50                         399         die "I need a $arg argument" unless $args{$arg};
4263                                                     }
4264           7                                 31      MKDEBUG && _d('Syncing table with args', Dumper(\%args));
4265           7                                 66      my ($plugins, $src, $dst, $tbl_struct, $cols, $chunk_size, $rd, $ch)
4266                                                        = @args{@required_args};
4267                                                  
4268  ***      7     50     33                  126      if ( $args{bidirectional} && $args{ChangeHandler}->{queue} ) {
4269  ***      0                                  0         die "Queueing does not work with bidirectional syncing";
4270                                                     }
4271                                                  
4272  ***      7     50                          45      $args{index_hint}    = 1 unless defined $args{index_hint};
4273  ***      7            50                   49      $args{lock}        ||= 0;
4274  ***      7            50                   43      $args{wait}        ||= 0;
4275  ***      7            50                   43      $args{transaction} ||= 0;
4276  ***      7            50                   45      $args{timeout_ok}  ||= 0;
4277                                                  
4278           7                                 38      my $q  = $self->{Quoter};
4279           7                                 34      my $vp = $self->{VersionParser};
4280                                                  
4281           7                                116      my ($plugin, %plugin_args) = $self->get_best_plugin(%args);
4282  ***      7     50                          78      die "No plugin can sync $src->{db}.$src->{tbl}" unless $plugin;
4283                                                  
4284           7                                 32      my $crc_col = '__crc';
4285           7                                 63      while ( $tbl_struct->{is_col}->{$crc_col} ) {
4286  ***      0                                  0         $crc_col = "_$crc_col"; # Prepend more _ until not a column.
4287                                                     }
4288           7                                 22      MKDEBUG && _d('CRC column:', $crc_col);
4289                                                  
4290           7                                 36      my $index_hint;
4291  ***      7     50                          45      if ( !$args{replicate} ) {
4292  ***      7     50     33                   62         my $hint = ($vp->version_ge($src->{dbh}, '4.0.9')
4293                                                                    && $vp->version_ge($dst->{dbh}, '4.0.9') ? 'FORCE' : 'USE')
4294                                                                 . ' INDEX';
4295  ***      7     50     33                  157         if ( $args{chunk_index} ) {
      ***            50                               
4296  ***      0                                  0            MKDEBUG && _d('Using given chunk index for index hint');
4297  ***      0                                  0            $index_hint = "$hint (" . $q->quote($args{chunk_index}) . ")";
4298                                                        }
4299                                                        elsif ( $plugin_args{chunk_index} && $args{index_hint} ) {
4300           7                                 23            MKDEBUG && _d('Using chunk index chosen by plugin for index hint');
4301           7                                 58            $index_hint = "$hint (" . $q->quote($plugin_args{chunk_index}) . ")";
4302                                                        }
4303           7                                 26         MKDEBUG && _d('Index hint:', $index_hint);
4304                                                     }
4305                                                     else {
4306  ***      0                                  0         MKDEBUG && _d('No index hint for --replicate');
4307                                                     }
4308                                                  
4309           7                                 30      eval {
4310           7                                177         $plugin->prepare_to_sync(
4311                                                           %args,
4312                                                           %plugin_args,
4313                                                           dbh        => $src->{dbh},
4314                                                           db         => $src->{db},
4315                                                           tbl        => $src->{tbl},
4316                                                           crc_col    => $crc_col,
4317                                                           index_hint => $index_hint,
4318                                                        );
4319                                                     };
4320  ***      7     50                          72      if ( $EVAL_ERROR ) {
4321  ***      0                                  0         die 'Failed to prepare TableSync', $plugin->name, ' plugin: ',
4322                                                           $EVAL_ERROR;
4323                                                     }
4324                                                  
4325  ***      7     50                          54      if ( $plugin->uses_checksum() ) {
4326           7                                 28         eval {
4327           7                                133            my ($chunk_sql, $row_sql) = $self->make_checksum_queries(%args);
4328           7                                 88            $plugin->set_checksum_queries($chunk_sql, $row_sql);
4329                                                        };
4330  ***      7     50                          43         if ( $EVAL_ERROR ) {
4331  ***      0                                  0            die "Failed to make checksum queries: $EVAL_ERROR";
4332                                                        }
4333                                                     } 
4334                                                  
4335  ***      7     50                          51      if ( $args{dry_run} ) {
4336  ***      0                                  0         return $ch->get_changes(), ALGORITHM => $plugin->name;
4337                                                     }
4338                                                  
4339                                                  
4340           7                                 26      eval {
4341           7                               1077         $src->{dbh}->do("USE `$src->{db}`");
4342           7                                943         $dst->{dbh}->do("USE `$dst->{db}`");
4343                                                     };
4344  ***      7     50                          58      if ( $EVAL_ERROR ) {
4345  ***      0                                  0         die "Failed to USE database on source or destination: $EVAL_ERROR";
4346                                                     }
4347                                                  
4348           7                                 23      MKDEBUG && _d('left dbh', $src->{dbh});
4349           7                                 22      MKDEBUG && _d('right dbh', $dst->{dbh});
4350                                                  
4351           7                                140      $self->lock_and_wait(%args, lock_level => 2);  # per-table lock
4352                                                     
4353           7                                 55      my $callback = $args{callback};
4354           7                                 26      my $cycle    = 0;
4355           7                                 83      while ( !$plugin->done() ) {
4356                                                  
4357          51                                179         MKDEBUG && _d('Beginning sync cycle', $cycle);
4358          51                                545         my $src_sql = $plugin->get_sql(
4359                                                           database => $src->{db},
4360                                                           table    => $src->{tbl},
4361                                                           where    => $args{where},
4362                                                        );
4363          51                                508         my $dst_sql = $plugin->get_sql(
4364                                                           database => $dst->{db},
4365                                                           table    => $dst->{tbl},
4366                                                           where    => $args{where},
4367                                                        );
4368          51                                203         MKDEBUG && _d('src:', $src_sql);
4369          51                                147         MKDEBUG && _d('dst:', $dst_sql);
4370                                                  
4371  ***     51     50                         335         if ( $args{transaction} ) {
4372  ***     51     50                         280            if ( $args{bidirectional} ) {
      ***             0                               
4373          51                                206               $src_sql .= ' FOR UPDATE';
4374          51                                213               $dst_sql .= ' FOR UPDATE';
4375                                                           }
4376                                                           elsif ( $args{changing_src} ) {
4377  ***      0                                  0               $src_sql .= ' FOR UPDATE';
4378  ***      0                                  0               $dst_sql .= ' LOCK IN SHARE MODE';
4379                                                           }
4380                                                           else {
4381  ***      0                                  0               $src_sql .= ' LOCK IN SHARE MODE';
4382  ***      0                                  0               $dst_sql .= ' FOR UPDATE';
4383                                                           }
4384                                                        }
4385                                                  
4386  ***     51     50                         255         $callback->($src_sql, $dst_sql) if $callback;
4387                                                  
4388          51                                296         $plugin->prepare_sync_cycle($src);
4389          51                                302         $plugin->prepare_sync_cycle($dst);
4390                                                  
4391          51                                188         my $src_sth = $src->{dbh}->prepare($src_sql);
4392          51                                129         my $dst_sth = $dst->{dbh}->prepare($dst_sql);
4393  ***     51     50                         478         if ( $args{buffer_to_client} ) {
4394  ***      0                                  0            $src_sth->{mysql_use_result} = 1;
4395  ***      0                                  0            $dst_sth->{mysql_use_result} = 1;
4396                                                        }
4397                                                  
4398          51                                206         my $executed_src = 0;
4399          51    100    100                  500         if ( !$cycle || !$plugin->pending_changes() ) {
4400          31                                578            $executed_src
4401                                                              = $self->lock_and_wait(%args, src_sth => $src_sth, lock_level => 1);
4402                                                        }
4403                                                  
4404  ***     51     50                       20203         $src_sth->execute() unless $executed_src;
4405          51                              17703         $dst_sth->execute();
4406                                                  
4407          51                                707         $rd->compare_sets(
4408                                                           left_sth   => $src_sth,
4409                                                           right_sth  => $dst_sth,
4410                                                           left_dbh   => $src->{dbh},
4411                                                           right_dbh  => $dst->{dbh},
4412                                                           syncer     => $plugin,
4413                                                           tbl_struct => $tbl_struct,
4414                                                        );
4415          50                                360         $ch->process_rows(1);
4416                                                  
4417          50                                141         MKDEBUG && _d('Finished sync cycle', $cycle);
4418          50                               1851         $cycle++;
4419                                                     }
4420                                                  
4421           6                                 35      $ch->process_rows();
4422                                                  
4423           6                                129      $self->unlock(%args, lock_level => 2);
4424                                                  
4425           6                                 57      return $ch->get_changes(), ALGORITHM => $plugin->name;
4426                                                  }
4427                                                  
4428                                                  sub make_checksum_queries {
4429           7                    7           208      my ( $self, %args ) = @_;
4430           7                                100      my @required_args = qw(src dst tbl_struct);
4431           7                                 44      foreach my $arg ( @required_args ) {
4432  ***     21     50                         150         die "I need a $arg argument" unless $args{$arg};
4433                                                     }
4434           7                                 50      my ($src, $dst, $tbl_struct) = @args{@required_args};
4435           7                                 35      my $checksum = $self->{TableChecksum};
4436                                                  
4437           7                                108      my $src_algo = $checksum->best_algorithm(
4438                                                        algorithm => 'BIT_XOR',
4439                                                        dbh       => $src->{dbh},
4440                                                        where     => 1,
4441                                                        chunk     => 1,
4442                                                        count     => 1,
4443                                                     );
4444           7                                 66      my $dst_algo = $checksum->best_algorithm(
4445                                                        algorithm => 'BIT_XOR',
4446                                                        dbh       => $dst->{dbh},
4447                                                        where     => 1,
4448                                                        chunk     => 1,
4449                                                        count     => 1,
4450                                                     );
4451  ***      7     50                          46      if ( $src_algo ne $dst_algo ) {
4452  ***      0                                  0         die "Source and destination checksum algorithms are different: ",
4453                                                           "$src_algo on source, $dst_algo on destination"
4454                                                     }
4455           7                                 21      MKDEBUG && _d('Chosen algo:', $src_algo);
4456                                                  
4457           7                                139      my $src_func = $checksum->choose_hash_func(dbh => $src->{dbh}, %args);
4458           7                                139      my $dst_func = $checksum->choose_hash_func(dbh => $dst->{dbh}, %args);
4459  ***      7     50                          69      if ( $src_func ne $dst_func ) {
4460  ***      0                                  0         die "Source and destination hash functions are different: ",
4461                                                        "$src_func on source, $dst_func on destination";
4462                                                     }
4463           7                                 21      MKDEBUG && _d('Chosen hash func:', $src_func);
4464                                                  
4465                                                  
4466           7                                111      my $crc_wid    = $checksum->get_crc_wid($src->{dbh}, $src_func);
4467           7                                 73      my ($crc_type) = $checksum->get_crc_type($src->{dbh}, $src_func);
4468           7                                 28      my $opt_slice;
4469  ***      7     50     33                  141      if ( $src_algo eq 'BIT_XOR' && $crc_type !~ m/int$/ ) {
4470  ***      0                                  0         $opt_slice = $checksum->optimize_xor(
4471                                                           dbh      => $src->{dbh},
4472                                                           function => $src_func
4473                                                        );
4474                                                     }
4475                                                  
4476           7                                183      my $chunk_sql = $checksum->make_checksum_query(
4477                                                        %args,
4478                                                        db        => $src->{db},
4479                                                        tbl       => $src->{tbl},
4480                                                        algorithm => $src_algo,
4481                                                        function  => $src_func,
4482                                                        crc_wid   => $crc_wid,
4483                                                        crc_type  => $crc_type,
4484                                                        opt_slice => $opt_slice,
4485                                                        replicate => undef, # replicate means something different to this sub
4486                                                     );                     # than what we use it for; do not pass it!
4487           7                                 43      MKDEBUG && _d('Chunk sql:', $chunk_sql);
4488           7                                105      my $row_sql = $checksum->make_row_checksum(
4489                                                        %args,
4490                                                        function => $src_func,
4491                                                     );
4492           7                                 46      MKDEBUG && _d('Row sql:', $row_sql);
4493           7                                102      return $chunk_sql, $row_sql;
4494                                                  }
4495                                                  
4496                                                  sub lock_table {
4497  ***      0                    0             0      my ( $self, $dbh, $where, $db_tbl, $mode ) = @_;
4498  ***      0                                  0      my $query = "LOCK TABLES $db_tbl $mode";
4499  ***      0                                  0      MKDEBUG && _d($query);
4500  ***      0                                  0      $dbh->do($query);
4501  ***      0                                  0      MKDEBUG && _d('Acquired table lock on', $where, 'in', $mode, 'mode');
4502                                                  }
4503                                                  
4504                                                  sub unlock {
4505           6                    6           212      my ( $self, %args ) = @_;
4506                                                  
4507           6                                 90      foreach my $arg ( qw(src dst lock transaction lock_level) ) {
4508  ***     30     50                         198         die "I need a $arg argument" unless defined $args{$arg};
4509                                                     }
4510           6                                 31      my $src = $args{src};
4511           6                                 31      my $dst = $args{dst};
4512                                                  
4513  ***      6     50     33                   92      return unless $args{lock} && $args{lock} <= $args{lock_level};
4514                                                  
4515  ***      0                                  0      foreach my $dbh ( $src->{dbh}, $dst->{dbh} ) {
4516  ***      0      0                           0         if ( $args{transaction} ) {
4517  ***      0                                  0            MKDEBUG && _d('Committing', $dbh);
4518  ***      0                                  0            $dbh->commit();
4519                                                        }
4520                                                        else {
4521  ***      0                                  0            my $sql = 'UNLOCK TABLES';
4522  ***      0                                  0            MKDEBUG && _d($dbh, $sql);
4523  ***      0                                  0            $dbh->do($sql);
4524                                                        }
4525                                                     }
4526                                                  
4527  ***      0                                  0      return;
4528                                                  }
4529                                                  
4530                                                  sub lock_and_wait {
4531          38                   38          1322      my ( $self, %args ) = @_;
4532          38                                387      my $result = 0;
4533                                                  
4534          38                                221      foreach my $arg ( qw(src dst lock lock_level) ) {
4535  ***    152     50                         974         die "I need a $arg argument" unless defined $args{$arg};
4536                                                     }
4537          38                                172      my $src = $args{src};
4538          38                                157      my $dst = $args{dst};
4539                                                  
4540  ***     38     50     33                  600      return unless $args{lock} && $args{lock} == $args{lock_level};
4541                                                  
4542  ***      0                                  0      foreach my $dbh ( $src->{dbh}, $dst->{dbh} ) {
4543  ***      0      0                           0         if ( $args{transaction} ) {
4544  ***      0                                  0            MKDEBUG && _d('Committing', $dbh);
4545  ***      0                                  0            $dbh->commit();
4546                                                        }
4547                                                        else {
4548  ***      0                                  0            my $sql = 'UNLOCK TABLES';
4549  ***      0                                  0            MKDEBUG && _d($dbh, $sql);
4550  ***      0                                  0            $dbh->do($sql);
4551                                                        }
4552                                                     }
4553                                                  
4554  ***      0      0                           0      if ( $args{lock} == 3 ) {
4555  ***      0                                  0         my $sql = 'FLUSH TABLES WITH READ LOCK';
4556  ***      0                                  0         MKDEBUG && _d($src->{dbh}, ',', $sql);
4557  ***      0                                  0         $src->{dbh}->do($sql);
4558                                                     }
4559                                                     else {
4560  ***      0      0                           0         if ( $args{transaction} ) {
4561  ***      0      0                           0            if ( $args{src_sth} ) {
4562  ***      0                                  0               MKDEBUG && _d('Executing statement on source to lock rows');
4563  ***      0                                  0               $args{src_sth}->execute();
4564  ***      0                                  0               $result = 1;
4565                                                           }
4566                                                        }
4567                                                        else {
4568  ***      0      0                           0            $self->lock_table($src->{dbh}, 'source',
4569                                                              $self->{Quoter}->quote($src->{db}, $src->{tbl}),
4570                                                              $args{changing_src} ? 'WRITE' : 'READ');
4571                                                        }
4572                                                     }
4573                                                  
4574  ***      0                                  0      eval {
4575  ***      0      0                           0         if ( $args{wait} ) {
4576  ***      0                                  0            $self->{MasterSlave}->wait_for_master(
4577                                                              $src->{misc_dbh}, $dst->{dbh}, $args{wait}, $args{timeout_ok});
4578                                                        }
4579                                                  
4580  ***      0      0                           0         if ( $args{changing_src} ) {
4581  ***      0                                  0            MKDEBUG && _d('Not locking destination because changing source ',
4582                                                              '(syncing via replication or sync-to-master)');
4583                                                        }
4584                                                        else {
4585  ***      0      0                           0            if ( $args{lock} == 3 ) {
      ***             0                               
4586  ***      0                                  0               my $sql = 'FLUSH TABLES WITH READ LOCK';
4587  ***      0                                  0               MKDEBUG && _d($dst->{dbh}, ',', $sql);
4588  ***      0                                  0               $dst->{dbh}->do($sql);
4589                                                           }
4590                                                           elsif ( !$args{transaction} ) {
4591  ***      0      0                           0               $self->lock_table($dst->{dbh}, 'dest',
4592                                                                 $self->{Quoter}->quote($dst->{db}, $dst->{tbl}),
4593                                                                 $args{execute} ? 'WRITE' : 'READ');
4594                                                           }
4595                                                        }
4596                                                     };
4597                                                  
4598  ***      0      0                           0      if ( $EVAL_ERROR ) {
4599  ***      0      0                           0         if ( $args{src_sth}->{Active} ) {
4600  ***      0                                  0            $args{src_sth}->finish();
4601                                                        }
4602  ***      0                                  0         foreach my $dbh ( $src->{dbh}, $dst->{dbh}, $src->{misc_dbh} ) {
4603  ***      0      0                           0            next unless $dbh;
4604  ***      0                                  0            MKDEBUG && _d('Caught error, unlocking/committing on', $dbh);
4605  ***      0                                  0            $dbh->do('UNLOCK TABLES');
4606  ***      0      0                           0            $dbh->commit() unless $dbh->{AutoCommit};
4607                                                        }
4608  ***      0                                  0         die $EVAL_ERROR;
4609                                                     }
4610                                                  
4611  ***      0                                  0      return $result;
4612                                                  }
4613                                                  
4614                                                  sub have_all_privs {
4615          14                   14           116      my ( $self, $dbh, $db, $tbl ) = @_;
4616          14                                124      my $db_tbl = $self->{Quoter}->quote($db, $tbl);
4617          14                                 83      my $sql    = "SHOW FULL COLUMNS FROM $db_tbl";
4618          14                                 40      MKDEBUG && _d('Permissions check:', $sql);
4619          14                                181      my $cols       = $dbh->selectall_arrayref($sql, {Slice => {}});
4620          14                                152      my ($hdr_name) = grep { m/privileges/i } keys %{$cols->[0]};
             126                                634   
              14                                154   
4621          14                                120      my $privs      = $cols->[0]->{$hdr_name};
4622          14                                 84      $sql = "DELETE FROM $db_tbl LIMIT 0"; # FULL COLUMNS doesn't show all privs
4623          14                                 49      MKDEBUG && _d('Permissions check:', $sql);
4624          14                                 50      eval { $dbh->do($sql); };
              14                               2300   
4625  ***     14     50                         102      my $can_delete = $EVAL_ERROR ? 0 : 1;
4626                                                  
4627          14                                 42      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
4628                                                        ($can_delete ? 'delete' : ''));
4629  ***     14     50     33                  483      if ( $privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/ 
      ***                   33                        
      ***                   33                        
4630                                                          && $can_delete ) {
4631          14                                 48         MKDEBUG && _d('User has all privs');
4632          14                                291         return 1;
4633                                                     }
4634  ***      0                                  0      MKDEBUG && _d('User does not have all privs');
4635  ***      0                                  0      return 0;
4636                                                  }
4637                                                  
4638                                                  sub _d {
4639  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4640  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4641  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4642                                                          @_;
4643  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4644                                                  }
4645                                                  
4646                                                  1;
4647                                                  
4648                                                  # ###########################################################################
4649                                                  # End TableSyncer package
4650                                                  # ###########################################################################
4651                                                  
4652                                                  # ###########################################################################
4653                                                  # TableNibbler package 5266
4654                                                  # ###########################################################################
4655                                                  package TableNibbler;
4656                                                  
4657          29                   29           256   use strict;
              29                                 93   
              29                                280   
4658          29                   29           179   use warnings FATAL => 'all';
              29                                 81   
              29                                299   
4659                                                  
4660          29                   29           180   use English qw(-no_match_vars);
              29                                 66   
              29                                209   
4661                                                  
4662  ***     29            50     29           216   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 89   
              29                                576   
4663                                                  
4664                                                  sub new {
4665           5                    5            58      my ( $class, %args ) = @_;
4666           5                                 35      my @required_args = qw(TableParser Quoter);
4667           5                                 34      foreach my $arg ( @required_args ) {
4668  ***     10     50                          69         die "I need a $arg argument" unless $args{$arg};
4669                                                     }
4670           5                                 36      my $self = { %args };
4671           5                                 63      return bless $self, $class;
4672                                                  }
4673                                                  
4674                                                  sub generate_asc_stmt {
4675  ***      0                    0             0      my ( $self, %args ) = @_;
4676  ***      0                                  0      my @required_args = qw(tbl_struct index);
4677  ***      0                                  0      foreach my $arg ( @required_args ) {
4678  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
4679                                                     }
4680  ***      0                                  0      my ($tbl_struct, $index) = @args{@required_args};
4681  ***      0      0                           0      my @cols = $args{cols}  ? @{$args{cols}} : @{$tbl_struct->{cols}};
      ***      0                                  0   
      ***      0                                  0   
4682  ***      0                                  0      my $q    = $self->{Quoter};
4683                                                  
4684  ***      0      0                           0      die "Index '$index' does not exist in table"
4685                                                        unless exists $tbl_struct->{keys}->{$index};
4686                                                  
4687  ***      0                                  0      my @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
      ***      0                                  0   
4688  ***      0                                  0      my @asc_slice;
4689                                                  
4690  ***      0                                  0      @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
      ***      0                                  0   
4691  ***      0                                  0      MKDEBUG && _d('Will ascend index', $index);
4692  ***      0                                  0      MKDEBUG && _d('Will ascend columns', join(', ', @asc_cols));
4693  ***      0      0                           0      if ( $args{asc_first} ) {
4694  ***      0                                  0         @asc_cols = $asc_cols[0];
4695  ***      0                                  0         MKDEBUG && _d('Ascending only first column');
4696                                                     }
4697                                                  
4698  ***      0                                  0      my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
4699  ***      0                                  0      foreach my $col ( @asc_cols ) {
4700  ***      0      0                           0         if ( !exists $col_posn{$col} ) {
4701  ***      0                                  0            push @cols, $col;
4702  ***      0                                  0            $col_posn{$col} = $#cols;
4703                                                        }
4704  ***      0                                  0         push @asc_slice, $col_posn{$col};
4705                                                     }
4706  ***      0                                  0      MKDEBUG && _d('Will ascend, in ordinal position:', join(', ', @asc_slice));
4707                                                  
4708  ***      0                                  0      my $asc_stmt = {
4709                                                        cols  => \@cols,
4710                                                        index => $index,
4711                                                        where => '',
4712                                                        slice => [],
4713                                                        scols => [],
4714                                                     };
4715                                                  
4716  ***      0      0                           0      if ( @asc_slice ) {
4717  ***      0                                  0         my $cmp_where;
4718  ***      0                                  0         foreach my $cmp ( qw(< <= >= >) ) {
4719  ***      0                                  0            $cmp_where = $self->generate_cmp_where(
4720                                                              type        => $cmp,
4721                                                              slice       => \@asc_slice,
4722                                                              cols        => \@cols,
4723                                                              quoter      => $q,
4724                                                              is_nullable => $tbl_struct->{is_nullable},
4725                                                           );
4726  ***      0                                  0            $asc_stmt->{boundaries}->{$cmp} = $cmp_where->{where};
4727                                                        }
4728  ***      0      0                           0         my $cmp = $args{asc_only} ? '>' : '>=';
4729  ***      0                                  0         $asc_stmt->{where} = $asc_stmt->{boundaries}->{$cmp};
4730  ***      0                                  0         $asc_stmt->{slice} = $cmp_where->{slice};
4731  ***      0                                  0         $asc_stmt->{scols} = $cmp_where->{scols};
4732                                                     }
4733                                                  
4734  ***      0                                  0      return $asc_stmt;
4735                                                  }
4736                                                  
4737                                                  sub generate_cmp_where {
4738  ***      0                    0             0      my ( $self, %args ) = @_;
4739  ***      0                                  0      foreach my $arg ( qw(type slice cols is_nullable) ) {
4740  ***      0      0                           0         die "I need a $arg arg" unless defined $args{$arg};
4741                                                     }
4742  ***      0                                  0      my @slice       = @{$args{slice}};
      ***      0                                  0   
4743  ***      0                                  0      my @cols        = @{$args{cols}};
      ***      0                                  0   
4744  ***      0                                  0      my $is_nullable = $args{is_nullable};
4745  ***      0                                  0      my $type        = $args{type};
4746  ***      0                                  0      my $q           = $self->{Quoter};
4747                                                  
4748  ***      0                                  0      (my $cmp = $type) =~ s/=//;
4749                                                  
4750  ***      0                                  0      my @r_slice;    # Resulting slice columns, by ordinal
4751  ***      0                                  0      my @r_scols;    # Ditto, by name
4752                                                  
4753  ***      0                                  0      my @clauses;
4754  ***      0                                  0      foreach my $i ( 0 .. $#slice ) {
4755  ***      0                                  0         my @clause;
4756                                                  
4757  ***      0                                  0         foreach my $j ( 0 .. $i - 1 ) {
4758  ***      0                                  0            my $ord = $slice[$j];
4759  ***      0                                  0            my $col = $cols[$ord];
4760  ***      0                                  0            my $quo = $q->quote($col);
4761  ***      0      0                           0            if ( $is_nullable->{$col} ) {
4762  ***      0                                  0               push @clause, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
4763  ***      0                                  0               push @r_slice, $ord, $ord;
4764  ***      0                                  0               push @r_scols, $col, $col;
4765                                                           }
4766                                                           else {
4767  ***      0                                  0               push @clause, "$quo = ?";
4768  ***      0                                  0               push @r_slice, $ord;
4769  ***      0                                  0               push @r_scols, $col;
4770                                                           }
4771                                                        }
4772                                                  
4773  ***      0                                  0         my $ord = $slice[$i];
4774  ***      0                                  0         my $col = $cols[$ord];
4775  ***      0                                  0         my $quo = $q->quote($col);
4776  ***      0                                  0         my $end = $i == $#slice; # Last clause of the whole group.
4777  ***      0      0                           0         if ( $is_nullable->{$col} ) {
4778  ***      0      0      0                    0            if ( $type =~ m/=/ && $end ) {
      ***             0                               
4779  ***      0                                  0               push @clause, "(? IS NULL OR $quo $type ?)";
4780                                                           }
4781                                                           elsif ( $type =~ m/>/ ) {
4782  ***      0                                  0               push @clause, "((? IS NULL AND $quo IS NOT NULL) OR ($quo $cmp ?))";
4783                                                           }
4784                                                           else { # If $type =~ m/</ ) {
4785  ***      0                                  0               push @clause, "((? IS NOT NULL AND $quo IS NULL) OR ($quo $cmp ?))";
4786                                                           }
4787  ***      0                                  0            push @r_slice, $ord, $ord;
4788  ***      0                                  0            push @r_scols, $col, $col;
4789                                                        }
4790                                                        else {
4791  ***      0                                  0            push @r_slice, $ord;
4792  ***      0                                  0            push @r_scols, $col;
4793  ***      0      0      0                    0            push @clause, ($type =~ m/=/ && $end ? "$quo $type ?" : "$quo $cmp ?");
4794                                                        }
4795                                                  
4796  ***      0                                  0         push @clauses, '(' . join(' AND ', @clause) . ')';
4797                                                     }
4798  ***      0                                  0      my $result = '(' . join(' OR ', @clauses) . ')';
4799  ***      0                                  0      my $where = {
4800                                                        slice => \@r_slice,
4801                                                        scols => \@r_scols,
4802                                                        where => $result,
4803                                                     };
4804  ***      0                                  0      return $where;
4805                                                  }
4806                                                  
4807                                                  sub generate_del_stmt {
4808  ***      0                    0             0      my ( $self, %args ) = @_;
4809                                                  
4810  ***      0                                  0      my $tbl  = $args{tbl_struct};
4811  ***      0      0                           0      my @cols = $args{cols} ? @{$args{cols}} : ();
      ***      0                                  0   
4812  ***      0                                  0      my $tp   = $self->{TableParser};
4813  ***      0                                  0      my $q    = $self->{Quoter};
4814                                                  
4815  ***      0                                  0      my @del_cols;
4816  ***      0                                  0      my @del_slice;
4817                                                  
4818  ***      0                                  0      my $index = $tp->find_best_index($tbl, $args{index});
4819  ***      0      0                           0      die "Cannot find an ascendable index in table" unless $index;
4820                                                  
4821  ***      0      0                           0      if ( $index ) {
4822  ***      0                                  0         @del_cols = @{$tbl->{keys}->{$index}->{cols}};
      ***      0                                  0   
4823                                                     }
4824                                                     else {
4825  ***      0                                  0         @del_cols = @{$tbl->{cols}};
      ***      0                                  0   
4826                                                     }
4827  ***      0                                  0      MKDEBUG && _d('Columns needed for DELETE:', join(', ', @del_cols));
4828                                                  
4829  ***      0                                  0      my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
4830  ***      0                                  0      foreach my $col ( @del_cols ) {
4831  ***      0      0                           0         if ( !exists $col_posn{$col} ) {
4832  ***      0                                  0            push @cols, $col;
4833  ***      0                                  0            $col_posn{$col} = $#cols;
4834                                                        }
4835  ***      0                                  0         push @del_slice, $col_posn{$col};
4836                                                     }
4837  ***      0                                  0      MKDEBUG && _d('Ordinals needed for DELETE:', join(', ', @del_slice));
4838                                                  
4839  ***      0                                  0      my $del_stmt = {
4840                                                        cols  => \@cols,
4841                                                        index => $index,
4842                                                        where => '',
4843                                                        slice => [],
4844                                                        scols => [],
4845                                                     };
4846                                                  
4847  ***      0                                  0      my @clauses;
4848  ***      0                                  0      foreach my $i ( 0 .. $#del_slice ) {
4849  ***      0                                  0         my $ord = $del_slice[$i];
4850  ***      0                                  0         my $col = $cols[$ord];
4851  ***      0                                  0         my $quo = $q->quote($col);
4852  ***      0      0                           0         if ( $tbl->{is_nullable}->{$col} ) {
4853  ***      0                                  0            push @clauses, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
4854  ***      0                                  0            push @{$del_stmt->{slice}}, $ord, $ord;
      ***      0                                  0   
4855  ***      0                                  0            push @{$del_stmt->{scols}}, $col, $col;
      ***      0                                  0   
4856                                                        }
4857                                                        else {
4858  ***      0                                  0            push @clauses, "$quo = ?";
4859  ***      0                                  0            push @{$del_stmt->{slice}}, $ord;
      ***      0                                  0   
4860  ***      0                                  0            push @{$del_stmt->{scols}}, $col;
      ***      0                                  0   
4861                                                        }
4862                                                     }
4863                                                  
4864  ***      0                                  0      $del_stmt->{where} = '(' . join(' AND ', @clauses) . ')';
4865                                                  
4866  ***      0                                  0      return $del_stmt;
4867                                                  }
4868                                                  
4869                                                  sub generate_ins_stmt {
4870  ***      0                    0             0      my ( $self, %args ) = @_;
4871  ***      0                                  0      foreach my $arg ( qw(ins_tbl sel_cols) ) {
4872  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
4873                                                     }
4874  ***      0                                  0      my $ins_tbl  = $args{ins_tbl};
4875  ***      0                                  0      my @sel_cols = @{$args{sel_cols}};
      ***      0                                  0   
4876                                                  
4877  ***      0      0                           0      die "You didn't specify any SELECT columns" unless @sel_cols;
4878                                                  
4879  ***      0                                  0      my @ins_cols;
4880  ***      0                                  0      my @ins_slice;
4881  ***      0                                  0      for my $i ( 0..$#sel_cols ) {
4882  ***      0      0                           0         next unless $ins_tbl->{is_col}->{$sel_cols[$i]};
4883  ***      0                                  0         push @ins_cols, $sel_cols[$i];
4884  ***      0                                  0         push @ins_slice, $i;
4885                                                     }
4886                                                  
4887                                                     return {
4888  ***      0                                  0         cols  => \@ins_cols,
4889                                                        slice => \@ins_slice,
4890                                                     };
4891                                                  }
4892                                                  
4893                                                  sub _d {
4894  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4895  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4896  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4897                                                          @_;
4898  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4899                                                  }
4900                                                  
4901                                                  1;
4902                                                  
4903                                                  # ###########################################################################
4904                                                  # End TableNibbler package
4905                                                  # ###########################################################################
4906                                                  
4907                                                  # ###########################################################################
4908                                                  # MasterSlave package 5362
4909                                                  # ###########################################################################
4910          29                   29           236   use strict;
              29                                 85   
              29                                171   
4911          29                   29           187   use warnings FATAL => 'all';
              29                                 78   
              29                                176   
4912                                                  
4913                                                  package MasterSlave;
4914                                                  
4915          29                   29           173   use English qw(-no_match_vars);
              29                                 84   
              29                                162   
4916          29                   29           216   use List::Util qw(min max);
              29                                 75   
              29                                175   
4917          29                   29           197   use Data::Dumper;
              29                                 73   
              29                                159   
4918                                                  $Data::Dumper::Quotekeys = 0;
4919                                                  $Data::Dumper::Indent    = 0;
4920                                                  
4921  ***     29            50     29           190   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 73   
              29                                419   
4922                                                  
4923                                                  sub new {
4924           5                    5            65      bless {}, shift;
4925                                                  }
4926                                                  
4927                                                  sub recurse_to_slaves {
4928  ***      0                    0             0      my ( $self, $args, $level ) = @_;
4929  ***      0             0                    0      $level ||= 0;
4930  ***      0                                  0      my $dp   = $args->{dsn_parser};
4931  ***      0                                  0      my $dsn  = $args->{dsn};
4932                                                  
4933  ***      0                                  0      my $dbh;
4934  ***      0                                  0      eval {
4935  ***      0             0                    0         $dbh = $args->{dbh} || $dp->get_dbh(
4936                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
4937  ***      0                                  0         MKDEBUG && _d('Connected to', $dp->as_string($dsn));
4938                                                     };
4939  ***      0      0                           0      if ( $EVAL_ERROR ) {
4940  ***      0      0                           0         print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
4941                                                           or die "Cannot print: $OS_ERROR";
4942  ***      0                                  0         return;
4943                                                     }
4944                                                  
4945  ***      0                                  0      my $sql  = 'SELECT @@SERVER_ID';
4946  ***      0                                  0      MKDEBUG && _d($sql);
4947  ***      0                                  0      my ($id) = $dbh->selectrow_array($sql);
4948  ***      0                                  0      MKDEBUG && _d('Working on server ID', $id);
4949  ***      0                                  0      my $master_thinks_i_am = $dsn->{server_id};
4950  ***      0      0      0                    0      if ( !defined $id
      ***                    0                        
      ***                    0                        
4951                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
4952                                                         || $args->{server_ids_seen}->{$id}++
4953                                                     ) {
4954  ***      0                                  0         MKDEBUG && _d('Server ID seen, or not what master said');
4955  ***      0      0                           0         if ( $args->{skip_callback} ) {
4956  ***      0                                  0            $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
4957                                                        }
4958  ***      0                                  0         return;
4959                                                     }
4960                                                  
4961  ***      0                                  0      $args->{callback}->($dsn, $dbh, $level, $args->{parent});
4962                                                  
4963  ***      0      0      0                    0      if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
4964                                                  
4965  ***      0      0                           0         my @slaves =
4966  ***      0                                  0            grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
4967                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
4968                                                  
4969  ***      0                                  0         foreach my $slave ( @slaves ) {
4970  ***      0                                  0            MKDEBUG && _d('Recursing from',
4971                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
4972  ***      0                                  0            $self->recurse_to_slaves(
4973                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
4974                                                        }
4975                                                     }
4976                                                  }
4977                                                  
4978                                                  sub find_slave_hosts {
4979  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
4980                                                  
4981  ***      0                                  0      my @methods = qw(processlist hosts);
4982  ***      0      0                           0      if ( $method ) {
4983  ***      0                                  0         @methods = grep { $_ ne $method } @methods;
      ***      0                                  0   
4984  ***      0                                  0         unshift @methods, $method;
4985                                                     }
4986                                                     else {
4987  ***      0      0      0                    0         if ( ($dsn->{P} || 3306) != 3306 ) {
4988  ***      0                                  0            MKDEBUG && _d('Port number is non-standard; using only hosts method');
4989  ***      0                                  0            @methods = qw(hosts);
4990                                                        }
4991                                                     }
4992  ***      0                                  0      MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
4993                                                        'using methods', @methods);
4994                                                  
4995  ***      0                                  0      my @slaves;
4996                                                     METHOD:
4997  ***      0                                  0      foreach my $method ( @methods ) {
4998  ***      0                                  0         my $find_slaves = "_find_slaves_by_$method";
4999  ***      0                                  0         MKDEBUG && _d('Finding slaves with', $find_slaves);
5000  ***      0                                  0         @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
5001  ***      0      0                           0         last METHOD if @slaves;
5002                                                     }
5003                                                  
5004  ***      0                                  0      MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
5005  ***      0                                  0      return @slaves;
5006                                                  }
5007                                                  
5008                                                  sub _find_slaves_by_processlist {
5009  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
5010                                                  
5011  ***      0                                  0      my @slaves = map  {
5012  ***      0                                  0         my $slave        = $dsn_parser->parse("h=$_", $dsn);
5013  ***      0                                  0         $slave->{source} = 'processlist';
5014  ***      0                                  0         $slave;
5015                                                     }
5016  ***      0                                  0      grep { $_ }
5017                                                     map  {
5018  ***      0                                  0         my ( $host ) = $_->{host} =~ m/^([^:]+):/;
5019  ***      0      0                           0         if ( $host eq 'localhost' ) {
5020  ***      0                                  0            $host = '127.0.0.1'; # Replication never uses sockets.
5021                                                        }
5022  ***      0                                  0         $host;
5023                                                     } $self->get_connected_slaves($dbh);
5024                                                  
5025  ***      0                                  0      return @slaves;
5026                                                  }
5027                                                  
5028                                                  sub _find_slaves_by_hosts {
5029  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
5030                                                  
5031  ***      0                                  0      my @slaves;
5032  ***      0                                  0      my $sql = 'SHOW SLAVE HOSTS';
5033  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
5034  ***      0                                  0      @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                  0   
5035                                                  
5036  ***      0      0                           0      if ( @slaves ) {
5037  ***      0                                  0         MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
5038  ***      0                                  0         @slaves = map {
5039  ***      0                                  0            my %hash;
5040  ***      0                                  0            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
5041  ***      0      0                           0            my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
5042                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
5043                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
5044  ***      0                                  0            my $dsn           = $dsn_parser->parse($spec, $dsn);
5045  ***      0                                  0            $dsn->{server_id} = $hash{server_id};
5046  ***      0                                  0            $dsn->{master_id} = $hash{master_id};
5047  ***      0                                  0            $dsn->{source}    = 'hosts';
5048  ***      0                                  0            $dsn;
5049                                                        } @slaves;
5050                                                     }
5051                                                  
5052  ***      0                                  0      return @slaves;
5053                                                  }
5054                                                  
5055                                                  sub get_connected_slaves {
5056  ***      0                    0             0      my ( $self, $dbh ) = @_;
5057                                                  
5058  ***      0                                  0      my $proc =
5059  ***      0                                  0         grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
5060  ***      0                                  0         @{$dbh->selectcol_arrayref('SHOW GRANTS')};
5061  ***      0      0                           0      if ( !$proc ) {
5062  ***      0                                  0         die "You do not have the PROCESS privilege";
5063                                                     }
5064                                                  
5065  ***      0                                  0      my $sql = 'SHOW PROCESSLIST';
5066  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
5067  ***      0                                  0      grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                  0   
5068                                                     map  { # Lowercase the column names
5069  ***      0                                  0         my %hash;
5070  ***      0                                  0         @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
5071  ***      0                                  0         \%hash;
5072                                                     }
5073  ***      0                                  0      @{$dbh->selectall_arrayref($sql, { Slice => {} })};
5074                                                  }
5075                                                  
5076                                                  sub is_master_of {
5077  ***      0                    0             0      my ( $self, $master, $slave ) = @_;
5078  ***      0      0                           0      my $master_status = $self->get_master_status($master)
5079                                                        or die "The server specified as a master is not a master";
5080  ***      0      0                           0      my $slave_status  = $self->get_slave_status($slave)
5081                                                        or die "The server specified as a slave is not a slave";
5082  ***      0      0                           0      my @connected     = $self->get_connected_slaves($master)
5083                                                        or die "The server specified as a master has no connected slaves";
5084  ***      0                                  0      my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
5085                                                  
5086  ***      0      0                           0      if ( $port != $slave_status->{master_port} ) {
5087  ***      0                                  0         die "The slave is connected to $slave_status->{master_port} "
5088                                                           . "but the master's port is $port";
5089                                                     }
5090                                                  
5091  ***      0      0                           0      if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                  0   
5092  ***      0                                  0         die "I don't see any slave I/O thread connected with user "
5093                                                           . $slave_status->{master_user};
5094                                                     }
5095                                                  
5096  ***      0      0      0                    0      if ( ($slave_status->{slave_io_state} || '')
5097                                                        eq 'Waiting for master to send event' )
5098                                                     {
5099  ***      0                                  0         my ( $master_log_name, $master_log_num )
5100                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
5101  ***      0                                  0         my ( $slave_log_name, $slave_log_num )
5102                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
5103  ***      0      0      0                    0         if ( $master_log_name ne $slave_log_name
5104                                                           || abs($master_log_num - $slave_log_num) > 1 )
5105                                                        {
5106  ***      0                                  0            die "The slave thinks it is reading from "
5107                                                              . "$slave_status->{master_log_file},  but the "
5108                                                              . "master is writing to $master_status->{file}";
5109                                                        }
5110                                                     }
5111  ***      0                                  0      return 1;
5112                                                  }
5113                                                  
5114                                                  sub get_master_dsn {
5115  ***      0                    0             0      my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
5116  ***      0      0                           0      my $master = $self->get_slave_status($dbh) or return undef;
5117  ***      0                                  0      my $spec   = "h=$master->{master_host},P=$master->{master_port}";
5118  ***      0                                  0      return       $dsn_parser->parse($spec, $dsn);
5119                                                  }
5120                                                  
5121                                                  sub get_slave_status {
5122           7                    7            42      my ( $self, $dbh ) = @_;
5123  ***      7     50                         101      if ( !$self->{not_a_slave}->{$dbh} ) {
5124  ***      7            33                   30         my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
5125                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
5126           7                                 89         MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
5127           7                               1599         $sth->execute();
5128           7                                 40         my ($ss) = @{$sth->fetchall_arrayref({})};
               7                                 60   
5129                                                  
5130  ***      7     50     33                  104         if ( $ss && %$ss ) {
5131  ***      0                                  0            $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
      ***      0                                  0   
5132  ***      0                                  0            return $ss;
5133                                                        }
5134                                                  
5135           7                                 21         MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
5136           7                                109         $self->{not_a_slave}->{$dbh}++;
5137                                                     }
5138                                                  }
5139                                                  
5140                                                  sub get_master_status {
5141  ***      0                    0             0      my ( $self, $dbh ) = @_;
5142  ***      0      0                           0      if ( !$self->{not_a_master}->{$dbh} ) {
5143  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
5144                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
5145  ***      0                                  0         MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
5146  ***      0                                  0         $sth->execute();
5147  ***      0                                  0         my ($ms) = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
5148                                                  
5149  ***      0      0      0                    0         if ( $ms && %$ms ) {
5150  ***      0                                  0            $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
      ***      0                                  0   
5151  ***      0      0      0                    0            if ( $ms->{file} && $ms->{position} ) {
5152  ***      0                                  0               return $ms;
5153                                                           }
5154                                                        }
5155                                                  
5156  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
5157  ***      0                                  0         $self->{not_a_master}->{$dbh}++;
5158                                                     }
5159                                                  }
5160                                                  
5161                                                  sub wait_for_master {
5162  ***      0                    0             0      my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
5163  ***      0                                  0      my $result;
5164  ***      0      0                           0      $time = 60 unless defined $time;
5165  ***      0                                  0      MKDEBUG && _d('Waiting for slave to catch up to master timeout ok:',
5166                                                        $timeoutok);
5167  ***      0             0                    0      $ms ||= $self->get_master_status($master);
5168  ***      0      0                           0      if ( $ms ) {
5169  ***      0                                  0         my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
5170  ***      0                                  0         MKDEBUG && _d($slave, $query);
5171  ***      0                                  0         ($result) = $slave->selectrow_array($query);
5172  ***      0      0                           0         my $stat = defined $result ? $result : 'NULL';
5173  ***      0                                  0         MKDEBUG && _d('Result of waiting:', $stat);
5174  ***      0      0      0                    0         if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                    0                        
5175  ***      0                                  0            die "MASTER_POS_WAIT returned $stat";
5176                                                        }
5177                                                     }
5178                                                     else {
5179  ***      0                                  0         MKDEBUG && _d('Not waiting: this server is not a master');
5180                                                     }
5181  ***      0                                  0      return $result;
5182                                                  }
5183                                                  
5184                                                  sub stop_slave {
5185  ***      0                    0             0      my ( $self, $dbh ) = @_;
5186  ***      0             0                    0      my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
5187                                                           ||= $dbh->prepare('STOP SLAVE');
5188  ***      0                                  0      MKDEBUG && _d($dbh, $sth->{Statement});
5189  ***      0                                  0      $sth->execute();
5190                                                  }
5191                                                  
5192                                                  sub start_slave {
5193  ***      0                    0             0      my ( $self, $dbh, $pos ) = @_;
5194  ***      0      0                           0      if ( $pos ) {
5195  ***      0                                  0         my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
5196                                                                . "MASTER_LOG_POS=$pos->{position}";
5197  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
5198  ***      0                                  0         $dbh->do($sql);
5199                                                     }
5200                                                     else {
5201  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
5202                                                              ||= $dbh->prepare('START SLAVE');
5203  ***      0                                  0         MKDEBUG && _d($dbh, $sth->{Statement});
5204  ***      0                                  0         $sth->execute();
5205                                                     }
5206                                                  }
5207                                                  
5208                                                  sub catchup_to_master {
5209  ***      0                    0             0      my ( $self, $slave, $master, $time ) = @_;
5210  ***      0                                  0      $self->stop_slave($master);
5211  ***      0                                  0      $self->stop_slave($slave);
5212  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave);
5213  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
5214  ***      0                                  0      my $master_status = $self->get_master_status($master);
5215  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
5216  ***      0                                  0      MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
5217                                                        'Slave position:', $self->pos_to_string($slave_pos));
5218  ***      0      0                           0      if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
5219  ***      0                                  0         MKDEBUG && _d('Waiting for slave to catch up to master');
5220  ***      0                                  0         $self->start_slave($slave, $master_pos);
5221  ***      0                                  0         eval {
5222  ***      0                                  0            $self->wait_for_master($master, $slave, $time, 0, $master_status);
5223                                                        };
5224  ***      0      0                           0         if ( $EVAL_ERROR ) {
5225  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
5226  ***      0      0                           0            if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
5227  ***      0                                  0               $slave_status = $self->get_slave_status($slave);
5228  ***      0      0                           0               if ( !$self->slave_is_running($slave_status) ) {
5229  ***      0                                  0                  MKDEBUG && _d('Master position:',
5230                                                                    $self->pos_to_string($master_pos),
5231                                                                    'Slave position:', $self->pos_to_string($slave_pos));
5232  ***      0                                  0                  $slave_pos = $self->repl_posn($slave_status);
5233  ***      0      0                           0                  if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
5234  ***      0                                  0                     die "$EVAL_ERROR but slave has not caught up to master";
5235                                                                 }
5236  ***      0                                  0                  MKDEBUG && _d('Slave is caught up to master and stopped');
5237                                                              }
5238                                                              else {
5239  ***      0                                  0                  die "$EVAL_ERROR but slave was still running";
5240                                                              }
5241                                                           }
5242                                                           else {
5243  ***      0                                  0               die $EVAL_ERROR;
5244                                                           }
5245                                                        }
5246                                                     }
5247                                                  }
5248                                                  
5249                                                  sub catchup_to_same_pos {
5250  ***      0                    0             0      my ( $self, $s1_dbh, $s2_dbh ) = @_;
5251  ***      0                                  0      $self->stop_slave($s1_dbh);
5252  ***      0                                  0      $self->stop_slave($s2_dbh);
5253  ***      0                                  0      my $s1_status = $self->get_slave_status($s1_dbh);
5254  ***      0                                  0      my $s2_status = $self->get_slave_status($s2_dbh);
5255  ***      0                                  0      my $s1_pos    = $self->repl_posn($s1_status);
5256  ***      0                                  0      my $s2_pos    = $self->repl_posn($s2_status);
5257  ***      0      0                           0      if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
5258  ***      0                                  0         $self->start_slave($s1_dbh, $s2_pos);
5259                                                     }
5260                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
5261  ***      0                                  0         $self->start_slave($s2_dbh, $s1_pos);
5262                                                     }
5263                                                  
5264  ***      0                                  0      $s1_status = $self->get_slave_status($s1_dbh);
5265  ***      0                                  0      $s2_status = $self->get_slave_status($s2_dbh);
5266  ***      0                                  0      $s1_pos    = $self->repl_posn($s1_status);
5267  ***      0                                  0      $s2_pos    = $self->repl_posn($s2_status);
5268                                                  
5269  ***      0      0      0                    0      if ( $self->slave_is_running($s1_status)
      ***                    0                        
5270                                                       || $self->slave_is_running($s2_status)
5271                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
5272                                                     {
5273  ***      0                                  0         die "The servers aren't both stopped at the same position";
5274                                                     }
5275                                                  
5276                                                  }
5277                                                  
5278                                                  sub change_master_to {
5279  ***      0                    0             0      my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
5280  ***      0                                  0      $self->stop_slave($dbh);
5281  ***      0                                  0      MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
5282  ***      0                                  0      my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
5283                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
5284                                                        . "MASTER_LOG_POS=$master_pos->{position}";
5285  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
5286  ***      0                                  0      $dbh->do($sql);
5287                                                  }
5288                                                  
5289                                                  sub make_sibling_of_master {
5290  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
5291                                                  
5292  ***      0      0                           0      my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5293                                                        or die "This server is not a slave";
5294  ***      0                                  0      my $master_dbh  = $dsn_parser->get_dbh(
5295                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
5296  ***      0      0                           0      my $gmaster_dsn
5297                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5298                                                        or die "This server's master is not a slave";
5299  ***      0                                  0      my $gmaster_dbh = $dsn_parser->get_dbh(
5300                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
5301  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
5302  ***      0                                  0         die "The slave's master's master is the slave: master-master replication";
5303                                                     }
5304                                                  
5305  ***      0                                  0      $self->stop_slave($master_dbh);
5306  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
5307  ***      0                                  0      $self->stop_slave($slave_dbh);
5308                                                  
5309  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
5310  ***      0                                  0      my $mslave_status = $self->get_slave_status($master_dbh);
5311  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
5312  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
5313  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
5314                                                  
5315  ***      0      0      0                    0      if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
5316                                                       && !$self->slave_is_running($slave_status)
5317                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
5318                                                     {
5319  ***      0                                  0         $self->change_master_to($slave_dbh, $gmaster_dsn,
5320                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
5321                                                     }
5322                                                     else {
5323  ***      0                                  0         die "The servers aren't both stopped at the same position";
5324                                                     }
5325                                                  
5326  ***      0                                  0      $mslave_status = $self->get_slave_status($master_dbh);
5327  ***      0                                  0      $slave_status  = $self->get_slave_status($slave_dbh);
5328  ***      0                                  0      my $mslave_pos = $self->repl_posn($mslave_status);
5329  ***      0                                  0      $slave_pos     = $self->repl_posn($slave_status);
5330  ***      0      0      0                    0      if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
5331                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
5332                                                     {
5333  ***      0                                  0         die "The servers don't have the same master/position after the change";
5334                                                     }
5335                                                  }
5336                                                  
5337                                                  sub make_slave_of_sibling {
5338  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
5339                                                          $dsn_parser, $timeout) = @_;
5340                                                  
5341  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
5342  ***      0                                  0         die "You are trying to make the slave a slave of itself";
5343                                                     }
5344                                                  
5345  ***      0      0                           0      my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5346                                                        or die "This server is not a slave";
5347  ***      0                                  0      my $master_dbh1 = $dsn_parser->get_dbh(
5348                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
5349  ***      0      0                           0      my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5350                                                        or die "The sibling is not a slave";
5351  ***      0      0                           0      if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
5352  ***      0                                  0         die "This server isn't a sibling of the slave";
5353                                                     }
5354  ***      0      0                           0      my $sib_master_stat = $self->get_master_status($sib_dbh)
5355                                                        or die "Binary logging is not enabled on the sibling";
5356  ***      0      0                           0      die "The log_slave_updates option is not enabled on the sibling"
5357                                                        unless $self->has_slave_updates($sib_dbh);
5358                                                  
5359  ***      0                                  0      $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
5360                                                  
5361  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
5362  ***      0                                  0      $self->change_master_to($slave_dbh, $sib_dsn,
5363                                                           $self->repl_posn($sib_master_stat));
5364                                                  
5365  ***      0                                  0      my $slave_status = $self->get_slave_status($slave_dbh);
5366  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
5367  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
5368  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
5369                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
5370                                                     {
5371  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the sibling, "
5372                                                           . "or it has a different replication position than the sibling";
5373                                                     }
5374                                                  }
5375                                                  
5376                                                  sub make_slave_of_uncle {
5377  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
5378                                                          $dsn_parser, $timeout) = @_;
5379                                                  
5380  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
5381  ***      0                                  0         die "You are trying to make the slave a slave of itself";
5382                                                     }
5383                                                  
5384  ***      0      0                           0      my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5385                                                        or die "This server is not a slave";
5386  ***      0                                  0      my $master_dbh = $dsn_parser->get_dbh(
5387                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
5388  ***      0      0                           0      my $gmaster_dsn
5389                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5390                                                        or die "The master is not a slave";
5391  ***      0      0                           0      my $unc_master_dsn
5392                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
5393                                                        or die "The uncle is not a slave";
5394  ***      0      0                           0      if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
5395  ***      0                                  0         die "The uncle isn't really the slave's uncle";
5396                                                     }
5397                                                  
5398  ***      0      0                           0      my $unc_master_stat = $self->get_master_status($unc_dbh)
5399                                                        or die "Binary logging is not enabled on the uncle";
5400  ***      0      0                           0      die "The log_slave_updates option is not enabled on the uncle"
5401                                                        unless $self->has_slave_updates($unc_dbh);
5402                                                  
5403  ***      0                                  0      $self->catchup_to_same_pos($master_dbh, $unc_dbh);
5404  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
5405                                                  
5406  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
5407  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
5408  ***      0      0                           0      if ( $self->pos_cmp(
5409                                                           $self->repl_posn($slave_status),
5410                                                           $self->repl_posn($master_status)) != 0 )
5411                                                     {
5412  ***      0                                  0         die "The slave is not caught up to its master";
5413                                                     }
5414                                                  
5415  ***      0                                  0      $unc_master_stat = $self->get_master_status($unc_dbh);
5416  ***      0                                  0      $self->change_master_to($slave_dbh, $unc_dsn,
5417                                                        $self->repl_posn($unc_master_stat));
5418                                                  
5419                                                  
5420  ***      0                                  0      $slave_status    = $self->get_slave_status($slave_dbh);
5421  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
5422  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
5423                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
5424                                                     {
5425  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the uncle, "
5426                                                           . "or it has a different replication position than the uncle";
5427                                                     }
5428                                                  }
5429                                                  
5430                                                  sub detach_slave {
5431  ***      0                    0             0      my ( $self, $dbh ) = @_;
5432  ***      0                                  0      $self->stop_slave($dbh);
5433  ***      0      0                           0      my $stat = $self->get_slave_status($dbh)
5434                                                        or die "This server is not a slave";
5435  ***      0                                  0      $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
5436  ***      0                                  0      $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
5437  ***      0                                  0      return $stat;
5438                                                  }
5439                                                  
5440                                                  sub slave_is_running {
5441  ***      0                    0             0      my ( $self, $slave_status ) = @_;
5442  ***      0             0                    0      return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
5443                                                  }
5444                                                  
5445                                                  sub has_slave_updates {
5446  ***      0                    0             0      my ( $self, $dbh ) = @_;
5447  ***      0                                  0      my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
5448  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
5449  ***      0                                  0      my ($name, $value) = $dbh->selectrow_array($sql);
5450  ***      0             0                    0      return $value && $value =~ m/^(1|ON)$/;
5451                                                  }
5452                                                  
5453                                                  sub repl_posn {
5454  ***      0                    0             0      my ( $self, $status ) = @_;
5455  ***      0      0      0                    0      if ( exists $status->{file} && exists $status->{position} ) {
5456                                                        return {
5457  ***      0                                  0            file     => $status->{file},
5458                                                           position => $status->{position},
5459                                                        };
5460                                                     }
5461                                                     else {
5462                                                        return {
5463  ***      0                                  0            file     => $status->{relay_master_log_file},
5464                                                           position => $status->{exec_master_log_pos},
5465                                                        };
5466                                                     }
5467                                                  }
5468                                                  
5469                                                  sub get_slave_lag {
5470  ***      0                    0             0      my ( $self, $dbh ) = @_;
5471  ***      0                                  0      my $stat = $self->get_slave_status($dbh);
5472  ***      0                                  0      return $stat->{seconds_behind_master};
5473                                                  }
5474                                                  
5475                                                  sub pos_cmp {
5476  ***      0                    0             0      my ( $self, $a, $b ) = @_;
5477  ***      0                                  0      return $self->pos_to_string($a) cmp $self->pos_to_string($b);
5478                                                  }
5479                                                  
5480                                                  sub short_host {
5481  ***      0                    0             0      my ( $self, $dsn ) = @_;
5482  ***      0                                  0      my ($host, $port);
5483  ***      0      0                           0      if ( $dsn->{master_host} ) {
5484  ***      0                                  0         $host = $dsn->{master_host};
5485  ***      0                                  0         $port = $dsn->{master_port};
5486                                                     }
5487                                                     else {
5488  ***      0                                  0         $host = $dsn->{h};
5489  ***      0                                  0         $port = $dsn->{P};
5490                                                     }
5491  ***      0      0      0                    0      return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
5492                                                  }
5493                                                  
5494                                                  sub pos_to_string {
5495  ***      0                    0             0      my ( $self, $pos ) = @_;
5496  ***      0                                  0      my $fmt  = '%s/%020d';
5497  ***      0                                  0      return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                  0   
5498                                                  }
5499                                                  
5500                                                  sub _d {
5501  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5502  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5503  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5504                                                          @_;
5505  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5506                                                  }
5507                                                  
5508                                                  1;
5509                                                  
5510                                                  # ###########################################################################
5511                                                  # End MasterSlave package
5512                                                  # ###########################################################################
5513                                                  
5514                                                  # ###########################################################################
5515                                                  # Daemon package 5266
5516                                                  # ###########################################################################
5517                                                  
5518                                                  package Daemon;
5519                                                  
5520          29                   29           279   use strict;
              29                                 88   
              29                                190   
5521          29                   29           188   use warnings FATAL => 'all';
              29                                 83   
              29                                180   
5522                                                  
5523          29                   29           181   use POSIX qw(setsid);
              29                                 69   
              29                                220   
5524          29                   29           193   use English qw(-no_match_vars);
              29                                 89   
              29                                171   
5525                                                  
5526  ***     29            50     29           209   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 73   
              29                                480   
5527                                                  
5528                                                  sub new {
5529  ***      0                    0             0      my ( $class, %args ) = @_;
5530  ***      0                                  0      foreach my $arg ( qw(o) ) {
5531  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5532                                                     }
5533  ***      0                                  0      my $o = $args{o};
5534  ***      0      0                           0      my $self = {
      ***             0                               
5535                                                        o        => $o,
5536                                                        log_file => $o->has('log') ? $o->get('log') : undef,
5537                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
5538                                                     };
5539                                                  
5540  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
5541                                                  
5542  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
5543  ***      0                                  0      return bless $self, $class;
5544                                                  }
5545                                                  
5546                                                  sub daemonize {
5547  ***      0                    0             0      my ( $self ) = @_;
5548                                                  
5549  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
5550  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
5551  ***      0      0                           0      if ( $pid ) {
5552  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
5553  ***      0                                  0         exit;
5554                                                     }
5555                                                  
5556  ***      0                                  0      $self->{child} = 1;
5557                                                  
5558  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
5559  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
5560                                                  
5561  ***      0                                  0      $self->_make_PID_file();
5562                                                  
5563  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
5564                                                  
5565  ***      0      0                           0      if ( -t STDIN ) {
5566  ***      0                                  0         close STDIN;
5567  ***      0      0                           0         open  STDIN, '/dev/null'
5568                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
5569                                                     }
5570                                                  
5571  ***      0      0                           0      if ( $self->{log_file} ) {
5572  ***      0                                  0         close STDOUT;
5573  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
5574                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
5575                                                  
5576  ***      0                                  0         close STDERR;
5577  ***      0      0                           0         open  STDERR, ">&STDOUT"
5578                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
5579                                                     }
5580                                                     else {
5581  ***      0      0                           0         if ( -t STDOUT ) {
5582  ***      0                                  0            close STDOUT;
5583  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
5584                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
5585                                                        }
5586  ***      0      0                           0         if ( -t STDERR ) {
5587  ***      0                                  0            close STDERR;
5588  ***      0      0                           0            open  STDERR, '>', '/dev/null'
5589                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
5590                                                        }
5591                                                     }
5592                                                  
5593  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
5594  ***      0                                  0      return;
5595                                                  }
5596                                                  
5597                                                  sub check_PID_file {
5598  ***      0                    0             0      my ( $self, $file ) = @_;
5599  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
5600  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
5601  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
5602  ***      0                                  0         my $pid;
5603  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
5604  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
5605  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
5606  ***      0      0                           0         if ( $pid ) {
5607  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
5608  ***      0      0                           0            if ( $pid_is_alive ) {
5609  ***      0                                  0               die "The PID file $PID_file already exists "
5610                                                                 . " and the PID that it contains, $pid, is running";
5611                                                           }
5612                                                           else {
5613  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
5614                                                                 . "contains, $pid, is not running";
5615                                                           }
5616                                                        }
5617                                                        else {
5618  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
5619                                                              . "contain a PID";
5620                                                        }
5621                                                     }
5622                                                     else {
5623  ***      0                                  0         MKDEBUG && _d('No PID file');
5624                                                     }
5625  ***      0                                  0      return;
5626                                                  }
5627                                                  
5628                                                  sub make_PID_file {
5629  ***      0                    0             0      my ( $self ) = @_;
5630  ***      0      0                           0      if ( exists $self->{child} ) {
5631  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
5632                                                     }
5633  ***      0                                  0      $self->_make_PID_file();
5634  ***      0                                  0      $self->{rm_PID_file} = 1;
5635  ***      0                                  0      return;
5636                                                  }
5637                                                  
5638                                                  sub _make_PID_file {
5639  ***      0                    0             0      my ( $self ) = @_;
5640                                                  
5641  ***      0                                  0      my $PID_file = $self->{PID_file};
5642  ***      0      0                           0      if ( !$PID_file ) {
5643  ***      0                                  0         MKDEBUG && _d('No PID file to create');
5644  ***      0                                  0         return;
5645                                                     }
5646                                                  
5647  ***      0                                  0      $self->check_PID_file();
5648                                                  
5649  ***      0      0                           0      open my $PID_FH, '>', $PID_file
5650                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
5651  ***      0      0                           0      print $PID_FH $PID
5652                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
5653  ***      0      0                           0      close $PID_FH
5654                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
5655                                                  
5656  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
5657  ***      0                                  0      return;
5658                                                  }
5659                                                  
5660                                                  sub _remove_PID_file {
5661  ***      0                    0             0      my ( $self ) = @_;
5662  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
5663  ***      0      0                           0         unlink $self->{PID_file}
5664                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
5665  ***      0                                  0         MKDEBUG && _d('Removed PID file');
5666                                                     }
5667                                                     else {
5668  ***      0                                  0         MKDEBUG && _d('No PID to remove');
5669                                                     }
5670  ***      0                                  0      return;
5671                                                  }
5672                                                  
5673                                                  sub DESTROY {
5674  ***      0                    0             0      my ( $self ) = @_;
5675  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
5676  ***      0                                  0      return;
5677                                                  }
5678                                                  
5679                                                  sub _d {
5680  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5681  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5682  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5683                                                          @_;
5684  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5685                                                  }
5686                                                  
5687                                                  1;
5688                                                  
5689                                                  # ###########################################################################
5690                                                  # End Daemon package
5691                                                  # ###########################################################################
5692                                                  
5693                                                  # ###########################################################################
5694                                                  # SchemaIterator package 5473
5695                                                  # ###########################################################################
5696                                                  package SchemaIterator;
5697                                                  
5698          29                   29           212   use strict;
              29                                 77   
              29                                176   
5699          29                   29           181   use warnings FATAL => 'all';
              29                                 78   
              29                                162   
5700                                                  
5701          29                   29           174   use English qw(-no_match_vars);
              29                                 84   
              29                                150   
5702          29                   29           199   use Data::Dumper;
              29                                104   
              29                                166   
5703                                                  $Data::Dumper::Indent    = 1;
5704                                                  $Data::Dumper::Sortkeys  = 1;
5705                                                  $Data::Dumper::Quotekeys = 0;
5706                                                  
5707  ***     29            50     29           184   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 77   
              29                                552   
5708                                                  
5709                                                  sub new {
5710           5                    5            48      my ( $class, %args ) = @_;
5711           5                                 42      foreach my $arg ( qw(Quoter) ) {
5712  ***      5     50                          46         die "I need a $arg argument" unless $args{$arg};
5713                                                     }
5714           5                                 55      my $self = {
5715                                                        %args,
5716                                                        filter => undef,
5717                                                        dbs    => [],
5718                                                     };
5719           5                                 87      return bless $self, $class;
5720                                                  }
5721                                                  
5722                                                  sub make_filter {
5723           5                    5            32      my ( $self, $o ) = @_;
5724           5                                 42      my @lines = (
5725                                                        'sub {',
5726                                                        '   my ( $dbh, $db, $tbl ) = @_;',
5727                                                        '   my $engine = undef;',
5728                                                     );
5729                                                  
5730                                                  
5731  ***      5     50                          33      my @permit_dbs = _make_filter('unless', '$db', $o->get('databases'))
5732                                                        if $o->has('databases');
5733  ***      5     50                          35      my @reject_dbs = _make_filter('if', '$db', $o->get('ignore-databases'))
5734                                                        if $o->has('ignore-databases');
5735           5                                 19      my @dbs_regex;
5736  ***      5     50     33                   33      if ( $o->has('databases-regex') && (my $p = $o->get('databases-regex')) ) {
5737  ***      0                                  0         push @dbs_regex, "      return 0 unless \$db && (\$db =~ m/$p/o);";
5738                                                     }
5739           5                                 19      my @reject_dbs_regex;
5740  ***      5     50     33                   28      if ( $o->has('ignore-databases-regex')
5741                                                          && (my $p = $o->get('ignore-databases-regex')) ) {
5742  ***      0                                  0         push @reject_dbs_regex, "      return 0 if \$db && (\$db =~ m/$p/o);";
5743                                                     }
5744  ***      5     50     33                   64      if ( @permit_dbs || @reject_dbs || @dbs_regex || @reject_dbs_regex ) {
      ***                   33                        
      ***                   33                        
5745  ***      5     50                          86         push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
5746                                                           '   if ( $db ) {',
5747                                                              (@permit_dbs        ? @permit_dbs       : ()),
5748                                                              (@reject_dbs        ? @reject_dbs       : ()),
5749                                                              (@dbs_regex         ? @dbs_regex        : ()),
5750                                                              (@reject_dbs_regex  ? @reject_dbs_regex : ()),
5751                                                           '   }';
5752                                                     }
5753                                                  
5754  ***      5     50     33                   29      if ( $o->has('tables') || $o->has('ignore-tables')
      ***                   33                        
5755                                                          || $o->has('ignore-tables-regex') ) {
5756                                                  
5757           5                                 19         my $have_qtbl       = 0;
5758           5                                 19         my $have_only_qtbls = 0;
5759           5                                 16         my %qtbls;
5760                                                  
5761           5                                 16         my @permit_tbls;
5762           5                                 14         my @permit_qtbls;
5763           5                                 19         my %permit_qtbls;
5764  ***      5     50                          28         if ( $o->get('tables') ) {
5765  ***      0                                  0            my %tbls;
5766                                                           map {
5767  ***      0      0                           0               if ( $_ =~ m/\./ ) {
      ***      0                                  0   
5768  ***      0                                  0                  $permit_qtbls{$_} = 1;
5769                                                              }
5770                                                              else {
5771  ***      0                                  0                  $tbls{$_} = 1;
5772                                                              }
5773  ***      0                                  0            } keys %{ $o->get('tables') };
5774  ***      0                                  0            @permit_tbls  = _make_filter('unless', '$tbl', \%tbls);
5775  ***      0                                  0            @permit_qtbls = _make_filter('unless', '$qtbl', \%permit_qtbls);
5776                                                  
5777  ***      0      0                           0            if ( @permit_qtbls ) {
5778  ***      0                                  0               push @lines,
5779                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
5780  ***      0                                  0               $have_qtbl = 1;
5781                                                           }
5782                                                        }
5783                                                  
5784           5                                 20         my @reject_tbls;
5785           5                                 16         my @reject_qtbls;
5786           5                                 24         my %reject_qtbls;
5787  ***      5     50                          29         if ( $o->get('ignore-tables') ) {
5788           5                                 18            my %tbls;
5789                                                           map {
5790  ***      0      0                           0               if ( $_ =~ m/\./ ) {
               5                                 24   
5791  ***      0                                  0                  $reject_qtbls{$_} = 1;
5792                                                              }
5793                                                              else {
5794  ***      0                                  0                  $tbls{$_} = 1;
5795                                                              }
5796           5                                 19            } keys %{ $o->get('ignore-tables') };
5797           5                                 33            @reject_tbls= _make_filter('if', '$tbl', \%tbls);
5798           5                                 32            @reject_qtbls = _make_filter('if', '$qtbl', \%reject_qtbls);
5799                                                  
5800  ***      5     50     33                   40            if ( @reject_qtbls && !$have_qtbl ) {
5801  ***      0                                  0               push @lines,
5802                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
5803                                                           }
5804                                                        }
5805                                                  
5806  ***      5     50     33                   41         if ( keys %permit_qtbls  && !@permit_dbs ) {
5807  ***      0                                  0            my $dbs = {};
5808  ***      0                                  0            map {
5809  ***      0                                  0               my ($db, undef) = split(/\./, $_);
5810  ***      0                                  0               $dbs->{$db} = 1;
5811                                                           } keys %permit_qtbls;
5812  ***      0                                  0            MKDEBUG && _d('Adding restriction "--databases',
5813                                                                 (join(',', keys %$dbs) . '"'));
5814  ***      0      0                           0            if ( keys %$dbs ) {
5815  ***      0                                  0               $o->set('databases', $dbs);
5816  ***      0                                  0               return $self->make_filter($o);
5817                                                           }
5818                                                        }
5819                                                  
5820           5                                 16         my @tbls_regex;
5821  ***      5     50     33                   28         if ( $o->has('tables-regex') && (my $p = $o->get('tables-regex')) ) {
5822  ***      0                                  0            push @tbls_regex, "      return 0 unless \$tbl && (\$tbl =~ m/$p/o);";
5823                                                        }
5824           5                                 19         my @reject_tbls_regex;
5825  ***      5     50     33                   32         if ( $o->has('ignore-tables-regex')
5826                                                             && (my $p = $o->get('ignore-tables-regex')) ) {
5827  ***      0                                  0            push @reject_tbls_regex,
5828                                                              "      return 0 if \$tbl && (\$tbl =~ m/$p/o);";
5829                                                        }
5830                                                  
5831           5                                 19         my @get_eng;
5832           5                                 16         my @permit_engs;
5833           5                                 17         my @reject_engs;
5834  ***      5     50     33                   27         if ( ($o->has('engines') && $o->get('engines'))
      ***                   33                        
      ***                   33                        
5835                                                             || ($o->has('ignore-engines') && $o->get('ignore-engines')) ) {
5836           5                                 45            push @get_eng,
5837                                                              '      my $sql = "SHOW TABLE STATUS "',
5838                                                              '              . ($db ? "FROM `$db`" : "")',
5839                                                              '              . " LIKE \'$tbl\'";',
5840                                                              '      MKDEBUG && _d($sql);',
5841                                                              '      eval {',
5842                                                              '         $engine = $dbh->selectrow_hashref($sql)->{engine};',
5843                                                              '      };',
5844                                                              '      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);',
5845                                                              '      MKDEBUG && _d($tbl, "uses engine", $engine);',
5846                                                              '      $engine = lc $engine if $engine;',
5847                                                           @permit_engs
5848                                                              = _make_filter('unless', '$engine', $o->get('engines'), 1);
5849                                                           @reject_engs
5850           5                                 34               = _make_filter('if', '$engine', $o->get('ignore-engines'), 1)
5851                                                        }
5852                                                  
5853  ***      5     50     33                  225         if ( @permit_tbls || @reject_tbls || @tbls_regex || @reject_tbls_regex
      ***                   33                        
      ***                   33                        
      ***                   33                        
      ***                   33                        
5854                                                             || @permit_engs || @reject_engs ) {
5855  ***      5     50                         148            push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
5856                                                              '   if ( $tbl ) {',
5857                                                                 (@permit_tbls       ? @permit_tbls        : ()),
5858                                                                 (@reject_tbls       ? @reject_tbls        : ()),
5859                                                                 (@tbls_regex        ? @tbls_regex         : ()),
5860                                                                 (@reject_tbls_regex ? @reject_tbls_regex  : ()),
5861                                                                 (@permit_qtbls      ? @permit_qtbls       : ()),
5862                                                                 (@reject_qtbls      ? @reject_qtbls       : ()),
5863                                                                 (@get_eng           ? @get_eng            : ()),
5864                                                                 (@permit_engs       ? @permit_engs        : ()),
5865                                                                 (@reject_engs       ? @reject_engs        : ()),
5866                                                              '   }';
5867                                                        }
5868                                                     }
5869                                                  
5870           5                                 30      push @lines,
5871                                                        '   MKDEBUG && _d(\'Passes filters:\', $db, $tbl, $engine, $dbh);',
5872                                                        '   return 1;',  '}';
5873                                                  
5874           5                                 61      my $code = join("\n", @lines);
5875           5                                 16      MKDEBUG && _d('filter sub:', $code);
5876  ***      5     50                        1810      my $filter_sub= eval $code
5877                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
5878                                                  
5879           5                                 69      return $filter_sub;
5880                                                  }
5881                                                  
5882                                                  sub set_filter {
5883           5                    5            31      my ( $self, $filter_sub ) = @_;
5884           5                                 27      $self->{filter} = $filter_sub;
5885           5                                 14      MKDEBUG && _d('Set filter sub');
5886           5                                 19      return;
5887                                                  }
5888                                                  
5889                                                  sub get_db_itr {
5890           5                    5            41      my ( $self, %args ) = @_;
5891           5                                 36      my @required_args = qw(dbh);
5892           5                                 36      foreach my $arg ( @required_args ) {
5893  ***      5     50                          41         die "I need a $arg argument" unless $args{$arg};
5894                                                     }
5895           5                                 29      my ($dbh) = @args{@required_args};
5896                                                  
5897           5                                 23      my $filter = $self->{filter};
5898           5                                 17      my @dbs;
5899           5                                 20      eval {
5900           5                                 21         my $sql = 'SHOW DATABASES';
5901           5                                 15         MKDEBUG && _d($sql);
5902  ***     20     50                         177         @dbs =  grep {
5903           5                                 16            my $ok = $filter ? $filter->($dbh, $_, undef) : 1;
5904          20    100                         192            $ok = 0 if $_ =~ m/information_schema|lost\+found/;
5905          20                                 89            $ok;
5906           5                                 19         } @{ $dbh->selectcol_arrayref($sql) };
5907           5                                 25         MKDEBUG && _d('Found', scalar @dbs, 'databases');
5908                                                     };
5909           5                                 17      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
5910                                                     return sub {
5911          10                   10            92         return shift @dbs;
5912           5                                 60      };
5913                                                  }
5914                                                  
5915                                                  sub get_tbl_itr {
5916           5                    5            50      my ( $self, %args ) = @_;
5917           5                                 32      my @required_args = qw(dbh db);
5918           5                                 37      foreach my $arg ( @required_args ) {
5919  ***     10     50                          70         die "I need a $arg argument" unless $args{$arg};
5920                                                     }
5921           5                                 37      my ($dbh, $db, $views) = @args{@required_args, 'views'};
5922                                                  
5923           5                                 23      my $filter = $self->{filter};
5924           5                                 15      my @tbls;
5925  ***      5     50                          27      if ( $db ) {
5926           5                                 22         eval {
5927           5                                 58            my $sql = 'SHOW /*!50002 FULL*/ TABLES FROM '
5928                                                                   . $self->{Quoter}->quote($db);
5929           5                                 16            MKDEBUG && _d($sql);
5930           5                                 41            @tbls = map {
5931           5                               1476               $_->[0]
5932                                                           }
5933                                                           grep {
5934           5                                 16               my ($tbl, $type) = @$_;
5935  ***      5     50                          50               my $ok = $filter ? $filter->($dbh, $db, $tbl) : 1;
5936  ***      5     50                          35               if ( !$views ) {
5937  ***      5     50     50                   46                  $ok = 0 if ($type || '') eq 'VIEW';
5938                                                              }
5939           5                                 29               $ok;
5940                                                           }
5941           5                                 20            @{ $dbh->selectall_arrayref($sql) };
5942           5                                101            MKDEBUG && _d('Found', scalar @tbls, 'tables in', $db);
5943                                                        };
5944           5                                 18         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
5945                                                     }
5946                                                     else {
5947  ***      0                                  0         MKDEBUG && _d('No db given so no tables');
5948                                                     }
5949                                                     return sub {
5950          10                   10           105         return shift @tbls;
5951           5                                 81      };
5952                                                  }
5953                                                  
5954                                                  sub _make_filter {
5955          30                   30           198      my ( $cond, $var_name, $objs, $lc ) = @_;
5956          30                                109      my @lines;
5957          30    100                         190      if ( scalar keys %$objs ) {
5958          15    100                         142         my $test = join(' || ',
5959          10                                 61            map { "$var_name eq '" . ($lc ? lc $_ : $_) ."'" } keys %$objs);
5960          10                                 84         push @lines, "      return 0 $cond $var_name && ($test);",
5961                                                     }
5962          30                                192      return @lines;
5963                                                  }
5964                                                  
5965                                                  sub _d {
5966  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5967  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5968  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5969                                                          @_;
5970  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5971                                                  }
5972                                                  
5973                                                  1;
5974                                                  
5975                                                  # ###########################################################################
5976                                                  # End SchemaIterator package
5977                                                  # ###########################################################################
5978                                                  
5979                                                  # ###########################################################################
5980                                                  # Transformers package 5715
5981                                                  # ###########################################################################
5982                                                  
5983                                                  package Transformers;
5984                                                  
5985          29                   29           225   use strict;
              29                                 87   
              29                                173   
5986          29                   29           182   use warnings FATAL => 'all';
              29                                 78   
              29                                178   
5987          29                   29           181   use English qw(-no_match_vars);
              29                                 95   
              29                                160   
5988          29                   29           399   use Time::Local qw(timegm timelocal);
              29                                 90   
              29                                321   
5989          29                   29           201   use Digest::MD5 qw(md5_hex);
              29                                 70   
              29                                212   
5990                                                  
5991  ***     29            50     29           216   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 73   
              29                                668   
5992                                                  
5993                                                  require Exporter;
5994                                                  our @ISA         = qw(Exporter);
5995                                                  our %EXPORT_TAGS = ();
5996                                                  our @EXPORT      = ();
5997                                                  our @EXPORT_OK   = qw(
5998                                                     micro_t
5999                                                     percentage_of
6000                                                     secs_to_time
6001                                                     time_to_secs
6002                                                     shorten
6003                                                     ts
6004                                                     parse_timestamp
6005                                                     unix_timestamp
6006                                                     any_unix_timestamp
6007                                                     make_checksum
6008                                                  );
6009                                                  
6010                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
6011                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
6012                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
6013                                                  
6014                                                  sub micro_t {
6015  ***      0                    0             0      my ( $t, %args ) = @_;
6016  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
6017  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
6018  ***      0                                  0      my $f;
6019                                                  
6020  ***      0      0                           0      $t = 0 if $t < 0;
6021                                                  
6022  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
6023                                                  
6024  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
6025                                                  
6026  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
6027  ***      0                                  0         $f = ($t * 1000000) . 'us';
6028                                                     }
6029                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
6030  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
6031  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
6032                                                     }
6033                                                     elsif ($t >= 1) {
6034  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
6035  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
6036                                                     }
6037                                                     else {
6038  ***      0                                  0         $f = 0;  # $t should = 0 at this point
6039                                                     }
6040                                                  
6041  ***      0                                  0      return $f;
6042                                                  }
6043                                                  
6044                                                  sub percentage_of {
6045  ***      0                    0             0      my ( $is, $of, %args ) = @_;
6046  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
6047  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
6048  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
6049                                                  }
6050                                                  
6051                                                  sub secs_to_time {
6052  ***      0                    0             0      my ( $secs, $fmt ) = @_;
6053  ***      0             0                    0      $secs ||= 0;
6054  ***      0      0                           0      return '00:00' unless $secs;
6055                                                  
6056  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
6057                                                            : $secs >= 3_600  ? 'h'
6058                                                            :                   'm';
6059                                                  
6060                                                     return
6061  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
6062                                                           "%d+%02d:%02d:%02d",
6063                                                           int($secs / 86_400),
6064                                                           int(($secs % 86_400) / 3_600),
6065                                                           int(($secs % 3_600) / 60),
6066                                                           $secs % 60)
6067                                                        : $fmt eq 'h' ? sprintf(
6068                                                           "%02d:%02d:%02d",
6069                                                           int(($secs % 86_400) / 3_600),
6070                                                           int(($secs % 3_600) / 60),
6071                                                           $secs % 60)
6072                                                        : sprintf(
6073                                                           "%02d:%02d",
6074                                                           int(($secs % 3_600) / 60),
6075                                                           $secs % 60);
6076                                                  }
6077                                                  
6078                                                  sub time_to_secs {
6079          11                   11            56      my ( $val, $default_suffix ) = @_;
6080  ***     11     50                          63      die "I need a val argument" unless defined $val;
6081          11                                 38      my $t = 0;
6082          11                                157      my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
6083  ***     11            33                   82      $suffix = $suffix || $default_suffix || 's';
      ***                   50                        
6084  ***     11     50                          76      if ( $suffix =~ m/[smhd]/ ) {
6085  ***     11     50                         230         $t = $suffix eq 's' ? $num * 1        # Seconds
                    100                               
      ***            50                               
6086                                                           : $suffix eq 'm' ? $num * 60       # Minutes
6087                                                           : $suffix eq 'h' ? $num * 3600     # Hours
6088                                                           :                  $num * 86400;   # Days
6089                                                  
6090  ***     11     50     33                   74         $t *= -1 if $prefix && $prefix eq '-';
6091                                                     }
6092                                                     else {
6093  ***      0                                  0         die "Invalid suffix for $val: $suffix";
6094                                                     }
6095          11                                 47      return $t;
6096                                                  }
6097                                                  
6098                                                  sub shorten {
6099  ***      0                    0             0      my ( $num, %args ) = @_;
6100  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
6101  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
6102  ***      0                                  0      my $n = 0;
6103  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
6104  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
6105  ***      0                                  0         $num /= $d;
6106  ***      0                                  0         ++$n;
6107                                                     }
6108  ***      0      0      0                    0      return sprintf(
6109                                                        $num =~ m/\./ || $n
6110                                                           ? "%.${p}f%s"
6111                                                           : '%d',
6112                                                        $num, $units[$n]);
6113                                                  }
6114                                                  
6115                                                  sub ts {
6116  ***      0                    0             0      my ( $time, $gmt ) = @_;
6117  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
6118                                                        = $gmt ? gmtime($time) : localtime($time);
6119  ***      0                                  0      $mon  += 1;
6120  ***      0                                  0      $year += 1900;
6121  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
6122                                                        $year, $mon, $mday, $hour, $min, $sec);
6123  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
6124  ***      0                                  0         $us = sprintf("%.6f", $us);
6125  ***      0                                  0         $us =~ s/^0\././;
6126  ***      0                                  0         $val .= $us;
6127                                                     }
6128  ***      0                                  0      return $val;
6129                                                  }
6130                                                  
6131                                                  sub parse_timestamp {
6132  ***      0                    0             0      my ( $val ) = @_;
6133  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
6134                                                           = $val =~ m/^$mysql_ts$/ )
6135                                                     {
6136  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
6137                                                                       . (defined $f ? '%02.6f' : '%02d'),
6138                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
6139                                                     }
6140  ***      0                                  0      return $val;
6141                                                  }
6142                                                  
6143                                                  sub unix_timestamp {
6144          12                   12            42      my ( $val, $gmt ) = @_;
6145  ***     12     50                         157      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
6146  ***     12     50                          75         $val = $gmt
6147                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
6148                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
6149  ***     12     50                          46         if ( defined $us ) {
6150  ***      0                                  0            $us = sprintf('%.6f', $us);
6151  ***      0                                  0            $us =~ s/^0\././;
6152  ***      0                                  0            $val .= $us;
6153                                                        }
6154                                                     }
6155          12                                 56      return $val;
6156                                                  }
6157                                                  
6158                                                  sub any_unix_timestamp {
6159          22                   22           111      my ( $val, $callback ) = @_;
6160                                                  
6161  ***     22     50                         495      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
                    100                               
      ***            50                               
      ***            50                               
6162  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
6163                                                           : $suffix eq 'm' ? $n * 60       # Minutes
6164                                                           : $suffix eq 'h' ? $n * 3600     # Hours
6165                                                           : $suffix eq 'd' ? $n * 86400    # Days
6166                                                           :                  $n;           # default: Seconds
6167  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
6168  ***      0                                  0         return time - $n;
6169                                                     }
6170                                                     elsif ( $val =~ m/^\d{9,}/ ) {
6171          10                                 32         MKDEBUG && _d('ts is already a unix timestamp');
6172          10                                 64         return $val;
6173                                                     }
6174                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
6175  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
6176  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
6177  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
6178                                                     }
6179                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
6180          12                                 24         MKDEBUG && _d('ts is properly formatted timestamp');
6181          12    100                          47         $val .= ' 00:00:00' unless $hms;
6182          12                                 41         return unix_timestamp($val);
6183                                                     }
6184                                                     else {
6185  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
6186  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
6187                                                     }
6188                                                  
6189  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
6190  ***      0                                  0      return;
6191                                                  }
6192                                                  
6193                                                  sub make_checksum {
6194  ***      0                    0             0      my ( $val ) = @_;
6195  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
6196  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
6197  ***      0                                  0      return $checksum;
6198                                                  }
6199                                                  
6200                                                  sub _d {
6201  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6202  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6203  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6204                                                          @_;
6205  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6206                                                  }
6207                                                  
6208                                                  1;
6209                                                  
6210                                                  # ###########################################################################
6211                                                  # End Transformers package
6212                                                  # ###########################################################################
6213                                                  
6214                                                  # ###########################################################################
6215                                                  # This is a combination of modules and programs in one -- a runnable module.
6216                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
6217                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
6218                                                  #
6219                                                  # Check at the end of this package for the call to main() which actually runs
6220                                                  # the program.
6221                                                  # ###########################################################################
6222                                                  package mk_table_sync;
6223                                                  
6224          29                   29           234   use English qw(-no_match_vars);
              29                                 76   
              29                                211   
6225          29                   29           231   use List::Util qw(sum max min);
              29                                 83   
              29                                199   
6226          29                   29           176   use POSIX qw(ceil);
              29                                 77   
              29                                201   
6227                                                  
6228                                                  Transformers->import(qw(time_to_secs any_unix_timestamp));
6229                                                  
6230  ***     29            50     29           188   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              29                                 84   
              29                                487   
6231                                                  
6232                                                  $OUTPUT_AUTOFLUSH = 1;
6233                                                  
6234                                                  my %dsn_for;
6235                                                  
6236                                                  sub main {
6237           5                    5        1728948      @ARGV = @_;  # set global ARGV for this package
6238                                                  
6239                                                     # ########################################################################
6240                                                     # Get configuration information.
6241                                                     # ########################################################################
6242           5                                275      my $dp = new DSNParser(
6243                                                        {
6244                                                           key  => 'D',
6245                                                           desc => 'Database containing the table to be synced',
6246                                                           dsn  => 'database',
6247                                                           copy => 1,
6248                                                        },
6249                                                        {
6250                                                           key  => 't',
6251                                                           desc => 'Table to be synced',
6252                                                           dsn  => undef,
6253                                                           copy => 1,
6254                                                        },
6255                                                     );
6256                                                  
6257           5                                172      my $o = new OptionParser(
6258                                                        dp          => $dp,
6259                                                        strict      => 0,
6260                                                        prompt      => '[OPTION]... DSN [DSN]...',
6261                                                        description => 'synchronizes data efficiently between MySQL tables.',
6262                                                     );
6263           5                                 51      $o->get_specs();
6264           5                                 77      $o->get_opts();
6265                                                  
6266           5                                 53      $dp->prop('set-vars', $o->get('set-vars'));
6267                                                  
6268  ***      5     50     33                   29      if ( $o->get('replicate') || $o->get('sync-to-master') ) {
6269  ***      0      0                           0         $o->set('wait', 60) unless $o->got('wait');
6270                                                     }
6271  ***      5     50                          33      if ( $o->get('wait') ) {
6272  ***      0      0                           0         $o->set('lock', 1) unless $o->got('lock');
6273                                                     }
6274  ***      5     50                          27      if ( $o->get('dry-run') ) {
6275  ***      0                                  0         $o->set('verbose', 1);
6276                                                     }
6277                                                  
6278                                                     # There's a conflict of interests: we added 't' and 'D' parts to dp,
6279                                                     # and there are -t and -D options (--tables, --databases), so parse_options()
6280                                                     # is going to return a DSN with the default values from -t and -D,
6281                                                     # but these are not actually be default dsn vals, they're filters.
6282                                                     # So we have to remove them from $dsn_defaults.
6283           5                                 55      my $dsn_defaults = $dp->parse_options($o);
6284           5                                 27      $dsn_defaults->{D} = undef;
6285           5                                 23      $dsn_defaults->{t} = undef;
6286                                                  
6287           5                                 18      my @dsns;
6288           5                                 47      while ( my $arg = shift(@ARGV) ) {
6289          12                                 86         my $dsn = $dp->parse($arg, $dsns[0], $dsn_defaults);
6290  ***     12     50     33                   99         die "You specified a t part, but not a D part in $arg"
6291                                                           if ($dsn->{t} && !$dsn->{D});
6292  ***     12     50     33                   86         if ( $dsn->{D} && !$dsn->{t} ) {
6293  ***      0                                  0            die "You specified a database but not a table in $arg.  Are you "
6294                                                              . "trying to sync only tables in the '$dsn->{D}' database?  "
6295                                                              . "If so, use '--databases $dsn->{D}' instead.\n";
6296                                                        }
6297          12                                108         push @dsns, $dsn;
6298                                                     }
6299                                                  
6300  ***      5     50     33                  116      if ( !@dsns
      ***                   33                        
      ***                   33                        
6301                                                          || (@dsns ==1 && !$o->get('replicate') && !$o->get('sync-to-master'))) {
6302  ***      0                                  0         $o->save_error('At least one DSN is required, and at least two are '
6303                                                           . 'required unless --sync-to-master or --replicate is specified');
6304                                                     }
6305                                                  
6306  ***      5     50     33                   53      if ( @dsns > 1 && $o->get('sync-to-master') && $o->get('replicate') ) {
      ***                   33                        
6307  ***      0                                  0         $o->save_error('--sync-to-master and --replicate require only one DSN ',
6308                                                           ' but ', scalar @dsns, ' where given');
6309                                                     }
6310                                                  
6311  ***      5     50                          44      if ( $o->get('lock-and-rename') ) {
6312  ***      0      0      0                    0         if ( @dsns != 2 || !$dsns[0]->{t} || !$dsns[1]->{t} ) {
      ***                    0                        
6313  ***      0                                  0            $o->save_error("--lock-and-rename requires exactly two DSNs and they "
6314                                                              . "must each specify a table.");
6315                                                        }
6316                                                     }
6317                                                  
6318  ***      5     50                          30      if ( $o->get('bidirectional') ) {
6319  ***      5     50     33                   24         if ( $o->get('replicate') || $o->get('sync-to-master') ) {
6320  ***      0                                  0            $o->save_error('--bidirectional does not work with '
6321                                                              . '--replicate or --sync-to-master');
6322                                                        }
6323  ***      5     50                          34         if ( @dsns < 2 ) {
6324  ***      0                                  0            $o->save_error('--bidirectional requires at least two DSNs');
6325                                                        }
6326  ***      5     50     33                   30         if ( !$o->get('conflict-column') || !$o->get('conflict-comparison') ) {
6327  ***      0                                  0            $o->save_error('--bidirectional requires --conflict-column '
6328                                                              . 'and --conflict-comparison');
6329                                                        }
6330           5                                 31         my $cc  = $o->get('conflict-comparison');
6331           5                                 97         my $cmp = $o->read_para_after(__FILE__, qr/MAGIC_comparisons/);
6332           5                                141         $cmp    =~ s/ //g;
6333  ***      5     50     33                  223         if ( $cc && $cc !~ m/$cmp/ ) {
6334  ***      0                                  0            $o->save_error("--conflict-comparison must be one of $cmp");
6335                                                        }
6336  ***      5     50     33                   94         if ( $cc && $cc =~ m/equals|matches/ && !$o->get('conflict-value') ) {
      ***                   33                        
6337  ***      0                                  0            $o->save_error("--conflict-comparison $cc requires --conflict-value")
6338                                                        }
6339                                                  
6340                                                        # Override --algorithms becuase only TableSyncChunk works with
6341                                                        # bidirectional syncing.
6342           5                                 52         $o->set('algorithms', 'Chunk');
6343           5                                 27         $o->set('buffer-to-client', 0);
6344                                                     }
6345                                                  
6346  ***      5     50                          49      if ( $o->get('explain-hosts') ) {
6347  ***      0                                  0         foreach my $host ( @dsns ) {
6348  ***      0                                  0            print "# DSN: ", $dp->as_string($host), "\n";
6349                                                        }
6350  ***      0                                  0         return 0;
6351                                                     }
6352                                                  
6353           5                                 59      $o->usage_or_errors();
6354                                                  
6355                                                     # ########################################################################
6356                                                     # If --pid, check it first since we'll die if it already exits.
6357                                                     # ########################################################################
6358           5                                 18      my $daemon;
6359  ***      5     50                          28      if ( $o->get('pid') ) {
6360                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
6361                                                        # in the the scope of main() because when it's destroyed it automatically
6362                                                        # removes the PID file.
6363  ***      0                                  0         $daemon = new Daemon(o=>$o);
6364  ***      0                                  0         $daemon->make_PID_file();
6365                                                     }
6366                                                  
6367                                                     # ########################################################################
6368                                                     # Do the work.
6369                                                     # ########################################################################
6370           5                                 90      my $q         = new Quoter();
6371           5                                102      my $tp        = new TableParser( Quoter => $q );
6372           5                                 96      my $vp        = new VersionParser();
6373           5                                110      my $ms        = new MasterSlave();
6374           5                                 91      my $du        = new MySQLDump( cache => 0 );
6375           5                                 93      my $chunker   = new TableChunker( Quoter => $q, MySQLDump => $du );
6376           5                                 94      my $nibbler   = new TableNibbler( Quoter => $q, TableParser => $tp );
6377           5                                 96      my $checksum  = new TableChecksum( Quoter => $q, VersionParser => $vp );
6378           5                                 91      my $syncer    = new TableSyncer(
6379                                                        Quoter        => $q,
6380                                                        VersionParser => $vp,
6381                                                        MasterSlave   => $ms,
6382                                                        TableChecksum => $checksum,
6383                                                     );
6384           5                                 73      my %modules = (
6385                                                        OptionParser   => $o,
6386                                                        DSNParser      => $dp,
6387                                                        MySQLDump      => $du,
6388                                                        TableParser    => $tp,
6389                                                        Quoter         => $q,
6390                                                        VersionParser  => $vp,
6391                                                        TableChunker   => $chunker,
6392                                                        TableNibbler   => $nibbler,
6393                                                        TableChecksum  => $checksum,
6394                                                        MasterSlave    => $ms,
6395                                                        TableSyncer    => $syncer,
6396                                                     );
6397                                                  
6398                                                     # Create the sync plugins.
6399           5                                 25      my $plugins = [];
6400           5                                 32      foreach my $plugin_name ( split(',', $o->get('algorithms')) ) {
6401           5                                 28         $plugin_name = "TableSync$plugin_name";
6402           5                                 17         MKDEBUG && _d('Loading', $plugin_name);
6403           5                                 18         my $plugin;
6404           5                                 20         eval {
6405           5                                122            $plugin = $plugin_name->new(%modules);
6406                                                        };
6407  ***      5     50                          35         die "Cannot load $plugin_name for --algorithm: $EVAL_ERROR"
6408                                                           if $EVAL_ERROR;
6409           5                                 36         push @$plugins, $plugin;
6410                                                     }
6411                                                  
6412                                                     # Create callbacks for bidirectional syncing.  Currently, this only
6413                                                     # works with TableSyncChunk, so that should be the only plugin because
6414                                                     # --algorithms was overriden earlier.
6415  ***      5     50                          34      if ( $o->get('bidirectional') ) {
6416           5                                 84         set_bidirectional_callbacks(
6417                                                           plugin => $plugins->[0],
6418                                                           %modules,
6419                                                        );
6420                                                     }
6421                                                  
6422           5                                 26      my $hdr         = "# %6s %7s %6s %6s %-9s %-4s %s.%s\n";
6423           5                                 20      my $exit_status = 0; # 1: internal error, 2: tables differed, 3: both
6424                                                  
6425                                                     # dsn[0] is expected to be the master (i.e. the source).  So if
6426                                                     # --sync-to-master, then dsn[0] is a slave.  Find its master and
6427                                                     # make the master dsn[0] and the slave dsn[1].
6428  ***      5     50                          28      if ( $o->get('sync-to-master') ) {
6429  ***      0                                  0         MKDEBUG && _d('Getting master of', $dp->as_string($dsns[0]));
6430  ***      0                                  0         $dsns[0]->{dbh} = get_cxn($dsns[0], %modules);
6431  ***      0      0                           0         my $master = $ms->get_master_dsn($dsns[0]->{dbh}, $dsns[0], $dp)
6432                                                           or die "Can't determine master of " . $dp->as_string($dsns[0]);
6433  ***      0                                  0         unshift @dsns, $master;  # dsn[0]=master, dsn[1]=slave
6434  ***      0                                  0         $dsns[0]->{dbh} = get_cxn($dsns[0], %modules);
6435  ***      0      0                           0         if ( $o->get('check-master') ) {
6436  ***      0                                  0            $ms->is_master_of($dsns[0]->{dbh}, $dsns[1]->{dbh});
6437                                                        }
6438                                                     }
6439                                                  
6440           5                                102      my %args = (
6441                                                        dsns    => \@dsns,
6442                                                        plugins => $plugins,
6443                                                        hdr     => $hdr,
6444                                                        %modules,
6445                                                     );
6446                                                  
6447  ***      5     50                          34      if ( $o->get('dry-run') ) {
6448  ***      0                                  0         print "# NOTE: --dry-run does not show if data needs to be synced because it\n"
6449                                                           .  "#       does not access, compare or sync data.  --dry-run only shows\n"
6450                                                           .  "#       the work that would be done.\n";
6451                                                  
6452                                                     }
6453                                                  
6454  ***      5     50                          28      if ( $o->get('lock-and-rename') ) {
      ***            50                               
      ***            50                               
6455  ***      0                                  0         $exit_status = lock_and_rename(%args);
6456                                                     }
6457                                                     elsif ( $dsns[0]->{t} ) {
6458  ***      0                                  0         $exit_status = sync_one_table(%args);
6459                                                     }
6460                                                     elsif ( $o->get('replicate') ) {
6461  ***      0                                  0         $exit_status = sync_via_replication(%args);
6462                                                     }
6463                                                     else {
6464           5                                 68         $exit_status = sync_all(%args);
6465                                                     }
6466                                                  
6467           5                               3169      return $exit_status;
6468                                                  }
6469                                                  
6470                                                  # ############################################################################
6471                                                  # Subroutines
6472                                                  # ############################################################################
6473                                                  
6474                                                  sub lock_and_rename {
6475  ***      0                    0             0      my ( %args ) = @_;
6476  ***      0                                  0      my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
6477                                                                            VersionParser);
6478  ***      0                                  0      foreach my $arg ( @required_args ) {
6479  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6480                                                     }
6481  ***      0                                  0      my $dsns = $args{dsns};
6482  ***      0                                  0      my $o    = $args{OptionParser};
6483  ***      0                                  0      my $dp   = $args{DSNParser};
6484  ***      0                                  0      my $q    = $args{Quoter};
6485                                                  
6486  ***      0                                  0      MKDEBUG && _d('Locking and syncing ONE TABLE with rename');
6487  ***      0             0                    0      my $src = {
6488                                                        dsn      => $dsns->[0],
6489                                                        dbh      => $dsns->[0]->{dbh} || get_cxn($dsns->[0], %args),
6490                                                        misc_dbh => get_cxn($dsns->[0], %args),
6491                                                        db       => $dsns->[0]->{D},
6492                                                        tbl      => $dsns->[0]->{t},
6493                                                     };
6494  ***      0             0                    0      my $dst = {
6495                                                        dsn      => $dsns->[1],
6496                                                        dbh      => $dsns->[1]->{dbh} || get_cxn($dsns->[1], %args),
6497                                                        misc_dbh => get_cxn($dsns->[1], %args),
6498                                                        db       => $dsns->[1]->{D},
6499                                                        tbl      => $dsns->[1]->{t},
6500                                                     };
6501                                                  
6502  ***      0      0                           0      if ( $o->get('verbose') ) {
6503  ***      0                                  0         print "# Lock and rename ", $dp->as_string($src->{dsn}), "\n";
6504  ***      0                                  0         printf $args{hdr}, @ChangeHandler::ACTIONS,
6505                                                           qw(ALGORITHM EXIT DATABASE TABLE);
6506                                                     }
6507                                                  
6508                                                     # We don't use lock_server() here because it does the usual stuff wrt
6509                                                     # waiting for slaves to catch up to master, etc, etc.
6510  ***      0                                  0      my $src_db_tbl = $q->quote($src->{db}, $src->{tbl});
6511  ***      0                                  0      my $dst_db_tbl = $q->quote($dst->{db}, $dst->{tbl});
6512  ***      0                                  0      my $tmp_db_tbl = $q->quote($src->{db}, $src->{tbl} . "_tmp_$PID");
6513  ***      0                                  0      my $sql = "LOCK TABLES $src_db_tbl WRITE";
6514  ***      0                                  0      MKDEBUG && _d($sql);
6515  ***      0                                  0      $src->{dbh}->do($sql);
6516  ***      0                                  0      $sql = "LOCK TABLES $dst_db_tbl WRITE";
6517  ***      0                                  0      MKDEBUG && _d($sql);
6518  ***      0                                  0      $dst->{dbh}->do($sql);
6519                                                  
6520  ***      0                                  0      my $exit_status = sync_a_table(
6521                                                        src  => $src,
6522                                                        dst  => $dst,
6523                                                        %args,
6524                                                     );
6525                                                  
6526                                                     # Now rename the tables to swap them.
6527  ***      0                                  0      $sql = "ALTER TABLE $src_db_tbl RENAME $tmp_db_tbl";
6528  ***      0                                  0      MKDEBUG && _d($sql);
6529  ***      0                                  0      $src->{dbh}->do($sql);
6530  ***      0                                  0      $sql = "ALTER TABLE $dst_db_tbl RENAME $src_db_tbl";
6531  ***      0                                  0      MKDEBUG && _d($sql);
6532  ***      0                                  0      $dst->{dbh}->do($sql);
6533  ***      0                                  0      $sql = "UNLOCK TABLES";
6534  ***      0                                  0      MKDEBUG && _d($sql);
6535  ***      0                                  0      $src->{dbh}->do($sql);
6536  ***      0                                  0      $sql = "ALTER TABLE $tmp_db_tbl RENAME $dst_db_tbl";
6537  ***      0                                  0      MKDEBUG && _d($sql);
6538  ***      0                                  0      $src->{dbh}->do($sql);
6539                                                  
6540  ***      0                                  0      unlock_server(src => $src, dst => $dst, %args);
6541                                                  
6542  ***      0                                  0      disconnect($src, $dst);
6543  ***      0                                  0      return $exit_status;
6544                                                  }
6545                                                  
6546                                                  sub sync_one_table {
6547  ***      0                    0             0      my ( %args ) = @_;
6548  ***      0                                  0      my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
6549                                                                            VersionParser);
6550  ***      0                                  0      foreach my $arg ( @required_args ) {
6551  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6552                                                     }
6553  ***      0                                  0      my @dsns = @{$args{dsns}};
      ***      0                                  0   
6554  ***      0                                  0      my $o    = $args{OptionParser};
6555  ***      0                                  0      my $dp   = $args{DSNParser};
6556                                                  
6557  ***      0                                  0      MKDEBUG && _d('DSN has t part; syncing ONE TABLE between servers');
6558  ***      0             0                    0      my $src = {
6559                                                        dsn      => $dsns[0],
6560                                                        dbh      => $dsns[0]->{dbh} || get_cxn($dsns[0], %args),
6561                                                        misc_dbh => get_cxn($dsns[0], %args),
6562                                                        db       => $dsns[0]->{D},
6563                                                        tbl      => $dsns[0]->{t},
6564                                                     };
6565                                                  
6566  ***      0                                  0      my $exit_status = 0;
6567  ***      0                                  0      foreach my $dsn ( @dsns[1 .. $#dsns] ) {
6568  ***      0             0                    0         my $dst = {
      ***                    0                        
      ***                    0                        
6569                                                           dsn      => $dsn,
6570                                                           dbh      => $dsn->{dbh} || get_cxn($dsn, %args),
6571                                                           misc_dbh => get_cxn($dsn, %args),
6572                                                           db       => $dsn->{D} || $src->{db},
6573                                                           tbl      => $dsn->{t} || $src->{tbl},
6574                                                        };
6575                                                  
6576  ***      0      0                           0         if ( $o->get('verbose') ) {
6577  ***      0      0                           0            print "# Syncing ", $dp->as_string($dsn),
6578                                                              ($o->get('dry-run') ? ' in dry-run mode, without accessing or '
6579                                                                 . 'comparing data' : '') , "\n";
6580  ***      0                                  0            printf $args{hdr}, @ChangeHandler::ACTIONS,
6581                                                              qw(ALGORITHM EXIT DATABASE TABLE);
6582                                                        }
6583                                                  
6584  ***      0                                  0         lock_server(src => $src, dst => $dst, %args);
6585                                                  
6586  ***      0                                  0         $exit_status |= sync_a_table(
6587                                                           src   => $src,
6588                                                           dst   => $dst,
6589                                                           %args,
6590                                                        );
6591                                                  
6592  ***      0                                  0         unlock_server(src => $src, dst => $dst, %args);
6593  ***      0                                  0         disconnect($dst);
6594                                                     }
6595                                                  
6596  ***      0                                  0      disconnect($src);
6597  ***      0                                  0      return $exit_status;
6598                                                  }
6599                                                  
6600                                                  sub sync_via_replication {
6601  ***      0                    0             0      my ( %args ) = @_;
6602  ***      0                                  0      my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
6603                                                                            VersionParser TableChecksum MasterSlave);
6604  ***      0                                  0      foreach my $arg ( @required_args ) {
6605  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6606                                                     }
6607  ***      0                                  0      my $dsns     = $args{dsns};
6608  ***      0                                  0      my $o        = $args{OptionParser};
6609  ***      0                                  0      my $dp       = $args{DSNParser};
6610  ***      0                                  0      my $q        = $args{Quoter};
6611  ***      0                                  0      my $checksum = $args{TableChecksum};
6612  ***      0                                  0      my $ms       = $args{MasterSlave};
6613                                                  
6614  ***      0                                  0      MKDEBUG && _d('Syncing via replication');
6615  ***      0             0                    0      my $src = {
6616                                                        dsn      => $dsns->[0],
6617                                                        dbh      => $dsns->[0]->{dbh} || get_cxn($dsns->[0], %args),
6618                                                        misc_dbh => get_cxn($dsns->[0], %args),
6619                                                        db       => undef,  # set later
6620                                                        tbl      => undef,  # set later
6621                                                     };
6622                                                  
6623                                                     # Filters for --databases and --tables.  We have to do these manually
6624                                                     # since we don't use MySQLFind for --replicate.
6625  ***      0                                  0      my $databases = $o->get('databases');
6626  ***      0                                  0      my $tables    = $o->get('tables');
6627                                                  
6628  ***      0                                  0      my $exit_status = 0;
6629                                                  
6630                                                     # Connect to the master and treat it as the source, then find
6631                                                     # differences on the slave and sync them.
6632  ***      0      0                           0      if ( $o->get('sync-to-master') ) {
6633  ***      0             0                    0         my $dst = {
6634                                                           dsn      => $dsns->[1],
6635                                                           dbh      => $dsns->[1]->{dbh} || get_cxn($dsns->[1], %args),
6636                                                           misc_dbh => get_cxn($dsns->[1], %args),
6637                                                           db       => undef,  # set later
6638                                                           tbl      => undef,  # set later
6639                                                        };
6640                                                  
6641                                                        # First, check that the master (source) has no discrepancies itself,
6642                                                        # and ignore tables that do.
6643  ***      0                                  0         my %skip_table;
6644  ***      0                                  0         map { $skip_table{$_->{db}}->{$_->{tbl}}++ }
      ***      0                                  0   
6645                                                           $checksum->find_replication_differences(
6646                                                              $src->{dbh}, $o->get('replicate'));
6647                                                  
6648                                                        # Now check the slave for differences and sync them if necessary.
6649  ***      0                                  0         my @diffs =  filter_diffs(
6650                                                           \%skip_table,
6651                                                           $databases,
6652                                                           $tables,
6653                                                           $checksum->find_replication_differences(
6654                                                              $dst->{dbh}, $o->get('replicate'))
6655                                                        );
6656                                                  
6657  ***      0      0                           0         if ( $o->get('verbose') ) {
6658  ***      0      0                           0            print "# Syncing via replication ", $dp->as_string($dst->{dsn}),
6659                                                              ($o->get('dry-run') ? ' in dry-run mode, without accessing or '
6660                                                                 . 'comparing data' : '') , "\n";
6661  ***      0                                  0            printf $args{hdr}, @ChangeHandler::ACTIONS,
6662                                                              qw(ALGORITHM EXIT DATABASE TABLE);
6663                                                        }
6664                                                  
6665  ***      0      0                           0         if ( @diffs ) {
6666  ***      0                                  0            lock_server(src => $src, dst => $dst, %args);
6667                                                  
6668  ***      0                                  0            foreach my $diff ( @diffs ) {
6669  ***      0                                  0               $src->{db}  = $dst->{db}  = $diff->{db};
6670  ***      0                                  0               $src->{tbl} = $dst->{tbl} = $diff->{tbl};
6671                                                  
6672  ***      0                                  0               $exit_status |= sync_a_table(
6673                                                                 src   => $src,
6674                                                                 dst   => $dst,
6675                                                                 where => $diff->{boundaries},
6676                                                                 %args,
6677                                                              );
6678                                                           }
6679                                                  
6680  ***      0                                  0            unlock_server(src => $src, dst => $dst, %args);
6681                                                        }
6682                                                        else {
6683  ***      0                                  0            MKDEBUG && _d('No checksum differences');
6684                                                        }
6685                                                  
6686  ***      0                                  0         disconnect($dst);
6687                                                     } # sync-to-master
6688                                                  
6689                                                     # The DSN is the master.  Connect to each slave, find differences,
6690                                                     # then sync them.
6691                                                     else {
6692  ***      0                                  0         my %skip_table;
6693                                                        $ms->recurse_to_slaves(
6694                                                           {  dbh        => $src->{dbh},
6695                                                              dsn        => $src->{dsn},
6696                                                              dsn_parser => $dp,
6697                                                              recurse    => 1,
6698                                                              callback   => sub {
6699  ***      0                    0             0                  my ( $dsn, $dbh, $level, $parent ) = @_;
6700  ***      0                                  0                  my @diffs = $checksum
6701                                                                    ->find_replication_differences($dbh, $o->get('replicate'));
6702  ***      0      0                           0                  if ( !$level ) {
6703                                                                    # This is the master; don't sync any tables that are wrong
6704                                                                    # here, for obvious reasons.
6705  ***      0                                  0                     map { $skip_table{$_->{db}}->{$_->{tbl}}++ } @diffs;
      ***      0                                  0   
6706                                                                 }
6707                                                                 else {
6708                                                                    # This is a slave.
6709  ***      0                                  0                     @diffs = filter_diffs(
6710                                                                       \%skip_table,
6711                                                                       $databases,
6712                                                                       $tables,
6713                                                                       @diffs
6714                                                                    );
6715                                                  
6716  ***      0      0                           0                     if ( $o->get('verbose') ) {
6717  ***      0      0                           0                        print "# Syncing via replication ", $dp->as_string($dsn),
6718                                                                          ($o->get('dry-run') ? ' in dry-run mode, without '
6719                                                                             . 'accessing or comparing data' : '') , "\n";
6720  ***      0                                  0                        printf $args{hdr}, @ChangeHandler::ACTIONS,
6721                                                                          qw(ALGORITHM EXIT DATABASE TABLE);
6722                                                                    }
6723                                                  
6724  ***      0      0                           0                     if ( @diffs ) {
6725  ***      0                                  0                        my $dst = {
6726                                                                          dsn      => $dsn,
6727                                                                          dbh      => $dbh,
6728                                                                          misc_dbh => get_cxn($dsn, %args),
6729                                                                          db       => undef,  # set later
6730                                                                          tbl      => undef,  # set later
6731                                                                       };
6732                                                  
6733  ***      0                                  0                        lock_server(src => $src, dst => $dst, %args);
6734                                                  
6735  ***      0                                  0                        foreach my $diff ( @diffs ) {
6736  ***      0                                  0                           $src->{db}  = $dst->{db}  = $diff->{db};
6737  ***      0                                  0                           $src->{tbl} = $dst->{tbl} = $diff->{tbl};
6738                                                  
6739  ***      0                                  0                           $exit_status |= sync_a_table(
6740                                                                             src   => $src,
6741                                                                             dst   => $dst,
6742                                                                             where => $diff->{boundaries},
6743                                                                             %args,
6744                                                                          );
6745                                                                       } 
6746                                                  
6747  ***      0                                  0                        unlock_server(src => $src, dst => $dst, %args);
6748  ***      0                                  0                        disconnect($dst);
6749                                                                    }
6750                                                                    else {
6751  ***      0                                  0                        MKDEBUG && _d('No checksum differences');
6752                                                                    }
6753                                                                 }  # this is a slave
6754                                                  
6755  ***      0                                  0                  return;
6756                                                              },  # recurse_to_slaves() callback
6757  ***      0                                  0               method => $o->get('recursion-method'),
6758                                                           },
6759                                                        );
6760                                                     } # DSN is master
6761                                                  
6762  ***      0                                  0      disconnect($src);
6763  ***      0                                  0      return $exit_status;
6764                                                  }
6765                                                  
6766                                                  sub sync_all {
6767           5                    5            71      my ( %args ) = @_;
6768           5                                 69      my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
6769                                                                            VersionParser TableParser MySQLDump);
6770           5                                 35      foreach my $arg ( @required_args ) {
6771  ***     45     50                         307         die "I need a $arg argument" unless $args{$arg};
6772                                                     }
6773           5                                 23      my @dsns = @{$args{dsns}};
               5                                 42   
6774           5                                 25      my $o    = $args{OptionParser};
6775           5                                 24      my $dp   = $args{DSNParser};
6776                                                  
6777           5                                 18      MKDEBUG && _d('Syncing all dbs and tbls');
6778  ***      5            33                  131      my $src = {
6779                                                        dsn      => $dsns[0],
6780                                                        dbh      => $dsns[0]->{dbh} || get_cxn($dsns[0], %args),
6781                                                        misc_dbh => get_cxn($dsns[0], %args),
6782                                                        db       => undef,  # set later
6783                                                        tbl      => undef,  # set later
6784                                                     };
6785                                                  
6786           5                                158      my $si = new SchemaIterator(
6787                                                        Quoter => $args{Quoter},
6788                                                     );
6789           5                                 60      $si->set_filter($si->make_filter($o));
6790                                                  
6791                                                     # Make a list of all dbs.tbls on the source.  It's more efficient this
6792                                                     # way because it avoids open/closing a dbh for each tbl and dsn, unless
6793                                                     # we pre-opened the dsn.  It would also cause confusing verbose output.
6794           5                                 27      my @dbs_tbls;
6795           5                                 54      my $next_db = $si->get_db_itr(dbh => $src->{dbh});
6796           5                                 31      while ( my $db = $next_db->() ) {
6797           5                                 21         MKDEBUG && _d('Getting tables from', $db);
6798           5                                 50         my $next_tbl = $si->get_tbl_itr(
6799                                                           dbh   => $src->{dbh},
6800                                                           db    => $db,
6801                                                           views => 0,
6802                                                        );
6803           5                                 33         while ( my $tbl = $next_tbl->() ) {
6804           5                                 16            MKDEBUG && _d('Got table', $tbl);
6805           5                                 56            push @dbs_tbls, { db => $db, tbl => $tbl };
6806                                                        }
6807                                                     }
6808                                                  
6809           5                                 19      my $exit_status = 0;
6810           5                                 69      foreach my $dsn ( @dsns[1 .. $#dsns] ) {
6811  ***      7     50                          68         if ( $o->get('verbose') ) {
6812  ***      0      0                           0            print "# Syncing ", $dp->as_string($dsn),
6813                                                              ($o->get('dry-run') ? ' in dry-run mode, without accessing or '
6814                                                                 . 'comparing data' : '') , "\n";
6815  ***      0                                  0            printf $args{hdr}, @ChangeHandler::ACTIONS,
6816                                                              qw(ALGORITHM EXIT DATABASE TABLE);
6817                                                        }
6818                                                  
6819  ***      7            33                  178         my $dst = {
6820                                                           dsn      => $dsn,
6821                                                           dbh      => $dsn->{dbh} || get_cxn($dsn, %args),
6822                                                           misc_dbh => get_cxn($dsn, %args),
6823                                                           db       => undef,  # set later
6824                                                           tbl      => undef,  # set later
6825                                                        };
6826                                                  
6827           7                                145         lock_server(src => $src, dst => $dst, %args);
6828                                                  
6829           7                                 64         foreach my $db_tbl ( @dbs_tbls ) {
6830           7                                 61            $src->{db}  = $dst->{db}  = $db_tbl->{db};
6831           7                                 59            $src->{tbl} = $dst->{tbl} = $db_tbl->{tbl};
6832                                                  
6833           7                                 96            $exit_status |= sync_a_table(
6834                                                              src => $src,
6835                                                              dst => $dst,
6836                                                              %args,
6837                                                           );
6838                                                        }
6839                                                  
6840           7                                104         unlock_server(src => $src, dst => $dst, %args);
6841           7                                 81         disconnect($dst);
6842                                                     }
6843                                                  
6844           5                                 46      disconnect($src);
6845           5                                826      return $exit_status;
6846                                                  }
6847                                                  
6848                                                  sub lock_server {
6849           7                    7           152      my ( %args ) = @_;
6850           7                                 79      foreach my $arg ( qw(src dst OptionParser DSNParser TableSyncer) ) {
6851  ***     35     50                         261         die "I need a $arg argument" unless $args{$arg};
6852                                                     }
6853           7                                 43      my $o = $args{OptionParser};
6854                                                  
6855  ***      7     50     33                   57      return unless $o->get('lock') && $o->get('lock') == 3;
6856                                                  
6857  ***      0                                  0      eval {
6858  ***      0                                  0         $args{TableSyncer}->lock_and_wait(
6859                                                           %args,
6860                                                           lock         => 3,
6861                                                           lock_level   => 3,
6862                                                           replicate    => $o->get('replicate'),
6863                                                           timeout_ok   => $o->get('timeout-ok'),
6864                                                           transaction  => $o->get('transaction'),
6865                                                           wait         => $o->get('wait'),
6866                                                        );
6867                                                     };
6868  ***      0      0                           0      if ( $EVAL_ERROR ) {
6869  ***      0                                  0         die "Failed to lock server: $EVAL_ERROR";
6870                                                     }
6871  ***      0                                  0      return;
6872                                                  }
6873                                                  
6874                                                  sub unlock_server {
6875           7                    7           116      my ( %args ) = @_;
6876           7                                 80      my @required_args = qw(src dst OptionParser DSNParser TableSyncer);
6877           7                                 37      foreach my $arg ( @required_args ) {
6878  ***     35     50                         232         die "I need a $arg argument" unless $args{$arg};
6879                                                     }
6880           7                                 51      my ($src, $dst, $o) = @args{@required_args};
6881                                                  
6882  ***      7     50     33                   44      return unless $o->get('lock') && $o->get('lock') == 3;
6883                                                  
6884  ***      0                                  0      eval {
6885                                                        # Open connections as needed.
6886  ***      0             0                    0         $src->{dbh}      ||= get_cxn($src->{dsn}, %args);
6887  ***      0             0                    0         $dst->{dbh}      ||= get_cxn($dst->{dsn}, %args);
6888  ***      0             0                    0         $src->{misc_dbh} ||= get_cxn($src->{dsn}, %args);
6889  ***      0             0                    0         $args{TableSyncer}->unlock(
      ***                    0                        
      ***                    0                        
      ***                    0                        
6890                                                           src_dbh      => $src->{dbh},
6891                                                           src_db       => '',
6892                                                           src_tbl      => '',
6893                                                           dst_dbh      => $dst->{dbh},
6894                                                           dst_db       => '',
6895                                                           dst_tbl      => '',
6896                                                           misc_dbh     => $src->{misc_dbh},
6897                                                           replicate    => $o->get('replicate')   || 0,
6898                                                           timeout_ok   => $o->get('timeout-ok')  || 0,
6899                                                           transaction  => $o->get('transaction') || 0,
6900                                                           wait         => $o->get('wait')        || 0,
6901                                                           lock         => 3,
6902                                                           lock_level   => 3,
6903                                                        );
6904                                                     };
6905  ***      0      0                           0      if ( $EVAL_ERROR ) {
6906  ***      0                                  0         die "Failed to unlock server: $EVAL_ERROR";
6907                                                     }
6908  ***      0                                  0      return;
6909                                                  }
6910                                                  
6911                                                  # This is the primary subroutine which actually makes the table syncs
6912                                                  # happen by calling $syncer->sync_table().  It is, therefore, a big
6913                                                  # wrapper around $syncer->sync_table(); it does pre- and post-sync
6914                                                  # stuff.  It returns an exit status; see EXIT STATUS in the POD.
6915                                                  sub sync_a_table {
6916           7                    7           109      my ( %args ) = @_;
6917           7                                 87      my @required_args = qw(src dst plugins OptionParser Quoter TableParser
6918                                                                            MySQLDump TableSyncer);
6919           7                                 37      foreach my $arg ( @required_args ) {
6920  ***     56     50                         356         die "I need a $arg argument" unless $args{$arg};
6921                                                     }
6922           7                                 72      my ($src, $dst, undef, $o, $q, $tp, $du, $syncer) = @args{@required_args};
6923                                                  
6924           7                                 25      my $exit_status = 0; 
6925           7                                 28      my %status;
6926           7                                 30      eval {
6927                                                        # This will either die if there's a problem or return the tbl struct.
6928           7                                 90         my $tbl_struct = ok_to_sync($src, $dst, %args);
6929                                                  
6930                                                        # If the table is InnoDB, prefer to sync it with transactions, unless
6931                                                        # the user explicitly said not to.
6932  ***      7     50                          84         my $use_txn = $o->got('transaction')            ? $o->get('transaction')
      ***            50                               
6933                                                                    : $tbl_struct->{engine} eq 'InnoDB' ? 1
6934                                                                    :                                     0;
6935                                                  
6936                                                        # Turn off AutoCommit if we're using transactions.
6937           7                                 76         $src->{dbh}->{AutoCommit}      = !$use_txn;
6938           7                                 48         $src->{misc_dbh}->{AutoCommit} = !$use_txn;
6939           7                                 43         $dst->{dbh}->{AutoCommit}      = !$use_txn;
6940           7                                 44         $dst->{misc_dbh}->{AutoCommit} = !$use_txn;
6941                                                  
6942                                                        # Determine which columns to compare.
6943           7                                 74         my $ignore_columns  = $o->get('ignore-columns');
6944          28                                192         my @compare_columns = grep {
6945  ***      7     50                          42            !$ignore_columns->{lc $_};
6946           7                                 32         } @{$o->get('columns') || $tbl_struct->{cols}};
6947                                                  
6948                                                        # Make sure conflict col is in compare cols else conflicting
6949                                                        # rows won't have the col for --conflict-comparison.
6950  ***      7     50                          54         if ( my $conflict_col = $o->get('conflict-column') ) {
6951          28                                149            push @compare_columns, $conflict_col
6952  ***      7     50                          36               unless grep { $_ eq $conflict_col } @compare_columns;
6953                                                        }
6954                                                  
6955                                                        # --print --verbose --verbose is the magic formula for having
6956                                                        # all src/dst sql printed so we can see the chunk/row sql.
6957           7                                 31         my $callback;
6958  ***      7     50     33                   45         if ( $o->get('print') && $o->get('verbose') >= 2 ) {
6959  ***      0                                  0            $callback = \&print_sql;
6960                                                        }
6961                                                  
6962                                                        # get_change_dbh() may die if, for example, the destination is
6963                                                        # not a slave.  Perhaps its work should be part of can_sync()?
6964           7                                122         my $change_dbh = get_change_dbh(tbl_struct => $tbl_struct, %args);
6965           7                                 99         my $actions    = make_action_subs(change_dbh => $change_dbh, %args);
6966                                                  
6967           7                                141         my $rd = new RowDiff(dbh => $src->{misc_dbh});
6968  ***      7     50     33                   90         my $ch = new ChangeHandler(
      ***                   33                        
      ***                   50                        
6969                                                           left_db    => $src->{db},
6970                                                           left_tbl   => $src->{tbl},
6971                                                           right_db   => $dst->{db},
6972                                                           right_tbl  => $dst->{tbl}, 
6973                                                           tbl_struct => $tbl_struct,
6974                                                           queue      => $o->get('buffer-to-client') ? 1 : 0,
6975                                                           replace    => $o->get('replace')
6976                                                                         || $o->get('replicate')
6977                                                                         || $o->get('sync-to-master')
6978                                                                         || 0,
6979                                                           actions    => $actions,
6980                                                           Quoter     => $args{Quoter},
6981                                                        );
6982                                                  
6983  ***      7            33                  101         %status = $syncer->sync_table(
      ***                   33                        
      ***                   33                        
      ***                   50                        
6984                                                           %args,
6985                                                           tbl_struct        => $tbl_struct,
6986                                                           cols              => \@compare_columns,
6987                                                           chunk_size        => $o->get('chunk-size'),
6988                                                           RowDiff           => $rd,
6989                                                           ChangeHandler     => $ch,
6990                                                           transaction       => $use_txn,
6991                                                           callback          => $callback,
6992                                                           where             => $args{where} || $o->get('where'),
6993                                                           bidirectional     => $o->get('bidirectional'),
6994                                                           buffer_in_mysql   => $o->get('buffer-in-mysql'),
6995                                                           buffer_to_client  => $o->get('buffer-to-client'),
6996                                                           changing_src      => $o->get('replicate')
6997                                                                                || $o->get('sync-to-master')
6998                                                                                || $o->get('bidirectional')
6999                                                                                || 0,
7000                                                           float_precision   => $o->get('float-precision'),
7001                                                           index_hint        => $o->get('index-hint'),
7002                                                           chunk_index       => $o->get('chunk-index'),
7003                                                           chunk_col         => $o->get('chunk-column'),
7004                                                           lock              => $o->get('lock'),
7005                                                           replace           => $o->get('replace'),
7006                                                           replicate         => $o->get('replicate'),
7007                                                           dry_run           => $o->get('dry-run'),
7008                                                           timeout_ok        => $o->get('timeout-ok'),
7009                                                           trim              => $o->get('trim'),
7010                                                           wait              => $o->get('wait'),
7011                                                           function          => $o->get('function'),
7012                                                        );
7013                                                  
7014           6    100                         151         if ( sum(@status{@ChangeHandler::ACTIONS}) ) {
7015           5                                 52            $exit_status |= 2;
7016                                                        }
7017                                                     };
7018                                                  
7019           7    100                          64      if ( $EVAL_ERROR ) {
7020           1                                 19         print_err($EVAL_ERROR, $dst->{db}, $dst->{tbl}, $dst->{dsn}->{h});
7021           1                                  6         $exit_status |= 1;
7022                                                     }
7023                                                  
7024                                                     # Print this last so that the exit status is its final result.
7025  ***      7     50                          98      if ( $o->get('verbose') ) {
7026  ***      0      0                           0         printf($args{hdr},
7027  ***      0                                  0            map { $_ || '0' } @status{@ChangeHandler::ACTIONS, 'ALGORITHM'},
7028                                                           $exit_status, $src->{db}, $src->{tbl});
7029                                                     }
7030                                                  
7031           7                                131      return $exit_status;
7032                                                  }
7033                                                  
7034                                                  sub get_change_dbh {
7035           7                    7           141      my ( %args ) = @_;
7036           7                                 82      my @required_args = qw(src dst tbl_struct OptionParser DSNParser
7037                                                                            MasterSlave);
7038           7                                 52      foreach my $arg ( @required_args ) {
7039  ***     42     50                         272         die "I need a $arg argument" unless $args{$arg};
7040                                                     }
7041           7                                 64      my ($src, $dst, $tbl_struct, $o, $dp, $ms) = @args{@required_args};
7042                                                  
7043           7                                 33      my $change_dbh = $dst->{dbh};  # The default case: making changes on dst.
7044                                                  
7045  ***      7     50     33                   40      if ( $o->get('sync-to-master') || $o->get('replicate') ) {
      ***            50                               
7046                                                        # Is it possible to make changes on the master (i.e. the source)?
7047                                                        # Only if REPLACE will work.
7048  ***      0                                  0         my $can_replace = grep { $_->{is_unique} } values %{$tbl_struct->{keys}};
      ***      0                                  0   
      ***      0                                  0   
7049  ***      0                                  0         MKDEBUG && _d("This table's replace-ability:", $can_replace);
7050  ***      0      0                           0         die "Can't make changes on the master because no unique index exists"
7051                                                           unless $can_replace;
7052  ***      0                                  0         $change_dbh = $src->{dbh};  # The alternate case.
7053  ***      0                                  0         MKDEBUG && _d('Will make changes on source', $change_dbh);
7054                                                     }
7055                                                     elsif ( $o->get('check-slave') ) {
7056                                                        # Is it safe to change data on the destination?  Only if it's *not*
7057                                                        # a slave.  We don't change tables on slaves directly.  If we are
7058                                                        # forced to change data on a slave, we require either that 1) binary
7059                                                        # logging is disabled, or 2) the check is bypassed.  By the way, just
7060                                                        # because the server is a slave doesn't mean it's not also the master
7061                                                        # of the master (master-master replication).
7062           7                                 95         my $slave_status = $ms->get_slave_status($dst->{dbh});
7063           7                                 22         my (undef, $log_bin) = $dst->{dbh}->selectrow_array(
7064                                                           'SHOW VARIABLES LIKE "log_bin"');
7065           7                                 22         my ($sql_log_bin) = $dst->{dbh}->selectrow_array(
7066                                                           'SELECT @@SQL_LOG_BIN');
7067           7                               1209         MKDEBUG && _d('Variables on destination:',
7068                                                           'log_bin=', (defined $log_bin ? $log_bin : 'NULL'),
7069                                                           ' @@SQL_LOG_BIN=', (defined $sql_log_bin ? $sql_log_bin : 'NULL'));
7070  ***      7     50     33                   77         if ( $slave_status && $sql_log_bin && ($log_bin || 'OFF') eq 'ON' ) {
      ***                    0                        
      ***                   33                        
7071  ***      0                                  0            die "Can't make changes on ", $dp->as_string($dst->{dsn}),
7072                                                              " because it's a slave.  See the documentation section",
7073                                                              " 'REPLICATION SAFETY' for solutions to this problem.";
7074                                                        }
7075           7                                 31         MKDEBUG && _d('Will make changes on destination', $change_dbh);
7076                                                     }
7077                                                  
7078           7                                 91      return $change_dbh;
7079                                                  }
7080                                                  
7081                                                  sub make_action_subs {
7082           7                    7           120      my ( %args ) = @_;
7083           7                                 78      my @required_args = qw(change_dbh OptionParser);
7084           7                                 51      foreach my $arg ( @required_args ) {
7085  ***     14     50                         115         die "I need a $arg argument" unless $args{$arg};
7086                                                     }
7087           7                                 49      my ($change_dbh, $o) = @args{@required_args};
7088                                                  
7089           7                                 24      my @actions;
7090  ***      7     50                          52      if ( $o->get('execute') ) {
7091                                                        push @actions, sub {
7092  ***     36            33     36           222            my ( $sql, $dbh ) = @_;
7093                                                           # Use $dbh if given.  It's from a bidirectional callback.
7094  ***     36            33                  223            $dbh ||= $change_dbh;
7095          36                                107            MKDEBUG && _d('Execute on dbh', $dbh, $sql);
7096          36                              11204            $dbh->do($sql);
7097           7                                 98         };
7098                                                     }
7099  ***      7     50                          49      if ( $o->get('print') ) {
7100                                                        # Print AFTER executing, so the print isn't misleading in case of an
7101                                                        # index violation etc that doesn't actually get executed.
7102                                                        push @actions, sub { 
7103          36                   36           307            my ( $sql, $dbh ) = @_;
7104                                                           # Append /*host:port*/ to the sql, if possible, so the user
7105                                                           # can see on which host it was/would be ran.
7106  ***     36     50                         392            my $dsn = $dsn_for{$dbh} if $dbh;
7107  ***     36     50                         205            if ( $dsn ) {
7108  ***     36            33                  354               my $h = $dsn->{h} || $dsn->{S} || '';
      ***                   50                        
7109  ***     36            50                  252               my $p = $dsn->{P} || '';
7110  ***     36     50                         374               $sql  = "/*$h" . ($p ? ":$p" : '') . "*/ $sql";
7111                                                           }
7112  ***     36     50                         520            print($sql, ";\n") or die "Cannot print: $OS_ERROR";
7113           7                                110         };
7114                                                     }
7115                                                  
7116           7                                 69      return \@actions;
7117                                                  }
7118                                                  
7119                                                  # Tries to extract the MySQL error message and print it
7120                                                  sub print_err {
7121           1                    1            34      my ( $msg, $database, $table, $host ) = @_;
7122  ***      1     50                          12      return if !defined $msg;
7123           1                                 14      $msg =~ s/^.*?failed: (.*?) at \S+ line (\d+).*$/$1 at line $2/s;
7124           1                                 18      $msg =~ s/\s+/ /g;
7125  ***      1     50     33                   21      if ( $database && $table ) {
7126           1                                 10         $msg .= " while doing $database.$table";
7127                                                     }
7128  ***      1     50                           8      if ( $host ) {
7129           1                                  6         $msg .= " on $host";
7130                                                     }
7131           1                                 13      print STDERR $msg, "\n";
7132                                                  }
7133                                                  
7134                                                  sub get_cxn {
7135          24                   24           430      my ( $dsn, %args ) = @_;
7136          24                                231      my @required_args = qw(OptionParser DSNParser);
7137          24                                142      foreach my $arg ( @required_args ) {
7138  ***     48     50                         359         die "I need a $arg argument" unless $args{$arg};
7139                                                     }
7140          24                                162      my ($o, $dp) = @args{@required_args};
7141                                                  
7142  ***     24     50     33                  292      if ( !$dsn->{p} && $o->get('ask-pass') ) {
7143  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password for $dsn->{h}: ");
7144                                                     }
7145          24                                206      my $dbh = $dp->get_dbh(
7146                                                        $dp->get_cxn_params($dsn, {})  # get_cxn_params needs the 2nd arg
7147                                                     );
7148                                                  
7149          24                                110      my $sql;
7150  ***     24     50                         185      if ( !$o->get('bin-log') ) {
7151  ***      0                                  0         $sql = "/*!32316 SET SQL_LOG_BIN=0 */";
7152  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
7153  ***      0                                  0         $dbh->do($sql);
7154                                                     }
7155  ***     24     50                         150      if ( !$o->get('unique-checks') ) {
7156  ***      0                                  0         $sql = "/*!40014 SET UNIQUE_CHECKS=0 */";
7157  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
7158  ***      0                                  0         $dbh->do($sql);
7159                                                     }
7160  ***     24     50                         149      if ( !$o->get('foreign-key-checks') ) {
7161  ***      0                                  0         $sql = "/*!40014 SET FOREIGN_KEY_CHECKS=0 */";
7162  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
7163  ***      0                                  0         $dbh->do($sql);
7164                                                     }
7165                                                     # Disable auto-increment on zero (bug #1919897).
7166          24                                111      $sql = '/*!40101 SET @@SQL_MODE := CONCAT(@@SQL_MODE, '
7167                                                          . '",NO_AUTO_VALUE_ON_ZERO")*/';
7168          24                                 72      MKDEBUG && _d($dbh, $sql);
7169          24                               3793      $dbh->do($sql);
7170                                                  
7171          24                                247      $dsn_for{$dbh} = $dsn;
7172                                                  
7173          24                                 81      MKDEBUG && _d('Opened dbh', $dbh);
7174          24                                585      return $dbh;
7175                                                  }
7176                                                  
7177                                                  sub ok_to_sync {
7178           7                    7           174      my ( %args ) = @_;
7179           7                                 92      my @required_args = qw(src dst DSNParser Quoter VersionParser TableParser
7180                                                                            MySQLDump TableSyncer OptionParser);
7181           7                                 50      foreach my $arg ( @required_args ) {
7182  ***     63     50                         452         die "I need a $arg argument" unless $args{$arg};
7183                                                     }
7184           7                                 73      my ($src, $dst, $dp, $q, $vp, $tp, $du, $syncer, $o) = @args{@required_args};
7185                                                  
7186                                                     # First things first: check that the src and dst dbs and tbls exist.
7187                                                     # This can fail in cases like h=host,D=bad,t=also_bad (i.e. simple
7188                                                     # user error).  It can also fail when syncing all dbs/tbls with sync_all()
7189                                                     # because the dst db/tbl is assumed to be the same as the src but
7190                                                     # this isn't always the case.
7191           7                                 24      my $src_tbl_ddl;
7192           7                                 26      eval {
7193                                                        # FYI: get_create_table() does USE db but doesn't eval it.
7194           7                               4219         $src->{dbh}->do("USE `$src->{db}`");
7195           7                                138         $src_tbl_ddl = $du->get_create_table($src->{dbh}, $q,
7196                                                           $src->{db}, $src->{tbl});
7197                                                     };
7198  ***      7     50                          49      die $EVAL_ERROR if $EVAL_ERROR;
7199                                                  
7200           7                                 26      my $dst_tbl_ddl;
7201           7                                 28      eval {
7202                                                        # FYI: get_create_table() does USE db but doesn't eval it.
7203           7                               1086         $dst->{dbh}->do("USE `$dst->{db}`");
7204           7                                115         $dst_tbl_ddl = $du->get_create_table($dst->{dbh}, $q,
7205                                                           $dst->{db}, $dst->{tbl});
7206                                                     };
7207  ***      7     50                          54      die $EVAL_ERROR if $EVAL_ERROR;
7208                                                  
7209                                                     # This doesn't work at the moment when syncing different table names.
7210                                                     # Check that src.db.tbl has the exact same schema as dst.db.tbl.
7211                                                     # if ( $o->get('check-schema') && ($src_tbl_ddl ne $dst_tbl_ddl) ) {
7212                                                     #   die "Source and destination tables have different schemas";
7213                                                     # }
7214           7                                 81      my $tbl_struct = $tp->parse($src_tbl_ddl);
7215                                                  
7216                                                     # Check that the user has all the necessary privs on the tbls.
7217  ***      7     50                          86      if ( $o->get('check-privileges') ) {
7218           7                                 22         MKDEBUG && _d('Checking privileges');
7219  ***      7     50                         107         if ( !$syncer->have_all_privs($src->{dbh}, $src->{db}, $src->{tbl}) ) {
7220  ***      0                                  0            die "User does not have all necessary privileges on ",
7221                                                              $q->quote($src->{db}, $src->{tbl});
7222                                                        }
7223  ***      7     50                          91         if ( !$syncer->have_all_privs($dst->{dbh}, $dst->{db}, $dst->{tbl}) ) {
7224  ***      0                                  0            die "User does not have all necessary privileges on ",
7225                                                              $q->quote($dst->{db}, $dst->{tbl});
7226                                                        }
7227                                                     }
7228                                                  
7229                                                     # Check that no triggers are defined on the dst tbl.
7230  ***      7     50                          88      if ( $o->get('check-triggers') ) {
7231           7                                 25         MKDEBUG && _d('Checking for triggers');
7232  ***      7     50                          54         if ( !defined $dst->{supports_triggers} ) {
7233           7                                 77            $dst->{supports_triggers} = $vp->version_ge($dst->{dbh}, '5.0.2');
7234                                                        }
7235  ***      7     50     33                  174         if ( $dst->{supports_triggers}
7236                                                             && $du->get_triggers($dst->{dbh}, $q, $dst->{db}, $dst->{tbl}) ) {
7237  ***      0                                  0            die "Triggers are defined on the table";
7238                                                        }
7239                                                        else {
7240           7                                 27            MKDEBUG && _d('Destination does not support triggers',
7241                                                              $dp->as_string($dst->{dsn}));
7242                                                        }
7243                                                     }
7244                                                  
7245           7                                143      return $tbl_struct;
7246                                                  }
7247                                                  
7248                                                  sub filter_diffs {
7249  ***      0                    0             0      my ( $skip_table, $databases, $tables, @diffs ) = @_;
7250  ***      0      0      0                    0      return grep {
      ***                    0                        
      ***                    0                        
      ***                    0                        
7251  ***      0                                  0         !$skip_table->{$_->{db}}->{$_->{tbl}}
7252                                                        && (!$databases || $databases->{$_->{db}})
7253                                                        && (!$tables || ($tables->{$_->{tbl}} || $tables->{"$_->{db}.$_->{tbl}"}))
7254                                                     } @diffs;
7255                                                  }
7256                                                  
7257                                                  sub disconnect {
7258          12                   12            86      my ( @hosts ) = @_;
7259          12                                 77      foreach my $host ( @hosts ) {
7260          12                                 64         foreach my $thing ( qw(dbh misc_dbh) ) {
7261          24                                177            my $dbh = $host->{$thing};
7262  ***     24     50                         168            next unless $dbh;
7263          24                                255            delete $dsn_for{$dbh};
7264  ***     24     50                         355            $dbh->commit() unless $dbh->{AutoCommit};
7265          24                             853750            $dbh->disconnect();
7266          24                                289            MKDEBUG && _d('Disconnected dbh', $dbh);
7267                                                        }
7268                                                     }
7269          12                                799      return;
7270                                                  }
7271                                                  
7272                                                  # This is passed as the callback for TableSyncer::sync_table()
7273                                                  # if --print --verbose --verbose is specified.
7274                                                  sub print_sql {
7275  ***      0                    0             0      my ( $src_sql, $dst_sql ) = @_;
7276  ***      0      0                           0      print "# $src_sql\n" if $src_sql;
7277  ***      0      0                           0      print "# $dst_sql\n" if $dst_sql;
7278  ***      0                                  0      return;
7279                                                  }
7280                                                  
7281                                                  # Compares left_val to right_val by doing cmp.  Returns one of the
7282                                                  # result constants listed below, or dies if cmp is invalid.  The val
7283                                                  # arg is used for certain cmp, like equals and matches.  The twos
7284                                                  # vals should generally not be equal; if they are, UPDATE_NEITHER is
7285                                                  # returned.  Threshold (thr) only applies to temporal datetimes and
7286                                                  # dates and numerical values.
7287          29                   29           299   use constant UPDATE_LEFT      => -1;
              29                                 87   
              29                                242   
7288          29                   29           194   use constant UPDATE_RIGHT     =>  1;
              29                                 84   
              29                                141   
7289          29                   29           189   use constant UPDATE_NEITHER   =>  0;  # neither value equals/matches
              29                                 83   
              29                                146   
7290          29                   29           176   use constant FAILED_THRESHOLD =>  2;  # failed to exceed threshold
              29                                 85   
              29                                141   
7291                                                  sub cmp_conflict_col {
7292          53                   53           407      my ( $left_val, $right_val, $cmp, $val, $thr ) = @_;
7293          53                                166      MKDEBUG && _d('Compare', @_);
7294          53                                149      my $res;
7295          53    100    100                  483      if ( $cmp eq 'newest' || $cmp eq 'oldest' ) {
                    100    100                        
                    100                               
                    100                               
7296  ***     41    100     50                  388         $res = $cmp eq 'newest' ? ($left_val  || '') cmp ($right_val || '')
      ***                   50                        
      ***                   50                        
      ***                   50                        
7297                                                             :                    ($right_val || '') cmp ($left_val  || '');
7298                                                  
7299          41    100                         199         if ( $thr ) {
7300          11                                 85            $thr     = time_to_secs($thr);
7301          11                                 71            my $lts  = any_unix_timestamp($left_val);
7302          11                                 52            my $rts  = any_unix_timestamp($right_val);
7303          11                                 60            my $diff = abs($lts - $rts);
7304          11                                 28            MKDEBUG && _d('Check threshold, lts rts thr abs-diff:',
7305                                                              $lts, $rts, $thr, $diff);
7306          11    100                          65            if ( $diff < $thr ) {
7307           5                                 15               MKDEBUG && _d("Failed threshold");
7308           5                                 30               return FAILED_THRESHOLD;
7309                                                           }
7310                                                        }
7311                                                     }
7312                                                     elsif ( $cmp eq 'greatest' || $cmp eq 'least' ) {
7313  ***      5    100     50                   39         $res = $cmp eq 'greatest' ? (($left_val ||0) > ($right_val ||0) ? 1 : -1)
      ***            50     50                        
      ***           100     50                        
      ***                   50                        
7314                                                             :                      (($left_val ||0) < ($right_val ||0) ? 1 : -1);
7315  ***      5    100     50                   30         $res = 0 if ($left_val || 0) == ($right_val || 0);
      ***                   50                        
7316           5    100                          18         if ( $thr ) {
7317           2                                  7            my $diff = abs($left_val - $right_val);
7318           2                                  4            MKDEBUG && _d('Check threshold, abs-diff:', $diff);
7319           2    100                          10            if ( $diff < $thr ) {
7320           1                                  3               MKDEBUG && _d("Failed threshold");
7321           1                                  6               return FAILED_THRESHOLD;
7322                                                           }
7323                                                        }
7324                                                     }
7325                                                     elsif ( $cmp eq 'equals' ) {
7326  ***      3    100     50                   26         $res = ($left_val  || '') eq $val ?  1
      ***           100     50                        
7327                                                             : ($right_val || '') eq $val ? -1
7328                                                             :                               0;
7329                                                     }
7330                                                     elsif ( $cmp eq 'matches' ) {
7331  ***      3    100     50                   81         $res = ($left_val  || '') =~ m/$val/ ?  1
      ***           100     50                        
7332                                                             : ($right_val || '') =~ m/$val/ ? -1
7333                                                             :                                  0;
7334                                                     }
7335                                                     else {
7336                                                        # Should happen; caller should have verified this.
7337           1                                  3         die "Invalid comparison: $cmp";
7338                                                     }
7339                                                  
7340          46                                240      return $res;
7341                                                  }
7342                                                  
7343                                                  sub set_bidirectional_callbacks {
7344           5                    5            75      my ( %args ) = @_;
7345           5                                 38      foreach my $arg ( qw(plugin OptionParser) ) {
7346  ***     10     50                          71         die "I need a $arg argument" unless $args{$arg};
7347                                                     }
7348           5                                 23      my $o      = $args{OptionParser};
7349           5                                 22      my $plugin = $args{plugin};
7350                                                  
7351           5                                 31      my $col = $o->get('conflict-column');
7352           5                                 31      my $cmp = $o->get('conflict-comparison');
7353           5                                 28      my $val = $o->get('conflict-value');
7354           5                                 33      my $thr = $o->get('conflict-threshold');
7355                                                  
7356                                                     # plugin and syncer are actually the same module.  For clarity we
7357                                                     # name them differently.
7358                                                  
7359                                                     $plugin->set_callback('same_row', sub {
7360          26                   26           296         my ( %args ) = @_;
7361          26                                230         my ($lr, $rr, $syncer) = @args{qw(lr rr syncer)};
7362          26                                116         my $ch = $syncer->{ChangeHandler};
7363          26                                100         my $action = 'UPDATE';
7364          26                                 80         my $change_dbh;
7365          26                                 82         my $auth_row;
7366          26                                 80         my $err;
7367                                                  
7368  ***     26            50                  188         my $left_val  = $lr->{$col} || '';
7369  ***     26            50                  169         my $right_val = $rr->{$col} || '';
7370          26                                 90         MKDEBUG && _d('left',  $col, 'value:', $left_val);
7371          26                                 81         MKDEBUG && _d('right', $col, 'value:', $right_val);
7372                                                  
7373          26                                197         my $res = cmp_conflict_col($left_val, $right_val, $cmp, $val, $thr);
7374          26    100                         189         if ( $res == UPDATE_LEFT ) {
                    100                               
                    100                               
      ***            50                               
7375          13                                 41            MKDEBUG && _d("right dbh $args{right_dbh} $cmp; "
7376                                                              . "update left dbh $args{left_dbh}");
7377          13                                106            $ch->set_src('right', $args{right_dbh});
7378          13                                 59            $auth_row   = $args{rr};
7379          13                                 67            $change_dbh = $args{left_dbh};
7380                                                        }
7381                                                        elsif ( $res == UPDATE_RIGHT ) {
7382           9                                 23            MKDEBUG && _d("left dbh $args{left_dbh} $cmp; "
7383                                                              . "update right dbh $args{right_dbh}");
7384           9                                 70            $ch->set_src('left', $args{left_dbh});
7385           9                                 38            $auth_row   = $args{lr};
7386           9                                 40            $change_dbh = $args{right_dbh};
7387                                                        }
7388                                                        elsif ( $res == UPDATE_NEITHER ) {
7389  ***      2     50     33                   43            if ( $cmp eq 'equals' || $cmp eq 'matches' ) {
7390  ***      0                                  0               $err = "neither `$col` value $cmp $val";
7391                                                           }
7392                                                           else {
7393           2                                 19               $err = "`$col` values are the same"
7394                                                           }
7395                                                        }
7396                                                        elsif ( $res == FAILED_THRESHOLD ) {
7397           2                                 21            $err = "`$col` values do not differ by the threhold, $thr."
7398                                                        }
7399                                                        else {
7400                                                           # Shouldn't happen.
7401  ***      0                                  0            die "cmp_conflict_col() returned an invalid result: $res."
7402                                                        }
7403                                                  
7404          26    100                         149         if ( $err ) {
7405           4                                 34            $action   = undef;  # skip change in case we just warn
7406           4                                 30            my $where = $ch->make_where_clause($lr, $syncer->key_cols());
7407           4                                 41            $err      = "# Cannot resolve conflict WHERE $where: $err\n";
7408                                                  
7409                                                           # die here is caught in sync_a_table().  We're deeply nested:
7410                                                           # sync_a_table > sync_table > compare_sets > syncer > here
7411           4    100                          38            $o->get('conflict-error') eq 'warn' ? warn $err : die $err;
7412                                                        }
7413                                                  
7414          25                                243         return $action, $auth_row, $change_dbh;
7415           5                                166      });
7416                                                  
7417                                                     $plugin->set_callback('not_in_right', sub {
7418           7                    7            89         my ( %args ) = @_;
7419           7                                 84         $args{syncer}->{ChangeHandler}->set_src('left', $args{left_dbh});
7420           7                                 79         return 'INSERT', $args{lr}, $args{right_dbh};
7421           5                                 58      });
7422                                                  
7423                                                     $plugin->set_callback('not_in_left', sub {
7424           7                    7            70         my ( %args ) = @_;
7425           7                                 81         $args{syncer}->{ChangeHandler}->set_src('right', $args{right_dbh});
7426           7                                 75         return 'INSERT', $args{rr}, $args{left_dbh};
7427           5                                 72      });
7428                                                  
7429           5                                 33      return;
7430                                                  }
7431                                                  
7432                                                  sub _d {
7433  ***      0                    0                    my ($package, undef, $line) = caller 0;
7434  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
7435  ***      0                                              map { defined $_ ? $_ : 'undef' }
7436                                                          @_;
7437  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7438                                                  }
7439                                                  
7440                                                  # ############################################################################
7441                                                  # Run the program.
7442                                                  # ############################################################################
7443                                                  if ( !caller ) { exit main(@ARGV); }
7444                                                  
7445                                                  1; # Because this is a module as well as a script.
7446                                                  
7447                                                  # ############################################################################
7448                                                  # Documentation
7449                                                  # ############################################################################
7450                                                  =pod
7451                                                  
7452                                                  =head1 NAME
7453                                                  
7454                                                  mk-table-sync - Synchronize MySQL tables efficiently.
7455                                                  
7456                                                  =head1 SYNOPSIS
7457                                                  
7458                                                  This tool changes data, so for maximum safety, you should back up your data
7459                                                  before you use it.
7460                                                  
7461                                                  To sync db.tbl1 from host1 to host2:
7462                                                  
7463                                                   mk-table-sync --execute u=user,p=pass,h=host1,D=db,t=tbl host2
7464                                                  
7465                                                  Sync all tables in host1 to host2 and host3:
7466                                                  
7467                                                   mk-table-sync --execute host1 host2 host3
7468                                                  
7469                                                  Resolve differences L<mk-table-checksum> found on this master's slaves:
7470                                                  
7471                                                   mk-table-sync --execute --replicate test.checksum master1
7472                                                  
7473                                                  Make slave1 have the same data as its replication master:
7474                                                  
7475                                                   mk-table-sync --execute --sync-to-master slave1
7476                                                  
7477                                                  Ditto, resolving differences L<mk-table-checksum> found:
7478                                                  
7479                                                   mk-table-sync --execute --sync-to-master \
7480                                                     --replicate test.checksum slave1
7481                                                  
7482                                                  Sync server2 in a master-master replication configuration, where server2's copy
7483                                                  of db1.tbl1 is known or suspected to be incorrect:
7484                                                  
7485                                                   mk-table-sync --execute --sync-to-master h=server2,D=db1,t=tbl1
7486                                                  
7487                                                  Note that in the master-master configuration, the following will NOT do what you
7488                                                  want, because it will make changes directly on server2, which will then flow
7489                                                  through replication and change server1's data:
7490                                                  
7491                                                   # Don't do this in a master-master setup!
7492                                                   mk-table-sync --execute h=server1,D=db1,t=tbl1 h=server2
7493                                                  
7494                                                  =head1 RISKS
7495                                                  
7496                                                  The following section is included to inform users about the potential risks,
7497                                                  whether known or unknown, of using this tool.  The two main categories of risks
7498                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
7499                                                  tools) and those created by bugs.
7500                                                  
7501                                                  With great power comes great responsibility!  This tool changes data, so it is a
7502                                                  good idea to back up your data.  It is also very powerful, which means it is
7503                                                  very complex, so you should run it with the L<"--dry-run"> option to see what it
7504                                                  will do, until you're familiar with its operation.  If you want to see which
7505                                                  rows are different, without changing any data, use L<"--print"> instead of
7506                                                  L<"--execute">.  
7507                                                  
7508                                                  Be careful when using mk-table-sync in any master-master setup.  Master-master
7509                                                  replication is inherently tricky, and it's easy to make mistakes.  Yyou need to
7510                                                  be sure you're using the tool correctly for master-master replication.  See the
7511                                                  L<"SYNOPSIS"> for the overview of the correct usage.
7512                                                  
7513                                                  In general, this tool is best suited when your tables have a primary key or
7514                                                  unique index.  Although it can synchronize data in tables lacking a primary key
7515                                                  or unique index, it might be best to sychronize that data by another means.
7516                                                  
7517                                                  At the time of this release, there is a bug that causes invalid SQL when
7518                                                  syncing columns with binary data, and a potential bug using
7519                                                  L<"--lock-and-rename"> with MySQL 5.1.
7520                                                  
7521                                                  The authoritative source for updated information is always the online issue
7522                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
7523                                                  see a list of such issues at the following URL:
7524                                                  L<http://www.maatkit.org/bugs/mk-table-sync>.
7525                                                  
7526                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
7527                                                  
7528                                                  =head1 DESCRIPTION
7529                                                  
7530                                                  B<WARNING> this tool is unfinished and could perform slowly.  The Chunk
7531                                                  algorithm is great when it can be used, and so is Nibble, but otherwise GroupBy
7532                                                  is the default choice and it may not perform very well.  Please run with
7533                                                  L<"--dry-run"> before subjecting your servers to this tool, and make backups of
7534                                                  your data!
7535                                                  
7536                                                  This tool is designed to do one-way and bidirectional synchronization of data.
7537                                                  It finds differences efficiently with one of several algorithms
7538                                                  (see L<"ALGORITHMS">).  It makes changes on the destination table(s) so it
7539                                                  matches the source.
7540                                                  
7541                                                  It does B<not> synchronize table structures, indexes, or any other schema
7542                                                  changes.  It synchronizes only data.
7543                                                  
7544                                                  It can operate through replication by comparing a slave with its master and
7545                                                  making changes on the master.  These changes will flow through replication and
7546                                                  correct any differences found on the slave.
7547                                                  
7548                                                  It accepts a list of DSNs (see the L<"--help"> output) to tell it where and how
7549                                                  to connect.
7550                                                  
7551                                                  There are many ways to invoke it.  The following is the abbreviated logic:
7552                                                  
7553                                                     if DSN has a t part, sync only that table:
7554                                                        if 1 DSN:
7555                                                           if --sync-to-master:
7556                                                              The DSN is a slave.  Connect to its master and sync.
7557                                                        if more than 1 DSN:
7558                                                           The first DSN is the source.  Sync each DSN in turn.
7559                                                     else if --replicate:
7560                                                        if --sync-to-master:
7561                                                           The DSN is a slave.  Connect to its master, find records
7562                                                           of differences, and fix.
7563                                                        else:
7564                                                           The DSN is the master.  Find slaves and connect to each,
7565                                                           find records of differences, and fix.
7566                                                     else:
7567                                                        if only 1 DSN and --sync-to-master:
7568                                                           The DSN is a slave.  Connect to its master, find tables and
7569                                                           filter with --databases etc, and sync each table to the master.
7570                                                        else:
7571                                                           find tables, filtering with --databases etc, and sync each
7572                                                           DSN to the first.
7573                                                  
7574                                                  If you're confused about how it the DSNs are interpreted, use the
7575                                                  L<"--explain-hosts"> option and it will tell you.
7576                                                  
7577                                                  =head1 OUTPUT
7578                                                  
7579                                                  If you specify the L<"--verbose"> option, you'll see information about the 
7580                                                  differences between the tables.  There is one row per table.  Each server is
7581                                                  printed separately.  For example,
7582                                                  
7583                                                     # Syncing h=host1,D=test,t=test1
7584                                                     # DELETE REPLACE INSERT UPDATE ALGORITHM EXIT DATABASE.TABLE
7585                                                     #      0       0      3      0 Chunk     2    test.test1
7586                                                  
7587                                                  Table test.test1 on host1 required 3 C<INSERT> statements to synchronize
7588                                                  and it used the Chunk algorithm (see L<"ALGORITHMS">).  Because differences were
7589                                                  found, its L<"EXIT STATUS"> was 2.
7590                                                  
7591                                                  If you specify the L<"--print"> option, you'll see the actual SQL statements
7592                                                  that the script uses to synchronize the table if L<"--execute"> is also
7593                                                  specified.
7594                                                  
7595                                                  If you want to see the SQL statements that mk-table-sync is using to select
7596                                                  chunks, nibbles, rows, etc., then specify L<"--print"> once and L<"--verbose">
7597                                                  twice.  Be careful though: this can print a lot of SQL statements.
7598                                                  
7599                                                  There are cases where no combination of C<INSERT>, C<UPDATE> or C<DELETE>
7600                                                  statements can resolve differences without violating some unique key.  For
7601                                                  example, suppose there's a primary key on column a and a unique key on column b.
7602                                                  Then there is no way to sync these two tables with straightforward UPDATE
7603                                                  statements:
7604                                                  
7605                                                   +---+---+  +---+---+
7606                                                   | a | b |  | a | b |
7607                                                   +---+---+  +---+---+
7608                                                   | 1 | 2 |  | 1 | 1 |
7609                                                   | 2 | 1 |  | 2 | 2 |
7610                                                   +---+---+  +---+---+
7611                                                  
7612                                                  The tool rewrites queries to C<DELETE> and C<REPLACE> in this case.  This is
7613                                                  automatically handled after the first index violation, so you don't have to
7614                                                  worry about it.
7615                                                  
7616                                                  =head1 REPLICATION SAFETY
7617                                                  
7618                                                  Synchronizing a replication master and slave safely is a non-trivial problem, in
7619                                                  general.  There are all sorts of issues to think about, such as other processes
7620                                                  changing data, trying to change data on the slave, whether the destination and
7621                                                  source are a master-master pair, and much more.
7622                                                  
7623                                                  In general, the safe way to do it is to change the data on the master, and let
7624                                                  the changes flow through replication to the slave like any other changes.
7625                                                  However, this works only if it's possible to REPLACE into the table on the
7626                                                  master.  REPLACE works only if there's a unique index on the table (otherwise it
7627                                                  just acts like an ordinary INSERT).
7628                                                  
7629                                                  If your table has unique keys, you should use the L<"--sync-to-master"> and/or
7630                                                  L<"--replicate"> options to sync a slave to its master.  This will generally do
7631                                                  the right thing.  When there is no unique key on the table, there is no choice
7632                                                  but to change the data on the slave, and mk-table-sync will detect that you're
7633                                                  trying to do so.  It will complain and die unless you specify
7634                                                  C<--no-check-slave> (see L<"--[no]check-slave">).
7635                                                  
7636                                                  If you're syncing a table without a primary or unique key on a master-master
7637                                                  pair, you must change the data on the destination server.  Therefore, you need
7638                                                  to specify C<--no-bin-log> for safety (see L<"--[no]bin-log">).  If you don't,
7639                                                  the changes you make on the destination server will replicate back to the
7640                                                  source server and change the data there!
7641                                                  
7642                                                  The generally safe thing to do on a master-master pair is to use the
7643                                                  L<"--sync-to-master"> option so you don't change the data on the destination
7644                                                  server.  You will also need to specify C<--no-check-slave> to keep
7645                                                  mk-table-sync from complaining that it is changing data on a slave.
7646                                                  
7647                                                  =head1 ALGORITHMS
7648                                                  
7649                                                  This tool has a generic data-syncing framework, within which it is possible to
7650                                                  use any number of different algorithms to actually find differences.  It chooses
7651                                                  the best algorithm automatically.  While I plan to add more algorithms in the
7652                                                  future, the following are implemented now:
7653                                                  
7654                                                  =over
7655                                                  
7656                                                  =item Chunk
7657                                                  
7658                                                  Finds an index whose first column is numeric (including date and time types),
7659                                                  and divides the column's range of values into chunks of approximately
7660                                                  L<"--chunk-size"> rows.  Syncs a chunk at a time by checksumming the entire
7661                                                  chunk.  If the chunk differs on the source and destination, checksums each
7662                                                  chunk's rows individually to find the rows that differ.
7663                                                  
7664                                                  It is efficient when the column has sufficient cardinality to make the chunks
7665                                                  end up about the right size.
7666                                                  
7667                                                  The initial per-chunk checksum is quite small and results in minimal network
7668                                                  traffic and memory consumption.  If a chunk's rows must be examined, only the
7669                                                  primary key columns and a checksum are sent over the network, not the entire
7670                                                  row.  If a row is found to be different, the entire row will be fetched, but not
7671                                                  before.
7672                                                  
7673                                                  =item Nibble
7674                                                  
7675                                                  Finds an index and ascends the index in fixed-size nibbles of L<"--chunk-size">
7676                                                  rows, using a non-backtracking algorithm (see L<mk-archiver> for more on this
7677                                                  algorithm).  It is very similar to L<"Chunk">, but instead of pre-calculating
7678                                                  the boundaries of each piece of the table based on index cardinality, it uses
7679                                                  C<LIMIT> to define each nibble's upper limit, and the previous nibble's upper
7680                                                  limit to define the lower limit.
7681                                                  
7682                                                  It works in steps: one query finds the row that will define the next nibble's
7683                                                  upper boundary, and the next query checksums the entire nibble.  If the nibble
7684                                                  differs between the source and destination, it examines the nibble row-by-row,
7685                                                  just as L<"Chunk"> does.
7686                                                  
7687                                                  =item GroupBy
7688                                                  
7689                                                  Selects the entire table grouped by all columns, with a COUNT(*) column added.
7690                                                  Compares all columns, and if they're the same, compares the COUNT(*) column's
7691                                                  value to determine how many rows to insert or delete into the destination.
7692                                                  Works on tables with no primary key or unique index.
7693                                                  
7694                                                  =item Stream
7695                                                  
7696                                                  Selects the entire table in one big stream and compares all columns.  Selects
7697                                                  all columns.  Much less efficient than the other algorithms, but works when
7698                                                  there is no suitable index for them to use.
7699                                                  
7700                                                  =item Future Plans
7701                                                  
7702                                                  Possibilities for future algorithms are TempTable (what I originally called
7703                                                  bottom-up in earlier versions of this tool), DrillDown (what I originallly
7704                                                  called top-down), and GroupByPrefix (similar to how SqlYOG Job Agent works).
7705                                                  Each algorithm has strengths and weaknesses.  If you'd like to implement your
7706                                                  favorite technique for finding differences between two sources of data on
7707                                                  possibly different servers, I'm willing to help.  The algorithms adhere to a
7708                                                  simple interface that makes it pretty easy to write your own.
7709                                                  
7710                                                  =back
7711                                                  
7712                                                  =head1 BIDIRECTIONAL SYNCING
7713                                                  
7714                                                  Bidirectional syncing is a new, experimental feature.  To make it work
7715                                                  reliably there are a number of strict limitations:
7716                                                  
7717                                                    * only works when syncing one server to other independent servers
7718                                                    * does not work in any way with replication
7719                                                    * requires that the table(s) are chunkable with the Chunk algorithm
7720                                                    * is not N-way, only bidirectional between two servers at a time
7721                                                    * does not handle DELETE changes
7722                                                  
7723                                                  For example, suppose we have three servers: c1, r1, r2.  c1 is the central
7724                                                  server, a pseudo-master to the other servers (viz. r1 and r2 are not slaves
7725                                                  to c1).  r1 and r2 are remote servers.  Rows in table foo are updated and
7726                                                  inserted on all three servers and we want to synchronize all the changes
7727                                                  between all the servers.  Table foo has columns:
7728                                                  
7729                                                    id    int PRIMARY KEY
7730                                                    ts    timestamp auto updated
7731                                                    name  varchar
7732                                                  
7733                                                  Auto-increment offsets are used so that new rows from any server do not
7734                                                  create conflicting primary key (id) values.  In general, newer rows, as
7735                                                  determined by the ts column, take precedence when a same but differing row
7736                                                  is found during the bidirectional sync.  "Same but differing" means that
7737                                                  two rows have the same primary key (id) value but different values for some
7738                                                  other column, like the name column in this example.  Same but differing
7739                                                  conflicts are resolved by a "conflict".  A conflict compares some column of
7740                                                  the competing rows to determine a "winner".  The winnning row becomes the
7741                                                  source and its values are used to update the other row.
7742                                                  
7743                                                  There are subtle differences between three columns used to achieve
7744                                                  bidirectional syncing that you should be familiar with: chunk column
7745                                                  (L<"--chunk-column">), comparison column(s) (L<"--columns">), and conflict
7746                                                  column (L<"--conflict-column">).  The chunk column is only used to chunk the
7747                                                  table; e.g. "WHERE id >= 5 AND id < 10".  Chunks are checksummed and when
7748                                                  chunk checksums reveal a difference, the tool selects the rows in that
7749                                                  chunk and checksums the L<"--columns"> for each row.  If a column checksum
7750                                                  differs, the rows have one or more conflicting column values.  In a
7751                                                  traditional unidirectional sync, the conflict is a moot point because it can
7752                                                  be resolved simply by updating the entire destination row with the source
7753                                                  row's values.  In a bidirectional sync, however, the L<"--conflict-column">
7754                                                  (in accordance with other C<--conflict-*> options list below) is compared
7755                                                  to determine which row is "correct" or "authoritative"; this row becomes
7756                                                  the "source".
7757                                                  
7758                                                  To sync all three servers completely, two runs of mk-table-sync are required.
7759                                                  The first run syncs c1 and r1, then syncs c1 and r2 including any changes
7760                                                  from r1.  At this point c1 and r2 are completely in sync, but r1 is missing
7761                                                  any changes from r2 because c1 didn't have these changes when it and r1
7762                                                  were synced.  So a second run is needed which syncs the servers in the same
7763                                                  order, but this time when c1 and r1 are synced r1 gets r2's changes.
7764                                                  
7765                                                  The tool does not sync N-ways, only bidirectionally between the first DSN
7766                                                  given on the command line and each subsequent DSN in turn.  So the tool in
7767                                                  this example would be ran twice like:
7768                                                  
7769                                                    mk-table-sync --bidirectional h=c1 h=r1 h=r2
7770                                                  
7771                                                  The L<"--bidirectional"> option enables this feature and causes various
7772                                                  sanity checks to be performed.  You must specify other options that tell
7773                                                  mk-table-sync how to resolve conflicts for same but differing rows.
7774                                                  These options are:
7775                                                  
7776                                                    * L<"--conflict-column">
7777                                                    * L<"--conflict-comparison">
7778                                                    * L<"--conflict-value">
7779                                                    * L<"--conflict-threshold">
7780                                                    * L<"--conflict-error">  (optional)
7781                                                  
7782                                                  Use L<"--print"> to test this option before L<"--execute">.  The printed
7783                                                  SQL statements will have comments saying on which host the statment
7784                                                  would be executed if you used L<"--execute">.
7785                                                  
7786                                                  Technical side note: the first DSN is always the "left" server and the other
7787                                                  DSNs are always the "right" server.  Since either server can become the source
7788                                                  or destination it's confusing to think of them as "src" and "dst".  Therefore,
7789                                                  they're generically referred to as left and right.  It's easy to remember
7790                                                  this because the first DSN is always to the left of the other server DSNs on
7791                                                  the command line.
7792                                                  
7793                                                  =head1 EXIT STATUS
7794                                                  
7795                                                  Exit status is as follows:
7796                                                  
7797                                                     STATUS  MEANING
7798                                                     ======  =======================================================
7799                                                     0       Success.
7800                                                     1       Internal error.
7801                                                     2       At least one table differed on the destination.
7802                                                     3       Combination of 1 and 2.
7803                                                  
7804                                                  =head1 OPTIONS
7805                                                  
7806                                                  Specify at least one of L<"--print">, L<"--execute">, or L<"--dry-run">.
7807                                                  
7808                                                  L<"--where"> and L<"--replicate"> are mutually exclusive.
7809                                                  
7810                                                  =over
7811                                                  
7812                                                  =item --algorithms
7813                                                  
7814                                                  type: string; default: Chunk,Nibble,GroupBy,Stream
7815                                                  
7816                                                  Algorithm to use when comparing the tables, in order of preference.
7817                                                  
7818                                                  For each table, mk-table-sync will check if the table can be synced with
7819                                                  the given algorithms in the order that they're given.  The first algorithm
7820                                                  that can sync the table is used.  See L<"ALGORITHMS">.
7821                                                  
7822                                                  =item --ask-pass
7823                                                  
7824                                                  Prompt for a password when connecting to MySQL.
7825                                                  
7826                                                  =item --bidirectional
7827                                                  
7828                                                  Enable bidirectional sync between first and subsequent hosts.
7829                                                  
7830                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
7831                                                  
7832                                                  =item --[no]bin-log
7833                                                  
7834                                                  default: yes
7835                                                  
7836                                                  Log to the binary log (C<SET SQL_LOG_BIN=1>).
7837                                                  
7838                                                  Specifying C<--no-bin-log> will C<SET SQL_LOG_BIN=0>.
7839                                                  
7840                                                  =item --buffer-in-mysql
7841                                                  
7842                                                  Instruct MySQL to buffer queries in its memory.
7843                                                  
7844                                                  This option adds the C<SQL_BUFFER_RESULT> option to the comparison queries.
7845                                                  This causes MySQL to execute the queries and place them in a temporary table
7846                                                  internally before sending the results back to mk-table-sync.  The advantage of
7847                                                  this strategy is that mk-table-sync can fetch rows as desired without using a
7848                                                  lot of memory inside the Perl process, while releasing locks on the MySQL table
7849                                                  (to reduce contention with other queries).  The disadvantage is that it uses
7850                                                  more memory on the MySQL server instead.
7851                                                  
7852                                                  You probably want to leave L<"--[no]buffer-to-client"> enabled too, because
7853                                                  buffering into a temp table and then fetching it all into Perl's memory is
7854                                                  probably a silly thing to do.  This option is most useful for the GroupBy and
7855                                                  Stream algorithms, which may fetch a lot of data from the server.
7856                                                  
7857                                                  =item --[no]buffer-to-client
7858                                                  
7859                                                  default: yes
7860                                                  
7861                                                  Fetch rows one-by-one from MySQL while comparing.
7862                                                  
7863                                                  This is disabled by default.  If enabled, all rows will be fetched into memory
7864                                                  for comparing.  This may result in the results "cursor" being held open for a
7865                                                  shorter time on the server, but if the tables are large, it could take a long
7866                                                  time anyway, and eat all your memory.  For most non-trivial data sizes, you
7867                                                  want to leave this disabled.
7868                                                  
7869                                                  =item --charset
7870                                                  
7871                                                  short form: -A; type: string
7872                                                  
7873                                                  Default character set.  If the value is utf8, sets Perl's binmode on
7874                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
7875                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
7876                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
7877                                                  connecting to MySQL.
7878                                                  
7879                                                  =item --[no]check-master
7880                                                  
7881                                                  default: yes
7882                                                  
7883                                                  With L<"--sync-to-master">, try to verify that the detected
7884                                                  master is the real master.
7885                                                  
7886                                                  =item --[no]check-privileges
7887                                                  
7888                                                  default: yes
7889                                                  
7890                                                  Check that user has all necessary privileges on source and destination table.
7891                                                  
7892                                                  =item --[no]check-slave
7893                                                  
7894                                                  default: yes
7895                                                  
7896                                                  Check whether the destination server is a slave.
7897                                                  
7898                                                  If the destination server is a slave, it's generally unsafe to make changes on
7899                                                  it.  However, sometimes you have to; L<"--replace"> won't work unless there's a
7900                                                  unique index, for example, so you can't make changes on the master in that
7901                                                  scenario.  By default mk-table-sync will complain if you try to change data on
7902                                                  a slave.  Specify C<--no-slave-check> to disable this check.  Use it at your own
7903                                                  risk.
7904                                                  
7905                                                  =item --[no]check-triggers
7906                                                  
7907                                                  default: yes
7908                                                  
7909                                                  Check that no triggers are defined on the destination table.
7910                                                  
7911                                                  Triggers were introduced in MySQL v5.0.2, so for older versions this option
7912                                                  has no effect because triggers will not be checked.
7913                                                  
7914                                                  =item --chunk-column
7915                                                  
7916                                                  type: string
7917                                                  
7918                                                  Chunk the table on this column.
7919                                                  
7920                                                  =item --chunk-index
7921                                                  
7922                                                  type: string
7923                                                  
7924                                                  Chunk the table using this index.
7925                                                  
7926                                                  =item --chunk-size
7927                                                  
7928                                                  type: string; default: 1000
7929                                                  
7930                                                  Number of rows or data size per chunk.
7931                                                  
7932                                                  The size of each chunk of rows for the L<"Chunk"> and L<"Nibble"> algorithms.
7933                                                  The size can be either a number of rows, or a data size.  Data sizes are
7934                                                  specified with a suffix of k=kibibytes, M=mebibytes, G=gibibytes.  Data sizes
7935                                                  are converted to a number of rows by dividing by the average row length.
7936                                                  
7937                                                  =item --columns
7938                                                  
7939                                                  short form: -c; type: array
7940                                                  
7941                                                  Compare this comma-separated list of columns.
7942                                                  
7943                                                  =item --config
7944                                                  
7945                                                  type: Array
7946                                                  
7947                                                  Read this comma-separated list of config files; if specified, this must be the
7948                                                  first option on the command line.
7949                                                  
7950                                                  =item --conflict-column
7951                                                  
7952                                                  type: string
7953                                                  
7954                                                  Compare this column when rows conflict during a L<"--bidirectional"> sync.
7955                                                  
7956                                                  When a same but differing row is found the value of this column from each
7957                                                  row is compared according to L<"--conflict-comparison">, L<"--conflict-value">
7958                                                  and L<"--conflict-threshold"> to determine which row has the correct data and
7959                                                  becomes the source.  The column can be any type for which there is an
7960                                                  appropriate L<"--conflict-comparison"> (this is almost all types except, for
7961                                                  example, blobs).
7962                                                  
7963                                                  This option only works with L<"--bidirectional">.
7964                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
7965                                                  
7966                                                  =item --conflict-comparison
7967                                                  
7968                                                  type: string
7969                                                  
7970                                                  Choose the L<"--conflict-column"> with this property as the source.
7971                                                  
7972                                                  The option affects how the L<"--conflict-column"> values from the conflicting
7973                                                  rows are compared.  Possible comparisons are one of these MAGIC_comparisons:
7974                                                  
7975                                                    newest|oldest|greatest|least|equals|matches
7976                                                  
7977                                                    COMPARISON  CHOOSES ROW WITH
7978                                                    ==========  =========================================================
7979                                                    newest      Newest temporal L<"--conflict-column"> value
7980                                                    oldest      Oldest temporal L<"--conflict-column"> value
7981                                                    greatest    Greatest numerical L<"--conflict-column"> value
7982                                                    least       Least numerical L<"--conflict-column"> value
7983                                                    equals      L<"--conflict-column"> value equal to L<"--conflict-value">
7984                                                    matches     L<"--conflict-column"> value matching Perl regex pattern
7985                                                                L<"--conflict-value">
7986                                                  
7987                                                  This option only works with L<"--bidirectional">.
7988                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
7989                                                  
7990                                                  =item --conflict-error
7991                                                  
7992                                                  type: string; default: warn
7993                                                  
7994                                                  How to report unresolvable conflicts and conflict errors
7995                                                  
7996                                                  This option changes how the user is notified when a conflict cannot be
7997                                                  resolved or causes some kind of error.  Possible values are:
7998                                                  
7999                                                    * warn: Print a warning to STDERR about the unresolvable conflict
8000                                                    * die:  Die, stop syncing, and print a warning to STDERR
8001                                                  
8002                                                  This option only works with L<"--bidirectional">.
8003                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
8004                                                  
8005                                                  =item --conflict-threshold
8006                                                  
8007                                                  type: string
8008                                                  
8009                                                  Amount by which one L<"--conflict-column"> must exceed the other.
8010                                                  
8011                                                  The L<"--conflict-threshold"> prevents a conflict from being resolved if
8012                                                  the absolute difference between the two L<"--conflict-column"> values is
8013                                                  less than this amount.  For example, if two L<"--conflict-columns"> have
8014                                                  timestamp values "2009-12-01 12:00:00" and "2009-12-01 12:05:00" the difference
8015                                                  is 5 minutes.  If L<"--conflict-threshold"> is set to "5m" the conflict will
8016                                                  be resolved, but if L<"--conflict-threshold"> is set to "6m" the conflict
8017                                                  will fail to resolve because the difference is not greater than or equal
8018                                                  to 6 minutes.  In this latter case, L<"--conflict-error"> will report
8019                                                  the failure.
8020                                                  
8021                                                  This option only works with L<"--bidirectional">.
8022                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
8023                                                  
8024                                                  =item --conflict-value
8025                                                  
8026                                                  type: string
8027                                                  
8028                                                  Use this value for certain L<"--conflict-comparison">.
8029                                                  
8030                                                  This option gives the value for C<equals> and C<matches>
8031                                                  L<"--conflict-comparison">.
8032                                                  
8033                                                  This option only works with L<"--bidirectional">.
8034                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
8035                                                  
8036                                                  =item --databases
8037                                                  
8038                                                  short form: -d; type: hash
8039                                                  
8040                                                  Sync only this comma-separated list of databases.
8041                                                  
8042                                                  A common request is to sync tables from one database with tables from another
8043                                                  database on the same or different server.  This is not yet possible.
8044                                                  L<"--databases"> will not do it, and you can't do it with the D part of the DSN
8045                                                  either because in the absence of a table name it assumes the whole server
8046                                                  should be synced and the D part controls only the connection's default database.
8047                                                  
8048                                                  =item --defaults-file
8049                                                  
8050                                                  short form: -F; type: string
8051                                                  
8052                                                  Only read mysql options from the given file.  You must give an absolute pathname.
8053                                                  
8054                                                  =item --dry-run
8055                                                  
8056                                                  Analyze, decide the sync algorithm to use, print and exit.
8057                                                  
8058                                                  Implies L<"--verbose"> so you can see the results.  The results are in the same
8059                                                  output format that you'll see from actually running the tool, but there will be
8060                                                  zeros for rows affected.  This is because the tool actually executes, but stops
8061                                                  before it compares any data and just returns zeros.  The zeros do not mean there
8062                                                  are no changes to be made.
8063                                                  
8064                                                  =item --engines
8065                                                  
8066                                                  short form: -e; type: hash
8067                                                  
8068                                                  Sync only this comma-separated list of storage engines.
8069                                                  
8070                                                  =item --execute
8071                                                  
8072                                                  Execute queries to make the tables have identical data.
8073                                                  
8074                                                  This option makes mk-table-sync actually sync table data by executing all
8075                                                  the queries that it created to resolve table differences.  Therefore, B<the
8076                                                  tables will be changed!>  And unless you also specify L<"--verbose">, the
8077                                                  changes will be made silently.  If this is not what you want, see
8078                                                  L<"--print"> or L<"--dry-run">.
8079                                                  
8080                                                  =item --explain-hosts
8081                                                  
8082                                                  Print connection information and exit.
8083                                                  
8084                                                  Print out a list of hosts to which mk-table-sync will connect, with all
8085                                                  the various connection options, and exit.
8086                                                  
8087                                                  =item --float-precision
8088                                                  
8089                                                  type: int
8090                                                  
8091                                                  Precision for C<FLOAT> and C<DOUBLE> column comparisons.
8092                                                  
8093                                                  If you specify this option, FLOAT and DOUBLE columns will be rounded to the
8094                                                  specified number of digits after the decimal point for the checksum.  This can
8095                                                  avoid mismatches due to different floating-point representations of
8096                                                  the same values on different MySQL versions and hardware.
8097                                                  
8098                                                  =item --[no]foreign-key-checks
8099                                                  
8100                                                  default: yes
8101                                                  
8102                                                  Enable foreign key checks (C<SET FOREIGN_KEY_CHECKS=1>).
8103                                                  
8104                                                  Specifying C<--no-foreign-key-checks> will C<SET FOREIGN_KEY_CHECKS=0>.
8105                                                  
8106                                                  =item --function
8107                                                  
8108                                                  type: string
8109                                                  
8110                                                  Which hash function you'd like to use for checksums.
8111                                                  
8112                                                  The default is C<CRC32>.  Other good choices include C<MD5> and C<SHA1>.  If you
8113                                                  have installed the C<FNV_64> user-defined function, C<mk-table-sync> will detect
8114                                                  it and prefer to use it, because it is much faster than the built-ins.  You can
8115                                                  also use MURMUR_HASH if you've installed that user-defined function.  Both of
8116                                                  these are distributed with Maatkit.  See L<mk-table-checksum> for more
8117                                                  information and benchmarks.
8118                                                  
8119                                                  =item --help
8120                                                  
8121                                                  Show help and exit.
8122                                                  
8123                                                  =item --host
8124                                                  
8125                                                  short form: -h; type: string
8126                                                  
8127                                                  Connect to host.
8128                                                  
8129                                                  =item --ignore-columns
8130                                                  
8131                                                  type: Hash
8132                                                  
8133                                                  Ignore this comma-separated list of column names in comparisons.
8134                                                  
8135                                                  This option causes columns not to be compared.  However, if a row is determined
8136                                                  to differ between tables, all columns in that row will be synced, regardless.
8137                                                  (It is not currently possible to exclude columns from the sync process itself,
8138                                                  only from the comparison.)
8139                                                  
8140                                                  =item --ignore-databases
8141                                                  
8142                                                  type: Hash
8143                                                  
8144                                                  Ignore this comma-separated list of databases.
8145                                                  
8146                                                  =item --ignore-engines
8147                                                  
8148                                                  type: Hash; default: FEDERATED,MRG_MyISAM
8149                                                  
8150                                                  Ignore this comma-separated list of storage engines.
8151                                                  
8152                                                  =item --ignore-tables
8153                                                  
8154                                                  type: Hash
8155                                                  
8156                                                  Ignore this comma-separated list of tables.
8157                                                  
8158                                                  Table names may be qualified with the database name.
8159                                                  
8160                                                  =item --[no]index-hint
8161                                                  
8162                                                  default: yes
8163                                                  
8164                                                  Add FORCE/USE INDEX hints to the chunk and row queries.
8165                                                  
8166                                                  By default C<mk-table-sync> adds a FORCE/USE INDEX hint to each SQL statement
8167                                                  to coerce MySQL into using the index chosen by the sync algorithm or specified
8168                                                  by L<"--chunk-index">.  This is usually a good thing, but in rare cases the
8169                                                  index may not be the best for the query so you can suppress the index hint
8170                                                  by specifying C<--no-index-hint> and let MySQL choose the index.
8171                                                  
8172                                                  This does not affect the queries printed by L<"--print">; it only affects the
8173                                                  chunk and row queries that C<mk-table-sync> uses to select and compare rows.
8174                                                  
8175                                                  =item --lock
8176                                                  
8177                                                  type: int
8178                                                  
8179                                                  Lock tables: 0=none, 1=per sync cycle, 2=per table, or 3=globally.
8180                                                  
8181                                                  This uses C<LOCK TABLES>.  This can help prevent tables being changed while
8182                                                  you're examining them.  The possible values are as follows:
8183                                                  
8184                                                    VALUE  MEANING
8185                                                    =====  =======================================================
8186                                                    0      Never lock tables.
8187                                                    1      Lock and unlock one time per sync cycle (as implemented
8188                                                           by the syncing algorithm).  This is the most granular
8189                                                           level of locking available.  For example, the Chunk
8190                                                           algorithm will lock each chunk of C<N> rows, and then
8191                                                           unlock them if they are the same on the source and the
8192                                                           destination, before moving on to the next chunk.
8193                                                    2      Lock and unlock before and after each table.
8194                                                    3      Lock and unlock once for every server (DSN) synced, with
8195                                                           C<FLUSH TABLES WITH READ LOCK>.
8196                                                  
8197                                                  A replication slave is never locked if L<"--replicate"> or L<"--sync-to-master">
8198                                                  is specified, since in theory locking the table on the master should prevent any
8199                                                  changes from taking place.  (You are not changing data on your slave, right?)
8200                                                  If L<"--wait"> is given, the master (source) is locked and then the tool waits
8201                                                  for the slave to catch up to the master before continuing.
8202                                                  
8203                                                  If C<--transaction> is specified, C<LOCK TABLES> is not used.  Instead, lock
8204                                                  and unlock are implemented by beginning and committing transactions.
8205                                                  The exception is if L<"--lock"> is 3.
8206                                                  
8207                                                  If C<--no-transaction> is specified, then C<LOCK TABLES> is used for any
8208                                                  value of L<"--lock">. See L<"--[no]transaction">.
8209                                                  
8210                                                  =item --lock-and-rename
8211                                                  
8212                                                  Lock the source and destination table, sync, then swap names.  This is useful as
8213                                                  a less-blocking ALTER TABLE, once the tables are reasonably in sync with each
8214                                                  other (which you may choose to accomplish via any number of means, including
8215                                                  dump and reload or even something like L<mk-archiver>).  It requires exactly two
8216                                                  DSNs and assumes they are on the same server, so it does no waiting for
8217                                                  replication or the like.  Tables are locked with LOCK TABLES.
8218                                                  
8219                                                  =item --password
8220                                                  
8221                                                  short form: -p; type: string
8222                                                  
8223                                                  Password to use when connecting.
8224                                                  
8225                                                  =item --pid
8226                                                  
8227                                                  type: string
8228                                                  
8229                                                  Create the given PID file.  The file contains the process ID of the script.
8230                                                  The PID file is removed when the script exits.  Before starting, the script
8231                                                  checks if the PID file already exists.  If it does not, then the script creates
8232                                                  and writes its own PID to it.  If it does, then the script checks the following:
8233                                                  if the file contains a PID and a process is running with that PID, then
8234                                                  the script dies; or, if there is no process running with that PID, then the
8235                                                  script overwrites the file with its own PID and starts; else, if the file
8236                                                  contains no PID, then the script dies.
8237                                                  
8238                                                  =item --port
8239                                                  
8240                                                  short form: -P; type: int
8241                                                  
8242                                                  Port number to use for connection.
8243                                                  
8244                                                  =item --print
8245                                                  
8246                                                  Print queries that will resolve differences.
8247                                                  
8248                                                  If you don't trust C<mk-table-sync>, or just want to see what it will do, this
8249                                                  is a good way to be safe.  These queries are valid SQL and you can run them
8250                                                  yourself if you want to sync the tables manually.
8251                                                  
8252                                                  =item --recursion-method
8253                                                  
8254                                                  type: string
8255                                                  
8256                                                  Preferred recursion method used to find slaves.
8257                                                  
8258                                                  Possible methods are:
8259                                                  
8260                                                    METHOD       USES
8261                                                    ===========  ================
8262                                                    processlist  SHOW PROCESSLIST
8263                                                    hosts        SHOW SLAVE HOSTS
8264                                                  
8265                                                  The processlist method is preferred because SHOW SLAVE HOSTS is not reliable.
8266                                                  However, the hosts method is required if the server uses a non-standard
8267                                                  port (not 3306).  Usually mk-table-sync does the right thing and finds
8268                                                  the slaves, but you may give a preferred method and it will be used first.
8269                                                  If it doesn't find any slaves, the other methods will be tried.
8270                                                  
8271                                                  
8272                                                  =item --replace
8273                                                  
8274                                                  Write all C<INSERT> and C<UPDATE> statements as C<REPLACE>.
8275                                                  
8276                                                  This is automatically switched on as needed when there are unique index
8277                                                  violations.
8278                                                  
8279                                                  =item --replicate
8280                                                  
8281                                                  type: string
8282                                                  
8283                                                  Sync tables listed as different in this table.
8284                                                  
8285                                                  Specifies that C<mk-table-sync> should examine the specified table to find data
8286                                                  that differs.  The table is exactly the same as the argument of the same name to
8287                                                  L<mk-table-checksum>.  That is, it contains records of which tables (and ranges
8288                                                  of values) differ between the master and slave.
8289                                                  
8290                                                  For each table and range of values that shows differences between the master and
8291                                                  slave, C<mk-table-checksum> will sync that table, with the appropriate C<WHERE>
8292                                                  clause, to its master.
8293                                                  
8294                                                  This automatically sets L<"--wait"> to 60 and causes changes to be made on the
8295                                                  master instead of the slave.
8296                                                  
8297                                                  If L<"--sync-to-master"> is specified, the tool will assume the server you
8298                                                  specified is the slave, and connect to the master as usual to sync.
8299                                                  
8300                                                  Otherwise, it will try to use C<SHOW PROCESSLIST> to find slaves of the server
8301                                                  you specified.  If it is unable to find any slaves via C<SHOW PROCESSLIST>, it
8302                                                  will inspect C<SHOW SLAVE HOSTS> instead.  You must configure each slave's
8303                                                  C<report-host>, C<report-port> and other options for this to work right.  After
8304                                                  finding slaves, it will inspect the specified table on each slave to find data
8305                                                  that needs to be synced, and sync it. 
8306                                                  
8307                                                  The tool examines the master's copy of the table first, assuming that the master
8308                                                  is potentially a slave as well.  Any table that shows differences there will
8309                                                  B<NOT> be synced on the slave(s).  For example, suppose your replication is set
8310                                                  up as A->B, B->C, B->D.  Suppose you use this argument and specify server B.
8311                                                  The tool will examine server B's copy of the table.  If it looks like server B's
8312                                                  data in table C<test.tbl1> is different from server A's copy, the tool will not
8313                                                  sync that table on servers C and D.
8314                                                  
8315                                                  =item --set-vars
8316                                                  
8317                                                  type: string; default: wait_timeout=10000
8318                                                  
8319                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
8320                                                  string will be appended to SET and executed.
8321                                                  
8322                                                  =item --socket
8323                                                  
8324                                                  short form: -S; type: string
8325                                                  
8326                                                  Socket file to use for connection.
8327                                                  
8328                                                  =item --sync-to-master
8329                                                  
8330                                                  Treat the DSN as a slave and sync it to its master.
8331                                                  
8332                                                  Treat the server you specified as a slave.  Inspect C<SHOW SLAVE STATUS>,
8333                                                  connect to the server's master, and treat the master as the source and the slave
8334                                                  as the destination.  Causes changes to be made on the master.  Sets L<"--wait">
8335                                                  to 60 by default, sets L<"--lock"> to 1 by default, and disables
8336                                                  L<"--[no]transaction"> by default.  See also L<"--replicate">, which changes
8337                                                  this option's behavior.
8338                                                  
8339                                                  =item --tables
8340                                                  
8341                                                  short form: -t; type: hash
8342                                                  
8343                                                  Sync only this comma-separated list of tables.
8344                                                  
8345                                                  Table names may be qualified with the database name.
8346                                                  
8347                                                  =item --timeout-ok
8348                                                  
8349                                                  Keep going if L<"--wait"> fails.
8350                                                  
8351                                                  If you specify L<"--wait"> and the slave doesn't catch up to the master's
8352                                                  position before the wait times out, the default behavior is to abort.  This
8353                                                  option makes the tool keep going anyway.  B<Warning>: if you are trying to get a
8354                                                  consistent comparision between the two servers, you probably don't want to keep
8355                                                  going after a timeout.
8356                                                  
8357                                                  =item --[no]transaction
8358                                                  
8359                                                  Use transactions instead of C<LOCK TABLES>.
8360                                                  
8361                                                  The granularity of beginning and committing transactions is controlled by
8362                                                  L<"--lock">.  This is enabled by default, but since L<"--lock"> is disabled by
8363                                                  default, it has no effect.
8364                                                  
8365                                                  Most options that enable locking also disable transactions by default, so if
8366                                                  you want to use transactional locking (via C<LOCK IN SHARE MODE> and C<FOR
8367                                                  UPDATE>, you must specify C<--transaction> explicitly.
8368                                                  
8369                                                  If you don't specify C<--transaction> explicitly C<mk-table-sync> will decide on
8370                                                  a per-table basis whether to use transactions or table locks.  It currently
8371                                                  uses transactions on InnoDB tables, and table locks on all others.
8372                                                  
8373                                                  If C<--no-transaction> is specified, then C<mk-table-sync> will not use
8374                                                  transactions at all (not even for InnoDB tables) and locking is controlled
8375                                                  by L<"--lock">.
8376                                                  
8377                                                  =item --trim
8378                                                  
8379                                                  C<TRIM()> C<VARCHAR> columns in C<BIT_XOR> and C<ACCUM> modes.  Helps when
8380                                                  comparing MySQL 4.1 to >= 5.0.
8381                                                  
8382                                                  This is useful when you don't care about the trailing space differences between
8383                                                  MySQL versions which vary in their handling of trailing spaces. MySQL 5.0 and 
8384                                                  later all retain trailing spaces in C<VARCHAR>, while previous versions would 
8385                                                  remove them.
8386                                                  
8387                                                  =item --[no]unique-checks
8388                                                  
8389                                                  default: yes
8390                                                  
8391                                                  Enable unique key checks (C<SET UNIQUE_CHECKS=1>).
8392                                                  
8393                                                  Specifying C<--no-unique-checks> will C<SET UNIQUE_CHECKS=0>.
8394                                                  
8395                                                  =item --user
8396                                                  
8397                                                  short form: -u; type: string
8398                                                  
8399                                                  User for login if not current user.
8400                                                  
8401                                                  =item --verbose
8402                                                  
8403                                                  short form: -v; cumulative: yes
8404                                                  
8405                                                  Print results of sync operations.
8406                                                  
8407                                                  See L<"OUTPUT"> for more details about the output.
8408                                                  
8409                                                  =item --version
8410                                                  
8411                                                  Show version and exit.
8412                                                  
8413                                                  =item --wait
8414                                                  
8415                                                  short form: -w; type: time
8416                                                  
8417                                                  How long to wait for slaves to catch up to their master.
8418                                                  
8419                                                  Make the master wait for the slave to catch up in replication before comparing
8420                                                  the tables.  The value is the number of seconds to wait before timing out (see
8421                                                  also L<"--timeout-ok">).  Sets L<"--lock"> to 1 and L<"--[no]transaction"> to 0
8422                                                  by default.  If you see an error such as the following,
8423                                                  
8424                                                    MASTER_POS_WAIT returned -1
8425                                                  
8426                                                  It means the timeout was exceeded and you need to increase it.
8427                                                  
8428                                                  The default value of this option is influenced by other options.  To see what
8429                                                  value is in effect, run with L<"--help">.
8430                                                  
8431                                                  =item --where
8432                                                  
8433                                                  type: string
8434                                                  
8435                                                  C<WHERE> clause to restrict syncing to part of the table.
8436                                                  
8437                                                  =back
8438                                                  
8439                                                  =head1 DOWNLOADING
8440                                                  
8441                                                  You can download Maatkit from Google Code at
8442                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
8443                                                  easily with a command like the following:
8444                                                  
8445                                                     wget http://www.maatkit.org/get/toolname
8446                                                     or
8447                                                     wget http://www.maatkit.org/trunk/toolname
8448                                                  
8449                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
8450                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
8451                                                  needed.  The first URL gets the latest released version of the tool, and the
8452                                                  second gets the latest trunk code from Subversion.
8453                                                  
8454                                                  =head1 ENVIRONMENT
8455                                                  
8456                                                  The environment variable MKDEBUG enables verbose debugging output in all of the
8457                                                  Maatkit tools:
8458                                                  
8459                                                     MKDEBUG=1 mk-....
8460                                                  
8461                                                  =head1 SYSTEM REQUIREMENTS
8462                                                  
8463                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
8464                                                  installed in any reasonably new version of Perl.
8465                                                  
8466                                                  =head1 BUGS
8467                                                  
8468                                                  For a list of known bugs see: L<http://www.maatkit.org/bugs/mk-table-sync>.
8469                                                  
8470                                                  Please use Google Code Issues and Groups to report bugs or request support:
8471                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
8472                                                  discuss Maatkit.
8473                                                  
8474                                                  Please include the complete command-line used to reproduce the problem you are
8475                                                  seeing, the version of all MySQL servers involved, the complete output of the
8476                                                  tool when run with L<"--version">, and if possible, debugging output produced by
8477                                                  running with the C<MKDEBUG=1> environment variable.
8478                                                  
8479                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
8480                                                  
8481                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
8482                                                  Feedback and improvements are welcome.
8483                                                  
8484                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
8485                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8486                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
8487                                                  
8488                                                  This program is free software; you can redistribute it and/or modify it under
8489                                                  the terms of the GNU General Public License as published by the Free Software
8490                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
8491                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
8492                                                  licenses.
8493                                                  
8494                                                  You should have received a copy of the GNU General Public License along with
8495                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
8496                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
8497                                                  
8498                                                  =head1 AUTHOR
8499                                                  
8500                                                  Baron Schwartz
8501                                                  
8502                                                  =head1 ABOUT MAATKIT
8503                                                  
8504                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
8505                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
8506                                                  code contributors.  Both are employed by Percona.  Financial support for
8507                                                  Maatkit development is primarily provided by Percona and its clients. 
8508                                                  
8509                                                  =head1 HISTORY AND ACKNOWLEDGEMENTS
8510                                                  
8511                                                  My work is based in part on Giuseppe Maxia's work on distributed databases,
8512                                                  L<http://www.sysadminmag.com/articles/2004/0408/> and code derived from that
8513                                                  article.  There is more explanation, and a link to the code, at
8514                                                  L<http://www.perlmonks.org/?node_id=381053>.
8515                                                  
8516                                                  Another programmer extended Maxia's work even further.  Fabien Coelho changed
8517                                                  and generalized Maxia's technique, introducing symmetry and avoiding some
8518                                                  problems that might have caused too-frequent checksum collisions.  This work
8519                                                  grew into pg_comparator, L<http://www.coelho.net/pg_comparator/>.  Coelho also
8520                                                  explained the technique further in a paper titled "Remote Comparison of Database
8521                                                  Tables" (L<http://cri.ensmp.fr/classement/doc/A-375.pdf>).
8522                                                  
8523                                                  This existing literature mostly addressed how to find the differences between
8524                                                  the tables, not how to resolve them once found.  I needed a tool that would not
8525                                                  only find them efficiently, but would then resolve them.  I first began thinking
8526                                                  about how to improve the technique further with my article
8527                                                  L<http://tinyurl.com/mysql-data-diff-algorithm>,
8528                                                  where I discussed a number of problems with the Maxia/Coelho "bottom-up"
8529                                                  algorithm.  After writing that article, I began to write this tool.  I wanted to
8530                                                  actually implement their algorithm with some improvements so I was sure I
8531                                                  understood it completely.  I discovered it is not what I thought it was, and is
8532                                                  considerably more complex than it appeared to me at first.  Fabien Coelho was
8533                                                  kind enough to address some questions over email.
8534                                                  
8535                                                  The first versions of this tool implemented a version of the Coelho/Maxia
8536                                                  algorithm, which I called "bottom-up", and my own, which I called "top-down."
8537                                                  Those algorithms are considerably more complex than the current algorithms and
8538                                                  I have removed them from this tool, and may add them back later.  The
8539                                                  improvements to the bottom-up algorithm are my original work, as is the
8540                                                  top-down algorithm.  The techniques to actually resolve the differences are
8541                                                  also my own work.
8542                                                  
8543                                                  Another tool that can synchronize tables is the SQLyog Job Agent from webyog.
8544                                                  Thanks to Rohit Nadhani, SJA's author, for the conversations about the general
8545                                                  techniques.  There is a comparison of mk-table-sync and SJA at
8546                                                  L<http://tinyurl.com/maatkit-vs-sqlyog>
8547                                                  
8548                                                  Thanks to the following people and organizations for helping in many ways:
8549                                                  
8550                                                  The Rimm-Kaufman Group L<http://www.rimmkaufman.com/>,
8551                                                  MySQL AB L<http://www.mysql.com/>,
8552                                                  Blue Ridge InternetWorks L<http://www.briworks.com/>,
8553                                                  Percona L<http://www.percona.com/>,
8554                                                  Fabien Coelho,
8555                                                  Giuseppe Maxia and others at MySQL AB,
8556                                                  Kristian Koehntopp (MySQL AB),
8557                                                  Rohit Nadhani (WebYog),
8558                                                  The helpful monks at Perlmonks,
8559                                                  And others too numerous to mention.
8560                                                  
8561                                                  =head1 VERSION
8562                                                  
8563                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5713 $.
8564                                                  
8565                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
58    ***     50      0      5   unless $args{$arg}
64    ***     50      5      0   exists $args{'strict'} ? :
107   ***     50      0      5   unless open my $fh, '<', $file
127          100   5050      5   unless $para =~ /^=head1 OPTIONS/
132          100      5     10   if $para =~ /^=over/
140   ***     50      0      5   unless $para
143          100    295      5   if (my($option) = $para =~ /^=item --(.*)/)
150          100    220     75   if ($para =~ /: /) { }
154   ***     50      0    310   unless $attributes{$attrib}
158          100     65    155   if ($attribs{'short form'})
174   ***     50      0    295   if $para =~ /^=item/
176          100     50    245   if (my($base_option) = $option =~ /^\[no\](.*)/)
181          100     65    230   $attribs{'short form'} ? :
             100     50    245   $attribs{'negatable'} ? :
             100      5    290   $attribs{'cumulative'} ? :
             100    170    125   $attribs{'type'} ? :
             100     70    225   $attribs{'default'} ? :
      ***     50      0    295   $attribs{'group'} ? :
193   ***     50      0    620   unless $para
196          100      5    615   if ($para =~ /^=head1/)
200          100    295    320   if $para =~ /^=item --/
204   ***     50      0      5   unless @specs
215          100    295     10   if (ref $opt) { }
220   ***     50      0    295   if (not $long)
225   ***     50      0    295   if exists $$self{'opts'}{$long}
228   ***     50      0    295   if (length $long == 1)
233          100     65    230   if ($short) { }
234   ***     50      0     65   if exists $$self{'short_opts'}{$short}
243          100     50    245   $$opt{'spec'} =~ /!/ ? :
244          100      5    290   $$opt{'spec'} =~ /\+/ ? :
245   ***     50      0    295   $$opt{'desc'} =~ /required/ ? :
257   ***     50      0    295   if ($type and $type eq 'd' and not $$self{'dp'})
262          100     50    245   if $type and $type =~ /[HhAadzm]/
264          100     70    225   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
265   ***     50     70      0   defined $def ? :
269          100      5    290   if ($long eq 'config')
273   ***     50      0    295   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
286          100      5      5   if ($opt =~ /mutually exclusive|one and only one/)
291          100      5      5   if ($opt =~ /at least one|one and only one/)
296   ***     50      0     10   if ($opt =~ /default to/)
301   ***     50      0     10   if ($opt =~ /restricted to option groups/)
311   ***     50      0     10   unless $rule_ok
328   ***     50      0     25   unless exists $$self{'opts'}{$long}
352   ***      0      0      0   unless exists $$self{'opts'}{$long}
372   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     40      0   exists $$self{'opts'}{$opt} ? :
377   ***     50      0     40   if ($$opt{'is_cumulative'}) { }
392          100      5    215   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     75    220   exists $$self{'defaults'}{$long} ? :
401   ***     50      0      5   if (@ARGV and $ARGV[0] eq '--config')
405   ***     50      5      0   if ($self->has('config'))
411   ***     50     20      0   if ($EVAL_ERROR)
412   ***     50      0     20   $self->got('config') ? :
427   ***     50      0      5   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
430   ***     50      0      5   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
431   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
437   ***     50      0      5   if (@ARGV and $$self{'strict'})
443   ***     50      0      5   if (@set > 1)
454   ***     50      0      5   if (@set == 0)
464          100     40    255   if ($$opt{'got'}) { }
      ***     50      0    255   elsif ($$opt{'is_required'}) { }
465   ***     50      0     40   if (exists $$self{'disables'}{$long})
472   ***     50      0     40   if (exists $$self{'allowed_groups'}{$long})
484   ***      0      0      0   if $restricted_opt eq $long
485   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
490   ***      0      0      0   if (@restricted_opts)
492   ***      0      0      0   if (@restricted_opts == 1) { }
521          100    125    170   unless $opt and $$opt{'type'}
524   ***     50      0    170   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    170   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    170   elsif ($val and $$opt{'type'} eq 'z') { }
             100     25    145   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      5    140   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
527   ***      0      0      0   if (not $suffix)
533   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
534   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
549   ***      0      0      0   if ($from_key)
560   ***      0      0      0   if (defined $num) { }
561   ***      0      0      0   if ($factor)
588          100     45    555   length $opt == 1 ? :
589   ***     50      0    600   unless $long and exists $$self{'opts'}{$long}
596   ***     50      0     27   length $opt == 1 ? :
597   ***     50      0     27   unless $long and exists $$self{'opts'}{$long}
604          100     45     50   length $opt == 1 ? :
605          100     90      5   defined $long ? :
610   ***     50      0     10   length $opt == 1 ? :
611   ***     50      0     10   unless $long and exists $$self{'opts'}{$long}
638   ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
646   ***     50      0      5   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      5   elsif (scalar @{$$self{'errors'};}) { }
647   ***      0      0      0   unless print $self->print_usage
651   ***      0      0      0   unless print $self->print_errors
660   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
669   ***      0      0      0   unless $$self{'got_opts'}
672   ***      0      0      0   $$_{'is_negatable'} ? :
676   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
692   ***      0      0      0   $group eq 'default' ? :
698   ***      0      0      0   $$opt{'is_negatable'} ? :
701   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
710   ***      0      0      0   if ($short) { }
719   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
723   ***      0      0      0   if ($$self{'dp'})
731   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
743   ***      0      0      0   if ref $_[0] eq 'OptionParser'
746   ***      0      0      0   unless print $prompt
754   ***      0      0      0   unless print "\n"
757   ***      0      0      0   if ($EVAL_ERROR)
779   ***     50     20      0   unless open my $fh, '<', $filename
787   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
790   ***      0      0      0   if ($line eq '--')
795   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
813   ***     50      0      5   unless open my $fh, '<', $file
817          100   4625      5   unless $para =~ /^=pod$/m
821          100    750      5   unless $para =~ /$regex/
826   ***     50      0      5   unless close $fh
840   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
855   ***      0      0      0   defined $_ ? :
894          100      8    154   unless defined $val
895          100      2    152   if $val eq ''
897   ***     50    152      0   if (not defined $is_numeric)
898          100     77     75   $val =~ /^0|\D/ ? :
901          100     75     77   if $is_numeric
911   ***     50      7      0   if (not $tbl)
920   ***      0      0      0   unless $like
1005         100      5    236   if (@_ > 2)
1014  ***     50      0     66   if (not $dsn)
1026  ***     50    220      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1038         100     12    533   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1044         100    313    232   if (not defined $final_props{$key})
1051  ***     50      0    220   unless exists $opts{$key}
1054  ***     50      0     66   if (my $required = $self->prop('required'))
1056  ***      0      0      0   unless $final_props{$key}
1065  ***     50      0      5   unless ref $o eq 'OptionParser'
1068         100     40      5   if $o->has($_)
1078  ***      0      0      0   unless ref $dsn
1079  ***      0      0      0   $_ eq 'p' ? :
1080  ***      0      0      0   if defined $$dsn{$_}
1093  ***      0      0      0   $opts{$key}{'copy'} ? :
1107  ***     50      0     73   if ($driver eq 'Pg') { }
1139  ***     50      0     73   $cxn_string =~ /charset=utf8/ ? :
1148  ***     50      0     73   if (not $have_dbi)
1167  ***     50     73      0   if ($cxn_string =~ /mysql/i)
1175  ***     50      0     73   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1180  ***      0      0      0   if ($charset eq 'utf8') { }
1181  ***      0      0      0   unless binmode STDOUT, ':utf8'
1185  ***      0      0      0   unless binmode STDOUT
1189         100     24     49   if ($self->prop('set-vars'))
1196  ***     50      0     73   if (not $dbh and $EVAL_ERROR)
1198  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1211  ***      0      0      0   if (not $tries)
1233  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1250  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1260  ***      0      0      0   unless $dsn_1
1261  ***      0      0      0   unless $dsn_2
1265  ***      0      0      0   if ($args{'overwrite'}) { }
1266  ***      0      0      0   defined $$dsn_1{$key} ? :
1269  ***      0      0      0   defined $$dsn_2{$key} ? :
1278  ***      0      0      0   defined $_ ? :
1316         100     13     23   if (not $$self{$dbh})
1320  ***     50     36      0   $$self{$dbh} ge $self->parse($target) ? :
1327  ***      0      0      0   defined $_ ? :
1354  ***      0      0      0   unless $args{$arg}
1372  ***      0      0      0   unless $args{$arg}
1400  ***      0      0      0   $$self{'buffer_in_mysql'} ? :
1442  ***      0      0      0   defined $_ ? :
1474  ***     50      0      5   unless $args{$arg}
1483  ***     50      0      7   unless $ddl
1484  ***     50      7      0   if (ref $ddl eq 'ARRAY')
1485  ***     50      7      0   if (lc $$ddl[0] eq 'table') { }
1495  ***     50      0      7   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
1501  ***     50      7      0   if $name
1519  ***     50      0     28   unless $type
1521         100     14     14   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
1525         100      7     21   if (not $def =~ /NOT NULL/)
1529         100      7     21   $def =~ /AUTO_INCREMENT/i ? :
1560  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1574  ***      0      0      0   if ($index)
1577  ***      0      0      0   if (not $best)
1578  ***      0      0      0   if ($index) { }
1591  ***      0      0      0   unless $where
1597  ***      0      0      0   if ($$expl{'possible_keys'}) { }
1601  ***      0      0      0   if ($$expl{'key'})
1621  ***      0      0      0   unless $args{$arg}
1635  ***      0      0      0   if ($EVAL_ERROR)
1639  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
1645  ***      0      0      0   unless $args{'all_privs'}
1652  ***      0      0      0   if ($EVAL_ERROR)
1656  ***      0      0      0   if (not scalar keys %$row)
1667  ***      0      0      0   $EVAL_ERROR ? :
1672  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
1698  ***     50      0     14   if $key =~ /FOREIGN/
1703  ***     50     14      0   if (not $engine =~ /MEMORY|HEAP/)
1710  ***     50      0     14   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
1717         100      7      7   $key =~ /PRIMARY|UNIQUE/ ? :
1741         100      7      7   if ($engine =~ /InnoDB/i and not $clustered_key)
1743  ***     50      7      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
1767  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
1796  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
1806  ***      0      0      0   unless $key_ddl =~ /,$/
1813  ***      0      0      0   if (@sec_indexes)
1830  ***      0      0      0   defined $_ ? :
1855  ***     50      0      7   unless $args{'dbh'}
1864  ***     50      0    204   unless defined $args{$arg}
1879         100    154      7   !$lr && !$left_done ? :
1883         100     50    104   !$lr || $EVAL_ERROR ? :
1889         100    154      7   !$rr && !$right_done ? :
1893         100     50    104   !$rr || $EVAL_ERROR ? :
1900         100    105     56   if ($lr and $rr)
1904         100    111     50   if ($lr or $rr)
1905         100     97     14   if ($lr and $rr and defined $cmp and $cmp == 0) { }
             100      7      7   elsif (not $rr or defined $cmp and $cmp < 0) { }
1908  ***     50      0     96   if $$self{'same_row'}
1915  ***     50      0      7   if $$self{'not_in_right'}
1922  ***     50      0      7   if $$self{'not_in_left'}
1927  ***     50      0    160   if $done and &$done(%args)
1937  ***     50      0    420   unless exists $args{$arg}
1948  ***     50      0    105   if (not defined $l or not defined $r) { }
1950  ***      0      0      0   defined $r ? :
      ***      0      0      0   defined $l ? :
1953         100     74     31   if ($$tbl_struct{'is_numeric'}{$col}) { }
      ***     50      0     31   elsif ($l ne $r) { }
1955  ***     50      0     74   if $trf
1957         100      8     66   if ($cmp)
1959  ***     50      0      8   if $callback
1966  ***      0      0      0   if ($coll and $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/) { }
1976  ***      0      0      0   if ($cmp)
1978  ***      0      0      0   if $callback
1989  ***      0      0      0   if (not $$self{'sth'}{$collation})
1990  ***      0      0      0   if (not $$self{'charset_for'})
2011  ***      0      0      0   defined $_ ? :
2061  ***     50      0      5   unless defined $args{'cache'}
2069  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2071  ***      0      0      0   unless $ddl
2072  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2086  ***      0      0      0   if ($trgs and @$trgs) { }
2089  ***      0      0      0   if ($$trg{'sql_mode'})
2093  ***      0      0      0   if ($$trg{'definer'})
2125  ***     50      0     28   if (not $new)
2132  ***     50     28      0   if ($curr and $new and $curr eq $new)
2144  ***     50     14      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2157  ***     50      0     14   if ($EVAL_ERROR)
2167  ***     50     14      0   if ($key) { }
2183  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2213  ***     50      7      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2226  ***     50      0      7   if ($sth->rows)
2239  ***     50      7      0   if ($tbl)
2247  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2250  ***      0      0      0   if ($like)
2258  ***      0      0      0   unless $like
2266  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2269  ***      0      0      0   if ($like)
2284  ***      0      0      0   unless $like
2292  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2295  ***      0      0      0   if ($like)
2303  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2310  ***      0      0      0   unless $like
2318  ***      0      0      0   defined $_ ? :
2348  ***     50      0     49   unless defined $args{$arg}
2376  ***     50      0     36   unless $src
2377         100     16     20   if (lc $src eq 'left') { }
      ***     50     20      0   elsif (lc $src eq 'right') { }
2389  ***     50     36      0   if $dbh
2416         100      3     36   unless $action
2419  ***     50      0     36   $$self{'replace'} && $action ne 'DELETE' ? :
2421  ***     50      0     36   if ($$self{'queue'}) { }
2429  ***     50      0     36   if ($EVAL_ERROR =~ /$DUPE_KEY/) { }
      ***     50      0     36   elsif ($EVAL_ERROR) { }
2445  ***      0      0      0   if ($$self{'replace'})
2446  ***      0      0      0   $action eq 'DELETE' ? :
2455  ***     50      0     56   if ($queue_level and $queue_level < $$self{'queue'})
2469  ***      0      0      0   if $$row[2]
2475  ***     50      0     56   if (not $error_count++ and $EVAL_ERROR =~ /$DUPE_KEY/) { }
      ***     50      0     56   elsif ($EVAL_ERROR) { }
2499  ***     50      0     22   if ($$self{'replace'})
2505  ***     50     22      0   if (my $dbh = $$self{'fetch_back'}) { }
2526  ***     50      0     14   if ($$self{'replace'})
2541  ***     50     14      0   if (my $dbh = $$self{'fetch_back'}) { }
2564  ***     50     40      0   defined $val ? :
2578  ***     50     36      0   if ($$self{'tbl_struct'}) { }
2585  ***     50      0    144   if (not defined $$pos{$_}) { }
2594  ***     50      0     36   if @not_in_tbl
2604  ***      0      0      0   defined $_ ? :
2637  ***     50      0     10   unless $args{$arg}
2652  ***     50      0      7   unless $args{$arg}
2659  ***     50      0     14   unless $$index{'type'} eq 'BTREE'
2663  ***     50     14      0   if ($args{'exact'})
2664         100      7      7   unless $$index{'is_unique'} and @{$$index{'cols'};} == 1
2677  ***     50      0      7   unless $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2683  ***     50      7      0   if $args{'exact'} and scalar @candidate_cols
2693  ***     50      7      0   if ($$tbl_struct{'keys'}{'PRIMARY'})
2716  ***     50      0     56   unless defined $args{$arg}
2727  ***     50      7      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type eq 'timestamp') { }
      ***      0      0      0   elsif ($col_type eq 'date') { }
      ***      0      0      0   elsif ($col_type eq 'time') { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
2759  ***     50      0      7   if (not defined $start_point)
2763  ***     50      0      7   if (not defined $end_point or $end_point < $start_point)
2772  ***     50      7      0   if ($int_types{$col_type})
2776  ***     50      0      7   if ($args{'exact'})
2782  ***     50      7      0   if ($start_point < $end_point) { }
2788         100      7     24   if ($iter++ == 0) { }
2798         100      4      3   if (@chunks) { }
2802  ***     50      0      3   $nullable ? :
2804  ***     50      0      7   if ($nullable)
2820  ***      0      0      0   unless $args{$arg}
2830  ***     50      0     28   unless $args{$arg}
2839  ***     50      0      7   if ($suffix) { }
      ***     50      7      0   elsif ($num) { }
2840  ***      0      0      0   $suffix eq 'M' ? :
      ***      0      0      0   $suffix eq 'k' ? :
2852  ***     50      0      7   if ($suffix or $args{'avg_row_length'})
2855  ***      0      0      0   if (not defined $n_rows)
2856  ***      0      0      0   $avg_row_length ? :
2860  ***     50      0      7   wantarray ? :
2867  ***     50      0     28   unless $args{$arg}
2872  ***     50      0      7   $where ? :
2880  ***     50      0      7   if ($EVAL_ERROR)
2882  ***      0      0      0   if ($EVAL_ERROR =~ /in your SQL syntax/) { }
2889  ***     50      0      7   $where ? :
2902  ***     50      0     59   $val =~ /\d[:-]/ ? :
2908  ***     50      0    310   unless defined $args{$arg}
2917  ***     50      0     62   if ($args{'where'} and grep {$_;} @{$args{'where'};})
2940  ***     50      0     31   if $start =~ /e/
2941  ***     50      0     31   if $end =~ /e/
2946  ***     50     31      0   if ($end > $start) { }
2992  ***      0      0      0   unless $check eq $time
3003  ***      0      0      0   defined $_ ? :
3036  ***     50      0     10   unless defined $args{$arg}
3049  ***      0      0      0   $comp & 1 ? :
3059  ***     50      7      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64')
3079  ***     50      7      0   if ($type eq 'bigint' and $length < 20)
3093  ***     50      0     14   if $alg and not $ALGOS{$alg}
3096  ***     50     14      0   if ($args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1'))
3105  ***     50      0     14   if (not $vp->version_ge($dbh, '4.1.1'))
3110  ***     50     14      0   if ($alg and grep {$_ eq $alg;} @choices)
3115  ***      0      0      0   if ($args{'count'} and grep {$_ ne 'CHECKSUM';} @choices)
3132  ***     50      0     14   if ($args{'function'})
3145  ***     50      0     14   if ($EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/)
3151  ***     50      0     14   unless $result
3160  ***      0      0      0   if $func =~ /^(?:FNV1A_64|FNV_64|CRC32)$/i
3167  ***      0      0      0   length $unsliced < 16 ? :
3180  ***      0      0      0   if ($sliced ne $unsliced)
3187  ***      0      0      0   if ($sliced eq $unsliced) { }
3200  ***      0      0      0   unless defined $args{$arg}
3207  ***      0      0      0   if ($len > 16)
3216  ***      0      0      0   if (defined $opt_slice and $opt_slice < @slices) { }
3239  ***     50     14      0   $args{'cols'} ? :
3243  ***     50     56      0   if $cols{$_}
3245         100     14     42   if ($type eq 'timestamp') { }
      ***     50      0     42   elsif ($type =~ /float|double/ and $args{'float_precision'}) { }
      ***     50      0     42   elsif ($type =~ /varchar/ and $args{'trim'}) { }
3262         100      7      7   if (not $args{'no_cols'})
3266         100      7     21   if ($col =~ /\+ 0/)
3275  ***     50     14      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64') { }
3277  ***     50     14      0   if (@nulls)
3284  ***     50     14      0   @cols > 1 ? :
3300  ***     50      0     42   unless $args{$arg}
3308  ***     50      0      7   unless $algorithm and $ALGOS{$algorithm}
3311  ***     50      0      7   if ($algorithm eq 'CHECKSUM')
3317  ***     50      7      0   if ($algorithm eq 'BIT_XOR') { }
3318  ***     50      7      0   if ($crc_type =~ /int$/) { }
3327  ***      0      0      0   if ($crc_type =~ /int$/) { }
3340  ***     50      0      7   if ($args{'replicate'}) { }
3346  ***     50      0      7   $args{'buffer'} ? :
3376  ***      0      0      0   defined $_ ? :
3408  ***     50      0     10   unless defined $args{$arg}
3427  ***     50      0      7   unless defined $args{$arg}
3434  ***     50      0      7   unless $exact
3437  ***     50      0      7   if ($args{'chunk_col'} or $args{'chunk_index'}) { }
3441  ***      0      0      0   if ($args{'chunk_col'})
3442  ***      0      0      0   unless $chunkable_cols[$i]{'column'} eq $args{'chunk_col'}
3444  ***      0      0      0   if ($args{'chunk_index'})
3445  ***      0      0      0   unless $chunkable_cols[$i]{'index'} eq $args{'chunk_index'}
3451  ***      0      0      0   if (not $colno)
3475  ***     50      0     63   unless defined $args{$arg}
3490  ***     50      7      0   if (not $args{'replicate'}) { }
3492  ***     50      7      0   if (not grep {not defined $range_params{$_};} 'min', 'max', 'rows_in_range') { }
3519  ***     50      0      7   unless $chunk_sql
3520  ***     50      0      7   unless $row_sql
3536         100     40     62   if ($$self{'state'}) { }
3545  ***     50      0     40   $$self{'buffer_in_mysql'} ? :
      ***     50      0     40   $args{'where'} ? :
3564         100     66     31   if ($$self{'state'}) { }
             100     20     11   elsif ($$lr{'cnt'} != $$rr{'cnt'} or $$lr{'crc'} ne $$rr{'crc'}) { }
3565         100     26     40   if ($$lr{$$self{'crc_col'}} ne $$rr{$$self{'crc_col'}})
3570  ***     50     26      0   if ($$self{'same_row'})
3591  ***     50      0      7   unless $$self{'state'}
3597  ***     50      7      0   if ($$self{'not_in_right'})
3612  ***     50      0      7   unless $$self{'state'}
3618  ***     50      7      0   if ($$self{'not_in_left'})
3633         100     20     30   if ($$self{'state'} == 1) { }
3657         100     20     24   if ($$self{'state'}) { }
3670         100     31    103   if ($$self{'state'} == 0) { }
3682  ***      0      0      0   defined $_ ? :
3714  ***      0      0      0   unless defined $args{$arg}
3727  ***      0      0      0   unless defined $args{$arg}
3731  ***      0      0      0   if ($nibble_index) { }
3733  ***      0      0      0   if (not $args{'tbl_struct'}{'keys'}{$nibble_index}{'is_unique'})
3737  ***      0      0      0   if ($args{'chunk_index'} and $args{'chunk_index'} ne $nibble_index)
3749  ***      0      0      0   if ($args{'src'} and $args{'src'}{'dbh'})
3761  ***      0      0      0   if ($table_status)
3762  ***      0      0      0   defined $$table_status{'rows'} ? :
      ***      0      0      0   defined $$table_status{'Rows'} ? :
3765  ***      0      0      0   if defined $n_rows and $n_rows <= 100
3784  ***      0      0      0   unless defined $args{$arg}
3803  ***      0      0      0   if (not $args{'replicate'}) { }
3830  ***      0      0      0   unless $nibble_sql
3831  ***      0      0      0   unless $row_sql
3847  ***      0      0      0   if ($$self{'state'}) { }
3856  ***      0      0      0   $$self{'buffer_in_mysql'} ? :
      ***      0      0      0   $$self{'index_hint'} ? :
      ***      0      0      0   $args{'where'} ? :
3877  ***      0      0      0   if (not $s)
3886  ***      0      0      0   if ($$self{'cached_boundaries'})
3891  ***      0      0      0   if ($$self{'cached_row'} and $$self{'cached_nibble'} == $$self{'nibble'}) { }
3900  ***      0      0      0   if ($$self{'nibble'} == 0 and not $$self{'small_table'})
3902  ***      0      0      0   if (lc($explain_index || '') ne lc $$s{'index'})
3903  ***      0      0      0   $explain_index ? :
3914  ***      0      0      0   if ($row) { }
3924  ***      0      0      0   $lb ? :
3944  ***      0      0      0   if ($$self{'nibble'})
3960  ***      0      0      0   unless $sql
3965  ***      0      0      0   if ($EVAL_ERROR)
3976  ***      0      0      0   if ($$self{'state'}) { }
      ***      0      0      0   elsif ($$lr{'cnt'} != $$rr{'cnt'} or ($$lr{'crc'} || 0) ne ($$rr{'crc'} || 0)) { }
3977  ***      0      0      0   if ($$lr{$$self{'crc_col'}} ne $$rr{$$self{'crc_col'}})
3991  ***      0      0      0   unless $$self{'state'}
3997  ***      0      0      0   unless $$self{'state'}
4003  ***      0      0      0   if ($$self{'state'} == 1) { }
4025  ***      0      0      0   if ($$self{'state'}) { }
4038  ***      0      0      0   if ($$self{'state'} == 0) { }
4050  ***      0      0      0   defined $_ ? :
4077  ***      0      0      0   unless $args{$arg}
4095  ***      0      0      0   unless defined $args{$arg}
4129  ***      0      0      0   $$self{'buffer_in_mysql'} ? :
4144  ***      0      0      0   unless $diff
4150  ***      0      0      0   if ($lc > $rc) { }
4201  ***      0      0      0   defined $_ ? :
4233  ***     50      0     20   unless defined $args{$arg}
4242  ***     50      0     14   unless $args{$arg}
4248  ***     50      7      0   if ($can_sync)
4262  ***     50      0     56   unless $args{$arg}
4268  ***     50      0      7   if ($args{'bidirectional'} and $args{'ChangeHandler'}{'queue'})
4272  ***     50      0      7   unless defined $args{'index_hint'}
4282  ***     50      0      7   unless $plugin
4291  ***     50      7      0   if (not $args{'replicate'}) { }
4292  ***     50      7      0   $vp->version_ge($$src{'dbh'}, '4.0.9') && $vp->version_ge($$dst{'dbh'}, '4.0.9') ? :
4295  ***     50      0      7   if ($args{'chunk_index'}) { }
      ***     50      7      0   elsif ($plugin_args{'chunk_index'} and $args{'index_hint'}) { }
4320  ***     50      0      7   if ($EVAL_ERROR)
4325  ***     50      7      0   if ($plugin->uses_checksum)
4330  ***     50      0      7   if ($EVAL_ERROR)
4335  ***     50      0      7   if ($args{'dry_run'})
4344  ***     50      0      7   if ($EVAL_ERROR)
4371  ***     50     51      0   if ($args{'transaction'})
4372  ***     50     51      0   if ($args{'bidirectional'}) { }
      ***      0      0      0   elsif ($args{'changing_src'}) { }
4386  ***     50      0     51   if $callback
4393  ***     50      0     51   if ($args{'buffer_to_client'})
4399         100     31     20   if (not $cycle or not $plugin->pending_changes)
4404  ***     50     51      0   unless $executed_src
4432  ***     50      0     21   unless $args{$arg}
4451  ***     50      0      7   if ($src_algo ne $dst_algo)
4459  ***     50      0      7   if ($src_func ne $dst_func)
4469  ***     50      0      7   if ($src_algo eq 'BIT_XOR' and not $crc_type =~ /int$/)
4508  ***     50      0     30   unless defined $args{$arg}
4513  ***     50      6      0   unless $args{'lock'} and $args{'lock'} <= $args{'lock_level'}
4516  ***      0      0      0   if ($args{'transaction'}) { }
4535  ***     50      0    152   unless defined $args{$arg}
4540  ***     50     38      0   unless $args{'lock'} and $args{'lock'} == $args{'lock_level'}
4543  ***      0      0      0   if ($args{'transaction'}) { }
4554  ***      0      0      0   if ($args{'lock'} == 3) { }
4560  ***      0      0      0   if ($args{'transaction'}) { }
4561  ***      0      0      0   if ($args{'src_sth'})
4568  ***      0      0      0   $args{'changing_src'} ? :
4575  ***      0      0      0   if ($args{'wait'})
4580  ***      0      0      0   if ($args{'changing_src'}) { }
4585  ***      0      0      0   if ($args{'lock'} == 3) { }
      ***      0      0      0   elsif (not $args{'transaction'}) { }
4591  ***      0      0      0   $args{'execute'} ? :
4598  ***      0      0      0   if ($EVAL_ERROR)
4599  ***      0      0      0   if ($args{'src_sth'}{'Active'})
4603  ***      0      0      0   unless $dbh
4606  ***      0      0      0   unless $$dbh{'AutoCommit'}
4625  ***     50      0     14   $EVAL_ERROR ? :
4629  ***     50     14      0   if ($privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/ and $can_delete)
4640  ***      0      0      0   defined $_ ? :
4668  ***     50      0     10   unless $args{$arg}
4678  ***      0      0      0   unless defined $args{$arg}
4681  ***      0      0      0   $args{'cols'} ? :
4684  ***      0      0      0   unless exists $$tbl_struct{'keys'}{$index}
4693  ***      0      0      0   if ($args{'asc_first'})
4700  ***      0      0      0   if (not exists $col_posn{$col})
4716  ***      0      0      0   if (@asc_slice)
4728  ***      0      0      0   $args{'asc_only'} ? :
4740  ***      0      0      0   unless defined $args{$arg}
4761  ***      0      0      0   if ($$is_nullable{$col}) { }
4777  ***      0      0      0   if ($$is_nullable{$col}) { }
4778  ***      0      0      0   if ($type =~ /=/ and $end) { }
      ***      0      0      0   elsif ($type =~ />/) { }
4793  ***      0      0      0   $type =~ /=/ && $end ? :
4811  ***      0      0      0   $args{'cols'} ? :
4819  ***      0      0      0   unless $index
4821  ***      0      0      0   if ($index) { }
4831  ***      0      0      0   if (not exists $col_posn{$col})
4852  ***      0      0      0   if ($$tbl{'is_nullable'}{$col}) { }
4872  ***      0      0      0   unless $args{$arg}
4877  ***      0      0      0   unless @sel_cols
4882  ***      0      0      0   unless $$ins_tbl{'is_col'}{$sel_cols[$i]}
4895  ***      0      0      0   defined $_ ? :
4939  ***      0      0      0   if ($EVAL_ERROR)
4940  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
4950  ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
4955  ***      0      0      0   if ($$args{'skip_callback'})
4963  ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
4965  ***      0      0      0   unless not $$_{'master_id'}
4982  ***      0      0      0   if ($method) { }
4987  ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
5001  ***      0      0      0   if @slaves
5019  ***      0      0      0   if ($host eq 'localhost')
5036  ***      0      0      0   if (@slaves)
5041  ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
5061  ***      0      0      0   if (not $proc)
5078  ***      0      0      0   unless my $master_status = $self->get_master_status($master)
5080  ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
5082  ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
5086  ***      0      0      0   if ($port != $$slave_status{'master_port'})
5091  ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
5096  ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
5103  ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
5116  ***      0      0      0   unless my $master = $self->get_slave_status($dbh)
5123  ***     50      7      0   if (not $$self{'not_a_slave'}{$dbh})
5130  ***     50      0      7   if ($ss and %$ss)
5142  ***      0      0      0   if (not $$self{'not_a_master'}{$dbh})
5149  ***      0      0      0   if ($ms and %$ms)
5151  ***      0      0      0   if ($$ms{'file'} and $$ms{'position'})
5164  ***      0      0      0   unless defined $time
5168  ***      0      0      0   if ($ms) { }
5172  ***      0      0      0   defined $result ? :
5174  ***      0      0      0   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
5194  ***      0      0      0   if ($pos) { }
5218  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
5224  ***      0      0      0   if ($EVAL_ERROR)
5226  ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
5228  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
5233  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
5257  ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
5269  ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
5292  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5296  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5301  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
5315  ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
5330  ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
5341  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
5345  ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5349  ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5351  ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
5354  ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
5356  ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
5368  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
5380  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
5384  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5388  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5391  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
5394  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
5398  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
5400  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
5408  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
5422  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
5433  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
5455  ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
5483  ***      0      0      0   if ($$dsn{'master_host'}) { }
5491  ***      0      0      0   ($port || 3306) == 3306 ? :
5502  ***      0      0      0   defined $_ ? :
5531  ***      0      0      0   unless $args{$arg}
5534  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
5550  ***      0      0      0   unless defined(my $pid = fork)
5551  ***      0      0      0   if ($pid)
5558  ***      0      0      0   unless POSIX::setsid()
5559  ***      0      0      0   unless chdir '/'
5565  ***      0      0      0   if (-t STDIN)
5567  ***      0      0      0   unless open STDIN, '/dev/null'
5571  ***      0      0      0   if ($$self{'log_file'}) { }
5573  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
5577  ***      0      0      0   unless open STDERR, '>&STDOUT'
5581  ***      0      0      0   if (-t STDOUT)
5583  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
5586  ***      0      0      0   if (-t STDERR)
5588  ***      0      0      0   unless open STDERR, '>', '/dev/null'
5599  ***      0      0      0   $self ? :
5601  ***      0      0      0   if ($PID_file and -f $PID_file) { }
5604  ***      0      0      0   if $EVAL_ERROR
5606  ***      0      0      0   if ($pid) { }
5608  ***      0      0      0   if ($pid_is_alive) { }
5630  ***      0      0      0   if (exists $$self{'child'})
5642  ***      0      0      0   if (not $PID_file)
5649  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
5651  ***      0      0      0   unless print $PID_FH $PID
5653  ***      0      0      0   unless close $PID_FH
5662  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
5663  ***      0      0      0   unless unlink $$self{'PID_file'}
5675  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
5681  ***      0      0      0   defined $_ ? :
5712  ***     50      0      5   unless $args{$arg}
5731  ***     50      5      0   if $o->has('databases')
5733  ***     50      5      0   if $o->has('ignore-databases')
5736  ***     50      0      5   if ($o->has('databases-regex') and my $p = $o->get('databases-regex'))
5740  ***     50      0      5   if ($o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex'))
5744  ***     50      5      0   if (@permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex)
5745  ***     50      5      0   @permit_dbs ? :
      ***     50      0      5   @reject_dbs ? :
      ***     50      0      5   @dbs_regex ? :
      ***     50      0      5   @reject_dbs_regex ? :
5754  ***     50      5      0   if ($o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex'))
5764  ***     50      0      5   if ($o->get('tables'))
5767  ***      0      0      0   if ($_ =~ /\./) { }
5777  ***      0      0      0   if (@permit_qtbls)
5787  ***     50      5      0   if ($o->get('ignore-tables'))
5790  ***      0      0      0   if ($_ =~ /\./) { }
5800  ***     50      0      5   if (@reject_qtbls and not $have_qtbl)
5806  ***     50      0      5   if (keys %permit_qtbls and not @permit_dbs)
5814  ***      0      0      0   if (keys %$dbs)
5821  ***     50      0      5   if ($o->has('tables-regex') and my $p = $o->get('tables-regex'))
5825  ***     50      0      5   if ($o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex'))
5834  ***     50      5      0   if ($o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines'))
5853  ***     50      5      0   if (@permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs)
5855  ***     50      0      5   @permit_tbls ? :
      ***     50      0      5   @reject_tbls ? :
      ***     50      0      5   @tbls_regex ? :
      ***     50      0      5   @reject_tbls_regex ? :
      ***     50      0      5   @permit_qtbls ? :
      ***     50      0      5   @reject_qtbls ? :
      ***     50      5      0   @get_eng ? :
      ***     50      0      5   @permit_engs ? :
      ***     50      5      0   @reject_engs ? :
5876  ***     50      0      5   unless my $filter_sub = eval $code
5893  ***     50      0      5   unless $args{$arg}
5902  ***     50     20      0   $filter ? :
5904         100      5     15   if $_ =~ /information_schema|lost\+found/
5919  ***     50      0     10   unless $args{$arg}
5925  ***     50      5      0   if ($db) { }
5935  ***     50      5      0   $filter ? :
5936  ***     50      5      0   if (not $views)
5937  ***     50      0      5   if ($type || '') eq 'VIEW'
5957         100     10     20   if (scalar keys %$objs)
5958         100     10      5   $lc ? :
5967  ***      0      0      0   defined $_ ? :
6016  ***      0      0      0   defined $args{'p_ms'} ? :
6017  ***      0      0      0   defined $args{'p_s'} ? :
6020  ***      0      0      0   if $t < 0
6022  ***      0      0      0   if $t =~ /e/
6026  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
6047  ***      0      0      0   $p ? :
6054  ***      0      0      0   unless $secs
6056  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
6061  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
6080  ***     50      0     11   unless defined $val
6084  ***     50     11      0   if ($suffix =~ /[smhd]/) { }
6085  ***     50      0      2   $suffix eq 'h' ? :
             100      9      2   $suffix eq 'm' ? :
      ***     50      0     11   $suffix eq 's' ? :
6090  ***     50      0     11   if $prefix and $prefix eq '-'
6100  ***      0      0      0   defined $args{'p'} ? :
6101  ***      0      0      0   defined $args{'d'} ? :
6108  ***      0      0      0   $num =~ /\./ || $n ? :
6117  ***      0      0      0   $gmt ? :
6123  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
6133  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
6136  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
6145  ***     50     12      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
6146  ***     50      0     12   $gmt ? :
6149  ***     50      0     12   if (defined $us)
6161  ***     50      0     22   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
             100     10     12   elsif ($val =~ /^\d{9,}/) { }
      ***     50      0     12   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***     50     12      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
6162  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
6176  ***      0      0      0   unless $hms
6181         100      4      8   unless $hms
6186  ***      0      0      0   if $callback and ref $callback eq 'CODE'
6202  ***      0      0      0   defined $_ ? :
6268  ***     50      0      5   if ($o->get('replicate') or $o->get('sync-to-master'))
6269  ***      0      0      0   unless $o->got('wait')
6271  ***     50      0      5   if ($o->get('wait'))
6272  ***      0      0      0   unless $o->got('lock')
6274  ***     50      0      5   if ($o->get('dry-run'))
6290  ***     50      0     12   if $$dsn{'t'} and not $$dsn{'D'}
6292  ***     50      0     12   if ($$dsn{'D'} and not $$dsn{'t'})
6300  ***     50      0      5   if (not @dsns or @dsns == 1 and not $o->get('replicate') and not $o->get('sync-to-master'))
6306  ***     50      0      5   if (@dsns > 1 and $o->get('sync-to-master') and $o->get('replicate'))
6311  ***     50      0      5   if ($o->get('lock-and-rename'))
6312  ***      0      0      0   if (@dsns != 2 or not $dsns[0]{'t'} or not $dsns[1]{'t'})
6318  ***     50      5      0   if ($o->get('bidirectional'))
6319  ***     50      0      5   if ($o->get('replicate') or $o->get('sync-to-master'))
6323  ***     50      0      5   if (@dsns < 2)
6326  ***     50      0      5   if (not $o->get('conflict-column') or not $o->get('conflict-comparison'))
6333  ***     50      0      5   if ($cc and not $cc =~ /$cmp/)
6336  ***     50      0      5   if ($cc and $cc =~ /equals|matches/ and not $o->get('conflict-value'))
6346  ***     50      0      5   if ($o->get('explain-hosts'))
6359  ***     50      0      5   if ($o->get('pid'))
6407  ***     50      0      5   if $EVAL_ERROR
6415  ***     50      5      0   if ($o->get('bidirectional'))
6428  ***     50      0      5   if ($o->get('sync-to-master'))
6431  ***      0      0      0   unless my $master = $ms->get_master_dsn($dsns[0]{'dbh'}, $dsns[0], $dp)
6435  ***      0      0      0   if ($o->get('check-master'))
6447  ***     50      0      5   if ($o->get('dry-run'))
6454  ***     50      0      5   if ($o->get('lock-and-rename')) { }
      ***     50      0      5   elsif ($dsns[0]{'t'}) { }
      ***     50      0      5   elsif ($o->get('replicate')) { }
6479  ***      0      0      0   unless $args{$arg}
6502  ***      0      0      0   if ($o->get('verbose'))
6551  ***      0      0      0   unless $args{$arg}
6576  ***      0      0      0   if ($o->get('verbose'))
6577  ***      0      0      0   $o->get('dry-run') ? :
6605  ***      0      0      0   unless $args{$arg}
6632  ***      0      0      0   if ($o->get('sync-to-master')) { }
6657  ***      0      0      0   if ($o->get('verbose'))
6658  ***      0      0      0   $o->get('dry-run') ? :
6665  ***      0      0      0   if (@diffs) { }
6702  ***      0      0      0   if (not $level) { }
6716  ***      0      0      0   if ($o->get('verbose'))
6717  ***      0      0      0   $o->get('dry-run') ? :
6724  ***      0      0      0   if (@diffs) { }
6771  ***     50      0     45   unless $args{$arg}
6811  ***     50      0      7   if ($o->get('verbose'))
6812  ***      0      0      0   $o->get('dry-run') ? :
6851  ***     50      0     35   unless $args{$arg}
6855  ***     50      7      0   unless $o->get('lock') and $o->get('lock') == 3
6868  ***      0      0      0   if ($EVAL_ERROR)
6878  ***     50      0     35   unless $args{$arg}
6882  ***     50      7      0   unless $o->get('lock') and $o->get('lock') == 3
6905  ***      0      0      0   if ($EVAL_ERROR)
6920  ***     50      0     56   unless $args{$arg}
6932  ***     50      7      0   $$tbl_struct{'engine'} eq 'InnoDB' ? :
      ***     50      0      7   $o->got('transaction') ? :
6945  ***     50      7      0   unless $o->get('columns')
6950  ***     50      7      0   if (my $conflict_col = $o->get('conflict-column'))
6952  ***     50      0      7   unless grep {$_ eq $conflict_col;} @compare_columns
6958  ***     50      0      7   if ($o->get('print') and $o->get('verbose') >= 2)
6968  ***     50      0      7   $o->get('buffer-to-client') ? :
7014         100      5      1   if (sum @status{@ChangeHandler::ACTIONS})
7019         100      1      6   if ($EVAL_ERROR)
7025  ***     50      0      7   if ($o->get('verbose'))
7026  ***      0      0      0   unless $_
7039  ***     50      0     42   unless $args{$arg}
7045  ***     50      0      7   if ($o->get('sync-to-master') or $o->get('replicate')) { }
      ***     50      7      0   elsif ($o->get('check-slave')) { }
7050  ***      0      0      0   unless $can_replace
7070  ***     50      0      7   if ($slave_status and $sql_log_bin and ($log_bin || 'OFF') eq 'ON')
7085  ***     50      0     14   unless $args{$arg}
7090  ***     50      7      0   if ($o->get('execute'))
7099  ***     50      7      0   if ($o->get('print'))
7106  ***     50     36      0   if $dbh
7107  ***     50     36      0   if ($dsn)
7110  ***     50     36      0   $p ? :
7112  ***     50      0     36   unless print $sql, ";\n"
7122  ***     50      0      1   if not defined $msg
7125  ***     50      1      0   if ($database and $table)
7128  ***     50      1      0   if ($host)
7138  ***     50      0     48   unless $args{$arg}
7142  ***     50      0     24   if (not $$dsn{'p'} and $o->get('ask-pass'))
7150  ***     50      0     24   if (not $o->get('bin-log'))
7155  ***     50      0     24   if (not $o->get('unique-checks'))
7160  ***     50      0     24   if (not $o->get('foreign-key-checks'))
7182  ***     50      0     63   unless $args{$arg}
7198  ***     50      0      7   if $EVAL_ERROR
7207  ***     50      0      7   if $EVAL_ERROR
7217  ***     50      7      0   if ($o->get('check-privileges'))
7219  ***     50      0      7   if (not $syncer->have_all_privs($$src{'dbh'}, $$src{'db'}, $$src{'tbl'}))
7223  ***     50      0      7   if (not $syncer->have_all_privs($$dst{'dbh'}, $$dst{'db'}, $$dst{'tbl'}))
7230  ***     50      7      0   if ($o->get('check-triggers'))
7232  ***     50      7      0   if (not defined $$dst{'supports_triggers'})
7235  ***     50      0      7   if ($$dst{'supports_triggers'} and $du->get_triggers($$dst{'dbh'}, $q, $$dst{'db'}, $$dst{'tbl'})) { }
7250  ***      0      0      0   if not $$skip_table{$$_{'db'}}{$$_{'tbl'}} and !$databases || $$databases{$$_{'db'}}
7262  ***     50      0     24   unless $dbh
7264  ***     50     24      0   unless $$dbh{'AutoCommit'}
7276  ***      0      0      0   if $src_sql
7277  ***      0      0      0   if $dst_sql
7295         100     41     12   if ($cmp eq 'newest' or $cmp eq 'oldest') { }
             100      5      7   elsif ($cmp eq 'greatest' or $cmp eq 'least') { }
             100      3      4   elsif ($cmp eq 'equals') { }
             100      3      1   elsif ($cmp eq 'matches') { }
7296         100     35      6   $cmp eq 'newest' ? :
7299         100     11     30   if ($thr)
7306         100      5      6   if ($diff < $thr)
7313         100      1      1   ($left_val || 0) > ($right_val || 0) ? :
      ***     50      0      3   ($left_val || 0) < ($right_val || 0) ? :
             100      2      3   $cmp eq 'greatest' ? :
7315         100      1      4   if ($left_val || 0) == ($right_val || 0)
7316         100      2      3   if ($thr)
7319         100      1      1   if ($diff < $thr)
7326         100      1      1   ($right_val || '') eq $val ? :
             100      1      2   ($left_val || '') eq $val ? :
7331         100      1      1   ($right_val || '') =~ /$val/ ? :
             100      1      2   ($left_val || '') =~ /$val/ ? :
7346  ***     50      0     10   unless $args{$arg}
7374         100     13     13   if ($res == -1) { }
             100      9      4   elsif ($res == 1) { }
             100      2      2   elsif ($res == 0) { }
      ***     50      2      0   elsif ($res == 2) { }
7389  ***     50      0      2   if ($cmp eq 'equals' or $cmp eq 'matches') { }
7404         100      4     22   if ($err)
7411         100      3      1   $o->get('conflict-error') eq 'warn' ? :
7434  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
2683  ***     50      0      7   $args{'exact'} and scalar @candidate_cols

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
257   ***     66    125    170      0   $type and $type eq 'd'
      ***     33    295      0      0   $type and $type eq 'd' and not $$self{'dp'}
262          100    125    120     50   $type and $type =~ /[HhAadzm]/
401   ***     33      0      5      0   @ARGV and $ARGV[0] eq '--config'
430   ***     33      0      5      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
437   ***     33      0      5      0   @ARGV and $$self{'strict'}
521   ***     66      0    125    170   $opt and $$opt{'type'}
524   ***     66    118     52      0   $val and $$opt{'type'} eq 'm'
      ***     66    118     52      0   $val and $$opt{'type'} eq 'd'
      ***     66    118     52      0   $val and $$opt{'type'} eq 'z'
             100    103     42      5   defined $val and $$opt{'type'} eq 'h'
      ***     66    103     37      0   defined $val and $$opt{'type'} eq 'a'
589   ***     33      0      0    600   $long and exists $$self{'opts'}{$long}
597   ***     33      0      0     27   $long and exists $$self{'opts'}{$long}
611   ***     33      0      0     10   $long and exists $$self{'opts'}{$long}
701   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
795   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1038         100    220    313     12   not defined $final_props{$key} and defined $$prev{$key}
      ***     66    533      0     12   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1160  ***     66     73      0     73   not $dbh and $tries--
1196  ***     33     73      0      0   not $dbh and $EVAL_ERROR
1672  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
1710  ***     33     14      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33     14      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
1741  ***     66      0      7      7   $engine =~ /InnoDB/i and not $clustered_key
1743  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
1767  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
1878         100    109      1     50   $left_done && $right_done
1879         100      6      1    154   !$lr && !$left_done
1889         100      2      5    154   !$rr && !$right_done
1900         100     51      5    105   $lr and $rr
1905         100      1      5    105   $lr and $rr
      ***     66      6      0    105   $lr and $rr and defined $cmp
             100      6      8     97   $lr and $rr and defined $cmp and $cmp == 0
             100      1      6      2   defined $cmp and $cmp < 0
1927  ***     33    160      0      0   $done and &$done(%args)
1966  ***      0      0      0      0   $coll and $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/
2086  ***      0      0      0      0   $trgs and @$trgs
2132  ***     33      0      0     28   $curr and $new
      ***     33      0      0     28   $curr and $new and $curr eq $new
2419  ***     33     36      0      0   $$self{'replace'} && $action ne 'DELETE'
2455  ***     66      6     50      0   $queue_level and $queue_level < $$self{'queue'}
2475  ***     33      0     56      0   not $error_count++ and $EVAL_ERROR =~ /$DUPE_KEY/
2661  ***     33     14      0      0   defined $_ and next
2664  ***     66      7      0      7   $$index{'is_unique'} and @{$$index{'cols'};} == 1
2917  ***     33      0     62      0   $args{'where'} and grep {$_;} @{$args{'where'};}
3059  ***     33      0      0      7   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
3079  ***     33      0      0      7   $type eq 'bigint' and $length < 20
3093  ***     33      0     14      0   $alg and not $ALGOS{$alg}
3110  ***     33      0      0     14   $alg and grep {$_ eq $alg;} @choices
3115  ***      0      0      0      0   $args{'count'} and grep {$_ ne 'CHECKSUM';} @choices
3126  ***      0      0      0      0   $ALGOS{$algorithm} && $ALGOS{$algorithm}{'hash'}
3136  ***     33      0     14      0   @funcs and not $result
3145  ***     33     14      0      0   $EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/
3169  ***      0      0      0      0   $start < $crc_wid and $sliced ne $unsliced
3216  ***      0      0      0      0   defined $opt_slice and $opt_slice < @slices
3245  ***     33     42      0      0   $type =~ /float|double/ and $args{'float_precision'}
      ***     66     28     14      0   $type =~ /varchar/ and $args{'trim'}
3275  ***     33      0      0     14   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
3308  ***     33      0      0      7   $algorithm and $ALGOS{$algorithm}
3652         100     20     31      6   $$self{'state'} == 0 && $$self{'chunk_num'} >= scalar @{$$self{'chunks'};}
3737  ***      0      0      0      0   $args{'chunk_index'} and $args{'chunk_index'} ne $nibble_index
3749  ***      0      0      0      0   $args{'src'} and $args{'src'}{'dbh'}
3765  ***      0      0      0      0   defined $n_rows and $n_rows <= 100
3891  ***      0      0      0      0   $$self{'cached_row'} and $$self{'cached_nibble'} == $$self{'nibble'}
3900  ***      0      0      0      0   $$self{'nibble'} == 0 and not $$self{'small_table'}
4020  ***      0      0      0      0   $$self{'state'} == 0 && $$self{'nibble'}
      ***      0      0      0      0   $$self{'state'} == 0 && $$self{'nibble'} && !$$self{'cached_row'}
4268  ***     33      0      7      0   $args{'bidirectional'} and $args{'ChangeHandler'}{'queue'}
4292  ***     33      0      0      7   $vp->version_ge($$src{'dbh'}, '4.0.9') && $vp->version_ge($$dst{'dbh'}, '4.0.9')
4295  ***     33      0      0      7   $plugin_args{'chunk_index'} and $args{'index_hint'}
4469  ***     33      0      7      0   $src_algo eq 'BIT_XOR' and not $crc_type =~ /int$/
4513  ***     33      6      0      0   $args{'lock'} and $args{'lock'} <= $args{'lock_level'}
4540  ***     33     38      0      0   $args{'lock'} and $args{'lock'} == $args{'lock_level'}
4629  ***     33      0      0     14   $privs =~ /select/ and $privs =~ /insert/
      ***     33      0      0     14   $privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/
      ***     33      0      0     14   $privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/ and $can_delete
4778  ***      0      0      0      0   $type =~ /=/ and $end
4793  ***      0      0      0      0   $type =~ /=/ && $end
4950  ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
5130  ***     33      7      0      0   $ss and %$ss
5149  ***      0      0      0      0   $ms and %$ms
5151  ***      0      0      0      0   $$ms{'file'} and $$ms{'position'}
5174  ***      0      0      0      0   $stat < 0 and not $timeoutok
5315  ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
5450  ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
5455  ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
5601  ***      0      0      0      0   $PID_file and -f $PID_file
5662  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
5736  ***     33      5      0      0   $o->has('databases-regex') and my $p = $o->get('databases-regex')
5740  ***     33      5      0      0   $o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex')
5800  ***     33      5      0      0   @reject_qtbls and not $have_qtbl
5806  ***     33      5      0      0   keys %permit_qtbls and not @permit_dbs
5821  ***     33      5      0      0   $o->has('tables-regex') and my $p = $o->get('tables-regex')
5825  ***     33      5      0      0   $o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex')
5834  ***     33      0      5      0   $o->has('engines') and $o->get('engines')
      ***     33      0      0      5   $o->has('ignore-engines') and $o->get('ignore-engines')
6026  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
6090  ***     33     11      0      0   $prefix and $prefix eq '-'
6104  ***      0      0      0      0   $num >= $d and $n < @units - 1
6186  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
6290  ***     33     12      0      0   $$dsn{'t'} and not $$dsn{'D'}
6292  ***     33     12      0      0   $$dsn{'D'} and not $$dsn{'t'}
6300  ***     33      5      0      0   @dsns == 1 and not $o->get('replicate')
      ***     33      5      0      0   @dsns == 1 and not $o->get('replicate') and not $o->get('sync-to-master')
6306  ***     33      0      5      0   @dsns > 1 and $o->get('sync-to-master')
      ***     33      5      0      0   @dsns > 1 and $o->get('sync-to-master') and $o->get('replicate')
6333  ***     33      0      5      0   $cc and not $cc =~ /$cmp/
6336  ***     33      0      5      0   $cc and $cc =~ /equals|matches/
      ***     33      5      0      0   $cc and $cc =~ /equals|matches/ and not $o->get('conflict-value')
6855  ***     33      7      0      0   $o->get('lock') and $o->get('lock') == 3
6882  ***     33      7      0      0   $o->get('lock') and $o->get('lock') == 3
6958  ***     33      0      7      0   $o->get('print') and $o->get('verbose') >= 2
7070  ***     33      7      0      0   $slave_status and $sql_log_bin
      ***     33      7      0      0   $slave_status and $sql_log_bin and ($log_bin || 'OFF') eq 'ON'
7125  ***     33      0      0      1   $database and $table
7142  ***     33      0     24      0   not $$dsn{'p'} and $o->get('ask-pass')
7235  ***     33      0      7      0   $$dst{'supports_triggers'} and $du->get_triggers($$dst{'dbh'}, $q, $$dst{'db'}, $$dst{'tbl'})
7250  ***      0      0      0      0   not $$skip_table{$$_{'db'}}{$$_{'tbl'}} and !$databases || $$databases{$$_{'db'}}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0     29   $ENV{'MKDEBUG'} || 0
62    ***     50      5      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
64    ***     50      5      0   $args{'prompt'} || '<options>'
      ***     50      5      0   $args{'dp'} || undef
106   ***     50      0      5   $file ||= '/home/daniel/dev/maatkit/mk-table-sync/mk-table-sync'
247   ***     50    295      0   $$opt{'group'} ||= 'default'
529   ***      0      0      0   $s || 's'
538   ***      0      0      0   $prefix || ''
566   ***      0      0      0   $pre || ''
573          100     10     15   $val || ''
576   ***     50      5      0   $val || ''
634   ***      0      0      0   $$self{'description'} || ''
703   ***      0      0      0   $s ||= 's'
729   ***      0      0      0   $$opt{'type'} || ''
876   ***     50      0     29   $ENV{'MKDEBUG'} || 0
948   ***     50      0     29   $ENV{'MKDEBUG'} || 0
1019         100      7     59   $prev ||= {}
1020         100     12     54   $defaults ||= {}
1093  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1106  ***     50      0     73   $self->prop('dbidriver') || ''
1110  ***      0      0      0   $$info{'D'} || ''
1116  ***     50      0     73   $$info{'D'} || ''
1138         100     49     24   $opts ||= {}
1233  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1249  ***      0      0      0   $level ||= 0
1250  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1300  ***     50      0     29   $ENV{'MKDEBUG'} || 0
1349  ***     50      0     29   $ENV{'MKDEBUG'} || 0
1400  ***      0      0      0   $args{'where'} || '1=1'
1467  ***     50      0     29   $ENV{'MKDEBUG'} || 0
1686  ***     50     14      0   $engine || undef
1709  ***     50      0     14   $type || $special || 'BTREE'
1796  ***      0      0      0   $$tbl_struct{'engine'} || ''
1798  ***      0      0      0   $clustered_key ||= ''
1851  ***     50      0     29   $ENV{'MKDEBUG'} || 0
2033  ***     50      0     29   $ENV{'MKDEBUG'} || 0
2303  ***      0      0      0   $$_[1] || ''
2342  ***     50      0     29   $ENV{'MKDEBUG'} || 0
2632  ***     50      0     29   $ENV{'MKDEBUG'} || 0
2923  ***     50     62      0   $args{'index_hint'} || ''
3025  ***     50      0     29   $ENV{'MKDEBUG'} || 0
3231  ***     50      0     14   $args{'sep'} || '#'
3233  ***     50     14      0   $sep ||= '#'
3403  ***     50      0     29   $ENV{'MKDEBUG'} || 0
3545  ***     50     40      0   $$self{'index_hint'} || ''
3709  ***     50      0     29   $ENV{'MKDEBUG'} || 0
3902  ***      0      0      0   $explain_index || ''
3917  ***      0      0      0   $$self{'tbl_struct'}{'is_numeric'}{$$s{'scols'}[$i++]} || 0
3940  ***      0      0      0   $$self{'index_hint'} || ''
3948  ***      0      0      0   $$self{'tbl_struct'}{'is_numeric'}{$$s{'scols'}[$i++]} || 0
3976  ***      0      0      0   $$lr{'crc'} || 0
      ***      0      0      0   $$rr{'crc'} || 0
4072  ***     50      0     29   $ENV{'MKDEBUG'} || 0
4129  ***      0      0      0   $args{'where'} || '1=1'
4227  ***     50      0     29   $ENV{'MKDEBUG'} || 0
4273  ***     50      0      7   $args{'lock'} ||= 0
4274  ***     50      0      7   $args{'wait'} ||= 0
4275  ***     50      7      0   $args{'transaction'} ||= 0
4276  ***     50      0      7   $args{'timeout_ok'} ||= 0
4662  ***     50      0     29   $ENV{'MKDEBUG'} || 0
4921  ***     50      0     29   $ENV{'MKDEBUG'} || 0
4929  ***      0      0      0   $level ||= 0
4987  ***      0      0      0   $$dsn{'P'} || 3306
5096  ***      0      0      0   $$slave_status{'slave_io_state'} || ''
5442  ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
5491  ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
5526  ***     50      0     29   $ENV{'MKDEBUG'} || 0
5707  ***     50      0     29   $ENV{'MKDEBUG'} || 0
5937  ***     50      5      0   $type || ''
5991  ***     50      0     29   $ENV{'MKDEBUG'} || 0
6046  ***      0      0      0   $args{'p'} || 0
6048  ***      0      0      0   $of ||= 1
6053  ***      0      0      0   $secs ||= 0
6083  ***     50     11      0   $suffix || $default_suffix || 's'
6230  ***     50      0     29   $ENV{'MKDEBUG'} || 0
6889  ***      0      0      0   $o->get('replicate') || 0
      ***      0      0      0   $o->get('timeout-ok') || 0
      ***      0      0      0   $o->get('transaction') || 0
      ***      0      0      0   $o->get('wait') || 0
6968  ***     50      0      7   $o->get('replace') || $o->get('replicate') || $o->get('sync-to-master') || 0
6983  ***     50      7      0   $o->get('replicate') || $o->get('sync-to-master') || $o->get('bidirectional') || 0
7070  ***      0      0      0   $log_bin || 'OFF'
7108  ***     50     36      0   $$dsn{'h'} || $$dsn{'S'} || ''
7109  ***     50     36      0   $$dsn{'P'} || ''
7296  ***     50     35      0   $left_val || ''
      ***     50     35      0   $right_val || ''
      ***     50      6      0   $right_val || ''
      ***     50      6      0   $left_val || ''
7313  ***     50      2      0   $left_val || 0
      ***     50      2      0   $right_val || 0
      ***     50      3      0   $left_val || 0
      ***     50      3      0   $right_val || 0
7315  ***     50      5      0   $left_val || 0
      ***     50      5      0   $right_val || 0
7326  ***     50      3      0   $left_val || ''
      ***     50      2      0   $right_val || ''
7331  ***     50      3      0   $left_val || ''
      ***     50      2      0   $right_val || ''
7368  ***     50     26      0   $$lr{$col} || ''
7369  ***     50     26      0   $$rr{$col} || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
61    ***     33      5      0      0   $program_name ||= $PROGRAM_NAME
62    ***     33      5      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33      5      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
524          100     20      5    145   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      5      0    140   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1129  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1130  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1131  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1132  ***      0      0      0      0   $$dsn{'u'} ||= $user
1133  ***      0      0      0      0   $$dsn{'D'} ||= $db
1560  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1639  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
1660  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
1709  ***     33      0      0     14   $type || $special
1883  ***     66     50      0    104   !$lr || $EVAL_ERROR
1893  ***     66     50      0    104   !$rr || $EVAL_ERROR
1904         100    110      1     50   $lr or $rr
1905         100      5      2      7   not $rr or defined $cmp and $cmp < 0
1948  ***     33      0      0    105   not defined $l or not defined $r
1966  ***      0      0      0      0   $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/
      ***      0      0      0      0   $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/
2144  ***     33     14      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2183  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2213  ***     33      7      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2247  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2266  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2280  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2292  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2677  ***     33      7      0      0   $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2763  ***     33      0      0      7   not defined $end_point or $end_point < $start_point
2775  ***     33      7      0      0   $interval ||= $args{'chunk_size'}
2852  ***     33      0      0      7   $suffix or $args{'avg_row_length'}
3096  ***     33     14      0      0   $args{'where'} or $args{'chunk'}
      ***     33     14      0      0   $args{'where'} or $args{'chunk'} or $args{'replicate'}
      ***     33     14      0      0   $args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1')
3437  ***     33      0      0      7   $args{'chunk_col'} or $args{'chunk_index'}
3564         100      9     11     11   $$lr{'cnt'} != $$rr{'cnt'} or $$lr{'crc'} ne $$rr{'crc'}
3976  ***      0      0      0      0   $$lr{'cnt'} != $$rr{'cnt'} or ($$lr{'crc'} || 0) ne ($$rr{'crc'} || 0)
4399         100      7     24     20   not $cycle or not $plugin->pending_changes
4935  ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
4950  ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
4963  ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
5103  ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
5124  ***     33      0      7      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
5143  ***      0      0      0      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
5167  ***      0      0      0      0   $ms ||= $self->get_master_status($master)
5174  ***      0      0      0      0   $stat eq 'NULL' or $stat < 0 and not $timeoutok
5186  ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
5201  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
5269  ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
5330  ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
5368  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
5422  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
5675  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
5744  ***     33      5      0      0   @permit_dbs or @reject_dbs
      ***     33      5      0      0   @permit_dbs or @reject_dbs or @dbs_regex
      ***     33      5      0      0   @permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex
5754  ***     33      5      0      0   $o->has('tables') or $o->has('ignore-tables')
      ***     33      5      0      0   $o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex')
5834  ***     33      0      5      0   $o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines')
5853  ***     33      0      0      5   @permit_tbls or @reject_tbls
      ***     33      0      0      5   @permit_tbls or @reject_tbls or @tbls_regex
      ***     33      0      0      5   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex
      ***     33      0      0      5   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs
      ***     33      0      5      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs
6056  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
6083  ***     33     11      0      0   $suffix || $default_suffix
6108  ***      0      0      0      0   $num =~ /\./ || $n
6268  ***     33      0      0      5   $o->get('replicate') or $o->get('sync-to-master')
6300  ***     33      0      0      5   not @dsns or @dsns == 1 and not $o->get('replicate') and not $o->get('sync-to-master')
6312  ***      0      0      0      0   @dsns != 2 or not $dsns[0]{'t'}
      ***      0      0      0      0   @dsns != 2 or not $dsns[0]{'t'} or not $dsns[1]{'t'}
6319  ***     33      0      0      5   $o->get('replicate') or $o->get('sync-to-master')
6326  ***     33      0      0      5   not $o->get('conflict-column') or not $o->get('conflict-comparison')
6487  ***      0      0      0      0   $$dsns[0]{'dbh'} || get_cxn($$dsns[0], %args)
6494  ***      0      0      0      0   $$dsns[1]{'dbh'} || get_cxn($$dsns[1], %args)
6558  ***      0      0      0      0   $dsns[0]{'dbh'} || get_cxn($dsns[0], %args)
6568  ***      0      0      0      0   $$dsn{'dbh'} || get_cxn($dsn, %args)
      ***      0      0      0      0   $$dsn{'D'} || $$src{'db'}
      ***      0      0      0      0   $$dsn{'t'} || $$src{'tbl'}
6615  ***      0      0      0      0   $$dsns[0]{'dbh'} || get_cxn($$dsns[0], %args)
6633  ***      0      0      0      0   $$dsns[1]{'dbh'} || get_cxn($$dsns[1], %args)
6778  ***     33      0      5      0   $dsns[0]{'dbh'} || get_cxn($dsns[0], %args)
6819  ***     33      0      7      0   $$dsn{'dbh'} || get_cxn($dsn, %args)
6886  ***      0      0      0      0   $$src{'dbh'} ||= get_cxn($$src{'dsn'}, %args)
6887  ***      0      0      0      0   $$dst{'dbh'} ||= get_cxn($$dst{'dsn'}, %args)
6888  ***      0      0      0      0   $$src{'misc_dbh'} ||= get_cxn($$src{'dsn'}, %args)
6968  ***     33      0      0      7   $o->get('replace') || $o->get('replicate')
      ***     33      0      0      7   $o->get('replace') || $o->get('replicate') || $o->get('sync-to-master')
6983  ***     33      0      0      7   $args{'where'} || $o->get('where')
      ***     33      0      0      7   $o->get('replicate') || $o->get('sync-to-master')
      ***     33      0      7      0   $o->get('replicate') || $o->get('sync-to-master') || $o->get('bidirectional')
7045  ***     33      0      0      7   $o->get('sync-to-master') or $o->get('replicate')
7092  ***     33     36      0      0    ||= 
7094  ***     33     36      0      0   $dbh ||= $change_dbh
7108  ***     33     36      0      0   $$dsn{'h'} || $$dsn{'S'}
7250  ***      0      0      0      0   $$tables{$$_{'tbl'}} or $$tables{"$$_{'db'}.$$_{'tbl'}"}
      ***      0      0      0      0   not $tables or ($$tables{$$_{'tbl'}} or $$tables{"$$_{'db'}.$$_{'tbl'}"})
      ***      0      0      0      0   !$databases || $$databases{$$_{'db'}}
7295         100     35      6     12   $cmp eq 'newest' or $cmp eq 'oldest'
             100      2      3      7   $cmp eq 'greatest' or $cmp eq 'least'
7389  ***     33      0      0      2   $cmp eq 'equals' or $cmp eq 'matches'


Covered Subroutines
-------------------

Subroutine                   Count Location                                                 
---------------------------- ----- ---------------------------------------------------------
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1295
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1296
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1298
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1300
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1344
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1345
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1347
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1349
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1459
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1460
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1461
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1462
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1467
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1847
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1848
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1849
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1851
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2028
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2029
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2031
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2033
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:23  
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2335
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2336
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2337
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2342
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:24  
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2619
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2620
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2624
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2625
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2626
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2627
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2632
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3020
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3021
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3022
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3023
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3025
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3393
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3394
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3396
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3397
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3398
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3403
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:35  
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:36  
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3699
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3700
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3702
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3703
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3704
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3709
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:38  
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:39  
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:40  
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4067
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4068
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4070
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4072
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:42  
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4218
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4219
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4221
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4222
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4227
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4657
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4658
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4660
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4662
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4910
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4911
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4915
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4916
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4917
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4921
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5520
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5521
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5523
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5524
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5526
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5698
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5699
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5701
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5702
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5707
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5985
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5986
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5987
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5988
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5989
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5991
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6224
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6225
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6226
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6230
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7287
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7288
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7289
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7290
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:872 
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:873 
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:874 
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:876 
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:936 
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:937 
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:938 
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:939 
BEGIN                           29 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:948 
__ANON__                        40 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:425 
__ANON__                        10 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5911
__ANON__                        10 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5950
__ANON__                        36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7092
__ANON__                        36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7103
__ANON__                        26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7360
__ANON__                         7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7418
__ANON__                         7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7424
_get_participants               10 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:325 
_make_filter                    30 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5955
_parse_specs                     5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:211 
_pod_to_specs                    5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:105 
_read_config_file               20 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:778 
_set_option                     40 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:371 
_take_action                    36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2404
_use_db                         28 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2124
_validate_type                 295 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:520 
any_unix_timestamp              22 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6159
best_algorithm                  14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3089
calculate_chunks                 7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2713
can_sync                         7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3425
change                          39 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2413
choose_hash_func                14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3130
cmp_conflict_col                53 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7292
compare_sets                    51 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1861
disconnect                      12 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7258
done                            57 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3647
done_with_rows                  50 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3632
fetch_back                      43 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2368
find_chunk_columns               7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2650
get                            600 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:587 
get_best_plugin                  7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4240
get_change_dbh                   7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7035
get_changes                      6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2571
get_crc_type                     7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3069
get_crc_wid                      7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3057
get_create_table                14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2143
get_cxn                         24 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7135
get_cxn_params                  73 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1103
get_db_itr                       5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5890
get_dbh                         73 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1137
get_defaults_files               5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:100 
get_engine                      14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1683
get_keys                         7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1690
get_opts                         5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:388 
get_range_statistics             7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2864
get_slave_status                 7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5122
get_specs                        5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:93  
get_sql                        102 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3535
get_tbl_itr                      5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5916
get_triggers                     7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2212
got                             27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:595 
has                             95 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:603 
have_all_privs                  14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4615
inject_chunks                   62 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2906
key_cmp                        105 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1934
key_cols                       134 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3668
lock_and_wait                   38 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4531
lock_server                      7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6849
main                             5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6237
make_INSERT                     14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2524
make_UPDATE                     22 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2497
make_action_subs                 7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7082
make_checksum_queries            7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4429
make_checksum_query              7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3297
make_filter                      5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5723
make_row                        14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2539
make_row_checksum               14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3227
make_where_clause               40 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2561
name                             6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3415
new                             16 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1303
new                              5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1471
new                              7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1854
new                              5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2060
new                              7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2345
new                              5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2635
new                              5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3034
new                              5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3406
new                              5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4230
new                              5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4665
new                              5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4924
new                              5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:56  
new                              5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5710
new                              5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:879 
new                             30 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:951 
not_in_left                      7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3611
not_in_right                     7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3590
ok_to_sync                       7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7178
parse                           66 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1013
parse                           49 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1308
parse                            7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1482
parse_options                    5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1064
pending_changes                 44 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3656
prepare_sync_cycle             102 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3527
prepare_to_sync                  7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3471
print_err                        1 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7121
process_rows                    56 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2452
prop                           241 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1004
quote                           59 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2901
quote                          470 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:884 
quote_val                      162 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:892 
range_num                       31 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2936
read_para_after                  5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:812 
same_row                        97 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3561
set                             10 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:609 
set_bidirectional_callbacks      5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7344
set_callback                    15 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3419
set_checksum_queries             7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3518
set_filter                       5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5883
set_src                         36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2375
size_to_rows                     7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2827
sort_cols                       36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2576
split_unquote                    7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:908 
sync_a_table                     7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6916
sync_all                         5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6767
sync_table                       7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4258
time_to_secs                    11 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6079
unix_timestamp                  12 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6144
unlock                           6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4505
unlock_server                    7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6875
usage_or_errors                  5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:645 
uses_checksum                    7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3514
version_ge                      36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1315

Uncovered Subroutines
---------------------

Subroutine                   Count Location                                                 
---------------------------- ----- ---------------------------------------------------------
DESTROY                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5674
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6699
__get_boundaries                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3873
__get_explain_index              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3959
__make_boundary_sql              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3935
__queue                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2443
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1277
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1326
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1441
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1829
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2010
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2317
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2603
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3002
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3375
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3681
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4049
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4200
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4639
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4894
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5501
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5680
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5966
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6201
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7433
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:854 
_find_slaves_by_hosts            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5029
_find_slaves_by_processlist      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5009
_make_PID_file                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5639
_remove_PID_file                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5661
as_string                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1077
can_sync                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1365
can_sync                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3725
can_sync                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4088
catchup_to_master                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5209
catchup_to_same_pos              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5250
change_master_to                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5279
check_PID_file                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5598
check_table                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1618
clone                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:831 
copy                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1259
crc32                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3043
daemonize                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5547
db_cmp                           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1988
descr                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:633 
detach_slave                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5431
disconnect                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1242
done                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1426
done                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4017
done                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4185
done_with_rows                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1421
done_with_rows                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4002
done_with_rows                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4180
dst                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2399
dump                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2067
errors                           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:623 
fill_in_dsn                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1125
filter_diffs                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7249
find_best_index                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1572
find_possible_keys               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1590
find_replication_differences     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3354
find_slave_hosts                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4979
generate_asc_stmt                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4675
generate_cmp_where               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4738
generate_del_stmt                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4808
generate_ins_stmt                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4870
get_columns                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2181
get_connected_slaves             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5056
get_databases                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2246
get_defaults                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:361 
get_first_chunkable_column       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2818
get_fks                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1757
get_groups                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:366 
get_hostname                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1232
get_master_dsn                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5115
get_master_status                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5141
get_slave_lag                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5470
get_sql                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1397
get_sql                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3846
get_sql                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4127
get_table_list                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2291
get_table_status                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2265
get_tmp_table                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2201
has_slave_updates                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5446
is_hash_algorithm                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3125
is_master_of                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5077
key_cols                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1431
key_cols                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4036
key_cols                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4190
literal_like                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:919 
lock_and_rename                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6475
lock_table                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4497
make_DELETE                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2489
make_PID_file                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5629
make_REPLACE                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2533
make_checksum                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6194
make_sibling_of_master           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5290
make_slave_of_sibling            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5338
make_slave_of_uncle              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5377
make_xor_slices                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3198
micro_t                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6015
name                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1361
name                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3721
name                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4084
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1352
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3712
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4075
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5529
not_in_left                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1416
not_in_left                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3996
not_in_left                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4170
not_in_right                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1411
not_in_right                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3990
not_in_right                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4160
optimize_xor                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3157
opts                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:337 
parse_timestamp                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6132
pending_changes                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1436
pending_changes                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4024
pending_changes                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4195
percentage_of                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6045
pos_cmp                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5476
pos_to_string                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5495
prepare_sync_cycle               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1392
prepare_sync_cycle               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3838
prepare_sync_cycle               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4122
prepare_to_sync                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1369
prepare_to_sync                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3780
prepare_to_sync                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4092
print_active_handles             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1248
print_errors                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:658 
print_sql                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7275
print_usage                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:668 
prompt                           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:628 
prompt_noecho                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:743 
range_date                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2962
range_datetime                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2969
range_time                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2955
range_timestamp                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2977
recurse_to_slaves                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4928
remove_auto_increment            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1786
remove_secondary_indexes         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1792
repl_posn                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5454
same_row                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1406
same_row                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3974
same_row                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4138
save_error                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:618 
secs_to_time                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6052
set_checksum_queries             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1388
set_checksum_queries             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3829
set_checksum_queries             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4118
set_defaults                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:349 
short_host                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5481
short_opts                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:343 
shorten                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6099
slave_is_running                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5441
sort_indexes                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1553
src                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2394
start_slave                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5193
stop_slave                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5185
sync_one_table                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6547
sync_via_replication             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6601
timestampdiff                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2984
ts                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6116
usage                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1086
uses_checksum                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1384
uses_checksum                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3825
uses_checksum                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4114
wait_for_master                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5162


