---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...-table-sync/mk-table-sync   63.4   44.0   40.2   73.1    n/a  100.0   56.3
Total                          63.4   44.0   40.2   73.1    n/a  100.0   56.3
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:15:35 2010
Finish:       Wed Jun 23 21:15:35 2010

Run:          ./001_compare_conflict_col.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:15:37 2010
Finish:       Wed Jun 23 21:15:37 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:15:42 2010
Finish:       Wed Jun 23 21:15:49 2010

Run:          ./102_triggers.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:15:54 2010
Finish:       Wed Jun 23 21:15:57 2010

Run:          ./103_force_index.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:16:01 2010
Finish:       Wed Jun 23 21:16:02 2010

Run:          ./104_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:16:07 2010
Finish:       Wed Jun 23 21:16:08 2010

Run:          ./105_master_master.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:16:12 2010
Finish:       Wed Jun 23 21:16:26 2010

Run:          ./106_lock_and_rename.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:16:30 2010
Finish:       Wed Jun 23 21:16:32 2010

Run:          ./107_option_sanity.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:16:37 2010
Finish:       Wed Jun 23 21:16:37 2010

Run:          ./108_sync_to_differnt_db.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:16:42 2010
Finish:       Wed Jun 23 21:16:49 2010

Run:          ./109_columns.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:16:54 2010
Finish:       Wed Jun 23 21:16:56 2010

Run:          ./110_replicate_do_db.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:17:00 2010
Finish:       Wed Jun 23 21:17:07 2010

Run:          ./111_lock_level.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:17:12 2010
Finish:       Wed Jun 23 21:17:12 2010

Run:          ./112_float_precision.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:17:17 2010
Finish:       Wed Jun 23 21:17:19 2010

Run:          ./113_specify_column_or_index.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:17:23 2010
Finish:       Wed Jun 23 21:17:25 2010

Run:          ./114_filters.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:17:29 2010
Finish:       Wed Jun 23 21:17:30 2010

Run:          ./115_bidirectional.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:17:35 2010
Finish:       Wed Jun 23 21:17:46 2010

Run:          ./116_binlog_format.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:17:51 2010
Finish:       Wed Jun 23 21:17:52 2010

Run:          ./117_check_privs.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:17:57 2010
Finish:       Wed Jun 23 21:17:57 2010

Run:          ./118_hex_blob.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:18:02 2010
Finish:       Wed Jun 23 21:18:03 2010

Run:          ./201_issue_22.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:18:07 2010
Finish:       Wed Jun 23 21:18:08 2010

Run:          ./202_issue_79.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:18:13 2010
Finish:       Wed Jun 23 21:18:17 2010

Run:          ./203_issue_96.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:18:21 2010
Finish:       Wed Jun 23 21:18:23 2010

Run:          ./204_issue_262.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:18:28 2010
Finish:       Wed Jun 23 21:18:29 2010

Run:          ./205_issue_218.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:18:33 2010
Finish:       Wed Jun 23 21:18:34 2010

Run:          ./206_issue_408.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:18:38 2010
Finish:       Wed Jun 23 21:18:45 2010

Run:          ./207_issue_616.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:18:50 2010
Finish:       Wed Jun 23 21:18:51 2010

Run:          ./208_issue_627.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:18:56 2010
Finish:       Wed Jun 23 21:18:58 2010

Run:          ./209_issue_631.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:19:03 2010
Finish:       Wed Jun 23 21:19:03 2010

Run:          ./210_issue_560.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:19:08 2010
Finish:       Wed Jun 23 21:19:12 2010

Run:          ./211_issue_634.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:19:16 2010
Finish:       Wed Jun 23 21:19:17 2010

Run:          ./212_issue_644.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:19:21 2010
Finish:       Wed Jun 23 21:19:23 2010

Run:          ./213_issue_804.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:19:28 2010
Finish:       Wed Jun 23 21:19:29 2010

Run:          ./214_issue_920.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:19:33 2010
Finish:       Wed Jun 23 21:19:33 2010

Run:          ./215_issue_965.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:19:38 2010
Finish:       Wed Jun 23 21:19:38 2010

Run:          ./216_issue_996.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:19:43 2010
Finish:       Wed Jun 23 21:19:45 2010

Run:          ./217_issue_1052.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jun 23 21:19:49 2010
Finish:       Wed Jun 23 21:19:50 2010

/home/daniel/dev/maatkit/mk-table-sync/mk-table-sync

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program synchronizes data efficiently between two MySQL tables, which
4                                                     # can be on different servers.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23            36                   36           252   use strict;
              36                                 95   
              36                                243   
24            36                   36           235   use warnings FATAL => 'all';
              36                                 92   
              36                                244   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 6512 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 6322
32                                                    # This package is a copy without comments from the original.  The original
33                                                    # with comments and its test file can be found in the SVN repository at,
34                                                    #   trunk/common/OptionParser.pm
35                                                    #   trunk/common/t/OptionParser.t
36                                                    # See http://code.google.com/p/maatkit/wiki/Developers for more information.
37                                                    # ###########################################################################
38                                                    package OptionParser;
39                                                    
40            36                   36           229   use strict;
              36                                 87   
              36                                168   
41            36                   36           213   use warnings FATAL => 'all';
              36                                 92   
              36                                172   
42                                                    
43            36                   36           384   use Getopt::Long;
              36                                114   
              36                                241   
44            36                   36           272   use List::Util qw(max);
              36                                 88   
              36                                406   
45            36                   36           224   use English qw(-no_match_vars);
              36                                 85   
              36                                264   
46                                                    
47    ***     36            50     36           246   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 92   
              36                                523   
48                                                    
49                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
50                                                    
51                                                    sub new {
52            52                   52          1163      my ( $class, %args ) = @_;
53            52                                515      foreach my $arg ( qw(description) ) {
54    ***     52     50                         584         die "I need a $arg argument" unless $args{$arg};
55                                                       }
56                                                    
57            52                               1109      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
58    ***     52            33                  385      $program_name ||= $PROGRAM_NAME;
59    ***     52            33                  811      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
60                                                    
61            52                                905      my %attributes = (
62                                                          'type'       => 1,
63                                                          'short form' => 1,
64                                                          'group'      => 1,
65                                                          'default'    => 1,
66                                                          'cumulative' => 1,
67                                                          'negatable'  => 1,
68                                                       );
69                                                    
70            52                               5496      my $self = {
71                                                          strict            => 1,
72                                                          prompt            => '<options>',
73                                                          head1             => 'OPTIONS',
74                                                          skip_rules        => 0,
75                                                          item              => '--(.*)',
76                                                          attributes        => \%attributes,
77                                                          parse_attributes  => \&_parse_attribs,
78                                                    
79                                                          %args,
80                                                    
81                                                          program_name      => $program_name,
82                                                          opts              => {},
83                                                          got_opts          => 0,
84                                                          short_opts        => {},
85                                                          defaults          => {},
86                                                          groups            => {},
87                                                          allowed_groups    => {},
88                                                          errors            => [],
89                                                          rules             => [],  # desc of rules for --help
90                                                          mutex             => [],  # rule: opts are mutually exclusive
91                                                          atleast1          => [],  # rule: at least one opt is required
92                                                          disables          => {},  # rule: opt disables other opts 
93                                                          defaults_to       => {},  # rule: opt defaults to value of other opt
94                                                          DSNParser         => undef,
95                                                          default_files     => [
96                                                             "/etc/maatkit/maatkit.conf",
97                                                             "/etc/maatkit/$program_name.conf",
98                                                             "$home/.maatkit.conf",
99                                                             "$home/.$program_name.conf",
100                                                         ],
101                                                         types             => {
102                                                            string => 's', # standard Getopt type
103                                                            int    => 'i', # standard Getopt type
104                                                            float  => 'f', # standard Getopt type
105                                                            Hash   => 'H', # hash, formed from a comma-separated list
106                                                            hash   => 'h', # hash as above, but only if a value is given
107                                                            Array  => 'A', # array, similar to Hash
108                                                            array  => 'a', # array, similar to hash
109                                                            DSN    => 'd', # DSN
110                                                            size   => 'z', # size with kMG suffix (powers of 2^10)
111                                                            time   => 'm', # time, with an optional suffix of s/h/m/d
112                                                         },
113                                                      };
114                                                   
115           52                               1107      return bless $self, $class;
116                                                   }
117                                                   
118                                                   sub get_specs {
119           26                   26           173      my ( $self, $file ) = @_;
120   ***     26            50                  231      $file ||= __FILE__;
121           26                               3065      my @specs = $self->_pod_to_specs($file);
122           26                               1326      $self->_parse_specs(@specs);
123                                                   
124   ***     26     50                        1486      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
125           26                                122      my $contents = do { local $/ = undef; <$fh> };
              26                                271   
              26                              20587   
126           26                                278      close $file;
127   ***     26     50                        4888      if ( $contents =~ m/^=head1 DSN OPTIONS/m ) {
128           26                                114         MKDEBUG && _d('Parsing DSN OPTIONS');
129           26                                297         my $dsn_attribs = {
130                                                            dsn  => 1,
131                                                            copy => 1,
132                                                         };
133                                                         my $parse_dsn_attribs = sub {
134          234                  234          1448            my ( $self, $option, $attribs ) = @_;
135          442                               1996            map {
136          234                               1592               my $val = $attribs->{$_};
137   ***    442     50                        3036               if ( $val ) {
138   ***    442     50                        2955                  $val    = $val eq 'yes' ? 1
                    100                               
139                                                                          : $val eq 'no'  ? 0
140                                                                          :                 $val;
141          442                               4108                  $attribs->{$_} = $val;
142                                                               }
143                                                            } keys %$attribs;
144                                                            return {
145          234                               4432               key => $option,
146                                                               %$attribs,
147                                                            };
148           26                                512         };
149           26                                465         my $dsn_o = new OptionParser(
150                                                            description       => 'DSN OPTIONS',
151                                                            head1             => 'DSN OPTIONS',
152                                                            dsn               => 0,         # XXX don't infinitely recurse!
153                                                            item              => '\* (.)',  # key opts are a single character
154                                                            skip_rules        => 1,         # no rules before opts
155                                                            attributes        => $dsn_attribs,
156                                                            parse_attributes  => $parse_dsn_attribs,
157                                                         );
158          234                               3585         my @dsn_opts = map {
159           26                                258            my $opts = {
160                                                               key  => $_->{spec}->{key},
161                                                               dsn  => $_->{spec}->{dsn},
162                                                               copy => $_->{spec}->{copy},
163                                                               desc => $_->{desc},
164                                                            };
165          234                               1109            $opts;
166                                                         } $dsn_o->_pod_to_specs($file);
167           26                               1036         $self->{DSNParser} = DSNParser->new(opts => \@dsn_opts);
168                                                      }
169                                                   
170           26                                 91      return;
171                                                   }
172                                                   
173                                                   sub DSNParser {
174           26                   26           139      my ( $self ) = @_;
175           26                                164      return $self->{DSNParser};
176                                                   };
177                                                   
178                                                   sub get_defaults_files {
179           26                   26           152      my ( $self ) = @_;
180           26                                116      return @{$self->{default_files}};
              26                                434   
181                                                   }
182                                                   
183                                                   sub _pod_to_specs {
184           52                   52           379      my ( $self, $file ) = @_;
185   ***     52            50                  336      $file ||= __FILE__;
186   ***     52     50                        2939      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
187                                                   
188           52                                275      my @specs = ();
189           52                                225      my @rules = ();
190           52                                196      my $para;
191                                                   
192           52                                595      local $INPUT_RECORD_SEPARATOR = '';
193           52                               1435      while ( $para = <$fh> ) {
194        62556    100                      795617         next unless $para =~ m/^=head1 $self->{head1}/;
195           52                                277         last;
196                                                      }
197                                                   
198           52                                619      while ( $para = <$fh> ) {
199          130    100                        1012         last if $para =~ m/^=over/;
200           78    100                         644         next if $self->{skip_rules};
201           52                                243         chomp $para;
202           52                                624         $para =~ s/\s+/ /g;
203           52                               1934         $para =~ s/$POD_link_re/$1/go;
204           52                                195         MKDEBUG && _d('Option rule:', $para);
205           52                                645         push @rules, $para;
206                                                      }
207                                                   
208   ***     52     50                         344      die "POD has no $self->{head1} section" unless $para;
209                                                   
210           52                                230      do {
211         1846    100                       25862         if ( my ($option) = $para =~ m/^=item $self->{item}/ ) {
212         1794                               7059            chomp $para;
213         1794                               5456            MKDEBUG && _d($para);
214         1794                               6010            my %attribs;
215                                                   
216         1794                              10540            $para = <$fh>; # read next paragraph, possibly attributes
217                                                   
218         1794    100                       11367            if ( $para =~ m/: / ) { # attributes
219         1404                              10066               $para =~ s/\s+\Z//g;
220         2080                              15103               %attribs = map {
221         1404                              10658                     my ( $attrib, $val) = split(/: /, $_);
222   ***   2080     50                       17044                     die "Unrecognized attribute for --$option: $attrib"
223                                                                        unless $self->{attributes}->{$attrib};
224         2080                              17898                     ($attrib, $val);
225                                                                  } split(/; /, $para);
226         1404    100                        9478               if ( $attribs{'short form'} ) {
227          338                               2514                  $attribs{'short form'} =~ s/-//;
228                                                               }
229         1404                               8862               $para = <$fh>; # read next paragraph, probably short help desc
230                                                            }
231                                                            else {
232          390                               1302               MKDEBUG && _d('Option has no attributes');
233                                                            }
234                                                   
235         1794                              18383            $para =~ s/\s+\Z//g;
236         1794                              16937            $para =~ s/\s+/ /g;
237         1794                              13925            $para =~ s/$POD_link_re/$1/go;
238                                                   
239         1794                              10201            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
240         1794                               5613            MKDEBUG && _d('Short help:', $para);
241                                                   
242   ***   1794     50                       11671            die "No description after option spec $option" if $para =~ m/^=item/;
243                                                   
244         1794    100                       13379            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
245          286                               1115               $option = $base_option;
246          286                               1517               $attribs{'negatable'} = 1;
247                                                            }
248                                                   
249         1794    100                       15316            push @specs, {
      ***            50                               
250                                                               spec  => $self->{parse_attributes}->($self, $option, \%attribs), 
251                                                               desc  => $para
252                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
253                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
254                                                            };
255                                                         }
256         1846                              21155         while ( $para = <$fh> ) {
257   ***   3666     50                       18638            last unless $para;
258         3666    100                       23621            if ( $para =~ m/^=head1/ ) {
259           52                                243               $para = undef; # Can't 'last' out of a do {} block.
260           52                                408               last;
261                                                            }
262         3614    100                       38400            last if $para =~ m/^=item /;
263                                                         }
264                                                      } while ( $para );
265                                                   
266   ***     52     50                         319      die "No valid specs in $self->{head1}" unless @specs;
267                                                   
268           52                               1637      close $fh;
269           52                                257      return @specs, @rules;
270                                                   }
271                                                   
272                                                   sub _parse_specs {
273           26                   26           495      my ( $self, @specs ) = @_;
274           26                                214      my %disables; # special rule that requires deferred checking
275                                                   
276           26                                233      foreach my $opt ( @specs ) {
277         1612    100                        8532         if ( ref $opt ) { # It's an option spec, not a rule.
278                                                            MKDEBUG && _d('Parsing opt spec:',
279         1560                               4646               map { ($_, '=>', $opt->{$_}) } keys %$opt);
280                                                   
281         1560                              16703            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
282   ***   1560     50                        9489            if ( !$long ) {
283   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
284                                                            }
285         1560                               7993            $opt->{long} = $long;
286                                                   
287   ***   1560     50                       11184            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
288         1560                              10270            $self->{opts}->{$long} = $opt;
289                                                   
290   ***   1560     50                        8956            if ( length $long == 1 ) {
291   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
292   ***      0                                  0               $self->{short_opts}->{$long} = $long;
293                                                            }
294                                                   
295         1560    100                        7546            if ( $short ) {
296   ***    338     50                        2376               die "Duplicate short option -$short"
297                                                                  if exists $self->{short_opts}->{$short};
298          338                               2565               $self->{short_opts}->{$short} = $long;
299          338                               1741               $opt->{short} = $short;
300                                                            }
301                                                            else {
302         1222                               6243               $opt->{short} = undef;
303                                                            }
304                                                   
305         1560    100                       12602            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
306         1560    100                       11467            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
307   ***   1560     50                       12840            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
308                                                   
309   ***   1560            50                 9336            $opt->{group} ||= 'default';
310         1560                              11425            $self->{groups}->{ $opt->{group} }->{$long} = 1;
311                                                   
312         1560                               7380            $opt->{value} = undef;
313         1560                               7276            $opt->{got}   = 0;
314                                                   
315         1560                              11699            my ( $type ) = $opt->{spec} =~ m/=(.)/;
316         1560                               8612            $opt->{type} = $type;
317         1560                               4535            MKDEBUG && _d($long, 'type:', $type);
318                                                   
319                                                   
320         1560    100    100                17421            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
321                                                   
322         1560    100                       14550            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
323   ***    390     50                        3241               $self->{defaults}->{$long} = defined $def ? $def : 1;
324          390                               1300               MKDEBUG && _d($long, 'default:', $def);
325                                                            }
326                                                   
327         1560    100                        8917            if ( $long eq 'config' ) {
328           26                                239               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
329                                                            }
330                                                   
331   ***   1560     50                       11616            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
332   ***      0                                  0               $disables{$long} = $dis;
333   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
334                                                            }
335                                                   
336         1560                              11118            $self->{opts}->{$long} = $opt;
337                                                         }
338                                                         else { # It's an option rule, not a spec.
339           52                                173            MKDEBUG && _d('Parsing rule:', $opt); 
340           52                                192            push @{$self->{rules}}, $opt;
              52                                369   
341           52                                458            my @participants = $self->_get_participants($opt);
342           52                                239            my $rule_ok = 0;
343                                                   
344           52    100                         645            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
345           26                                121               $rule_ok = 1;
346           26                                116               push @{$self->{mutex}}, \@participants;
              26                                186   
347           26                                110               MKDEBUG && _d(@participants, 'are mutually exclusive');
348                                                            }
349           52    100                         614            if ( $opt =~ m/at least one|one and only one/ ) {
350           26                                106               $rule_ok = 1;
351           26                                106               push @{$self->{atleast1}}, \@participants;
              26                                192   
352           26                                109               MKDEBUG && _d(@participants, 'require at least one');
353                                                            }
354   ***     52     50                         426            if ( $opt =~ m/default to/ ) {
355   ***      0                                  0               $rule_ok = 1;
356   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
357   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
358                                                            }
359   ***     52     50                         415            if ( $opt =~ m/restricted to option groups/ ) {
360   ***      0                                  0               $rule_ok = 1;
361   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
362   ***      0                                  0               my @groups = split(',', $groups);
363   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
364   ***      0                                  0                  s/\s+//;
365   ***      0                                  0                  $_ => 1;
366                                                               } @groups;
367                                                            }
368                                                   
369   ***     52     50                         438            die "Unrecognized option rule: $opt" unless $rule_ok;
370                                                         }
371                                                      }
372                                                   
373           26                                232      foreach my $long ( keys %disables ) {
374   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
375   ***      0                                  0         $self->{disables}->{$long} = \@participants;
376   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
377                                                      }
378                                                   
379           26                                267      return; 
380                                                   }
381                                                   
382                                                   sub _get_participants {
383           52                   52           365      my ( $self, $str ) = @_;
384           52                                226      my @participants;
385           52                                788      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
386   ***    130     50                         970         die "Option --$long does not exist while processing rule $str"
387                                                            unless exists $self->{opts}->{$long};
388          130                                770         push @participants, $long;
389                                                      }
390           52                                201      MKDEBUG && _d('Participants for', $str, ':', @participants);
391           52                                511      return @participants;
392                                                   }
393                                                   
394                                                   sub opts {
395   ***      0                    0             0      my ( $self ) = @_;
396   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
397   ***      0                                  0      return %opts;
398                                                   }
399                                                   
400                                                   sub short_opts {
401   ***      0                    0             0      my ( $self ) = @_;
402   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
403   ***      0                                  0      return %short_opts;
404                                                   }
405                                                   
406                                                   sub set_defaults {
407   ***      0                    0             0      my ( $self, %defaults ) = @_;
408   ***      0                                  0      $self->{defaults} = {};
409   ***      0                                  0      foreach my $long ( keys %defaults ) {
410   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
411                                                            unless exists $self->{opts}->{$long};
412   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
413   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
414                                                      }
415   ***      0                                  0      return;
416                                                   }
417                                                   
418                                                   sub get_defaults {
419   ***      0                    0             0      my ( $self ) = @_;
420   ***      0                                  0      return $self->{defaults};
421                                                   }
422                                                   
423                                                   sub get_groups {
424   ***      0                    0             0      my ( $self ) = @_;
425   ***      0                                  0      return $self->{groups};
426                                                   }
427                                                   
428                                                   sub _set_option {
429          124                  124           730      my ( $self, $opt, $val ) = @_;
430   ***    124      0                         341      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
431                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
432                                                               : die "Getopt::Long gave a nonexistent option: $opt";
433                                                   
434          124                                307      $opt = $self->{opts}->{$long};
435          124    100                         981      if ( $opt->{is_cumulative} ) {
436            8                                 36         $opt->{value}++;
437                                                      }
438                                                      else {
439          116                                584         $opt->{value} = $val;
440                                                      }
441          124                                556      $opt->{got} = 1;
442          124                                615      MKDEBUG && _d('Got option', $long, '=', $val);
443                                                   }
444                                                   
445                                                   sub get_opts {
446           26                   26           180      my ( $self ) = @_; 
447                                                   
448           26                                115      foreach my $long ( keys %{$self->{opts}} ) {
              26                                870   
449         1560                               9129         $self->{opts}->{$long}->{got} = 0;
450         1560    100                       18874         $self->{opts}->{$long}->{value}
                    100                               
451                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
452                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
453                                                            : undef;
454                                                      }
455           26                                282      $self->{got_opts} = 0;
456                                                   
457           26                                161      $self->{errors} = [];
458                                                   
459   ***     26     50     33                  598      if ( @ARGV && $ARGV[0] eq "--config" ) {
460   ***      0                                  0         shift @ARGV;
461   ***      0                                  0         $self->_set_option('config', shift @ARGV);
462                                                      }
463   ***     26     50                         358      if ( $self->has('config') ) {
464           26                                 94         my @extra_args;
465           26                                321         foreach my $filename ( split(',', $self->get('config')) ) {
466          104                                373            eval {
467          104                                785               push @extra_args, $self->_read_config_file($filename);
468                                                            };
469   ***    104     50                         775            if ( $EVAL_ERROR ) {
470   ***    104     50                         630               if ( $self->got('config') ) {
471   ***      0                                  0                  die $EVAL_ERROR;
472                                                               }
473                                                               elsif ( MKDEBUG ) {
474                                                                  _d($EVAL_ERROR);
475                                                               }
476                                                            }
477                                                         }
478           26                                219         unshift @ARGV, @extra_args;
479                                                      }
480                                                   
481           26                                424      Getopt::Long::Configure('no_ignore_case', 'bundling');
482                                                      GetOptions(
483         1534                  124         16373         map    { $_->{spec} => sub { $self->_set_option(@_); } }
             124                                806   
            1560                               8497   
484           26                                315         grep   { $_->{long} ne 'config' } # --config is handled specially above.
485   ***     26     50                         123         values %{$self->{opts}}
486                                                      ) or $self->save_error('Error parsing options');
487                                                   
488   ***     26     50     33                 3490      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
489   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
490                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
491                                                               or die "Cannot print: $OS_ERROR";
492   ***      0                                  0         exit 0;
493                                                      }
494                                                   
495   ***     26     50     33                  570      if ( @ARGV && $self->{strict} ) {
496   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
497                                                      }
498                                                   
499           26                                105      foreach my $mutex ( @{$self->{mutex}} ) {
              26                                220   
500           26                                151         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
              52                                384   
501   ***     26     50                         292         if ( @set > 1 ) {
502   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
503   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
504                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
505                                                                    . ' are mutually exclusive.';
506   ***      0                                  0            $self->save_error($err);
507                                                         }
508                                                      }
509                                                   
510           26                                120      foreach my $required ( @{$self->{atleast1}} ) {
              26                                192   
511           26                                154         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
              78                                572   
512   ***     26     50                         236         if ( @set == 0 ) {
513   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
514   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
515                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
516   ***      0                                  0            $self->save_error("Specify at least one of $err");
517                                                         }
518                                                      }
519                                                   
520           26                                111      $self->_check_opts( keys %{$self->{opts}} );
              26                                675   
521           26                                272      $self->{got_opts} = 1;
522           26                                108      return;
523                                                   }
524                                                   
525                                                   sub _check_opts {
526           26                   26           729      my ( $self, @long ) = @_;
527           26                                221      my $long_last = scalar @long;
528           26                                176      while ( @long ) {
529           26                                306         foreach my $i ( 0..$#long ) {
530         1560                               6380            my $long = $long[$i];
531   ***   1560     50                        7221            next unless $long;
532         1560                               7987            my $opt  = $self->{opts}->{$long};
533         1560    100                       11479            if ( $opt->{got} ) {
      ***            50                               
534   ***    120     50                         769               if ( exists $self->{disables}->{$long} ) {
535   ***      0                                  0                  my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
536   ***      0                                  0                  map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
537   ***      0                                  0                  MKDEBUG && _d('Unset options', @disable_opts,
538                                                                     'because', $long,'disables them');
539                                                               }
540                                                   
541   ***    120     50                         796               if ( exists $self->{allowed_groups}->{$long} ) {
542                                                   
543   ***      0                                  0                  my @restricted_groups = grep {
544   ***      0                                  0                     !exists $self->{allowed_groups}->{$long}->{$_}
545   ***      0                                  0                  } keys %{$self->{groups}};
546                                                   
547   ***      0                                  0                  my @restricted_opts;
548   ***      0                                  0                  foreach my $restricted_group ( @restricted_groups ) {
549   ***      0                                  0                     RESTRICTED_OPT:
550   ***      0                                  0                     foreach my $restricted_opt (
551                                                                        keys %{$self->{groups}->{$restricted_group}} )
552                                                                     {
553   ***      0      0                           0                        next RESTRICTED_OPT if $restricted_opt eq $long;
554   ***      0      0                           0                        push @restricted_opts, $restricted_opt
555                                                                           if $self->{opts}->{$restricted_opt}->{got};
556                                                                     }
557                                                                  }
558                                                   
559   ***      0      0                           0                  if ( @restricted_opts ) {
560   ***      0                                  0                     my $err;
561   ***      0      0                           0                     if ( @restricted_opts == 1 ) {
562   ***      0                                  0                        $err = "--$restricted_opts[0]";
563                                                                     }
564                                                                     else {
565   ***      0                                  0                        $err = join(', ',
566   ***      0                                  0                                  map { "--$self->{opts}->{$_}->{long}" }
567   ***      0                                  0                                  grep { $_ } 
568                                                                                  @restricted_opts[0..scalar(@restricted_opts) - 2]
569                                                                               )
570                                                                             . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
571                                                                     }
572   ***      0                                  0                     $self->save_error("--$long is not allowed with $err");
573                                                                  }
574                                                               }
575                                                   
576                                                            }
577                                                            elsif ( $opt->{is_required} ) { 
578   ***      0                                  0               $self->save_error("Required option --$long must be specified");
579                                                            }
580                                                   
581         1560                               7492            $self->_validate_type($opt);
582   ***   1560     50                        7607            if ( $opt->{parsed} ) {
583         1560                               7477               delete $long[$i];
584                                                            }
585                                                            else {
586   ***      0                                  0               MKDEBUG && _d('Temporarily failed to parse', $long);
587                                                            }
588                                                         }
589                                                   
590   ***     26     50                         264         die "Failed to parse options, possibly due to circular dependencies"
591                                                            if @long == $long_last;
592           26                                176         $long_last = @long;
593                                                      }
594                                                   
595           26                                130      return;
596                                                   }
597                                                   
598                                                   sub _validate_type {
599         1560                 1560          7280      my ( $self, $opt ) = @_;
600   ***   1560     50                        7651      return unless $opt;
601                                                   
602         1560    100                        9258      if ( !$opt->{type} ) {
603          676                               2983         $opt->{parsed} = 1;
604          676                               2460         return;
605                                                      }
606                                                   
607          884                               3846      my $val = $opt->{value};
608                                                   
609   ***    884     50     66                30118      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
                    100    100                        
                    100    100                        
      ***                   66                        
      ***                   66                        
610   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
611   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
612   ***      0      0                           0         if ( !$suffix ) {
613   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
614   ***      0             0                    0            $suffix = $s || 's';
615   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
616                                                               $opt->{long}, '(value:', $val, ')');
617                                                         }
618   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
619   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
620                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
621                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
622                                                                 :                  $num * 86400;   # Days
623   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
624   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
625                                                         }
626                                                         else {
627   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
628                                                         }
629                                                      }
630                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
631   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
632   ***      0                                  0         my $prev = {};
633   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
634   ***      0      0                           0         if ( $from_key ) {
635   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
636   ***      0      0                           0            if ( $self->{opts}->{$from_key}->{parsed} ) {
637   ***      0                                  0               $prev = $self->{opts}->{$from_key}->{value};
638                                                            }
639                                                            else {
640   ***      0                                  0               MKDEBUG && _d('Cannot parse', $opt->{long}, 'until',
641                                                                  $from_key, 'parsed');
642   ***      0                                  0               return;
643                                                            }
644                                                         }
645   ***      0                                  0         my $defaults = $self->{DSNParser}->parse_options($self);
646   ***      0                                  0         $opt->{value} = $self->{DSNParser}->parse($val, $prev, $defaults);
647                                                      }
648                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
649   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
650   ***      0                                  0         $self->_parse_size($opt, $val);
651                                                      }
652                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
653          115           100                 1758         $opt->{value} = { map { $_ => 1 } split(/(?<!\\),\s*/, ($val || '')) };
              63                                497   
654                                                      }
655                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
656   ***     26            50                  470         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
657                                                      }
658                                                      else {
659          743                               2299         MKDEBUG && _d('Nothing to validate for option',
660                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
661                                                      }
662                                                   
663          884                               4006      $opt->{parsed} = 1;
664          884                               3212      return;
665                                                   }
666                                                   
667                                                   sub get {
668         2456                 2456         12401      my ( $self, $opt ) = @_;
669         2456    100                       13819      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
670   ***   2456     50     33                28828      die "Option $opt does not exist"
671                                                         unless $long && exists $self->{opts}->{$long};
672         2456                              26111      return $self->{opts}->{$long}->{value};
673                                                   }
674                                                   
675                                                   sub got {
676          144                  144           911      my ( $self, $opt ) = @_;
677   ***    144     50                         947      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
678   ***    144     50     33                 2039      die "Option $opt does not exist"
679                                                         unless $long && exists $self->{opts}->{$long};
680          144                               1546      return $self->{opts}->{$long}->{got};
681                                                   }
682                                                   
683                                                   sub has {
684          346                  346          1849      my ( $self, $opt ) = @_;
685          346    100                        2430      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
686          346    100                        4287      return defined $long ? exists $self->{opts}->{$long} : 0;
687                                                   }
688                                                   
689                                                   sub set {
690           21                   21           134      my ( $self, $opt, $val ) = @_;
691   ***     21     50                         131      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
692   ***     21     50     33                  353      die "Option $opt does not exist"
693                                                         unless $long && exists $self->{opts}->{$long};
694           21                                121      $self->{opts}->{$long}->{value} = $val;
695           21                                 83      return;
696                                                   }
697                                                   
698                                                   sub save_error {
699   ***      0                    0             0      my ( $self, $error ) = @_;
700   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
701                                                   }
702                                                   
703                                                   sub errors {
704   ***      0                    0             0      my ( $self ) = @_;
705   ***      0                                  0      return $self->{errors};
706                                                   }
707                                                   
708                                                   sub prompt {
709   ***      0                    0             0      my ( $self ) = @_;
710   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
711                                                   }
712                                                   
713                                                   sub descr {
714   ***      0                    0             0      my ( $self ) = @_;
715   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
716                                                                 . "  For more details, please use the --help option, "
717                                                                 . "or try 'perldoc $PROGRAM_NAME' "
718                                                                 . "for complete documentation.";
719   ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
720                                                         unless $ENV{DONT_BREAK_LINES};
721   ***      0                                  0      $descr =~ s/ +$//mg;
722   ***      0                                  0      return $descr;
723                                                   }
724                                                   
725                                                   sub usage_or_errors {
726           26                   26           152      my ( $self ) = @_;
727   ***     26     50                         211      if ( $self->{opts}->{help}->{got} ) {
      ***     26     50                         297   
728   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
729   ***      0                                  0         exit 0;
730                                                      }
731                                                      elsif ( scalar @{$self->{errors}} ) {
732   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
733   ***      0                                  0         exit 0;
734                                                      }
735           26                                113      return;
736                                                   }
737                                                   
738                                                   sub print_errors {
739   ***      0                    0             0      my ( $self ) = @_;
740   ***      0                                  0      my $usage = $self->prompt() . "\n";
741   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
742   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
743                                                                 . "\n";
744                                                      }
745   ***      0                                  0      return $usage . "\n" . $self->descr();
746                                                   }
747                                                   
748                                                   sub print_usage {
749   ***      0                    0             0      my ( $self ) = @_;
750   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
751   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
752                                                   
753   ***      0      0                           0      my $maxl = max(
754   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
755                                                         @opts);
756                                                   
757   ***      0      0                           0      my $maxs = max(0,
758   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
759   ***      0                                  0         values %{$self->{short_opts}});
760                                                   
761   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
762   ***      0                                  0      my $rcol = 80 - $lcol - 6;
763   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
764                                                   
765   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
766                                                   
767   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
768                                                   
769   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
770   ***      0                                  0      push @groups, 'default';
771                                                   
772   ***      0                                  0      foreach my $group ( reverse @groups ) {
773   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
774   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
775   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
776                                                            grep { $_->{group} eq $group }
777                                                            @opts )
778                                                         {
779   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
780   ***      0                                  0            my $short = $opt->{short};
781   ***      0                                  0            my $desc  = $opt->{desc};
782   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
783   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
784   ***      0             0                    0               $s    ||= 's';
785   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
786   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
787                                                                      . "d=days; if no suffix, $s is used.";
788                                                            }
789   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
790   ***      0                                  0            $desc =~ s/ +$//mg;
791   ***      0      0                           0            if ( $short ) {
792   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
793                                                            }
794                                                            else {
795   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
796                                                            }
797                                                         }
798                                                      }
799                                                   
800   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
801   ***      0                                  0         $usage .= "\nRules:\n\n";
802   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
803                                                      }
804   ***      0      0                           0      if ( $self->{DSNParser} ) {
805   ***      0                                  0         $usage .= "\n" . $self->{DSNParser}->usage();
806                                                      }
807   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
808   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
809   ***      0                                  0         my $val   = $opt->{value};
810   ***      0             0                    0         my $type  = $opt->{type} || '';
811   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
812   ***      0      0                           0         $val      = $bool              ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
813                                                                   : !defined $val      ? '(No value)'
814                                                                   : $type eq 'd'       ? $self->{DSNParser}->as_string($val)
815                                                                   : $type =~ m/H|h/    ? join(',', sort keys %$val)
816                                                                   : $type =~ m/A|a/    ? join(',', @$val)
817                                                                   :                    $val;
818   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
819                                                      }
820   ***      0                                  0      return $usage;
821                                                   }
822                                                   
823                                                   sub prompt_noecho {
824   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
825   ***      0                                  0      my ( $prompt ) = @_;
826   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
827   ***      0      0                           0      print $prompt
828                                                         or die "Cannot print: $OS_ERROR";
829   ***      0                                  0      my $response;
830   ***      0                                  0      eval {
831   ***      0                                  0         require Term::ReadKey;
832   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
833   ***      0                                  0         chomp($response = <STDIN>);
834   ***      0                                  0         Term::ReadKey::ReadMode('normal');
835   ***      0      0                           0         print "\n"
836                                                            or die "Cannot print: $OS_ERROR";
837                                                      };
838   ***      0      0                           0      if ( $EVAL_ERROR ) {
839   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
840                                                      }
841   ***      0                                  0      return $response;
842                                                   }
843                                                   
844                                                   if ( MKDEBUG ) {
845                                                      print '# ', $^X, ' ', $], "\n";
846                                                      my $uname = `uname -a`;
847                                                      if ( $uname ) {
848                                                         $uname =~ s/\s+/ /g;
849                                                         print "# $uname\n";
850                                                      }
851                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
852                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
853                                                         ($main::SVN_REV || ''), __LINE__);
854                                                      print('# Arguments: ',
855                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
856                                                   }
857                                                   
858                                                   sub _read_config_file {
859          104                  104           641      my ( $self, $filename ) = @_;
860   ***    104     50                         339      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
861   ***      0                                  0      my @args;
862   ***      0                                  0      my $prefix = '--';
863   ***      0                                  0      my $parse  = 1;
864                                                   
865                                                      LINE:
866   ***      0                                  0      while ( my $line = <$fh> ) {
867   ***      0                                  0         chomp $line;
868   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
869   ***      0                                  0         $line =~ s/\s+#.*$//g;
870   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
871   ***      0      0                           0         if ( $line eq '--' ) {
872   ***      0                                  0            $prefix = '';
873   ***      0                                  0            $parse  = 0;
874   ***      0                                  0            next LINE;
875                                                         }
876   ***      0      0      0                    0         if ( $parse
      ***             0                               
877                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
878                                                         ) {
879   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
880                                                         }
881                                                         elsif ( $line =~ m/./ ) {
882   ***      0                                  0            push @args, $line;
883                                                         }
884                                                         else {
885   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
886                                                         }
887                                                      }
888   ***      0                                  0      close $fh;
889   ***      0                                  0      return @args;
890                                                   }
891                                                   
892                                                   sub read_para_after {
893            5                    5            49      my ( $self, $file, $regex ) = @_;
894   ***      5     50                         297      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
895            5                                 48      local $INPUT_RECORD_SEPARATOR = '';
896            5                                 20      my $para;
897            5                                163      while ( $para = <$fh> ) {
898         4995    100                       52218         next unless $para =~ m/^=pod$/m;
899            5                                 22         last;
900                                                      }
901            5                                 52      while ( $para = <$fh> ) {
902          770    100                        7874         next unless $para =~ m/$regex/;
903            5                                 17         last;
904                                                      }
905            5                                 22      $para = <$fh>;
906            5                                 21      chomp($para);
907   ***      5     50                          81      close $fh or die "Can't close $file: $OS_ERROR";
908            5                                 21      return $para;
909                                                   }
910                                                   
911                                                   sub clone {
912   ***      0                    0             0      my ( $self ) = @_;
913                                                   
914   ***      0                                  0      my %clone = map {
915   ***      0                                  0         my $hashref  = $self->{$_};
916   ***      0                                  0         my $val_copy = {};
917   ***      0                                  0         foreach my $key ( keys %$hashref ) {
918   ***      0                                  0            my $ref = ref $hashref->{$key};
919   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
920   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
921   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
922                                                                              : $hashref->{$key};
923                                                         }
924   ***      0                                  0         $_ => $val_copy;
925                                                      } qw(opts short_opts defaults);
926                                                   
927   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
928   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
929                                                      }
930                                                   
931   ***      0                                  0      return bless \%clone;     
932                                                   }
933                                                   
934                                                   sub _parse_size {
935   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
936                                                   
937   ***      0      0      0                    0      if ( lc($val || '') eq 'null' ) {
938   ***      0                                  0         MKDEBUG && _d('NULL size for', $opt->{long});
939   ***      0                                  0         $opt->{value} = 'null';
940   ***      0                                  0         return;
941                                                      }
942                                                   
943   ***      0                                  0      my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
944   ***      0                                  0      my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
945   ***      0      0                           0      if ( defined $num ) {
946   ***      0      0                           0         if ( $factor ) {
947   ***      0                                  0            $num *= $factor_for{$factor};
948   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{y},
949                                                               'to num', $num, '* factor', $factor);
950                                                         }
951   ***      0             0                    0         $opt->{value} = ($pre || '') . $num;
952                                                      }
953                                                      else {
954   ***      0                                  0         $self->save_error("Invalid size for --$opt->{long}");
955                                                      }
956   ***      0                                  0      return;
957                                                   }
958                                                   
959                                                   sub _parse_attribs {
960         1560                 1560         10084      my ( $self, $option, $attribs ) = @_;
961         1560                               8015      my $types = $self->{types};
962         1560    100                       44064      return $option
                    100                               
                    100                               
                    100                               
963                                                         . ($attribs->{'short form'} ? '|' . $attribs->{'short form'}   : '' )
964                                                         . ($attribs->{'negatable'}  ? '!'                              : '' )
965                                                         . ($attribs->{'cumulative'} ? '+'                              : '' )
966                                                         . ($attribs->{'type'}       ? '=' . $types->{$attribs->{type}} : '' );
967                                                   }
968                                                   
969                                                   sub _d {
970   ***      0                    0             0      my ($package, undef, $line) = caller 0;
971   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
972   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
973                                                           @_;
974   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
975                                                   }
976                                                   
977                                                   1;
978                                                   
979                                                   # ###########################################################################
980                                                   # End OptionParser package
981                                                   # ###########################################################################
982                                                   
983                                                   # ###########################################################################
984                                                   # Quoter package 6240
985                                                   # This package is a copy without comments from the original.  The original
986                                                   # with comments and its test file can be found in the SVN repository at,
987                                                   #   trunk/common/Quoter.pm
988                                                   #   trunk/common/t/Quoter.t
989                                                   # See http://code.google.com/p/maatkit/wiki/Developers for more information.
990                                                   # ###########################################################################
991                                                   package Quoter;
992                                                   
993           36                   36           360   use strict;
              36                                110   
              36                                548   
994           36                   36           220   use warnings FATAL => 'all';
              36                                 91   
              36                                279   
995           36                   36           225   use English qw(-no_match_vars);
              36                                125   
              36                                221   
996                                                   
997   ***     36            50     36           249   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 98   
              36                                539   
998                                                   
999                                                   sub new {
1000          26                   26           172      my ( $class ) = @_;
1001          26                                407      return bless {}, $class;
1002                                                  }
1003                                                  
1004                                                  sub quote {
1005        1243                 1243          6919      my ( $self, @vals ) = @_;
1006        1243                               6684      foreach my $val ( @vals ) {
1007        1667                               8022         $val =~ s/`/``/g;
1008                                                     }
1009        1243                               5274      return join('.', map { '`' . $_ . '`' } @vals);
            1667                              13144   
1010                                                  }
1011                                                  
1012                                                  sub quote_val {
1013         419                  419          1875      my ( $self, $val ) = @_;
1014                                                  
1015         419    100                        2023      return 'NULL' unless defined $val;         # undef = NULL
1016         383    100                        1695      return "''" if $val eq '';                 # blank string = ''
1017         380    100                        1693      return $val if $val =~ m/^0x[0-9a-fA-F]/;  # hex value like 0xe5f190
1018                                                  
1019         379                               1339      $val =~ s/(['\\])/\\$1/g;
1020         379                               2876      return "'$val'";
1021                                                  }
1022                                                  
1023                                                  sub split_unquote {
1024          31                   31           182      my ( $self, $db_tbl, $default_db ) = @_;
1025          31                                279      $db_tbl =~ s/`//g;
1026          31                                256      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
1027  ***     31     50                         187      if ( !$tbl ) {
1028          31                                116         $tbl = $db;
1029          31                                113         $db  = $default_db;
1030                                                     }
1031          31                                191      return ($db, $tbl);
1032                                                  }
1033                                                  
1034                                                  sub literal_like {
1035           6                    6            31      my ( $self, $like ) = @_;
1036  ***      6     50                          33      return unless $like;
1037           6                                 71      $like =~ s/([%_])/\\$1/g;
1038           6                                 38      return "'$like'";
1039                                                  }
1040                                                  
1041                                                  sub join_quote {
1042  ***      0                    0             0      my ( $self, $default_db, $db_tbl ) = @_;
1043  ***      0      0                           0      return unless $db_tbl;
1044  ***      0                                  0      my ($db, $tbl) = split(/[.]/, $db_tbl);
1045  ***      0      0                           0      if ( !$tbl ) {
1046  ***      0                                  0         $tbl = $db;
1047  ***      0                                  0         $db  = $default_db;
1048                                                     }
1049  ***      0      0      0                    0      $db  = "`$db`"  if $db  && $db  !~ m/^`/;
1050  ***      0      0      0                    0      $tbl = "`$tbl`" if $tbl && $tbl !~ m/^`/;
1051  ***      0      0                           0      return $db ? "$db.$tbl" : $tbl;
1052                                                  }
1053                                                  
1054                                                  1;
1055                                                  
1056                                                  # ###########################################################################
1057                                                  # End Quoter package
1058                                                  # ###########################################################################
1059                                                  
1060                                                  # ###########################################################################
1061                                                  # DSNParser package 6366
1062                                                  # This package is a copy without comments from the original.  The original
1063                                                  # with comments and its test file can be found in the SVN repository at,
1064                                                  #   trunk/common/DSNParser.pm
1065                                                  #   trunk/common/t/DSNParser.t
1066                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1067                                                  # ###########################################################################
1068                                                  package DSNParser;
1069                                                  
1070          36                   36           256   use strict;
              36                                100   
              36                                208   
1071          36                   36           215   use warnings FATAL => 'all';
              36                                 98   
              36                                191   
1072          36                   36           212   use English qw(-no_match_vars);
              36                                110   
              36                                177   
1073          36                   36           235   use Data::Dumper;
              36                                 90   
              36                                313   
1074                                                  $Data::Dumper::Indent    = 0;
1075                                                  $Data::Dumper::Quotekeys = 0;
1076                                                  
1077                                                  eval {
1078                                                     require DBI;
1079                                                  };
1080                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1081                                                  
1082  ***     36            50     36           231   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                108   
              36                                480   
1083                                                  
1084                                                  sub new {
1085          58                   58          1048      my ( $class, %args ) = @_;
1086          58                                555      foreach my $arg ( qw(opts) ) {
1087  ***     58     50                         597         die "I need a $arg argument" unless $args{$arg};
1088                                                     }
1089          58                                522      my $self = {
1090                                                        opts => {}  # h, P, u, etc.  Should come from DSN OPTIONS section in POD.
1091                                                     };
1092          58                                459      foreach my $opt ( @{$args{opts}} ) {
              58                                441   
1093  ***    522     50     33                 6107         if ( !$opt->{key} || !$opt->{desc} ) {
1094  ***      0                                  0            die "Invalid DSN option: ", Dumper($opt);
1095                                                        }
1096                                                        MKDEBUG && _d('DSN option:',
1097                                                           join(', ',
1098         522                               1290               map { "$_=" . (defined $opt->{$_} ? ($opt->{$_} || '') : 'undef') }
1099                                                                 keys %$opt
1100                                                           )
1101                                                        );
1102  ***    522            50                 6223         $self->{opts}->{$opt->{key}} = {
1103                                                           dsn  => $opt->{dsn},
1104                                                           desc => $opt->{desc},
1105                                                           copy => $opt->{copy} || 0,
1106                                                        };
1107                                                     }
1108          58                               1477      return bless $self, $class;
1109                                                  }
1110                                                  
1111                                                  sub prop {
1112         613                  613          5194      my ( $self, $prop, $value ) = @_;
1113         613    100                        3512      if ( @_ > 2 ) {
1114          26                                 82         MKDEBUG && _d('Setting', $prop, 'property');
1115          26                                156         $self->{$prop} = $value;
1116                                                     }
1117         613                               5252      return $self->{$prop};
1118                                                  }
1119                                                  
1120                                                  sub parse {
1121         144                  144          5233      my ( $self, $dsn, $prev, $defaults ) = @_;
1122         144    100                         905      if ( !$dsn ) {
1123          17                                 50         MKDEBUG && _d('No DSN to parse');
1124          17                                110         return;
1125                                                     }
1126         127                                375      MKDEBUG && _d('Parsing', $dsn);
1127         127           100                  758      $prev     ||= {};
1128         127           100                  715      $defaults ||= {};
1129         127                                438      my %given_props;
1130         127                                401      my %final_props;
1131         127                                627      my $opts = $self->{opts};
1132                                                  
1133         127                               1143      foreach my $dsn_part ( split(/,/, $dsn) ) {
1134  ***    462     50                        4589         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1135         462                               2782            $given_props{$prop_key} = $prop_val;
1136                                                        }
1137                                                        else {
1138  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1139  ***      0                                  0            $given_props{h} = $dsn_part;
1140                                                        }
1141                                                     }
1142                                                  
1143         127                               1052      foreach my $key ( keys %$opts ) {
1144        1143                               2853         MKDEBUG && _d('Finding value for', $key);
1145        1143                               4921         $final_props{$key} = $given_props{$key};
1146        1143    100    100                12163         if (   !defined $final_props{$key}
      ***                   66                        
1147                                                             && defined $prev->{$key} && $opts->{$key}->{copy} )
1148                                                        {
1149          38                                182            $final_props{$key} = $prev->{$key};
1150          38                                117            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1151                                                        }
1152        1143    100                        5971         if ( !defined $final_props{$key} ) {
1153         643                               2578            $final_props{$key} = $defaults->{$key};
1154         643                               2299            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1155                                                        }
1156                                                     }
1157                                                  
1158         127                                864      foreach my $key ( keys %given_props ) {
1159  ***    462     50                        2597         die "Unknown DSN option '$key' in '$dsn'.  For more details, "
1160                                                              . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
1161                                                              . "for complete documentation."
1162                                                           unless exists $opts->{$key};
1163                                                     }
1164  ***    127     50                         801      if ( (my $required = $self->prop('required')) ) {
1165  ***      0                                  0         foreach my $key ( keys %$required ) {
1166  ***      0      0                           0            die "Missing required DSN option '$key' in '$dsn'.  For more details, "
1167                                                                 . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
1168                                                                 . "for complete documentation."
1169                                                              unless $final_props{$key};
1170                                                        }
1171                                                     }
1172                                                  
1173         127                               1019      return \%final_props;
1174                                                  }
1175                                                  
1176                                                  sub parse_options {
1177          26                   26           153      my ( $self, $o ) = @_;
1178  ***     26     50                         227      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1179          10                                 88      my $dsn_string
1180                                                        = join(',',
1181         234    100                        1158             map  { "$_=".$o->get($_); }
1182          26                                283             grep { $o->has($_) && $o->get($_) }
1183          26                                120             keys %{$self->{opts}}
1184                                                          );
1185          26                                161      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1186          26                                244      return $self->parse($dsn_string);
1187                                                  }
1188                                                  
1189                                                  sub as_string {
1190          10                   10            56      my ( $self, $dsn, $props ) = @_;
1191  ***     10     50                          59      return $dsn unless ref $dsn;
1192  ***     10     50                          59      my %allowed = $props ? map { $_=>1 } @$props : ();
      ***      0                                  0   
1193          56    100                         382      return join(',',
1194          92    100                         742         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_})  }
1195  ***     92     50                         437         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1196          10                                154         grep { !$props || $allowed{$_}                   }
1197                                                        sort keys %$dsn );
1198                                                  }
1199                                                  
1200                                                  sub usage {
1201  ***      0                    0             0      my ( $self ) = @_;
1202  ***      0                                  0      my $usage
1203                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1204                                                        . "  KEY  COPY  MEANING\n"
1205                                                        . "  ===  ====  =============================================\n";
1206  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1207  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1208  ***      0      0      0                    0         $usage .= "  $key    "
1209                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1210                                                               .  ($opts{$key}->{desc} || '[No description]')
1211                                                               . "\n";
1212                                                     }
1213  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1214  ***      0                                  0      return $usage;
1215                                                  }
1216                                                  
1217                                                  sub get_cxn_params {
1218         174                  174          1599      my ( $self, $info ) = @_;
1219         174                                614      my $dsn;
1220         174                                614      my %opts = %{$self->{opts}};
             174                               2399   
1221  ***    174            50                 1235      my $driver = $self->prop('dbidriver') || '';
1222  ***    174     50                         941      if ( $driver eq 'Pg' ) {
1223  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1224  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1225  ***      0             0                    0                        grep { defined $info->{$_} }
1226                                                                       qw(h P));
1227                                                     }
1228                                                     else {
1229         362                               3094         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1230         870                               4064            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1231         174           100                 2300                        grep { defined $info->{$_} }
1232                                                                       qw(F h P S A))
1233                                                           . ';mysql_read_default_group=client';
1234                                                     }
1235         174                                687      MKDEBUG && _d($dsn);
1236         174                               1942      return ($dsn, $info->{u}, $info->{p});
1237                                                  }
1238                                                  
1239                                                  sub fill_in_dsn {
1240  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1241  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1242  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1243  ***      0                                  0      $user =~ s/@.*//;
1244  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1245  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1246  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1247  ***      0             0                    0      $dsn->{u} ||= $user;
1248  ***      0             0                    0      $dsn->{D} ||= $db;
1249                                                  }
1250                                                  
1251                                                  sub get_dbh {
1252         174                  174          1398      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1253         174           100                 1098      $opts ||= {};
1254  ***    174     50                        2296      my $defaults = {
1255                                                        AutoCommit         => 0,
1256                                                        RaiseError         => 1,
1257                                                        PrintError         => 0,
1258                                                        ShowErrorStatement => 1,
1259                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1260                                                     };
1261         174                               1060      @{$defaults}{ keys %$opts } = values %$opts;
             174                                808   
1262                                                  
1263  ***    174     50                        1011      if ( $opts->{mysql_use_result} ) {
1264  ***      0                                  0         $defaults->{mysql_use_result} = 1;
1265                                                     }
1266                                                  
1267  ***    174     50                         855      if ( !$have_dbi ) {
1268  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1269                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1270                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1271                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1272                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1273                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1274                                                  
1275                                                     }
1276                                                  
1277         174                                536      my $dbh;
1278         174                                625      my $tries = 2;
1279  ***    174            66                 2213      while ( !$dbh && $tries-- ) {
1280                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1281         174                                488            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1282                                                  
1283         174                                670         eval {
1284         174                               1743            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1285                                                  
1286  ***    174     50                        1808            if ( $cxn_string =~ m/mysql/i ) {
1287         174                                581               my $sql;
1288                                                  
1289         174                                716               $sql = 'SELECT @@SQL_MODE';
1290         174                                496               MKDEBUG && _d($dbh, $sql);
1291         174                                484               my ($sql_mode) = $dbh->selectrow_array($sql);
1292                                                  
1293  ***    174     50                       34766               $sql = 'SET @@SQL_QUOTE_SHOW_CREATE = 1'
1294                                                                   . '/*!40101, @@SQL_MODE=\'NO_AUTO_VALUE_ON_ZERO'
1295                                                                   . ($sql_mode ? ",$sql_mode" : '')
1296                                                                   . '\'*/';
1297         174                                533               MKDEBUG && _d($dbh, $sql);
1298         174                              19736               $dbh->do($sql);
1299                                                  
1300  ***    174     50                        1786               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1301  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1302  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1303  ***      0                                  0                  $dbh->do($sql);
1304  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1305  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1306  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1307                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1308                                                                 }
1309                                                                 else {
1310  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1311                                                                 }
1312                                                              }
1313                                                  
1314         174    100                        1245               if ( $self->prop('set-vars') ) {
1315         112                                619                  $sql = "SET " . $self->prop('set-vars');
1316         112                                370                  MKDEBUG && _d($dbh, ':', $sql);
1317         112                              11961                  $dbh->do($sql);
1318                                                              }
1319                                                           }
1320                                                        };
1321  ***    174     50     33                 2290         if ( !$dbh && $EVAL_ERROR ) {
1322  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1323  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1324  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1325  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1326                                                           }
1327                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1328  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1329                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1330                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1331                                                                 . "DBD::mysql is not installed, try:\n"
1332                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1333                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1334                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1335                                                           }
1336  ***      0      0                           0            if ( !$tries ) {
1337  ***      0                                  0               die $EVAL_ERROR;
1338                                                           }
1339                                                        }
1340                                                     }
1341                                                  
1342         174                                491      MKDEBUG && _d('DBH info: ',
1343                                                        $dbh,
1344                                                        Dumper($dbh->selectrow_hashref(
1345                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1346                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1347                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1348                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1349                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1350                                                        '$DBI::VERSION:',        $DBI::VERSION,
1351                                                     );
1352                                                  
1353         174                               1247      return $dbh;
1354                                                  }
1355                                                  
1356                                                  sub get_hostname {
1357  ***      0                    0             0      my ( $self, $dbh ) = @_;
1358  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1359  ***      0                                  0         return $host;
1360                                                     }
1361  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1362                                                        'SELECT /*!50038 @@hostname, */ 1');
1363  ***      0                                  0      return $hostname;
1364                                                  }
1365                                                  
1366                                                  sub disconnect {
1367  ***      0                    0             0      my ( $self, $dbh ) = @_;
1368  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1369  ***      0                                  0      $dbh->disconnect;
1370                                                  }
1371                                                  
1372                                                  sub print_active_handles {
1373  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1374  ***      0             0                    0      $level ||= 0;
1375  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1376                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1377                                                        or die "Cannot print: $OS_ERROR";
1378  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1379  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1380                                                     }
1381                                                  }
1382                                                  
1383                                                  sub copy {
1384  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1385  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1386  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1387  ***      0                                  0      my %new_dsn = map {
1388  ***      0                                  0         my $key = $_;
1389  ***      0                                  0         my $val;
1390  ***      0      0                           0         if ( $args{overwrite} ) {
1391  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1392                                                        }
1393                                                        else {
1394  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1395                                                        }
1396  ***      0                                  0         $key => $val;
1397  ***      0                                  0      } keys %{$self->{opts}};
1398  ***      0                                  0      return \%new_dsn;
1399                                                  }
1400                                                  
1401                                                  sub _d {
1402  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1403  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1404  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1405                                                          @_;
1406  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1407                                                  }
1408                                                  
1409                                                  1;
1410                                                  
1411                                                  # ###########################################################################
1412                                                  # End DSNParser package
1413                                                  # ###########################################################################
1414                                                  
1415                                                  # ###########################################################################
1416                                                  # VersionParser package 5266
1417                                                  # This package is a copy without comments from the original.  The original
1418                                                  # with comments and its test file can be found in the SVN repository at,
1419                                                  #   trunk/common/VersionParser.pm
1420                                                  #   trunk/common/t/VersionParser.t
1421                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1422                                                  # ###########################################################################
1423                                                  package VersionParser;
1424                                                  
1425          36                   36           283   use strict;
              36                                104   
              36                                203   
1426          36                   36           217   use warnings FATAL => 'all';
              36                               2788   
              36                               3656   
1427                                                  
1428          36                   36           725   use English qw(-no_match_vars);
              36                               1094   
              36                                196   
1429                                                  
1430  ***     36            50     36           236   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                325   
              36                                504   
1431                                                  
1432                                                  sub new {
1433          39                   39           320      my ( $class ) = @_;
1434          39                                462      bless {}, $class;
1435                                                  }
1436                                                  
1437                                                  sub parse {
1438         186                  186          9476      my ( $self, $str ) = @_;
1439         186                               2654      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1440         186                                610      MKDEBUG && _d($str, 'parses to', $result);
1441         186                               1396      return $result;
1442                                                  }
1443                                                  
1444                                                  sub version_ge {
1445         132                  132           813      my ( $self, $dbh, $target ) = @_;
1446         132    100                        1024      if ( !$self->{$dbh} ) {
1447          54                                162         $self->{$dbh} = $self->parse(
1448                                                           $dbh->selectrow_array('SELECT VERSION()'));
1449                                                     }
1450  ***    132     50                        1707      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1451         132                                379      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
1452         132                               1167      return $result;
1453                                                  }
1454                                                  
1455                                                  sub _d {
1456  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1457  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1458  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1459                                                          @_;
1460  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1461                                                  }
1462                                                  
1463                                                  1;
1464                                                  
1465                                                  # ###########################################################################
1466                                                  # End VersionParser package
1467                                                  # ###########################################################################
1468                                                  
1469                                                  # ###########################################################################
1470                                                  # TableSyncStream package 5697
1471                                                  # This package is a copy without comments from the original.  The original
1472                                                  # with comments and its test file can be found in the SVN repository at,
1473                                                  #   trunk/common/TableSyncStream.pm
1474                                                  #   trunk/common/t/TableSyncStream.t
1475                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1476                                                  # ###########################################################################
1477                                                  package TableSyncStream;
1478                                                  
1479          36                   36           241   use strict;
              36                                 84   
              36                                183   
1480          36                   36           211   use warnings FATAL => 'all';
              36                                 97   
              36                                171   
1481                                                  
1482          36                   36           218   use English qw(-no_match_vars);
              36                                 79   
              36                                172   
1483                                                  
1484  ***     36            50     36           220   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 90   
              36                                596   
1485                                                  
1486                                                  sub new {
1487          15                   15           189      my ( $class, %args ) = @_;
1488          15                                112      foreach my $arg ( qw(Quoter) ) {
1489  ***     15     50                         133         die "I need a $arg argument" unless $args{$arg};
1490                                                     }
1491          15                                167      my $self = { %args };
1492          15                                274      return bless $self, $class;
1493                                                  }
1494                                                  
1495                                                  sub name {
1496           3                    3            45      return 'Stream';
1497                                                  }
1498                                                  
1499                                                  sub can_sync {
1500           3                    3            16      return 1;  # We can sync anything.
1501                                                  }
1502                                                  
1503                                                  sub prepare_to_sync {
1504           3                    3            74      my ( $self, %args ) = @_;
1505           3                                 27      my @required_args = qw(cols ChangeHandler);
1506           3                                 14      foreach my $arg ( @required_args ) {
1507  ***      6     50                          39         die "I need a $arg argument" unless $args{$arg};
1508                                                     }
1509           3                                 17      $self->{cols}            = $args{cols};
1510           3                                 13      $self->{buffer_in_mysql} = $args{buffer_in_mysql};
1511           3                                 12      $self->{ChangeHandler}   = $args{ChangeHandler};
1512                                                  
1513           3                                 36      $self->{done}  = 0;
1514                                                  
1515           3                                 24      return;
1516                                                  }
1517                                                  
1518                                                  sub uses_checksum {
1519           3                    3            15      return 0;  # We don't need checksum queries.
1520                                                  }
1521                                                  
1522                                                  sub set_checksum_queries {
1523  ***      0                    0             0      return;  # This shouldn't be called, but just in case.
1524                                                  }
1525                                                  
1526                                                  sub prepare_sync_cycle {
1527           6                    6            23      my ( $self, $host ) = @_;
1528           6                                 16      return;
1529                                                  }
1530                                                  
1531                                                  sub get_sql {
1532           6                    6            39      my ( $self, %args ) = @_;
1533           8                                 33      return "SELECT "
1534                                                        . ($self->{buffer_in_mysql} ? 'SQL_BUFFER_RESULT ' : '')
1535  ***      6     50     50                   39         . join(', ', map { $self->{Quoter}->quote($_) } @{$self->{cols}})
               6                                 24   
1536                                                        . ' FROM ' . $self->{Quoter}->quote(@args{qw(database table)})
1537                                                        . ' WHERE ' . ( $args{where} || '1=1' );
1538                                                  }
1539                                                  
1540                                                  sub same_row {
1541           3                    3            20      my ( $self, %args ) = @_;
1542           3                                 16      return;
1543                                                  }
1544                                                  
1545                                                  sub not_in_right {
1546           5                    5            39      my ( $self, %args ) = @_;
1547           5                                 33      $self->{ChangeHandler}->change('INSERT', $args{lr}, $self->key_cols());
1548                                                  }
1549                                                  
1550                                                  sub not_in_left {
1551  ***      0                    0             0      my ( $self, %args ) = @_;
1552  ***      0                                  0      $self->{ChangeHandler}->change('DELETE', $args{rr}, $self->key_cols());
1553                                                  }
1554                                                  
1555                                                  sub done_with_rows {
1556           3                    3            14      my ( $self ) = @_;
1557           3                                 21      $self->{done} = 1;
1558                                                  }
1559                                                  
1560                                                  sub done {
1561           6                    6            26      my ( $self ) = @_;
1562           6                                 36      return $self->{done};
1563                                                  }
1564                                                  
1565                                                  sub key_cols {
1566           8                    8            28      my ( $self ) = @_;
1567           8                                 48      return $self->{cols};
1568                                                  }
1569                                                  
1570                                                  sub pending_changes {
1571  ***      0                    0             0      my ( $self ) = @_;
1572  ***      0                                  0      return;
1573                                                  }
1574                                                  
1575                                                  sub _d {
1576  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1577  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1578  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1579                                                          @_;
1580  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1581                                                  }
1582                                                  
1583                                                  1;
1584                                                  
1585                                                  # ###########################################################################
1586                                                  # End TableSyncStream package
1587                                                  # ###########################################################################
1588                                                  
1589                                                  # ###########################################################################
1590                                                  # TableParser package 5980
1591                                                  # This package is a copy without comments from the original.  The original
1592                                                  # with comments and its test file can be found in the SVN repository at,
1593                                                  #   trunk/common/TableParser.pm
1594                                                  #   trunk/common/t/TableParser.t
1595                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1596                                                  # ###########################################################################
1597                                                  package TableParser;
1598                                                  
1599          36                   36           247   use strict;
              36                                 86   
              36                                185   
1600          36                   36           204   use warnings FATAL => 'all';
              36                                 78   
              36                                193   
1601          36                   36           202   use English qw(-no_match_vars);
              36                                 94   
              36                                178   
1602          36                   36           222   use Data::Dumper;
              36                                 85   
              36                                185   
1603                                                  $Data::Dumper::Indent    = 1;
1604                                                  $Data::Dumper::Sortkeys  = 1;
1605                                                  $Data::Dumper::Quotekeys = 0;
1606                                                  
1607  ***     36            50     36           225   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 87   
              36                                479   
1608                                                  
1609                                                  
1610                                                  sub new {
1611          26                   26           286      my ( $class, %args ) = @_;
1612          26                                176      my @required_args = qw(Quoter);
1613          26                                165      foreach my $arg ( @required_args ) {
1614  ***     26     50                         225         die "I need a $arg argument" unless $args{$arg};
1615                                                     }
1616          26                                225      my $self = { %args };
1617          26                                374      return bless $self, $class;
1618                                                  }
1619                                                  
1620                                                  
1621                                                  sub parse {
1622          31                   31           197      my ( $self, $ddl, $opts ) = @_;
1623  ***     31     50                         175      return unless $ddl;
1624  ***     31     50                         218      if ( ref $ddl eq 'ARRAY' ) {
1625  ***     31     50                         222         if ( lc $ddl->[0] eq 'table' ) {
1626          31                                169            $ddl = $ddl->[1];
1627                                                        }
1628                                                        else {
1629                                                           return {
1630  ***      0                                  0               engine => 'VIEW',
1631                                                           };
1632                                                        }
1633                                                     }
1634                                                  
1635  ***     31     50                         433      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
1636  ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
1637                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
1638                                                     }
1639                                                  
1640          31                                401      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
1641  ***     31     50                         371      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
1642                                                  
1643          31                                895      $ddl =~ s/(`[^`]+`)/\L$1/g;
1644                                                  
1645          31                                320      my $engine = $self->get_engine($ddl);
1646                                                  
1647          31                                874      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
1648          31                                163      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
              76                                617   
1649          31                                122      MKDEBUG && _d('Table cols:', join(', ', map { "`$_`" } @cols));
1650                                                  
1651          31                                102      my %def_for;
1652          31                                253      @def_for{@cols} = @defs;
1653                                                  
1654          31                                123      my (@nums, @null);
1655          31                                129      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
1656          31                                192      foreach my $col ( @cols ) {
1657          76                                310         my $def = $def_for{$col};
1658          76                                692         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
1659  ***     76     50                         389         die "Can't determine column type for $def" unless $type;
1660          76                                326         $type_for{$col} = $type;
1661          76    100                         646         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
1662          41                                180            push @nums, $col;
1663          41                                192            $is_numeric{$col} = 1;
1664                                                        }
1665          76    100                         473         if ( $def !~ m/NOT NULL/ ) {
1666          19                                 90            push @null, $col;
1667          19                                 84            $is_nullable{$col} = 1;
1668                                                        }
1669          76    100                         622         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
1670                                                     }
1671                                                  
1672          31                                323      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
1673                                                  
1674                                                     return {
1675          76                                484         name           => $name,
1676                                                        cols           => \@cols,
1677          76                                985         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
1678          31                                379         is_col         => { map { $_ => 1 } @cols },
1679                                                        null_cols      => \@null,
1680                                                        is_nullable    => \%is_nullable,
1681                                                        is_autoinc     => \%is_autoinc,
1682                                                        clustered_key  => $clustered_key,
1683                                                        keys           => $keys,
1684                                                        defs           => \%def_for,
1685                                                        numeric_cols   => \@nums,
1686                                                        is_numeric     => \%is_numeric,
1687                                                        engine         => $engine,
1688                                                        type_for       => \%type_for,
1689                                                     };
1690                                                  }
1691                                                  
1692                                                  sub sort_indexes {
1693           7                    7            33      my ( $self, $tbl ) = @_;
1694                                                  
1695                                                     my @indexes
1696  ***      0                                  0         = sort {
1697           6                                 55            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
1698                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
1699                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
1700  ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
1701                                                        }
1702                                                        grep {
1703           7                                 57            $tbl->{keys}->{$_}->{type} eq 'BTREE'
1704                                                        }
1705           7                                 26         sort keys %{$tbl->{keys}};
1706                                                  
1707           7                                 23      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
1708           7                                 35      return @indexes;
1709                                                  }
1710                                                  
1711                                                  sub find_best_index {
1712           7                    7            33      my ( $self, $tbl, $index ) = @_;
1713           7                                 25      my $best;
1714  ***      7     50                          38      if ( $index ) {
1715  ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
1716                                                     }
1717  ***      7     50                          33      if ( !$best ) {
1718  ***      7     50                          32         if ( $index ) {
1719  ***      0                                  0            die "Index '$index' does not exist in table";
1720                                                        }
1721                                                        else {
1722           7                                 49            ($best) = $self->sort_indexes($tbl);
1723                                                        }
1724                                                     }
1725           7                                 22      MKDEBUG && _d('Best index found is', $best);
1726           7                                 30      return $best;
1727                                                  }
1728                                                  
1729                                                  sub find_possible_keys {
1730  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
1731  ***      0      0                           0      return () unless $where;
1732  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
1733                                                        . ' WHERE ' . $where;
1734  ***      0                                  0      MKDEBUG && _d($sql);
1735  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
1736  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
1737  ***      0      0                           0      if ( $expl->{possible_keys} ) {
1738  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
1739  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
1740  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
1741  ***      0      0                           0         if ( $expl->{key} ) {
1742  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
1743  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
1744  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
1745  ***      0                                  0            my %seen;
1746  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
1747                                                        }
1748  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
1749  ***      0                                  0         return @candidates;
1750                                                     }
1751                                                     else {
1752  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
1753  ***      0                                  0         return ();
1754                                                     }
1755                                                  }
1756                                                  
1757                                                  sub check_table {
1758  ***      0                    0             0      my ( $self, %args ) = @_;
1759  ***      0                                  0      my @required_args = qw(dbh db tbl);
1760  ***      0                                  0      foreach my $arg ( @required_args ) {
1761  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1762                                                     }
1763  ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
1764  ***      0                                  0      my $q      = $self->{Quoter};
1765  ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
1766  ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
1767                                                  
1768  ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
1769                                                             . ' LIKE ' . $q->literal_like($tbl);
1770  ***      0                                  0      MKDEBUG && _d($sql);
1771  ***      0                                  0      my $row;
1772  ***      0                                  0      eval {
1773  ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
1774                                                     };
1775  ***      0      0                           0      if ( $EVAL_ERROR ) {
1776  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1777  ***      0                                  0         return 0;
1778                                                     }
1779  ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
1780  ***      0                                  0         MKDEBUG && _d('Table does not exist');
1781  ***      0                                  0         return 0;
1782                                                     }
1783                                                  
1784  ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
1785  ***      0      0                           0      return 1 unless $args{all_privs};
1786                                                  
1787  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
1788  ***      0                                  0      MKDEBUG && _d($sql);
1789  ***      0                                  0      eval {
1790  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
1791                                                     };
1792  ***      0      0                           0      if ( $EVAL_ERROR ) {
1793  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1794  ***      0                                  0         return 0;
1795                                                     }
1796  ***      0      0                           0      if ( !scalar keys %$row ) {
1797  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
1798  ***      0                                  0         return 0;
1799                                                     }
1800  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
1801                                                  
1802  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
1803  ***      0                                  0      MKDEBUG && _d($sql);
1804  ***      0                                  0      eval {
1805  ***      0                                  0         $dbh->do($sql);
1806                                                     };
1807  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
1808                                                  
1809  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
1810                                                        ($can_delete ? 'delete' : ''));
1811                                                  
1812  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
1813                                                            && $can_delete) ) {
1814  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
1815  ***      0                                  0         return 0;
1816                                                     }
1817                                                  
1818  ***      0                                  0      MKDEBUG && _d('User has all privs');
1819  ***      0                                  0      return 1;
1820                                                  }
1821                                                  
1822                                                  sub get_engine {
1823          62                   62           366      my ( $self, $ddl, $opts ) = @_;
1824          62                               1000      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
1825          62                                205      MKDEBUG && _d('Storage engine:', $engine);
1826  ***     62            50                  420      return $engine || undef;
1827                                                  }
1828                                                  
1829                                                  sub get_keys {
1830          31                   31           225      my ( $self, $ddl, $opts, $is_nullable ) = @_;
1831          31                                172      my $engine        = $self->get_engine($ddl);
1832          31                                120      my $keys          = {};
1833          31                                104      my $clustered_key = undef;
1834                                                  
1835                                                     KEY:
1836          31                                488      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
1837                                                  
1838  ***     38     50                         248         next KEY if $key =~ m/FOREIGN/;
1839                                                  
1840          38                                146         my $key_ddl = $key;
1841          38                                103         MKDEBUG && _d('Parsed key:', $key_ddl);
1842                                                  
1843  ***     38     50                         310         if ( $engine !~ m/MEMORY|HEAP/ ) {
1844          38                                183            $key =~ s/USING HASH/USING BTREE/;
1845                                                        }
1846                                                  
1847          38                                419         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
1848          38                                223         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
1849  ***     38            33                  717         $type = $type || $special || 'BTREE';
      ***                   50                        
1850  ***     38     50     33                  390         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
1851                                                           && $engine =~ m/HEAP|MEMORY/i )
1852                                                        {
1853  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
1854                                                        }
1855                                                  
1856          38                                404         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
1857          38    100                         316         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
1858          38                                115         my @cols;
1859          38                                118         my @col_prefixes;
1860          38                                343         foreach my $col_def ( $cols =~ m/`[^`]+`(?:\(\d+\))?/g ) {
1861          49                                444            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
1862          49                                225            push @cols, $name;
1863          49                                256            push @col_prefixes, $prefix;
1864                                                        }
1865          38                                200         $name =~ s/`//g;
1866                                                  
1867          38                                107         MKDEBUG && _d( $name, 'key cols:', join(', ', map { "`$_`" } @cols));
1868                                                  
1869          49                                287         $keys->{$name} = {
1870                                                           name         => $name,
1871                                                           type         => $type,
1872                                                           colnames     => $cols,
1873                                                           cols         => \@cols,
1874                                                           col_prefixes => \@col_prefixes,
1875                                                           is_unique    => $unique,
1876          49                                655            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
1877          38                                296            is_col       => { map { $_ => 1 } @cols },
1878                                                           ddl          => $key_ddl,
1879                                                        };
1880                                                  
1881          38    100    100                  597         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
1882          18                                 89            my $this_key = $keys->{$name};
1883  ***     18    100     33                  122            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***            50                               
1884          17                                 68               $clustered_key = 'PRIMARY';
1885                                                           }
1886                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
1887  ***      0                                  0               $clustered_key = $this_key->{name};
1888                                                           }
1889          18                                 95            MKDEBUG && $clustered_key && _d('This key is the clustered key');
1890                                                        }
1891                                                     }
1892                                                  
1893          31                                228      return $keys, $clustered_key;
1894                                                  }
1895                                                  
1896                                                  sub get_fks {
1897  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
1898  ***      0                                  0      my $fks = {};
1899                                                  
1900  ***      0                                  0      foreach my $fk (
1901                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
1902                                                     {
1903  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
1904  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
1905  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
1906                                                  
1907  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
1908  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
1909                                                        }
1910                                                  
1911  ***      0                                  0         $fks->{$name} = {
1912                                                           name           => $name,
1913                                                           colnames       => $cols,
1914  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
1915                                                           parent_tbl     => $parent,
1916                                                           parent_colnames=> $parent_cols,
1917  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
1918                                                           ddl            => $fk,
1919                                                        };
1920                                                     }
1921                                                  
1922  ***      0                                  0      return $fks;
1923                                                  }
1924                                                  
1925                                                  sub remove_auto_increment {
1926  ***      0                    0             0      my ( $self, $ddl ) = @_;
1927  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
1928  ***      0                                  0      return $ddl;
1929                                                  }
1930                                                  
1931                                                  sub remove_secondary_indexes {
1932  ***      0                    0             0      my ( $self, $ddl ) = @_;
1933  ***      0                                  0      my $sec_indexes_ddl;
1934  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
1935                                                  
1936  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
1937  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
1938  ***      0             0                    0         $clustered_key  ||= '';
1939                                                  
1940  ***      0                                  0         my @sec_indexes   = map {
1941  ***      0                                  0            my $key_def = $_->{ddl};
1942  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
1943  ***      0                                  0            $ddl =~ s/\s+$key_def//i;
1944                                                  
1945  ***      0                                  0            my $key_ddl = "ADD $_->{ddl}";
1946  ***      0      0                           0            $key_ddl   .= ',' unless $key_ddl =~ m/,$/;
1947  ***      0                                  0            $key_ddl;
1948                                                        }
1949  ***      0                                  0         grep { $_->{name} ne $clustered_key }
1950  ***      0                                  0         values %{$tbl_struct->{keys}};
1951  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
1952                                                  
1953  ***      0      0                           0         if ( @sec_indexes ) {
1954  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
1955  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
1956                                                        }
1957                                                  
1958  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
1959                                                     }
1960                                                     else {
1961  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
1962                                                           $tbl_struct->{engine}, 'table');
1963                                                     }
1964                                                  
1965  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
1966                                                  }
1967                                                  
1968                                                  sub _d {
1969  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1970  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1971  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1972                                                          @_;
1973  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1974                                                  }
1975                                                  
1976                                                  1;
1977                                                  
1978                                                  # ###########################################################################
1979                                                  # End TableParser package
1980                                                  # ###########################################################################
1981                                                  
1982                                                  # ###########################################################################
1983                                                  # RowDiff package 5697
1984                                                  # This package is a copy without comments from the original.  The original
1985                                                  # with comments and its test file can be found in the SVN repository at,
1986                                                  #   trunk/common/RowDiff.pm
1987                                                  #   trunk/common/t/RowDiff.t
1988                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1989                                                  # ###########################################################################
1990                                                  package RowDiff;
1991                                                  
1992          36                   36           294   use strict;
              36                                 94   
              36                                207   
1993          36                   36           210   use warnings FATAL => 'all';
              36                                 92   
              36                                218   
1994          36                   36           208   use English qw(-no_match_vars);
              36                                 87   
              36                                202   
1995                                                  
1996  ***     36            50     36           247   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 91   
              36                                510   
1997                                                  
1998                                                  sub new {
1999          28                   28           216      my ( $class, %args ) = @_;
2000  ***     28     50                         201      die "I need a dbh" unless $args{dbh};
2001          28                                182      my $self = { %args };
2002          28                                398      return bless $self, $class;
2003                                                  }
2004                                                  
2005                                                  sub compare_sets {
2006          98                   98          1344      my ( $self, %args ) = @_;
2007          98                               1218      my @required_args = qw(left_sth right_sth syncer tbl_struct);
2008          98                                528      foreach my $arg ( @required_args ) {
2009  ***    392     50                        2416         die "I need a $arg argument" unless defined $args{$arg};
2010                                                     }
2011          98                                447      my $left_sth   = $args{left_sth};
2012          98                                439      my $right_sth  = $args{right_sth};
2013          98                                366      my $syncer     = $args{syncer};
2014          98                                359      my $tbl_struct = $args{tbl_struct};
2015                                                  
2016          98                                352      my ($lr, $rr);    # Current row from the left/right sths.
2017          98                                591      $args{key_cols} = $syncer->key_cols();  # for key_cmp()
2018                                                  
2019          98                                345      my $left_done  = 0;
2020          98                                342      my $right_done = 0;
2021          98                                407      my $done       = $self->{done};
2022                                                  
2023          98           100                  324      do {
2024         489    100    100                 4392         if ( !$lr && !$left_done ) {
2025         476                               1122            MKDEBUG && _d('Fetching row from left');
2026         476                               1375            eval { $lr = $left_sth->fetchrow_hashref(); };
             476                               3793   
2027         476                               6323            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2028  ***    476    100     66                 4192            $left_done = !$lr || $EVAL_ERROR ? 1 : 0;
2029                                                        }
2030                                                        elsif ( MKDEBUG ) {
2031                                                           _d('Left still has rows');
2032                                                        }
2033                                                  
2034         489    100    100                 4069         if ( !$rr && !$right_done ) {
2035         459                               1090            MKDEBUG && _d('Fetching row from right');
2036         459                               1302            eval { $rr = $right_sth->fetchrow_hashref(); };
             459                               3036   
2037         459                               5448            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2038  ***    459    100     66                 3981            $right_done = !$rr || $EVAL_ERROR ? 1 : 0;
2039                                                        }
2040                                                        elsif ( MKDEBUG ) {
2041                                                           _d('Right still has rows');
2042                                                        }
2043                                                  
2044         489                               1303         my $cmp;
2045         489    100    100                 3762         if ( $lr && $rr ) {
2046         371                               2434            $cmp = $self->key_cmp(%args, lr => $lr, rr => $rr);
2047         371                               1109            MKDEBUG && _d('Key comparison on left and right:', $cmp);
2048                                                        }
2049         489    100    100                 3080         if ( $lr || $rr ) {
2050         392    100    100                 6438            if ( $lr && $rr && defined $cmp && $cmp == 0 ) {
      ***           100     66                        
                           100                        
                           100                        
                           100                        
2051         349                                948               MKDEBUG && _d('Left and right have the same key');
2052         349                               2190               $syncer->same_row(%args, lr => $lr, rr => $rr);
2053  ***    348     50                        1771               $self->{same_row}->(%args, lr => $lr, rr => $rr)
2054                                                                 if $self->{same_row};
2055         348                               1277               $lr = $rr = undef; # Fetch another row from each side.
2056                                                           }
2057                                                           elsif ( !$rr || ( defined $cmp && $cmp < 0 ) ) {
2058          30                                 89               MKDEBUG && _d('Left is not in right');
2059          30                                297               $syncer->not_in_right(%args, lr => $lr, rr => $rr);
2060  ***     30     50                         193               $self->{not_in_right}->(%args, lr => $lr, rr => $rr)
2061                                                                 if $self->{not_in_right};
2062          30                                128               $lr = undef;
2063                                                           }
2064                                                           else {
2065          13                                 41               MKDEBUG && _d('Right is not in left');
2066          13                                135               $syncer->not_in_left(%args, lr => $lr, rr => $rr);
2067  ***     13     50                          82               $self->{not_in_left}->(%args, lr => $lr, rr => $rr)
2068                                                                 if $self->{not_in_left};
2069          13                                 49               $rr = undef;
2070                                                           }
2071                                                        }
2072  ***    488     50     33                 5208         $left_done = $right_done = 1 if $done && $done->(%args);
2073                                                     } while ( !($left_done && $right_done) );
2074          97                                275      MKDEBUG && _d('No more rows');
2075          97                                561      $syncer->done_with_rows();
2076                                                  }
2077                                                  
2078                                                  sub key_cmp {
2079         371                  371          3051      my ( $self, %args ) = @_;
2080         371                               2207      my @required_args = qw(lr rr key_cols tbl_struct);
2081         371                               1350      foreach my $arg ( @required_args ) {
2082  ***   1484     50                        6894         die "I need a $arg argument" unless exists $args{$arg};
2083                                                     }
2084         371                               1860      my ($lr, $rr, $key_cols, $tbl_struct) = @args{@required_args};
2085         371                                901      MKDEBUG && _d('Comparing keys using columns:', join(',', @$key_cols));
2086                                                  
2087         371                               1320      my $callback = $self->{key_cmp};
2088         371                               1219      my $trf      = $self->{trf};
2089                                                  
2090         371                               1288      foreach my $col ( @$key_cols ) {
2091         489                               1637         my $l = $lr->{$col};
2092         489                               1578         my $r = $rr->{$col};
2093  ***    489    100     66                 4156         if ( !defined $l || !defined $r ) {
2094           1                                  3            MKDEBUG && _d($col, 'is not defined in both rows');
2095  ***      1     50                          10            return defined $l ? 1 : defined $r ? -1 : 0;
      ***            50                               
2096                                                        }
2097                                                        else {
2098         488    100                        2619            if ( $tbl_struct->{is_numeric}->{$col} ) {   # Numeric column
                    100                               
2099         422                                993               MKDEBUG && _d($col, 'is numeric');
2100  ***    422     50                        1505               ($l, $r) = $trf->($l, $r, $tbl_struct, $col) if $trf;
2101         422                               1491               my $cmp = $l <=> $r;
2102         422    100                        2129               if ( $cmp ) {
2103          21                                 57                  MKDEBUG && _d('Column', $col, 'differs:', $l, '!=', $r);
2104  ***     21     50                          80                  $callback->($col, $l, $r) if $callback;
2105          21                                140                  return $cmp;
2106                                                              }
2107                                                           }
2108                                                           elsif ( $l ne $r ) {
2109           1                                  2               my $cmp;
2110           1                                  6               my $coll = $tbl_struct->{collation_for}->{$col};
2111  ***      1     50      0                    5               if ( $coll && ( $coll ne 'latin1_swedish_ci'
      ***                    0                        
      ***                   33                        
2112                                                                             || $l =~ m/[^\040-\177]/ || $r =~ m/[^\040-\177]/) )
2113                                                              {
2114  ***      0                                  0                  MKDEBUG && _d('Comparing', $col, 'via MySQL');
2115  ***      0                                  0                  $cmp = $self->db_cmp($coll, $l, $r);
2116                                                              }
2117                                                              else {
2118           1                                  2                  MKDEBUG && _d('Comparing', $col, 'in lowercase');
2119           1                                 10                  $cmp = lc $l cmp lc $r;
2120                                                              }
2121  ***      1     50                           5               if ( $cmp ) {
2122           1                                  2                  MKDEBUG && _d('Column', $col, 'differs:', $l, 'ne', $r);
2123  ***      1     50                           4                  $callback->($col, $l, $r) if $callback;
2124           1                                  6                  return $cmp;
2125                                                              }
2126                                                           }
2127                                                        }
2128                                                     }
2129         348                               2028      return 0;
2130                                                  }
2131                                                  
2132                                                  sub db_cmp {
2133  ***      0                    0             0      my ( $self, $collation, $l, $r ) = @_;
2134  ***      0      0                           0      if ( !$self->{sth}->{$collation} ) {
2135  ***      0      0                           0         if ( !$self->{charset_for} ) {
2136  ***      0                                  0            MKDEBUG && _d('Fetching collations from MySQL');
2137  ***      0                                  0            my @collations = @{$self->{dbh}->selectall_arrayref(
      ***      0                                  0   
2138                                                              'SHOW COLLATION', {Slice => { collation => 1, charset => 1 }})};
2139  ***      0                                  0            foreach my $collation ( @collations ) {
2140  ***      0                                  0               $self->{charset_for}->{$collation->{collation}}
2141                                                                 = $collation->{charset};
2142                                                           }
2143                                                        }
2144  ***      0                                  0         my $sql = "SELECT STRCMP(_$self->{charset_for}->{$collation}? COLLATE $collation, "
2145                                                           . "_$self->{charset_for}->{$collation}? COLLATE $collation) AS res";
2146  ***      0                                  0         MKDEBUG && _d($sql);
2147  ***      0                                  0         $self->{sth}->{$collation} = $self->{dbh}->prepare($sql);
2148                                                     }
2149  ***      0                                  0      my $sth = $self->{sth}->{$collation};
2150  ***      0                                  0      $sth->execute($l, $r);
2151  ***      0                                  0      return $sth->fetchall_arrayref()->[0]->[0];
2152                                                  }
2153                                                  
2154                                                  sub _d {
2155  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2156  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2157  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2158                                                          @_;
2159  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2160                                                  }
2161                                                  
2162                                                  1;
2163                                                  
2164                                                  # ###########################################################################
2165                                                  # End RowDiff package
2166                                                  # ###########################################################################
2167                                                  
2168                                                  # ###########################################################################
2169                                                  # MySQLDump package 6345
2170                                                  # This package is a copy without comments from the original.  The original
2171                                                  # with comments and its test file can be found in the SVN repository at,
2172                                                  #   trunk/common/MySQLDump.pm
2173                                                  #   trunk/common/t/MySQLDump.t
2174                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2175                                                  # ###########################################################################
2176                                                  package MySQLDump;
2177                                                  
2178          36                   36           276   use strict;
              36                                 90   
              36                                196   
2179          36                   36           232   use warnings FATAL => 'all';
              36                                101   
              36                                200   
2180                                                  
2181          36                   36           225   use English qw(-no_match_vars);
              36                                 93   
              36                                182   
2182                                                  
2183  ***     36            50     36           231   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 86   
              36                                496   
2184                                                  
2185                                                  ( our $before = <<'EOF') =~ s/^   //gm;
2186                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
2187                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
2188                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
2189                                                     /*!40101 SET NAMES utf8 */;
2190                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
2191                                                     /*!40103 SET TIME_ZONE='+00:00' */;
2192                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
2193                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2194                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2195                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2196                                                  EOF
2197                                                  
2198                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2199                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2200                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2201                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2202                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2203                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2204                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2205                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2206                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2207                                                  EOF
2208                                                  
2209                                                  sub new {
2210          26                   26           276      my ( $class, %args ) = @_;
2211          26                                152      my $self = {
2212                                                        cache => 0,  # Afaik no script uses this cache any longer because
2213                                                     };
2214          26                                357      return bless $self, $class;
2215                                                  }
2216                                                  
2217                                                  sub dump {
2218  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2219                                                  
2220  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2221  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2222  ***      0      0                           0         return unless $ddl;
2223  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
2224  ***      0                                  0            return $before
2225                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2226                                                              . $ddl->[1] . ";\n";
2227                                                        }
2228                                                        else {
2229  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2230                                                              . '/*!50001 DROP VIEW IF EXISTS '
2231                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2232                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2233                                                        }
2234                                                     }
2235                                                     elsif ( $what eq 'triggers' ) {
2236  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2237  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
2238  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
2239  ***      0                                  0            foreach my $trg ( @$trgs ) {
2240  ***      0      0                           0               if ( $trg->{sql_mode} ) {
2241  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2242                                                              }
2243  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
2244  ***      0      0                           0               if ( $trg->{definer} ) {
2245  ***      0                                  0                  my ( $user, $host )
2246  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
2247                                                                      split('@', $trg->{definer}, 2);
2248  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
2249                                                              }
2250  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2251                                                                 $quoter->quote($trg->{trigger}),
2252  ***      0                                  0                  @{$trg}{qw(timing event)},
2253                                                                 $quoter->quote($trg->{table}),
2254                                                                 $trg->{statement});
2255                                                           }
2256  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2257  ***      0                                  0            return $result;
2258                                                        }
2259                                                        else {
2260  ***      0                                  0            return undef;
2261                                                        }
2262                                                     }
2263                                                     elsif ( $what eq 'view' ) {
2264  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2265  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2266                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2267                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2268                                                     }
2269                                                     else {
2270  ***      0                                  0         die "You didn't say what to dump.";
2271                                                     }
2272                                                  }
2273                                                  
2274                                                  sub _use_db {
2275          62                   62           530      my ( $self, $dbh, $quoter, $new ) = @_;
2276  ***     62     50                         377      if ( !$new ) {
2277  ***      0                                  0         MKDEBUG && _d('No new DB to use');
2278  ***      0                                  0         return;
2279                                                     }
2280          62                                377      my $sql = 'USE ' . $quoter->quote($new);
2281          62                                182      MKDEBUG && _d($dbh, $sql);
2282          62                               5929      $dbh->do($sql);
2283          62                                343      return;
2284                                                  }
2285                                                  
2286                                                  sub get_create_table {
2287          62                   62           459      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2288  ***     62     50     33                  580      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2289          62                                253         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2290                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2291                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2292                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2293          62                                172         MKDEBUG && _d($sql);
2294          62                                190         eval { $dbh->do($sql); };
              62                               8765   
2295          62                                253         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2296          62                                452         $self->_use_db($dbh, $quoter, $db);
2297          62                                349         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2298          62                                197         MKDEBUG && _d($sql);
2299          62                                195         my $href;
2300          62                                199         eval { $href = $dbh->selectrow_hashref($sql); };
              62                                178   
2301  ***     62     50                         526         if ( $EVAL_ERROR ) {
2302  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2303  ***      0                                  0            return;
2304                                                        }
2305                                                  
2306          62                                241         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2307                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2308          62                                166         MKDEBUG && _d($sql);
2309          62                               6765         $dbh->do($sql);
2310          62                                491         my ($key) = grep { m/create table/i } keys %$href;
             124                                910   
2311  ***     62     50                         354         if ( $key ) {
2312          62                                178            MKDEBUG && _d('This table is a base table');
2313          62                                830            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2314                                                        }
2315                                                        else {
2316  ***      0                                  0            MKDEBUG && _d('This table is a view');
2317  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
2318  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2319                                                        }
2320                                                     }
2321          62                                497      return $self->{tables}->{$db}->{$tbl};
2322                                                  }
2323                                                  
2324                                                  sub get_columns {
2325  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2326  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
2327  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2328  ***      0                                  0         $self->_use_db($dbh, $quoter, $db);
2329  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2330  ***      0                                  0         MKDEBUG && _d($sql);
2331  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2332                                                  
2333  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
2334                                                           map {
2335  ***      0                                  0               my %row;
2336  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2337  ***      0                                  0               \%row;
2338                                                           } @$cols
2339                                                        ];
2340                                                     }
2341  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
2342                                                  }
2343                                                  
2344                                                  sub get_tmp_table {
2345  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2346  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2347  ***      0                                  0      $result .= join(",\n",
2348  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2349  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2350  ***      0                                  0      $result .= "\n)";
2351  ***      0                                  0      MKDEBUG && _d($result);
2352  ***      0                                  0      return $result;
2353                                                  }
2354                                                  
2355                                                  sub get_triggers {
2356          30                   30           238      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2357  ***     30     50     33                  305      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2358          30                                222         $self->{triggers}->{$db} = {};
2359          30                                138         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2360                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2361                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2362                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2363          30                                 79         MKDEBUG && _d($sql);
2364          30                                133         eval { $dbh->do($sql); };
              30                               4846   
2365          30                                121         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2366          30                                203         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2367          30                                101         MKDEBUG && _d($sql);
2368          30                                 84         my $sth = $dbh->prepare($sql);
2369          30                              17639         $sth->execute();
2370  ***     30     50                         768         if ( $sth->rows ) {
2371  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
2372  ***      0                                  0            foreach my $trg (@$trgs) {
2373  ***      0                                  0               my %trg;
2374  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
2375  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
2376                                                           }
2377                                                        }
2378          30                                151         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2379                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2380          30                                 98         MKDEBUG && _d($sql);
2381          30                               5024         $dbh->do($sql);
2382                                                     }
2383  ***     30     50                         202      if ( $tbl ) {
2384          30                                498         return $self->{triggers}->{$db}->{$tbl};
2385                                                     }
2386  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
2387                                                  }
2388                                                  
2389                                                  sub get_databases {
2390  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
2391  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2392  ***      0                                  0         my $sql = 'SHOW DATABASES';
2393  ***      0                                  0         my @params;
2394  ***      0      0                           0         if ( $like ) {
2395  ***      0                                  0            $sql .= ' LIKE ?';
2396  ***      0                                  0            push @params, $like;
2397                                                        }
2398  ***      0                                  0         my $sth = $dbh->prepare($sql);
2399  ***      0                                  0         MKDEBUG && _d($sql, @params);
2400  ***      0                                  0         $sth->execute( @params );
2401  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
2402  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
2403  ***      0                                  0         return @dbs;
2404                                                     }
2405  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
2406                                                  }
2407                                                  
2408                                                  sub get_table_status {
2409  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2410  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2411  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2412  ***      0                                  0         my @params;
2413  ***      0      0                           0         if ( $like ) {
2414  ***      0                                  0            $sql .= ' LIKE ?';
2415  ***      0                                  0            push @params, $like;
2416                                                        }
2417  ***      0                                  0         MKDEBUG && _d($sql, @params);
2418  ***      0                                  0         my $sth = $dbh->prepare($sql);
2419  ***      0                                  0         $sth->execute(@params);
2420  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2421  ***      0                                  0         @tables = map {
2422  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
2423  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2424  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2425  ***      0                                  0            delete $tbl{type};
2426  ***      0                                  0            \%tbl;
2427                                                        } @tables;
2428  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
2429  ***      0                                  0         return @tables;
2430                                                     }
2431  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
2432                                                  }
2433                                                  
2434                                                  sub get_table_list {
2435  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2436  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2437  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2438  ***      0                                  0         my @params;
2439  ***      0      0                           0         if ( $like ) {
2440  ***      0                                  0            $sql .= ' LIKE ?';
2441  ***      0                                  0            push @params, $like;
2442                                                        }
2443  ***      0                                  0         MKDEBUG && _d($sql, @params);
2444  ***      0                                  0         my $sth = $dbh->prepare($sql);
2445  ***      0                                  0         $sth->execute(@params);
2446  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
2447  ***      0      0      0                    0         @tables = map {
2448  ***      0                                  0            my %tbl = (
2449                                                              name   => $_->[0],
2450                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2451                                                           );
2452  ***      0                                  0            \%tbl;
2453                                                        } @tables;
2454  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
2455  ***      0                                  0         return @tables;
2456                                                     }
2457  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
2458                                                  }
2459                                                  
2460                                                  sub _d {
2461  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2462  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2463  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2464                                                          @_;
2465  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2466                                                  }
2467                                                  
2468                                                  1;
2469                                                  
2470                                                  # ###########################################################################
2471                                                  # End MySQLDump package
2472                                                  # ###########################################################################
2473                                                  
2474                                                  # ###########################################################################
2475                                                  # ChangeHandler package 6514
2476                                                  # This package is a copy without comments from the original.  The original
2477                                                  # with comments and its test file can be found in the SVN repository at,
2478                                                  #   trunk/common/ChangeHandler.pm
2479                                                  #   trunk/common/t/ChangeHandler.t
2480                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2481                                                  # ###########################################################################
2482                                                  package ChangeHandler;
2483                                                  
2484          36                   36           277   use strict;
              36                                106   
              36                                201   
2485          36                   36           216   use warnings FATAL => 'all';
              36                                 93   
              36                                205   
2486          36                   36           216   use English qw(-no_match_vars);
              36                                 92   
              36                                186   
2487                                                  
2488                                                  my $DUPE_KEY  = qr/Duplicate entry/;
2489                                                  our @ACTIONS  = qw(DELETE REPLACE INSERT UPDATE);
2490                                                  
2491  ***     36            50     36           238   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 96   
              36                                545   
2492                                                  
2493                                                  sub new {
2494          28                   28           529      my ( $class, %args ) = @_;
2495          28                                253      foreach my $arg ( qw(Quoter left_db left_tbl right_db right_tbl
2496                                                                          replace queue) ) {
2497  ***    196     50                        1095         die "I need a $arg argument" unless defined $args{$arg};
2498                                                     }
2499          28                                123      my $q = $args{Quoter};
2500                                                  
2501          28                                423      my $self = {
2502                                                        hex_blob     => 1,
2503                                                        %args,
2504                                                        left_db_tbl  => $q->quote(@args{qw(left_db left_tbl)}),
2505                                                        right_db_tbl => $q->quote(@args{qw(right_db right_tbl)}),
2506                                                     };
2507                                                  
2508          28                                210      $self->{src_db_tbl} = $self->{left_db_tbl};
2509          28                                165      $self->{dst_db_tbl} = $self->{right_db_tbl};
2510                                                  
2511          28                                136      map { $self->{$_} = [] } @ACTIONS;
             112                                866   
2512          28                                165      $self->{changes} = { map { $_ => 0 } @ACTIONS };
             112                                556   
2513                                                  
2514          28                                446      return bless $self, $class;
2515                                                  }
2516                                                  
2517                                                  sub fetch_back {
2518          56                   56           270      my ( $self, $dbh ) = @_;
2519          56                                256      $self->{fetch_back} = $dbh;
2520          56                                155      MKDEBUG && _d('Set fetch back dbh', $dbh);
2521          56                                191      return;
2522                                                  }
2523                                                  
2524                                                  sub set_src {
2525          36                   36           192      my ( $self, $src, $dbh ) = @_;
2526  ***     36     50                         172      die "I need a src argument" unless $src;
2527          36    100                         218      if ( lc $src eq 'left' ) {
      ***            50                               
2528          16                                 85         $self->{src_db_tbl} = $self->{left_db_tbl};
2529          16                                 89         $self->{dst_db_tbl} = $self->{right_db_tbl};
2530                                                     }
2531                                                     elsif ( lc $src eq 'right' ) {
2532          20                                100         $self->{src_db_tbl} = $self->{right_db_tbl};
2533          20                                102         $self->{dst_db_tbl} = $self->{left_db_tbl}; 
2534                                                     }
2535                                                     else {
2536  ***      0                                  0         die "src argument must be either 'left' or 'right'"
2537                                                     }
2538          36                                 96      MKDEBUG && _d('Set src to', $src);
2539  ***     36     50                         237      $self->fetch_back($dbh) if $dbh;
2540          36                                107      return;
2541                                                  }
2542                                                  
2543                                                  sub src {
2544  ***      0                    0             0      my ( $self ) = @_;
2545  ***      0                                  0      return $self->{src_db_tbl};
2546                                                  }
2547                                                  
2548                                                  sub dst {
2549  ***      0                    0             0      my ( $self ) = @_;
2550  ***      0                                  0      return $self->{dst_db_tbl};
2551                                                  }
2552                                                  
2553                                                  sub _take_action {
2554          73                   73           404      my ( $self, $sql, $dbh ) = @_;
2555          73                                230      MKDEBUG && _d('Calling subroutines on', $dbh, $sql);
2556          73                                227      foreach my $action ( @{$self->{actions}} ) {
              73                                432   
2557         124                                641         $action->($sql, $dbh);
2558                                                     }
2559          73                                452      return;
2560                                                  }
2561                                                  
2562                                                  sub change {
2563          76                   76           478      my ( $self, $action, $row, $cols, $dbh ) = @_;
2564          76                                229      MKDEBUG && _d($dbh, $action, 'where', $self->make_where_clause($row, $cols));
2565                                                  
2566          76    100                         374      return unless $action;
2567                                                  
2568                                                     $self->{changes}->{
2569          73    100    100                  690         $self->{replace} && $action ne 'DELETE' ? 'REPLACE' : $action
2570                                                     }++;
2571          73    100                         363      if ( $self->{queue} ) {
2572          37                                218         $self->__queue($action, $row, $cols, $dbh);
2573                                                     }
2574                                                     else {
2575          36                                109         eval {
2576          36                                163            my $func = "make_$action";
2577          36                                249            $self->_take_action($self->$func($row, $cols), $dbh);
2578                                                        };
2579  ***     36     50                         418         if ( $EVAL_ERROR =~ m/$DUPE_KEY/ ) {
      ***            50                               
2580  ***      0                                  0            MKDEBUG && _d('Duplicate key violation; will queue and rewrite');
2581  ***      0                                  0            $self->{queue}++;
2582  ***      0                                  0            $self->{replace} = 1;
2583  ***      0                                  0            $self->__queue($action, $row, $cols, $dbh);
2584                                                        }
2585                                                        elsif ( $EVAL_ERROR ) {
2586  ***      0                                  0            die $EVAL_ERROR;
2587                                                        }
2588                                                     }
2589          73                                476      return;
2590                                                  }
2591                                                  
2592                                                  sub __queue {
2593          37                   37           218      my ( $self, $action, $row, $cols, $dbh ) = @_;
2594          37                                114      MKDEBUG && _d('Queueing change for later');
2595          37    100                         192      if ( $self->{replace} ) {
2596          13    100                         122         $action = $action eq 'DELETE' ? $action : 'REPLACE';
2597                                                     }
2598          37                                114      push @{$self->{$action}}, [ $row, $cols, $dbh ];
              37                                260   
2599                                                  }
2600                                                  
2601                                                  sub process_rows {
2602         124                  124           783      my ( $self, $queue_level, $trace_msg ) = @_;
2603         124                                505      my $error_count = 0;
2604                                                     TRY: {
2605  ***    124     50     66                  417         if ( $queue_level && $queue_level < $self->{queue} ) { # see redo below!
             124                               1355   
2606  ***      0                                  0            MKDEBUG && _d('Not processing now', $queue_level, '<', $self->{queue});
2607  ***      0                                  0            return;
2608                                                        }
2609         124                                338         MKDEBUG && _d('Processing rows:');
2610         124                                433         my ($row, $cur_act);
2611         124                                387         eval {
2612         124                                663            foreach my $action ( @ACTIONS ) {
2613         496                               1994               my $func = "make_$action";
2614         496                               1962               my $rows = $self->{$action};
2615         496                               1255               MKDEBUG && _d(scalar(@$rows), 'to', $action);
2616         496                               1548               $cur_act = $action;
2617         496                               2906               while ( @$rows ) {
2618          37                                159                  $row    = shift @$rows;
2619          37                                351                  my $sql = $self->$func(@$row);
2620  ***     37     50                         291                  $sql   .= " /*maatkit $trace_msg*/" if $trace_msg;
2621          37                                258                  $self->_take_action($sql, $row->[2]);
2622                                                              }
2623                                                           }
2624         124                                503            $error_count = 0;
2625                                                        };
2626  ***    124     50     33                 2772         if ( !$error_count++ && $EVAL_ERROR =~ m/$DUPE_KEY/ ) {
      ***            50                               
2627  ***      0                                  0            MKDEBUG && _d('Duplicate key violation; re-queueing and rewriting');
2628  ***      0                                  0            $self->{queue}++; # Defer rows to the very end
2629  ***      0                                  0            $self->{replace} = 1;
2630  ***      0                                  0            $self->__queue($cur_act, @$row);
2631  ***      0                                  0            redo TRY;
2632                                                        }
2633                                                        elsif ( $EVAL_ERROR ) {
2634  ***      0                                  0            die $EVAL_ERROR;
2635                                                        }
2636                                                     }
2637                                                  }
2638                                                  
2639                                                  sub make_DELETE {
2640           6                    6            26      my ( $self, $row, $cols ) = @_;
2641           6                                 18      MKDEBUG && _d('Make DELETE');
2642           6                                 61      return "DELETE FROM $self->{dst_db_tbl} WHERE "
2643                                                        . $self->make_where_clause($row, $cols)
2644                                                        . ' LIMIT 1';
2645                                                  }
2646                                                  
2647                                                  sub make_UPDATE {
2648          25                   25          1831      my ( $self, $row, $cols ) = @_;
2649          25                                 76      MKDEBUG && _d('Make UPDATE');
2650  ***     25     50                         138      if ( $self->{replace} ) {
2651  ***      0                                  0         return $self->make_row('REPLACE', $row, $cols);
2652                                                     }
2653          25                                116      my %in_where = map { $_ => 1 } @$cols;
              26                                175   
2654          25                                176      my $where = $self->make_where_clause($row, $cols);
2655          25                                 76      my @cols;
2656  ***     25     50                         146      if ( my $dbh = $self->{fetch_back} ) {
2657          25                                149         my $sql = $self->make_fetch_back_query($where);
2658          25                                 68         MKDEBUG && _d('Fetching data on dbh', $dbh, 'for UPDATE:', $sql);
2659          25                                 72         my $res = $dbh->selectrow_hashref($sql);
2660          25                                298         @{$row}{keys %$res} = values %$res;
              25                                175   
2661          25                                183         @cols = $self->sort_cols($res);
2662                                                     }
2663                                                     else {
2664  ***      0                                  0         @cols = $self->sort_cols($row);
2665                                                     }
2666          69                                369      return "UPDATE $self->{dst_db_tbl} SET "
2667                                                        . join(', ', map {
2668          95                                421               $self->{Quoter}->quote($_)
2669                                                              . '=' .  $self->{Quoter}->quote_val($row->{$_})
2670          25                                213            } grep { !$in_where{$_} } @cols)
2671                                                        . " WHERE $where LIMIT 1";
2672                                                  }
2673                                                  
2674                                                  sub make_INSERT {
2675          33                   33           172      my ( $self, $row, $cols ) = @_;
2676          33                                 99      MKDEBUG && _d('Make INSERT');
2677  ***     33     50                         180      if ( $self->{replace} ) {
2678  ***      0                                  0         return $self->make_row('REPLACE', $row, $cols);
2679                                                     }
2680          33                                212      return $self->make_row('INSERT', $row, $cols);
2681                                                  }
2682                                                  
2683                                                  sub make_REPLACE {
2684           9                    9            42      my ( $self, $row, $cols ) = @_;
2685           9                                 27      MKDEBUG && _d('Make REPLACE');
2686           9                                 62      return $self->make_row('REPLACE', $row, $cols);
2687                                                  }
2688                                                  
2689                                                  sub make_row {
2690          42                   42           237      my ( $self, $verb, $row, $cols ) = @_;
2691          42                                144      my @cols; 
2692          42    100                         238      if ( my $dbh = $self->{fetch_back} ) {
2693          30                                179         my $where = $self->make_where_clause($row, $cols);
2694          30                                191         my $sql   = $self->make_fetch_back_query($where);
2695          30                                 82         MKDEBUG && _d('Fetching data on dbh', $dbh, 'for', $verb, ':', $sql);
2696          30                                 87         my $res = $dbh->selectrow_hashref($sql);
2697          30                                321         @{$row}{keys %$res} = values %$res;
              30                                201   
2698          30                                223         @cols = $self->sort_cols($res);
2699                                                     }
2700                                                     else {
2701          12                                 77         @cols = $self->sort_cols($row);
2702                                                     }
2703          42                                203      my $q = $self->{Quoter};
2704         115                                494      return "$verb INTO $self->{dst_db_tbl}("
2705         115                                496         . join(', ', map { $q->quote($_) } @cols)
2706                                                        . ') VALUES ('
2707          42                                315         . join(', ', map { $q->quote_val($_) } @{$row}{@cols} )
              42                                195   
2708                                                        . ')';
2709                                                  }
2710                                                  
2711                                                  sub make_where_clause {
2712          65                   65           351      my ( $self, $row, $cols ) = @_;
2713          80                                341      my @clauses = map {
2714          65                                301         my $val = $row->{$_};
2715  ***     80     50                         365         my $sep = defined $val ? '=' : ' IS ';
2716          80                                458         $self->{Quoter}->quote($_) . $sep . $self->{Quoter}->quote_val($val);
2717                                                     } @$cols;
2718          65                                432      return join(' AND ', @clauses);
2719                                                  }
2720                                                  
2721                                                  sub get_changes {
2722          27                   27           131      my ( $self ) = @_;
2723          27                                 97      return %{$self->{changes}};
              27                                297   
2724                                                  }
2725                                                  
2726                                                  sub sort_cols {
2727          67                   67           317      my ( $self, $row ) = @_;
2728          67                                216      my @cols;
2729  ***     67     50                         369      if ( $self->{tbl_struct} ) { 
2730          67                                388         my $pos = $self->{tbl_struct}->{col_posn};
2731          67                                189         my @not_in_tbl;
2732         219                                931         @cols = sort {
2733                                                              $pos->{$a} <=> $pos->{$b}
2734                                                           }
2735                                                           grep {
2736  ***     67     50                         355               if ( !defined $pos->{$_} ) {
             210                               1021   
2737  ***      0                                  0                  push @not_in_tbl, $_;
2738  ***      0                                  0                  0;
2739                                                              }
2740                                                              else {
2741         210                                667                  1;
2742                                                              }
2743                                                           }
2744                                                           keys %$row;
2745  ***     67     50                         664         push @cols, @not_in_tbl if @not_in_tbl;
2746                                                     }
2747                                                     else {
2748  ***      0                                  0         @cols = sort keys %$row;
2749                                                     }
2750          67                                580      return @cols;
2751                                                  }
2752                                                  
2753                                                  sub make_fetch_back_query {
2754          55                   55           284      my ( $self, $where ) = @_;
2755  ***     55     50                         277      die "I need a where argument" unless $where;
2756          55                                189      my $cols       = '*';
2757          55                                219      my $tbl_struct = $self->{tbl_struct};
2758  ***     55     50                         275      if ( $tbl_struct ) {
2759         192                                631         $cols = join(', ',
2760                                                           map {
2761          55                                344               my $col = $_;
2762         192    100    100                 2422               if (    $self->{hex_blob}
2763                                                                   && $tbl_struct->{type_for}->{$col} =~ m/blob|text|binary/ ) {
2764           2                                 22                  $col = "IF(`$col`='', '', CONCAT('0x', HEX(`$col`))) AS `$col`";
2765                                                              }
2766                                                              else {
2767         190                                770                  $col = "`$col`";
2768                                                              }
2769         192                                786               $col;
2770          55                                217            } @{ $tbl_struct->{cols} }
2771                                                        );
2772                                                  
2773  ***     55     50                         302         if ( !$cols ) {
2774  ***      0                                  0            MKDEBUG && _d('Failed to make explicit columns list from tbl struct');
2775  ***      0                                  0            $cols = '*';
2776                                                        }
2777                                                     }
2778          55                                479      return "SELECT $cols FROM $self->{src_db_tbl} WHERE $where LIMIT 1";
2779                                                  }
2780                                                  
2781                                                  sub _d {
2782  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2783  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2784  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2785                                                          @_;
2786  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2787                                                  }
2788                                                  
2789                                                  1;
2790                                                  
2791                                                  # ###########################################################################
2792                                                  # End ChangeHandler package
2793                                                  # ###########################################################################
2794                                                  
2795                                                  # ###########################################################################
2796                                                  # TableChunker package 6492
2797                                                  # This package is a copy without comments from the original.  The original
2798                                                  # with comments and its test file can be found in the SVN repository at,
2799                                                  #   trunk/common/TableChunker.pm
2800                                                  #   trunk/common/t/TableChunker.t
2801                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2802                                                  # ###########################################################################
2803                                                  package TableChunker;
2804                                                  
2805                                                  
2806          36                   36           277   use strict;
              36                                 97   
              36                                198   
2807          36                   36           215   use warnings FATAL => 'all';
              36                                 97   
              36                                195   
2808          36                   36           214   use English qw(-no_match_vars);
              36                                 84   
              36                                201   
2809                                                  
2810          36                   36           252   use POSIX qw(ceil);
              36                                 97   
              36                                333   
2811          36                   36           245   use List::Util qw(min max);
              36                                184   
              36                                376   
2812          36                   36           224   use Data::Dumper;
              36                                100   
              36                                192   
2813                                                  $Data::Dumper::Indent    = 1;
2814                                                  $Data::Dumper::Sortkeys  = 1;
2815                                                  $Data::Dumper::Quotekeys = 0;
2816                                                  
2817  ***     36            50     36           234   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 92   
              36                                519   
2818                                                  
2819                                                  sub new {
2820          26                   26           254      my ( $class, %args ) = @_;
2821          26                                192      foreach my $arg ( qw(Quoter MySQLDump) ) {
2822  ***     52     50                         376         die "I need a $arg argument" unless $args{$arg};
2823                                                     }
2824          26                                190      my $self = { %args };
2825          26                                401      return bless $self, $class;
2826                                                  }
2827                                                  
2828                                                  my $EPOCH      = '1970-01-01';
2829                                                  my %int_types  = map { $_ => 1 }
2830                                                     qw(bigint date datetime int mediumint smallint time timestamp tinyint year);
2831                                                  my %real_types = map { $_ => 1 }
2832                                                     qw(decimal double float);
2833                                                  
2834                                                  sub find_chunk_columns {
2835          20                   20           572      my ( $self, %args ) = @_;
2836          20                                237      foreach my $arg ( qw(tbl_struct) ) {
2837  ***     20     50                         171         die "I need a $arg argument" unless $args{$arg};
2838                                                     }
2839          20                                 97      my $tbl_struct = $args{tbl_struct};
2840                                                  
2841          20                                119      my @possible_indexes;
2842          20                                 73      foreach my $index ( values %{ $tbl_struct->{keys} } ) {
              20                                160   
2843                                                  
2844  ***     28     50                         196         next unless $index->{type} eq 'BTREE';
2845                                                  
2846  ***     28            33                   82         defined $_ && next for @{ $index->{col_prefixes} };
              28                                 92   
              28                                290   
2847                                                  
2848  ***     28     50                         180         if ( $args{exact} ) {
2849          28    100    100                  270            next unless $index->{is_unique} && @{$index->{cols}} == 1;
              21                                229   
2850                                                        }
2851                                                  
2852          16                                104         push @possible_indexes, $index;
2853                                                     }
2854                                                     MKDEBUG && _d('Possible chunk indexes in order:',
2855          20                                 72         join(', ', map { $_->{name} } @possible_indexes));
2856                                                  
2857          20                                 73      my $can_chunk_exact = 0;
2858          20                                 75      my @candidate_cols;
2859          20                                100      foreach my $index ( @possible_indexes ) { 
2860          16                                100         my $col = $index->{cols}->[0];
2861                                                  
2862  ***     16     50     33                  197         next unless ( $int_types{$tbl_struct->{type_for}->{$col}}
2863                                                                      || $real_types{$tbl_struct->{type_for}->{$col}} );
2864                                                  
2865          16                                213         push @candidate_cols, { column => $col, index => $index->{name} };
2866                                                     }
2867                                                  
2868  ***     20    100     50                  303      $can_chunk_exact = 1 if $args{exact} && scalar @candidate_cols;
2869                                                  
2870          20                                 66      if ( MKDEBUG ) {
2871                                                        my $chunk_type = $args{exact} ? 'Exact' : 'Inexact';
2872                                                        _d($chunk_type, 'chunkable:',
2873                                                           join(', ', map { "$_->{column} on $_->{index}" } @candidate_cols));
2874                                                     }
2875                                                  
2876          20                                 76      my @result;
2877          20                                 59      MKDEBUG && _d('Ordering columns by order in tbl, PK first');
2878          20    100                         178      if ( $tbl_struct->{keys}->{PRIMARY} ) {
2879          18                                132         my $pk_first_col = $tbl_struct->{keys}->{PRIMARY}->{cols}->[0];
2880          18                                 71         @result          = grep { $_->{column} eq $pk_first_col } @candidate_cols;
              15                                111   
2881          18                                 90         @candidate_cols  = grep { $_->{column} ne $pk_first_col } @candidate_cols;
              15                                106   
2882                                                     }
2883          20                                 84      my $i = 0;
2884          20                                 74      my %col_pos = map { $_ => $i++ } @{$tbl_struct->{cols}};
              58                                350   
              20                                126   
2885          20                                177      push @result, sort { $col_pos{$a->{column}} <=> $col_pos{$b->{column}} }
      ***      0                                  0   
2886                                                                      @candidate_cols;
2887                                                  
2888          20                                 59      if ( MKDEBUG ) {
2889                                                        _d('Chunkable columns:',
2890                                                           join(', ', map { "$_->{column} on $_->{index}" } @result));
2891                                                        _d('Can chunk exactly:', $can_chunk_exact);
2892                                                     }
2893                                                  
2894          20                                275      return ($can_chunk_exact, @result);
2895                                                  }
2896                                                  
2897                                                  sub calculate_chunks {
2898          14                   14           451      my ( $self, %args ) = @_;
2899          14                                227      my @required_args = qw(dbh db tbl tbl_struct chunk_col min max rows_in_range
2900                                                                            chunk_size);
2901          14                                 92      foreach my $arg ( @required_args ) {
2902  ***    126     50                         761         die "I need a $arg argument" unless defined $args{$arg};
2903                                                     }
2904          14                                 50      MKDEBUG && _d('Calculate chunks for', Dumper(\%args));
2905          14                                106      my ($dbh, $db, $tbl) = @args{@required_args};
2906          14                                 62      my $q        = $self->{Quoter};
2907          14                                 86      my $db_tbl   = $q->quote($db, $tbl);
2908          14                                111      my $col_type = $args{tbl_struct}->{type_for}->{$args{chunk_col}};
2909          14                                 46      MKDEBUG && _d('chunk col type:', $col_type);
2910                                                  
2911          14                                146      my $range_func = $self->range_func_for($col_type);
2912          14                                 56      my ($start_point, $end_point);
2913          14                                 53      eval {
2914          14                                140         $start_point = $self->value_to_number(
2915                                                           value       => $args{min},
2916                                                           column_type => $col_type,
2917                                                           dbh         => $dbh,
2918                                                        );
2919          14                                104         $end_point  = $self->value_to_number(
2920                                                           value       => $args{max},
2921                                                           column_type => $col_type,
2922                                                           dbh         => $dbh,
2923                                                        );
2924                                                     };
2925  ***     14     50                          88      if ( $EVAL_ERROR ) {
2926  ***      0      0                           0         if ( $EVAL_ERROR =~ m/don't know how to chunk/ ) {
2927  ***      0                                  0            die $EVAL_ERROR;
2928                                                        }
2929                                                        else {
2930  ***      0      0                           0            die "Error calculating chunk start and end points for table "
2931                                                              . "`$args{tbl_struct}->{name}` on column `$args{chunk_col}` "
2932                                                              . "with min/max values "
2933                                                              . join('/',
2934  ***      0                                  0                     map { defined $args{$_} ? $args{$_} : 'undef' } qw(min max))
2935                                                              . ":\n\n"
2936                                                              . $EVAL_ERROR
2937                                                              . "\nVerify that the min and max values are valid for the column.  "
2938                                                              . "If they are valid, this error could be caused by a bug in the "
2939                                                              . "tool.";
2940                                                        }
2941                                                     }
2942                                                  
2943  ***     14     50                          84      if ( !defined $start_point ) {
2944  ***      0                                  0         MKDEBUG && _d('Start point is undefined');
2945  ***      0                                  0         $start_point = 0;
2946                                                     }
2947  ***     14     50     33                  232      if ( !defined $end_point || $end_point < $start_point ) {
2948  ***      0                                  0         MKDEBUG && _d('End point is undefined or before start point');
2949  ***      0                                  0         $end_point = 0;
2950                                                     }
2951          14                                 40      MKDEBUG && _d("Actual chunk range:", $start_point, "to", $end_point);
2952                                                  
2953          14                                 69      my $have_zero_chunk = 0;
2954  ***     14     50                          93      if ( $args{zero_chunk} ) {
2955  ***      0      0      0                    0         if ( $start_point != $end_point && $start_point >= 0 ) {
2956  ***      0                                  0            MKDEBUG && _d('Zero chunking');
2957  ***      0                                  0            my $nonzero_val = $self->get_nonzero_value(
2958                                                              %args,
2959                                                              db_tbl   => $db_tbl,
2960                                                              col      => $args{chunk_col},
2961                                                              col_type => $col_type,
2962                                                              val      => $args{min}
2963                                                           );
2964  ***      0                                  0            $start_point = $self->value_to_number(
2965                                                              value       => $nonzero_val,
2966                                                              column_type => $col_type,
2967                                                              dbh         => $dbh,
2968                                                           );
2969  ***      0                                  0            $have_zero_chunk = 1;
2970                                                        }
2971                                                        else {
2972  ***      0                                  0            MKDEBUG && _d("Cannot zero chunk");
2973                                                        }
2974                                                     }
2975          14                                 40      MKDEBUG && _d("Using chunk range:", $start_point, "to", $end_point);
2976                                                  
2977          14                                156      my $interval = $args{chunk_size}
2978                                                                  * ($end_point - $start_point)
2979                                                                  / $args{rows_in_range};
2980  ***     14     50                         105      if ( $int_types{$col_type} ) {
2981          14                                310         $interval = ceil($interval);
2982                                                     }
2983  ***     14            66                   91      $interval ||= $args{chunk_size};
2984  ***     14     50                          87      if ( $args{exact} ) {
2985  ***      0                                  0         $interval = $args{chunk_size};
2986                                                     }
2987          14                                 45      MKDEBUG && _d('Chunk interval:', $interval, 'units');
2988                                                  
2989          14                                 48      my @chunks;
2990          14                                120      my $col = $q->quote($args{chunk_col});
2991          14    100                          95      if ( $start_point < $end_point ) {
2992                                                  
2993  ***     12     50                          75         push @chunks, "$col = 0" if $have_zero_chunk;
2994                                                  
2995          12                                 53         my ( $beg, $end );
2996          12                                 43         my $iter = 0;
2997                                                        for ( my $i = $start_point; $i < $end_point; $i += $interval ) {
2998          39                                260            ( $beg, $end ) = $self->$range_func($dbh, $i, $interval, $end_point);
2999                                                  
3000          39    100                         219            if ( $iter++ == 0 ) {
3001  ***     12     50                         125               push @chunks,
3002                                                                 ($have_zero_chunk ? "$col > 0 AND " : "")
3003                                                                 ."$col < " . $q->quote_val($end);
3004                                                           }
3005                                                           else {
3006          27                                160               push @chunks, "$col >= " . $q->quote_val($beg) . " AND $col < " . $q->quote_val($end);
3007                                                           }
3008          12                                 53         }
3009                                                  
3010          12                                107         my $nullable = $args{tbl_struct}->{is_nullable}->{$args{chunk_col}};
3011          12                                 51         pop @chunks;
3012          12    100                          75         if ( @chunks ) {
3013           5                                 32            push @chunks, "$col >= " . $q->quote_val($beg);
3014                                                        }
3015                                                        else {
3016           7    100                          53            push @chunks, $nullable ? "$col IS NOT NULL" : '1=1';
3017                                                        }
3018          12    100                          70         if ( $nullable ) {
3019           1                                  8            push @chunks, "$col IS NULL";
3020                                                        }
3021                                                     }
3022                                                     else {
3023           2                                  7         MKDEBUG && _d('No chunks; using single chunk 1=1');
3024           2                                 12         push @chunks, '1=1';
3025                                                     }
3026                                                  
3027          14                                238      return @chunks;
3028                                                  }
3029                                                  
3030                                                  sub get_first_chunkable_column {
3031  ***      0                    0             0      my ( $self, %args ) = @_;
3032  ***      0                                  0      foreach my $arg ( qw(tbl_struct) ) {
3033  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3034                                                     }
3035                                                  
3036  ***      0                                  0      my ($exact, @cols) = $self->find_chunk_columns(%args);
3037  ***      0                                  0      my $col = $cols[0]->{column};
3038  ***      0                                  0      my $idx = $cols[0]->{index};
3039                                                  
3040  ***      0                                  0      my $wanted_col = $args{chunk_column};
3041  ***      0                                  0      my $wanted_idx = $args{chunk_index};
3042  ***      0                                  0      MKDEBUG && _d("Preferred chunk col/idx:", $wanted_col, $wanted_idx);
3043                                                  
3044  ***      0      0      0                    0      if ( $wanted_col && $wanted_idx ) {
      ***             0                               
      ***             0                               
3045  ***      0                                  0         foreach my $chunkable_col ( @cols ) {
3046  ***      0      0      0                    0            if (    $wanted_col eq $chunkable_col->{column}
3047                                                                && $wanted_idx eq $chunkable_col->{index} ) {
3048  ***      0                                  0               $col = $wanted_col;
3049  ***      0                                  0               $idx = $wanted_idx;
3050  ***      0                                  0               last;
3051                                                           }
3052                                                        }
3053                                                     }
3054                                                     elsif ( $wanted_col ) {
3055  ***      0                                  0         foreach my $chunkable_col ( @cols ) {
3056  ***      0      0                           0            if ( $wanted_col eq $chunkable_col->{column} ) {
3057  ***      0                                  0               $col = $wanted_col;
3058  ***      0                                  0               $idx = $chunkable_col->{index};
3059  ***      0                                  0               last;
3060                                                           }
3061                                                        }
3062                                                     }
3063                                                     elsif ( $wanted_idx ) {
3064  ***      0                                  0         foreach my $chunkable_col ( @cols ) {
3065  ***      0      0                           0            if ( $wanted_idx eq $chunkable_col->{index} ) {
3066  ***      0                                  0               $col = $chunkable_col->{column};
3067  ***      0                                  0               $idx = $wanted_idx;
3068  ***      0                                  0               last;
3069                                                           }
3070                                                        }
3071                                                     }
3072                                                  
3073  ***      0                                  0      MKDEBUG && _d('First chunkable col/index:', $col, $idx);
3074  ***      0                                  0      return $col, $idx;
3075                                                  }
3076                                                  
3077                                                  sub size_to_rows {
3078          20                   20           572      my ( $self, %args ) = @_;
3079          20                                275      my @required_args = qw(dbh db tbl chunk_size);
3080          20                                114      foreach my $arg ( @required_args ) {
3081  ***     80     50                         490         die "I need a $arg argument" unless $args{$arg};
3082                                                     }
3083          20                                158      my ($dbh, $db, $tbl, $chunk_size) = @args{@required_args};
3084          20                                 92      my $q  = $self->{Quoter};
3085          20                                101      my $du = $self->{MySQLDump};
3086                                                  
3087          20                                 76      my ($n_rows, $avg_row_length);
3088                                                  
3089          20                                322      my ( $num, $suffix ) = $chunk_size =~ m/^(\d+)([MGk])?$/;
3090  ***     20     50                         149      if ( $suffix ) { # Convert to bytes.
      ***            50                               
3091  ***      0      0                           0         $chunk_size = $suffix eq 'k' ? $num * 1_024
      ***             0                               
3092                                                                    : $suffix eq 'M' ? $num * 1_024 * 1_024
3093                                                                    :                  $num * 1_024 * 1_024 * 1_024;
3094                                                     }
3095                                                     elsif ( $num ) {
3096          20                                 83         $n_rows = $num;
3097                                                     }
3098                                                     else {
3099  ***      0                                  0         die "Invalid chunk size $chunk_size; must be an integer "
3100                                                           . "with optional suffix kMG";
3101                                                     }
3102                                                  
3103  ***     20     50     33                  304      if ( $suffix || $args{avg_row_length} ) {
3104  ***      0                                  0         my ($status) = $du->get_table_status($dbh, $q, $db, $tbl);
3105  ***      0                                  0         $avg_row_length = $status->{avg_row_length};
3106  ***      0      0                           0         if ( !defined $n_rows ) {
3107  ***      0      0                           0            $n_rows = $avg_row_length ? ceil($chunk_size / $avg_row_length) : undef;
3108                                                        }
3109                                                     }
3110                                                  
3111          20                                281      return $n_rows, $avg_row_length;
3112                                                  }
3113                                                  
3114                                                  sub get_range_statistics {
3115          14                   14           509      my ( $self, %args ) = @_;
3116          14                                209      my @required_args = qw(dbh db tbl chunk_col tbl_struct);
3117          14                                 96      foreach my $arg ( @required_args ) {
3118  ***     70     50                         437         die "I need a $arg argument" unless $args{$arg};
3119                                                     }
3120          14                                118      my ($dbh, $db, $tbl, $col) = @args{@required_args};
3121          14                                 58      my $where = $args{where};
3122          14                                 68      my $q     = $self->{Quoter};
3123                                                  
3124          14                                 91      my $col_type       = $args{tbl_struct}->{type_for}->{$col};
3125          14                                 88      my $col_is_numeric = $args{tbl_struct}->{is_numeric}->{$col};
3126                                                  
3127          14                                 95      my $db_tbl = $q->quote($db, $tbl);
3128          14                                103      $col       = $q->quote($col);
3129                                                  
3130          14                                 61      my ($min, $max);
3131          14                                 48      eval {
3132  ***     14     50                         220         my $sql = "SELECT MIN($col), MAX($col) FROM $db_tbl"
                    100                               
3133                                                                . ($args{index_hint} ? " $args{index_hint}" : "")
3134                                                                . ($where ? " WHERE ($where)" : '');
3135          14                                 59         MKDEBUG && _d($dbh, $sql);
3136          14                                 51         ($min, $max) = $dbh->selectrow_array($sql);
3137          14                               4238         MKDEBUG && _d("Actual end points:", $min, $max);
3138                                                  
3139          14                                373         ($min, $max) = $self->get_valid_end_points(
3140                                                           %args,
3141                                                           dbh      => $dbh,
3142                                                           db_tbl   => $db_tbl,
3143                                                           col      => $col,
3144                                                           col_type => $col_type,
3145                                                           min      => $min,
3146                                                           max      => $max,
3147                                                        );
3148          14                                110         MKDEBUG && _d("Valid end points:", $min, $max);
3149                                                     };
3150  ***     14     50                          86      if ( $EVAL_ERROR ) {
3151  ***      0                                  0         die "Error getting min and max values for table $db_tbl "
3152                                                           . "on column $col: $EVAL_ERROR";
3153                                                     }
3154                                                  
3155  ***     14     50                         179      my $sql = "EXPLAIN SELECT * FROM $db_tbl"
                    100                               
3156                                                             . ($args{index_hint} ? " $args{index_hint}" : "")
3157                                                             . ($where ? " WHERE $where" : '');
3158          14                                 44      MKDEBUG && _d($sql);
3159          14                                 42      my $expl = $dbh->selectrow_hashref($sql);
3160                                                  
3161                                                     return (
3162          14                                434         min           => $min,
3163                                                        max           => $max,
3164                                                        rows_in_range => $expl->{rows},
3165                                                     );
3166                                                  }
3167                                                  
3168                                                  sub inject_chunks {
3169         112                  112          1298      my ( $self, %args ) = @_;
3170         112                                718      foreach my $arg ( qw(database table chunks chunk_num query) ) {
3171  ***    560     50                        3141         die "I need a $arg argument" unless defined $args{$arg};
3172                                                     }
3173         112                                401      MKDEBUG && _d('Injecting chunk', $args{chunk_num});
3174         112                                452      my $query   = $args{query};
3175         112                                858      my $comment = sprintf("/*%s.%s:%d/%d*/",
3176                                                        $args{database}, $args{table},
3177         112                                704         $args{chunk_num} + 1, scalar @{$args{chunks}});
3178         112                                849      $query =~ s!/\*PROGRESS_COMMENT\*/!$comment!;
3179         112                                746      my $where = "WHERE (" . $args{chunks}->[$args{chunk_num}] . ')';
3180  ***    112    100     66                  846      if ( $args{where} && grep { $_ } @{$args{where}} ) {
             112                                944   
             112                                540   
3181          18                                 96         $where .= " AND ("
3182          18                                 58            . join(" AND ", map { "($_)" } grep { $_ } @{$args{where}} )
              18                                 60   
              18                                 66   
3183                                                           . ")";
3184                                                     }
3185         112                                903      my $db_tbl     = $self->{Quoter}->quote(@args{qw(database table)});
3186  ***    112            50                  684      my $index_hint = $args{index_hint} || '';
3187                                                  
3188         112                                295      MKDEBUG && _d('Parameters:',
3189                                                        Dumper({WHERE => $where, DB_TBL => $db_tbl, INDEX_HINT => $index_hint}));
3190         112                               1013      $query =~ s!/\*WHERE\*/! $where!;
3191         112                                637      $query =~ s!/\*DB_TBL\*/!$db_tbl!;
3192         112                                758      $query =~ s!/\*INDEX_HINT\*/! $index_hint!;
3193         112                               1157      $query =~ s!/\*CHUNK_NUM\*/! $args{chunk_num} AS chunk_num,!;
3194                                                  
3195         112                                946      return $query;
3196                                                  }
3197                                                  
3198                                                  
3199                                                  sub value_to_number {
3200          28                   28           254      my ( $self, %args ) = @_;
3201          28                                188      my @required_args = qw(value column_type dbh);
3202          28                                146      foreach my $arg ( @required_args ) {
3203  ***     84     50                         570         die "I need a $arg argument" unless defined $args{$arg};
3204                                                     }
3205          28                                195      my ($val, $col_type, $dbh) = @args{@required_args};
3206          28                                 84      MKDEBUG && _d('Converting MySQL', $col_type, $val);
3207                                                  
3208          28                                281      my %mysql_conv_func_for = (
3209                                                        timestamp => 'UNIX_TIMESTAMP',
3210                                                        date      => 'TO_DAYS',
3211                                                        time      => 'TIME_TO_SEC',
3212                                                        datetime  => 'TO_DAYS',
3213                                                     );
3214                                                  
3215          28                                 84      my $num;
3216  ***     28     50                         281      if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
3217          28                                118         $num = $val;
3218                                                     }
3219                                                     elsif ( $col_type =~ m/^(?:timestamp|date|time)$/ ) {
3220  ***      0                                  0         my $func = $mysql_conv_func_for{$col_type};
3221  ***      0                                  0         my $sql = "SELECT $func(?)";
3222  ***      0                                  0         MKDEBUG && _d($dbh, $sql, $val);
3223  ***      0                                  0         my $sth = $dbh->prepare($sql);
3224  ***      0                                  0         $sth->execute($val);
3225  ***      0                                  0         ($num) = $sth->fetchrow_array();
3226                                                     }
3227                                                     elsif ( $col_type eq 'datetime' ) {
3228  ***      0                                  0         $num = $self->timestampdiff($dbh, $val);
3229                                                     }
3230                                                     else {
3231  ***      0                                  0         die "I don't know how to chunk $col_type\n";
3232                                                     }
3233          28                                 80      MKDEBUG && _d('Converts to', $num);
3234          28                                222      return $num;
3235                                                  }
3236                                                  
3237                                                  sub range_func_for {
3238          14                   14            80      my ( $self, $col_type ) = @_;
3239  ***     14     50                          85      return unless $col_type;
3240          14                                 45      my $range_func;
3241  ***     14     50                         221      if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
3242          14                                 70         $range_func  = 'range_num';
3243                                                     }
3244                                                     elsif ( $col_type =~ m/^(?:timestamp|date|time)$/ ) {
3245  ***      0                                  0         $range_func  = "range_$col_type";
3246                                                     }
3247                                                     elsif ( $col_type eq 'datetime' ) {
3248  ***      0                                  0         $range_func  = 'range_datetime';
3249                                                     }
3250          14                                 74      return $range_func;
3251                                                  }
3252                                                  
3253                                                  sub range_num {
3254          39                   39           258      my ( $self, $dbh, $start, $interval, $max ) = @_;
3255          39                                292      my $end = min($max, $start + $interval);
3256                                                  
3257                                                  
3258  ***     39     50                         219      $start = sprintf('%.17f', $start) if $start =~ /e/;
3259  ***     39     50                         211      $end   = sprintf('%.17f', $end)   if $end   =~ /e/;
3260                                                  
3261          39                                145      $start =~ s/\.(\d{5}).*$/.$1/;
3262          39                                126      $end   =~ s/\.(\d{5}).*$/.$1/;
3263                                                  
3264  ***     39     50                         183      if ( $end > $start ) {
3265          39                                242         return ( $start, $end );
3266                                                     }
3267                                                     else {
3268  ***      0                                  0         die "Chunk size is too small: $end !> $start\n";
3269                                                     }
3270                                                  }
3271                                                  
3272                                                  sub range_time {
3273  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3274  ***      0                                  0      my $sql = "SELECT SEC_TO_TIME($start), SEC_TO_TIME(LEAST($max, $start + $interval))";
3275  ***      0                                  0      MKDEBUG && _d($sql);
3276  ***      0                                  0      return $dbh->selectrow_array($sql);
3277                                                  }
3278                                                  
3279                                                  sub range_date {
3280  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3281  ***      0                                  0      my $sql = "SELECT FROM_DAYS($start), FROM_DAYS(LEAST($max, $start + $interval))";
3282  ***      0                                  0      MKDEBUG && _d($sql);
3283  ***      0                                  0      return $dbh->selectrow_array($sql);
3284                                                  }
3285                                                  
3286                                                  sub range_datetime {
3287  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3288  ***      0                                  0      my $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $start SECOND), "
3289                                                         . "DATE_ADD('$EPOCH', INTERVAL LEAST($max, $start + $interval) SECOND)";
3290  ***      0                                  0      MKDEBUG && _d($sql);
3291  ***      0                                  0      return $dbh->selectrow_array($sql);
3292                                                  }
3293                                                  
3294                                                  sub range_timestamp {
3295  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3296  ***      0                                  0      my $sql = "SELECT FROM_UNIXTIME($start), FROM_UNIXTIME(LEAST($max, $start + $interval))";
3297  ***      0                                  0      MKDEBUG && _d($sql);
3298  ***      0                                  0      return $dbh->selectrow_array($sql);
3299                                                  }
3300                                                  
3301                                                  sub timestampdiff {
3302  ***      0                    0             0      my ( $self, $dbh, $time ) = @_;
3303  ***      0                                  0      my $sql = "SELECT (COALESCE(TO_DAYS('$time'), 0) * 86400 + TIME_TO_SEC('$time')) "
3304                                                        . "- TO_DAYS('$EPOCH 00:00:00') * 86400";
3305  ***      0                                  0      MKDEBUG && _d($sql);
3306  ***      0                                  0      my ( $diff ) = $dbh->selectrow_array($sql);
3307  ***      0                                  0      $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $diff SECOND)";
3308  ***      0                                  0      MKDEBUG && _d($sql);
3309  ***      0                                  0      my ( $check ) = $dbh->selectrow_array($sql);
3310  ***      0      0                           0      die <<"   EOF"
3311                                                     Incorrect datetime math: given $time, calculated $diff but checked to $check.
3312                                                     This could be due to a version of MySQL that overflows on large interval
3313                                                     values to DATE_ADD(), or the given datetime is not a valid date.  If not,
3314                                                     please report this as a bug.
3315                                                     EOF
3316                                                        unless $check eq $time;
3317  ***      0                                  0      return $diff;
3318                                                  }
3319                                                  
3320                                                  
3321                                                  
3322                                                  
3323                                                  sub get_valid_end_points {
3324          14                   14           668      my ( $self, %args ) = @_;
3325          14                                223      my @required_args = qw(dbh db_tbl col col_type);
3326          14                                 93      foreach my $arg ( @required_args ) {
3327  ***     56     50                         369         die "I need a $arg argument" unless $args{$arg};
3328                                                     }
3329          14                                110      my ($dbh, $db_tbl, $col, $col_type) = @args{@required_args};
3330          14                                 91      my ($real_min, $real_max)           = @args{qw(min max)};
3331                                                  
3332          14    100                         195      my $err_fmt = "Error finding a valid %s value for table $db_tbl on "
3333                                                                 . "column $col. The real %s value %s is invalid and "
3334                                                                 . "no other valid values were found.  Verify that the table "
3335                                                                 . "has at least one valid value for this column"
3336                                                                 . ($args{where} ? " where $args{where}." : ".");
3337                                                  
3338          14                                 56      my $valid_min = $real_min;
3339  ***     14     50                          93      if ( defined $valid_min ) {
3340          14                                 46         MKDEBUG && _d("Validating min end point:", $real_min);
3341          14                                249         $valid_min = $self->_get_valid_end_point(
3342                                                           %args,
3343                                                           val      => $real_min,
3344                                                           endpoint => 'min',
3345                                                        );
3346  ***     14     50      0                  136         die sprintf($err_fmt, 'minimum', 'minimum', ($real_min || "NULL"))
3347                                                           unless defined $valid_min;
3348                                                     }
3349                                                     
3350          14                                 55      my $valid_max = $real_max;
3351  ***     14     50                         111      if ( defined $valid_max ) {
3352          14                                 43         MKDEBUG && _d("Validating max end point:", $real_min);
3353          14                                203         $valid_max = $self->_get_valid_end_point(
3354                                                           %args,
3355                                                           val      => $real_max,
3356                                                           endpoint => 'max',
3357                                                        );
3358  ***     14     50      0                  139         die sprintf($err_fmt, 'maximum', 'maximum', ($real_max || "NULL"))
3359                                                           unless defined $valid_max;
3360                                                     }
3361                                                  
3362          14                                192      return $valid_min, $valid_max;
3363                                                  }
3364                                                  
3365                                                  sub _get_valid_end_point {
3366          28                   28          1121      my ( $self, %args ) = @_;
3367          28                                403      my @required_args = qw(dbh db_tbl col col_type);
3368          28                                146      foreach my $arg ( @required_args ) {
3369  ***    112     50                         699         die "I need a $arg argument" unless $args{$arg};
3370                                                     }
3371          28                                194      my ($dbh, $db_tbl, $col, $col_type) = @args{@required_args};
3372          28                                110      my $val = $args{val};
3373                                                  
3374  ***     28     50                         152      return $val unless defined $val;
3375                                                  
3376  ***     28     50                         167      my $validate = $col_type =~ m/time|date/ ? \&_validate_temporal_value
3377                                                                  :                             undef;
3378                                                  
3379  ***     28     50                         164      if ( !$validate ) {
3380          28                                 86         MKDEBUG && _d("No validator for", $col_type, "values");
3381          28                                379         return $val;
3382                                                     }
3383                                                  
3384  ***      0      0                           0      return $val if defined $validate->($dbh, $val);
3385                                                  
3386  ***      0                                  0      MKDEBUG && _d("Value is invalid, getting first valid value");
3387  ***      0                                  0      $val = $self->get_first_valid_value(
3388                                                        %args,
3389                                                        val      => $val,
3390                                                        validate => $validate,
3391                                                     );
3392                                                  
3393  ***      0                                  0      return $val;
3394                                                  }
3395                                                  
3396                                                  sub get_first_valid_value {
3397  ***      0                    0             0      my ( $self, %args ) = @_;
3398  ***      0                                  0      my @required_args = qw(dbh db_tbl col validate endpoint);
3399  ***      0                                  0      foreach my $arg ( @required_args ) {
3400  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3401                                                     }
3402  ***      0                                  0      my ($dbh, $db_tbl, $col, $validate, $endpoint) = @args{@required_args};
3403  ***      0      0                           0      my $tries = defined $args{tries} ? $args{tries} : 5;
3404  ***      0                                  0      my $val   = $args{val};
3405                                                  
3406  ***      0      0                           0      return unless defined $val;
3407                                                  
3408  ***      0      0                           0      my $cmp = $endpoint =~ m/min/i ? '>'
      ***             0                               
3409                                                             : $endpoint =~ m/max/i ? '<'
3410                                                             :                        die "Invalid endpoint arg: $endpoint";
3411  ***      0      0                           0      my $sql = "SELECT $col FROM $db_tbl "
      ***             0                               
3412                                                             . ($args{index_hint} ? "$args{index_hint} " : "")
3413                                                             . "WHERE $col $cmp ? AND $col IS NOT NULL "
3414                                                             . ($args{where} ? "AND ($args{where}) " : "")
3415                                                             . "ORDER BY $col LIMIT 1";
3416  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3417  ***      0                                  0      my $sth = $dbh->prepare($sql);
3418                                                  
3419  ***      0                                  0      my $last_val = $val;
3420  ***      0                                  0      while ( $tries-- ) {
3421  ***      0                                  0         $sth->execute($last_val);
3422  ***      0                                  0         my ($next_val) = $sth->fetchrow_array();
3423  ***      0                                  0         MKDEBUG && _d('Next value:', $next_val, '; tries left:', $tries);
3424  ***      0      0                           0         if ( !defined $next_val ) {
3425  ***      0                                  0            MKDEBUG && _d('No more rows in table');
3426  ***      0                                  0            last;
3427                                                        }
3428  ***      0      0                           0         if ( defined $validate->($dbh, $next_val) ) {
3429  ***      0                                  0            MKDEBUG && _d('First valid value:', $next_val);
3430  ***      0                                  0            $sth->finish();
3431  ***      0                                  0            return $next_val;
3432                                                        }
3433  ***      0                                  0         $last_val = $next_val;
3434                                                     }
3435  ***      0                                  0      $sth->finish();
3436  ***      0                                  0      $val = undef;  # no valid value found
3437                                                  
3438  ***      0                                  0      return $val;
3439                                                  }
3440                                                  
3441                                                  sub _validate_temporal_value {
3442  ***      0                    0             0      my ( $dbh, $val ) = @_;
3443  ***      0                                  0      my $sql = "SELECT IF(TIME_FORMAT(?,'%H:%i:%s')=?, TIME_TO_SEC(?), TO_DAYS(?))";
3444  ***      0                                  0      my $res;
3445  ***      0                                  0      eval {
3446  ***      0                                  0         MKDEBUG && _d($dbh, $sql, $val);
3447  ***      0                                  0         my $sth = $dbh->prepare($sql);
3448  ***      0                                  0         $sth->execute($val, $val, $val, $val);
3449  ***      0                                  0         ($res) = $sth->fetchrow_array();
3450  ***      0                                  0         $sth->finish();
3451                                                     };
3452  ***      0      0                           0      if ( $EVAL_ERROR ) {
3453  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
3454                                                     }
3455  ***      0                                  0      return $res;
3456                                                  }
3457                                                  
3458                                                  sub get_nonzero_value {
3459  ***      0                    0             0      my ( $self, %args ) = @_;
3460  ***      0                                  0      my @required_args = qw(dbh db_tbl col col_type);
3461  ***      0                                  0      foreach my $arg ( @required_args ) {
3462  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3463                                                     }
3464  ***      0                                  0      my ($dbh, $db_tbl, $col, $col_type) = @args{@required_args};
3465  ***      0      0                           0      my $tries = defined $args{tries} ? $args{tries} : 5;
3466  ***      0                                  0      my $val   = $args{val};
3467                                                  
3468                                                     my $is_nonzero = $col_type =~ m/time|date/ ? \&_validate_temporal_value
3469  ***      0      0             0             0                     :                             sub { return $_[1]; };
      ***      0                                  0   
3470                                                  
3471  ***      0      0                           0      if ( !$is_nonzero->($dbh, $val) ) {  # quasi-double-negative, sorry
3472  ***      0                                  0         MKDEBUG && _d('Discarding zero value:', $val);
3473  ***      0      0                           0         my $sql = "SELECT $col FROM $db_tbl "
      ***             0                               
3474                                                                . ($args{index_hint} ? "$args{index_hint} " : "")
3475                                                                . "WHERE $col > ? AND $col IS NOT NULL "
3476                                                                . ($args{where} ? "AND ($args{where}) " : '')
3477                                                                . "ORDER BY $col LIMIT 1";
3478  ***      0                                  0         MKDEBUG && _d($sql);
3479  ***      0                                  0         my $sth = $dbh->prepare($sql);
3480                                                  
3481  ***      0                                  0         my $last_val = $val;
3482  ***      0                                  0         while ( $tries-- ) {
3483  ***      0                                  0            $sth->execute($last_val);
3484  ***      0                                  0            my ($next_val) = $sth->fetchrow_array();
3485  ***      0      0                           0            if ( $is_nonzero->($dbh, $next_val) ) {
3486  ***      0                                  0               MKDEBUG && _d('First non-zero value:', $next_val);
3487  ***      0                                  0               $sth->finish();
3488  ***      0                                  0               return $next_val;
3489                                                           }
3490  ***      0                                  0            $last_val = $next_val;
3491                                                        }
3492  ***      0                                  0         $sth->finish();
3493  ***      0                                  0         $val = undef;  # no non-zero value found
3494                                                     }
3495                                                  
3496  ***      0                                  0      return $val;
3497                                                  }
3498                                                  
3499                                                  sub _d {
3500  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3501  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3502  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3503                                                          @_;
3504  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3505                                                  }
3506                                                  
3507                                                  1;
3508                                                  
3509                                                  # ###########################################################################
3510                                                  # End TableChunker package
3511                                                  # ###########################################################################
3512                                                  
3513                                                  # ###########################################################################
3514                                                  # TableChecksum package 6511
3515                                                  # This package is a copy without comments from the original.  The original
3516                                                  # with comments and its test file can be found in the SVN repository at,
3517                                                  #   trunk/common/TableChecksum.pm
3518                                                  #   trunk/common/t/TableChecksum.t
3519                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3520                                                  # ###########################################################################
3521                                                  package TableChecksum;
3522                                                  
3523          36                   36           332   use strict;
              36                                103   
              36                                241   
3524          36                   36           214   use warnings FATAL => 'all';
              36                                106   
              36                                229   
3525          36                   36           215   use English qw(-no_match_vars);
              36                                 86   
              36                                225   
3526          36                   36           257   use List::Util qw(max);
              36                                 93   
              36                                201   
3527                                                  
3528  ***     36            50     36           231   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                100   
              36                                550   
3529                                                  
3530                                                  our %ALGOS = (
3531                                                     CHECKSUM => { pref => 0, hash => 0 },
3532                                                     BIT_XOR  => { pref => 2, hash => 1 },
3533                                                     ACCUM    => { pref => 3, hash => 1 },
3534                                                  );
3535                                                  
3536                                                  sub new {
3537          26                   26           214      my ( $class, %args ) = @_;
3538          26                                193      foreach my $arg ( qw(Quoter VersionParser) ) {
3539  ***     52     50                         373         die "I need a $arg argument" unless defined $args{$arg};
3540                                                     }
3541          26                                183      my $self = { %args };
3542          26                                392      return bless $self, $class;
3543                                                  }
3544                                                  
3545                                                  sub crc32 {
3546  ***      0                    0             0      my ( $self, $string ) = @_;
3547  ***      0                                  0      my $poly = 0xEDB88320;
3548  ***      0                                  0      my $crc  = 0xFFFFFFFF;
3549  ***      0                                  0      foreach my $char ( split(//, $string) ) {
3550  ***      0                                  0         my $comp = ($crc ^ ord($char)) & 0xFF;
3551  ***      0                                  0         for ( 1 .. 8 ) {
3552  ***      0      0                           0            $comp = $comp & 1 ? $poly ^ ($comp >> 1) : $comp >> 1;
3553                                                        }
3554  ***      0                                  0         $crc = (($crc >> 8) & 0x00FFFFFF) ^ $comp;
3555                                                     }
3556  ***      0                                  0      return $crc ^ 0xFFFFFFFF;
3557                                                  }
3558                                                  
3559                                                  sub get_crc_wid {
3560          20                   20           129      my ( $self, $dbh, $func ) = @_;
3561          20                                 82      my $crc_wid = 16;
3562  ***     20     50     33                  325      if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
3563          20                                 79         eval {
3564          20                                 66            my ($val) = $dbh->selectrow_array("SELECT $func('a')");
3565          20                               3207            $crc_wid = max(16, length($val));
3566                                                        };
3567                                                     }
3568          20                                110      return $crc_wid;
3569                                                  }
3570                                                  
3571                                                  sub get_crc_type {
3572          20                   20           125      my ( $self, $dbh, $func ) = @_;
3573          20                                 89      my $type   = '';
3574          20                                 71      my $length = 0;
3575          20                                130      my $sql    = "SELECT $func('a')";
3576          20                                 53      my $sth    = $dbh->prepare($sql);
3577          20                                137      eval {
3578          20                               2377         $sth->execute();
3579          20                                254         $type   = $sth->{mysql_type_name}->[0];
3580          20                                170         $length = $sth->{mysql_length}->[0];
3581          20                                182         MKDEBUG && _d($sql, $type, $length);
3582  ***     20    100     66                  323         if ( $type eq 'bigint' && $length < 20 ) {
3583          19                                 90            $type = 'int';
3584                                                        }
3585                                                     };
3586          20                                246      $sth->finish;
3587          20                                 61      MKDEBUG && _d('crc_type:', $type, 'length:', $length);
3588          20                                433      return ($type, $length);
3589                                                  }
3590                                                  
3591                                                  sub best_algorithm {
3592          40                   40           412      my ( $self, %args ) = @_;
3593          40                                276      my ( $alg, $dbh ) = @args{ qw(algorithm dbh) };
3594          40                                176      my $vp = $self->{VersionParser};
3595          40                                 86      my @choices = sort { $ALGOS{$a}->{pref} <=> $ALGOS{$b}->{pref} } keys %ALGOS;
             120                                703   
3596  ***     40     50     33                  680      die "Invalid checksum algorithm $alg"
3597                                                        if $alg && !$ALGOS{$alg};
3598                                                  
3599  ***     40     50     33                  459      if (
      ***                   33                        
      ***                   33                        
3600                                                        $args{where} || $args{chunk}        # CHECKSUM does whole table
3601                                                        || $args{replicate}                 # CHECKSUM can't do INSERT.. SELECT
3602                                                        || !$vp->version_ge($dbh, '4.1.1')) # CHECKSUM doesn't exist
3603                                                     {
3604          40                                121         MKDEBUG && _d('Cannot use CHECKSUM algorithm');
3605          40                                166         @choices = grep { $_ ne 'CHECKSUM' } @choices;
             120                                620   
3606                                                     }
3607                                                  
3608  ***     40     50                         249      if ( !$vp->version_ge($dbh, '4.1.1') ) {
3609  ***      0                                  0         MKDEBUG && _d('Cannot use BIT_XOR algorithm because MySQL < 4.1.1');
3610  ***      0                                  0         @choices = grep { $_ ne 'BIT_XOR' } @choices;
      ***      0                                  0   
3611                                                     }
3612                                                  
3613  ***     40     50     33                  374      if ( $alg && grep { $_ eq $alg } @choices ) {
              80                                537   
3614          40                                121         MKDEBUG && _d('User requested', $alg, 'algorithm');
3615          40                                282         return $alg;
3616                                                     }
3617                                                  
3618  ***      0      0      0                    0      if ( $args{count} && grep { $_ ne 'CHECKSUM' } @choices ) {
      ***      0                                  0   
3619  ***      0                                  0         MKDEBUG && _d('Not using CHECKSUM algorithm because COUNT desired');
3620  ***      0                                  0         @choices = grep { $_ ne 'CHECKSUM' } @choices;
      ***      0                                  0   
3621                                                     }
3622                                                  
3623  ***      0                                  0      MKDEBUG && _d('Algorithms, in order:', @choices);
3624  ***      0                                  0      return $choices[0];
3625                                                  }
3626                                                  
3627                                                  sub is_hash_algorithm {
3628  ***      0                    0             0      my ( $self, $algorithm ) = @_;
3629  ***      0             0                    0      return $ALGOS{$algorithm} && $ALGOS{$algorithm}->{hash};
3630                                                  }
3631                                                  
3632                                                  sub choose_hash_func {
3633          40                   40          1064      my ( $self, %args ) = @_;
3634          40                                503      my @funcs = qw(CRC32 FNV1A_64 FNV_64 MD5 SHA1);
3635          40    100                         229      if ( $args{function} ) {
3636           2                                 14         unshift @funcs, $args{function};
3637                                                     }
3638          40                                149      my ($result, $error);
3639  ***     40            33                  157      do {
3640          40                                121         my $func;
3641          40                                139         eval {
3642          40                                183            $func = shift(@funcs);
3643          40                                210            my $sql = "SELECT $func('test-string')";
3644          40                                109            MKDEBUG && _d($sql);
3645          40                               7957            $args{dbh}->do($sql);
3646          40                                246            $result = $func;
3647                                                        };
3648  ***     40     50     33                  746         if ( $EVAL_ERROR && $EVAL_ERROR =~ m/failed: (.*?) at \S+ line/ ) {
3649  ***      0                                  0            $error .= qq{$func cannot be used because "$1"\n};
3650  ***      0                                  0            MKDEBUG && _d($func, 'cannot be used because', $1);
3651                                                        }
3652                                                     } while ( @funcs && !$result );
3653                                                  
3654  ***     40     50                         197      die $error unless $result;
3655          40                                111      MKDEBUG && _d('Chosen hash func:', $result);
3656          40                                508      return $result;
3657                                                  }
3658                                                  
3659                                                  sub optimize_xor {
3660           1                    1            11      my ( $self, %args ) = @_;
3661           1                                  9      my ($dbh, $func) = @args{qw(dbh function)};
3662                                                  
3663  ***      1     50                          11      die "$func never needs the BIT_XOR optimization"
3664                                                        if $func =~ m/^(?:FNV1A_64|FNV_64|CRC32)$/i;
3665                                                  
3666           1                                  5      my $opt_slice = 0;
3667           1                                  4      my $unsliced  = uc $dbh->selectall_arrayref("SELECT $func('a')")->[0]->[0];
3668           1                                222      my $sliced    = '';
3669           1                                  6      my $start     = 1;
3670  ***      1     50                          10      my $crc_wid   = length($unsliced) < 16 ? 16 : length($unsliced);
3671                                                  
3672  ***      1            66                    4      do { # Try different positions till sliced result equals non-sliced.
3673           2                                  7         MKDEBUG && _d('Trying slice', $opt_slice);
3674           2                                320         $dbh->do('SET @crc := "", @cnt := 0');
3675           2                                 31         my $slices = $self->make_xor_slices(
3676                                                           query     => "\@crc := $func('a')",
3677                                                           crc_wid   => $crc_wid,
3678                                                           opt_slice => $opt_slice,
3679                                                        );
3680                                                  
3681           2                                 17         my $sql = "SELECT CONCAT($slices) AS TEST FROM (SELECT NULL) AS x";
3682           2                                  7         $sliced = ($dbh->selectrow_array($sql))[0];
3683           2    100                         898         if ( $sliced ne $unsliced ) {
3684           1                                  5            MKDEBUG && _d('Slice', $opt_slice, 'does not work');
3685           1                                  5            $start += 16;
3686           1                                 29            ++$opt_slice;
3687                                                        }
3688                                                     } while ( $start < $crc_wid && $sliced ne $unsliced );
3689                                                  
3690  ***      1     50                          11      if ( $sliced eq $unsliced ) {
3691           1                                  4         MKDEBUG && _d('Slice', $opt_slice, 'works');
3692           1                                 10         return $opt_slice;
3693                                                     }
3694                                                     else {
3695  ***      0                                  0         MKDEBUG && _d('No slice works');
3696  ***      0                                  0         return undef;
3697                                                     }
3698                                                  }
3699                                                  
3700                                                  sub make_xor_slices {
3701           3                    3            71      my ( $self, %args ) = @_;
3702           3                                 33      foreach my $arg ( qw(query crc_wid) ) {
3703  ***      6     50                          55         die "I need a $arg argument" unless defined $args{$arg};
3704                                                     }
3705           3                                 28      my ( $query, $crc_wid, $opt_slice ) = @args{qw(query crc_wid opt_slice)};
3706                                                  
3707           3                                 12      my @slices;
3708                                                     for ( my $start = 1; $start <= $crc_wid; $start += 16 ) {
3709           6                                 34         my $len = $crc_wid - $start + 1;
3710           6    100                          41         if ( $len > 16 ) {
3711           3                                 13            $len = 16;
3712                                                        }
3713           6                                100         push @slices,
3714                                                           "LPAD(CONV(BIT_XOR("
3715                                                           . "CAST(CONV(SUBSTRING(\@crc, $start, $len), 16, 10) AS UNSIGNED))"
3716                                                           . ", 10, 16), $len, '0')";
3717           3                                 12      }
3718                                                  
3719  ***      3     50     33                   53      if ( defined $opt_slice && $opt_slice < @slices ) {
3720           3                                 55         $slices[$opt_slice] =~ s/\@crc/\@crc := $query/;
3721                                                     }
3722                                                     else {
3723  ***      0                                  0         map { s/\@crc/$query/ } @slices;
      ***      0                                  0   
3724                                                     }
3725                                                  
3726           3                                 47      return join(', ', @slices);
3727                                                  }
3728                                                  
3729                                                  sub make_row_checksum {
3730          40                   40          1113      my ( $self, %args ) = @_;
3731          40                                498      my ( $tbl_struct, $func ) = @args{ qw(tbl_struct function) };
3732          40                                180      my $q = $self->{Quoter};
3733                                                  
3734  ***     40            50                  455      my $sep = $args{sep} || '#';
3735          40                                163      $sep =~ s/'//g;
3736  ***     40            50                  190      $sep ||= '#';
3737                                                  
3738          40                                142      my %ignorecols = map { $_ => 1 } @{$args{ignorecols}};
      ***      0                                  0   
              40                                272   
3739                                                  
3740         148                                847      my %cols = map { lc($_) => 1 }
             148                                656   
3741          40                                196                 grep { !exists $ignorecols{$_} }
3742  ***     40     50                         253                 ($args{cols} ? @{$args{cols}} : @{$tbl_struct->{cols}});
      ***      0                                  0   
3743          40                                195      my %seen;
3744         120                                612      my @cols =
3745                                                        map {
3746  ***    120     50                        1289            my $type = $tbl_struct->{type_for}->{$_};
3747         120                                568            my $result = $q->quote($_);
3748  ***    120    100     33                 1356            if ( $type eq 'timestamp' ) {
      ***            50    100                        
                    100                               
3749          14                                 58               $result .= ' + 0';
3750                                                           }
3751                                                           elsif ( $args{float_precision} && $type =~ m/float|double/ ) {
3752  ***      0                                  0               $result = "ROUND($result, $args{float_precision})";
3753                                                           }
3754                                                           elsif ( $args{trim} && $type =~ m/varchar/ ) {
3755           2                                  7               $result = "TRIM($result)";
3756                                                           }
3757         120                                564            $result;
3758                                                        }
3759                                                        grep {
3760          40                                244            $cols{$_} && !$seen{$_}++
3761                                                        }
3762          40                                145         @{$tbl_struct->{cols}};
3763                                                  
3764          40                                164      my $query;
3765          40    100                         235      if ( !$args{no_cols} ) {
3766          60                                199         $query = join(', ',
3767                                                                    map { 
3768          20                                 99                        my $col = $_;
3769          60    100                         428                        if ( $col =~ m/\+ 0/ ) {
                    100                               
3770           7                                 69                           my ($real_col) = /^(\S+)/;
3771           7                                 34                           $col .= " AS $real_col";
3772                                                                       }
3773                                                                       elsif ( $col =~ m/TRIM/ ) {
3774           1                                 12                           my ($real_col) = m/TRIM\(([^\)]+)\)/;
3775           1                                  5                           $col .= " AS $real_col";
3776                                                                       }
3777          60                                262                        $col;
3778                                                                    } @cols)
3779                                                               . ', ';
3780                                                     }
3781                                                  
3782  ***     40     50     33                  567      if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
3783          40                                139         my @nulls = grep { $cols{$_} } @{$tbl_struct->{null_cols}};
              32                                179   
              40                                228   
3784          40    100                         231         if ( @nulls ) {
3785          32                                162            my $bitmap = "CONCAT("
3786          28                                134               . join(', ', map { 'ISNULL(' . $q->quote($_) . ')' } @nulls)
3787                                                              . ")";
3788          28                                136            push @cols, $bitmap;
3789                                                        }
3790                                                  
3791  ***     40     50                         458         $query .= @cols > 1
3792                                                                ? "$func(CONCAT_WS('$sep', " . join(', ', @cols) . '))'
3793                                                                : "$func($cols[0])";
3794                                                     }
3795                                                     else {
3796  ***      0                                  0         my $fnv_func = uc $func;
3797  ***      0                                  0         $query .= "$fnv_func(" . join(', ', @cols) . ')';
3798                                                     }
3799                                                  
3800          40                                541      return $query;
3801                                                  }
3802                                                  
3803                                                  sub make_checksum_query {
3804          20                   20           778      my ( $self, %args ) = @_;
3805          20                                318      my @required_args = qw(db tbl tbl_struct algorithm crc_wid crc_type);
3806          20                                262      foreach my $arg( @required_args ) {
3807  ***    120     50                         704         die "I need a $arg argument" unless $args{$arg};
3808                                                     }
3809          20                                177      my ( $db, $tbl, $tbl_struct, $algorithm,
3810                                                          $crc_wid, $crc_type) = @args{@required_args};
3811          20                                 87      my $func = $args{function};
3812          20                                 89      my $q = $self->{Quoter};
3813          20                                 65      my $result;
3814                                                  
3815  ***     20     50     33                  297      die "Invalid or missing checksum algorithm"
3816                                                        unless $algorithm && $ALGOS{$algorithm};
3817                                                  
3818  ***     20     50                         115      if ( $algorithm eq 'CHECKSUM' ) {
3819  ***      0                                  0         return "CHECKSUM TABLE " . $q->quote($db, $tbl);
3820                                                     }
3821                                                  
3822          20                                353      my $expr = $self->make_row_checksum(%args, no_cols=>1);
3823                                                  
3824  ***     20     50                         177      if ( $algorithm eq 'BIT_XOR' ) {
3825          20    100                         151         if ( $crc_type =~ m/int$/ ) {
3826          19                                137            $result = "COALESCE(LOWER(CONV(BIT_XOR(CAST($expr AS UNSIGNED)), 10, 16)), 0) AS crc ";
3827                                                        }
3828                                                        else {
3829           1                                 20            my $slices = $self->make_xor_slices( query => $expr, %args );
3830           1                                 14            $result = "COALESCE(LOWER(CONCAT($slices)), 0) AS crc ";
3831                                                        }
3832                                                     }
3833                                                     else {
3834  ***      0      0                           0         if ( $crc_type =~ m/int$/ ) {
3835  ***      0                                  0            $result = "COALESCE(RIGHT(MAX("
3836                                                              . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
3837                                                              . "CONV(CAST($func(CONCAT(\@crc, $expr)) AS UNSIGNED), 10, 16))"
3838                                                              . "), $crc_wid), 0) AS crc ";
3839                                                        }
3840                                                        else {
3841  ***      0                                  0            $result = "COALESCE(RIGHT(MAX("
3842                                                              . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
3843                                                              . "$func(CONCAT(\@crc, $expr)))"
3844                                                              . "), $crc_wid), 0) AS crc ";
3845                                                        }
3846                                                     }
3847  ***     20     50                         121      if ( $args{replicate} ) {
3848  ***      0                                  0         $result = "REPLACE /*PROGRESS_COMMENT*/ INTO $args{replicate} "
3849                                                           . "(db, tbl, chunk, boundaries, this_cnt, this_crc) "
3850                                                           . "SELECT ?, ?, /*CHUNK_NUM*/ ?, COUNT(*) AS cnt, $result";
3851                                                     }
3852                                                     else {
3853  ***     20     50                         200         $result = "SELECT "
3854                                                           . ($args{buffer} ? 'SQL_BUFFER_RESULT ' : '')
3855                                                           . "/*PROGRESS_COMMENT*//*CHUNK_NUM*/ COUNT(*) AS cnt, $result";
3856                                                     }
3857          20                                271      return $result . "FROM /*DB_TBL*//*INDEX_HINT*//*WHERE*/";
3858                                                  }
3859                                                  
3860                                                  sub find_replication_differences {
3861           6                    6            29      my ( $self, $dbh, $table ) = @_;
3862                                                  
3863           6                                145      (my $sql = <<"   EOF") =~ s/\s+/ /gm;
3864                                                        SELECT db, tbl, chunk, boundaries,
3865                                                           COALESCE(this_cnt-master_cnt, 0) AS cnt_diff,
3866                                                           COALESCE(
3867                                                              this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc),
3868                                                              0
3869                                                           ) AS crc_diff,
3870                                                           this_cnt, master_cnt, this_crc, master_crc
3871                                                        FROM $table
3872                                                        WHERE master_cnt <> this_cnt OR master_crc <> this_crc
3873                                                        OR ISNULL(master_crc) <> ISNULL(this_crc)
3874                                                     EOF
3875                                                  
3876           6                                 15      MKDEBUG && _d($sql);
3877           6                                 32      my $diffs = $dbh->selectall_arrayref($sql, { Slice => {} });
3878           6                                 74      return @$diffs;
3879                                                  }
3880                                                  
3881                                                  sub _d {
3882  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3883  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3884  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3885                                                          @_;
3886  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3887                                                  }
3888                                                  
3889                                                  1;
3890                                                  
3891                                                  # ###########################################################################
3892                                                  # End TableChecksum package
3893                                                  # ###########################################################################
3894                                                  
3895                                                  # ###########################################################################
3896                                                  # TableSyncChunk package 6389
3897                                                  # This package is a copy without comments from the original.  The original
3898                                                  # with comments and its test file can be found in the SVN repository at,
3899                                                  #   trunk/common/TableSyncChunk.pm
3900                                                  #   trunk/common/t/TableSyncChunk.t
3901                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3902                                                  # ###########################################################################
3903                                                  package TableSyncChunk;
3904                                                  
3905          36                   36           312   use strict;
              36                                102   
              36                                277   
3906          36                   36           313   use warnings FATAL => 'all';
              36                                103   
              36                                227   
3907                                                  
3908          36                   36           207   use English qw(-no_match_vars);
              36                                111   
              36                                209   
3909          36                   36           243   use List::Util qw(max);
              36                                 87   
              36                                186   
3910          36                   36           223   use Data::Dumper;
              36                                 91   
              36                                231   
3911                                                  $Data::Dumper::Indent    = 1;
3912                                                  $Data::Dumper::Sortkeys  = 1;
3913                                                  $Data::Dumper::Quotekeys = 0;
3914                                                  
3915  ***     36            50     36           225   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                100   
              36                                507   
3916                                                  
3917                                                  sub new {
3918          19                   19           237      my ( $class, %args ) = @_;
3919          19                                161      foreach my $arg ( qw(TableChunker Quoter) ) {
3920  ***     38     50                         281         die "I need a $arg argument" unless defined $args{$arg};
3921                                                     }
3922          19                                215      my $self = { %args };
3923          19                                359      return bless $self, $class;
3924                                                  }
3925                                                  
3926                                                  sub name {
3927          13                   13           299      return 'Chunk';
3928                                                  }
3929                                                  
3930                                                  sub set_callback {
3931          15                   15            73      my ( $self, $callback, $code ) = @_;
3932          15                                 82      $self->{$callback} = $code;
3933          15                                 51      return;
3934                                                  }
3935                                                  
3936                                                  sub can_sync {
3937          20                   20           595      my ( $self, %args ) = @_;
3938          20                                243      foreach my $arg ( qw(tbl_struct) ) {
3939  ***     20     50                         167         die "I need a $arg argument" unless defined $args{$arg};
3940                                                     }
3941                                                  
3942          20                                380      my ($exact, @chunkable_cols) = $self->{TableChunker}->find_chunk_columns(
3943                                                        %args,
3944                                                        exact => 1,
3945                                                     );
3946          20    100                         214      return unless $exact;
3947                                                  
3948          14                                 56      my $colno;
3949  ***     14     50     33                  245      if ( $args{chunk_col} || $args{chunk_index} ) {
3950  ***      0                                  0         MKDEBUG && _d('Checking requested col', $args{chunk_col},
3951                                                           'and/or index', $args{chunk_index});
3952  ***      0                                  0         for my $i ( 0..$#chunkable_cols ) {
3953  ***      0      0                           0            if ( $args{chunk_col} ) {
3954  ***      0      0                           0               next unless $chunkable_cols[$i]->{column} eq $args{chunk_col};
3955                                                           }
3956  ***      0      0                           0            if ( $args{chunk_index} ) {
3957  ***      0      0                           0               next unless $chunkable_cols[$i]->{index} eq $args{chunk_index};
3958                                                           }
3959  ***      0                                  0            $colno = $i;
3960  ***      0                                  0            last;
3961                                                        }
3962                                                  
3963  ***      0      0                           0         if ( !$colno ) {
3964  ***      0                                  0            MKDEBUG && _d('Cannot chunk on column', $args{chunk_col},
3965                                                              'and/or using index', $args{chunk_index});
3966  ***      0                                  0            return;
3967                                                        }
3968                                                     }
3969                                                     else {
3970          14                                 63         $colno = 0;  # First, best chunkable column/index.
3971                                                     }
3972                                                  
3973          14                                 43      MKDEBUG && _d('Can chunk on column', $chunkable_cols[$colno]->{column},
3974                                                        'using index', $chunkable_cols[$colno]->{index});
3975                                                     return (
3976          14                                292         1,
3977                                                        chunk_col   => $chunkable_cols[$colno]->{column},
3978                                                        chunk_index => $chunkable_cols[$colno]->{index},
3979                                                     ),
3980                                                  }
3981                                                  
3982                                                  sub prepare_to_sync {
3983          14                   14           507      my ( $self, %args ) = @_;
3984          14                                236      my @required_args = qw(dbh db tbl tbl_struct cols chunk_col
3985                                                                            chunk_size crc_col ChangeHandler);
3986          14                                 92      foreach my $arg ( @required_args ) {
3987  ***    126     50                         772         die "I need a $arg argument" unless defined $args{$arg};
3988                                                     }
3989          14                                 71      my $chunker  = $self->{TableChunker};
3990                                                  
3991          14                                 83      $self->{chunk_col}       = $args{chunk_col};
3992          14                                 87      $self->{crc_col}         = $args{crc_col};
3993          14                                 83      $self->{index_hint}      = $args{index_hint};
3994          14                                101      $self->{buffer_in_mysql} = $args{buffer_in_mysql};
3995          14                                 93      $self->{ChangeHandler}   = $args{ChangeHandler};
3996                                                  
3997          14                                276      $self->{ChangeHandler}->fetch_back($args{dbh});
3998                                                  
3999          14                                 56      push @{$args{cols}}, $args{chunk_col};
              14                                 89   
4000                                                  
4001          14                                 49      my @chunks;
4002          14                                308      my %range_params = $chunker->get_range_statistics(%args);
4003  ***     14     50                         150      if ( !grep { !defined $range_params{$_} } qw(min max rows_in_range) ) {
              42                                261   
4004          14                                255         ($args{chunk_size}) = $chunker->size_to_rows(%args);
4005          14                                299         @chunks = $chunker->calculate_chunks(%args, %range_params);
4006                                                     }
4007                                                     else {
4008  ***      0                                  0         MKDEBUG && _d('No range statistics; using single chunk 1=1');
4009  ***      0                                  0         @chunks = '1=1';
4010                                                     }
4011                                                  
4012          14                                157      $self->{chunks}    = \@chunks;
4013          14                                 86      $self->{chunk_num} = 0;
4014          14                                 76      $self->{state}     = 0;
4015                                                  
4016          14                                182      return;
4017                                                  }
4018                                                  
4019                                                  sub uses_checksum {
4020          14                   14            90      return 1;
4021                                                  }
4022                                                  
4023                                                  sub set_checksum_queries {
4024          14                   14           109      my ( $self, $chunk_sql, $row_sql ) = @_;
4025  ***     14     50                         100      die "I need a chunk_sql argument" unless $chunk_sql;
4026  ***     14     50                          77      die "I need a row_sql argument" unless $row_sql;
4027          14                                 81      $self->{chunk_sql} = $chunk_sql;
4028          14                                 73      $self->{row_sql}   = $row_sql;
4029          14                                 64      return;
4030                                                  }
4031                                                  
4032                                                  sub prepare_sync_cycle {
4033         140                  140           757      my ( $self, $host ) = @_;
4034         140                                606      my $sql = 'SET @crc := "", @cnt := 0';
4035         140                                375      MKDEBUG && _d($sql);
4036         140                              19237      $host->{dbh}->do($sql);
4037         140                                711      return;
4038                                                  }
4039                                                  
4040                                                  sub get_sql {
4041         140                  140          1186      my ( $self, %args ) = @_;
4042         140    100                         834      if ( $self->{state} ) {  # select rows in a chunk
4043          56                                250         my $q = $self->{Quoter};
4044          56                                266         return 'SELECT /*rows in chunk*/ '
4045                                                           . ($self->{buffer_in_mysql} ? 'SQL_BUFFER_RESULT ' : '')
4046                                                           . $self->{row_sql} . " AS $self->{crc_col}"
4047                                                           . ' FROM ' . $self->{Quoter}->quote(@args{qw(database table)})
4048                                                           . ' '. ($self->{index_hint} || '')
4049                                                           . ' WHERE (' . $self->{chunks}->[$self->{chunk_num}] . ')'
4050                                                           . ($args{where} ? " AND ($args{where})" : '')
4051  ***     56     50     50                  995            . ' ORDER BY ' . join(', ', map {$q->quote($_) } @{$self->key_cols()});
              56    100                         267   
4052                                                     }
4053                                                     else {  # select a chunk of rows
4054          84                               1271         return $self->{TableChunker}->inject_chunks(
4055                                                           database   => $args{database},
4056                                                           table      => $args{table},
4057                                                           chunks     => $self->{chunks},
4058                                                           chunk_num  => $self->{chunk_num},
4059                                                           query      => $self->{chunk_sql},
4060                                                           index_hint => $self->{index_hint},
4061                                                           where      => [ $args{where} ],
4062                                                        );
4063                                                     }
4064                                                  }
4065                                                  
4066                                                  sub same_row {
4067         223                  223          1811      my ( $self, %args ) = @_;
4068         223                               1328      my ($lr, $rr) = @args{qw(lr rr)};
4069                                                  
4070         223    100    100                 1666      if ( $self->{state} ) {  # checksumming rows
                    100                               
4071         181    100                        1517         if ( $lr->{$self->{crc_col}} ne $rr->{$self->{crc_col}} ) {
4072          33                                116            my $action   = 'UPDATE';
4073          33                                103            my $auth_row = $lr;
4074          33                                103            my $change_dbh;
4075                                                  
4076          33    100                         195            if ( $self->{same_row} ) {
4077          26                                208               ($action, $auth_row, $change_dbh) = $self->{same_row}->(%args);
4078                                                           }
4079                                                  
4080          32                                228            $self->{ChangeHandler}->change(
4081                                                              $action,            # Execute the action
4082                                                              $auth_row,          # with these row values
4083                                                              $self->key_cols(),  # identified by these key cols
4084                                                              $change_dbh,        # on this dbh
4085                                                           );
4086                                                        }
4087                                                     }
4088                                                     elsif ( $lr->{cnt} != $rr->{cnt} || $lr->{crc} ne $rr->{crc} ) {
4089          28                                 86         MKDEBUG && _d('Rows:', Dumper($lr, $rr));
4090          28                                 81         MKDEBUG && _d('Will examine this chunk before moving to next');
4091          28                                209         $self->{state} = 1; # Must examine this chunk row-by-row
4092                                                     }
4093                                                  }
4094                                                  
4095                                                  sub not_in_right {
4096          10                   10           125      my ( $self, %args ) = @_;
4097  ***     10     50                          92      die "Called not_in_right in state 0" unless $self->{state};
4098                                                  
4099          10                                 40      my $action   = 'INSERT';
4100          10                                 40      my $auth_row = $args{lr};
4101          10                                 35      my $change_dbh;
4102                                                  
4103          10    100                          70      if ( $self->{not_in_right} ) {
4104           7                                 66         ($action, $auth_row, $change_dbh) = $self->{not_in_right}->(%args);
4105                                                     }
4106                                                  
4107          10                                 83      $self->{ChangeHandler}->change(
4108                                                        $action,            # Execute the action
4109                                                        $auth_row,          # with these row values
4110                                                        $self->key_cols(),  # identified by these key cols
4111                                                        $change_dbh,        # on this dbh
4112                                                     );
4113          10                                 77      return;
4114                                                  }
4115                                                  
4116                                                  sub not_in_left {
4117           8                    8            81      my ( $self, %args ) = @_;
4118  ***      8     50                          58      die "Called not_in_left in state 0" unless $self->{state};
4119                                                  
4120           8                                 37      my $action   = 'DELETE';
4121           8                                 28      my $auth_row = $args{rr};
4122           8                                 23      my $change_dbh;
4123                                                  
4124           8    100                          48      if ( $self->{not_in_left} ) {
4125           7                                 52         ($action, $auth_row, $change_dbh) = $self->{not_in_left}->(%args);
4126                                                     }
4127                                                  
4128           8                                 57      $self->{ChangeHandler}->change(
4129                                                        $action,            # Execute the action
4130                                                        $auth_row,          # with these row values
4131                                                        $self->key_cols(),  # identified by these key cols
4132                                                        $change_dbh,        # on this dbh
4133                                                     );
4134           8                                 52      return;
4135                                                  }
4136                                                  
4137                                                  sub done_with_rows {
4138          69                   69           336      my ( $self ) = @_;
4139          69    100                         491      if ( $self->{state} == 1 ) {
4140          28                                123         $self->{state} = 2;
4141          28                                 94         MKDEBUG && _d('Setting state =', $self->{state});
4142                                                     }
4143                                                     else {
4144          41                                273         $self->{state} = 0;
4145          41                                183         $self->{chunk_num}++;
4146          41                                130         MKDEBUG && _d('Setting state =', $self->{state},
4147                                                           'chunk_num =', $self->{chunk_num});
4148                                                     }
4149          69                                570      return;
4150                                                  }
4151                                                  
4152                                                  sub done {
4153          83                   83           497      my ( $self ) = @_;
4154                                                     MKDEBUG && _d('Done with', $self->{chunk_num}, 'of',
4155          83                                257         scalar(@{$self->{chunks}}), 'chunks');
4156          83                                239      MKDEBUG && $self->{state} && _d('Chunk differs; must examine rows');
4157          55                                657      return $self->{state} == 0
4158          83           100                  883         && $self->{chunk_num} >= scalar(@{$self->{chunks}})
4159                                                  }
4160                                                  
4161                                                  sub pending_changes {
4162          56                   56           267      my ( $self ) = @_;
4163          56    100                         329      if ( $self->{state} ) {
4164          28                                 85         MKDEBUG && _d('There are pending changes');
4165          28                                294         return 1;
4166                                                     }
4167                                                     else {
4168          28                                 90         MKDEBUG && _d('No pending changes');
4169          28                                295         return 0;
4170                                                     }
4171                                                  }
4172                                                  
4173                                                  sub key_cols {
4174         180                  180           799      my ( $self ) = @_;
4175         180                                562      my @cols;
4176         180    100                        1085      if ( $self->{state} == 0 ) {
4177          42                                225         @cols = qw(chunk_num);
4178                                                     }
4179                                                     else {
4180         138                                814         @cols = $self->{chunk_col};
4181                                                     }
4182         180                                512      MKDEBUG && _d('State', $self->{state},',', 'key cols', join(', ', @cols));
4183         180                               1297      return \@cols;
4184                                                  }
4185                                                  
4186                                                  sub _d {
4187  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4188  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4189  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4190                                                          @_;
4191  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4192                                                  }
4193                                                  
4194                                                  1;
4195                                                  
4196                                                  # ###########################################################################
4197                                                  # End TableSyncChunk package
4198                                                  # ###########################################################################
4199                                                  
4200                                                  # ###########################################################################
4201                                                  # TableSyncNibble package 6511
4202                                                  # This package is a copy without comments from the original.  The original
4203                                                  # with comments and its test file can be found in the SVN repository at,
4204                                                  #   trunk/common/TableSyncNibble.pm
4205                                                  #   trunk/common/t/TableSyncNibble.t
4206                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
4207                                                  # ###########################################################################
4208                                                  package TableSyncNibble;
4209                                                  
4210          36                   36           274   use strict;
              36                                102   
              36                                213   
4211          36                   36           218   use warnings FATAL => 'all';
              36                                 89   
              36                                213   
4212                                                  
4213          36                   36           211   use English qw(-no_match_vars);
              36                                101   
              36                                235   
4214          36                   36           236   use List::Util qw(max);
              36                                 96   
              36                                183   
4215          36                   36           222   use Data::Dumper;
              36                                 82   
              36                                173   
4216                                                  $Data::Dumper::Indent    = 1;
4217                                                  $Data::Dumper::Sortkeys  = 1;
4218                                                  $Data::Dumper::Quotekeys = 0;
4219                                                  
4220  ***     36            50     36           223   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                103   
              36                                488   
4221                                                  
4222                                                  sub new {
4223          16                   16           208      my ( $class, %args ) = @_;
4224          16                                147      foreach my $arg ( qw(TableNibbler TableChunker TableParser Quoter) ) {
4225  ***     64     50                         417         die "I need a $arg argument" unless defined $args{$arg};
4226                                                     }
4227          16                                196      my $self = { %args };
4228          16                                312      return bless $self, $class;
4229                                                  }
4230                                                  
4231                                                  sub name {
4232           6                    6           111      return 'Nibble';
4233                                                  }
4234                                                  
4235                                                  sub can_sync {
4236           7                    7           151      my ( $self, %args ) = @_;
4237           7                                 75      foreach my $arg ( qw(tbl_struct) ) {
4238  ***      7     50                          49         die "I need a $arg argument" unless defined $args{$arg};
4239                                                     }
4240                                                  
4241           7                                 71      my $nibble_index = $self->{TableParser}->find_best_index($args{tbl_struct});
4242           7    100                          29      if ( $nibble_index ) {
4243           6                                 18         MKDEBUG && _d('Best nibble index:', Dumper($nibble_index));
4244  ***      6     50                          47         if ( !$args{tbl_struct}->{keys}->{$nibble_index}->{is_unique} ) {
4245  ***      0                                  0            MKDEBUG && _d('Best nibble index is not unique');
4246  ***      0                                  0            return;
4247                                                        }
4248  ***      6     50     33                   41         if ( $args{chunk_index} && $args{chunk_index} ne $nibble_index ) {
4249  ***      0                                  0            MKDEBUG && _d('Best nibble index is not requested index',
4250                                                              $args{chunk_index});
4251  ***      0                                  0            return;
4252                                                        }
4253                                                     }
4254                                                     else {
4255           1                                  2         MKDEBUG && _d('No best nibble index returned');
4256           1                                  8         return;
4257                                                     }
4258                                                  
4259           6                                 18      my $small_table = 0;
4260  ***      6     50     33                   91      if ( $args{src} && $args{src}->{dbh} ) {
4261           6                                 31         my $dbh = $args{src}->{dbh};
4262           6                                 30         my $db  = $args{src}->{db};
4263           6                                 26         my $tbl = $args{src}->{tbl};
4264           6                                 16         my $table_status;
4265           6                                 24         eval {
4266           6                                 49            my $sql = "SHOW TABLE STATUS FROM `$db` LIKE "
4267                                                                   . $self->{Quoter}->literal_like($tbl);
4268           6                                 19            MKDEBUG && _d($sql);
4269           6                                 17            $table_status = $dbh->selectrow_hashref($sql);
4270                                                        };
4271           6                                 43         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
4272  ***      6     50                          35         if ( $table_status ) {
4273  ***      6      0                          47            my $n_rows   = defined $table_status->{Rows} ? $table_status->{Rows}
      ***            50                               
4274                                                                        : defined $table_status->{rows} ? $table_status->{rows}
4275                                                                        : undef;
4276  ***      6    100     66                  124            $small_table = 1 if defined $n_rows && $n_rows <= 100;
4277                                                        }
4278                                                     }
4279           6                                 16      MKDEBUG && _d('Small table:', $small_table);
4280                                                  
4281           6                                 15      MKDEBUG && _d('Can nibble using index', $nibble_index);
4282                                                     return (
4283           6                                133         1,
4284                                                        chunk_index => $nibble_index,
4285                                                        key_cols    => $args{tbl_struct}->{keys}->{$nibble_index}->{cols},
4286                                                        small_table => $small_table,
4287                                                     );
4288                                                  }
4289                                                  
4290                                                  sub prepare_to_sync {
4291           6                    6           195      my ( $self, %args ) = @_;
4292           6                                 76      my @required_args = qw(dbh db tbl tbl_struct chunk_index key_cols chunk_size
4293                                                                            crc_col ChangeHandler);
4294           6                                 37      foreach my $arg ( @required_args ) {
4295  ***     54     50                         268         die "I need a $arg argument" unless defined $args{$arg};
4296                                                     }
4297                                                  
4298           6                                 33      $self->{dbh}             = $args{dbh};
4299           6                                 28      $self->{tbl_struct}      = $args{tbl_struct};
4300           6                                 27      $self->{crc_col}         = $args{crc_col};
4301           6                                 27      $self->{index_hint}      = $args{index_hint};
4302           6                                 36      $self->{key_cols}        = $args{key_cols};
4303           6                                111      ($self->{chunk_size})    = $self->{TableChunker}->size_to_rows(%args);
4304           6                                 45      $self->{buffer_in_mysql} = $args{buffer_in_mysql};
4305           6                                 28      $self->{small_table}     = $args{small_table};
4306           6                                 30      $self->{ChangeHandler}   = $args{ChangeHandler};
4307                                                  
4308           6                                 78      $self->{ChangeHandler}->fetch_back($args{dbh});
4309                                                  
4310           6                                 24      my %seen;
4311           6                                 19      my @ucols = grep { !$seen{$_}++ } @{$args{cols}}, @{$args{key_cols}};
              28                                144   
               6                                 31   
               6                                 28   
4312           6                                 33      $args{cols} = \@ucols;
4313                                                  
4314           6                                104      $self->{sel_stmt} = $self->{TableNibbler}->generate_asc_stmt(
4315                                                        %args,
4316                                                        index    => $args{chunk_index}, # expects an index arg, not chunk_index
4317                                                        asc_only => 1,
4318                                                     );
4319                                                  
4320           6                                 43      $self->{nibble}            = 0;
4321           6                                 24      $self->{cached_row}        = undef;
4322           6                                 32      $self->{cached_nibble}     = undef;
4323           6                                 26      $self->{cached_boundaries} = undef;
4324           6                                 22      $self->{state}             = 0;
4325                                                  
4326           6                                 67      return;
4327                                                  }
4328                                                  
4329                                                  sub uses_checksum {
4330           6                    6            33      return 1;
4331                                                  }
4332                                                  
4333                                                  sub set_checksum_queries {
4334           6                    6            34      my ( $self, $nibble_sql, $row_sql ) = @_;
4335  ***      6     50                          32      die "I need a nibble_sql argument" unless $nibble_sql;
4336  ***      6     50                          26      die "I need a row_sql argument" unless $row_sql;
4337           6                                 26      $self->{nibble_sql} = $nibble_sql;
4338           6                                 25      $self->{row_sql} = $row_sql;
4339           6                                 23      return;
4340                                                  }
4341                                                  
4342                                                  sub prepare_sync_cycle {
4343          40                   40           167      my ( $self, $host ) = @_;
4344          40                                133      my $sql = 'SET @crc := "", @cnt := 0';
4345          40                                 95      MKDEBUG && _d($sql);
4346          40                               4193      $host->{dbh}->do($sql);
4347          40                                166      return;
4348                                                  }
4349                                                  
4350                                                  sub get_sql {
4351          40                   40           281      my ( $self, %args ) = @_;
4352          40    100                         199      if ( $self->{state} ) {
4353          12                                 48         my $q = $self->{Quoter};
4354          26                                 99         return 'SELECT /*rows in nibble*/ '
4355                                                           . ($self->{buffer_in_mysql} ? 'SQL_BUFFER_RESULT ' : '')
4356                                                           . $self->{row_sql} . " AS $self->{crc_col}"
4357                                                           . ' FROM ' . $q->quote(@args{qw(database table)})
4358                                                           . ' ' . ($self->{index_hint} ? $self->{index_hint} : '')
4359                                                           . ' WHERE (' . $self->__get_boundaries(%args) . ')'
4360                                                           . ($args{where} ? " AND ($args{where})" : '')
4361  ***     12     50                         153            . ' ORDER BY ' . join(', ', map {$q->quote($_) } @{$self->key_cols()});
      ***     12     50                          52   
                    100                               
4362                                                     }
4363                                                     else {
4364          28                                171         my $where = $self->__get_boundaries(%args);
4365          28                                363         return $self->{TableChunker}->inject_chunks(
4366                                                           database   => $args{database},
4367                                                           table      => $args{table},
4368                                                           chunks     => [ $where ],
4369                                                           chunk_num  => 0,
4370                                                           query      => $self->{nibble_sql},
4371                                                           index_hint => $self->{index_hint},
4372                                                           where      => [ $args{where} ],
4373                                                        );
4374                                                     }
4375                                                  }
4376                                                  
4377                                                  sub __get_boundaries {
4378          40                   40           237      my ( $self, %args ) = @_;
4379          40                                173      my $q = $self->{Quoter};
4380          40                                137      my $s = $self->{sel_stmt};
4381                                                  
4382          40                                 99      my $lb;   # Lower boundary part of WHERE
4383          40                                 96      my $ub;   # Upper boundary part of WHERE
4384          40                                104      my $row;  # Next upper boundary row or cached_row
4385                                                  
4386          40    100                         194      if ( $self->{cached_boundaries} ) {
4387          26                                 61         MKDEBUG && _d('Using cached boundaries');
4388          26                                193         return $self->{cached_boundaries};
4389                                                     }
4390                                                  
4391  ***     14     50     66                  121      if ( $self->{cached_row} && $self->{cached_nibble} == $self->{nibble} ) {
4392  ***      0                                  0         MKDEBUG && _d('Using cached row for boundaries');
4393  ***      0                                  0         $row = $self->{cached_row};
4394                                                     }
4395                                                     else {
4396          14                                 34         MKDEBUG && _d('Getting next upper boundary row');
4397          14                                 36         my $sql;
4398          14                                103         ($sql, $lb) = $self->__make_boundary_sql(%args);  # $lb from outer scope!
4399                                                  
4400          14    100    100                  147         if ( $self->{nibble} == 0 && !$self->{small_table} ) {
4401           2                                 12            my $explain_index = $self->__get_explain_index($sql);
4402  ***      2     50     50                   19            if ( lc($explain_index || '') ne lc($s->{index}) ) {
4403  ***      0      0                           0               die 'Cannot nibble table '.$q->quote($args{database}, $args{table})
4404                                                                 . " because MySQL chose "
4405                                                                 . ($explain_index ? "the `$explain_index`" : 'no') . ' index'
4406                                                                 . " instead of the `$s->{index}` index";
4407                                                           }
4408                                                        }
4409                                                  
4410          14                                 36         $row = $self->{dbh}->selectrow_hashref($sql);
4411          14                                 80         MKDEBUG && _d($row ? 'Got a row' : "Didn't get a row");
4412                                                     }
4413                                                  
4414          14    100                          69      if ( $row ) {
4415           8                                 24         my $i = 0;
4416           8                                 43         $ub   = $s->{boundaries}->{'<='};
4417           8           100                   71         $ub   =~ s/\?/$q->quote_val($row->{$s->{scols}->[$i]}, $self->{tbl_struct}->{is_numeric}->{$s->{scols}->[$i++]} || 0)/eg;
              42                                440   
4418                                                     }
4419                                                     else {
4420           6                                 18         MKDEBUG && _d('No upper boundary');
4421           6                                 23         $ub = '1=1';
4422                                                     }
4423                                                  
4424          14    100                          92      my $where = $lb ? "($lb AND $ub)" : $ub;
4425                                                  
4426          14                                 58      $self->{cached_row}        = $row;
4427          14                                 72      $self->{cached_nibble}     = $self->{nibble};
4428          14                                 59      $self->{cached_boundaries} = $where;
4429                                                  
4430          14                                 33      MKDEBUG && _d('WHERE clause:', $where);
4431          14                                 86      return $where;
4432                                                  }
4433                                                  
4434                                                  sub __make_boundary_sql {
4435          14                   14            92      my ( $self, %args ) = @_;
4436          14                                 43      my $lb;
4437          14                                 60      my $q   = $self->{Quoter};
4438          14                                 51      my $s   = $self->{sel_stmt};
4439          37                                147      my $sql = "SELECT /*nibble boundary $self->{nibble}*/ "
4440  ***     14    100     50                   71         . join(',', map { $q->quote($_) } @{$s->{cols}})
              14                                 74   
4441                                                        . " FROM " . $q->quote($args{database}, $args{table})
4442                                                        . ' ' . ($self->{index_hint} || '')
4443                                                        . ($args{where} ? " WHERE ($args{where})" : "");
4444                                                  
4445          14    100                          75      if ( $self->{nibble} ) {
4446           8                                 29         my $tmp = $self->{cached_row};
4447           8                                 21         my $i   = 0;
4448           8                                 43         $lb     = $s->{boundaries}->{'>'};
4449           8           100                   80         $lb     =~ s/\?/$q->quote_val($tmp->{$s->{scols}->[$i]}, $self->{tbl_struct}->{is_numeric}->{$s->{scols}->[$i++]} || 0)/eg;
              42                                426   
4450           8    100                          46         $sql   .= $args{where} ? " AND $lb" : " WHERE $lb";
4451                                                     }
4452          14                                 53      $sql .= " ORDER BY " . join(',', map { $q->quote($_) } @{$self->{key_cols}})
              29                                106   
              14                                 65   
4453                                                           . ' LIMIT ' . ($self->{chunk_size} - 1) . ', 1';
4454          14                                 42      MKDEBUG && _d('Lower boundary:', $lb);
4455          14                                 36      MKDEBUG && _d('Next boundary sql:', $sql);
4456          14                                 97      return $sql, $lb;
4457                                                  }
4458                                                  
4459                                                  sub __get_explain_index {
4460           2                    2            14      my ( $self, $sql ) = @_;
4461  ***      2     50                           9      return unless $sql;
4462           2                                  5      my $explain;
4463           2                                  6      eval {
4464           2                                 15         $explain = $self->{dbh}->selectall_arrayref("EXPLAIN $sql",{Slice => {}});
4465                                                     };
4466  ***      2     50                          18      if ( $EVAL_ERROR ) {
4467  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
4468  ***      0                                  0         return;
4469                                                     }
4470           2                                  5      MKDEBUG && _d('EXPLAIN key:', $explain->[0]->{key}); 
4471           2                                 16      return $explain->[0]->{key};
4472                                                  }
4473                                                  
4474                                                  sub same_row {
4475         120                  120           837      my ( $self, %args ) = @_;
4476         120                                608      my ($lr, $rr) = @args{qw(lr rr)};
4477         120    100    100                  622      if ( $self->{state} ) {
                    100                               
4478         106    100                         788         if ( $lr->{$self->{crc_col}} ne $rr->{$self->{crc_col}} ) {
4479           1                                  6            $self->{ChangeHandler}->change('UPDATE', $lr, $self->key_cols());
4480                                                        }
4481                                                     }
4482                                                     elsif ( $lr->{cnt} != $rr->{cnt} || $lr->{crc} ne $rr->{crc} ) {
4483           6                                 17         MKDEBUG && _d('Rows:', Dumper($lr, $rr));
4484           6                                 17         MKDEBUG && _d('Will examine this nibble before moving to next');
4485           6                                 38         $self->{state} = 1; # Must examine this nibble row-by-row
4486                                                     }
4487                                                  }
4488                                                  
4489                                                  sub not_in_right {
4490           8                    8            78      my ( $self, %args ) = @_;
4491  ***      8     50                          56      die "Called not_in_right in state 0" unless $self->{state};
4492           8                                 47      $self->{ChangeHandler}->change('INSERT', $args{lr}, $self->key_cols());
4493                                                  }
4494                                                  
4495                                                  sub not_in_left {
4496           4                    4            37      my ( $self, %args ) = @_;
4497  ***      4     50                          25      die "Called not_in_left in state 0" unless $self->{state};
4498           4                                 21      $self->{ChangeHandler}->change('DELETE', $args{rr}, $self->key_cols());
4499                                                  }
4500                                                  
4501                                                  sub done_with_rows {
4502          20                   20            80      my ( $self ) = @_;
4503          20    100                         109      if ( $self->{state} == 1 ) {
4504           6                                 29         $self->{state} = 2;
4505           6                                 41         MKDEBUG && _d('Setting state =', $self->{state});
4506                                                     }
4507                                                     else {
4508          14                                 56         $self->{state} = 0;
4509          14                                 56         $self->{nibble}++;
4510          14                                 64         delete $self->{cached_boundaries};
4511          14                                 92         MKDEBUG && _d('Setting state =', $self->{state},
4512                                                           ', nibble =', $self->{nibble});
4513                                                     }
4514                                                  }
4515                                                  
4516                                                  sub done {
4517          26                   26           114      my ( $self ) = @_;
4518          26                                 68      MKDEBUG && _d('Done with nibble', $self->{nibble});
4519          26                                 70      MKDEBUG && $self->{state} && _d('Nibble differs; must examine rows');
4520          26           100                  412      return $self->{state} == 0 && $self->{nibble} && !$self->{cached_row};
                           100                        
4521                                                  }
4522                                                  
4523                                                  sub pending_changes {
4524          14                   14            57      my ( $self ) = @_;
4525          14    100                          69      if ( $self->{state} ) {
4526           6                                 16         MKDEBUG && _d('There are pending changes');
4527           6                                 52         return 1;
4528                                                     }
4529                                                     else {
4530           8                                 19         MKDEBUG && _d('No pending changes');
4531           8                                 61         return 0;
4532                                                     }
4533                                                  }
4534                                                  
4535                                                  sub key_cols {
4536          45                   45           158      my ( $self ) = @_;
4537          45                                164      my @cols;
4538          45    100                         213      if ( $self->{state} == 0 ) {
4539          14                                 64         @cols = qw(chunk_num);
4540                                                     }
4541                                                     else {
4542          31                                 87         @cols = @{$self->{key_cols}};
              31                                182   
4543                                                     }
4544          45                                122      MKDEBUG && _d('State', $self->{state},',', 'key cols', join(', ', @cols));
4545          45                                303      return \@cols;
4546                                                  }
4547                                                  
4548                                                  sub _d {
4549  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4550  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4551  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4552                                                          @_;
4553  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4554                                                  }
4555                                                  
4556                                                  1;
4557                                                  
4558                                                  # ###########################################################################
4559                                                  # End TableSyncNibble package
4560                                                  # ###########################################################################
4561                                                  
4562                                                  # ###########################################################################
4563                                                  # TableSyncGroupBy package 5697
4564                                                  # This package is a copy without comments from the original.  The original
4565                                                  # with comments and its test file can be found in the SVN repository at,
4566                                                  #   trunk/common/TableSyncGroupBy.pm
4567                                                  #   trunk/common/t/TableSyncGroupBy.t
4568                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
4569                                                  # ###########################################################################
4570                                                  package TableSyncGroupBy;
4571                                                  
4572          36                   36           274   use strict;
              36                                105   
              36                                226   
4573          36                   36           220   use warnings FATAL => 'all';
              36                                 96   
              36                                217   
4574                                                  
4575          36                   36           222   use English qw(-no_match_vars);
              36                                 87   
              36                                217   
4576                                                  
4577  ***     36            50     36           237   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 86   
              36                                897   
4578                                                  
4579                                                  sub new {
4580          16                   16           203      my ( $class, %args ) = @_;
4581          16                                119      foreach my $arg ( qw(Quoter) ) {
4582  ***     16     50                         158         die "I need a $arg argument" unless $args{$arg};
4583                                                     }
4584          16                                189      my $self = { %args };
4585          16                                303      return bless $self, $class;
4586                                                  }
4587                                                  
4588                                                  sub name {
4589           5                    5           100      return 'GroupBy';
4590                                                  }
4591                                                  
4592                                                  sub can_sync {
4593           5                    5            31      return 1;  # We can sync anything.
4594                                                  }
4595                                                  
4596                                                  sub prepare_to_sync {
4597           5                    5           148      my ( $self, %args ) = @_;
4598           5                                 66      my @required_args = qw(tbl_struct cols ChangeHandler);
4599           5                                 22      foreach my $arg ( @required_args ) {
4600  ***     15     50                          91         die "I need a $arg argument" unless defined $args{$arg};
4601                                                     }
4602                                                  
4603           5                                 26      $self->{cols}            = $args{cols};
4604           5                                 25      $self->{buffer_in_mysql} = $args{buffer_in_mysql};
4605           5                                 23      $self->{ChangeHandler}   = $args{ChangeHandler};
4606                                                  
4607           5                                 44      $self->{count_col} = '__maatkit_count';
4608           5                                 50      while ( $args{tbl_struct}->{is_col}->{$self->{count_col}} ) {
4609  ***      0                                  0         $self->{count_col} = "_$self->{count_col}";
4610                                                     }
4611           5                                 14      MKDEBUG && _d('COUNT column will be named', $self->{count_col});
4612                                                  
4613           5                                 38      $self->{done} = 0;
4614                                                  
4615           5                                 47      return;
4616                                                  }
4617                                                  
4618                                                  sub uses_checksum {
4619           5                    5            27      return 0;  # We don't need checksum queries.
4620                                                  }
4621                                                  
4622                                                  sub set_checksum_queries {
4623  ***      0                    0             0      return;  # This shouldn't be called, but just in case.
4624                                                  }
4625                                                  
4626                                                  sub prepare_sync_cycle {
4627          10                   10            51      my ( $self, $host ) = @_;
4628          10                                 34      return;
4629                                                  }
4630                                                  
4631                                                  sub get_sql {
4632          10                   10            81      my ( $self, %args ) = @_;
4633          10                                 39      my $cols = join(', ', map { $self->{Quoter}->quote($_) } @{$self->{cols}});
              14                                 75   
              10                                 50   
4634  ***     10     50     50                  121      return "SELECT"
4635                                                        . ($self->{buffer_in_mysql} ? ' SQL_BUFFER_RESULT' : '')
4636                                                        . " $cols, COUNT(*) AS $self->{count_col}"
4637                                                        . ' FROM ' . $self->{Quoter}->quote(@args{qw(database table)})
4638                                                        . ' WHERE ' . ( $args{where} || '1=1' )
4639                                                        . " GROUP BY $cols ORDER BY $cols";
4640                                                  }
4641                                                  
4642                                                  sub same_row {
4643           3                    3            21      my ( $self, %args ) = @_;
4644           3                                 18      my ($lr, $rr) = @args{qw(lr rr)};
4645           3                                 12      my $cc   = $self->{count_col};
4646           3                                  9      my $lc   = $lr->{$cc};
4647           3                                  9      my $rc   = $rr->{$cc};
4648           3                                 12      my $diff = abs($lc - $rc);
4649  ***      3     50                          19      return unless $diff;
4650  ***      0                                  0      $lr = { %$lr };
4651  ***      0                                  0      delete $lr->{$cc};
4652  ***      0                                  0      $rr = { %$rr };
4653  ***      0                                  0      delete $rr->{$cc};
4654  ***      0                                  0      foreach my $i ( 1 .. $diff ) {
4655  ***      0      0                           0         if ( $lc > $rc ) {
4656  ***      0                                  0            $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
4657                                                        }
4658                                                        else {
4659  ***      0                                  0            $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
4660                                                        }
4661                                                     }
4662                                                  }
4663                                                  
4664                                                  sub not_in_right {
4665           7                    7            96      my ( $self, %args ) = @_;
4666           7                                 42      my $lr = $args{lr};
4667           7                                 45      $lr = { %$lr };
4668           7                                 47      my $cnt = delete $lr->{$self->{count_col}};
4669           7                                 53      foreach my $i ( 1 .. $cnt ) {
4670           7                                 43         $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
4671                                                     }
4672                                                  }
4673                                                  
4674                                                  sub not_in_left {
4675           1                    1            10      my ( $self, %args ) = @_;
4676           1                                  4      my $rr = $args{rr};
4677           1                                  6      $rr = { %$rr };
4678           1                                  5      my $cnt = delete $rr->{$self->{count_col}};
4679           1                                  7      foreach my $i ( 1 .. $cnt ) {
4680           1                                  5         $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
4681                                                     }
4682                                                  }
4683                                                  
4684                                                  sub done_with_rows {
4685           5                    5            24      my ( $self ) = @_;
4686           5                                 40      $self->{done} = 1;
4687                                                  }
4688                                                  
4689                                                  sub done {
4690          10                   10            47      my ( $self ) = @_;
4691          10                                 78      return $self->{done};
4692                                                  }
4693                                                  
4694                                                  sub key_cols {
4695          13                   13            55      my ( $self ) = @_;
4696          13                                107      return $self->{cols};
4697                                                  }
4698                                                  
4699                                                  sub pending_changes {
4700  ***      0                    0             0      my ( $self ) = @_;
4701  ***      0                                  0      return;
4702                                                  }
4703                                                  
4704                                                  sub _d {
4705  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4706  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4707  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4708                                                          @_;
4709  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4710                                                  }
4711                                                  
4712                                                  1;
4713                                                  
4714                                                  # ###########################################################################
4715                                                  # End TableSyncGroupBy package
4716                                                  # ###########################################################################
4717                                                  
4718                                                  # ###########################################################################
4719                                                  # TableSyncer package 6517
4720                                                  # This package is a copy without comments from the original.  The original
4721                                                  # with comments and its test file can be found in the SVN repository at,
4722                                                  #   trunk/common/TableSyncer.pm
4723                                                  #   trunk/common/t/TableSyncer.t
4724                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
4725                                                  # ###########################################################################
4726                                                  package TableSyncer;
4727                                                  
4728          36                   36           372   use strict;
              36                                110   
              36                                352   
4729          36                   36           217   use warnings FATAL => 'all';
              36                                 98   
              36                                236   
4730                                                  
4731          36                   36           216   use English qw(-no_match_vars);
              36                                 98   
              36                                199   
4732          36                   36           234   use Data::Dumper;
              36                                 89   
              36                                215   
4733                                                  $Data::Dumper::Indent    = 1;
4734                                                  $Data::Dumper::Sortkeys  = 1;
4735                                                  $Data::Dumper::Quotekeys = 0;
4736                                                  
4737  ***     36            50     36           222   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 97   
              36                                512   
4738                                                  
4739                                                  sub new {
4740          26                   26           317      my ( $class, %args ) = @_;
4741          26                                225      my @required_args = qw(MasterSlave Quoter VersionParser TableChecksum);
4742          26                                168      foreach my $arg ( @required_args ) {
4743  ***    104     50                         663         die "I need a $arg argument" unless defined $args{$arg};
4744                                                     }
4745          26                                196      my $self = { %args };
4746          26                                388      return bless $self, $class;
4747                                                  }
4748                                                  
4749                                                  sub get_best_plugin {
4750          28                   28           776      my ( $self, %args ) = @_;
4751          28                                315      foreach my $arg ( qw(plugins tbl_struct) ) {
4752  ***     56     50                         379         die "I need a $arg argument" unless $args{$arg};
4753                                                     }
4754          28                                 94      MKDEBUG && _d('Getting best plugin');
4755          28                                 90      foreach my $plugin ( @{$args{plugins}} ) {
              28                                171   
4756          35                                105         MKDEBUG && _d('Trying plugin', $plugin->name);
4757          35                                566         my ($can_sync, %plugin_args) = $plugin->can_sync(%args);
4758          35    100                         296         if ( $can_sync ) {
4759          28                                 84           MKDEBUG && _d('Can sync with', $plugin->name, Dumper(\%plugin_args));
4760          28                                393           return $plugin, %plugin_args;
4761                                                        }
4762                                                     }
4763  ***      0                                  0      MKDEBUG && _d('No plugin can sync the table');
4764  ***      0                                  0      return;
4765                                                  }
4766                                                  
4767                                                  sub sync_table {
4768          28                   28          1099      my ( $self, %args ) = @_;
4769          28                                375      my @required_args = qw(plugins src dst tbl_struct cols chunk_size
4770                                                                            RowDiff ChangeHandler);
4771          28                                174      foreach my $arg ( @required_args ) {
4772  ***    224     50                        1209         die "I need a $arg argument" unless $args{$arg};
4773                                                     }
4774                                                     MKDEBUG && _d('Syncing table with args:',
4775          28                                 94         map { "$_: " . Dumper($args{$_}) }
4776                                                        qw(plugins src dst tbl_struct cols chunk_size));
4777                                                  
4778          28                                252      my ($plugins, $src, $dst, $tbl_struct, $cols, $chunk_size, $rd, $ch)
4779                                                        = @args{@required_args};
4780          28                                129      my $dp = $self->{DSNParser};
4781  ***     28     50                         249      $args{trace} = 1 unless defined $args{trace};
4782                                                  
4783  ***     28     50     66                  257      if ( $args{bidirectional} && $args{ChangeHandler}->{queue} ) {
4784  ***      0                                  0         die "Queueing does not work with bidirectional syncing";
4785                                                     }
4786                                                  
4787  ***     28     50                         163      $args{index_hint}    = 1 unless defined $args{index_hint};
4788          28           100                  154      $args{lock}        ||= 0;
4789          28           100                  183      $args{wait}        ||= 0;
4790          28           100                  158      $args{transaction} ||= 0;
4791  ***     28            50                  161      $args{timeout_ok}  ||= 0;
4792                                                  
4793          28                                129      my $q  = $self->{Quoter};
4794          28                                118      my $vp = $self->{VersionParser};
4795                                                  
4796          28                                447      my ($plugin, %plugin_args) = $self->get_best_plugin(%args);
4797  ***     28     50                         248      die "No plugin can sync $src->{db}.$src->{tbl}" unless $plugin;
4798                                                  
4799          28                                112      my $crc_col = '__crc';
4800          28                                229      while ( $tbl_struct->{is_col}->{$crc_col} ) {
4801  ***      0                                  0         $crc_col = "_$crc_col"; # Prepend more _ until not a column.
4802                                                     }
4803          28                                 81      MKDEBUG && _d('CRC column:', $crc_col);
4804                                                  
4805          28                                 89      my $index_hint;
4806  ***     28     50     33                  838      my $hint = ($vp->version_ge($src->{dbh}, '4.0.9')
4807                                                                 && $vp->version_ge($dst->{dbh}, '4.0.9') ? 'FORCE' : 'USE')
4808                                                              . ' INDEX';
4809  ***     28     50     66                  447      if ( $args{chunk_index} ) {
                    100                               
4810  ***      0                                  0         MKDEBUG && _d('Using given chunk index for index hint');
4811  ***      0                                  0         $index_hint = "$hint (" . $q->quote($args{chunk_index}) . ")";
4812                                                     }
4813                                                     elsif ( $plugin_args{chunk_index} && $args{index_hint} ) {
4814          20                                 59         MKDEBUG && _d('Using chunk index chosen by plugin for index hint');
4815          20                                153         $index_hint = "$hint (" . $q->quote($plugin_args{chunk_index}) . ")";
4816                                                     }
4817          28                                 89      MKDEBUG && _d('Index hint:', $index_hint);
4818                                                  
4819          28                                108      eval {
4820          28                                624         $plugin->prepare_to_sync(
4821                                                           %args,
4822                                                           %plugin_args,
4823                                                           dbh        => $src->{dbh},
4824                                                           db         => $src->{db},
4825                                                           tbl        => $src->{tbl},
4826                                                           crc_col    => $crc_col,
4827                                                           index_hint => $index_hint,
4828                                                        );
4829                                                     };
4830  ***     28     50                         241      if ( $EVAL_ERROR ) {
4831  ***      0                                  0         die 'Failed to prepare TableSync', $plugin->name, ' plugin: ',
4832                                                           $EVAL_ERROR;
4833                                                     }
4834                                                  
4835          28    100                         217      if ( $plugin->uses_checksum() ) {
4836          20                                 74         eval {
4837          20                                399            my ($chunk_sql, $row_sql) = $self->make_checksum_queries(%args);
4838          20                                228            $plugin->set_checksum_queries($chunk_sql, $row_sql);
4839                                                        };
4840  ***     20     50                         147         if ( $EVAL_ERROR ) {
4841  ***      0                                  0            die "Failed to make checksum queries: $EVAL_ERROR";
4842                                                        }
4843                                                     } 
4844                                                  
4845  ***     28     50                         175      if ( $args{dry_run} ) {
4846  ***      0                                  0         return $ch->get_changes(), ALGORITHM => $plugin->name;
4847                                                     }
4848                                                  
4849                                                  
4850          28                                113      eval {
4851          28                               3573         $src->{dbh}->do("USE `$src->{db}`");
4852          28                               2999         $dst->{dbh}->do("USE `$dst->{db}`");
4853                                                     };
4854  ***     28     50                         192      if ( $EVAL_ERROR ) {
4855  ***      0                                  0         die "Failed to USE database on source or destination: $EVAL_ERROR";
4856                                                     }
4857                                                  
4858          28                                 80      MKDEBUG && _d('left dbh', $src->{dbh});
4859          28                                 78      MKDEBUG && _d('right dbh', $dst->{dbh});
4860                                                  
4861         140           100                 1496      my $trace_msg
4862                                                        = $args{trace} ? "pid:$PID src_db:$src->{db} src_tbl:$src->{tbl} "
4863                                                           . ($dp && $src->{dsn} ? "src_dsn:".$dp->as_string($src->{dsn}) : "")
4864                                                           . " dst_db:$dst->{db} dst_tbl:$dst->{tbl} "
4865                                                           . ($dp && $dst->{dsn} ? "src_dsn:".$dp->as_string($dst->{dsn}) : "")
4866  ***     28     50     33                  814            . " " . join(" ", map { "$_:" . ($args{$_} || 0) }
      ***            50     33                        
      ***            50                               
4867                                                                       qw(lock transaction changing_src replicate bidirectional))
4868                                                        :                "";
4869          28                                100      MKDEBUG && _d("Binlog trace message:", $trace_msg);
4870                                                  
4871          28                                504      $self->lock_and_wait(%args, lock_level => 2);  # per-table lock
4872                                                  
4873          28                                188      my $callback = $args{callback};
4874          28                                107      my $cycle    = 0;
4875          28                                279      while ( !$plugin->done() ) {
4876                                                  
4877          98                                392         MKDEBUG && _d('Beginning sync cycle', $cycle);
4878          98                                981         my $src_sql = $plugin->get_sql(
4879                                                           database => $src->{db},
4880                                                           table    => $src->{tbl},
4881                                                           where    => $args{where},
4882                                                        );
4883          98                                882         my $dst_sql = $plugin->get_sql(
4884                                                           database => $dst->{db},
4885                                                           table    => $dst->{tbl},
4886                                                           where    => $args{where},
4887                                                        );
4888                                                  
4889          98    100                         669         if ( $args{transaction} ) {
4890          76    100                         459            if ( $args{bidirectional} ) {
                    100                               
4891          51                                191               $src_sql .= ' FOR UPDATE';
4892          51                                205               $dst_sql .= ' FOR UPDATE';
4893                                                           }
4894                                                           elsif ( $args{changing_src} ) {
4895           6                                 21               $src_sql .= ' FOR UPDATE';
4896           6                                 23               $dst_sql .= ' LOCK IN SHARE MODE';
4897                                                           }
4898                                                           else {
4899          19                                 77               $src_sql .= ' LOCK IN SHARE MODE';
4900          19                                 79               $dst_sql .= ' FOR UPDATE';
4901                                                           }
4902                                                        }
4903          98                                271         MKDEBUG && _d('src:', $src_sql);
4904          98                                271         MKDEBUG && _d('dst:', $dst_sql);
4905                                                  
4906          98    100                         480         $callback->($src_sql, $dst_sql) if $callback;
4907                                                  
4908          98                                582         $plugin->prepare_sync_cycle($src);
4909          98                                502         $plugin->prepare_sync_cycle($dst);
4910                                                  
4911          98                                295         my $src_sth = $src->{dbh}->prepare($src_sql);
4912          98                                241         my $dst_sth = $dst->{dbh}->prepare($dst_sql);
4913          98    100                         896         if ( $args{buffer_to_client} ) {
4914          47                                649            $src_sth->{mysql_use_result} = 1;
4915          47                                352            $dst_sth->{mysql_use_result} = 1;
4916                                                        }
4917                                                  
4918          98                                413         my $executed_src = 0;
4919          98    100    100                  955         if ( !$cycle || !$plugin->pending_changes() ) {
4920          64                               1138            $executed_src
4921                                                              = $self->lock_and_wait(%args, src_sth => $src_sth, lock_level => 1);
4922                                                        }
4923                                                  
4924          98    100                       35963         $src_sth->execute() unless $executed_src;
4925          98                              35223         $dst_sth->execute();
4926                                                  
4927          98                               1890         $rd->compare_sets(
4928                                                           left_sth   => $src_sth,
4929                                                           right_sth  => $dst_sth,
4930                                                           left_dbh   => $src->{dbh},
4931                                                           right_dbh  => $dst->{dbh},
4932                                                           syncer     => $plugin,
4933                                                           tbl_struct => $tbl_struct,
4934                                                        );
4935          97                                726         $ch->process_rows(1, $trace_msg);
4936                                                  
4937          97                                269         MKDEBUG && _d('Finished sync cycle', $cycle);
4938          97                               3382         $cycle++;
4939                                                     }
4940                                                  
4941          27                                187      $ch->process_rows(0, $trace_msg);
4942                                                  
4943          27                                552      $self->unlock(%args, lock_level => 2);
4944                                                  
4945          27                                247      return $ch->get_changes(), ALGORITHM => $plugin->name;
4946                                                  }
4947                                                  
4948                                                  sub make_checksum_queries {
4949          20                   20           531      my ( $self, %args ) = @_;
4950          20                                273      my @required_args = qw(src dst tbl_struct);
4951          20                                122      foreach my $arg ( @required_args ) {
4952  ***     60     50                         373         die "I need a $arg argument" unless $args{$arg};
4953                                                     }
4954          20                                146      my ($src, $dst, $tbl_struct) = @args{@required_args};
4955          20                                 89      my $checksum = $self->{TableChecksum};
4956                                                  
4957          20                                263      my $src_algo = $checksum->best_algorithm(
4958                                                        algorithm => 'BIT_XOR',
4959                                                        dbh       => $src->{dbh},
4960                                                        where     => 1,
4961                                                        chunk     => 1,
4962                                                        count     => 1,
4963                                                     );
4964          20                                169      my $dst_algo = $checksum->best_algorithm(
4965                                                        algorithm => 'BIT_XOR',
4966                                                        dbh       => $dst->{dbh},
4967                                                        where     => 1,
4968                                                        chunk     => 1,
4969                                                        count     => 1,
4970                                                     );
4971  ***     20     50                         133      if ( $src_algo ne $dst_algo ) {
4972  ***      0                                  0         die "Source and destination checksum algorithms are different: ",
4973                                                           "$src_algo on source, $dst_algo on destination"
4974                                                     }
4975          20                                 65      MKDEBUG && _d('Chosen algo:', $src_algo);
4976                                                  
4977          20                                382      my $src_func = $checksum->choose_hash_func(dbh => $src->{dbh}, %args);
4978          20                                357      my $dst_func = $checksum->choose_hash_func(dbh => $dst->{dbh}, %args);
4979  ***     20     50                         194      if ( $src_func ne $dst_func ) {
4980  ***      0                                  0         die "Source and destination hash functions are different: ",
4981                                                        "$src_func on source, $dst_func on destination";
4982                                                     }
4983          20                                 57      MKDEBUG && _d('Chosen hash func:', $src_func);
4984                                                  
4985                                                  
4986          20                                205      my $crc_wid    = $checksum->get_crc_wid($src->{dbh}, $src_func);
4987          20                                183      my ($crc_type) = $checksum->get_crc_type($src->{dbh}, $src_func);
4988          20                                 83      my $opt_slice;
4989  ***     20    100     66                  385      if ( $src_algo eq 'BIT_XOR' && $crc_type !~ m/int$/ ) {
4990           1                                 22         $opt_slice = $checksum->optimize_xor(
4991                                                           dbh      => $src->{dbh},
4992                                                           function => $src_func
4993                                                        );
4994                                                     }
4995                                                  
4996          20                                519      my $chunk_sql = $checksum->make_checksum_query(
4997                                                        %args,
4998                                                        db        => $src->{db},
4999                                                        tbl       => $src->{tbl},
5000                                                        algorithm => $src_algo,
5001                                                        function  => $src_func,
5002                                                        crc_wid   => $crc_wid,
5003                                                        crc_type  => $crc_type,
5004                                                        opt_slice => $opt_slice,
5005                                                        replicate => undef, # replicate means something different to this sub
5006                                                     );                     # than what we use it for; do not pass it!
5007          20                                118      MKDEBUG && _d('Chunk sql:', $chunk_sql);
5008          20                                256      my $row_sql = $checksum->make_row_checksum(
5009                                                        %args,
5010                                                        function => $src_func,
5011                                                     );
5012          20                                126      MKDEBUG && _d('Row sql:', $row_sql);
5013          20                                280      return $chunk_sql, $row_sql;
5014                                                  }
5015                                                  
5016                                                  sub lock_table {
5017           8                    8            61      my ( $self, $dbh, $where, $db_tbl, $mode ) = @_;
5018           8                                 51      my $query = "LOCK TABLES $db_tbl $mode";
5019           8                                 23      MKDEBUG && _d($query);
5020           8                                858      $dbh->do($query);
5021           8                                 56      MKDEBUG && _d('Acquired table lock on', $where, 'in', $mode, 'mode');
5022                                                  }
5023                                                  
5024                                                  sub unlock {
5025          27                   27           966      my ( $self, %args ) = @_;
5026                                                  
5027          27                                342      foreach my $arg ( qw(src dst lock transaction lock_level) ) {
5028  ***    135     50                         793         die "I need a $arg argument" unless defined $args{$arg};
5029                                                     }
5030          27                                120      my $src = $args{src};
5031          27                                104      my $dst = $args{dst};
5032                                                  
5033  ***     27    100     66                  376      return unless $args{lock} && $args{lock} <= $args{lock_level};
5034                                                  
5035           6                                 39      foreach my $dbh ( $src->{dbh}, $dst->{dbh} ) {
5036          12    100                          68         if ( $args{transaction} ) {
5037           4                                  9            MKDEBUG && _d('Committing', $dbh);
5038           4                                349            $dbh->commit();
5039                                                        }
5040                                                        else {
5041           8                                 34            my $sql = 'UNLOCK TABLES';
5042           8                                 21            MKDEBUG && _d($dbh, $sql);
5043           8                               1020            $dbh->do($sql);
5044                                                        }
5045                                                     }
5046                                                  
5047           6                                 71      return;
5048                                                  }
5049                                                  
5050                                                  sub lock_and_wait {
5051          92                   92          2809      my ( $self, %args ) = @_;
5052          92                                857      my $result = 0;
5053                                                  
5054          92                                460      foreach my $arg ( qw(src dst lock lock_level) ) {
5055  ***    368     50                        2112         die "I need a $arg argument" unless defined $args{$arg};
5056                                                     }
5057          92                                382      my $src = $args{src};
5058          92                                351      my $dst = $args{dst};
5059                                                  
5060          92    100    100                 1304      return unless $args{lock} && $args{lock} == $args{lock_level};
5061          12                                 36      MKDEBUG && _d('lock and wait, lock level', $args{lock});
5062                                                  
5063          12                                 78      foreach my $dbh ( $src->{dbh}, $dst->{dbh} ) {
5064          24    100                         130         if ( $args{transaction} ) {
5065           8                                 17            MKDEBUG && _d('Committing', $dbh);
5066           8                                629            $dbh->commit();
5067                                                        }
5068                                                        else {
5069          16                                 67            my $sql = 'UNLOCK TABLES';
5070          16                                 47            MKDEBUG && _d($dbh, $sql);
5071          16                               1485            $dbh->do($sql);
5072                                                        }
5073                                                     }
5074                                                  
5075  ***     12     50                          97      if ( $args{lock} == 3 ) {
5076  ***      0                                  0         my $sql = 'FLUSH TABLES WITH READ LOCK';
5077  ***      0                                  0         MKDEBUG && _d($src->{dbh}, $sql);
5078  ***      0                                  0         $src->{dbh}->do($sql);
5079                                                     }
5080                                                     else {
5081          12    100                          61         if ( $args{transaction} ) {
5082  ***      4     50                          19            if ( $args{src_sth} ) {
5083           4                                 11               MKDEBUG && _d('Executing statement on source to lock rows');
5084                                                  
5085           4                                 14               my $sql = "START TRANSACTION /*!40108 WITH CONSISTENT SNAPSHOT */";
5086           4                                  9               MKDEBUG && _d($src->{dbh}, $sql);
5087           4                                263               $src->{dbh}->do($sql);
5088                                                  
5089           4                               1337               $args{src_sth}->execute();
5090           4                                 21               $result = 1;
5091                                                           }
5092                                                        }
5093                                                        else {
5094  ***      8     50                          84            $self->lock_table($src->{dbh}, 'source',
5095                                                              $self->{Quoter}->quote($src->{db}, $src->{tbl}),
5096                                                              $args{changing_src} ? 'WRITE' : 'READ');
5097                                                        }
5098                                                     }
5099                                                  
5100          12                                 46      eval {
5101  ***     12     50                          79         if ( $args{wait} ) {
5102          12                                149            $self->{MasterSlave}->wait_for_master(
5103                                                              $src->{misc_dbh}, $dst->{dbh}, $args{wait}, $args{timeout_ok});
5104                                                        }
5105                                                  
5106  ***     12     50                          65         if ( $args{changing_src} ) {
5107          12                                 43            MKDEBUG && _d('Not locking destination because changing source ',
5108                                                              '(syncing via replication or sync-to-master)');
5109                                                        }
5110                                                        else {
5111  ***      0      0                           0            if ( $args{lock} == 3 ) {
      ***             0                               
5112  ***      0                                  0               my $sql = 'FLUSH TABLES WITH READ LOCK';
5113  ***      0                                  0               MKDEBUG && _d($dst->{dbh}, ',', $sql);
5114  ***      0                                  0               $dst->{dbh}->do($sql);
5115                                                           }
5116                                                           elsif ( !$args{transaction} ) {
5117  ***      0      0                           0               $self->lock_table($dst->{dbh}, 'dest',
5118                                                                 $self->{Quoter}->quote($dst->{db}, $dst->{tbl}),
5119                                                                 $args{execute} ? 'WRITE' : 'READ');
5120                                                           }
5121                                                        }
5122                                                     };
5123                                                  
5124  ***     12     50                          56      if ( $EVAL_ERROR ) {
5125  ***      0      0                           0         if ( $args{src_sth}->{Active} ) {
5126  ***      0                                  0            $args{src_sth}->finish();
5127                                                        }
5128  ***      0                                  0         foreach my $dbh ( $src->{dbh}, $dst->{dbh}, $src->{misc_dbh} ) {
5129  ***      0      0                           0            next unless $dbh;
5130  ***      0                                  0            MKDEBUG && _d('Caught error, unlocking/committing on', $dbh);
5131  ***      0                                  0            $dbh->do('UNLOCK TABLES');
5132  ***      0      0                           0            $dbh->commit() unless $dbh->{AutoCommit};
5133                                                        }
5134  ***      0                                  0         die $EVAL_ERROR;
5135                                                     }
5136                                                  
5137          12                                152      return $result;
5138                                                  }
5139                                                  
5140                                                  sub have_all_privs {
5141          59                   59           417      my ( $self, $dbh, $db, $tbl ) = @_;
5142          59                                523      my $db_tbl = $self->{Quoter}->quote($db, $tbl);
5143          59                                282      my $sql    = "SHOW FULL COLUMNS FROM $db_tbl";
5144          59                                174      MKDEBUG && _d('Permissions check:', $sql);
5145          59                                667      my $cols       = $dbh->selectall_arrayref($sql, {Slice => {}});
5146          59                                517      my ($hdr_name) = grep { m/privileges/i } keys %{$cols->[0]};
             531                               2268   
              59                                525   
5147          59                                418      my $privs      = $cols->[0]->{$hdr_name};
5148          59                                299      $sql = "DELETE FROM $db_tbl LIMIT 0"; # FULL COLUMNS doesn't show all privs
5149          59                                174      MKDEBUG && _d('Permissions check:', $sql);
5150          59                                203      eval { $dbh->do($sql); };
              59                               8593   
5151          59    100                         385      my $can_delete = $EVAL_ERROR ? 0 : 1;
5152                                                  
5153          59                                174      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
5154                                                        ($can_delete ? 'delete' : ''));
5155  ***     59    100     66                 1601      if ( $privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/ 
      ***                   66                        
      ***                   66                        
5156                                                          && $can_delete ) {
5157          58                                165         MKDEBUG && _d('User has all privs');
5158          58                                871         return 1;
5159                                                     }
5160           1                                  3      MKDEBUG && _d('User does not have all privs');
5161           1                                 12      return 0;
5162                                                  }
5163                                                  
5164                                                  sub _d {
5165  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5166  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5167  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5168                                                          @_;
5169  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5170                                                  }
5171                                                  
5172                                                  1;
5173                                                  
5174                                                  # ###########################################################################
5175                                                  # End TableSyncer package
5176                                                  # ###########################################################################
5177                                                  
5178                                                  # ###########################################################################
5179                                                  # TableNibbler package 5266
5180                                                  # This package is a copy without comments from the original.  The original
5181                                                  # with comments and its test file can be found in the SVN repository at,
5182                                                  #   trunk/common/TableNibbler.pm
5183                                                  #   trunk/common/t/TableNibbler.t
5184                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
5185                                                  # ###########################################################################
5186                                                  package TableNibbler;
5187                                                  
5188          36                   36           288   use strict;
              36                                 98   
              36                                236   
5189          36                   36           218   use warnings FATAL => 'all';
              36                                111   
              36                                226   
5190                                                  
5191          36                   36           225   use English qw(-no_match_vars);
              36                                 90   
              36                                193   
5192                                                  
5193  ***     36            50     36           231   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 97   
              36                                498   
5194                                                  
5195                                                  sub new {
5196          26                   26           236      my ( $class, %args ) = @_;
5197          26                                175      my @required_args = qw(TableParser Quoter);
5198          26                                166      foreach my $arg ( @required_args ) {
5199  ***     52     50                         371         die "I need a $arg argument" unless $args{$arg};
5200                                                     }
5201          26                                173      my $self = { %args };
5202          26                                360      return bless $self, $class;
5203                                                  }
5204                                                  
5205                                                  sub generate_asc_stmt {
5206           6                    6           182      my ( $self, %args ) = @_;
5207           6                                 68      my @required_args = qw(tbl_struct index);
5208           6                                 35      foreach my $arg ( @required_args ) {
5209  ***     12     50                          71         die "I need a $arg argument" unless defined $args{$arg};
5210                                                     }
5211           6                                 35      my ($tbl_struct, $index) = @args{@required_args};
5212  ***      6     50                          30      my @cols = $args{cols}  ? @{$args{cols}} : @{$tbl_struct->{cols}};
               6                                 42   
      ***      0                                  0   
5213           6                                 29      my $q    = $self->{Quoter};
5214                                                  
5215  ***      6     50                          38      die "Index '$index' does not exist in table"
5216                                                        unless exists $tbl_struct->{keys}->{$index};
5217                                                  
5218           6                                 22      my @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
               6                                 41   
5219           6                                 19      my @asc_slice;
5220                                                  
5221           6                                 18      @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
               6                                 42   
5222           6                                 16      MKDEBUG && _d('Will ascend index', $index);
5223           6                                 17      MKDEBUG && _d('Will ascend columns', join(', ', @asc_cols));
5224  ***      6     50                          29      if ( $args{asc_first} ) {
5225  ***      0                                  0         @asc_cols = $asc_cols[0];
5226  ***      0                                  0         MKDEBUG && _d('Ascending only first column');
5227                                                     }
5228                                                  
5229           6                                 19      my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
               6                                 20   
               6                                 21   
              15                                 74   
5230           6                                 28      foreach my $col ( @asc_cols ) {
5231  ***     13     50                          63         if ( !exists $col_posn{$col} ) {
5232  ***      0                                  0            push @cols, $col;
5233  ***      0                                  0            $col_posn{$col} = $#cols;
5234                                                        }
5235          13                                 64         push @asc_slice, $col_posn{$col};
5236                                                     }
5237           6                                 20      MKDEBUG && _d('Will ascend, in ordinal position:', join(', ', @asc_slice));
5238                                                  
5239           6                                 64      my $asc_stmt = {
5240                                                        cols  => \@cols,
5241                                                        index => $index,
5242                                                        where => '',
5243                                                        slice => [],
5244                                                        scols => [],
5245                                                     };
5246                                                  
5247  ***      6     50                          32      if ( @asc_slice ) {
5248           6                                 19         my $cmp_where;
5249           6                                 29         foreach my $cmp ( qw(< <= >= >) ) {
5250          24                                191            $cmp_where = $self->generate_cmp_where(
5251                                                              type        => $cmp,
5252                                                              slice       => \@asc_slice,
5253                                                              cols        => \@cols,
5254                                                              quoter      => $q,
5255                                                              is_nullable => $tbl_struct->{is_nullable},
5256                                                           );
5257          24                                221            $asc_stmt->{boundaries}->{$cmp} = $cmp_where->{where};
5258                                                        }
5259  ***      6     50                          34         my $cmp = $args{asc_only} ? '>' : '>=';
5260           6                                 35         $asc_stmt->{where} = $asc_stmt->{boundaries}->{$cmp};
5261           6                                 26         $asc_stmt->{slice} = $cmp_where->{slice};
5262           6                                 32         $asc_stmt->{scols} = $cmp_where->{scols};
5263                                                     }
5264                                                  
5265           6                                 74      return $asc_stmt;
5266                                                  }
5267                                                  
5268                                                  sub generate_cmp_where {
5269          24                   24           181      my ( $self, %args ) = @_;
5270          24                                125      foreach my $arg ( qw(type slice cols is_nullable) ) {
5271  ***     96     50                         477         die "I need a $arg arg" unless defined $args{$arg};
5272                                                     }
5273          24                                 71      my @slice       = @{$args{slice}};
              24                                117   
5274          24                                 71      my @cols        = @{$args{cols}};
              24                                118   
5275          24                                 93      my $is_nullable = $args{is_nullable};
5276          24                                 76      my $type        = $args{type};
5277          24                                 83      my $q           = $self->{Quoter};
5278                                                  
5279          24                                126      (my $cmp = $type) =~ s/=//;
5280                                                  
5281          24                                 65      my @r_slice;    # Resulting slice columns, by ordinal
5282          24                                 60      my @r_scols;    # Ditto, by name
5283                                                  
5284          24                                 60      my @clauses;
5285          24                                149      foreach my $i ( 0 .. $#slice ) {
5286          52                                159         my @clause;
5287                                                  
5288          52                                226         foreach my $j ( 0 .. $i - 1 ) {
5289          32                                 99            my $ord = $slice[$j];
5290          32                                100            my $col = $cols[$ord];
5291          32                                122            my $quo = $q->quote($col);
5292          32    100                         143            if ( $is_nullable->{$col} ) {
5293           4                                 18               push @clause, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
5294           4                                 11               push @r_slice, $ord, $ord;
5295           4                                 17               push @r_scols, $col, $col;
5296                                                           }
5297                                                           else {
5298          28                                102               push @clause, "$quo = ?";
5299          28                                 86               push @r_slice, $ord;
5300          28                                117               push @r_scols, $col;
5301                                                           }
5302                                                        }
5303                                                  
5304          52                                178         my $ord = $slice[$i];
5305          52                                171         my $col = $cols[$ord];
5306          52                                206         my $quo = $q->quote($col);
5307          52                                208         my $end = $i == $#slice; # Last clause of the whole group.
5308          52    100                         226         if ( $is_nullable->{$col} ) {
5309           8    100    100                   66            if ( $type =~ m/=/ && $end ) {
                    100                               
5310           2                                 11               push @clause, "(? IS NULL OR $quo $type ?)";
5311                                                           }
5312                                                           elsif ( $type =~ m/>/ ) {
5313           3                                 17               push @clause, "((? IS NULL AND $quo IS NOT NULL) OR ($quo $cmp ?))";
5314                                                           }
5315                                                           else { # If $type =~ m/</ ) {
5316           3                                 22               push @clause, "((? IS NOT NULL AND $quo IS NULL) OR ($quo $cmp ?))";
5317                                                           }
5318           8                                 24            push @r_slice, $ord, $ord;
5319           8                                 25            push @r_scols, $col, $col;
5320                                                        }
5321                                                        else {
5322          44                                142            push @r_slice, $ord;
5323          44                                147            push @r_scols, $col;
5324          44    100    100                  424            push @clause, ($type =~ m/=/ && $end ? "$quo $type ?" : "$quo $cmp ?");
5325                                                        }
5326                                                  
5327          52                                319         push @clauses, '(' . join(' AND ', @clause) . ')';
5328                                                     }
5329          24                                128      my $result = '(' . join(' OR ', @clauses) . ')';
5330          24                                140      my $where = {
5331                                                        slice => \@r_slice,
5332                                                        scols => \@r_scols,
5333                                                        where => $result,
5334                                                     };
5335          24                                160      return $where;
5336                                                  }
5337                                                  
5338                                                  sub generate_del_stmt {
5339  ***      0                    0             0      my ( $self, %args ) = @_;
5340                                                  
5341  ***      0                                  0      my $tbl  = $args{tbl_struct};
5342  ***      0      0                           0      my @cols = $args{cols} ? @{$args{cols}} : ();
      ***      0                                  0   
5343  ***      0                                  0      my $tp   = $self->{TableParser};
5344  ***      0                                  0      my $q    = $self->{Quoter};
5345                                                  
5346  ***      0                                  0      my @del_cols;
5347  ***      0                                  0      my @del_slice;
5348                                                  
5349  ***      0                                  0      my $index = $tp->find_best_index($tbl, $args{index});
5350  ***      0      0                           0      die "Cannot find an ascendable index in table" unless $index;
5351                                                  
5352  ***      0      0                           0      if ( $index ) {
5353  ***      0                                  0         @del_cols = @{$tbl->{keys}->{$index}->{cols}};
      ***      0                                  0   
5354                                                     }
5355                                                     else {
5356  ***      0                                  0         @del_cols = @{$tbl->{cols}};
      ***      0                                  0   
5357                                                     }
5358  ***      0                                  0      MKDEBUG && _d('Columns needed for DELETE:', join(', ', @del_cols));
5359                                                  
5360  ***      0                                  0      my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
5361  ***      0                                  0      foreach my $col ( @del_cols ) {
5362  ***      0      0                           0         if ( !exists $col_posn{$col} ) {
5363  ***      0                                  0            push @cols, $col;
5364  ***      0                                  0            $col_posn{$col} = $#cols;
5365                                                        }
5366  ***      0                                  0         push @del_slice, $col_posn{$col};
5367                                                     }
5368  ***      0                                  0      MKDEBUG && _d('Ordinals needed for DELETE:', join(', ', @del_slice));
5369                                                  
5370  ***      0                                  0      my $del_stmt = {
5371                                                        cols  => \@cols,
5372                                                        index => $index,
5373                                                        where => '',
5374                                                        slice => [],
5375                                                        scols => [],
5376                                                     };
5377                                                  
5378  ***      0                                  0      my @clauses;
5379  ***      0                                  0      foreach my $i ( 0 .. $#del_slice ) {
5380  ***      0                                  0         my $ord = $del_slice[$i];
5381  ***      0                                  0         my $col = $cols[$ord];
5382  ***      0                                  0         my $quo = $q->quote($col);
5383  ***      0      0                           0         if ( $tbl->{is_nullable}->{$col} ) {
5384  ***      0                                  0            push @clauses, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
5385  ***      0                                  0            push @{$del_stmt->{slice}}, $ord, $ord;
      ***      0                                  0   
5386  ***      0                                  0            push @{$del_stmt->{scols}}, $col, $col;
      ***      0                                  0   
5387                                                        }
5388                                                        else {
5389  ***      0                                  0            push @clauses, "$quo = ?";
5390  ***      0                                  0            push @{$del_stmt->{slice}}, $ord;
      ***      0                                  0   
5391  ***      0                                  0            push @{$del_stmt->{scols}}, $col;
      ***      0                                  0   
5392                                                        }
5393                                                     }
5394                                                  
5395  ***      0                                  0      $del_stmt->{where} = '(' . join(' AND ', @clauses) . ')';
5396                                                  
5397  ***      0                                  0      return $del_stmt;
5398                                                  }
5399                                                  
5400                                                  sub generate_ins_stmt {
5401  ***      0                    0             0      my ( $self, %args ) = @_;
5402  ***      0                                  0      foreach my $arg ( qw(ins_tbl sel_cols) ) {
5403  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5404                                                     }
5405  ***      0                                  0      my $ins_tbl  = $args{ins_tbl};
5406  ***      0                                  0      my @sel_cols = @{$args{sel_cols}};
      ***      0                                  0   
5407                                                  
5408  ***      0      0                           0      die "You didn't specify any SELECT columns" unless @sel_cols;
5409                                                  
5410  ***      0                                  0      my @ins_cols;
5411  ***      0                                  0      my @ins_slice;
5412  ***      0                                  0      for my $i ( 0..$#sel_cols ) {
5413  ***      0      0                           0         next unless $ins_tbl->{is_col}->{$sel_cols[$i]};
5414  ***      0                                  0         push @ins_cols, $sel_cols[$i];
5415  ***      0                                  0         push @ins_slice, $i;
5416                                                     }
5417                                                  
5418                                                     return {
5419  ***      0                                  0         cols  => \@ins_cols,
5420                                                        slice => \@ins_slice,
5421                                                     };
5422                                                  }
5423                                                  
5424                                                  sub _d {
5425  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5426  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5427  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5428                                                          @_;
5429  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5430                                                  }
5431                                                  
5432                                                  1;
5433                                                  
5434                                                  # ###########################################################################
5435                                                  # End TableNibbler package
5436                                                  # ###########################################################################
5437                                                  
5438                                                  # ###########################################################################
5439                                                  # MasterSlave package 6452
5440                                                  # This package is a copy without comments from the original.  The original
5441                                                  # with comments and its test file can be found in the SVN repository at,
5442                                                  #   trunk/common/MasterSlave.pm
5443                                                  #   trunk/common/t/MasterSlave.t
5444                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
5445                                                  # ###########################################################################
5446          36                   36           270   use strict;
              36                                 91   
              36                                201   
5447          36                   36           213   use warnings FATAL => 'all';
              36                                101   
              36                                203   
5448                                                  
5449                                                  package MasterSlave;
5450                                                  
5451          36                   36           229   use English qw(-no_match_vars);
              36                                 90   
              36                                191   
5452          36                   36           250   use List::Util qw(min max);
              36                                 93   
              36                                223   
5453          36                   36           218   use Data::Dumper;
              36                                 85   
              36                                191   
5454                                                  $Data::Dumper::Quotekeys = 0;
5455                                                  $Data::Dumper::Indent    = 0;
5456                                                  
5457  ***     36            50     36           226   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 85   
              36                                495   
5458                                                  
5459                                                  sub new {
5460          26                   26           247      my ( $class, %args ) = @_;
5461          26                                173      my $self = { %args };
5462          26                                362      return bless $self, $class;
5463                                                  }
5464                                                  
5465                                                  sub recurse_to_slaves {
5466  ***      0                    0             0      my ( $self, $args, $level ) = @_;
5467  ***      0             0                    0      $level ||= 0;
5468  ***      0                                  0      my $dp   = $args->{dsn_parser};
5469  ***      0                                  0      my $dsn  = $args->{dsn};
5470                                                  
5471  ***      0                                  0      my $dbh;
5472  ***      0                                  0      eval {
5473  ***      0             0                    0         $dbh = $args->{dbh} || $dp->get_dbh(
5474                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
5475  ***      0                                  0         MKDEBUG && _d('Connected to', $dp->as_string($dsn));
5476                                                     };
5477  ***      0      0                           0      if ( $EVAL_ERROR ) {
5478  ***      0      0                           0         print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
5479                                                           or die "Cannot print: $OS_ERROR";
5480  ***      0                                  0         return;
5481                                                     }
5482                                                  
5483  ***      0                                  0      my $sql  = 'SELECT @@SERVER_ID';
5484  ***      0                                  0      MKDEBUG && _d($sql);
5485  ***      0                                  0      my ($id) = $dbh->selectrow_array($sql);
5486  ***      0                                  0      MKDEBUG && _d('Working on server ID', $id);
5487  ***      0                                  0      my $master_thinks_i_am = $dsn->{server_id};
5488  ***      0      0      0                    0      if ( !defined $id
      ***                    0                        
      ***                    0                        
5489                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
5490                                                         || $args->{server_ids_seen}->{$id}++
5491                                                     ) {
5492  ***      0                                  0         MKDEBUG && _d('Server ID seen, or not what master said');
5493  ***      0      0                           0         if ( $args->{skip_callback} ) {
5494  ***      0                                  0            $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
5495                                                        }
5496  ***      0                                  0         return;
5497                                                     }
5498                                                  
5499  ***      0                                  0      $args->{callback}->($dsn, $dbh, $level, $args->{parent});
5500                                                  
5501  ***      0      0      0                    0      if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
5502                                                  
5503  ***      0      0                           0         my @slaves =
5504  ***      0                                  0            grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
5505                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
5506                                                  
5507  ***      0                                  0         foreach my $slave ( @slaves ) {
5508  ***      0                                  0            MKDEBUG && _d('Recursing from',
5509                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
5510  ***      0                                  0            $self->recurse_to_slaves(
5511                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
5512                                                        }
5513                                                     }
5514                                                  }
5515                                                  
5516                                                  sub find_slave_hosts {
5517  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
5518                                                  
5519  ***      0                                  0      my @methods = qw(processlist hosts);
5520  ***      0      0                           0      if ( $method ) {
5521  ***      0                                  0         @methods = grep { $_ ne $method } @methods;
      ***      0                                  0   
5522  ***      0                                  0         unshift @methods, $method;
5523                                                     }
5524                                                     else {
5525  ***      0      0      0                    0         if ( ($dsn->{P} || 3306) != 3306 ) {
5526  ***      0                                  0            MKDEBUG && _d('Port number is non-standard; using only hosts method');
5527  ***      0                                  0            @methods = qw(hosts);
5528                                                        }
5529                                                     }
5530  ***      0                                  0      MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
5531                                                        'using methods', @methods);
5532                                                  
5533  ***      0                                  0      my @slaves;
5534                                                     METHOD:
5535  ***      0                                  0      foreach my $method ( @methods ) {
5536  ***      0                                  0         my $find_slaves = "_find_slaves_by_$method";
5537  ***      0                                  0         MKDEBUG && _d('Finding slaves with', $find_slaves);
5538  ***      0                                  0         @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
5539  ***      0      0                           0         last METHOD if @slaves;
5540                                                     }
5541                                                  
5542  ***      0                                  0      MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
5543  ***      0                                  0      return @slaves;
5544                                                  }
5545                                                  
5546                                                  sub _find_slaves_by_processlist {
5547  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
5548                                                  
5549  ***      0                                  0      my @slaves = map  {
5550  ***      0                                  0         my $slave        = $dsn_parser->parse("h=$_", $dsn);
5551  ***      0                                  0         $slave->{source} = 'processlist';
5552  ***      0                                  0         $slave;
5553                                                     }
5554  ***      0                                  0      grep { $_ }
5555                                                     map  {
5556  ***      0                                  0         my ( $host ) = $_->{host} =~ m/^([^:]+):/;
5557  ***      0      0                           0         if ( $host eq 'localhost' ) {
5558  ***      0                                  0            $host = '127.0.0.1'; # Replication never uses sockets.
5559                                                        }
5560  ***      0                                  0         $host;
5561                                                     } $self->get_connected_slaves($dbh);
5562                                                  
5563  ***      0                                  0      return @slaves;
5564                                                  }
5565                                                  
5566                                                  sub _find_slaves_by_hosts {
5567  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
5568                                                  
5569  ***      0                                  0      my @slaves;
5570  ***      0                                  0      my $sql = 'SHOW SLAVE HOSTS';
5571  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
5572  ***      0                                  0      @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                  0   
5573                                                  
5574  ***      0      0                           0      if ( @slaves ) {
5575  ***      0                                  0         MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
5576  ***      0                                  0         @slaves = map {
5577  ***      0                                  0            my %hash;
5578  ***      0                                  0            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
5579  ***      0      0                           0            my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
5580                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
5581                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
5582  ***      0                                  0            my $dsn           = $dsn_parser->parse($spec, $dsn);
5583  ***      0                                  0            $dsn->{server_id} = $hash{server_id};
5584  ***      0                                  0            $dsn->{master_id} = $hash{master_id};
5585  ***      0                                  0            $dsn->{source}    = 'hosts';
5586  ***      0                                  0            $dsn;
5587                                                        } @slaves;
5588                                                     }
5589                                                  
5590  ***      0                                  0      return @slaves;
5591                                                  }
5592                                                  
5593                                                  sub get_connected_slaves {
5594           5                    5            28      my ( $self, $dbh ) = @_;
5595                                                  
5596           5                                 22      my $show = "SHOW GRANTS FOR ";
5597           5                                 18      my $user = 'CURRENT_USER()';
5598           5                                 28      my $vp   = $self->{VersionParser};
5599  ***      5     50     33                   77      if ( $vp && !$vp->version_ge($dbh, '4.1.2') ) {
5600  ***      0                                  0         $user = $dbh->selectrow_arrayref('SELECT USER()')->[0];
5601  ***      0                                  0         $user =~ s/([^@]+)@(.+)/'$1'\@'$2'/;
5602                                                     }
5603           5                                 30      my $sql = $show . $user;
5604           5                                 14      MKDEBUG && _d($dbh, $sql);
5605                                                  
5606           5                                 16      my $proc;
5607           5                                 19      eval {
5608           5                                108         $proc = grep {
5609           5                                 15            m/ALL PRIVILEGES.*?\*\.\*|PROCESS/
5610           5                                 17         } @{$dbh->selectcol_arrayref($sql)};
5611                                                     };
5612  ***      5     50                          35      if ( $EVAL_ERROR ) {
5613                                                  
5614  ***      0      0                           0         if ( $EVAL_ERROR =~ m/no such grant defined for user/ ) {
5615  ***      0                                  0            MKDEBUG && _d('Retrying SHOW GRANTS without host; error:',
5616                                                              $EVAL_ERROR);
5617  ***      0                                  0            ($user) = split('@', $user);
5618  ***      0                                  0            $sql    = $show . $user;
5619  ***      0                                  0            MKDEBUG && _d($sql);
5620  ***      0                                  0            eval {
5621  ***      0                                  0               $proc = grep {
5622  ***      0                                  0                  m/ALL PRIVILEGES.*?\*\.\*|PROCESS/
5623  ***      0                                  0               } @{$dbh->selectcol_arrayref($sql)};
5624                                                           };
5625                                                        }
5626                                                  
5627  ***      0      0                           0         die "Failed to $sql: $EVAL_ERROR" if $EVAL_ERROR;
5628                                                     }
5629  ***      5     50                          25      if ( !$proc ) {
5630  ***      0                                  0         die "You do not have the PROCESS privilege";
5631                                                     }
5632                                                  
5633           5                                 19      $sql = 'SHOW PROCESSLIST';
5634           5                                 16      MKDEBUG && _d($dbh, $sql);
5635          15                                135      grep { $_->{command} =~ m/Binlog Dump/i }
              15                                 68   
5636                                                     map  { # Lowercase the column names
5637           5                                170         my %hash;
5638          15                                124         @hash{ map { lc $_ } keys %$_ } = values %$_;
             120                                576   
5639          15                                101         \%hash;
5640                                                     }
5641           5                                 22      @{$dbh->selectall_arrayref($sql, { Slice => {} })};
5642                                                  }
5643                                                  
5644                                                  sub is_master_of {
5645           5                    5            33      my ( $self, $master, $slave ) = @_;
5646  ***      5     50                          56      my $master_status = $self->get_master_status($master)
5647                                                        or die "The server specified as a master is not a master";
5648  ***      5     50                          36      my $slave_status  = $self->get_slave_status($slave)
5649                                                        or die "The server specified as a slave is not a slave";
5650  ***      5     50                          58      my @connected     = $self->get_connected_slaves($master)
5651                                                        or die "The server specified as a master has no connected slaves";
5652           5                                 14      my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
5653                                                  
5654  ***      5     50                        2921      if ( $port != $slave_status->{master_port} ) {
5655  ***      0                                  0         die "The slave is connected to $slave_status->{master_port} "
5656                                                           . "but the master's port is $port";
5657                                                     }
5658                                                  
5659  ***      5     50                          26      if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
               5                                 54   
5660  ***      0                                  0         die "I don't see any slave I/O thread connected with user "
5661                                                           . $slave_status->{master_user};
5662                                                     }
5663                                                  
5664  ***      5     50     50                   52      if ( ($slave_status->{slave_io_state} || '')
5665                                                        eq 'Waiting for master to send event' )
5666                                                     {
5667           5                                 96         my ( $master_log_name, $master_log_num )
5668                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
5669           5                                 60         my ( $slave_log_name, $slave_log_num )
5670                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
5671  ***      5     50     33                  107         if ( $master_log_name ne $slave_log_name
5672                                                           || abs($master_log_num - $slave_log_num) > 1 )
5673                                                        {
5674  ***      0                                  0            die "The slave thinks it is reading from "
5675                                                              . "$slave_status->{master_log_file},  but the "
5676                                                              . "master is writing to $master_status->{file}";
5677                                                        }
5678                                                     }
5679           5                                103      return 1;
5680                                                  }
5681                                                  
5682                                                  sub get_master_dsn {
5683           5                    5            34      my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
5684  ***      5     50                          42      my $master = $self->get_slave_status($dbh) or return undef;
5685           5                                 46      my $spec   = "h=$master->{master_host},P=$master->{master_port}";
5686           5                                 34      return       $dsn_parser->parse($spec, $dsn);
5687                                                  }
5688                                                  
5689                                                  sub get_slave_status {
5690          33                   33           173      my ( $self, $dbh ) = @_;
5691  ***     33     50                         434      if ( !$self->{not_a_slave}->{$dbh} ) {
5692  ***     33            66                  136         my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
5693                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
5694          33                                307         MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
5695          33                               6683         $sth->execute();
5696          33                                142         my ($ss) = @{$sth->fetchall_arrayref({})};
              33                                407   
5697                                                  
5698  ***     33    100     66                  603         if ( $ss && %$ss ) {
5699          18                                225            $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
             684                               4123   
5700          18                                424            return $ss;
5701                                                        }
5702                                                  
5703          15                                 41         MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
5704          15                                183         $self->{not_a_slave}->{$dbh}++;
5705                                                     }
5706                                                  }
5707                                                  
5708                                                  sub get_master_status {
5709          17                   17            90      my ( $self, $dbh ) = @_;
5710  ***     17     50                         233      if ( !$self->{not_a_master}->{$dbh} ) {
5711  ***     17            66                   90         my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
5712                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
5713          17                                146         MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
5714          17                               2187         $sth->execute();
5715          17                                 78         my ($ms) = @{$sth->fetchall_arrayref({})};
              17                                126   
5716                                                  
5717  ***     17     50     33                  415         if ( $ms && %$ms ) {
5718          17                                121            $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
              68                                473   
5719  ***     17     50     33                  328            if ( $ms->{file} && $ms->{position} ) {
5720          17                                107               return $ms;
5721                                                           }
5722                                                        }
5723                                                  
5724  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
5725  ***      0                                  0         $self->{not_a_master}->{$dbh}++;
5726                                                     }
5727                                                  }
5728                                                  
5729                                                  sub wait_for_master {
5730          12                   12            93      my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
5731          12                                 39      my $result;
5732  ***     12     50                          74      $time = 60 unless defined $time;
5733          12                                 29      MKDEBUG && _d('Waiting', $time, 'seconds for slave to catch up to master;',
5734                                                        'timeout ok:', ($timeoutok ? 'yes' : 'no'));
5735  ***     12            33                  108      $ms ||= $self->get_master_status($master);
5736  ***     12     50                          67      if ( $ms ) {
5737          12                                105         my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
5738          12                                 31         MKDEBUG && _d($slave, $query);
5739          12                                 31         ($result) = $slave->selectrow_array($query);
5740  ***     12     50                        2038         my $stat = defined $result ? $result : 'NULL';
5741          12                                 34         MKDEBUG && _d('Result of waiting:', $stat);
5742  ***     12     50     33                  229         if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                   33                        
5743  ***      0                                  0            die "MASTER_POS_WAIT returned $stat";
5744                                                        }
5745                                                     }
5746                                                     else {
5747  ***      0                                  0         MKDEBUG && _d('Not waiting: this server is not a master');
5748                                                     }
5749          12                                 72      return $result;
5750                                                  }
5751                                                  
5752                                                  sub stop_slave {
5753  ***      0                    0             0      my ( $self, $dbh ) = @_;
5754  ***      0             0                    0      my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
5755                                                           ||= $dbh->prepare('STOP SLAVE');
5756  ***      0                                  0      MKDEBUG && _d($dbh, $sth->{Statement});
5757  ***      0                                  0      $sth->execute();
5758                                                  }
5759                                                  
5760                                                  sub start_slave {
5761  ***      0                    0             0      my ( $self, $dbh, $pos ) = @_;
5762  ***      0      0                           0      if ( $pos ) {
5763  ***      0                                  0         my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
5764                                                                . "MASTER_LOG_POS=$pos->{position}";
5765  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
5766  ***      0                                  0         $dbh->do($sql);
5767                                                     }
5768                                                     else {
5769  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
5770                                                              ||= $dbh->prepare('START SLAVE');
5771  ***      0                                  0         MKDEBUG && _d($dbh, $sth->{Statement});
5772  ***      0                                  0         $sth->execute();
5773                                                     }
5774                                                  }
5775                                                  
5776                                                  sub catchup_to_master {
5777  ***      0                    0             0      my ( $self, $slave, $master, $time ) = @_;
5778  ***      0                                  0      $self->stop_slave($master);
5779  ***      0                                  0      $self->stop_slave($slave);
5780  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave);
5781  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
5782  ***      0                                  0      my $master_status = $self->get_master_status($master);
5783  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
5784  ***      0                                  0      MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
5785                                                        'Slave position:', $self->pos_to_string($slave_pos));
5786  ***      0      0                           0      if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
5787  ***      0                                  0         MKDEBUG && _d('Waiting for slave to catch up to master');
5788  ***      0                                  0         $self->start_slave($slave, $master_pos);
5789  ***      0                                  0         eval {
5790  ***      0                                  0            $self->wait_for_master($master, $slave, $time, 0, $master_status);
5791                                                        };
5792  ***      0      0                           0         if ( $EVAL_ERROR ) {
5793  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
5794  ***      0      0                           0            if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
5795  ***      0                                  0               $slave_status = $self->get_slave_status($slave);
5796  ***      0      0                           0               if ( !$self->slave_is_running($slave_status) ) {
5797  ***      0                                  0                  MKDEBUG && _d('Master position:',
5798                                                                    $self->pos_to_string($master_pos),
5799                                                                    'Slave position:', $self->pos_to_string($slave_pos));
5800  ***      0                                  0                  $slave_pos = $self->repl_posn($slave_status);
5801  ***      0      0                           0                  if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
5802  ***      0                                  0                     die "$EVAL_ERROR but slave has not caught up to master";
5803                                                                 }
5804  ***      0                                  0                  MKDEBUG && _d('Slave is caught up to master and stopped');
5805                                                              }
5806                                                              else {
5807  ***      0                                  0                  die "$EVAL_ERROR but slave was still running";
5808                                                              }
5809                                                           }
5810                                                           else {
5811  ***      0                                  0               die $EVAL_ERROR;
5812                                                           }
5813                                                        }
5814                                                     }
5815                                                  }
5816                                                  
5817                                                  sub catchup_to_same_pos {
5818  ***      0                    0             0      my ( $self, $s1_dbh, $s2_dbh ) = @_;
5819  ***      0                                  0      $self->stop_slave($s1_dbh);
5820  ***      0                                  0      $self->stop_slave($s2_dbh);
5821  ***      0                                  0      my $s1_status = $self->get_slave_status($s1_dbh);
5822  ***      0                                  0      my $s2_status = $self->get_slave_status($s2_dbh);
5823  ***      0                                  0      my $s1_pos    = $self->repl_posn($s1_status);
5824  ***      0                                  0      my $s2_pos    = $self->repl_posn($s2_status);
5825  ***      0      0                           0      if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
5826  ***      0                                  0         $self->start_slave($s1_dbh, $s2_pos);
5827                                                     }
5828                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
5829  ***      0                                  0         $self->start_slave($s2_dbh, $s1_pos);
5830                                                     }
5831                                                  
5832  ***      0                                  0      $s1_status = $self->get_slave_status($s1_dbh);
5833  ***      0                                  0      $s2_status = $self->get_slave_status($s2_dbh);
5834  ***      0                                  0      $s1_pos    = $self->repl_posn($s1_status);
5835  ***      0                                  0      $s2_pos    = $self->repl_posn($s2_status);
5836                                                  
5837  ***      0      0      0                    0      if ( $self->slave_is_running($s1_status)
      ***                    0                        
5838                                                       || $self->slave_is_running($s2_status)
5839                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
5840                                                     {
5841  ***      0                                  0         die "The servers aren't both stopped at the same position";
5842                                                     }
5843                                                  
5844                                                  }
5845                                                  
5846                                                  sub change_master_to {
5847  ***      0                    0             0      my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
5848  ***      0                                  0      $self->stop_slave($dbh);
5849  ***      0                                  0      MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
5850  ***      0                                  0      my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
5851                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
5852                                                        . "MASTER_LOG_POS=$master_pos->{position}";
5853  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
5854  ***      0                                  0      $dbh->do($sql);
5855                                                  }
5856                                                  
5857                                                  sub make_sibling_of_master {
5858  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
5859                                                  
5860  ***      0      0                           0      my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5861                                                        or die "This server is not a slave";
5862  ***      0                                  0      my $master_dbh  = $dsn_parser->get_dbh(
5863                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
5864  ***      0      0                           0      my $gmaster_dsn
5865                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5866                                                        or die "This server's master is not a slave";
5867  ***      0                                  0      my $gmaster_dbh = $dsn_parser->get_dbh(
5868                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
5869  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
5870  ***      0                                  0         die "The slave's master's master is the slave: master-master replication";
5871                                                     }
5872                                                  
5873  ***      0                                  0      $self->stop_slave($master_dbh);
5874  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
5875  ***      0                                  0      $self->stop_slave($slave_dbh);
5876                                                  
5877  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
5878  ***      0                                  0      my $mslave_status = $self->get_slave_status($master_dbh);
5879  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
5880  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
5881  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
5882                                                  
5883  ***      0      0      0                    0      if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
5884                                                       && !$self->slave_is_running($slave_status)
5885                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
5886                                                     {
5887  ***      0                                  0         $self->change_master_to($slave_dbh, $gmaster_dsn,
5888                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
5889                                                     }
5890                                                     else {
5891  ***      0                                  0         die "The servers aren't both stopped at the same position";
5892                                                     }
5893                                                  
5894  ***      0                                  0      $mslave_status = $self->get_slave_status($master_dbh);
5895  ***      0                                  0      $slave_status  = $self->get_slave_status($slave_dbh);
5896  ***      0                                  0      my $mslave_pos = $self->repl_posn($mslave_status);
5897  ***      0                                  0      $slave_pos     = $self->repl_posn($slave_status);
5898  ***      0      0      0                    0      if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
5899                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
5900                                                     {
5901  ***      0                                  0         die "The servers don't have the same master/position after the change";
5902                                                     }
5903                                                  }
5904                                                  
5905                                                  sub make_slave_of_sibling {
5906  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
5907                                                          $dsn_parser, $timeout) = @_;
5908                                                  
5909  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
5910  ***      0                                  0         die "You are trying to make the slave a slave of itself";
5911                                                     }
5912                                                  
5913  ***      0      0                           0      my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5914                                                        or die "This server is not a slave";
5915  ***      0                                  0      my $master_dbh1 = $dsn_parser->get_dbh(
5916                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
5917  ***      0      0                           0      my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5918                                                        or die "The sibling is not a slave";
5919  ***      0      0                           0      if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
5920  ***      0                                  0         die "This server isn't a sibling of the slave";
5921                                                     }
5922  ***      0      0                           0      my $sib_master_stat = $self->get_master_status($sib_dbh)
5923                                                        or die "Binary logging is not enabled on the sibling";
5924  ***      0      0                           0      die "The log_slave_updates option is not enabled on the sibling"
5925                                                        unless $self->has_slave_updates($sib_dbh);
5926                                                  
5927  ***      0                                  0      $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
5928                                                  
5929  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
5930  ***      0                                  0      $self->change_master_to($slave_dbh, $sib_dsn,
5931                                                           $self->repl_posn($sib_master_stat));
5932                                                  
5933  ***      0                                  0      my $slave_status = $self->get_slave_status($slave_dbh);
5934  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
5935  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
5936  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
5937                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
5938                                                     {
5939  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the sibling, "
5940                                                           . "or it has a different replication position than the sibling";
5941                                                     }
5942                                                  }
5943                                                  
5944                                                  sub make_slave_of_uncle {
5945  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
5946                                                          $dsn_parser, $timeout) = @_;
5947                                                  
5948  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
5949  ***      0                                  0         die "You are trying to make the slave a slave of itself";
5950                                                     }
5951                                                  
5952  ***      0      0                           0      my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5953                                                        or die "This server is not a slave";
5954  ***      0                                  0      my $master_dbh = $dsn_parser->get_dbh(
5955                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
5956  ***      0      0                           0      my $gmaster_dsn
5957                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5958                                                        or die "The master is not a slave";
5959  ***      0      0                           0      my $unc_master_dsn
5960                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
5961                                                        or die "The uncle is not a slave";
5962  ***      0      0                           0      if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
5963  ***      0                                  0         die "The uncle isn't really the slave's uncle";
5964                                                     }
5965                                                  
5966  ***      0      0                           0      my $unc_master_stat = $self->get_master_status($unc_dbh)
5967                                                        or die "Binary logging is not enabled on the uncle";
5968  ***      0      0                           0      die "The log_slave_updates option is not enabled on the uncle"
5969                                                        unless $self->has_slave_updates($unc_dbh);
5970                                                  
5971  ***      0                                  0      $self->catchup_to_same_pos($master_dbh, $unc_dbh);
5972  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
5973                                                  
5974  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
5975  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
5976  ***      0      0                           0      if ( $self->pos_cmp(
5977                                                           $self->repl_posn($slave_status),
5978                                                           $self->repl_posn($master_status)) != 0 )
5979                                                     {
5980  ***      0                                  0         die "The slave is not caught up to its master";
5981                                                     }
5982                                                  
5983  ***      0                                  0      $unc_master_stat = $self->get_master_status($unc_dbh);
5984  ***      0                                  0      $self->change_master_to($slave_dbh, $unc_dsn,
5985                                                        $self->repl_posn($unc_master_stat));
5986                                                  
5987                                                  
5988  ***      0                                  0      $slave_status    = $self->get_slave_status($slave_dbh);
5989  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
5990  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
5991                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
5992                                                     {
5993  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the uncle, "
5994                                                           . "or it has a different replication position than the uncle";
5995                                                     }
5996                                                  }
5997                                                  
5998                                                  sub detach_slave {
5999  ***      0                    0             0      my ( $self, $dbh ) = @_;
6000  ***      0                                  0      $self->stop_slave($dbh);
6001  ***      0      0                           0      my $stat = $self->get_slave_status($dbh)
6002                                                        or die "This server is not a slave";
6003  ***      0                                  0      $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
6004  ***      0                                  0      $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
6005  ***      0                                  0      return $stat;
6006                                                  }
6007                                                  
6008                                                  sub slave_is_running {
6009  ***      0                    0             0      my ( $self, $slave_status ) = @_;
6010  ***      0             0                    0      return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
6011                                                  }
6012                                                  
6013                                                  sub has_slave_updates {
6014  ***      0                    0             0      my ( $self, $dbh ) = @_;
6015  ***      0                                  0      my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
6016  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
6017  ***      0                                  0      my ($name, $value) = $dbh->selectrow_array($sql);
6018  ***      0             0                    0      return $value && $value =~ m/^(1|ON)$/;
6019                                                  }
6020                                                  
6021                                                  sub repl_posn {
6022  ***      0                    0             0      my ( $self, $status ) = @_;
6023  ***      0      0      0                    0      if ( exists $status->{file} && exists $status->{position} ) {
6024                                                        return {
6025  ***      0                                  0            file     => $status->{file},
6026                                                           position => $status->{position},
6027                                                        };
6028                                                     }
6029                                                     else {
6030                                                        return {
6031  ***      0                                  0            file     => $status->{relay_master_log_file},
6032                                                           position => $status->{exec_master_log_pos},
6033                                                        };
6034                                                     }
6035                                                  }
6036                                                  
6037                                                  sub get_slave_lag {
6038  ***      0                    0             0      my ( $self, $dbh ) = @_;
6039  ***      0                                  0      my $stat = $self->get_slave_status($dbh);
6040  ***      0                                  0      return $stat->{seconds_behind_master};
6041                                                  }
6042                                                  
6043                                                  sub pos_cmp {
6044  ***      0                    0             0      my ( $self, $a, $b ) = @_;
6045  ***      0                                  0      return $self->pos_to_string($a) cmp $self->pos_to_string($b);
6046                                                  }
6047                                                  
6048                                                  sub short_host {
6049  ***      0                    0             0      my ( $self, $dsn ) = @_;
6050  ***      0                                  0      my ($host, $port);
6051  ***      0      0                           0      if ( $dsn->{master_host} ) {
6052  ***      0                                  0         $host = $dsn->{master_host};
6053  ***      0                                  0         $port = $dsn->{master_port};
6054                                                     }
6055                                                     else {
6056  ***      0                                  0         $host = $dsn->{h};
6057  ***      0                                  0         $port = $dsn->{P};
6058                                                     }
6059  ***      0      0      0                    0      return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
6060                                                  }
6061                                                     
6062                                                  sub is_replication_thread {
6063  ***      0                    0             0      my ( $self, $query, $type ) = @_; 
6064  ***      0      0                           0      return unless $query;
6065                                                  
6066  ***      0             0                    0      $type ||= 'all';
6067  ***      0      0                           0      die "Invalid type: $type"
6068                                                        unless $type =~ m/binlog_dump|slave_io|slave_sql|all/i;
6069                                                  
6070  ***      0                                  0      my $match = 0;
6071  ***      0      0                           0      if ( $type =~ m/binlog_dump|all/i ) {
6072  ***      0      0      0                    0         $match = 1
      ***                    0                        
6073                                                           if ($query->{Command} || $query->{command} || '') eq "Binlog Dump";
6074                                                     }
6075  ***      0      0                           0      if ( !$match ) {
6076  ***      0      0      0                    0         if ( ($query->{User} || $query->{user} || '') eq "system user" ) {
      ***                    0                        
6077  ***      0             0                    0            my $state = $query->{State} || $query->{state} || '';
      ***                    0                        
6078  ***      0      0                           0            if ( $type =~ m/slave_io|all/i ) {
6079  ***      0                                  0               ($match) = $state =~ m/
6080                                                                 ^(Waiting\sfor\smaster\supdate
6081                                                                  |Connecting\sto\smaster
6082                                                                  |Waiting\sto\sreconnect\safter\sa\sfailed
6083                                                                  |Reconnecting\safter\sa\sfailed\sbinlog
6084                                                                  |Waiting\sfor\smaster\sto\ssend\sevent
6085                                                                  |Queueing\smaster\sevent\sto\sthe\srelay
6086                                                                  |Waiting\sto\sreconnect\safter\sa\sfailed
6087                                                                  |Reconnecting\safter\sa\sfailed\smaster
6088                                                                  |Waiting\sfor\sthe\sslave\sSQL\sthread)/xi;
6089                                                           }
6090  ***      0      0      0                    0            if ( !$match && $type =~ m/slave_sql|all/i ) {
6091  ***      0                                  0               ($match) = $state =~ m/
6092                                                                 ^(Waiting\sfor\sthe\snext\sevent
6093                                                                  |Reading\sevent\sfrom\sthe\srelay\slog
6094                                                                  |Has\sread\sall\srelay\slog;\swaiting
6095                                                                  |Making\stemp\sfile)/xi; 
6096                                                           }
6097                                                        }
6098                                                        else {
6099  ***      0                                  0            MKDEBUG && _d('Not system user');
6100                                                        }
6101                                                     }
6102  ***      0                                  0      MKDEBUG && _d($type, 'replication thread:', ($match ? 'yes' : 'no'),
6103                                                        '; match:', $match);
6104  ***      0                                  0      return $match;
6105                                                  }
6106                                                  
6107                                                  sub get_replication_filters {
6108  ***      0                    0             0      my ( $self, %args ) = @_;
6109  ***      0                                  0      my @required_args = qw(dbh);
6110  ***      0                                  0      foreach my $arg ( @required_args ) {
6111  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6112                                                     }
6113  ***      0                                  0      my ($dbh) = @args{@required_args};
6114                                                  
6115  ***      0                                  0      my %filters = ();
6116                                                  
6117  ***      0                                  0      my $status = $self->get_master_status($dbh);
6118  ***      0      0                           0      if ( $status ) {
6119  ***      0      0                           0         map { $filters{$_} = $status->{$_} }
      ***      0                                  0   
6120  ***      0                                  0         grep { defined $status->{$_} && $status->{$_} ne '' }
6121                                                        qw(
6122                                                           binlog_do_db
6123                                                           binlog_ignore_db
6124                                                        );
6125                                                     }
6126                                                  
6127  ***      0                                  0      $status = $self->get_slave_status($dbh);
6128  ***      0      0                           0      if ( $status ) {
6129  ***      0      0                           0         map { $filters{$_} = $status->{$_} }
      ***      0                                  0   
6130  ***      0                                  0         grep { defined $status->{$_} && $status->{$_} ne '' }
6131                                                        qw(
6132                                                           replicate_do_db
6133                                                           replicate_ignore_db
6134                                                           replicate_do_table
6135                                                           replicate_ignore_table 
6136                                                           replicate_wild_do_table
6137                                                           replicate_wild_ignore_table
6138                                                        );
6139                                                  
6140  ***      0                                  0         my $sql = "SHOW VARIABLES LIKE 'slave_skip_errors'";
6141  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
6142  ***      0                                  0         my $row = $dbh->selectrow_arrayref($sql);
6143  ***      0      0      0                    0         $filters{slave_skip_errors} = $row->[1] if $row->[1] && $row->[1] ne 'OFF';
6144                                                     }
6145                                                  
6146  ***      0                                  0      return \%filters; 
6147                                                  }
6148                                                  
6149                                                  sub pos_to_string {
6150  ***      0                    0             0      my ( $self, $pos ) = @_;
6151  ***      0                                  0      my $fmt  = '%s/%020d';
6152  ***      0                                  0      return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                  0   
6153                                                  }
6154                                                  
6155                                                  sub _d {
6156  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6157  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6158  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6159                                                          @_;
6160  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6161                                                  }
6162                                                  
6163                                                  1;
6164                                                  
6165                                                  # ###########################################################################
6166                                                  # End MasterSlave package
6167                                                  # ###########################################################################
6168                                                  
6169                                                  # ###########################################################################
6170                                                  # Daemon package 6255
6171                                                  # This package is a copy without comments from the original.  The original
6172                                                  # with comments and its test file can be found in the SVN repository at,
6173                                                  #   trunk/common/Daemon.pm
6174                                                  #   trunk/common/t/Daemon.t
6175                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
6176                                                  # ###########################################################################
6177                                                  
6178                                                  package Daemon;
6179                                                  
6180          36                   36           322   use strict;
              36                                107   
              36                                362   
6181          36                   36           229   use warnings FATAL => 'all';
              36                                105   
              36                                226   
6182                                                  
6183          36                   36           222   use POSIX qw(setsid);
              36                                 98   
              36                                258   
6184          36                   36           228   use English qw(-no_match_vars);
              36                                 94   
              36                                222   
6185                                                  
6186  ***     36            50     36           250   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 87   
              36                                545   
6187                                                  
6188                                                  sub new {
6189  ***      0                    0             0      my ( $class, %args ) = @_;
6190  ***      0                                  0      foreach my $arg ( qw(o) ) {
6191  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6192                                                     }
6193  ***      0                                  0      my $o = $args{o};
6194  ***      0      0                           0      my $self = {
      ***             0                               
6195                                                        o        => $o,
6196                                                        log_file => $o->has('log') ? $o->get('log') : undef,
6197                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
6198                                                     };
6199                                                  
6200  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
6201                                                  
6202  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
6203  ***      0                                  0      return bless $self, $class;
6204                                                  }
6205                                                  
6206                                                  sub daemonize {
6207  ***      0                    0             0      my ( $self ) = @_;
6208                                                  
6209  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
6210  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
6211  ***      0      0                           0      if ( $pid ) {
6212  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
6213  ***      0                                  0         exit;
6214                                                     }
6215                                                  
6216  ***      0                                  0      $self->{PID_owner} = $PID;
6217  ***      0                                  0      $self->{child}     = 1;
6218                                                  
6219  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
6220  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
6221                                                  
6222  ***      0                                  0      $self->_make_PID_file();
6223                                                  
6224  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
6225                                                  
6226  ***      0      0                           0      if ( -t STDIN ) {
6227  ***      0                                  0         close STDIN;
6228  ***      0      0                           0         open  STDIN, '/dev/null'
6229                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
6230                                                     }
6231                                                  
6232  ***      0      0                           0      if ( $self->{log_file} ) {
6233  ***      0                                  0         close STDOUT;
6234  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
6235                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
6236                                                  
6237  ***      0                                  0         close STDERR;
6238  ***      0      0                           0         open  STDERR, ">&STDOUT"
6239                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
6240                                                     }
6241                                                     else {
6242  ***      0      0                           0         if ( -t STDOUT ) {
6243  ***      0                                  0            close STDOUT;
6244  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
6245                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
6246                                                        }
6247  ***      0      0                           0         if ( -t STDERR ) {
6248  ***      0                                  0            close STDERR;
6249  ***      0      0                           0            open  STDERR, '>', '/dev/null'
6250                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
6251                                                        }
6252                                                     }
6253                                                  
6254  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
6255  ***      0                                  0      return;
6256                                                  }
6257                                                  
6258                                                  sub check_PID_file {
6259  ***      0                    0             0      my ( $self, $file ) = @_;
6260  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
6261  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
6262  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
6263  ***      0                                  0         my $pid;
6264  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
6265  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
6266  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
6267  ***      0      0                           0         if ( $pid ) {
6268  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
6269  ***      0      0                           0            if ( $pid_is_alive ) {
6270  ***      0                                  0               die "The PID file $PID_file already exists "
6271                                                                 . " and the PID that it contains, $pid, is running";
6272                                                           }
6273                                                           else {
6274  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
6275                                                                 . "contains, $pid, is not running";
6276                                                           }
6277                                                        }
6278                                                        else {
6279  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
6280                                                              . "contain a PID";
6281                                                        }
6282                                                     }
6283                                                     else {
6284  ***      0                                  0         MKDEBUG && _d('No PID file');
6285                                                     }
6286  ***      0                                  0      return;
6287                                                  }
6288                                                  
6289                                                  sub make_PID_file {
6290  ***      0                    0             0      my ( $self ) = @_;
6291  ***      0      0                           0      if ( exists $self->{child} ) {
6292  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
6293                                                     }
6294  ***      0                                  0      $self->_make_PID_file();
6295  ***      0                                  0      $self->{PID_owner} = $PID;
6296  ***      0                                  0      return;
6297                                                  }
6298                                                  
6299                                                  sub _make_PID_file {
6300  ***      0                    0             0      my ( $self ) = @_;
6301                                                  
6302  ***      0                                  0      my $PID_file = $self->{PID_file};
6303  ***      0      0                           0      if ( !$PID_file ) {
6304  ***      0                                  0         MKDEBUG && _d('No PID file to create');
6305  ***      0                                  0         return;
6306                                                     }
6307                                                  
6308  ***      0                                  0      $self->check_PID_file();
6309                                                  
6310  ***      0      0                           0      open my $PID_FH, '>', $PID_file
6311                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
6312  ***      0      0                           0      print $PID_FH $PID
6313                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
6314  ***      0      0                           0      close $PID_FH
6315                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
6316                                                  
6317  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
6318  ***      0                                  0      return;
6319                                                  }
6320                                                  
6321                                                  sub _remove_PID_file {
6322  ***      0                    0             0      my ( $self ) = @_;
6323  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
6324  ***      0      0                           0         unlink $self->{PID_file}
6325                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
6326  ***      0                                  0         MKDEBUG && _d('Removed PID file');
6327                                                     }
6328                                                     else {
6329  ***      0                                  0         MKDEBUG && _d('No PID to remove');
6330                                                     }
6331  ***      0                                  0      return;
6332                                                  }
6333                                                  
6334                                                  sub DESTROY {
6335  ***      0                    0             0      my ( $self ) = @_;
6336                                                  
6337  ***      0      0      0                    0      $self->_remove_PID_file() if ($self->{PID_owner} || 0) == $PID;
6338                                                  
6339  ***      0                                  0      return;
6340                                                  }
6341                                                  
6342                                                  sub _d {
6343  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6344  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6345  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6346                                                          @_;
6347  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6348                                                  }
6349                                                  
6350                                                  1;
6351                                                  
6352                                                  # ###########################################################################
6353                                                  # End Daemon package
6354                                                  # ###########################################################################
6355                                                  
6356                                                  # ###########################################################################
6357                                                  # SchemaIterator package 5473
6358                                                  # This package is a copy without comments from the original.  The original
6359                                                  # with comments and its test file can be found in the SVN repository at,
6360                                                  #   trunk/common/SchemaIterator.pm
6361                                                  #   trunk/common/t/SchemaIterator.t
6362                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
6363                                                  # ###########################################################################
6364                                                  package SchemaIterator;
6365                                                  
6366          36                   36           267   use strict;
              36                                108   
              36                                197   
6367          36                   36           223   use warnings FATAL => 'all';
              36                                 85   
              36                                205   
6368                                                  
6369          36                   36           216   use English qw(-no_match_vars);
              36                                110   
              36                                206   
6370          36                   36           247   use Data::Dumper;
              36                                104   
              36                                199   
6371                                                  $Data::Dumper::Indent    = 1;
6372                                                  $Data::Dumper::Sortkeys  = 1;
6373                                                  $Data::Dumper::Quotekeys = 0;
6374                                                  
6375  ***     36            50     36           224   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 95   
              36                                523   
6376                                                  
6377                                                  sub new {
6378           9                    9            79      my ( $class, %args ) = @_;
6379           9                                 60      foreach my $arg ( qw(Quoter) ) {
6380  ***      9     50                          78         die "I need a $arg argument" unless $args{$arg};
6381                                                     }
6382           9                                 89      my $self = {
6383                                                        %args,
6384                                                        filter => undef,
6385                                                        dbs    => [],
6386                                                     };
6387           9                                146      return bless $self, $class;
6388                                                  }
6389                                                  
6390                                                  sub make_filter {
6391          10                   10            56      my ( $self, $o ) = @_;
6392          10                                 80      my @lines = (
6393                                                        'sub {',
6394                                                        '   my ( $dbh, $db, $tbl ) = @_;',
6395                                                        '   my $engine = undef;',
6396                                                     );
6397                                                  
6398                                                  
6399  ***     10     50                          67      my @permit_dbs = _make_filter('unless', '$db', $o->get('databases'))
6400                                                        if $o->has('databases');
6401  ***     10     50                          63      my @reject_dbs = _make_filter('if', '$db', $o->get('ignore-databases'))
6402                                                        if $o->has('ignore-databases');
6403          10                                 38      my @dbs_regex;
6404  ***     10     50     33                   55      if ( $o->has('databases-regex') && (my $p = $o->get('databases-regex')) ) {
6405  ***      0                                  0         push @dbs_regex, "      return 0 unless \$db && (\$db =~ m/$p/o);";
6406                                                     }
6407          10                                 44      my @reject_dbs_regex;
6408  ***     10     50     33                   53      if ( $o->has('ignore-databases-regex')
6409                                                          && (my $p = $o->get('ignore-databases-regex')) ) {
6410  ***      0                                  0         push @reject_dbs_regex, "      return 0 if \$db && (\$db =~ m/$p/o);";
6411                                                     }
6412  ***     10    100     66                  143      if ( @permit_dbs || @reject_dbs || @dbs_regex || @reject_dbs_regex ) {
      ***                   66                        
      ***                   66                        
6413  ***      9     50                         124         push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
6414                                                           '   if ( $db ) {',
6415                                                              (@permit_dbs        ? @permit_dbs       : ()),
6416                                                              (@reject_dbs        ? @reject_dbs       : ()),
6417                                                              (@dbs_regex         ? @dbs_regex        : ()),
6418                                                              (@reject_dbs_regex  ? @reject_dbs_regex : ()),
6419                                                           '   }';
6420                                                     }
6421                                                  
6422  ***     10     50     33                   57      if ( $o->has('tables') || $o->has('ignore-tables')
      ***                   33                        
6423                                                          || $o->has('ignore-tables-regex') ) {
6424                                                  
6425          10                                 38         my $have_qtbl       = 0;
6426          10                                 34         my $have_only_qtbls = 0;
6427          10                                 33         my %qtbls;
6428                                                  
6429          10                                 33         my @permit_tbls;
6430          10                                 28         my @permit_qtbls;
6431          10                                 30         my %permit_qtbls;
6432          10    100                          53         if ( $o->get('tables') ) {
6433           2                                  8            my %tbls;
6434                                                           map {
6435  ***      2     50                          15               if ( $_ =~ m/\./ ) {
               2                                 13   
6436           2                                 16                  $permit_qtbls{$_} = 1;
6437                                                              }
6438                                                              else {
6439  ***      0                                  0                  $tbls{$_} = 1;
6440                                                              }
6441           2                                  7            } keys %{ $o->get('tables') };
6442           2                                 16            @permit_tbls  = _make_filter('unless', '$tbl', \%tbls);
6443           2                                132            @permit_qtbls = _make_filter('unless', '$qtbl', \%permit_qtbls);
6444                                                  
6445  ***      2     50                          16            if ( @permit_qtbls ) {
6446           2                                 10               push @lines,
6447                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
6448           2                                 11               $have_qtbl = 1;
6449                                                           }
6450                                                        }
6451                                                  
6452          10                                 35         my @reject_tbls;
6453          10                                 31         my @reject_qtbls;
6454          10                                 42         my %reject_qtbls;
6455  ***     10     50                          53         if ( $o->get('ignore-tables') ) {
6456          10                                 36            my %tbls;
6457                                                           map {
6458  ***      0      0                           0               if ( $_ =~ m/\./ ) {
              10                                 50   
6459  ***      0                                  0                  $reject_qtbls{$_} = 1;
6460                                                              }
6461                                                              else {
6462  ***      0                                  0                  $tbls{$_} = 1;
6463                                                              }
6464          10                                 34            } keys %{ $o->get('ignore-tables') };
6465          10                                 62            @reject_tbls= _make_filter('if', '$tbl', \%tbls);
6466          10                                 61            @reject_qtbls = _make_filter('if', '$qtbl', \%reject_qtbls);
6467                                                  
6468  ***     10     50     33                   98            if ( @reject_qtbls && !$have_qtbl ) {
6469  ***      0                                  0               push @lines,
6470                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
6471                                                           }
6472                                                        }
6473                                                  
6474          10    100    100                  103         if ( keys %permit_qtbls  && !@permit_dbs ) {
6475           1                                  5            my $dbs = {};
6476           1                                 11            map {
6477           1                                  6               my ($db, undef) = split(/\./, $_);
6478           1                                  9               $dbs->{$db} = 1;
6479                                                           } keys %permit_qtbls;
6480           1                                  3            MKDEBUG && _d('Adding restriction "--databases',
6481                                                                 (join(',', keys %$dbs) . '"'));
6482  ***      1     50                          11            if ( keys %$dbs ) {
6483           1                                  8               $o->set('databases', $dbs);
6484           1                                 35               return $self->make_filter($o);
6485                                                           }
6486                                                        }
6487                                                  
6488           9                                 33         my @tbls_regex;
6489  ***      9     50     33                   50         if ( $o->has('tables-regex') && (my $p = $o->get('tables-regex')) ) {
6490  ***      0                                  0            push @tbls_regex, "      return 0 unless \$tbl && (\$tbl =~ m/$p/o);";
6491                                                        }
6492           9                                 29         my @reject_tbls_regex;
6493  ***      9     50     33                   65         if ( $o->has('ignore-tables-regex')
6494                                                             && (my $p = $o->get('ignore-tables-regex')) ) {
6495  ***      0                                  0            push @reject_tbls_regex,
6496                                                              "      return 0 if \$tbl && (\$tbl =~ m/$p/o);";
6497                                                        }
6498                                                  
6499           9                                 32         my @get_eng;
6500           9                                 31         my @permit_engs;
6501           9                                 28         my @reject_engs;
6502  ***      9     50     33                   48         if ( ($o->has('engines') && $o->get('engines'))
      ***                   33                        
      ***                   33                        
6503                                                             || ($o->has('ignore-engines') && $o->get('ignore-engines')) ) {
6504           9                                 76            push @get_eng,
6505                                                              '      my $sql = "SHOW TABLE STATUS "',
6506                                                              '              . ($db ? "FROM `$db`" : "")',
6507                                                              '              . " LIKE \'$tbl\'";',
6508                                                              '      MKDEBUG && _d($sql);',
6509                                                              '      eval {',
6510                                                              '         $engine = $dbh->selectrow_hashref($sql)->{engine};',
6511                                                              '      };',
6512                                                              '      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);',
6513                                                              '      MKDEBUG && _d($tbl, "uses engine", $engine);',
6514                                                              '      $engine = lc $engine if $engine;',
6515                                                           @permit_engs
6516                                                              = _make_filter('unless', '$engine', $o->get('engines'), 1);
6517                                                           @reject_engs
6518           9                                 60               = _make_filter('if', '$engine', $o->get('ignore-engines'), 1)
6519                                                        }
6520                                                  
6521  ***      9     50     33                  384         if ( @permit_tbls || @reject_tbls || @tbls_regex || @reject_tbls_regex
      ***                   33                        
      ***                   33                        
      ***                   33                        
      ***                   33                        
6522                                                             || @permit_engs || @reject_engs ) {
6523  ***      9     50                         243            push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
                    100                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
6524                                                              '   if ( $tbl ) {',
6525                                                                 (@permit_tbls       ? @permit_tbls        : ()),
6526                                                                 (@reject_tbls       ? @reject_tbls        : ()),
6527                                                                 (@tbls_regex        ? @tbls_regex         : ()),
6528                                                                 (@reject_tbls_regex ? @reject_tbls_regex  : ()),
6529                                                                 (@permit_qtbls      ? @permit_qtbls       : ()),
6530                                                                 (@reject_qtbls      ? @reject_qtbls       : ()),
6531                                                                 (@get_eng           ? @get_eng            : ()),
6532                                                                 (@permit_engs       ? @permit_engs        : ()),
6533                                                                 (@reject_engs       ? @reject_engs        : ()),
6534                                                              '   }';
6535                                                        }
6536                                                     }
6537                                                  
6538           9                                 55      push @lines,
6539                                                        '   MKDEBUG && _d(\'Passes filters:\', $db, $tbl, $engine, $dbh);',
6540                                                        '   return 1;',  '}';
6541                                                  
6542           9                                 99      my $code = join("\n", @lines);
6543           9                                 25      MKDEBUG && _d('filter sub:', $code);
6544  ***      9     50                        3033      my $filter_sub= eval $code
6545                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
6546                                                  
6547           9                                108      return $filter_sub;
6548                                                  }
6549                                                  
6550                                                  sub set_filter {
6551           9                    9            51      my ( $self, $filter_sub ) = @_;
6552           9                                 44      $self->{filter} = $filter_sub;
6553           9                                 26      MKDEBUG && _d('Set filter sub');
6554           9                                 34      return;
6555                                                  }
6556                                                  
6557                                                  sub get_db_itr {
6558           9                    9            64      my ( $self, %args ) = @_;
6559           9                                 48      my @required_args = qw(dbh);
6560           9                                 48      foreach my $arg ( @required_args ) {
6561  ***      9     50                          78         die "I need a $arg argument" unless $args{$arg};
6562                                                     }
6563           9                                 49      my ($dbh) = @args{@required_args};
6564                                                  
6565           9                                 41      my $filter = $self->{filter};
6566           9                                 26      my @dbs;
6567           9                                 39      eval {
6568           9                                 37         my $sql = 'SHOW DATABASES';
6569           9                                 26         MKDEBUG && _d($sql);
6570  ***     36     50                         298         @dbs =  grep {
6571           9                                 29            my $ok = $filter ? $filter->($dbh, $_, undef) : 1;
6572          36    100                         320            $ok = 0 if $_ =~ m/information_schema|lost\+found/;
6573          36                                162            $ok;
6574           9                                 38         } @{ $dbh->selectcol_arrayref($sql) };
6575           9                                 46         MKDEBUG && _d('Found', scalar @dbs, 'databases');
6576                                                     };
6577           9                                 27      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
6578                                                     return sub {
6579          18                   18           133         return shift @dbs;
6580           9                                104      };
6581                                                  }
6582                                                  
6583                                                  sub get_tbl_itr {
6584           9                    9            93      my ( $self, %args ) = @_;
6585           9                                 59      my @required_args = qw(dbh db);
6586           9                                 56      foreach my $arg ( @required_args ) {
6587  ***     18     50                         131         die "I need a $arg argument" unless $args{$arg};
6588                                                     }
6589           9                                 68      my ($dbh, $db, $views) = @args{@required_args, 'views'};
6590                                                  
6591           9                                 40      my $filter = $self->{filter};
6592           9                                 28      my @tbls;
6593  ***      9     50                          44      if ( $db ) {
6594           9                                 32         eval {
6595           9                                189            my $sql = 'SHOW /*!50002 FULL*/ TABLES FROM '
6596                                                                   . $self->{Quoter}->quote($db);
6597           9                                 30            MKDEBUG && _d($sql);
6598           9                                 76            @tbls = map {
6599           9                               2658               $_->[0]
6600                                                           }
6601                                                           grep {
6602           9                                 34               my ($tbl, $type) = @$_;
6603  ***      9     50                          89               my $ok = $filter ? $filter->($dbh, $db, $tbl) : 1;
6604  ***      9     50                          58               if ( !$views ) {
6605  ***      9     50     50                   74                  $ok = 0 if ($type || '') eq 'VIEW';
6606                                                              }
6607           9                                 47               $ok;
6608                                                           }
6609           9                                 35            @{ $dbh->selectall_arrayref($sql) };
6610           9                                166            MKDEBUG && _d('Found', scalar @tbls, 'tables in', $db);
6611                                                        };
6612           9                                 35         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
6613                                                     }
6614                                                     else {
6615  ***      0                                  0         MKDEBUG && _d('No db given so no tables');
6616                                                     }
6617                                                     return sub {
6618          18                   18           180         return shift @tbls;
6619           9                                171      };
6620                                                  }
6621                                                  
6622                                                  sub _make_filter {
6623          62                   62           374      my ( $cond, $var_name, $objs, $lc ) = @_;
6624          62                                211      my @lines;
6625          62    100                         378      if ( scalar keys %$objs ) {
6626          29    100                         261         my $test = join(' || ',
6627          20                                116            map { "$var_name eq '" . ($lc ? lc $_ : $_) ."'" } keys %$objs);
6628          20                                165         push @lines, "      return 0 $cond $var_name && ($test);",
6629                                                     }
6630          62                                401      return @lines;
6631                                                  }
6632                                                  
6633                                                  sub _d {
6634  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6635  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6636  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6637                                                          @_;
6638  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6639                                                  }
6640                                                  
6641                                                  1;
6642                                                  
6643                                                  # ###########################################################################
6644                                                  # End SchemaIterator package
6645                                                  # ###########################################################################
6646                                                  
6647                                                  # ###########################################################################
6648                                                  # Transformers package 6387
6649                                                  # This package is a copy without comments from the original.  The original
6650                                                  # with comments and its test file can be found in the SVN repository at,
6651                                                  #   trunk/common/Transformers.pm
6652                                                  #   trunk/common/t/Transformers.t
6653                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
6654                                                  # ###########################################################################
6655                                                  
6656                                                  package Transformers;
6657                                                  
6658          36                   36           276   use strict;
              36                                107   
              36                                204   
6659          36                   36           228   use warnings FATAL => 'all';
              36                                 89   
              36                                208   
6660          36                   36           224   use English qw(-no_match_vars);
              36                                 89   
              36                                188   
6661          36                   36           475   use Time::Local qw(timegm timelocal);
              36                                113   
              36                                383   
6662          36                   36           246   use Digest::MD5 qw(md5_hex);
              36                                 84   
              36                                267   
6663                                                  
6664  ***     36            50     36           220   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 91   
              36                                838   
6665                                                  
6666                                                  require Exporter;
6667                                                  our @ISA         = qw(Exporter);
6668                                                  our %EXPORT_TAGS = ();
6669                                                  our @EXPORT      = ();
6670                                                  our @EXPORT_OK   = qw(
6671                                                     micro_t
6672                                                     percentage_of
6673                                                     secs_to_time
6674                                                     time_to_secs
6675                                                     shorten
6676                                                     ts
6677                                                     parse_timestamp
6678                                                     unix_timestamp
6679                                                     any_unix_timestamp
6680                                                     make_checksum
6681                                                  );
6682                                                  
6683                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
6684                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
6685                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
6686                                                  
6687                                                  sub micro_t {
6688  ***      0                    0             0      my ( $t, %args ) = @_;
6689  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
6690  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
6691  ***      0                                  0      my $f;
6692                                                  
6693  ***      0      0                           0      $t = 0 if $t < 0;
6694                                                  
6695  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
6696                                                  
6697  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
6698                                                  
6699  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
6700  ***      0                                  0         $f = ($t * 1000000) . 'us';
6701                                                     }
6702                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
6703  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
6704  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
6705                                                     }
6706                                                     elsif ($t >= 1) {
6707  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
6708  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
6709                                                     }
6710                                                     else {
6711  ***      0                                  0         $f = 0;  # $t should = 0 at this point
6712                                                     }
6713                                                  
6714  ***      0                                  0      return $f;
6715                                                  }
6716                                                  
6717                                                  sub percentage_of {
6718  ***      0                    0             0      my ( $is, $of, %args ) = @_;
6719  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
6720  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
6721  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
6722                                                  }
6723                                                  
6724                                                  sub secs_to_time {
6725  ***      0                    0             0      my ( $secs, $fmt ) = @_;
6726  ***      0             0                    0      $secs ||= 0;
6727  ***      0      0                           0      return '00:00' unless $secs;
6728                                                  
6729  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
6730                                                            : $secs >= 3_600  ? 'h'
6731                                                            :                   'm';
6732                                                  
6733                                                     return
6734  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
6735                                                           "%d+%02d:%02d:%02d",
6736                                                           int($secs / 86_400),
6737                                                           int(($secs % 86_400) / 3_600),
6738                                                           int(($secs % 3_600) / 60),
6739                                                           $secs % 60)
6740                                                        : $fmt eq 'h' ? sprintf(
6741                                                           "%02d:%02d:%02d",
6742                                                           int(($secs % 86_400) / 3_600),
6743                                                           int(($secs % 3_600) / 60),
6744                                                           $secs % 60)
6745                                                        : sprintf(
6746                                                           "%02d:%02d",
6747                                                           int(($secs % 3_600) / 60),
6748                                                           $secs % 60);
6749                                                  }
6750                                                  
6751                                                  sub time_to_secs {
6752          11                   11            46      my ( $val, $default_suffix ) = @_;
6753  ***     11     50                          50      die "I need a val argument" unless defined $val;
6754          11                                 33      my $t = 0;
6755          11                                120      my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
6756  ***     11            33                   67      $suffix = $suffix || $default_suffix || 's';
      ***                   50                        
6757  ***     11     50                          56      if ( $suffix =~ m/[smhd]/ ) {
6758  ***     11     50                          82         $t = $suffix eq 's' ? $num * 1        # Seconds
                    100                               
      ***            50                               
6759                                                           : $suffix eq 'm' ? $num * 60       # Minutes
6760                                                           : $suffix eq 'h' ? $num * 3600     # Hours
6761                                                           :                  $num * 86400;   # Days
6762                                                  
6763  ***     11     50     33                   63         $t *= -1 if $prefix && $prefix eq '-';
6764                                                     }
6765                                                     else {
6766  ***      0                                  0         die "Invalid suffix for $val: $suffix";
6767                                                     }
6768          11                                 39      return $t;
6769                                                  }
6770                                                  
6771                                                  sub shorten {
6772  ***      0                    0             0      my ( $num, %args ) = @_;
6773  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
6774  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
6775  ***      0                                  0      my $n = 0;
6776  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
6777  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
6778  ***      0                                  0         $num /= $d;
6779  ***      0                                  0         ++$n;
6780                                                     }
6781  ***      0      0      0                    0      return sprintf(
6782                                                        $num =~ m/\./ || $n
6783                                                           ? "%.${p}f%s"
6784                                                           : '%d',
6785                                                        $num, $units[$n]);
6786                                                  }
6787                                                  
6788                                                  sub ts {
6789  ***      0                    0             0      my ( $time, $gmt ) = @_;
6790  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
6791                                                        = $gmt ? gmtime($time) : localtime($time);
6792  ***      0                                  0      $mon  += 1;
6793  ***      0                                  0      $year += 1900;
6794  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
6795                                                        $year, $mon, $mday, $hour, $min, $sec);
6796  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
6797  ***      0                                  0         $us = sprintf("%.6f", $us);
6798  ***      0                                  0         $us =~ s/^0\././;
6799  ***      0                                  0         $val .= $us;
6800                                                     }
6801  ***      0                                  0      return $val;
6802                                                  }
6803                                                  
6804                                                  sub parse_timestamp {
6805  ***      0                    0             0      my ( $val ) = @_;
6806  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
6807                                                           = $val =~ m/^$mysql_ts$/ )
6808                                                     {
6809  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
6810                                                                       . (defined $f ? '%09.6f' : '%02d'),
6811                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
6812                                                     }
6813  ***      0                                  0      return $val;
6814                                                  }
6815                                                  
6816                                                  sub unix_timestamp {
6817          12                   12            40      my ( $val, $gmt ) = @_;
6818  ***     12     50                         162      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
6819  ***     12     50                          73         $val = $gmt
6820                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
6821                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
6822  ***     12     50                          48         if ( defined $us ) {
6823  ***      0                                  0            $us = sprintf('%.6f', $us);
6824  ***      0                                  0            $us =~ s/^0\././;
6825  ***      0                                  0            $val .= $us;
6826                                                        }
6827                                                     }
6828          12                                 57      return $val;
6829                                                  }
6830                                                  
6831                                                  sub any_unix_timestamp {
6832          22                   22            92      my ( $val, $callback ) = @_;
6833                                                  
6834  ***     22     50                         425      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
                    100                               
      ***            50                               
      ***            50                               
6835  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
6836                                                           : $suffix eq 'm' ? $n * 60       # Minutes
6837                                                           : $suffix eq 'h' ? $n * 3600     # Hours
6838                                                           : $suffix eq 'd' ? $n * 86400    # Days
6839                                                           :                  $n;           # default: Seconds
6840  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
6841  ***      0                                  0         return time - $n;
6842                                                     }
6843                                                     elsif ( $val =~ m/^\d{9,}/ ) {
6844          10                                 24         MKDEBUG && _d('ts is already a unix timestamp');
6845          10                                 44         return $val;
6846                                                     }
6847                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
6848  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
6849  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
6850  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
6851                                                     }
6852                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
6853          12                                 29         MKDEBUG && _d('ts is properly formatted timestamp');
6854          12    100                          47         $val .= ' 00:00:00' unless $hms;
6855          12                                 44         return unix_timestamp($val);
6856                                                     }
6857                                                     else {
6858  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
6859  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
6860                                                     }
6861                                                  
6862  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
6863  ***      0                                  0      return;
6864                                                  }
6865                                                  
6866                                                  sub make_checksum {
6867  ***      0                    0             0      my ( $val ) = @_;
6868  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
6869  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
6870  ***      0                                  0      return $checksum;
6871                                                  }
6872                                                  
6873                                                  sub _d {
6874  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6875  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6876  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6877                                                          @_;
6878  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6879                                                  }
6880                                                  
6881                                                  1;
6882                                                  
6883                                                  # ###########################################################################
6884                                                  # End Transformers package
6885                                                  # ###########################################################################
6886                                                  
6887                                                  # ###########################################################################
6888                                                  # This is a combination of modules and programs in one -- a runnable module.
6889                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
6890                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
6891                                                  #
6892                                                  # Check at the end of this package for the call to main() which actually runs
6893                                                  # the program.
6894                                                  # ###########################################################################
6895                                                  package mk_table_sync;
6896                                                  
6897          36                   36           268   use English qw(-no_match_vars);
              36                                 97   
              36                                246   
6898          36                   36           270   use List::Util qw(sum max min);
              36                                 98   
              36                                230   
6899          36                   36           213   use POSIX qw(ceil);
              36                                 96   
              36                                239   
6900                                                  
6901                                                  Transformers->import(qw(time_to_secs any_unix_timestamp));
6902                                                  
6903  ***     36            50     36           229   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              36                                 92   
              36                                562   
6904                                                  
6905                                                  $OUTPUT_AUTOFLUSH = 1;
6906                                                  
6907                                                  my %dsn_for;
6908                                                  
6909                                                  sub main {
6910          26                   26        3278947      @ARGV = @_;  # set global ARGV for this package
6911                                                  
6912                                                     # Reset global vars else tests will have weird results.
6913          26                                269      %dsn_for = ();
6914                                                  
6915                                                     # ########################################################################
6916                                                     # Get configuration information.
6917                                                     # ########################################################################
6918          26                                879      my $o = new OptionParser(
6919                                                        strict      => 0,
6920                                                        prompt      => '[OPTION...] DSN [DSN...]',
6921                                                        description => 'synchronizes data efficiently between MySQL tables.',
6922                                                     );
6923          26                                285      $o->get_specs();
6924          26                                837      $o->get_opts();
6925                                                  
6926          26                                248      my $dp = $o->DSNParser();
6927          26                                192      $dp->prop('set-vars', $o->get('set-vars'));
6928                                                  
6929          26    100    100                  160      if ( $o->get('replicate') || $o->get('sync-to-master') ) {
6930  ***      5     50                          35         $o->set('wait', 60) unless $o->got('wait');
6931                                                     }
6932          26    100                         153      if ( $o->get('wait') ) {
6933  ***      5     50                          30         $o->set('lock', 1) unless $o->got('lock');
6934                                                     }
6935  ***     26     50                         201      if ( $o->get('dry-run') ) {
6936  ***      0                                  0         $o->set('verbose', 1);
6937                                                     }
6938                                                  
6939                                                     # There's a conflict of interests: we added 't' and 'D' parts to dp,
6940                                                     # and there are -t and -D options (--tables, --databases), so parse_options()
6941                                                     # is going to return a DSN with the default values from -t and -D,
6942                                                     # but these are not actually be default dsn vals, they're filters.
6943                                                     # So we have to remove them from $dsn_defaults.
6944          26                                301      my $dsn_defaults = $dp->parse_options($o);
6945          26                                158      $dsn_defaults->{D} = undef;
6946          26                                121      $dsn_defaults->{t} = undef;
6947                                                  
6948          26                                115      my @dsns;
6949          26                                464      while ( my $arg = shift(@ARGV) ) {
6950          51                                436         my $dsn = $dp->parse($arg, $dsns[0], $dsn_defaults);
6951  ***     51     50     66                  671         die "You specified a t part, but not a D part in $arg"
6952                                                           if ($dsn->{t} && !$dsn->{D});
6953  ***     51     50     66                  560         if ( $dsn->{D} && !$dsn->{t} ) {
6954  ***      0                                  0            die "You specified a database but not a table in $arg.  Are you "
6955                                                              . "trying to sync only tables in the '$dsn->{D}' database?  "
6956                                                              . "If so, use '--databases $dsn->{D}' instead.\n";
6957                                                        }
6958          51                                514         push @dsns, $dsn;
6959                                                     }
6960                                                  
6961  ***     26     50    100                  661      if ( !@dsns
      ***                   66                        
      ***                   33                        
6962                                                          || (@dsns ==1 && !$o->get('replicate') && !$o->get('sync-to-master'))) {
6963  ***      0                                  0         $o->save_error('At least one DSN is required, and at least two are '
6964                                                           . 'required unless --sync-to-master or --replicate is specified');
6965                                                     }
6966                                                  
6967  ***     26     50     66                  294      if ( @dsns > 1 && $o->get('sync-to-master') && $o->get('replicate') ) {
      ***                   33                        
6968  ***      0                                  0         $o->save_error('--sync-to-master and --replicate require only one DSN ',
6969                                                           ' but ', scalar @dsns, ' where given');
6970                                                     }
6971                                                  
6972  ***     26     50                         161      if ( $o->get('lock-and-rename') ) {
6973  ***      0      0      0                    0         if ( @dsns != 2 || !$dsns[0]->{t} || !$dsns[1]->{t} ) {
      ***                    0                        
6974  ***      0                                  0            $o->save_error("--lock-and-rename requires exactly two DSNs and they "
6975                                                              . "must each specify a table.");
6976                                                        }
6977                                                     }
6978                                                  
6979          26    100                         155      if ( $o->get('bidirectional') ) {
6980  ***      5     50     33                   30         if ( $o->get('replicate') || $o->get('sync-to-master') ) {
6981  ***      0                                  0            $o->save_error('--bidirectional does not work with '
6982                                                              . '--replicate or --sync-to-master');
6983                                                        }
6984  ***      5     50                          35         if ( @dsns < 2 ) {
6985  ***      0                                  0            $o->save_error('--bidirectional requires at least two DSNs');
6986                                                        }
6987  ***      5     50     33                   35         if ( !$o->get('conflict-column') || !$o->get('conflict-comparison') ) {
6988  ***      0                                  0            $o->save_error('--bidirectional requires --conflict-column '
6989                                                              . 'and --conflict-comparison');
6990                                                        }
6991           5                                 40         my $cc  = $o->get('conflict-comparison');
6992           5                                109         my $cmp = $o->read_para_after(__FILE__, qr/MAGIC_comparisons/);
6993           5                                120         $cmp    =~ s/ //g;
6994  ***      5     50     33                  174         if ( $cc && $cc !~ m/$cmp/ ) {
6995  ***      0                                  0            $o->save_error("--conflict-comparison must be one of $cmp");
6996                                                        }
6997  ***      5     50     33                   69         if ( $cc && $cc =~ m/equals|matches/ && !$o->get('conflict-value') ) {
      ***                   33                        
6998  ***      0                                  0            $o->save_error("--conflict-comparison $cc requires --conflict-value")
6999                                                        }
7000                                                  
7001                                                        # Override --algorithms becuase only TableSyncChunk works with
7002                                                        # bidirectional syncing.
7003           5                                 67         $o->set('algorithms', 'Chunk');
7004           5                                 27         $o->set('buffer-to-client', 0);
7005                                                     }
7006                                                  
7007  ***     26     50                         152      if ( $o->get('explain-hosts') ) {
7008  ***      0                                  0         foreach my $host ( @dsns ) {
7009  ***      0                                  0            print "# DSN: ", $dp->as_string($host), "\n";
7010                                                        }
7011  ***      0                                  0         return 0;
7012                                                     }
7013                                                  
7014          26                                237      $o->usage_or_errors();
7015                                                  
7016                                                     # ########################################################################
7017                                                     # If --pid, check it first since we'll die if it already exits.
7018                                                     # ########################################################################
7019          26                                 82      my $daemon;
7020  ***     26     50                         155      if ( $o->get('pid') ) {
7021                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
7022                                                        # in the the scope of main() because when it's destroyed it automatically
7023                                                        # removes the PID file.
7024  ***      0                                  0         $daemon = new Daemon(o=>$o);
7025  ***      0                                  0         $daemon->make_PID_file();
7026                                                     }
7027                                                  
7028                                                     # ########################################################################
7029                                                     # Do the work.
7030                                                     # ########################################################################
7031          26                                426      my $q         = new Quoter();
7032          26                                540      my $tp        = new TableParser( Quoter => $q );
7033          26                                426      my $vp        = new VersionParser();
7034          26                                465      my $ms        = new MasterSlave(VersionParser => $vp);
7035          26                                498      my $du        = new MySQLDump( cache => 0 );
7036          26                                467      my $chunker   = new TableChunker( Quoter => $q, MySQLDump => $du );
7037          26                                516      my $nibbler   = new TableNibbler( Quoter => $q, TableParser => $tp );
7038          26                                480      my $checksum  = new TableChecksum( Quoter => $q, VersionParser => $vp );
7039          26                                457      my $syncer    = new TableSyncer(
7040                                                        Quoter        => $q,
7041                                                        VersionParser => $vp,
7042                                                        MasterSlave   => $ms,
7043                                                        TableChecksum => $checksum,
7044                                                     );
7045          26                                398      my %modules = (
7046                                                        OptionParser   => $o,
7047                                                        DSNParser      => $dp,
7048                                                        MySQLDump      => $du,
7049                                                        TableParser    => $tp,
7050                                                        Quoter         => $q,
7051                                                        VersionParser  => $vp,
7052                                                        TableChunker   => $chunker,
7053                                                        TableNibbler   => $nibbler,
7054                                                        TableChecksum  => $checksum,
7055                                                        MasterSlave    => $ms,
7056                                                        TableSyncer    => $syncer,
7057                                                     );
7058                                                  
7059                                                     # Create the sync plugins.
7060          26                                126      my $plugins = [];
7061          26                                182      foreach my $plugin_name ( split(',', $o->get('algorithms')) ) {
7062          66                                327         $plugin_name = "TableSync$plugin_name";
7063          66                                200         MKDEBUG && _d('Loading', $plugin_name);
7064          66                                206         my $plugin;
7065          66                                227         eval {
7066          66                               1371            $plugin = $plugin_name->new(%modules);
7067                                                        };
7068  ***     66     50                         420         die "Cannot load $plugin_name for --algorithm: $EVAL_ERROR"
7069                                                           if $EVAL_ERROR;
7070          66                                369         push @$plugins, $plugin;
7071                                                     }
7072                                                  
7073                                                     # Create callbacks for bidirectional syncing.  Currently, this only
7074                                                     # works with TableSyncChunk, so that should be the only plugin because
7075                                                     # --algorithms was overriden earlier.
7076          26    100                         171      if ( $o->get('bidirectional') ) {
7077           5                                 69         set_bidirectional_callbacks(
7078                                                           plugin => $plugins->[0],
7079                                                           %modules,
7080                                                        );
7081                                                     }
7082                                                  
7083          26                                122      my $hdr         = "# %6s %7s %6s %6s %-9s %-4s %s.%s\n";
7084          26                                101      my $exit_status = 0; # 1: internal error, 2: tables differed, 3: both
7085                                                  
7086                                                     # dsn[0] is expected to be the master (i.e. the source).  So if
7087                                                     # --sync-to-master, then dsn[0] is a slave.  Find its master and
7088                                                     # make the master dsn[0] and the slave dsn[1].
7089          26    100                         155      if ( $o->get('sync-to-master') ) {
7090           5                                 15         MKDEBUG && _d('Getting master of', $dp->as_string($dsns[0]));
7091           5                                 88         $dsns[0]->{dbh} = get_cxn($dsns[0], %modules);
7092  ***      5     50                          82         my $master = $ms->get_master_dsn($dsns[0]->{dbh}, $dsns[0], $dp)
7093                                                           or die "Can't determine master of " . $dp->as_string($dsns[0]);
7094           5                                 22         unshift @dsns, $master;  # dsn[0]=master, dsn[1]=slave
7095           5                                 52         $dsns[0]->{dbh} = get_cxn($dsns[0], %modules);
7096  ***      5     50                          39         if ( $o->get('check-master') ) {
7097           5                                 77            $ms->is_master_of($dsns[0]->{dbh}, $dsns[1]->{dbh});
7098                                                        }
7099                                                     }
7100                                                  
7101          26                                428      my %args = (
7102                                                        dsns    => \@dsns,
7103                                                        plugins => $plugins,
7104                                                        hdr     => $hdr,
7105                                                        %modules,
7106                                                     );
7107                                                  
7108  ***     26     50                         192      if ( $o->get('dry-run') ) {
7109  ***      0                                  0         print "# NOTE: --dry-run does not show if data needs to be synced because it\n"
7110                                                           .  "#       does not access, compare or sync data.  --dry-run only shows\n"
7111                                                           .  "#       the work that would be done.\n";
7112                                                  
7113                                                     }
7114                                                  
7115  ***     26     50                         145      if ( $o->get('lock-and-rename') ) {
                    100                               
                    100                               
7116  ***      0                                  0         $exit_status = lock_and_rename(%args);
7117                                                     }
7118                                                     elsif ( $dsns[0]->{t} ) {
7119          14                                227         $exit_status = sync_one_table(%args);
7120                                                     }
7121                                                     elsif ( $o->get('replicate') ) {
7122           3                                 40         $exit_status = sync_via_replication(%args);
7123                                                     }
7124                                                     else {
7125           9                                133         $exit_status = sync_all(%args);
7126                                                     }
7127                                                  
7128          26                              12983      return $exit_status;
7129                                                  }
7130                                                  
7131                                                  # ############################################################################
7132                                                  # Subroutines
7133                                                  # ############################################################################
7134                                                  
7135                                                  sub lock_and_rename {
7136  ***      0                    0             0      my ( %args ) = @_;
7137  ***      0                                  0      my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
7138                                                                            VersionParser);
7139  ***      0                                  0      foreach my $arg ( @required_args ) {
7140  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
7141                                                     }
7142  ***      0                                  0      my $dsns = $args{dsns};
7143  ***      0                                  0      my $o    = $args{OptionParser};
7144  ***      0                                  0      my $dp   = $args{DSNParser};
7145  ***      0                                  0      my $q    = $args{Quoter};
7146                                                  
7147  ***      0                                  0      MKDEBUG && _d('Locking and syncing ONE TABLE with rename');
7148  ***      0             0                    0      my $src = {
7149                                                        dsn      => $dsns->[0],
7150                                                        dbh      => $dsns->[0]->{dbh} || get_cxn($dsns->[0], %args),
7151                                                        misc_dbh => get_cxn($dsns->[0], %args),
7152                                                        db       => $dsns->[0]->{D},
7153                                                        tbl      => $dsns->[0]->{t},
7154                                                     };
7155  ***      0             0                    0      my $dst = {
7156                                                        dsn      => $dsns->[1],
7157                                                        dbh      => $dsns->[1]->{dbh} || get_cxn($dsns->[1], %args),
7158                                                        misc_dbh => get_cxn($dsns->[1], %args),
7159                                                        db       => $dsns->[1]->{D},
7160                                                        tbl      => $dsns->[1]->{t},
7161                                                     };
7162                                                  
7163  ***      0      0                           0      if ( $o->get('verbose') ) {
7164  ***      0                                  0         print "# Lock and rename ", $dp->as_string($src->{dsn}), "\n";
7165  ***      0                                  0         printf $args{hdr}, @ChangeHandler::ACTIONS,
7166                                                           qw(ALGORITHM EXIT DATABASE TABLE);
7167                                                     }
7168                                                  
7169                                                     # We don't use lock_server() here because it does the usual stuff wrt
7170                                                     # waiting for slaves to catch up to master, etc, etc.
7171  ***      0                                  0      my $src_db_tbl = $q->quote($src->{db}, $src->{tbl});
7172  ***      0                                  0      my $dst_db_tbl = $q->quote($dst->{db}, $dst->{tbl});
7173  ***      0                                  0      my $tmp_db_tbl = $q->quote($src->{db}, $src->{tbl} . "_tmp_$PID");
7174  ***      0                                  0      my $sql = "LOCK TABLES $src_db_tbl WRITE";
7175  ***      0                                  0      MKDEBUG && _d($sql);
7176  ***      0                                  0      $src->{dbh}->do($sql);
7177  ***      0                                  0      $sql = "LOCK TABLES $dst_db_tbl WRITE";
7178  ***      0                                  0      MKDEBUG && _d($sql);
7179  ***      0                                  0      $dst->{dbh}->do($sql);
7180                                                  
7181  ***      0                                  0      my $exit_status = sync_a_table(
7182                                                        src  => $src,
7183                                                        dst  => $dst,
7184                                                        %args,
7185                                                     );
7186                                                  
7187                                                     # Now rename the tables to swap them.
7188  ***      0                                  0      $sql = "ALTER TABLE $src_db_tbl RENAME $tmp_db_tbl";
7189  ***      0                                  0      MKDEBUG && _d($sql);
7190  ***      0                                  0      $src->{dbh}->do($sql);
7191  ***      0                                  0      $sql = "ALTER TABLE $dst_db_tbl RENAME $src_db_tbl";
7192  ***      0                                  0      MKDEBUG && _d($sql);
7193  ***      0                                  0      $dst->{dbh}->do($sql);
7194  ***      0                                  0      $sql = "UNLOCK TABLES";
7195  ***      0                                  0      MKDEBUG && _d($sql);
7196  ***      0                                  0      $src->{dbh}->do($sql);
7197  ***      0                                  0      $sql = "ALTER TABLE $tmp_db_tbl RENAME $dst_db_tbl";
7198  ***      0                                  0      MKDEBUG && _d($sql);
7199  ***      0                                  0      $src->{dbh}->do($sql);
7200                                                  
7201  ***      0                                  0      unlock_server(src => $src, dst => $dst, %args);
7202                                                  
7203  ***      0                                  0      disconnect($src, $dst);
7204  ***      0                                  0      return $exit_status;
7205                                                  }
7206                                                  
7207                                                  sub sync_one_table {
7208          14                   14           221      my ( %args ) = @_;
7209          14                                214      my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
7210                                                                            VersionParser);
7211          14                                105      foreach my $arg ( @required_args ) {
7212  ***     98     50                         601         die "I need a $arg argument" unless $args{$arg};
7213                                                     }
7214          14                                 60      my @dsns = @{$args{dsns}};
              14                                 99   
7215          14                                 82      my $o    = $args{OptionParser};
7216          14                                 60      my $dp   = $args{DSNParser};
7217                                                  
7218          14                                 43      MKDEBUG && _d('DSN has t part; syncing ONE TABLE between servers');
7219  ***     14            33                  361      my $src = {
7220                                                        dsn      => $dsns[0],
7221                                                        dbh      => $dsns[0]->{dbh} || get_cxn($dsns[0], %args),
7222                                                        misc_dbh => get_cxn($dsns[0], %args),
7223                                                        db       => $dsns[0]->{D},
7224                                                        tbl      => $dsns[0]->{t},
7225                                                     };
7226                                                  
7227          14                                122      my $exit_status = 0;
7228          14                                200      foreach my $dsn ( @dsns[1 .. $#dsns] ) {
7229  ***     16            33                  335         my $dst = {
      ***                   33                        
      ***                   33                        
7230                                                           dsn      => $dsn,
7231                                                           dbh      => $dsn->{dbh} || get_cxn($dsn, %args),
7232                                                           misc_dbh => get_cxn($dsn, %args),
7233                                                           db       => $dsn->{D} || $src->{db},
7234                                                           tbl      => $dsn->{t} || $src->{tbl},
7235                                                        };
7236                                                  
7237          16    100                         169         if ( $o->get('verbose') ) {
7238  ***      6     50                          47            print "# Syncing ", $dp->as_string($dsn),
7239                                                              ($o->get('dry-run') ? ' in dry-run mode, without accessing or '
7240                                                                 . 'comparing data' : '') , "\n";
7241           6                                109            printf $args{hdr}, @ChangeHandler::ACTIONS,
7242                                                              qw(ALGORITHM EXIT DATABASE TABLE);
7243                                                        }
7244                                                  
7245          16                                259         lock_server(src => $src, dst => $dst, %args);
7246                                                  
7247          16                                194         $exit_status |= sync_a_table(
7248                                                           src   => $src,
7249                                                           dst   => $dst,
7250                                                           %args,
7251                                                        );
7252                                                  
7253          16                               1199         unlock_server(src => $src, dst => $dst, %args);
7254          16                                158         disconnect($dst);
7255                                                     }
7256                                                  
7257          14                                119      disconnect($src);
7258          14                               1410      return $exit_status;
7259                                                  }
7260                                                  
7261                                                  sub sync_via_replication {
7262           3                    3            44      my ( %args ) = @_;
7263           3                                 24      my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
7264                                                                            VersionParser TableChecksum MasterSlave);
7265           3                                 20      foreach my $arg ( @required_args ) {
7266  ***     27     50                         115         die "I need a $arg argument" unless $args{$arg};
7267                                                     }
7268           3                                 25      my $dsns     = $args{dsns};
7269           3                                 11      my $o        = $args{OptionParser};
7270           3                                 10      my $dp       = $args{DSNParser};
7271           3                                 11      my $q        = $args{Quoter};
7272           3                                  8      my $checksum = $args{TableChecksum};
7273           3                                  9      my $ms       = $args{MasterSlave};
7274                                                  
7275           3                                  9      MKDEBUG && _d('Syncing via replication');
7276  ***      3            33                   38      my $src = {
7277                                                        dsn      => $dsns->[0],
7278                                                        dbh      => $dsns->[0]->{dbh} || get_cxn($dsns->[0], %args),
7279                                                        misc_dbh => get_cxn($dsns->[0], %args),
7280                                                        db       => undef,  # set later
7281                                                        tbl      => undef,  # set later
7282                                                     };
7283                                                  
7284                                                     # Filters for --databases and --tables.  We have to do these manually
7285                                                     # since we don't use MySQLFind for --replicate.
7286           3                                 20      my $databases = $o->get('databases');
7287           3                                 15      my $tables    = $o->get('tables');
7288                                                  
7289           3                                 10      my $exit_status = 0;
7290                                                  
7291                                                     # Connect to the master and treat it as the source, then find
7292                                                     # differences on the slave and sync them.
7293  ***      3     50                          18      if ( $o->get('sync-to-master') ) {
7294  ***      3            33                   40         my $dst = {
7295                                                           dsn      => $dsns->[1],
7296                                                           dbh      => $dsns->[1]->{dbh} || get_cxn($dsns->[1], %args),
7297                                                           misc_dbh => get_cxn($dsns->[1], %args),
7298                                                           db       => undef,  # set later
7299                                                           tbl      => undef,  # set later
7300                                                        };
7301                                                  
7302                                                        # First, check that the master (source) has no discrepancies itself,
7303                                                        # and ignore tables that do.
7304           3                                 24         my %skip_table;
7305           3                                 19         map { $skip_table{$_->{db}}->{$_->{tbl}}++ }
      ***      0                                  0   
7306                                                           $checksum->find_replication_differences(
7307                                                              $src->{dbh}, $o->get('replicate'));
7308                                                  
7309                                                        # Now check the slave for differences and sync them if necessary.
7310           3                                 25         my @diffs =  filter_diffs(
7311                                                           \%skip_table,
7312                                                           $databases,
7313                                                           $tables,
7314                                                           $checksum->find_replication_differences(
7315                                                              $dst->{dbh}, $o->get('replicate'))
7316                                                        );
7317                                                  
7318           3    100                          17         if ( $o->get('verbose') ) {
7319  ***      2     50                          20            print "# Syncing via replication ", $dp->as_string($dst->{dsn}),
7320                                                              ($o->get('dry-run') ? ' in dry-run mode, without accessing or '
7321                                                                 . 'comparing data' : '') , "\n";
7322           2                                 40            printf $args{hdr}, @ChangeHandler::ACTIONS,
7323                                                              qw(ALGORITHM EXIT DATABASE TABLE);
7324                                                        }
7325                                                  
7326  ***      3     50                          15         if ( @diffs ) {
7327           3                                 45            lock_server(src => $src, dst => $dst, %args);
7328                                                  
7329           3                                 16            foreach my $diff ( @diffs ) {
7330           4                                 24               $src->{db}  = $dst->{db}  = $diff->{db};
7331           4                                 22               $src->{tbl} = $dst->{tbl} = $diff->{tbl};
7332                                                  
7333           4                                 49               $exit_status |= sync_a_table(
7334                                                                 src   => $src,
7335                                                                 dst   => $dst,
7336                                                                 where => $diff->{boundaries},
7337                                                                 %args,
7338                                                              );
7339                                                           }
7340                                                  
7341           3                                 38            unlock_server(src => $src, dst => $dst, %args);
7342                                                        }
7343                                                        else {
7344  ***      0                                  0            MKDEBUG && _d('No checksum differences');
7345                                                        }
7346                                                  
7347           3                                 22         disconnect($dst);
7348                                                     } # sync-to-master
7349                                                  
7350                                                     # The DSN is the master.  Connect to each slave, find differences,
7351                                                     # then sync them.
7352                                                     else {
7353  ***      0                                  0         my %skip_table;
7354                                                        $ms->recurse_to_slaves(
7355                                                           {  dbh        => $src->{dbh},
7356                                                              dsn        => $src->{dsn},
7357                                                              dsn_parser => $dp,
7358                                                              recurse    => 1,
7359                                                              callback   => sub {
7360  ***      0                    0             0                  my ( $dsn, $dbh, $level, $parent ) = @_;
7361  ***      0                                  0                  my @diffs = $checksum
7362                                                                    ->find_replication_differences($dbh, $o->get('replicate'));
7363  ***      0      0                           0                  if ( !$level ) {
7364                                                                    # This is the master; don't sync any tables that are wrong
7365                                                                    # here, for obvious reasons.
7366  ***      0                                  0                     map { $skip_table{$_->{db}}->{$_->{tbl}}++ } @diffs;
      ***      0                                  0   
7367                                                                 }
7368                                                                 else {
7369                                                                    # This is a slave.
7370  ***      0                                  0                     @diffs = filter_diffs(
7371                                                                       \%skip_table,
7372                                                                       $databases,
7373                                                                       $tables,
7374                                                                       @diffs
7375                                                                    );
7376                                                  
7377  ***      0      0                           0                     if ( $o->get('verbose') ) {
7378  ***      0      0                           0                        print "# Syncing via replication ", $dp->as_string($dsn),
7379                                                                          ($o->get('dry-run') ? ' in dry-run mode, without '
7380                                                                             . 'accessing or comparing data' : '') , "\n";
7381  ***      0                                  0                        printf $args{hdr}, @ChangeHandler::ACTIONS,
7382                                                                          qw(ALGORITHM EXIT DATABASE TABLE);
7383                                                                    }
7384                                                  
7385  ***      0      0                           0                     if ( @diffs ) {
7386  ***      0                                  0                        my $dst = {
7387                                                                          dsn      => $dsn,
7388                                                                          dbh      => $dbh,
7389                                                                          misc_dbh => get_cxn($dsn, %args),
7390                                                                          db       => undef,  # set later
7391                                                                          tbl      => undef,  # set later
7392                                                                       };
7393                                                  
7394  ***      0                                  0                        lock_server(src => $src, dst => $dst, %args);
7395                                                  
7396  ***      0                                  0                        foreach my $diff ( @diffs ) {
7397  ***      0                                  0                           $src->{db}  = $dst->{db}  = $diff->{db};
7398  ***      0                                  0                           $src->{tbl} = $dst->{tbl} = $diff->{tbl};
7399                                                  
7400  ***      0                                  0                           $exit_status |= sync_a_table(
7401                                                                             src   => $src,
7402                                                                             dst   => $dst,
7403                                                                             where => $diff->{boundaries},
7404                                                                             %args,
7405                                                                          );
7406                                                                       } 
7407                                                  
7408  ***      0                                  0                        unlock_server(src => $src, dst => $dst, %args);
7409  ***      0                                  0                        disconnect($dst);
7410                                                                    }
7411                                                                    else {
7412  ***      0                                  0                        MKDEBUG && _d('No checksum differences');
7413                                                                    }
7414                                                                 }  # this is a slave
7415                                                  
7416  ***      0                                  0                  return;
7417                                                              },  # recurse_to_slaves() callback
7418  ***      0                                  0               method => $o->get('recursion-method'),
7419                                                           },
7420                                                        );
7421                                                     } # DSN is master
7422                                                  
7423           3                                 16      disconnect($src);
7424           3                                 48      return $exit_status;
7425                                                  }
7426                                                  
7427                                                  sub sync_all {
7428           9                    9           125      my ( %args ) = @_;
7429           9                                100      my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
7430                                                                            VersionParser TableParser MySQLDump);
7431           9                                 59      foreach my $arg ( @required_args ) {
7432  ***     81     50                         464         die "I need a $arg argument" unless $args{$arg};
7433                                                     }
7434           9                                 77      my @dsns = @{$args{dsns}};
               9                                 64   
7435           9                                 50      my $o    = $args{OptionParser};
7436           9                                 35      my $dp   = $args{DSNParser};
7437                                                  
7438           9                                 27      MKDEBUG && _d('Syncing all dbs and tbls');
7439  ***      9            66                  188      my $src = {
7440                                                        dsn      => $dsns[0],
7441                                                        dbh      => $dsns[0]->{dbh} || get_cxn($dsns[0], %args),
7442                                                        misc_dbh => get_cxn($dsns[0], %args),
7443                                                        db       => undef,  # set later
7444                                                        tbl      => undef,  # set later
7445                                                     };
7446                                                  
7447           9                                258      my $si = new SchemaIterator(
7448                                                        Quoter => $args{Quoter},
7449                                                     );
7450           9                                 95      $si->set_filter($si->make_filter($o));
7451                                                  
7452                                                     # Make a list of all dbs.tbls on the source.  It's more efficient this
7453                                                     # way because it avoids open/closing a dbh for each tbl and dsn, unless
7454                                                     # we pre-opened the dsn.  It would also cause confusing verbose output.
7455           9                                 33      my @dbs_tbls;
7456           9                                 78      my $next_db = $si->get_db_itr(dbh => $src->{dbh});
7457           9                                 50      while ( my $db = $next_db->() ) {
7458           9                                 37         MKDEBUG && _d('Getting tables from', $db);
7459           9                                 99         my $next_tbl = $si->get_tbl_itr(
7460                                                           dbh   => $src->{dbh},
7461                                                           db    => $db,
7462                                                           views => 0,
7463                                                        );
7464           9                                 54         while ( my $tbl = $next_tbl->() ) {
7465           9                                 34            MKDEBUG && _d('Got table', $tbl);
7466           9                                 92            push @dbs_tbls, { db => $db, tbl => $tbl };
7467                                                        }
7468                                                     }
7469                                                  
7470           9                                 36      my $exit_status = 0;
7471           9                                114      foreach my $dsn ( @dsns[1 .. $#dsns] ) {
7472  ***     11     50                          92         if ( $o->get('verbose') ) {
7473  ***      0      0                           0            print "# Syncing ", $dp->as_string($dsn),
7474                                                              ($o->get('dry-run') ? ' in dry-run mode, without accessing or '
7475                                                                 . 'comparing data' : '') , "\n";
7476  ***      0                                  0            printf $args{hdr}, @ChangeHandler::ACTIONS,
7477                                                              qw(ALGORITHM EXIT DATABASE TABLE);
7478                                                        }
7479                                                  
7480  ***     11            66                  219         my $dst = {
7481                                                           dsn      => $dsn,
7482                                                           dbh      => $dsn->{dbh} || get_cxn($dsn, %args),
7483                                                           misc_dbh => get_cxn($dsn, %args),
7484                                                           db       => undef,  # set later
7485                                                           tbl      => undef,  # set later
7486                                                        };
7487                                                  
7488          11                                208         lock_server(src => $src, dst => $dst, %args);
7489                                                  
7490          11                                 71         foreach my $db_tbl ( @dbs_tbls ) {
7491          11                                 89            $src->{db}  = $dst->{db}  = $db_tbl->{db};
7492          11                                 77            $src->{tbl} = $dst->{tbl} = $db_tbl->{tbl};
7493                                                  
7494          11                                264            $exit_status |= sync_a_table(
7495                                                              src => $src,
7496                                                              dst => $dst,
7497                                                              %args,
7498                                                           );
7499                                                        }
7500                                                  
7501          11                                225         unlock_server(src => $src, dst => $dst, %args);
7502          11                                111         disconnect($dst);
7503                                                     }
7504                                                  
7505           9                                 74      disconnect($src);
7506           9                               1291      return $exit_status;
7507                                                  }
7508                                                  
7509                                                  sub lock_server {
7510          30                   30           582      my ( %args ) = @_;
7511          30                                283      foreach my $arg ( qw(src dst OptionParser DSNParser TableSyncer) ) {
7512  ***    150     50                         873         die "I need a $arg argument" unless $args{$arg};
7513                                                     }
7514          30                                141      my $o = $args{OptionParser};
7515                                                  
7516  ***     30     50     66                  156      return unless $o->get('lock') && $o->get('lock') == 3;
7517                                                  
7518  ***      0                                  0      eval {
7519  ***      0                                  0         $args{TableSyncer}->lock_and_wait(
7520                                                           %args,
7521                                                           lock         => 3,
7522                                                           lock_level   => 3,
7523                                                           replicate    => $o->get('replicate'),
7524                                                           timeout_ok   => $o->get('timeout-ok'),
7525                                                           transaction  => $o->get('transaction'),
7526                                                           wait         => $o->get('wait'),
7527                                                        );
7528                                                     };
7529  ***      0      0                           0      if ( $EVAL_ERROR ) {
7530  ***      0                                  0         die "Failed to lock server: $EVAL_ERROR";
7531                                                     }
7532  ***      0                                  0      return;
7533                                                  }
7534                                                  
7535                                                  sub unlock_server {
7536          30                   30           423      my ( %args ) = @_;
7537          30                                295      my @required_args = qw(src dst OptionParser DSNParser TableSyncer);
7538          30                                182      foreach my $arg ( @required_args ) {
7539  ***    150     50                         865         die "I need a $arg argument" unless $args{$arg};
7540                                                     }
7541          30                                205      my ($src, $dst, $o) = @args{@required_args};
7542                                                  
7543  ***     30     50     66                  174      return unless $o->get('lock') && $o->get('lock') == 3;
7544                                                  
7545  ***      0                                  0      eval {
7546                                                        # Open connections as needed.
7547  ***      0             0                    0         $src->{dbh}      ||= get_cxn($src->{dsn}, %args);
7548  ***      0             0                    0         $dst->{dbh}      ||= get_cxn($dst->{dsn}, %args);
7549  ***      0             0                    0         $src->{misc_dbh} ||= get_cxn($src->{dsn}, %args);
7550  ***      0             0                    0         $args{TableSyncer}->unlock(
      ***                    0                        
      ***                    0                        
      ***                    0                        
7551                                                           src_dbh      => $src->{dbh},
7552                                                           src_db       => '',
7553                                                           src_tbl      => '',
7554                                                           dst_dbh      => $dst->{dbh},
7555                                                           dst_db       => '',
7556                                                           dst_tbl      => '',
7557                                                           misc_dbh     => $src->{misc_dbh},
7558                                                           replicate    => $o->get('replicate')   || 0,
7559                                                           timeout_ok   => $o->get('timeout-ok')  || 0,
7560                                                           transaction  => $o->get('transaction') || 0,
7561                                                           wait         => $o->get('wait')        || 0,
7562                                                           lock         => 3,
7563                                                           lock_level   => 3,
7564                                                        );
7565                                                     };
7566  ***      0      0                           0      if ( $EVAL_ERROR ) {
7567  ***      0                                  0         die "Failed to unlock server: $EVAL_ERROR";
7568                                                     }
7569  ***      0                                  0      return;
7570                                                  }
7571                                                  
7572                                                  # This is the primary subroutine which actually makes the table syncs
7573                                                  # happen by calling $syncer->sync_table().  It is, therefore, a big
7574                                                  # wrapper around $syncer->sync_table(); it does pre- and post-sync
7575                                                  # stuff.  It returns an exit status; see EXIT STATUS in the POD.
7576                                                  sub sync_a_table {
7577          31                   31           446      my ( %args ) = @_;
7578          31                                316      my @required_args = qw(src dst plugins OptionParser Quoter TableParser
7579                                                                            MySQLDump TableSyncer);
7580          31                                187      foreach my $arg ( @required_args ) {
7581  ***    248     50                        1350         die "I need a $arg argument" unless $args{$arg};
7582                                                     }
7583          31                                278      my ($src, $dst, undef, $o, $q, $tp, $du, $syncer) = @args{@required_args};
7584                                                  
7585          31                                104      my $exit_status = 0; 
7586          31                                116      my %status;
7587          31                                116      eval {
7588                                                        # This will either die if there's a problem or return the tbl struct.
7589          31                                366         my $tbl_struct = ok_to_sync($src, $dst, %args);
7590                                                  
7591                                                        # If the table is InnoDB, prefer to sync it with transactions, unless
7592                                                        # the user explicitly said not to.
7593          30    100                         324         my $use_txn = $o->got('transaction')            ? $o->get('transaction')
      ***            50                               
7594                                                                    : $tbl_struct->{engine} eq 'InnoDB' ? 1
7595                                                                    :                                     0;
7596                                                  
7597                                                        # Turn off AutoCommit if we're using transactions.
7598          30                               1534         $src->{dbh}->{AutoCommit}      = !$use_txn;
7599          30                               1249         $src->{misc_dbh}->{AutoCommit} = !$use_txn;
7600          30                               1124         $dst->{dbh}->{AutoCommit}      = !$use_txn;
7601          30                               1109         $dst->{misc_dbh}->{AutoCommit} = !$use_txn;
7602                                                  
7603                                                        # Determine which columns to compare.
7604          30                                271         my $ignore_columns  = $o->get('ignore-columns');
7605          75                                505         my @compare_columns = grep {
7606  ***     30     50                         172            !$ignore_columns->{lc $_};
7607          30                                126         } @{$o->get('columns') || $tbl_struct->{cols}};
7608                                                  
7609                                                        # Make sure conflict col is in compare cols else conflicting
7610                                                        # rows won't have the col for --conflict-comparison.
7611          30    100                         198         if ( my $conflict_col = $o->get('conflict-column') ) {
7612          28                                129            push @compare_columns, $conflict_col
7613  ***      7     50                          30               unless grep { $_ eq $conflict_col } @compare_columns;
7614                                                        }
7615                                                  
7616                                                        # --print --verbose --verbose is the magic formula for having
7617                                                        # all src/dst sql printed so we can see the chunk/row sql.
7618          30                                 96         my $callback;
7619  ***     30    100     66                  157         if ( $o->get('print') && $o->get('verbose') >= 2 ) {
7620           3                                 19            $callback = \&print_sql;
7621                                                        }
7622                                                  
7623                                                        # get_change_dbh() may die if, for example, the destination is
7624                                                        # not a slave.  Perhaps its work should be part of can_sync()?
7625          30                                476         my $change_dbh = get_change_dbh(tbl_struct => $tbl_struct, %args);
7626          28                                355         my $actions    = make_action_subs(change_dbh => $change_dbh, %args);
7627                                                  
7628          28                                668         my $rd = new RowDiff(dbh => $src->{misc_dbh});
7629  ***     28    100     66                  410         my $ch = new ChangeHandler(
                           100                        
                           100                        
7630                                                           left_db    => $src->{db},
7631                                                           left_tbl   => $src->{tbl},
7632                                                           right_db   => $dst->{db},
7633                                                           right_tbl  => $dst->{tbl}, 
7634                                                           tbl_struct => $tbl_struct,
7635                                                           hex_blob   => $o->get('hex-blob'),
7636                                                           queue      => $o->get('buffer-to-client') ? 1 : 0,
7637                                                           replace    => $o->get('replace')
7638                                                                         || $o->get('replicate')
7639                                                                         || $o->get('sync-to-master')
7640                                                                         || 0,
7641                                                           actions    => $actions,
7642                                                           Quoter     => $args{Quoter},
7643                                                        );
7644                                                  
7645  ***     28            66                  323         %status = $syncer->sync_table(
                           100                        
                           100                        
                           100                        
7646                                                           %args,
7647                                                           tbl_struct        => $tbl_struct,
7648                                                           cols              => \@compare_columns,
7649                                                           chunk_size        => $o->get('chunk-size'),
7650                                                           RowDiff           => $rd,
7651                                                           ChangeHandler     => $ch,
7652                                                           transaction       => $use_txn,
7653                                                           callback          => $callback,
7654                                                           where             => $args{where} || $o->get('where'),
7655                                                           bidirectional     => $o->get('bidirectional'),
7656                                                           buffer_in_mysql   => $o->get('buffer-in-mysql'),
7657                                                           buffer_to_client  => $o->get('buffer-to-client'),
7658                                                           changing_src      => $o->get('replicate')
7659                                                                                || $o->get('sync-to-master')
7660                                                                                || $o->get('bidirectional')
7661                                                                                || 0,
7662                                                           float_precision   => $o->get('float-precision'),
7663                                                           index_hint        => $o->get('index-hint'),
7664                                                           chunk_index       => $o->get('chunk-index'),
7665                                                           chunk_col         => $o->get('chunk-column'),
7666                                                           lock              => $o->get('lock'),
7667                                                           replace           => $o->get('replace'),
7668                                                           replicate         => $o->get('replicate'),
7669                                                           dry_run           => $o->get('dry-run'),
7670                                                           timeout_ok        => $o->get('timeout-ok'),
7671                                                           trim              => $o->get('trim'),
7672                                                           wait              => $o->get('wait'),
7673                                                           function          => $o->get('function'),
7674                                                        );
7675                                                  
7676          27    100                         595         if ( sum(@status{@ChangeHandler::ACTIONS}) ) {
7677          26                                242            $exit_status |= 2;
7678                                                        }
7679                                                     };
7680                                                  
7681          31    100                         231      if ( $EVAL_ERROR ) {
7682           4                                 54         print_err($EVAL_ERROR, $dst->{db}, $dst->{tbl}, $dst->{dsn}->{h});
7683           4                                 19         $exit_status |= 1;
7684                                                     }
7685                                                  
7686                                                     # Print this last so that the exit status is its final result.
7687          31    100                         241      if ( $o->get('verbose') ) {
7688          72    100                         492         printf($args{hdr},
7689           9                                 85            map { $_ || '0' } @status{@ChangeHandler::ACTIONS, 'ALGORITHM'},
7690                                                           $exit_status, $src->{db}, $src->{tbl});
7691                                                     }
7692                                                  
7693          31                                430      return $exit_status;
7694                                                  }
7695                                                  
7696                                                  sub get_change_dbh {
7697          30                   30           537      my ( %args ) = @_;
7698          30                                292      my @required_args = qw(src dst tbl_struct OptionParser DSNParser
7699                                                                            MasterSlave);
7700          30                                202      foreach my $arg ( @required_args ) {
7701  ***    180     50                         998         die "I need a $arg argument" unless $args{$arg};
7702                                                     }
7703          30                                270      my ($src, $dst, $tbl_struct, $o, $dp, $ms) = @args{@required_args};
7704                                                  
7705          30                                129      my $change_dbh = $dst->{dbh};  # The default case: making changes on dst.
7706                                                  
7707  ***     30    100     66                  148      if ( $o->get('sync-to-master') || $o->get('replicate') ) {
                    100                               
7708                                                        # Is it possible to make changes on the master (i.e. the source)?
7709                                                        # Only if REPLACE will work.
7710           6                                 22         my $can_replace = grep { $_->{is_unique} } values %{$tbl_struct->{keys}};
               8                                 46   
               6                                 40   
7711           6                                 17         MKDEBUG && _d("This table's replace-ability:", $can_replace);
7712  ***      6     50                          33         die "Can't make changes on the master because no unique index exists"
7713                                                           unless $can_replace;
7714           6                                 25         $change_dbh = $src->{dbh};  # The alternate case.
7715           6                                 18         MKDEBUG && _d('Will make changes on source', $change_dbh);
7716                                                     }
7717                                                     elsif ( $o->get('check-slave') ) {
7718                                                        # Is it safe to change data on the destination?  Only if it's *not*
7719                                                        # a slave.  We don't change tables on slaves directly.  If we are
7720                                                        # forced to change data on a slave, we require either that 1) binary
7721                                                        # logging is disabled, or 2) the check is bypassed.  By the way, just
7722                                                        # because the server is a slave doesn't mean it's not also the master
7723                                                        # of the master (master-master replication).
7724          23                                272         my $slave_status = $ms->get_slave_status($dst->{dbh});
7725          23                                 69         my (undef, $log_bin) = $dst->{dbh}->selectrow_array(
7726                                                           'SHOW VARIABLES LIKE "log_bin"');
7727          23                                 65         my ($sql_log_bin) = $dst->{dbh}->selectrow_array(
7728                                                           'SELECT @@SQL_LOG_BIN');
7729          23                               3408         MKDEBUG && _d('Variables on destination:',
7730                                                           'log_bin=', (defined $log_bin ? $log_bin : 'NULL'),
7731                                                           ' @@SQL_LOG_BIN=', (defined $sql_log_bin ? $sql_log_bin : 'NULL'));
7732          23    100    100                  315         if ( $slave_status && $sql_log_bin && ($log_bin || 'OFF') eq 'ON' ) {
      ***                   50                        
      ***                   66                        
7733           2                                 23            die "Can't make changes on ", $dp->as_string($dst->{dsn}),
7734                                                              " because it's a slave.  See the documentation section",
7735                                                              " 'REPLICATION SAFETY' for solutions to this problem.";
7736                                                        }
7737          21                                139         MKDEBUG && _d('Will make changes on destination', $change_dbh);
7738                                                     }
7739                                                  
7740          28                                286      return $change_dbh;
7741                                                  }
7742                                                  
7743                                                  sub make_action_subs {
7744          28                   28           395      my ( %args ) = @_;
7745          28                                269      my @required_args = qw(change_dbh OptionParser);
7746          28                                178      foreach my $arg ( @required_args ) {
7747  ***     56     50                         372         die "I need a $arg argument" unless $args{$arg};
7748                                                     }
7749          28                                162      my ($change_dbh, $o) = @args{@required_args};
7750                                                  
7751          28                                 98      my @actions;
7752          28    100                         175      if ( $o->get('execute') ) {
7753                                                        push @actions, sub {
7754  ***     51            66     51           267            my ( $sql, $dbh ) = @_;
7755                                                           # Use $dbh if given.  It's from a bidirectional callback.
7756  ***     51            66                  272            $dbh ||= $change_dbh;
7757          51                                127            MKDEBUG && _d('Execute on dbh', $dbh, $sql);
7758          51                              14353            $dbh->do($sql);
7759          15                                203         };
7760                                                     }
7761  ***     28     50                         151      if ( $o->get('print') ) {
7762                                                        # Print AFTER executing, so the print isn't misleading in case of an
7763                                                        # index violation etc that doesn't actually get executed.
7764                                                        push @actions, sub { 
7765          73                   73           467            my ( $sql, $dbh ) = @_;
7766                                                           # Append /*host:port*/ to the sql, if possible, so the user
7767                                                           # can see on which host it was/would be ran.
7768          73    100                         505            my $dsn = $dsn_for{$dbh} if $dbh;
7769          73    100                         342            if ( $dsn ) {
7770  ***     36            33                  296               my $h = $dsn->{h} || $dsn->{S} || '';
      ***                   50                        
7771  ***     36            50                  210               my $p = $dsn->{P} || '';
7772  ***     36     50                         301               $sql  = "/*$h" . ($p ? ":$p" : '') . "*/ $sql";
7773                                                           }
7774  ***     73     50                         932            print($sql, ";\n") or die "Cannot print: $OS_ERROR";
7775          28                                386         };
7776                                                     }
7777                                                  
7778          28                                235      return \@actions;
7779                                                  }
7780                                                  
7781                                                  # Tries to extract the MySQL error message and print it
7782                                                  sub print_err {
7783           4                    4            36      my ( $msg, $database, $table, $host ) = @_;
7784  ***      4     50                          28      return if !defined $msg;
7785           4                                 42      $msg =~ s/^.*?failed: (.*?) at \S+ line (\d+).*$/$1 at line $2/s;
7786           4                                 79      $msg =~ s/\s+/ /g;
7787  ***      4     50     33                   59      if ( $database && $table ) {
7788           4                                 27         $msg .= " while doing $database.$table";
7789                                                     }
7790  ***      4     50                          23      if ( $host ) {
7791           4                                 20         $msg .= " on $host";
7792                                                     }
7793           4                                 57      print STDERR $msg, "\n";
7794                                                  }
7795                                                  
7796                                                  sub get_cxn {
7797         112                  112          1620      my ( $dsn, %args ) = @_;
7798         112                                893      my @required_args = qw(OptionParser DSNParser);
7799         112                                575      foreach my $arg ( @required_args ) {
7800  ***    224     50                        1445         die "I need a $arg argument" unless $args{$arg};
7801                                                     }
7802         112                                704      my ($o, $dp) = @args{@required_args};
7803                                                  
7804  ***    112     50     66                 1069      if ( !$dsn->{p} && $o->get('ask-pass') ) {
7805                                                        # Just "F=file" is a valid DSN but fill_in_dsn() can't help us
7806                                                        # because we haven't connected yet.  If h is not specified,
7807                                                        # then user is relying on F or .my.cnf/system defaults.
7808                                                        # http://code.google.com/p/maatkit/issues/detail?id=947
7809  ***      0      0                           0         my $host  = $dsn->{h} ? $dsn->{h}
7810                                                                  :             "DSN ". $dp->as_string($dsn);
7811  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password for $host: ");
7812                                                     }
7813         112                                949      my $dbh = $dp->get_dbh(
7814                                                        $dp->get_cxn_params($dsn, {})  # get_cxn_params needs the 2nd arg
7815                                                     );
7816                                                  
7817         112                                545      my $sql;
7818         112    100                         850      if ( !$o->get('bin-log') ) {
7819          24                                124         $sql = "/*!32316 SET SQL_LOG_BIN=0 */";
7820          24                                 78         MKDEBUG && _d($dbh, $sql);
7821          24                               2671         $dbh->do($sql);
7822                                                     }
7823  ***    112     50                         677      if ( !$o->get('unique-checks') ) {
7824  ***      0                                  0         $sql = "/*!40014 SET UNIQUE_CHECKS=0 */";
7825  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
7826  ***      0                                  0         $dbh->do($sql);
7827                                                     }
7828  ***    112     50                         594      if ( !$o->get('foreign-key-checks') ) {
7829  ***      0                                  0         $sql = "/*!40014 SET FOREIGN_KEY_CHECKS=0 */";
7830  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
7831  ***      0                                  0         $dbh->do($sql);
7832                                                     }
7833                                                  
7834                                                     # Disable auto-increment on zero (bug #1919897).
7835         112                                476      $sql = '/*!40101 SET @@SQL_MODE := CONCAT(@@SQL_MODE, '
7836                                                          . '",NO_AUTO_VALUE_ON_ZERO")*/';
7837         112                                344      MKDEBUG && _d($dbh, $sql);
7838         112                              14841      $dbh->do($sql);
7839                                                     
7840                                                     # Ensure statement-based replication.
7841                                                     # http://code.google.com/p/maatkit/issues/detail?id=95
7842         112                                570      $sql = '/*!50105 SET @@binlog_format="STATEMENT"*/';
7843         112                                319      MKDEBUG && _d($dbh, $sql);
7844         112                              10795      $dbh->do($sql);
7845                                                  
7846  ***    112     50                         752      if ( $o->get('transaction') ) {
7847  ***      0                                  0         my $sql = "SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ";
7848  ***      0                                  0         eval {
7849  ***      0                                  0            MKDEBUG && _d($dbh, $sql);
7850  ***      0                                  0            $dbh->do($sql);
7851                                                        };
7852  ***      0      0                           0         die "Failed to $sql: $EVAL_ERROR" if $EVAL_ERROR;
7853                                                     }
7854                                                  
7855         112                                774      $dsn_for{$dbh} = $dsn;
7856                                                  
7857         112                                315      MKDEBUG && _d('Opened dbh', $dbh);
7858         112                               2346      return $dbh;
7859                                                  }
7860                                                  
7861                                                  sub ok_to_sync {
7862          31                   31           505      my ( %args ) = @_;
7863          31                                341      my @required_args = qw(src dst DSNParser Quoter VersionParser TableParser
7864                                                                            MySQLDump TableSyncer OptionParser);
7865          31                                189      foreach my $arg ( @required_args ) {
7866  ***    279     50                        1500         die "I need a $arg argument" unless $args{$arg};
7867                                                     }
7868          31                                266      my ($src, $dst, $dp, $q, $vp, $tp, $du, $syncer, $o) = @args{@required_args};
7869                                                  
7870                                                     # First things first: check that the src and dst dbs and tbls exist.
7871                                                     # This can fail in cases like h=host,D=bad,t=also_bad (i.e. simple
7872                                                     # user error).  It can also fail when syncing all dbs/tbls with sync_all()
7873                                                     # because the dst db/tbl is assumed to be the same as the src but
7874                                                     # this isn't always the case.
7875          31                                 98      my $src_tbl_ddl;
7876          31                                114      eval {
7877                                                        # FYI: get_create_table() does USE db but doesn't eval it.
7878          31                               4112         $src->{dbh}->do("USE `$src->{db}`");
7879          31                                502         $src_tbl_ddl = $du->get_create_table($src->{dbh}, $q,
7880                                                           $src->{db}, $src->{tbl});
7881                                                     };
7882  ***     31     50                         176      die $EVAL_ERROR if $EVAL_ERROR;
7883                                                  
7884          31                                 99      my $dst_tbl_ddl;
7885          31                                111      eval {
7886                                                        # FYI: get_create_table() does USE db but doesn't eval it.
7887          31                               3569         $dst->{dbh}->do("USE `$dst->{db}`");
7888          31                                310         $dst_tbl_ddl = $du->get_create_table($dst->{dbh}, $q,
7889                                                           $dst->{db}, $dst->{tbl});
7890                                                     };
7891  ***     31     50                         193      die $EVAL_ERROR if $EVAL_ERROR;
7892                                                  
7893                                                     # This doesn't work at the moment when syncing different table names.
7894                                                     # Check that src.db.tbl has the exact same schema as dst.db.tbl.
7895                                                     # if ( $o->get('check-schema') && ($src_tbl_ddl ne $dst_tbl_ddl) ) {
7896                                                     #   die "Source and destination tables have different schemas";
7897                                                     # }
7898          31                                329      my $tbl_struct = $tp->parse($src_tbl_ddl);
7899                                                  
7900                                                     # Check that the user has all the necessary privs on the tbls.
7901          31    100                         267      if ( $o->get('check-privileges') ) {
7902          30                                 92         MKDEBUG && _d('Checking privileges');
7903          30    100                         408         if ( !$syncer->have_all_privs($src->{dbh}, $src->{db}, $src->{tbl}) ) {
7904           1                                 11            die "User does not have all necessary privileges on ",
7905                                                              $q->quote($src->{db}, $src->{tbl});
7906                                                        }
7907  ***     29     50                         308         if ( !$syncer->have_all_privs($dst->{dbh}, $dst->{db}, $dst->{tbl}) ) {
7908  ***      0                                  0            die "User does not have all necessary privileges on ",
7909                                                              $q->quote($dst->{db}, $dst->{tbl});
7910                                                        }
7911                                                     }
7912                                                  
7913                                                     # Check that no triggers are defined on the dst tbl.
7914  ***     30     50                         500      if ( $o->get('check-triggers') ) {
7915          30                                 96         MKDEBUG && _d('Checking for triggers');
7916          30    100                         220         if ( !defined $dst->{supports_triggers} ) {
7917          29                                278            $dst->{supports_triggers} = $vp->version_ge($dst->{dbh}, '5.0.2');
7918                                                        }
7919  ***     30     50     33                  654         if ( $dst->{supports_triggers}
7920                                                             && $du->get_triggers($dst->{dbh}, $q, $dst->{db}, $dst->{tbl}) ) {
7921  ***      0                                  0            die "Triggers are defined on the table";
7922                                                        }
7923                                                        else {
7924          30                                105            MKDEBUG && _d('Destination does not support triggers',
7925                                                              $dp->as_string($dst->{dsn}));
7926                                                        }
7927                                                     }
7928                                                  
7929          30                                534      return $tbl_struct;
7930                                                  }
7931                                                  
7932                                                  sub filter_diffs {
7933           3                    3            21      my ( $skip_table, $databases, $tables, @diffs ) = @_;
7934  ***      4     50      0                  102      return grep {
      ***                   33                        
      ***                   66                        
      ***                   33                        
7935           3                                 15         !$skip_table->{$_->{db}}->{$_->{tbl}}
7936                                                        && (!$databases || $databases->{$_->{db}})
7937                                                        && (!$tables || ($tables->{$_->{tbl}} || $tables->{"$_->{db}.$_->{tbl}"}))
7938                                                     } @diffs;
7939                                                  }
7940                                                  
7941                                                  sub disconnect {
7942          56                   56           360      my ( @hosts ) = @_;
7943          56                                308      foreach my $host ( @hosts ) {
7944          56                                259         foreach my $thing ( qw(dbh misc_dbh) ) {
7945         112                                625            my $dbh = $host->{$thing};
7946  ***    112     50                         626            next unless $dbh;
7947         112                                796            delete $dsn_for{$dbh};
7948         112    100                        1125            $dbh->commit() unless $dbh->{AutoCommit};
7949         112                             1415698            $dbh->disconnect();
7950         112                                864            MKDEBUG && _d('Disconnected dbh', $dbh);
7951                                                        }
7952                                                     }
7953          56                               2896      return;
7954                                                  }
7955                                                  
7956                                                  # This is passed as the callback for TableSyncer::sync_table()
7957                                                  # if --print --verbose --verbose is specified.
7958                                                  sub print_sql {
7959          12                   12            67      my ( $src_sql, $dst_sql ) = @_;
7960  ***     12     50                         156      print "# $src_sql\n" if $src_sql;
7961  ***     12     50                          66      print "# $dst_sql\n" if $dst_sql;
7962          12                                 35      return;
7963                                                  }
7964                                                  
7965                                                  # Compares left_val to right_val by doing cmp.  Returns one of the
7966                                                  # result constants listed below, or dies if cmp is invalid.  The val
7967                                                  # arg is used for certain cmp, like equals and matches.  The twos
7968                                                  # vals should generally not be equal; if they are, UPDATE_NEITHER is
7969                                                  # returned.  Threshold (thr) only applies to temporal datetimes and
7970                                                  # dates and numerical values.
7971          36                   36           345   use constant UPDATE_LEFT      => -1;
              36                                106   
              36                                265   
7972          36                   36           224   use constant UPDATE_RIGHT     =>  1;
              36                                100   
              36                                192   
7973          36                   36           218   use constant UPDATE_NEITHER   =>  0;  # neither value equals/matches
              36                                 89   
              36                                175   
7974          36                   36           216   use constant FAILED_THRESHOLD =>  2;  # failed to exceed threshold
              36                                100   
              36                                171   
7975                                                  sub cmp_conflict_col {
7976          53                   53           375      my ( $left_val, $right_val, $cmp, $val, $thr ) = @_;
7977          53                                152      MKDEBUG && _d('Compare', @_);
7978          53                                146      my $res;
7979          53    100    100                  445      if ( $cmp eq 'newest' || $cmp eq 'oldest' ) {
                    100    100                        
                    100                               
                    100                               
7980  ***     41    100     50                  351         $res = $cmp eq 'newest' ? ($left_val  || '') cmp ($right_val || '')
      ***                   50                        
      ***                   50                        
      ***                   50                        
7981                                                             :                    ($right_val || '') cmp ($left_val  || '');
7982                                                  
7983          41    100                         182         if ( $thr ) {
7984          11                                 57            $thr     = time_to_secs($thr);
7985          11                                 61            my $lts  = any_unix_timestamp($left_val);
7986          11                                 45            my $rts  = any_unix_timestamp($right_val);
7987          11                                 47            my $diff = abs($lts - $rts);
7988          11                                 25            MKDEBUG && _d('Check threshold, lts rts thr abs-diff:',
7989                                                              $lts, $rts, $thr, $diff);
7990          11    100                          54            if ( $diff < $thr ) {
7991           5                                 12               MKDEBUG && _d("Failed threshold");
7992           5                                 28               return FAILED_THRESHOLD;
7993                                                           }
7994                                                        }
7995                                                     }
7996                                                     elsif ( $cmp eq 'greatest' || $cmp eq 'least' ) {
7997  ***      5    100     50                   41         $res = $cmp eq 'greatest' ? (($left_val ||0) > ($right_val ||0) ? 1 : -1)
      ***            50     50                        
      ***           100     50                        
      ***                   50                        
7998                                                             :                      (($left_val ||0) < ($right_val ||0) ? 1 : -1);
7999  ***      5    100     50                   32         $res = 0 if ($left_val || 0) == ($right_val || 0);
      ***                   50                        
8000           5    100                          20         if ( $thr ) {
8001           2                                  7            my $diff = abs($left_val - $right_val);
8002           2                                  5            MKDEBUG && _d('Check threshold, abs-diff:', $diff);
8003           2    100                          11            if ( $diff < $thr ) {
8004           1                                  4               MKDEBUG && _d("Failed threshold");
8005           1                                  6               return FAILED_THRESHOLD;
8006                                                           }
8007                                                        }
8008                                                     }
8009                                                     elsif ( $cmp eq 'equals' ) {
8010  ***      3    100     50                   23         $res = ($left_val  || '') eq $val ?  1
      ***           100     50                        
8011                                                             : ($right_val || '') eq $val ? -1
8012                                                             :                               0;
8013                                                     }
8014                                                     elsif ( $cmp eq 'matches' ) {
8015  ***      3    100     50                   78         $res = ($left_val  || '') =~ m/$val/ ?  1
      ***           100     50                        
8016                                                             : ($right_val || '') =~ m/$val/ ? -1
8017                                                             :                                  0;
8018                                                     }
8019                                                     else {
8020                                                        # Should happen; caller should have verified this.
8021           1                                  3         die "Invalid comparison: $cmp";
8022                                                     }
8023                                                  
8024          46                                222      return $res;
8025                                                  }
8026                                                  
8027                                                  sub set_bidirectional_callbacks {
8028           5                    5            71      my ( %args ) = @_;
8029           5                                 38      foreach my $arg ( qw(plugin OptionParser) ) {
8030  ***     10     50                          57         die "I need a $arg argument" unless $args{$arg};
8031                                                     }
8032           5                                 22      my $o      = $args{OptionParser};
8033           5                                 19      my $plugin = $args{plugin};
8034                                                  
8035           5                                 25      my $col = $o->get('conflict-column');
8036           5                                 24      my $cmp = $o->get('conflict-comparison');
8037           5                                 23      my $val = $o->get('conflict-value');
8038           5                                 19      my $thr = $o->get('conflict-threshold');
8039                                                  
8040                                                     # plugin and syncer are actually the same module.  For clarity we
8041                                                     # name them differently.
8042                                                  
8043                                                     $plugin->set_callback('same_row', sub {
8044          26                   26           232         my ( %args ) = @_;
8045          26                                204         my ($lr, $rr, $syncer) = @args{qw(lr rr syncer)};
8046          26                                109         my $ch = $syncer->{ChangeHandler};
8047          26                                 91         my $action = 'UPDATE';
8048          26                                 74         my $change_dbh;
8049          26                                 74         my $auth_row;
8050          26                                 78         my $err;
8051                                                  
8052  ***     26            50                  160         my $left_val  = $lr->{$col} || '';
8053  ***     26            50                  146         my $right_val = $rr->{$col} || '';
8054          26                                 68         MKDEBUG && _d('left',  $col, 'value:', $left_val);
8055          26                                 69         MKDEBUG && _d('right', $col, 'value:', $right_val);
8056                                                  
8057          26                                166         my $res = cmp_conflict_col($left_val, $right_val, $cmp, $val, $thr);
8058          26    100                         188         if ( $res == UPDATE_LEFT ) {
                    100                               
                    100                               
      ***            50                               
8059          13                                 34            MKDEBUG && _d("right dbh $args{right_dbh} $cmp; "
8060                                                              . "update left dbh $args{left_dbh}");
8061          13                                 83            $ch->set_src('right', $args{right_dbh});
8062          13                                 48            $auth_row   = $args{rr};
8063          13                                 53            $change_dbh = $args{left_dbh};
8064                                                        }
8065                                                        elsif ( $res == UPDATE_RIGHT ) {
8066           9                                 22            MKDEBUG && _d("left dbh $args{left_dbh} $cmp; "
8067                                                              . "update right dbh $args{right_dbh}");
8068           9                                 60            $ch->set_src('left', $args{left_dbh});
8069           9                                 33            $auth_row   = $args{lr};
8070           9                                 39            $change_dbh = $args{right_dbh};
8071                                                        }
8072                                                        elsif ( $res == UPDATE_NEITHER ) {
8073  ***      2     50     33                   45            if ( $cmp eq 'equals' || $cmp eq 'matches' ) {
8074  ***      0                                  0               $err = "neither `$col` value $cmp $val";
8075                                                           }
8076                                                           else {
8077           2                                 19               $err = "`$col` values are the same"
8078                                                           }
8079                                                        }
8080                                                        elsif ( $res == FAILED_THRESHOLD ) {
8081           2                                 16            $err = "`$col` values do not differ by the threhold, $thr."
8082                                                        }
8083                                                        else {
8084                                                           # Shouldn't happen.
8085  ***      0                                  0            die "cmp_conflict_col() returned an invalid result: $res."
8086                                                        }
8087                                                  
8088          26    100                         124         if ( $err ) {
8089           4                                 18            $action   = undef;  # skip change in case we just warn
8090           4                                 24            my $where = $ch->make_where_clause($lr, $syncer->key_cols());
8091           4                                 36            $err      = "# Cannot resolve conflict WHERE $where: $err\n";
8092                                                  
8093                                                           # die here is caught in sync_a_table().  We're deeply nested:
8094                                                           # sync_a_table > sync_table > compare_sets > syncer > here
8095           4    100                          35            $o->get('conflict-error') eq 'warn' ? warn $err : die $err;
8096                                                        }
8097                                                  
8098          25                                191         return $action, $auth_row, $change_dbh;
8099           5                                139      });
8100                                                  
8101                                                     $plugin->set_callback('not_in_right', sub {
8102           7                    7            71         my ( %args ) = @_;
8103           7                                 71         $args{syncer}->{ChangeHandler}->set_src('left', $args{left_dbh});
8104           7                                 63         return 'INSERT', $args{lr}, $args{right_dbh};
8105           5                                 53      });
8106                                                  
8107                                                     $plugin->set_callback('not_in_left', sub {
8108           7                    7            52         my ( %args ) = @_;
8109           7                                 56         $args{syncer}->{ChangeHandler}->set_src('right', $args{right_dbh});
8110           7                                 53         return 'INSERT', $args{rr}, $args{left_dbh};
8111           5                                 43      });
8112                                                  
8113           5                                 28      return;
8114                                                  }
8115                                                  
8116                                                  sub _d {
8117  ***      0                    0                    my ($package, undef, $line) = caller 0;
8118  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
8119  ***      0                                              map { defined $_ ? $_ : 'undef' }
8120                                                          @_;
8121  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
8122                                                  }
8123                                                  
8124                                                  # ############################################################################
8125                                                  # Run the program.
8126                                                  # ############################################################################
8127                                                  if ( !caller ) { exit main(@ARGV); }
8128                                                  
8129                                                  1; # Because this is a module as well as a script.
8130                                                  
8131                                                  # ############################################################################
8132                                                  # Documentation
8133                                                  # ############################################################################
8134                                                  =pod
8135                                                  
8136                                                  =head1 NAME
8137                                                  
8138                                                  mk-table-sync - Synchronize MySQL tables efficiently.
8139                                                  
8140                                                  =head1 SYNOPSIS
8141                                                  
8142                                                  This tool changes data, so for maximum safety, you should back up your data
8143                                                  before you use it.
8144                                                  
8145                                                  To sync db.tbl1 from host1 to host2:
8146                                                  
8147                                                   mk-table-sync --execute u=user,p=pass,h=host1,D=db,t=tbl host2
8148                                                  
8149                                                  Sync all tables in host1 to host2 and host3:
8150                                                  
8151                                                   mk-table-sync --execute host1 host2 host3
8152                                                  
8153                                                  Resolve differences L<mk-table-checksum> found on this master's slaves:
8154                                                  
8155                                                   mk-table-sync --execute --replicate test.checksum master1
8156                                                  
8157                                                  Make slave1 have the same data as its replication master:
8158                                                  
8159                                                   mk-table-sync --execute --sync-to-master slave1
8160                                                  
8161                                                  Ditto, resolving differences L<mk-table-checksum> found:
8162                                                  
8163                                                   mk-table-sync --execute --sync-to-master \
8164                                                     --replicate test.checksum slave1
8165                                                  
8166                                                  Sync server2 in a master-master replication configuration, where server2's copy
8167                                                  of db1.tbl1 is known or suspected to be incorrect:
8168                                                  
8169                                                   mk-table-sync --execute --sync-to-master h=server2,D=db1,t=tbl1
8170                                                  
8171                                                  Note that in the master-master configuration, the following will NOT do what you
8172                                                  want, because it will make changes directly on server2, which will then flow
8173                                                  through replication and change server1's data:
8174                                                  
8175                                                   # Don't do this in a master-master setup!
8176                                                   mk-table-sync --execute h=server1,D=db1,t=tbl1 h=server2
8177                                                  
8178                                                  =head1 RISKS
8179                                                  
8180                                                  The following section is included to inform users about the potential risks,
8181                                                  whether known or unknown, of using this tool.  The two main categories of risks
8182                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
8183                                                  tools) and those created by bugs.
8184                                                  
8185                                                  With great power comes great responsibility!  This tool changes data, so it is a
8186                                                  good idea to back up your data.  It is also very powerful, which means it is
8187                                                  very complex, so you should run it with the L<"--dry-run"> option to see what it
8188                                                  will do, until you're familiar with its operation.  If you want to see which
8189                                                  rows are different, without changing any data, use L<"--print"> instead of
8190                                                  L<"--execute">.  
8191                                                  
8192                                                  Be careful when using mk-table-sync in any master-master setup.  Master-master
8193                                                  replication is inherently tricky, and it's easy to make mistakes.  Yyou need to
8194                                                  be sure you're using the tool correctly for master-master replication.  See the
8195                                                  L<"SYNOPSIS"> for the overview of the correct usage.
8196                                                  
8197                                                  In general, this tool is best suited when your tables have a primary key or
8198                                                  unique index.  Although it can synchronize data in tables lacking a primary key
8199                                                  or unique index, it might be best to sychronize that data by another means.
8200                                                  
8201                                                  At the time of this release, there is a potential bug using
8202                                                  L<"--lock-and-rename"> with MySQL 5.1, a bug detecting certain differences,
8203                                                  a bug using ROUND() across different platforms, a bug mixing collations, and
8204                                                  a limitation quoting strings starting with "0x" that look like binary data.
8205                                                  
8206                                                  The authoritative source for updated information is always the online issue
8207                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
8208                                                  see a list of such issues at the following URL:
8209                                                  L<http://www.maatkit.org/bugs/mk-table-sync>.
8210                                                  
8211                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
8212                                                  
8213                                                  =head1 DESCRIPTION
8214                                                  
8215                                                  B<WARNING> this tool is unfinished and could perform slowly.  The Chunk
8216                                                  algorithm is great when it can be used, and so is Nibble, but otherwise GroupBy
8217                                                  is the default choice and it may not perform very well.  Please run with
8218                                                  L<"--dry-run"> before subjecting your servers to this tool, and make backups of
8219                                                  your data!
8220                                                  
8221                                                  This tool is designed to do one-way and bidirectional synchronization of data.
8222                                                  It finds differences efficiently with one of several algorithms
8223                                                  (see L<"ALGORITHMS">).  It makes changes on the destination table(s) so it
8224                                                  matches the source.
8225                                                  
8226                                                  It does B<not> synchronize table structures, indexes, or any other schema
8227                                                  changes.  It synchronizes only data.
8228                                                  
8229                                                  It can operate through replication by comparing a slave with its master and
8230                                                  making changes on the master.  These changes will flow through replication and
8231                                                  correct any differences found on the slave.
8232                                                  
8233                                                  It accepts a list of DSNs (see the L<"--help"> output) to tell it where and how
8234                                                  to connect.
8235                                                  
8236                                                  There are many ways to invoke it.  The following is the abbreviated logic:
8237                                                  
8238                                                     if DSN has a t part, sync only that table:
8239                                                        if 1 DSN:
8240                                                           if --sync-to-master:
8241                                                              The DSN is a slave.  Connect to its master and sync.
8242                                                        if more than 1 DSN:
8243                                                           The first DSN is the source.  Sync each DSN in turn.
8244                                                     else if --replicate:
8245                                                        if --sync-to-master:
8246                                                           The DSN is a slave.  Connect to its master, find records
8247                                                           of differences, and fix.
8248                                                        else:
8249                                                           The DSN is the master.  Find slaves and connect to each,
8250                                                           find records of differences, and fix.
8251                                                     else:
8252                                                        if only 1 DSN and --sync-to-master:
8253                                                           The DSN is a slave.  Connect to its master, find tables and
8254                                                           filter with --databases etc, and sync each table to the master.
8255                                                        else:
8256                                                           find tables, filtering with --databases etc, and sync each
8257                                                           DSN to the first.
8258                                                  
8259                                                  If you're confused about how it the DSNs are interpreted, use the
8260                                                  L<"--explain-hosts"> option and it will tell you.
8261                                                  
8262                                                  =head1 OUTPUT
8263                                                  
8264                                                  If you specify the L<"--verbose"> option, you'll see information about the 
8265                                                  differences between the tables.  There is one row per table.  Each server is
8266                                                  printed separately.  For example,
8267                                                  
8268                                                     # Syncing h=host1,D=test,t=test1
8269                                                     # DELETE REPLACE INSERT UPDATE ALGORITHM EXIT DATABASE.TABLE
8270                                                     #      0       0      3      0 Chunk     2    test.test1
8271                                                  
8272                                                  Table test.test1 on host1 required 3 C<INSERT> statements to synchronize
8273                                                  and it used the Chunk algorithm (see L<"ALGORITHMS">).  Because differences were
8274                                                  found, its L<"EXIT STATUS"> was 2.
8275                                                  
8276                                                  If you specify the L<"--print"> option, you'll see the actual SQL statements
8277                                                  that the script uses to synchronize the table if L<"--execute"> is also
8278                                                  specified.
8279                                                  
8280                                                  If you want to see the SQL statements that mk-table-sync is using to select
8281                                                  chunks, nibbles, rows, etc., then specify L<"--print"> once and L<"--verbose">
8282                                                  twice.  Be careful though: this can print a lot of SQL statements.
8283                                                  
8284                                                  There are cases where no combination of C<INSERT>, C<UPDATE> or C<DELETE>
8285                                                  statements can resolve differences without violating some unique key.  For
8286                                                  example, suppose there's a primary key on column a and a unique key on column b.
8287                                                  Then there is no way to sync these two tables with straightforward UPDATE
8288                                                  statements:
8289                                                  
8290                                                   +---+---+  +---+---+
8291                                                   | a | b |  | a | b |
8292                                                   +---+---+  +---+---+
8293                                                   | 1 | 2 |  | 1 | 1 |
8294                                                   | 2 | 1 |  | 2 | 2 |
8295                                                   +---+---+  +---+---+
8296                                                  
8297                                                  The tool rewrites queries to C<DELETE> and C<REPLACE> in this case.  This is
8298                                                  automatically handled after the first index violation, so you don't have to
8299                                                  worry about it.
8300                                                  
8301                                                  =head1 REPLICATION SAFETY
8302                                                  
8303                                                  Synchronizing a replication master and slave safely is a non-trivial problem, in
8304                                                  general.  There are all sorts of issues to think about, such as other processes
8305                                                  changing data, trying to change data on the slave, whether the destination and
8306                                                  source are a master-master pair, and much more.
8307                                                  
8308                                                  In general, the safe way to do it is to change the data on the master, and let
8309                                                  the changes flow through replication to the slave like any other changes.
8310                                                  However, this works only if it's possible to REPLACE into the table on the
8311                                                  master.  REPLACE works only if there's a unique index on the table (otherwise it
8312                                                  just acts like an ordinary INSERT).
8313                                                  
8314                                                  If your table has unique keys, you should use the L<"--sync-to-master"> and/or
8315                                                  L<"--replicate"> options to sync a slave to its master.  This will generally do
8316                                                  the right thing.  When there is no unique key on the table, there is no choice
8317                                                  but to change the data on the slave, and mk-table-sync will detect that you're
8318                                                  trying to do so.  It will complain and die unless you specify
8319                                                  C<--no-check-slave> (see L<"--[no]check-slave">).
8320                                                  
8321                                                  If you're syncing a table without a primary or unique key on a master-master
8322                                                  pair, you must change the data on the destination server.  Therefore, you need
8323                                                  to specify C<--no-bin-log> for safety (see L<"--[no]bin-log">).  If you don't,
8324                                                  the changes you make on the destination server will replicate back to the
8325                                                  source server and change the data there!
8326                                                  
8327                                                  The generally safe thing to do on a master-master pair is to use the
8328                                                  L<"--sync-to-master"> option so you don't change the data on the destination
8329                                                  server.  You will also need to specify C<--no-check-slave> to keep
8330                                                  mk-table-sync from complaining that it is changing data on a slave.
8331                                                  
8332                                                  =head1 ALGORITHMS
8333                                                  
8334                                                  This tool has a generic data-syncing framework, within which it is possible to
8335                                                  use any number of different algorithms to actually find differences.  It chooses
8336                                                  the best algorithm automatically.  While I plan to add more algorithms in the
8337                                                  future, the following are implemented now:
8338                                                  
8339                                                  =over
8340                                                  
8341                                                  =item Chunk
8342                                                  
8343                                                  Finds an index whose first column is numeric (including date and time types),
8344                                                  and divides the column's range of values into chunks of approximately
8345                                                  L<"--chunk-size"> rows.  Syncs a chunk at a time by checksumming the entire
8346                                                  chunk.  If the chunk differs on the source and destination, checksums each
8347                                                  chunk's rows individually to find the rows that differ.
8348                                                  
8349                                                  It is efficient when the column has sufficient cardinality to make the chunks
8350                                                  end up about the right size.
8351                                                  
8352                                                  The initial per-chunk checksum is quite small and results in minimal network
8353                                                  traffic and memory consumption.  If a chunk's rows must be examined, only the
8354                                                  primary key columns and a checksum are sent over the network, not the entire
8355                                                  row.  If a row is found to be different, the entire row will be fetched, but not
8356                                                  before.
8357                                                  
8358                                                  =item Nibble
8359                                                  
8360                                                  Finds an index and ascends the index in fixed-size nibbles of L<"--chunk-size">
8361                                                  rows, using a non-backtracking algorithm (see L<mk-archiver> for more on this
8362                                                  algorithm).  It is very similar to L<"Chunk">, but instead of pre-calculating
8363                                                  the boundaries of each piece of the table based on index cardinality, it uses
8364                                                  C<LIMIT> to define each nibble's upper limit, and the previous nibble's upper
8365                                                  limit to define the lower limit.
8366                                                  
8367                                                  It works in steps: one query finds the row that will define the next nibble's
8368                                                  upper boundary, and the next query checksums the entire nibble.  If the nibble
8369                                                  differs between the source and destination, it examines the nibble row-by-row,
8370                                                  just as L<"Chunk"> does.
8371                                                  
8372                                                  =item GroupBy
8373                                                  
8374                                                  Selects the entire table grouped by all columns, with a COUNT(*) column added.
8375                                                  Compares all columns, and if they're the same, compares the COUNT(*) column's
8376                                                  value to determine how many rows to insert or delete into the destination.
8377                                                  Works on tables with no primary key or unique index.
8378                                                  
8379                                                  =item Stream
8380                                                  
8381                                                  Selects the entire table in one big stream and compares all columns.  Selects
8382                                                  all columns.  Much less efficient than the other algorithms, but works when
8383                                                  there is no suitable index for them to use.
8384                                                  
8385                                                  =item Future Plans
8386                                                  
8387                                                  Possibilities for future algorithms are TempTable (what I originally called
8388                                                  bottom-up in earlier versions of this tool), DrillDown (what I originallly
8389                                                  called top-down), and GroupByPrefix (similar to how SqlYOG Job Agent works).
8390                                                  Each algorithm has strengths and weaknesses.  If you'd like to implement your
8391                                                  favorite technique for finding differences between two sources of data on
8392                                                  possibly different servers, I'm willing to help.  The algorithms adhere to a
8393                                                  simple interface that makes it pretty easy to write your own.
8394                                                  
8395                                                  =back
8396                                                  
8397                                                  =head1 BIDIRECTIONAL SYNCING
8398                                                  
8399                                                  Bidirectional syncing is a new, experimental feature.  To make it work
8400                                                  reliably there are a number of strict limitations:
8401                                                  
8402                                                    * only works when syncing one server to other independent servers
8403                                                    * does not work in any way with replication
8404                                                    * requires that the table(s) are chunkable with the Chunk algorithm
8405                                                    * is not N-way, only bidirectional between two servers at a time
8406                                                    * does not handle DELETE changes
8407                                                  
8408                                                  For example, suppose we have three servers: c1, r1, r2.  c1 is the central
8409                                                  server, a pseudo-master to the other servers (viz. r1 and r2 are not slaves
8410                                                  to c1).  r1 and r2 are remote servers.  Rows in table foo are updated and
8411                                                  inserted on all three servers and we want to synchronize all the changes
8412                                                  between all the servers.  Table foo has columns:
8413                                                  
8414                                                    id    int PRIMARY KEY
8415                                                    ts    timestamp auto updated
8416                                                    name  varchar
8417                                                  
8418                                                  Auto-increment offsets are used so that new rows from any server do not
8419                                                  create conflicting primary key (id) values.  In general, newer rows, as
8420                                                  determined by the ts column, take precedence when a same but differing row
8421                                                  is found during the bidirectional sync.  "Same but differing" means that
8422                                                  two rows have the same primary key (id) value but different values for some
8423                                                  other column, like the name column in this example.  Same but differing
8424                                                  conflicts are resolved by a "conflict".  A conflict compares some column of
8425                                                  the competing rows to determine a "winner".  The winnning row becomes the
8426                                                  source and its values are used to update the other row.
8427                                                  
8428                                                  There are subtle differences between three columns used to achieve
8429                                                  bidirectional syncing that you should be familiar with: chunk column
8430                                                  (L<"--chunk-column">), comparison column(s) (L<"--columns">), and conflict
8431                                                  column (L<"--conflict-column">).  The chunk column is only used to chunk the
8432                                                  table; e.g. "WHERE id >= 5 AND id < 10".  Chunks are checksummed and when
8433                                                  chunk checksums reveal a difference, the tool selects the rows in that
8434                                                  chunk and checksums the L<"--columns"> for each row.  If a column checksum
8435                                                  differs, the rows have one or more conflicting column values.  In a
8436                                                  traditional unidirectional sync, the conflict is a moot point because it can
8437                                                  be resolved simply by updating the entire destination row with the source
8438                                                  row's values.  In a bidirectional sync, however, the L<"--conflict-column">
8439                                                  (in accordance with other C<--conflict-*> options list below) is compared
8440                                                  to determine which row is "correct" or "authoritative"; this row becomes
8441                                                  the "source".
8442                                                  
8443                                                  To sync all three servers completely, two runs of mk-table-sync are required.
8444                                                  The first run syncs c1 and r1, then syncs c1 and r2 including any changes
8445                                                  from r1.  At this point c1 and r2 are completely in sync, but r1 is missing
8446                                                  any changes from r2 because c1 didn't have these changes when it and r1
8447                                                  were synced.  So a second run is needed which syncs the servers in the same
8448                                                  order, but this time when c1 and r1 are synced r1 gets r2's changes.
8449                                                  
8450                                                  The tool does not sync N-ways, only bidirectionally between the first DSN
8451                                                  given on the command line and each subsequent DSN in turn.  So the tool in
8452                                                  this example would be ran twice like:
8453                                                  
8454                                                    mk-table-sync --bidirectional h=c1 h=r1 h=r2
8455                                                  
8456                                                  The L<"--bidirectional"> option enables this feature and causes various
8457                                                  sanity checks to be performed.  You must specify other options that tell
8458                                                  mk-table-sync how to resolve conflicts for same but differing rows.
8459                                                  These options are:
8460                                                  
8461                                                    * L<"--conflict-column">
8462                                                    * L<"--conflict-comparison">
8463                                                    * L<"--conflict-value">
8464                                                    * L<"--conflict-threshold">
8465                                                    * L<"--conflict-error">  (optional)
8466                                                  
8467                                                  Use L<"--print"> to test this option before L<"--execute">.  The printed
8468                                                  SQL statements will have comments saying on which host the statment
8469                                                  would be executed if you used L<"--execute">.
8470                                                  
8471                                                  Technical side note: the first DSN is always the "left" server and the other
8472                                                  DSNs are always the "right" server.  Since either server can become the source
8473                                                  or destination it's confusing to think of them as "src" and "dst".  Therefore,
8474                                                  they're generically referred to as left and right.  It's easy to remember
8475                                                  this because the first DSN is always to the left of the other server DSNs on
8476                                                  the command line.
8477                                                  
8478                                                  =head1 EXIT STATUS
8479                                                  
8480                                                  Exit status is as follows:
8481                                                  
8482                                                     STATUS  MEANING
8483                                                     ======  =======================================================
8484                                                     0       Success.
8485                                                     1       Internal error.
8486                                                     2       At least one table differed on the destination.
8487                                                     3       Combination of 1 and 2.
8488                                                  
8489                                                  =head1 OPTIONS
8490                                                  
8491                                                  Specify at least one of L<"--print">, L<"--execute">, or L<"--dry-run">.
8492                                                  
8493                                                  L<"--where"> and L<"--replicate"> are mutually exclusive.
8494                                                  
8495                                                  =over
8496                                                  
8497                                                  =item --algorithms
8498                                                  
8499                                                  type: string; default: Chunk,Nibble,GroupBy,Stream
8500                                                  
8501                                                  Algorithm to use when comparing the tables, in order of preference.
8502                                                  
8503                                                  For each table, mk-table-sync will check if the table can be synced with
8504                                                  the given algorithms in the order that they're given.  The first algorithm
8505                                                  that can sync the table is used.  See L<"ALGORITHMS">.
8506                                                  
8507                                                  =item --ask-pass
8508                                                  
8509                                                  Prompt for a password when connecting to MySQL.
8510                                                  
8511                                                  =item --bidirectional
8512                                                  
8513                                                  Enable bidirectional sync between first and subsequent hosts.
8514                                                  
8515                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
8516                                                  
8517                                                  =item --[no]bin-log
8518                                                  
8519                                                  default: yes
8520                                                  
8521                                                  Log to the binary log (C<SET SQL_LOG_BIN=1>).
8522                                                  
8523                                                  Specifying C<--no-bin-log> will C<SET SQL_LOG_BIN=0>.
8524                                                  
8525                                                  =item --buffer-in-mysql
8526                                                  
8527                                                  Instruct MySQL to buffer queries in its memory.
8528                                                  
8529                                                  This option adds the C<SQL_BUFFER_RESULT> option to the comparison queries.
8530                                                  This causes MySQL to execute the queries and place them in a temporary table
8531                                                  internally before sending the results back to mk-table-sync.  The advantage of
8532                                                  this strategy is that mk-table-sync can fetch rows as desired without using a
8533                                                  lot of memory inside the Perl process, while releasing locks on the MySQL table
8534                                                  (to reduce contention with other queries).  The disadvantage is that it uses
8535                                                  more memory on the MySQL server instead.
8536                                                  
8537                                                  You probably want to leave L<"--[no]buffer-to-client"> enabled too, because
8538                                                  buffering into a temp table and then fetching it all into Perl's memory is
8539                                                  probably a silly thing to do.  This option is most useful for the GroupBy and
8540                                                  Stream algorithms, which may fetch a lot of data from the server.
8541                                                  
8542                                                  =item --[no]buffer-to-client
8543                                                  
8544                                                  default: yes
8545                                                  
8546                                                  Fetch rows one-by-one from MySQL while comparing.
8547                                                  
8548                                                  This option enables C<mysql_use_result> which causes MySQL to hold the selected
8549                                                  rows on the server until the tool fetches them.  This allows the tool to use
8550                                                  less memory but may keep the rows locked on the server longer.
8551                                                  
8552                                                  If this option is disabled by specifying C<--no-buffer-to-client> then
8553                                                  C<mysql_store_result> is used which causes MySQL to send all selected rows to
8554                                                  the tool at once.  This may result in the results "cursor" being held open for
8555                                                  a shorter time on the server, but if the tables are large, it could take a long
8556                                                  time anyway, and use all your memory.
8557                                                  
8558                                                  For most non-trivial data sizes, you want to leave this option enabled.
8559                                                  
8560                                                  This option is disabled when L<"--bidirectional"> is used.
8561                                                  
8562                                                  =item --charset
8563                                                  
8564                                                  short form: -A; type: string
8565                                                  
8566                                                  Default character set.  If the value is utf8, sets Perl's binmode on
8567                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
8568                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
8569                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
8570                                                  connecting to MySQL.
8571                                                  
8572                                                  =item --[no]check-master
8573                                                  
8574                                                  default: yes
8575                                                  
8576                                                  With L<"--sync-to-master">, try to verify that the detected
8577                                                  master is the real master.
8578                                                  
8579                                                  =item --[no]check-privileges
8580                                                  
8581                                                  default: yes
8582                                                  
8583                                                  Check that user has all necessary privileges on source and destination table.
8584                                                  
8585                                                  =item --[no]check-slave
8586                                                  
8587                                                  default: yes
8588                                                  
8589                                                  Check whether the destination server is a slave.
8590                                                  
8591                                                  If the destination server is a slave, it's generally unsafe to make changes on
8592                                                  it.  However, sometimes you have to; L<"--replace"> won't work unless there's a
8593                                                  unique index, for example, so you can't make changes on the master in that
8594                                                  scenario.  By default mk-table-sync will complain if you try to change data on
8595                                                  a slave.  Specify C<--no-slave-check> to disable this check.  Use it at your own
8596                                                  risk.
8597                                                  
8598                                                  =item --[no]check-triggers
8599                                                  
8600                                                  default: yes
8601                                                  
8602                                                  Check that no triggers are defined on the destination table.
8603                                                  
8604                                                  Triggers were introduced in MySQL v5.0.2, so for older versions this option
8605                                                  has no effect because triggers will not be checked.
8606                                                  
8607                                                  =item --chunk-column
8608                                                  
8609                                                  type: string
8610                                                  
8611                                                  Chunk the table on this column.
8612                                                  
8613                                                  =item --chunk-index
8614                                                  
8615                                                  type: string
8616                                                  
8617                                                  Chunk the table using this index.
8618                                                  
8619                                                  =item --chunk-size
8620                                                  
8621                                                  type: string; default: 1000
8622                                                  
8623                                                  Number of rows or data size per chunk.
8624                                                  
8625                                                  The size of each chunk of rows for the L<"Chunk"> and L<"Nibble"> algorithms.
8626                                                  The size can be either a number of rows, or a data size.  Data sizes are
8627                                                  specified with a suffix of k=kibibytes, M=mebibytes, G=gibibytes.  Data sizes
8628                                                  are converted to a number of rows by dividing by the average row length.
8629                                                  
8630                                                  =item --columns
8631                                                  
8632                                                  short form: -c; type: array
8633                                                  
8634                                                  Compare this comma-separated list of columns.
8635                                                  
8636                                                  =item --config
8637                                                  
8638                                                  type: Array
8639                                                  
8640                                                  Read this comma-separated list of config files; if specified, this must be the
8641                                                  first option on the command line.
8642                                                  
8643                                                  =item --conflict-column
8644                                                  
8645                                                  type: string
8646                                                  
8647                                                  Compare this column when rows conflict during a L<"--bidirectional"> sync.
8648                                                  
8649                                                  When a same but differing row is found the value of this column from each
8650                                                  row is compared according to L<"--conflict-comparison">, L<"--conflict-value">
8651                                                  and L<"--conflict-threshold"> to determine which row has the correct data and
8652                                                  becomes the source.  The column can be any type for which there is an
8653                                                  appropriate L<"--conflict-comparison"> (this is almost all types except, for
8654                                                  example, blobs).
8655                                                  
8656                                                  This option only works with L<"--bidirectional">.
8657                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
8658                                                  
8659                                                  =item --conflict-comparison
8660                                                  
8661                                                  type: string
8662                                                  
8663                                                  Choose the L<"--conflict-column"> with this property as the source.
8664                                                  
8665                                                  The option affects how the L<"--conflict-column"> values from the conflicting
8666                                                  rows are compared.  Possible comparisons are one of these MAGIC_comparisons:
8667                                                  
8668                                                    newest|oldest|greatest|least|equals|matches
8669                                                  
8670                                                    COMPARISON  CHOOSES ROW WITH
8671                                                    ==========  =========================================================
8672                                                    newest      Newest temporal L<"--conflict-column"> value
8673                                                    oldest      Oldest temporal L<"--conflict-column"> value
8674                                                    greatest    Greatest numerical L<"--conflict-column"> value
8675                                                    least       Least numerical L<"--conflict-column"> value
8676                                                    equals      L<"--conflict-column"> value equal to L<"--conflict-value">
8677                                                    matches     L<"--conflict-column"> value matching Perl regex pattern
8678                                                                L<"--conflict-value">
8679                                                  
8680                                                  This option only works with L<"--bidirectional">.
8681                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
8682                                                  
8683                                                  =item --conflict-error
8684                                                  
8685                                                  type: string; default: warn
8686                                                  
8687                                                  How to report unresolvable conflicts and conflict errors
8688                                                  
8689                                                  This option changes how the user is notified when a conflict cannot be
8690                                                  resolved or causes some kind of error.  Possible values are:
8691                                                  
8692                                                    * warn: Print a warning to STDERR about the unresolvable conflict
8693                                                    * die:  Die, stop syncing, and print a warning to STDERR
8694                                                  
8695                                                  This option only works with L<"--bidirectional">.
8696                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
8697                                                  
8698                                                  =item --conflict-threshold
8699                                                  
8700                                                  type: string
8701                                                  
8702                                                  Amount by which one L<"--conflict-column"> must exceed the other.
8703                                                  
8704                                                  The L<"--conflict-threshold"> prevents a conflict from being resolved if
8705                                                  the absolute difference between the two L<"--conflict-column"> values is
8706                                                  less than this amount.  For example, if two L<"--conflict-column"> have
8707                                                  timestamp values "2009-12-01 12:00:00" and "2009-12-01 12:05:00" the difference
8708                                                  is 5 minutes.  If L<"--conflict-threshold"> is set to "5m" the conflict will
8709                                                  be resolved, but if L<"--conflict-threshold"> is set to "6m" the conflict
8710                                                  will fail to resolve because the difference is not greater than or equal
8711                                                  to 6 minutes.  In this latter case, L<"--conflict-error"> will report
8712                                                  the failure.
8713                                                  
8714                                                  This option only works with L<"--bidirectional">.
8715                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
8716                                                  
8717                                                  =item --conflict-value
8718                                                  
8719                                                  type: string
8720                                                  
8721                                                  Use this value for certain L<"--conflict-comparison">.
8722                                                  
8723                                                  This option gives the value for C<equals> and C<matches>
8724                                                  L<"--conflict-comparison">.
8725                                                  
8726                                                  This option only works with L<"--bidirectional">.
8727                                                  See L<"BIDIRECTIONAL SYNCING"> for more information.
8728                                                  
8729                                                  =item --databases
8730                                                  
8731                                                  short form: -d; type: hash
8732                                                  
8733                                                  Sync only this comma-separated list of databases.
8734                                                  
8735                                                  A common request is to sync tables from one database with tables from another
8736                                                  database on the same or different server.  This is not yet possible.
8737                                                  L<"--databases"> will not do it, and you can't do it with the D part of the DSN
8738                                                  either because in the absence of a table name it assumes the whole server
8739                                                  should be synced and the D part controls only the connection's default database.
8740                                                  
8741                                                  =item --defaults-file
8742                                                  
8743                                                  short form: -F; type: string
8744                                                  
8745                                                  Only read mysql options from the given file.  You must give an absolute pathname.
8746                                                  
8747                                                  =item --dry-run
8748                                                  
8749                                                  Analyze, decide the sync algorithm to use, print and exit.
8750                                                  
8751                                                  Implies L<"--verbose"> so you can see the results.  The results are in the same
8752                                                  output format that you'll see from actually running the tool, but there will be
8753                                                  zeros for rows affected.  This is because the tool actually executes, but stops
8754                                                  before it compares any data and just returns zeros.  The zeros do not mean there
8755                                                  are no changes to be made.
8756                                                  
8757                                                  =item --engines
8758                                                  
8759                                                  short form: -e; type: hash
8760                                                  
8761                                                  Sync only this comma-separated list of storage engines.
8762                                                  
8763                                                  =item --execute
8764                                                  
8765                                                  Execute queries to make the tables have identical data.
8766                                                  
8767                                                  This option makes mk-table-sync actually sync table data by executing all
8768                                                  the queries that it created to resolve table differences.  Therefore, B<the
8769                                                  tables will be changed!>  And unless you also specify L<"--verbose">, the
8770                                                  changes will be made silently.  If this is not what you want, see
8771                                                  L<"--print"> or L<"--dry-run">.
8772                                                  
8773                                                  =item --explain-hosts
8774                                                  
8775                                                  Print connection information and exit.
8776                                                  
8777                                                  Print out a list of hosts to which mk-table-sync will connect, with all
8778                                                  the various connection options, and exit.
8779                                                  
8780                                                  =item --float-precision
8781                                                  
8782                                                  type: int
8783                                                  
8784                                                  Precision for C<FLOAT> and C<DOUBLE> column comparisons.
8785                                                  
8786                                                  If you specify this option, FLOAT and DOUBLE columns will be rounded to the
8787                                                  specified number of digits after the decimal point for the checksum.  This can
8788                                                  avoid mismatches due to different floating-point representations of
8789                                                  the same values on different MySQL versions and hardware.
8790                                                  
8791                                                  =item --[no]foreign-key-checks
8792                                                  
8793                                                  default: yes
8794                                                  
8795                                                  Enable foreign key checks (C<SET FOREIGN_KEY_CHECKS=1>).
8796                                                  
8797                                                  Specifying C<--no-foreign-key-checks> will C<SET FOREIGN_KEY_CHECKS=0>.
8798                                                  
8799                                                  =item --function
8800                                                  
8801                                                  type: string
8802                                                  
8803                                                  Which hash function you'd like to use for checksums.
8804                                                  
8805                                                  The default is C<CRC32>.  Other good choices include C<MD5> and C<SHA1>.  If you
8806                                                  have installed the C<FNV_64> user-defined function, C<mk-table-sync> will detect
8807                                                  it and prefer to use it, because it is much faster than the built-ins.  You can
8808                                                  also use MURMUR_HASH if you've installed that user-defined function.  Both of
8809                                                  these are distributed with Maatkit.  See L<mk-table-checksum> for more
8810                                                  information and benchmarks.
8811                                                  
8812                                                  =item --help
8813                                                  
8814                                                  Show help and exit.
8815                                                  
8816                                                  =item --[no]hex-blob
8817                                                  
8818                                                  default: yes
8819                                                  
8820                                                  C<HEX()> C<BLOB>, C<TEXT> and C<BINARY> columns.
8821                                                  
8822                                                  When row data from the source is fetched to create queries to sync the
8823                                                  data (i.e. the queries seen with L<"--print"> and exeucted by L<"--execute">),
8824                                                  binary columns are wrapped in HEX() so the binary data does not produce
8825                                                  an invalid SQL statement.  You can disable this option but you probably
8826                                                  shouldn't.
8827                                                  
8828                                                  =item --host
8829                                                  
8830                                                  short form: -h; type: string
8831                                                  
8832                                                  Connect to host.
8833                                                  
8834                                                  =item --ignore-columns
8835                                                  
8836                                                  type: Hash
8837                                                  
8838                                                  Ignore this comma-separated list of column names in comparisons.
8839                                                  
8840                                                  This option causes columns not to be compared.  However, if a row is determined
8841                                                  to differ between tables, all columns in that row will be synced, regardless.
8842                                                  (It is not currently possible to exclude columns from the sync process itself,
8843                                                  only from the comparison.)
8844                                                  
8845                                                  =item --ignore-databases
8846                                                  
8847                                                  type: Hash
8848                                                  
8849                                                  Ignore this comma-separated list of databases.
8850                                                  
8851                                                  =item --ignore-engines
8852                                                  
8853                                                  type: Hash; default: FEDERATED,MRG_MyISAM
8854                                                  
8855                                                  Ignore this comma-separated list of storage engines.
8856                                                  
8857                                                  =item --ignore-tables
8858                                                  
8859                                                  type: Hash
8860                                                  
8861                                                  Ignore this comma-separated list of tables.
8862                                                  
8863                                                  Table names may be qualified with the database name.
8864                                                  
8865                                                  =item --[no]index-hint
8866                                                  
8867                                                  default: yes
8868                                                  
8869                                                  Add FORCE/USE INDEX hints to the chunk and row queries.
8870                                                  
8871                                                  By default C<mk-table-sync> adds a FORCE/USE INDEX hint to each SQL statement
8872                                                  to coerce MySQL into using the index chosen by the sync algorithm or specified
8873                                                  by L<"--chunk-index">.  This is usually a good thing, but in rare cases the
8874                                                  index may not be the best for the query so you can suppress the index hint
8875                                                  by specifying C<--no-index-hint> and let MySQL choose the index.
8876                                                  
8877                                                  This does not affect the queries printed by L<"--print">; it only affects the
8878                                                  chunk and row queries that C<mk-table-sync> uses to select and compare rows.
8879                                                  
8880                                                  =item --lock
8881                                                  
8882                                                  type: int
8883                                                  
8884                                                  Lock tables: 0=none, 1=per sync cycle, 2=per table, or 3=globally.
8885                                                  
8886                                                  This uses C<LOCK TABLES>.  This can help prevent tables being changed while
8887                                                  you're examining them.  The possible values are as follows:
8888                                                  
8889                                                    VALUE  MEANING
8890                                                    =====  =======================================================
8891                                                    0      Never lock tables.
8892                                                    1      Lock and unlock one time per sync cycle (as implemented
8893                                                           by the syncing algorithm).  This is the most granular
8894                                                           level of locking available.  For example, the Chunk
8895                                                           algorithm will lock each chunk of C<N> rows, and then
8896                                                           unlock them if they are the same on the source and the
8897                                                           destination, before moving on to the next chunk.
8898                                                    2      Lock and unlock before and after each table.
8899                                                    3      Lock and unlock once for every server (DSN) synced, with
8900                                                           C<FLUSH TABLES WITH READ LOCK>.
8901                                                  
8902                                                  A replication slave is never locked if L<"--replicate"> or L<"--sync-to-master">
8903                                                  is specified, since in theory locking the table on the master should prevent any
8904                                                  changes from taking place.  (You are not changing data on your slave, right?)
8905                                                  If L<"--wait"> is given, the master (source) is locked and then the tool waits
8906                                                  for the slave to catch up to the master before continuing.
8907                                                  
8908                                                  If C<--transaction> is specified, C<LOCK TABLES> is not used.  Instead, lock
8909                                                  and unlock are implemented by beginning and committing transactions.
8910                                                  The exception is if L<"--lock"> is 3.
8911                                                  
8912                                                  If C<--no-transaction> is specified, then C<LOCK TABLES> is used for any
8913                                                  value of L<"--lock">. See L<"--[no]transaction">.
8914                                                  
8915                                                  =item --lock-and-rename
8916                                                  
8917                                                  Lock the source and destination table, sync, then swap names.  This is useful as
8918                                                  a less-blocking ALTER TABLE, once the tables are reasonably in sync with each
8919                                                  other (which you may choose to accomplish via any number of means, including
8920                                                  dump and reload or even something like L<mk-archiver>).  It requires exactly two
8921                                                  DSNs and assumes they are on the same server, so it does no waiting for
8922                                                  replication or the like.  Tables are locked with LOCK TABLES.
8923                                                  
8924                                                  =item --password
8925                                                  
8926                                                  short form: -p; type: string
8927                                                  
8928                                                  Password to use when connecting.
8929                                                  
8930                                                  =item --pid
8931                                                  
8932                                                  type: string
8933                                                  
8934                                                  Create the given PID file.  The file contains the process ID of the script.
8935                                                  The PID file is removed when the script exits.  Before starting, the script
8936                                                  checks if the PID file already exists.  If it does not, then the script creates
8937                                                  and writes its own PID to it.  If it does, then the script checks the following:
8938                                                  if the file contains a PID and a process is running with that PID, then
8939                                                  the script dies; or, if there is no process running with that PID, then the
8940                                                  script overwrites the file with its own PID and starts; else, if the file
8941                                                  contains no PID, then the script dies.
8942                                                  
8943                                                  =item --port
8944                                                  
8945                                                  short form: -P; type: int
8946                                                  
8947                                                  Port number to use for connection.
8948                                                  
8949                                                  =item --print
8950                                                  
8951                                                  Print queries that will resolve differences.
8952                                                  
8953                                                  If you don't trust C<mk-table-sync>, or just want to see what it will do, this
8954                                                  is a good way to be safe.  These queries are valid SQL and you can run them
8955                                                  yourself if you want to sync the tables manually.
8956                                                  
8957                                                  =item --recursion-method
8958                                                  
8959                                                  type: string
8960                                                  
8961                                                  Preferred recursion method used to find slaves.
8962                                                  
8963                                                  Possible methods are:
8964                                                  
8965                                                    METHOD       USES
8966                                                    ===========  ================
8967                                                    processlist  SHOW PROCESSLIST
8968                                                    hosts        SHOW SLAVE HOSTS
8969                                                  
8970                                                  The processlist method is preferred because SHOW SLAVE HOSTS is not reliable.
8971                                                  However, the hosts method is required if the server uses a non-standard
8972                                                  port (not 3306).  Usually mk-table-sync does the right thing and finds
8973                                                  the slaves, but you may give a preferred method and it will be used first.
8974                                                  If it doesn't find any slaves, the other methods will be tried.
8975                                                  
8976                                                  
8977                                                  =item --replace
8978                                                  
8979                                                  Write all C<INSERT> and C<UPDATE> statements as C<REPLACE>.
8980                                                  
8981                                                  This is automatically switched on as needed when there are unique index
8982                                                  violations.
8983                                                  
8984                                                  =item --replicate
8985                                                  
8986                                                  type: string
8987                                                  
8988                                                  Sync tables listed as different in this table.
8989                                                  
8990                                                  Specifies that C<mk-table-sync> should examine the specified table to find data
8991                                                  that differs.  The table is exactly the same as the argument of the same name to
8992                                                  L<mk-table-checksum>.  That is, it contains records of which tables (and ranges
8993                                                  of values) differ between the master and slave.
8994                                                  
8995                                                  For each table and range of values that shows differences between the master and
8996                                                  slave, C<mk-table-checksum> will sync that table, with the appropriate C<WHERE>
8997                                                  clause, to its master.
8998                                                  
8999                                                  This automatically sets L<"--wait"> to 60 and causes changes to be made on the
9000                                                  master instead of the slave.
9001                                                  
9002                                                  If L<"--sync-to-master"> is specified, the tool will assume the server you
9003                                                  specified is the slave, and connect to the master as usual to sync.
9004                                                  
9005                                                  Otherwise, it will try to use C<SHOW PROCESSLIST> to find slaves of the server
9006                                                  you specified.  If it is unable to find any slaves via C<SHOW PROCESSLIST>, it
9007                                                  will inspect C<SHOW SLAVE HOSTS> instead.  You must configure each slave's
9008                                                  C<report-host>, C<report-port> and other options for this to work right.  After
9009                                                  finding slaves, it will inspect the specified table on each slave to find data
9010                                                  that needs to be synced, and sync it. 
9011                                                  
9012                                                  The tool examines the master's copy of the table first, assuming that the master
9013                                                  is potentially a slave as well.  Any table that shows differences there will
9014                                                  B<NOT> be synced on the slave(s).  For example, suppose your replication is set
9015                                                  up as A->B, B->C, B->D.  Suppose you use this argument and specify server B.
9016                                                  The tool will examine server B's copy of the table.  If it looks like server B's
9017                                                  data in table C<test.tbl1> is different from server A's copy, the tool will not
9018                                                  sync that table on servers C and D.
9019                                                  
9020                                                  =item --set-vars
9021                                                  
9022                                                  type: string; default: wait_timeout=10000
9023                                                  
9024                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
9025                                                  string will be appended to SET and executed.
9026                                                  
9027                                                  =item --socket
9028                                                  
9029                                                  short form: -S; type: string
9030                                                  
9031                                                  Socket file to use for connection.
9032                                                  
9033                                                  =item --sync-to-master
9034                                                  
9035                                                  Treat the DSN as a slave and sync it to its master.
9036                                                  
9037                                                  Treat the server you specified as a slave.  Inspect C<SHOW SLAVE STATUS>,
9038                                                  connect to the server's master, and treat the master as the source and the slave
9039                                                  as the destination.  Causes changes to be made on the master.  Sets L<"--wait">
9040                                                  to 60 by default, sets L<"--lock"> to 1 by default, and disables
9041                                                  L<"--[no]transaction"> by default.  See also L<"--replicate">, which changes
9042                                                  this option's behavior.
9043                                                  
9044                                                  =item --tables
9045                                                  
9046                                                  short form: -t; type: hash
9047                                                  
9048                                                  Sync only this comma-separated list of tables.
9049                                                  
9050                                                  Table names may be qualified with the database name.
9051                                                  
9052                                                  =item --timeout-ok
9053                                                  
9054                                                  Keep going if L<"--wait"> fails.
9055                                                  
9056                                                  If you specify L<"--wait"> and the slave doesn't catch up to the master's
9057                                                  position before the wait times out, the default behavior is to abort.  This
9058                                                  option makes the tool keep going anyway.  B<Warning>: if you are trying to get a
9059                                                  consistent comparision between the two servers, you probably don't want to keep
9060                                                  going after a timeout.
9061                                                  
9062                                                  =item --[no]transaction
9063                                                  
9064                                                  Use transactions instead of C<LOCK TABLES>.
9065                                                  
9066                                                  The granularity of beginning and committing transactions is controlled by
9067                                                  L<"--lock">.  This is enabled by default, but since L<"--lock"> is disabled by
9068                                                  default, it has no effect.
9069                                                  
9070                                                  Most options that enable locking also disable transactions by default, so if
9071                                                  you want to use transactional locking (via C<LOCK IN SHARE MODE> and C<FOR
9072                                                  UPDATE>, you must specify C<--transaction> explicitly.
9073                                                  
9074                                                  If you don't specify C<--transaction> explicitly C<mk-table-sync> will decide on
9075                                                  a per-table basis whether to use transactions or table locks.  It currently
9076                                                  uses transactions on InnoDB tables, and table locks on all others.
9077                                                  
9078                                                  If C<--no-transaction> is specified, then C<mk-table-sync> will not use
9079                                                  transactions at all (not even for InnoDB tables) and locking is controlled
9080                                                  by L<"--lock">.
9081                                                  
9082                                                  When enabled, either explicitly or implicitly, the transaction isolation level
9083                                                  is set C<REPEATABLE READ> and transactions are started C<WITH CONSISTENT
9084                                                  SNAPSHOT>.
9085                                                  
9086                                                  =item --trim
9087                                                  
9088                                                  C<TRIM()> C<VARCHAR> columns in C<BIT_XOR> and C<ACCUM> modes.  Helps when
9089                                                  comparing MySQL 4.1 to >= 5.0.
9090                                                  
9091                                                  This is useful when you don't care about the trailing space differences between
9092                                                  MySQL versions which vary in their handling of trailing spaces. MySQL 5.0 and 
9093                                                  later all retain trailing spaces in C<VARCHAR>, while previous versions would 
9094                                                  remove them.
9095                                                  
9096                                                  =item --[no]unique-checks
9097                                                  
9098                                                  default: yes
9099                                                  
9100                                                  Enable unique key checks (C<SET UNIQUE_CHECKS=1>).
9101                                                  
9102                                                  Specifying C<--no-unique-checks> will C<SET UNIQUE_CHECKS=0>.
9103                                                  
9104                                                  =item --user
9105                                                  
9106                                                  short form: -u; type: string
9107                                                  
9108                                                  User for login if not current user.
9109                                                  
9110                                                  =item --verbose
9111                                                  
9112                                                  short form: -v; cumulative: yes
9113                                                  
9114                                                  Print results of sync operations.
9115                                                  
9116                                                  See L<"OUTPUT"> for more details about the output.
9117                                                  
9118                                                  =item --version
9119                                                  
9120                                                  Show version and exit.
9121                                                  
9122                                                  =item --wait
9123                                                  
9124                                                  short form: -w; type: time
9125                                                  
9126                                                  How long to wait for slaves to catch up to their master.
9127                                                  
9128                                                  Make the master wait for the slave to catch up in replication before comparing
9129                                                  the tables.  The value is the number of seconds to wait before timing out (see
9130                                                  also L<"--timeout-ok">).  Sets L<"--lock"> to 1 and L<"--[no]transaction"> to 0
9131                                                  by default.  If you see an error such as the following,
9132                                                  
9133                                                    MASTER_POS_WAIT returned -1
9134                                                  
9135                                                  It means the timeout was exceeded and you need to increase it.
9136                                                  
9137                                                  The default value of this option is influenced by other options.  To see what
9138                                                  value is in effect, run with L<"--help">.
9139                                                  
9140                                                  =item --where
9141                                                  
9142                                                  type: string
9143                                                  
9144                                                  C<WHERE> clause to restrict syncing to part of the table.
9145                                                  
9146                                                  =back
9147                                                  
9148                                                  =head1 DSN OPTIONS
9149                                                  
9150                                                  These DSN options are used to create a DSN.  Each option is given like
9151                                                  C<option=value>.  The options are case-sensitive, so P and p are not the
9152                                                  same option.  There cannot be whitespace before or after the C<=> and
9153                                                  if the value contains whitespace it must be quoted.  DSN options are
9154                                                  comma-separated.  See the L<maatkit> manpage for full details.
9155                                                  
9156                                                  =over
9157                                                  
9158                                                  =item * A
9159                                                  
9160                                                  dsn: charset; copy: yes
9161                                                  
9162                                                  Default character set.
9163                                                  
9164                                                  =item * D
9165                                                  
9166                                                  dsn: database; copy: yes
9167                                                  
9168                                                  Database containing the table to be synced.
9169                                                  
9170                                                  =item * F
9171                                                  
9172                                                  dsn: mysql_read_default_file; copy: yes
9173                                                  
9174                                                  Only read default options from the given file
9175                                                  
9176                                                  =item * h
9177                                                  
9178                                                  dsn: host; copy: yes
9179                                                  
9180                                                  Connect to host.
9181                                                  
9182                                                  =item * p
9183                                                  
9184                                                  dsn: password; copy: yes
9185                                                  
9186                                                  Password to use when connecting.
9187                                                  
9188                                                  =item * P
9189                                                  
9190                                                  dsn: port; copy: yes
9191                                                  
9192                                                  Port number to use for connection.
9193                                                  
9194                                                  =item * S
9195                                                  
9196                                                  dsn: mysql_socket; copy: yes
9197                                                  
9198                                                  Socket file to use for connection.
9199                                                  
9200                                                  =item * t
9201                                                  
9202                                                  copy: yes
9203                                                  
9204                                                  Table to be synced.
9205                                                  
9206                                                  =item * u
9207                                                  
9208                                                  dsn: user; copy: yes
9209                                                  
9210                                                  User for login if not current user.
9211                                                  
9212                                                  =back
9213                                                  
9214                                                  =head1 DOWNLOADING
9215                                                  
9216                                                  You can download Maatkit from Google Code at
9217                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
9218                                                  easily with a command like the following:
9219                                                  
9220                                                     wget http://www.maatkit.org/get/toolname
9221                                                     or
9222                                                     wget http://www.maatkit.org/trunk/toolname
9223                                                  
9224                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
9225                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
9226                                                  needed.  The first URL gets the latest released version of the tool, and the
9227                                                  second gets the latest trunk code from Subversion.
9228                                                  
9229                                                  =head1 ENVIRONMENT
9230                                                  
9231                                                  The environment variable MKDEBUG enables verbose debugging output in all of the
9232                                                  Maatkit tools:
9233                                                  
9234                                                     MKDEBUG=1 mk-....
9235                                                  
9236                                                  =head1 SYSTEM REQUIREMENTS
9237                                                  
9238                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
9239                                                  installed in any reasonably new version of Perl.
9240                                                  
9241                                                  =head1 BUGS
9242                                                  
9243                                                  For a list of known bugs see: L<http://www.maatkit.org/bugs/mk-table-sync>.
9244                                                  
9245                                                  Please use Google Code Issues and Groups to report bugs or request support:
9246                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
9247                                                  discuss Maatkit.
9248                                                  
9249                                                  Please include the complete command-line used to reproduce the problem you are
9250                                                  seeing, the version of all MySQL servers involved, the complete output of the
9251                                                  tool when run with L<"--version">, and if possible, debugging output produced by
9252                                                  running with the C<MKDEBUG=1> environment variable.
9253                                                  
9254                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
9255                                                  
9256                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
9257                                                  Feedback and improvements are welcome.
9258                                                  
9259                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9260                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
9261                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9262                                                  
9263                                                  This program is free software; you can redistribute it and/or modify it under
9264                                                  the terms of the GNU General Public License as published by the Free Software
9265                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
9266                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
9267                                                  licenses.
9268                                                  
9269                                                  You should have received a copy of the GNU General Public License along with
9270                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
9271                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
9272                                                  
9273                                                  =head1 AUTHOR
9274                                                  
9275                                                  Baron Schwartz
9276                                                  
9277                                                  =head1 ABOUT MAATKIT
9278                                                  
9279                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
9280                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
9281                                                  code contributors.  Both are employed by Percona.  Financial support for
9282                                                  Maatkit development is primarily provided by Percona and its clients. 
9283                                                  
9284                                                  =head1 HISTORY AND ACKNOWLEDGEMENTS
9285                                                  
9286                                                  My work is based in part on Giuseppe Maxia's work on distributed databases,
9287                                                  L<http://www.sysadminmag.com/articles/2004/0408/> and code derived from that
9288                                                  article.  There is more explanation, and a link to the code, at
9289                                                  L<http://www.perlmonks.org/?node_id=381053>.
9290                                                  
9291                                                  Another programmer extended Maxia's work even further.  Fabien Coelho changed
9292                                                  and generalized Maxia's technique, introducing symmetry and avoiding some
9293                                                  problems that might have caused too-frequent checksum collisions.  This work
9294                                                  grew into pg_comparator, L<http://www.coelho.net/pg_comparator/>.  Coelho also
9295                                                  explained the technique further in a paper titled "Remote Comparison of Database
9296                                                  Tables" (L<http://cri.ensmp.fr/classement/doc/A-375.pdf>).
9297                                                  
9298                                                  This existing literature mostly addressed how to find the differences between
9299                                                  the tables, not how to resolve them once found.  I needed a tool that would not
9300                                                  only find them efficiently, but would then resolve them.  I first began thinking
9301                                                  about how to improve the technique further with my article
9302                                                  L<http://tinyurl.com/mysql-data-diff-algorithm>,
9303                                                  where I discussed a number of problems with the Maxia/Coelho "bottom-up"
9304                                                  algorithm.  After writing that article, I began to write this tool.  I wanted to
9305                                                  actually implement their algorithm with some improvements so I was sure I
9306                                                  understood it completely.  I discovered it is not what I thought it was, and is
9307                                                  considerably more complex than it appeared to me at first.  Fabien Coelho was
9308                                                  kind enough to address some questions over email.
9309                                                  
9310                                                  The first versions of this tool implemented a version of the Coelho/Maxia
9311                                                  algorithm, which I called "bottom-up", and my own, which I called "top-down."
9312                                                  Those algorithms are considerably more complex than the current algorithms and
9313                                                  I have removed them from this tool, and may add them back later.  The
9314                                                  improvements to the bottom-up algorithm are my original work, as is the
9315                                                  top-down algorithm.  The techniques to actually resolve the differences are
9316                                                  also my own work.
9317                                                  
9318                                                  Another tool that can synchronize tables is the SQLyog Job Agent from webyog.
9319                                                  Thanks to Rohit Nadhani, SJA's author, for the conversations about the general
9320                                                  techniques.  There is a comparison of mk-table-sync and SJA at
9321                                                  L<http://tinyurl.com/maatkit-vs-sqlyog>
9322                                                  
9323                                                  Thanks to the following people and organizations for helping in many ways:
9324                                                  
9325                                                  The Rimm-Kaufman Group L<http://www.rimmkaufman.com/>,
9326                                                  MySQL AB L<http://www.mysql.com/>,
9327                                                  Blue Ridge InternetWorks L<http://www.briworks.com/>,
9328                                                  Percona L<http://www.percona.com/>,
9329                                                  Fabien Coelho,
9330                                                  Giuseppe Maxia and others at MySQL AB,
9331                                                  Kristian Koehntopp (MySQL AB),
9332                                                  Rohit Nadhani (WebYog),
9333                                                  The helpful monks at Perlmonks,
9334                                                  And others too numerous to mention.
9335                                                  
9336                                                  =head1 VERSION
9337                                                  
9338                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 6512 $.
9339                                                  
9340                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
54    ***     50      0     52   unless $args{$arg}
124   ***     50      0     26   unless open my $fh, '<', $file
127   ***     50     26      0   if ($contents =~ /^=head1 DSN OPTIONS/m)
137   ***     50    442      0   if ($val)
138   ***     50      0    208   $val eq 'no' ? :
             100    234    208   $val eq 'yes' ? :
186   ***     50      0     52   unless open my $fh, '<', $file
194          100  62504     52   unless $para =~ /^=head1 $$self{'head1'}/
199          100     52     78   if $para =~ /^=over/
200          100     26     52   if $$self{'skip_rules'}
208   ***     50      0     52   unless $para
211          100   1794     52   if (my($option) = $para =~ /^=item $$self{'item'}/)
218          100   1404    390   if ($para =~ /: /) { }
222   ***     50      0   2080   unless $$self{'attributes'}{$attrib}
226          100    338   1066   if ($attribs{'short form'})
242   ***     50      0   1794   if $para =~ /^=item/
244          100    286   1508   if (my($base_option) = $option =~ /^\[no\](.*)/)
249          100    390   1404   $attribs{'default'} ? :
      ***     50      0   1794   $attribs{'group'} ? :
257   ***     50      0   3666   unless $para
258          100     52   3614   if ($para =~ /^=head1/)
262          100   1794   1820   if $para =~ /^=item /
266   ***     50      0     52   unless @specs
277          100   1560     52   if (ref $opt) { }
282   ***     50      0   1560   if (not $long)
287   ***     50      0   1560   if exists $$self{'opts'}{$long}
290   ***     50      0   1560   if (length $long == 1)
295          100    338   1222   if ($short) { }
296   ***     50      0    338   if exists $$self{'short_opts'}{$short}
305          100    286   1274   $$opt{'spec'} =~ /!/ ? :
306          100     26   1534   $$opt{'spec'} =~ /\+/ ? :
307   ***     50      0   1560   $$opt{'desc'} =~ /required/ ? :
320          100    260   1300   if $type and $type =~ /[HhAadzm]/
322          100    390   1170   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
323   ***     50    390      0   defined $def ? :
327          100     26   1534   if ($long eq 'config')
331   ***     50      0   1560   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
344          100     26     26   if ($opt =~ /mutually exclusive|one and only one/)
349          100     26     26   if ($opt =~ /at least one|one and only one/)
354   ***     50      0     52   if ($opt =~ /default to/)
359   ***     50      0     52   if ($opt =~ /restricted to option groups/)
369   ***     50      0     52   unless $rule_ok
386   ***     50      0    130   unless exists $$self{'opts'}{$long}
410   ***      0      0      0   unless exists $$self{'opts'}{$long}
430   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50    124      0   exists $$self{'opts'}{$opt} ? :
435          100      8    116   if ($$opt{'is_cumulative'}) { }
450          100     26   1118   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100    416   1144   exists $$self{'defaults'}{$long} ? :
459   ***     50      0     26   if (@ARGV and $ARGV[0] eq '--config')
463   ***     50     26      0   if ($self->has('config'))
469   ***     50    104      0   if ($EVAL_ERROR)
470   ***     50      0    104   $self->got('config') ? :
485   ***     50      0     26   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
488   ***     50      0     26   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
489   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
495   ***     50      0     26   if (@ARGV and $$self{'strict'})
501   ***     50      0     26   if (@set > 1)
512   ***     50      0     26   if (@set == 0)
531   ***     50      0   1560   unless $long
533          100    120   1440   if ($$opt{'got'}) { }
      ***     50      0   1440   elsif ($$opt{'is_required'}) { }
534   ***     50      0    120   if (exists $$self{'disables'}{$long})
541   ***     50      0    120   if (exists $$self{'allowed_groups'}{$long})
553   ***      0      0      0   if $restricted_opt eq $long
554   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
559   ***      0      0      0   if (@restricted_opts)
561   ***      0      0      0   if (@restricted_opts == 1) { }
582   ***     50   1560      0   if ($$opt{'parsed'}) { }
590   ***     50      0     26   if @long == $long_last
600   ***     50      0   1560   unless $opt
602          100    676    884   if (not $$opt{'type'})
609   ***     50      0    884   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    884   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    884   elsif ($val and $$opt{'type'} eq 'z') { }
             100    115    769   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     26    743   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
612   ***      0      0      0   if (not $suffix)
618   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
619   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
634   ***      0      0      0   if ($from_key)
636   ***      0      0      0   if ($$self{'opts'}{$from_key}{'parsed'}) { }
669          100    218   2238   length $opt == 1 ? :
670   ***     50      0   2456   unless $long and exists $$self{'opts'}{$long}
677   ***     50      0    144   length $opt == 1 ? :
678   ***     50      0    144   unless $long and exists $$self{'opts'}{$long}
685          100    234    112   length $opt == 1 ? :
686          100    320     26   defined $long ? :
691   ***     50      0     21   length $opt == 1 ? :
692   ***     50      0     21   unless $long and exists $$self{'opts'}{$long}
719   ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
727   ***     50      0     26   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0     26   elsif (scalar @{$$self{'errors'};}) { }
728   ***      0      0      0   unless print $self->print_usage
732   ***      0      0      0   unless print $self->print_errors
741   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
750   ***      0      0      0   unless $$self{'got_opts'}
753   ***      0      0      0   $$_{'is_negatable'} ? :
757   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
773   ***      0      0      0   $group eq 'default' ? :
779   ***      0      0      0   $$opt{'is_negatable'} ? :
782   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
791   ***      0      0      0   if ($short) { }
800   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
804   ***      0      0      0   if ($$self{'DSNParser'})
812   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
824   ***      0      0      0   if ref $_[0] eq 'OptionParser'
827   ***      0      0      0   unless print $prompt
835   ***      0      0      0   unless print "\n"
838   ***      0      0      0   if ($EVAL_ERROR)
860   ***     50    104      0   unless open my $fh, '<', $filename
868   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
871   ***      0      0      0   if ($line eq '--')
876   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
894   ***     50      0      5   unless open my $fh, '<', $file
898          100   4990      5   unless $para =~ /^=pod$/m
902          100    765      5   unless $para =~ /$regex/
907   ***     50      0      5   unless close $fh
921   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
937   ***      0      0      0   if (lc($val || '') eq 'null')
945   ***      0      0      0   if (defined $num) { }
946   ***      0      0      0   if ($factor)
962          100    338   1222   $$attribs{'short form'} ? :
             100    286   1274   $$attribs{'negatable'} ? :
             100     26   1534   $$attribs{'cumulative'} ? :
             100    884    676   $$attribs{'type'} ? :
971   ***      0      0      0   defined $_ ? :
1015         100     36    383   unless defined $val
1016         100      3    380   if $val eq ''
1017         100      1    379   if $val =~ /^0x[0-9a-fA-F]/
1027  ***     50     31      0   if (not $tbl)
1036  ***     50      0      6   unless $like
1043  ***      0      0      0   unless $db_tbl
1045  ***      0      0      0   if (not $tbl)
1049  ***      0      0      0   if $db and not $db =~ /^`/
1050  ***      0      0      0   if $tbl and not $tbl =~ /^`/
1051  ***      0      0      0   $db ? :
1087  ***     50      0     58   unless $args{$arg}
1093  ***     50      0    522   if (not $$opt{'key'} or not $$opt{'desc'})
1113         100     26    587   if (@_ > 2)
1122         100     17    127   if (not $dsn)
1134  ***     50    462      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1146         100     38   1105   if (not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'})
1152         100    643    500   if (not defined $final_props{$key})
1159  ***     50      0    462   unless exists $$opts{$key}
1164  ***     50      0    127   if (my $required = $self->prop('required'))
1166  ***      0      0      0   unless $final_props{$key}
1178  ***     50      0     26   unless ref $o eq 'OptionParser'
1181         100    208     26   if $o->has($_)
1191  ***     50      0     10   unless ref $dsn
1192  ***     50      0     10   $props ? :
1193         100     10     46   $_ eq 'p' ? :
1194         100     58     34   if defined $$dsn{$_}
1195  ***     50      0     92   unless not $props
1208  ***      0      0      0   $opts{$key}{'copy'} ? :
1222  ***     50      0    174   if ($driver eq 'Pg') { }
1254  ***     50      0    174   $cxn_string =~ /charset=utf8/ ? :
1263  ***     50      0    174   if ($$opts{'mysql_use_result'})
1267  ***     50      0    174   if (not $have_dbi)
1286  ***     50    174      0   if ($cxn_string =~ /mysql/i)
1293  ***     50      0    174   $sql_mode ? :
1300  ***     50      0    174   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1305  ***      0      0      0   if ($charset eq 'utf8') { }
1306  ***      0      0      0   unless binmode STDOUT, ':utf8'
1310  ***      0      0      0   unless binmode STDOUT
1314         100    112     62   if ($self->prop('set-vars'))
1321  ***     50      0    174   if (not $dbh and $EVAL_ERROR)
1323  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1336  ***      0      0      0   if (not $tries)
1358  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1375  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1385  ***      0      0      0   unless $dsn_1
1386  ***      0      0      0   unless $dsn_2
1390  ***      0      0      0   if ($args{'overwrite'}) { }
1391  ***      0      0      0   defined $$dsn_1{$key} ? :
1394  ***      0      0      0   defined $$dsn_2{$key} ? :
1403  ***      0      0      0   defined $_ ? :
1446         100     54     78   if (not $$self{$dbh})
1450  ***     50    132      0   $$self{$dbh} ge $self->parse($target) ? :
1457  ***      0      0      0   defined $_ ? :
1489  ***     50      0     15   unless $args{$arg}
1507  ***     50      0      6   unless $args{$arg}
1535  ***     50      0      6   $$self{'buffer_in_mysql'} ? :
1577  ***      0      0      0   defined $_ ? :
1614  ***     50      0     26   unless $args{$arg}
1623  ***     50      0     31   unless $ddl
1624  ***     50     31      0   if (ref $ddl eq 'ARRAY')
1625  ***     50     31      0   if (lc $$ddl[0] eq 'table') { }
1635  ***     50      0     31   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
1641  ***     50     31      0   if $name
1659  ***     50      0     76   unless $type
1661         100     41     35   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
1665         100     19     57   if (not $def =~ /NOT NULL/)
1669         100     10     66   $def =~ /AUTO_INCREMENT/i ? :
1700  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1714  ***     50      0      7   if ($index)
1717  ***     50      7      0   if (not $best)
1718  ***     50      0      7   if ($index) { }
1731  ***      0      0      0   unless $where
1737  ***      0      0      0   if ($$expl{'possible_keys'}) { }
1741  ***      0      0      0   if ($$expl{'key'})
1761  ***      0      0      0   unless $args{$arg}
1775  ***      0      0      0   if ($EVAL_ERROR)
1779  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
1785  ***      0      0      0   unless $args{'all_privs'}
1792  ***      0      0      0   if ($EVAL_ERROR)
1796  ***      0      0      0   if (not scalar keys %$row)
1807  ***      0      0      0   $EVAL_ERROR ? :
1812  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
1838  ***     50      0     38   if $key =~ /FOREIGN/
1843  ***     50     38      0   if (not $engine =~ /MEMORY|HEAP/)
1850  ***     50      0     38   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
1857         100     31      7   $key =~ /PRIMARY|UNIQUE/ ? :
1881         100     18     20   if ($engine =~ /InnoDB/i and not $clustered_key)
1883         100     17      1   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***     50      0      1   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
1907  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
1936  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
1946  ***      0      0      0   unless $key_ddl =~ /,$/
1953  ***      0      0      0   if (@sec_indexes)
1970  ***      0      0      0   defined $_ ? :
2000  ***     50      0     28   unless $args{'dbh'}
2009  ***     50      0    392   unless defined $args{$arg}
2024         100    476     13   !$lr && !$left_done ? :
2028         100     97    379   !$lr || $EVAL_ERROR ? :
2034         100    459     30   !$rr && !$right_done ? :
2038         100     97    362   !$rr || $EVAL_ERROR ? :
2045         100    371    118   if ($lr and $rr)
2049         100    392     97   if ($lr or $rr)
2050         100    349     43   if ($lr and $rr and defined $cmp and $cmp == 0) { }
             100     30     13   elsif (not $rr or defined $cmp and $cmp < 0) { }
2053  ***     50      0    348   if $$self{'same_row'}
2060  ***     50      0     30   if $$self{'not_in_right'}
2067  ***     50      0     13   if $$self{'not_in_left'}
2072  ***     50      0    488   if $done and &$done(%args)
2082  ***     50      0   1484   unless exists $args{$arg}
2093         100      1    488   if (not defined $l or not defined $r) { }
2095  ***     50      0      1   defined $r ? :
      ***     50      0      1   defined $l ? :
2098         100    422     66   if ($$tbl_struct{'is_numeric'}{$col}) { }
             100      1     65   elsif ($l ne $r) { }
2100  ***     50      0    422   if $trf
2102         100     21    401   if ($cmp)
2104  ***     50      0     21   if $callback
2111  ***     50      0      1   if ($coll and $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/) { }
2121  ***     50      1      0   if ($cmp)
2123  ***     50      0      1   if $callback
2134  ***      0      0      0   if (not $$self{'sth'}{$collation})
2135  ***      0      0      0   if (not $$self{'charset_for'})
2156  ***      0      0      0   defined $_ ? :
2220  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2222  ***      0      0      0   unless $ddl
2223  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2237  ***      0      0      0   if ($trgs and @$trgs) { }
2240  ***      0      0      0   if ($$trg{'sql_mode'})
2244  ***      0      0      0   if ($$trg{'definer'})
2276  ***     50      0     62   if (not $new)
2288  ***     50     62      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2301  ***     50      0     62   if ($EVAL_ERROR)
2311  ***     50     62      0   if ($key) { }
2327  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2357  ***     50     30      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2370  ***     50      0     30   if ($sth->rows)
2383  ***     50     30      0   if ($tbl)
2391  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2394  ***      0      0      0   if ($like)
2402  ***      0      0      0   unless $like
2410  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2413  ***      0      0      0   if ($like)
2428  ***      0      0      0   unless $like
2436  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2439  ***      0      0      0   if ($like)
2447  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2454  ***      0      0      0   unless $like
2462  ***      0      0      0   defined $_ ? :
2497  ***     50      0    196   unless defined $args{$arg}
2526  ***     50      0     36   unless $src
2527         100     16     20   if (lc $src eq 'left') { }
      ***     50     20      0   elsif (lc $src eq 'right') { }
2539  ***     50     36      0   if $dbh
2566         100      3     73   unless $action
2569         100      9     64   $$self{'replace'} && $action ne 'DELETE' ? :
2571         100     37     36   if ($$self{'queue'}) { }
2579  ***     50      0     36   if ($EVAL_ERROR =~ /$DUPE_KEY/) { }
      ***     50      0     36   elsif ($EVAL_ERROR) { }
2595         100     13     24   if ($$self{'replace'})
2596         100      4      9   $action eq 'DELETE' ? :
2605  ***     50      0    124   if ($queue_level and $queue_level < $$self{'queue'})
2620  ***     50     37      0   if $trace_msg
2626  ***     50      0    124   if (not $error_count++ and $EVAL_ERROR =~ /$DUPE_KEY/) { }
      ***     50      0    124   elsif ($EVAL_ERROR) { }
2650  ***     50      0     25   if ($$self{'replace'})
2656  ***     50     25      0   if (my $dbh = $$self{'fetch_back'}) { }
2677  ***     50      0     33   if ($$self{'replace'})
2692         100     30     12   if (my $dbh = $$self{'fetch_back'}) { }
2715  ***     50     80      0   defined $val ? :
2729  ***     50     67      0   if ($$self{'tbl_struct'}) { }
2736  ***     50      0    210   if (not defined $$pos{$_}) { }
2745  ***     50      0     67   if @not_in_tbl
2755  ***     50      0     55   unless $where
2758  ***     50     55      0   if ($tbl_struct)
2762         100      2    190   if ($$self{'hex_blob'} and $$tbl_struct{'type_for'}{$col} =~ /blob|text|binary/) { }
2773  ***     50      0     55   if (not $cols)
2783  ***      0      0      0   defined $_ ? :
2822  ***     50      0     52   unless $args{$arg}
2837  ***     50      0     20   unless $args{$arg}
2844  ***     50      0     28   unless $$index{'type'} eq 'BTREE'
2848  ***     50     28      0   if ($args{'exact'})
2849         100     12     16   unless $$index{'is_unique'} and @{$$index{'cols'};} == 1
2862  ***     50      0     16   unless $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2868         100     14      6   if $args{'exact'} and scalar @candidate_cols
2878         100     18      2   if ($$tbl_struct{'keys'}{'PRIMARY'})
2902  ***     50      0    126   unless defined $args{$arg}
2925  ***     50      0     14   if ($EVAL_ERROR)
2926  ***      0      0      0   if ($EVAL_ERROR =~ /don't know how to chunk/) { }
2930  ***      0      0      0   defined $args{$_} ? :
2943  ***     50      0     14   if (not defined $start_point)
2947  ***     50      0     14   if (not defined $end_point or $end_point < $start_point)
2954  ***     50      0     14   if ($args{'zero_chunk'})
2955  ***      0      0      0   if ($start_point != $end_point and $start_point >= 0) { }
2980  ***     50     14      0   if ($int_types{$col_type})
2984  ***     50      0     14   if ($args{'exact'})
2991         100     12      2   if ($start_point < $end_point) { }
2993  ***     50      0     12   if $have_zero_chunk
3000         100     12     27   if ($iter++ == 0) { }
3001  ***     50      0     12   $have_zero_chunk ? :
3012         100      5      7   if (@chunks) { }
3016         100      1      6   $nullable ? :
3018         100      1     11   if ($nullable)
3033  ***      0      0      0   unless $args{$arg}
3044  ***      0      0      0   if ($wanted_col and $wanted_idx) { }
      ***      0      0      0   elsif ($wanted_col) { }
      ***      0      0      0   elsif ($wanted_idx) { }
3046  ***      0      0      0   if ($wanted_col eq $$chunkable_col{'column'} and $wanted_idx eq $$chunkable_col{'index'})
3056  ***      0      0      0   if ($wanted_col eq $$chunkable_col{'column'})
3065  ***      0      0      0   if ($wanted_idx eq $$chunkable_col{'index'})
3081  ***     50      0     80   unless $args{$arg}
3090  ***     50      0     20   if ($suffix) { }
      ***     50     20      0   elsif ($num) { }
3091  ***      0      0      0   $suffix eq 'M' ? :
      ***      0      0      0   $suffix eq 'k' ? :
3103  ***     50      0     20   if ($suffix or $args{'avg_row_length'})
3106  ***      0      0      0   if (not defined $n_rows)
3107  ***      0      0      0   $avg_row_length ? :
3118  ***     50      0     70   unless $args{$arg}
3132  ***     50     14      0   $args{'index_hint'} ? :
             100      2     12   $where ? :
3150  ***     50      0     14   if ($EVAL_ERROR)
3155  ***     50     14      0   $args{'index_hint'} ? :
             100      2     12   $where ? :
3171  ***     50      0    560   unless defined $args{$arg}
3180         100     18     94   if ($args{'where'} and grep {$_;} @{$args{'where'};})
3203  ***     50      0     84   unless defined $args{$arg}
3216  ***     50     28      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type =~ /^(?:timestamp|date|time)$/) { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
3239  ***     50      0     14   unless $col_type
3241  ***     50     14      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type =~ /^(?:timestamp|date|time)$/) { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
3258  ***     50      0     39   if $start =~ /e/
3259  ***     50      0     39   if $end =~ /e/
3264  ***     50     39      0   if ($end > $start) { }
3310  ***      0      0      0   unless $check eq $time
3327  ***     50      0     56   unless $args{$arg}
3332         100      2     12   $args{'where'} ? :
3339  ***     50     14      0   if (defined $valid_min)
3346  ***     50      0     14   unless defined $valid_min
3351  ***     50     14      0   if (defined $valid_max)
3358  ***     50      0     14   unless defined $valid_max
3369  ***     50      0    112   unless $args{$arg}
3374  ***     50      0     28   unless defined $val
3376  ***     50      0     28   $col_type =~ /time|date/ ? :
3379  ***     50     28      0   if (not $validate)
3384  ***      0      0      0   if defined &$validate($dbh, $val)
3400  ***      0      0      0   unless $args{$arg}
3403  ***      0      0      0   defined $args{'tries'} ? :
3406  ***      0      0      0   unless defined $val
3408  ***      0      0      0   $endpoint =~ /max/i ? :
      ***      0      0      0   $endpoint =~ /min/i ? :
3411  ***      0      0      0   $args{'index_hint'} ? :
      ***      0      0      0   $args{'where'} ? :
3424  ***      0      0      0   if (not defined $next_val)
3428  ***      0      0      0   if (defined &$validate($dbh, $next_val))
3452  ***      0      0      0   if ($EVAL_ERROR)
3462  ***      0      0      0   unless $args{$arg}
3465  ***      0      0      0   defined $args{'tries'} ? :
3469  ***      0      0      0   $col_type =~ /time|date/ ? :
3471  ***      0      0      0   if (not &$is_nonzero($dbh, $val))
3473  ***      0      0      0   $args{'index_hint'} ? :
      ***      0      0      0   $args{'where'} ? :
3485  ***      0      0      0   if (&$is_nonzero($dbh, $next_val))
3501  ***      0      0      0   defined $_ ? :
3539  ***     50      0     52   unless defined $args{$arg}
3552  ***      0      0      0   $comp & 1 ? :
3562  ***     50     20      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64')
3582         100     19      1   if ($type eq 'bigint' and $length < 20)
3596  ***     50      0     40   if $alg and not $ALGOS{$alg}
3599  ***     50     40      0   if ($args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1'))
3608  ***     50      0     40   if (not $vp->version_ge($dbh, '4.1.1'))
3613  ***     50     40      0   if ($alg and grep {$_ eq $alg;} @choices)
3618  ***      0      0      0   if ($args{'count'} and grep {$_ ne 'CHECKSUM';} @choices)
3635         100      2     38   if ($args{'function'})
3648  ***     50      0     40   if ($EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/)
3654  ***     50      0     40   unless $result
3663  ***     50      0      1   if $func =~ /^(?:FNV1A_64|FNV_64|CRC32)$/i
3670  ***     50      0      1   length $unsliced < 16 ? :
3683         100      1      1   if ($sliced ne $unsliced)
3690  ***     50      1      0   if ($sliced eq $unsliced) { }
3703  ***     50      0      6   unless defined $args{$arg}
3710         100      3      3   if ($len > 16)
3719  ***     50      3      0   if (defined $opt_slice and $opt_slice < @slices) { }
3742  ***     50     40      0   $args{'cols'} ? :
3746  ***     50    120      0   if $cols{$_}
3748         100     14    106   if ($type eq 'timestamp') { }
      ***     50      0    106   elsif ($args{'float_precision'} and $type =~ /float|double/) { }
             100      2    104   elsif ($args{'trim'} and $type =~ /varchar/) { }
3765         100     20     20   if (not $args{'no_cols'})
3769         100      7     53   if ($col =~ /\+ 0/) { }
             100      1     52   elsif ($col =~ /TRIM/) { }
3782  ***     50     40      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64') { }
3784         100     28     12   if (@nulls)
3791  ***     50     40      0   @cols > 1 ? :
3807  ***     50      0    120   unless $args{$arg}
3815  ***     50      0     20   unless $algorithm and $ALGOS{$algorithm}
3818  ***     50      0     20   if ($algorithm eq 'CHECKSUM')
3824  ***     50     20      0   if ($algorithm eq 'BIT_XOR') { }
3825         100     19      1   if ($crc_type =~ /int$/) { }
3834  ***      0      0      0   if ($crc_type =~ /int$/) { }
3847  ***     50      0     20   if ($args{'replicate'}) { }
3853  ***     50      0     20   $args{'buffer'} ? :
3883  ***      0      0      0   defined $_ ? :
3920  ***     50      0     38   unless defined $args{$arg}
3939  ***     50      0     20   unless defined $args{$arg}
3946         100      6     14   unless $exact
3949  ***     50      0     14   if ($args{'chunk_col'} or $args{'chunk_index'}) { }
3953  ***      0      0      0   if ($args{'chunk_col'})
3954  ***      0      0      0   unless $chunkable_cols[$i]{'column'} eq $args{'chunk_col'}
3956  ***      0      0      0   if ($args{'chunk_index'})
3957  ***      0      0      0   unless $chunkable_cols[$i]{'index'} eq $args{'chunk_index'}
3963  ***      0      0      0   if (not $colno)
3987  ***     50      0    126   unless defined $args{$arg}
4003  ***     50     14      0   if (not grep {not defined $range_params{$_};} 'min', 'max', 'rows_in_range') { }
4025  ***     50      0     14   unless $chunk_sql
4026  ***     50      0     14   unless $row_sql
4042         100     56     84   if ($$self{'state'}) { }
4051  ***     50      0     56   $$self{'buffer_in_mysql'} ? :
             100      6     50   $args{'where'} ? :
4070         100    181     42   if ($$self{'state'}) { }
             100     28     14   elsif ($$lr{'cnt'} != $$rr{'cnt'} or $$lr{'crc'} ne $$rr{'crc'}) { }
4071         100     33    148   if ($$lr{$$self{'crc_col'}} ne $$rr{$$self{'crc_col'}})
4076         100     26      7   if ($$self{'same_row'})
4097  ***     50      0     10   unless $$self{'state'}
4103         100      7      3   if ($$self{'not_in_right'})
4118  ***     50      0      8   unless $$self{'state'}
4124         100      7      1   if ($$self{'not_in_left'})
4139         100     28     41   if ($$self{'state'} == 1) { }
4163         100     28     28   if ($$self{'state'}) { }
4176         100     42    138   if ($$self{'state'} == 0) { }
4188  ***      0      0      0   defined $_ ? :
4225  ***     50      0     64   unless defined $args{$arg}
4238  ***     50      0      7   unless defined $args{$arg}
4242         100      6      1   if ($nibble_index) { }
4244  ***     50      0      6   if (not $args{'tbl_struct'}{'keys'}{$nibble_index}{'is_unique'})
4248  ***     50      0      6   if ($args{'chunk_index'} and $args{'chunk_index'} ne $nibble_index)
4260  ***     50      6      0   if ($args{'src'} and $args{'src'}{'dbh'})
4272  ***     50      6      0   if ($table_status)
4273  ***      0      0      0   defined $$table_status{'rows'} ? :
      ***     50      6      0   defined $$table_status{'Rows'} ? :
4276         100      4      2   if defined $n_rows and $n_rows <= 100
4295  ***     50      0     54   unless defined $args{$arg}
4335  ***     50      0      6   unless $nibble_sql
4336  ***     50      0      6   unless $row_sql
4352         100     12     28   if ($$self{'state'}) { }
4361  ***     50      0     12   $$self{'buffer_in_mysql'} ? :
      ***     50     12      0   $$self{'index_hint'} ? :
             100      4      8   $args{'where'} ? :
4386         100     26     14   if ($$self{'cached_boundaries'})
4391  ***     50      0     14   if ($$self{'cached_row'} and $$self{'cached_nibble'} == $$self{'nibble'}) { }
4400         100      2     12   if ($$self{'nibble'} == 0 and not $$self{'small_table'})
4402  ***     50      0      2   if (lc($explain_index || '') ne lc $$s{'index'})
4403  ***      0      0      0   $explain_index ? :
4414         100      8      6   if ($row) { }
4424         100      8      6   $lb ? :
4440         100      4     10   $args{'where'} ? :
4445         100      8      6   if ($$self{'nibble'})
4450         100      2      6   $args{'where'} ? :
4461  ***     50      0      2   unless $sql
4466  ***     50      0      2   if ($EVAL_ERROR)
4477         100    106     14   if ($$self{'state'}) { }
             100      6      8   elsif ($$lr{'cnt'} != $$rr{'cnt'} or $$lr{'crc'} ne $$rr{'crc'}) { }
4478         100      1    105   if ($$lr{$$self{'crc_col'}} ne $$rr{$$self{'crc_col'}})
4491  ***     50      0      8   unless $$self{'state'}
4497  ***     50      0      4   unless $$self{'state'}
4503         100      6     14   if ($$self{'state'} == 1) { }
4525         100      6      8   if ($$self{'state'}) { }
4538         100     14     31   if ($$self{'state'} == 0) { }
4550  ***      0      0      0   defined $_ ? :
4582  ***     50      0     16   unless $args{$arg}
4600  ***     50      0     15   unless defined $args{$arg}
4634  ***     50      0     10   $$self{'buffer_in_mysql'} ? :
4649  ***     50      3      0   unless $diff
4655  ***      0      0      0   if ($lc > $rc) { }
4706  ***      0      0      0   defined $_ ? :
4743  ***     50      0    104   unless defined $args{$arg}
4752  ***     50      0     56   unless $args{$arg}
4758         100     28      7   if ($can_sync)
4772  ***     50      0    224   unless $args{$arg}
4781  ***     50     28      0   unless defined $args{'trace'}
4783  ***     50      0     28   if ($args{'bidirectional'} and $args{'ChangeHandler'}{'queue'})
4787  ***     50      0     28   unless defined $args{'index_hint'}
4797  ***     50      0     28   unless $plugin
4806  ***     50     28      0   $vp->version_ge($$src{'dbh'}, '4.0.9') && $vp->version_ge($$dst{'dbh'}, '4.0.9') ? :
4809  ***     50      0     28   if ($args{'chunk_index'}) { }
             100     20      8   elsif ($plugin_args{'chunk_index'} and $args{'index_hint'}) { }
4830  ***     50      0     28   if ($EVAL_ERROR)
4835         100     20      8   if ($plugin->uses_checksum)
4840  ***     50      0     20   if ($EVAL_ERROR)
4845  ***     50      0     28   if ($args{'dry_run'})
4854  ***     50      0     28   if ($EVAL_ERROR)
4866  ***     50      0     28   $dp && $$src{'dsn'} ? :
      ***     50      0     28   $dp && $$dst{'dsn'} ? :
      ***     50     28      0   $args{'trace'} ? :
4889         100     76     22   if ($args{'transaction'})
4890         100     51     25   if ($args{'bidirectional'}) { }
             100      6     19   elsif ($args{'changing_src'}) { }
4906         100     12     86   if $callback
4913         100     47     51   if ($args{'buffer_to_client'})
4919         100     64     34   if (not $cycle or not $plugin->pending_changes)
4924         100     94      4   unless $executed_src
4952  ***     50      0     60   unless $args{$arg}
4971  ***     50      0     20   if ($src_algo ne $dst_algo)
4979  ***     50      0     20   if ($src_func ne $dst_func)
4989         100      1     19   if ($src_algo eq 'BIT_XOR' and not $crc_type =~ /int$/)
5028  ***     50      0    135   unless defined $args{$arg}
5033         100     21      6   unless $args{'lock'} and $args{'lock'} <= $args{'lock_level'}
5036         100      4      8   if ($args{'transaction'}) { }
5055  ***     50      0    368   unless defined $args{$arg}
5060         100     80     12   unless $args{'lock'} and $args{'lock'} == $args{'lock_level'}
5064         100      8     16   if ($args{'transaction'}) { }
5075  ***     50      0     12   if ($args{'lock'} == 3) { }
5081         100      4      8   if ($args{'transaction'}) { }
5082  ***     50      4      0   if ($args{'src_sth'})
5094  ***     50      8      0   $args{'changing_src'} ? :
5101  ***     50     12      0   if ($args{'wait'})
5106  ***     50     12      0   if ($args{'changing_src'}) { }
5111  ***      0      0      0   if ($args{'lock'} == 3) { }
      ***      0      0      0   elsif (not $args{'transaction'}) { }
5117  ***      0      0      0   $args{'execute'} ? :
5124  ***     50      0     12   if ($EVAL_ERROR)
5125  ***      0      0      0   if ($args{'src_sth'}{'Active'})
5129  ***      0      0      0   unless $dbh
5132  ***      0      0      0   unless $$dbh{'AutoCommit'}
5151         100      1     58   $EVAL_ERROR ? :
5155         100     58      1   if ($privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/ and $can_delete)
5166  ***      0      0      0   defined $_ ? :
5199  ***     50      0     52   unless $args{$arg}
5209  ***     50      0     12   unless defined $args{$arg}
5212  ***     50      6      0   $args{'cols'} ? :
5215  ***     50      0      6   unless exists $$tbl_struct{'keys'}{$index}
5224  ***     50      0      6   if ($args{'asc_first'})
5231  ***     50      0     13   if (not exists $col_posn{$col})
5247  ***     50      6      0   if (@asc_slice)
5259  ***     50      6      0   $args{'asc_only'} ? :
5271  ***     50      0     96   unless defined $args{$arg}
5292         100      4     28   if ($$is_nullable{$col}) { }
5308         100      8     44   if ($$is_nullable{$col}) { }
5309         100      2      6   if ($type =~ /=/ and $end) { }
             100      3      3   elsif ($type =~ />/) { }
5324         100     10     34   $type =~ /=/ && $end ? :
5342  ***      0      0      0   $args{'cols'} ? :
5350  ***      0      0      0   unless $index
5352  ***      0      0      0   if ($index) { }
5362  ***      0      0      0   if (not exists $col_posn{$col})
5383  ***      0      0      0   if ($$tbl{'is_nullable'}{$col}) { }
5403  ***      0      0      0   unless $args{$arg}
5408  ***      0      0      0   unless @sel_cols
5413  ***      0      0      0   unless $$ins_tbl{'is_col'}{$sel_cols[$i]}
5426  ***      0      0      0   defined $_ ? :
5477  ***      0      0      0   if ($EVAL_ERROR)
5478  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
5488  ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
5493  ***      0      0      0   if ($$args{'skip_callback'})
5501  ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
5503  ***      0      0      0   unless not $$_{'master_id'}
5520  ***      0      0      0   if ($method) { }
5525  ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
5539  ***      0      0      0   if @slaves
5557  ***      0      0      0   if ($host eq 'localhost')
5574  ***      0      0      0   if (@slaves)
5579  ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
5599  ***     50      0      5   if ($vp and not $vp->version_ge($dbh, '4.1.2'))
5612  ***     50      0      5   if ($EVAL_ERROR)
5614  ***      0      0      0   if ($EVAL_ERROR =~ /no such grant defined for user/)
5627  ***      0      0      0   if $EVAL_ERROR
5629  ***     50      0      5   if (not $proc)
5646  ***     50      0      5   unless my $master_status = $self->get_master_status($master)
5648  ***     50      0      5   unless my $slave_status = $self->get_slave_status($slave)
5650  ***     50      0      5   unless my(@connected) = $self->get_connected_slaves($master)
5654  ***     50      0      5   if ($port != $$slave_status{'master_port'})
5659  ***     50      0      5   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
5664  ***     50      5      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
5671  ***     50      0      5   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
5684  ***     50      0      5   unless my $master = $self->get_slave_status($dbh)
5691  ***     50     33      0   if (not $$self{'not_a_slave'}{$dbh})
5698         100     18     15   if ($ss and %$ss)
5710  ***     50     17      0   if (not $$self{'not_a_master'}{$dbh})
5717  ***     50     17      0   if ($ms and %$ms)
5719  ***     50     17      0   if ($$ms{'file'} and $$ms{'position'})
5732  ***     50      0     12   unless defined $time
5736  ***     50     12      0   if ($ms) { }
5740  ***     50     12      0   defined $result ? :
5742  ***     50      0     12   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
5762  ***      0      0      0   if ($pos) { }
5786  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
5792  ***      0      0      0   if ($EVAL_ERROR)
5794  ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
5796  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
5801  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
5825  ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
5837  ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
5860  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5864  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5869  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
5883  ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
5898  ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
5909  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
5913  ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5917  ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5919  ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
5922  ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
5924  ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
5936  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
5948  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
5952  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5956  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5959  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
5962  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
5966  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
5968  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
5976  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
5990  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
6001  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
6023  ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
6051  ***      0      0      0   if ($$dsn{'master_host'}) { }
6059  ***      0      0      0   ($port || 3306) == 3306 ? :
6064  ***      0      0      0   unless $query
6067  ***      0      0      0   unless $type =~ /binlog_dump|slave_io|slave_sql|all/i
6071  ***      0      0      0   if ($type =~ /binlog_dump|all/i)
6072  ***      0      0      0   if ($$query{'Command'} || $$query{'command'} || '') eq 'Binlog Dump'
6075  ***      0      0      0   if (not $match)
6076  ***      0      0      0   if (($$query{'User'} || $$query{'user'} || '') eq 'system user') { }
6078  ***      0      0      0   if ($type =~ /slave_io|all/i)
6090  ***      0      0      0   if (not $match and $type =~ /slave_sql|all/i)
6111  ***      0      0      0   unless $args{$arg}
6118  ***      0      0      0   if ($status)
6119  ***      0      0      0   if defined $$status{$_}
6128  ***      0      0      0   if ($status)
6129  ***      0      0      0   if defined $$status{$_}
6143  ***      0      0      0   if $$row[1] and $$row[1] ne 'OFF'
6157  ***      0      0      0   defined $_ ? :
6191  ***      0      0      0   unless $args{$arg}
6194  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
6210  ***      0      0      0   unless defined(my $pid = fork)
6211  ***      0      0      0   if ($pid)
6219  ***      0      0      0   unless POSIX::setsid()
6220  ***      0      0      0   unless chdir '/'
6226  ***      0      0      0   if (-t STDIN)
6228  ***      0      0      0   unless open STDIN, '/dev/null'
6232  ***      0      0      0   if ($$self{'log_file'}) { }
6234  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
6238  ***      0      0      0   unless open STDERR, '>&STDOUT'
6242  ***      0      0      0   if (-t STDOUT)
6244  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
6247  ***      0      0      0   if (-t STDERR)
6249  ***      0      0      0   unless open STDERR, '>', '/dev/null'
6260  ***      0      0      0   $self ? :
6262  ***      0      0      0   if ($PID_file and -f $PID_file) { }
6265  ***      0      0      0   if $EVAL_ERROR
6267  ***      0      0      0   if ($pid) { }
6269  ***      0      0      0   if ($pid_is_alive) { }
6291  ***      0      0      0   if (exists $$self{'child'})
6303  ***      0      0      0   if (not $PID_file)
6310  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
6312  ***      0      0      0   unless print $PID_FH $PID
6314  ***      0      0      0   unless close $PID_FH
6323  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
6324  ***      0      0      0   unless unlink $$self{'PID_file'}
6337  ***      0      0      0   if ($$self{'PID_owner'} || 0) == $PID
6344  ***      0      0      0   defined $_ ? :
6380  ***     50      0      9   unless $args{$arg}
6399  ***     50     10      0   if $o->has('databases')
6401  ***     50     10      0   if $o->has('ignore-databases')
6404  ***     50      0     10   if ($o->has('databases-regex') and my $p = $o->get('databases-regex'))
6408  ***     50      0     10   if ($o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex'))
6412         100      9      1   if (@permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex)
6413  ***     50      9      0   @permit_dbs ? :
      ***     50      0      9   @reject_dbs ? :
      ***     50      0      9   @dbs_regex ? :
      ***     50      0      9   @reject_dbs_regex ? :
6422  ***     50     10      0   if ($o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex'))
6432         100      2      8   if ($o->get('tables'))
6435  ***     50      2      0   if ($_ =~ /\./) { }
6445  ***     50      2      0   if (@permit_qtbls)
6455  ***     50     10      0   if ($o->get('ignore-tables'))
6458  ***      0      0      0   if ($_ =~ /\./) { }
6468  ***     50      0     10   if (@reject_qtbls and not $have_qtbl)
6474         100      1      9   if (keys %permit_qtbls and not @permit_dbs)
6482  ***     50      1      0   if (keys %$dbs)
6489  ***     50      0      9   if ($o->has('tables-regex') and my $p = $o->get('tables-regex'))
6493  ***     50      0      9   if ($o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex'))
6502  ***     50      9      0   if ($o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines'))
6521  ***     50      9      0   if (@permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs)
6523  ***     50      0      9   @permit_tbls ? :
      ***     50      0      9   @reject_tbls ? :
      ***     50      0      9   @tbls_regex ? :
      ***     50      0      9   @reject_tbls_regex ? :
             100      1      8   @permit_qtbls ? :
      ***     50      0      9   @reject_qtbls ? :
      ***     50      9      0   @get_eng ? :
      ***     50      0      9   @permit_engs ? :
      ***     50      9      0   @reject_engs ? :
6544  ***     50      0      9   unless my $filter_sub = eval $code
6561  ***     50      0      9   unless $args{$arg}
6570  ***     50     36      0   $filter ? :
6572         100      9     27   if $_ =~ /information_schema|lost\+found/
6587  ***     50      0     18   unless $args{$arg}
6593  ***     50      9      0   if ($db) { }
6603  ***     50      9      0   $filter ? :
6604  ***     50      9      0   if (not $views)
6605  ***     50      0      9   if ($type || '') eq 'VIEW'
6625         100     20     42   if (scalar keys %$objs)
6626         100     18     11   $lc ? :
6635  ***      0      0      0   defined $_ ? :
6689  ***      0      0      0   defined $args{'p_ms'} ? :
6690  ***      0      0      0   defined $args{'p_s'} ? :
6693  ***      0      0      0   if $t < 0
6695  ***      0      0      0   if $t =~ /e/
6699  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
6720  ***      0      0      0   $p ? :
6727  ***      0      0      0   unless $secs
6729  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
6734  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
6753  ***     50      0     11   unless defined $val
6757  ***     50     11      0   if ($suffix =~ /[smhd]/) { }
6758  ***     50      0      2   $suffix eq 'h' ? :
             100      9      2   $suffix eq 'm' ? :
      ***     50      0     11   $suffix eq 's' ? :
6763  ***     50      0     11   if $prefix and $prefix eq '-'
6773  ***      0      0      0   defined $args{'p'} ? :
6774  ***      0      0      0   defined $args{'d'} ? :
6781  ***      0      0      0   $num =~ /\./ || $n ? :
6790  ***      0      0      0   $gmt ? :
6796  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
6806  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
6809  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
6818  ***     50     12      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
6819  ***     50      0     12   $gmt ? :
6822  ***     50      0     12   if (defined $us)
6834  ***     50      0     22   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
             100     10     12   elsif ($val =~ /^\d{9,}/) { }
      ***     50      0     12   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***     50     12      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
6835  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
6849  ***      0      0      0   unless $hms
6854         100      4      8   unless $hms
6859  ***      0      0      0   if $callback and ref $callback eq 'CODE'
6875  ***      0      0      0   defined $_ ? :
6929         100      5     21   if ($o->get('replicate') or $o->get('sync-to-master'))
6930  ***     50      5      0   unless $o->got('wait')
6932         100      5     21   if ($o->get('wait'))
6933  ***     50      5      0   unless $o->got('lock')
6935  ***     50      0     26   if ($o->get('dry-run'))
6951  ***     50      0     51   if $$dsn{'t'} and not $$dsn{'D'}
6953  ***     50      0     51   if ($$dsn{'D'} and not $$dsn{'t'})
6961  ***     50      0     26   if (not @dsns or @dsns == 1 and not $o->get('replicate') and not $o->get('sync-to-master'))
6967  ***     50      0     26   if (@dsns > 1 and $o->get('sync-to-master') and $o->get('replicate'))
6972  ***     50      0     26   if ($o->get('lock-and-rename'))
6973  ***      0      0      0   if (@dsns != 2 or not $dsns[0]{'t'} or not $dsns[1]{'t'})
6979         100      5     21   if ($o->get('bidirectional'))
6980  ***     50      0      5   if ($o->get('replicate') or $o->get('sync-to-master'))
6984  ***     50      0      5   if (@dsns < 2)
6987  ***     50      0      5   if (not $o->get('conflict-column') or not $o->get('conflict-comparison'))
6994  ***     50      0      5   if ($cc and not $cc =~ /$cmp/)
6997  ***     50      0      5   if ($cc and $cc =~ /equals|matches/ and not $o->get('conflict-value'))
7007  ***     50      0     26   if ($o->get('explain-hosts'))
7020  ***     50      0     26   if ($o->get('pid'))
7068  ***     50      0     66   if $EVAL_ERROR
7076         100      5     21   if ($o->get('bidirectional'))
7089         100      5     21   if ($o->get('sync-to-master'))
7092  ***     50      0      5   unless my $master = $ms->get_master_dsn($dsns[0]{'dbh'}, $dsns[0], $dp)
7096  ***     50      5      0   if ($o->get('check-master'))
7108  ***     50      0     26   if ($o->get('dry-run'))
7115  ***     50      0     26   if ($o->get('lock-and-rename')) { }
             100     14     12   elsif ($dsns[0]{'t'}) { }
             100      3      9   elsif ($o->get('replicate')) { }
7140  ***      0      0      0   unless $args{$arg}
7163  ***      0      0      0   if ($o->get('verbose'))
7212  ***     50      0     98   unless $args{$arg}
7237         100      6     10   if ($o->get('verbose'))
7238  ***     50      0      6   $o->get('dry-run') ? :
7266  ***     50      0     27   unless $args{$arg}
7293  ***     50      3      0   if ($o->get('sync-to-master')) { }
7318         100      2      1   if ($o->get('verbose'))
7319  ***     50      0      2   $o->get('dry-run') ? :
7326  ***     50      3      0   if (@diffs) { }
7363  ***      0      0      0   if (not $level) { }
7377  ***      0      0      0   if ($o->get('verbose'))
7378  ***      0      0      0   $o->get('dry-run') ? :
7385  ***      0      0      0   if (@diffs) { }
7432  ***     50      0     81   unless $args{$arg}
7472  ***     50      0     11   if ($o->get('verbose'))
7473  ***      0      0      0   $o->get('dry-run') ? :
7512  ***     50      0    150   unless $args{$arg}
7516  ***     50     30      0   unless $o->get('lock') and $o->get('lock') == 3
7529  ***      0      0      0   if ($EVAL_ERROR)
7539  ***     50      0    150   unless $args{$arg}
7543  ***     50     30      0   unless $o->get('lock') and $o->get('lock') == 3
7566  ***      0      0      0   if ($EVAL_ERROR)
7581  ***     50      0    248   unless $args{$arg}
7593         100     18     12   $$tbl_struct{'engine'} eq 'InnoDB' ? :
      ***     50      0     30   $o->got('transaction') ? :
7606  ***     50     30      0   unless $o->get('columns')
7611         100      7     23   if (my $conflict_col = $o->get('conflict-column'))
7613  ***     50      0      7   unless grep {$_ eq $conflict_col;} @compare_columns
7619         100      3     27   if ($o->get('print') and $o->get('verbose') >= 2)
7629         100     21      7   $o->get('buffer-to-client') ? :
7676         100     26      1   if (sum @status{@ChangeHandler::ACTIONS})
7681         100      4     27   if ($EVAL_ERROR)
7687         100      9     22   if ($o->get('verbose'))
7688         100     27     45   unless $_
7701  ***     50      0    180   unless $args{$arg}
7707         100      6     24   if ($o->get('sync-to-master') or $o->get('replicate')) { }
             100     23      1   elsif ($o->get('check-slave')) { }
7712  ***     50      0      6   unless $can_replace
7732         100      2     21   if ($slave_status and $sql_log_bin and ($log_bin || 'OFF') eq 'ON')
7747  ***     50      0     56   unless $args{$arg}
7752         100     15     13   if ($o->get('execute'))
7761  ***     50     28      0   if ($o->get('print'))
7768         100     36     37   if $dbh
7769         100     36     37   if ($dsn)
7772  ***     50     36      0   $p ? :
7774  ***     50      0     73   unless print $sql, ";\n"
7784  ***     50      0      4   if not defined $msg
7787  ***     50      4      0   if ($database and $table)
7790  ***     50      4      0   if ($host)
7800  ***     50      0    224   unless $args{$arg}
7804  ***     50      0    112   if (not $$dsn{'p'} and $o->get('ask-pass'))
7809  ***      0      0      0   $$dsn{'h'} ? :
7818         100     24     88   if (not $o->get('bin-log'))
7823  ***     50      0    112   if (not $o->get('unique-checks'))
7828  ***     50      0    112   if (not $o->get('foreign-key-checks'))
7846  ***     50      0    112   if ($o->get('transaction'))
7852  ***      0      0      0   if $EVAL_ERROR
7866  ***     50      0    279   unless $args{$arg}
7882  ***     50      0     31   if $EVAL_ERROR
7891  ***     50      0     31   if $EVAL_ERROR
7901         100     30      1   if ($o->get('check-privileges'))
7903         100      1     29   if (not $syncer->have_all_privs($$src{'dbh'}, $$src{'db'}, $$src{'tbl'}))
7907  ***     50      0     29   if (not $syncer->have_all_privs($$dst{'dbh'}, $$dst{'db'}, $$dst{'tbl'}))
7914  ***     50     30      0   if ($o->get('check-triggers'))
7916         100     29      1   if (not defined $$dst{'supports_triggers'})
7919  ***     50      0     30   if ($$dst{'supports_triggers'} and $du->get_triggers($$dst{'dbh'}, $q, $$dst{'db'}, $$dst{'tbl'})) { }
7934  ***     50      4      0   if not $$skip_table{$$_{'db'}}{$$_{'tbl'}} and !$databases || $$databases{$$_{'db'}}
7946  ***     50      0    112   unless $dbh
7948         100     68     44   unless $$dbh{'AutoCommit'}
7960  ***     50     12      0   if $src_sql
7961  ***     50     12      0   if $dst_sql
7979         100     41     12   if ($cmp eq 'newest' or $cmp eq 'oldest') { }
             100      5      7   elsif ($cmp eq 'greatest' or $cmp eq 'least') { }
             100      3      4   elsif ($cmp eq 'equals') { }
             100      3      1   elsif ($cmp eq 'matches') { }
7980         100     35      6   $cmp eq 'newest' ? :
7983         100     11     30   if ($thr)
7990         100      5      6   if ($diff < $thr)
7997         100      1      1   ($left_val || 0) > ($right_val || 0) ? :
      ***     50      0      3   ($left_val || 0) < ($right_val || 0) ? :
             100      2      3   $cmp eq 'greatest' ? :
7999         100      1      4   if ($left_val || 0) == ($right_val || 0)
8000         100      2      3   if ($thr)
8003         100      1      1   if ($diff < $thr)
8010         100      1      1   ($right_val || '') eq $val ? :
             100      1      2   ($left_val || '') eq $val ? :
8015         100      1      1   ($right_val || '') =~ /$val/ ? :
             100      1      2   ($left_val || '') =~ /$val/ ? :
8030  ***     50      0     10   unless $args{$arg}
8058         100     13     13   if ($res == -1) { }
             100      9      4   elsif ($res == 1) { }
             100      2      2   elsif ($res == 0) { }
      ***     50      2      0   elsif ($res == 2) { }
8073  ***     50      0      2   if ($cmp eq 'equals' or $cmp eq 'matches') { }
8088         100      4     22   if ($err)
8095         100      3      1   $o->get('conflict-error') eq 'warn' ? :
8118  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
2868  ***     50      0     20   $args{'exact'} and scalar @candidate_cols

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
320          100    676    624    260   $type and $type =~ /[HhAadzm]/
459   ***     33      0     26      0   @ARGV and $ARGV[0] eq '--config'
488   ***     33      0     26      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
495   ***     33      0     26      0   @ARGV and $$self{'strict'}
609   ***     66    691    193      0   $val and $$opt{'type'} eq 'm'
      ***     66    691    193      0   $val and $$opt{'type'} eq 'd'
      ***     66    691    193      0   $val and $$opt{'type'} eq 'z'
             100    613    156     11   defined $val and $$opt{'type'} eq 'h'
      ***     66    613    130      0   defined $val and $$opt{'type'} eq 'a'
670   ***     33      0      0   2456   $long and exists $$self{'opts'}{$long}
678   ***     33      0      0    144   $long and exists $$self{'opts'}{$long}
692   ***     33      0      0     21   $long and exists $$self{'opts'}{$long}
782   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
876   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1049  ***      0      0      0      0   $db and not $db =~ /^`/
1050  ***      0      0      0      0   $tbl and not $tbl =~ /^`/
1146         100    462    643     38   not defined $final_props{$key} and defined $$prev{$key}
      ***     66   1105      0     38   not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'}
1279  ***     66    174      0    174   not $dbh and $tries--
1321  ***     33    174      0      0   not $dbh and $EVAL_ERROR
1812  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
1850  ***     33     38      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33     38      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
1881         100     13      7     18   $engine =~ /InnoDB/i and not $clustered_key
1883  ***     33      0      1      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
1907  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
2023         100    388      3     97   $left_done && $right_done
2024         100     10      3    476   !$lr && !$left_done
2034         100     12     18    459   !$rr && !$right_done
2045         100    100     18    371   $lr and $rr
2050         100      3     18    371   $lr and $rr
      ***     66     21      0    371   $lr and $rr and defined $cmp
             100     21     22    349   $lr and $rr and defined $cmp and $cmp == 0
             100      3     10     12   defined $cmp and $cmp < 0
2072  ***     33    488      0      0   $done and &$done(%args)
2111  ***     33      1      0      0   $coll and $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/
2237  ***      0      0      0      0   $trgs and @$trgs
2569         100     60      4      9   $$self{'replace'} && $action ne 'DELETE'
2605  ***     66     27     97      0   $queue_level and $queue_level < $$self{'queue'}
2626  ***     33      0    124      0   not $error_count++ and $EVAL_ERROR =~ /$DUPE_KEY/
2762         100      2    188      2   $$self{'hex_blob'} and $$tbl_struct{'type_for'}{$col} =~ /blob|text|binary/
2846  ***     33     34      0      0   defined $_ and next
2849         100      7      5     16   $$index{'is_unique'} and @{$$index{'cols'};} == 1
2955  ***      0      0      0      0   $start_point != $end_point and $start_point >= 0
3044  ***      0      0      0      0   $wanted_col and $wanted_idx
3046  ***      0      0      0      0   $wanted_col eq $$chunkable_col{'column'} and $wanted_idx eq $$chunkable_col{'index'}
3180  ***     66      0     94     18   $args{'where'} and grep {$_;} @{$args{'where'};}
3562  ***     33      0      0     20   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
3582  ***     66      1      0     19   $type eq 'bigint' and $length < 20
3596  ***     33      0     40      0   $alg and not $ALGOS{$alg}
3613  ***     33      0      0     40   $alg and grep {$_ eq $alg;} @choices
3618  ***      0      0      0      0   $args{'count'} and grep {$_ ne 'CHECKSUM';} @choices
3629  ***      0      0      0      0   $ALGOS{$algorithm} && $ALGOS{$algorithm}{'hash'}
3639  ***     33      0     40      0   @funcs and not $result
3648  ***     33     40      0      0   $EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/
3672  ***     66      0      1      1   $start < $crc_wid and $sliced ne $unsliced
3719  ***     33      0      0      3   defined $opt_slice and $opt_slice < @slices
3748  ***     33    106      0      0   $args{'float_precision'} and $type =~ /float|double/
             100     98      6      2   $args{'trim'} and $type =~ /varchar/
3782  ***     33      0      0     40   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
3815  ***     33      0      0     20   $algorithm and $ALGOS{$algorithm}
4158         100     28     42     13   $$self{'state'} == 0 && $$self{'chunk_num'} >= scalar @{$$self{'chunks'};}
4248  ***     33      6      0      0   $args{'chunk_index'} and $args{'chunk_index'} ne $nibble_index
4260  ***     33      0      0      6   $args{'src'} and $args{'src'}{'dbh'}
4276  ***     66      0      2      4   defined $n_rows and $n_rows <= 100
4391  ***     66      6      8      0   $$self{'cached_row'} and $$self{'cached_nibble'} == $$self{'nibble'}
4400         100      8      4      2   $$self{'nibble'} == 0 and not $$self{'small_table'}
4520         100      6      6     14   $$self{'state'} == 0 && $$self{'nibble'}
             100     12      8      6   $$self{'state'} == 0 && $$self{'nibble'} && !$$self{'cached_row'}
4783  ***     66     21      7      0   $args{'bidirectional'} and $args{'ChangeHandler'}{'queue'}
4806  ***     33      0      0     28   $vp->version_ge($$src{'dbh'}, '4.0.9') && $vp->version_ge($$dst{'dbh'}, '4.0.9')
4809  ***     66      8      0     20   $plugin_args{'chunk_index'} and $args{'index_hint'}
4866  ***     33     28      0      0   $dp && $$src{'dsn'}
      ***     33     28      0      0   $dp && $$dst{'dsn'}
4989  ***     66      0     19      1   $src_algo eq 'BIT_XOR' and not $crc_type =~ /int$/
5033  ***     66     21      0      6   $args{'lock'} and $args{'lock'} <= $args{'lock_level'}
5060         100     74      6     12   $args{'lock'} and $args{'lock'} == $args{'lock_level'}
5155  ***     66      0      1     58   $privs =~ /select/ and $privs =~ /insert/
      ***     66      1      0     58   $privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/
      ***     66      1      0     58   $privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/ and $can_delete
5309         100      4      2      2   $type =~ /=/ and $end
5324         100     22     12     10   $type =~ /=/ && $end
5488  ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
5599  ***     33      0      5      0   $vp and not $vp->version_ge($dbh, '4.1.2')
5698  ***     66     15      0     18   $ss and %$ss
5717  ***     33      0      0     17   $ms and %$ms
5719  ***     33      0      0     17   $$ms{'file'} and $$ms{'position'}
5742  ***     33     12      0      0   $stat < 0 and not $timeoutok
5883  ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
6018  ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
6023  ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
6090  ***      0      0      0      0   not $match and $type =~ /slave_sql|all/i
6143  ***      0      0      0      0   $$row[1] and $$row[1] ne 'OFF'
6262  ***      0      0      0      0   $PID_file and -f $PID_file
6323  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
6404  ***     33     10      0      0   $o->has('databases-regex') and my $p = $o->get('databases-regex')
6408  ***     33     10      0      0   $o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex')
6468  ***     33     10      0      0   @reject_qtbls and not $have_qtbl
6474         100      8      1      1   keys %permit_qtbls and not @permit_dbs
6489  ***     33      9      0      0   $o->has('tables-regex') and my $p = $o->get('tables-regex')
6493  ***     33      9      0      0   $o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex')
6502  ***     33      0      9      0   $o->has('engines') and $o->get('engines')
      ***     33      0      0      9   $o->has('ignore-engines') and $o->get('ignore-engines')
6699  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
6763  ***     33     11      0      0   $prefix and $prefix eq '-'
6777  ***      0      0      0      0   $num >= $d and $n < @units - 1
6859  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
6951  ***     66     21     30      0   $$dsn{'t'} and not $$dsn{'D'}
6953  ***     66     21     30      0   $$dsn{'D'} and not $$dsn{'t'}
6961         100     21      3      2   @dsns == 1 and not $o->get('replicate')
      ***     66     24      2      0   @dsns == 1 and not $o->get('replicate') and not $o->get('sync-to-master')
6967  ***     66      5     21      0   @dsns > 1 and $o->get('sync-to-master')
      ***     33     26      0      0   @dsns > 1 and $o->get('sync-to-master') and $o->get('replicate')
6994  ***     33      0      5      0   $cc and not $cc =~ /$cmp/
6997  ***     33      0      5      0   $cc and $cc =~ /equals|matches/
      ***     33      5      0      0   $cc and $cc =~ /equals|matches/ and not $o->get('conflict-value')
7516  ***     66     25      5      0   $o->get('lock') and $o->get('lock') == 3
7543  ***     66     25      5      0   $o->get('lock') and $o->get('lock') == 3
7619  ***     66      0     27      3   $o->get('print') and $o->get('verbose') >= 2
7732         100     15      6      2   $slave_status and $sql_log_bin
      ***     66     21      0      2   $slave_status and $sql_log_bin and ($log_bin || 'OFF') eq 'ON'
7787  ***     33      0      0      4   $database and $table
7804  ***     66     72     40      0   not $$dsn{'p'} and $o->get('ask-pass')
7919  ***     33      0     30      0   $$dst{'supports_triggers'} and $du->get_triggers($$dst{'dbh'}, $q, $$dst{'db'}, $$dst{'tbl'})
7934  ***     33      0      0      4   not $$skip_table{$$_{'db'}}{$$_{'tbl'}} and !$databases || $$databases{$$_{'db'}}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
47    ***     50      0     36   $ENV{'MKDEBUG'} || 0
59    ***     50     52      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
120   ***     50      0     26   $file ||= '/home/daniel/dev/maatkit/mk-table-sync/mk-table-sync'
185   ***     50     52      0   $file ||= '/home/daniel/dev/maatkit/mk-table-sync/mk-table-sync'
309   ***     50   1560      0   $$opt{'group'} ||= 'default'
614   ***      0      0      0   $s || 's'
623   ***      0      0      0   $prefix || ''
653          100     37     78   $val || ''
656   ***     50     26      0   $val || ''
715   ***      0      0      0   $$self{'description'} || ''
784   ***      0      0      0   $s ||= 's'
810   ***      0      0      0   $$opt{'type'} || ''
937   ***      0      0      0   $val || ''
951   ***      0      0      0   $pre || ''
997   ***     50      0     36   $ENV{'MKDEBUG'} || 0
1082  ***     50      0     36   $ENV{'MKDEBUG'} || 0
1102  ***     50    522      0   $$opt{'copy'} || 0
1127         100     30     97   $prev ||= {}
1128         100     51     76   $defaults ||= {}
1208  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1221  ***     50      0    174   $self->prop('dbidriver') || ''
1225  ***      0      0      0   $$info{'D'} || ''
1231         100     60    114   $$info{'D'} || ''
1253         100     62    112   $opts ||= {}
1358  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1374  ***      0      0      0   $level ||= 0
1375  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1430  ***     50      0     36   $ENV{'MKDEBUG'} || 0
1484  ***     50      0     36   $ENV{'MKDEBUG'} || 0
1535  ***     50      0      6   $args{'where'} || '1=1'
1607  ***     50      0     36   $ENV{'MKDEBUG'} || 0
1826  ***     50     62      0   $engine || undef
1849  ***     50      0     38   $type || $special || 'BTREE'
1936  ***      0      0      0   $$tbl_struct{'engine'} || ''
1938  ***      0      0      0   $clustered_key ||= ''
1996  ***     50      0     36   $ENV{'MKDEBUG'} || 0
2183  ***     50      0     36   $ENV{'MKDEBUG'} || 0
2447  ***      0      0      0   $$_[1] || ''
2491  ***     50      0     36   $ENV{'MKDEBUG'} || 0
2817  ***     50      0     36   $ENV{'MKDEBUG'} || 0
3186  ***     50    112      0   $args{'index_hint'} || ''
3346  ***      0      0      0   $real_min || 'NULL'
3358  ***      0      0      0   $real_max || 'NULL'
3528  ***     50      0     36   $ENV{'MKDEBUG'} || 0
3734  ***     50      0     40   $args{'sep'} || '#'
3736  ***     50     40      0   $sep ||= '#'
3915  ***     50      0     36   $ENV{'MKDEBUG'} || 0
4051  ***     50     56      0   $$self{'index_hint'} || ''
4220  ***     50      0     36   $ENV{'MKDEBUG'} || 0
4402  ***     50      2      0   $explain_index || ''
4417         100     30     12   $$self{'tbl_struct'}{'is_numeric'}{$$s{'scols'}[$i++]} || 0
4440  ***     50     14      0   $$self{'index_hint'} || ''
4449         100     30     12   $$self{'tbl_struct'}{'is_numeric'}{$$s{'scols'}[$i++]} || 0
4577  ***     50      0     36   $ENV{'MKDEBUG'} || 0
4634  ***     50      0     10   $args{'where'} || '1=1'
4737  ***     50      0     36   $ENV{'MKDEBUG'} || 0
4788         100      6     22   $args{'lock'} ||= 0
4789         100      6     22   $args{'wait'} ||= 0
4790         100     17     11   $args{'transaction'} ||= 0
4791  ***     50      0     28   $args{'timeout_ok'} ||= 0
4861         100     47     93   $args{$_} || 0
5193  ***     50      0     36   $ENV{'MKDEBUG'} || 0
5457  ***     50      0     36   $ENV{'MKDEBUG'} || 0
5467  ***      0      0      0   $level ||= 0
5525  ***      0      0      0   $$dsn{'P'} || 3306
5664  ***     50      5      0   $$slave_status{'slave_io_state'} || ''
6010  ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
6059  ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
6066  ***      0      0      0   $type ||= 'all'
6072  ***      0      0      0   $$query{'Command'} || $$query{'command'} || ''
6076  ***      0      0      0   $$query{'User'} || $$query{'user'} || ''
6077  ***      0      0      0   $$query{'State'} || $$query{'state'} || ''
6186  ***     50      0     36   $ENV{'MKDEBUG'} || 0
6337  ***      0      0      0   $$self{'PID_owner'} || 0
6375  ***     50      0     36   $ENV{'MKDEBUG'} || 0
6605  ***     50      9      0   $type || ''
6664  ***     50      0     36   $ENV{'MKDEBUG'} || 0
6719  ***      0      0      0   $args{'p'} || 0
6721  ***      0      0      0   $of ||= 1
6726  ***      0      0      0   $secs ||= 0
6756  ***     50     11      0   $suffix || $default_suffix || 's'
6903  ***     50      0     36   $ENV{'MKDEBUG'} || 0
7550  ***      0      0      0   $o->get('replicate') || 0
      ***      0      0      0   $o->get('timeout-ok') || 0
      ***      0      0      0   $o->get('transaction') || 0
      ***      0      0      0   $o->get('wait') || 0
7629         100      6     22   $o->get('replace') || $o->get('replicate') || $o->get('sync-to-master') || 0
7645         100     13     15   $o->get('replicate') || $o->get('sync-to-master') || $o->get('bidirectional') || 0
7732  ***     50      2      0   $log_bin || 'OFF'
7770  ***     50     36      0   $$dsn{'h'} || $$dsn{'S'} || ''
7771  ***     50     36      0   $$dsn{'P'} || ''
7980  ***     50     35      0   $left_val || ''
      ***     50     35      0   $right_val || ''
      ***     50      6      0   $right_val || ''
      ***     50      6      0   $left_val || ''
7997  ***     50      2      0   $left_val || 0
      ***     50      2      0   $right_val || 0
      ***     50      3      0   $left_val || 0
      ***     50      3      0   $right_val || 0
7999  ***     50      5      0   $left_val || 0
      ***     50      5      0   $right_val || 0
8010  ***     50      3      0   $left_val || ''
      ***     50      2      0   $right_val || ''
8015  ***     50      3      0   $left_val || ''
      ***     50      2      0   $right_val || ''
8052  ***     50     26      0   $$lr{$col} || ''
8053  ***     50     26      0   $$rr{$col} || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
58    ***     33     52      0      0   $program_name ||= $PROGRAM_NAME
59    ***     33     52      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     52      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
609          100    104     11    769   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66     26      0    743   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1093  ***     33      0      0    522   not $$opt{'key'} or not $$opt{'desc'}
1244  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1245  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1246  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1247  ***      0      0      0      0   $$dsn{'u'} ||= $user
1248  ***      0      0      0      0   $$dsn{'D'} ||= $db
1700  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1779  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
1800  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
1849  ***     33      0      0     38   $type || $special
2028  ***     66     97      0    379   !$lr || $EVAL_ERROR
2038  ***     66     97      0    362   !$rr || $EVAL_ERROR
2049         100    389      3     97   $lr or $rr
2050         100     18     12     13   not $rr or defined $cmp and $cmp < 0
2093  ***     66      1      0    488   not defined $l or not defined $r
2111  ***      0      0      0      0   $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/
      ***      0      0      0      0   $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/
2288  ***     33     62      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2327  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2357  ***     33     30      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2391  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2410  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2424  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2436  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2862  ***     33     16      0      0   $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2947  ***     33      0      0     14   not defined $end_point or $end_point < $start_point
2983  ***     66     12      2      0   $interval ||= $args{'chunk_size'}
3103  ***     33      0      0     20   $suffix or $args{'avg_row_length'}
3599  ***     33     40      0      0   $args{'where'} or $args{'chunk'}
      ***     33     40      0      0   $args{'where'} or $args{'chunk'} or $args{'replicate'}
      ***     33     40      0      0   $args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1')
3949  ***     33      0      0     14   $args{'chunk_col'} or $args{'chunk_index'}
4070         100     13     15     14   $$lr{'cnt'} != $$rr{'cnt'} or $$lr{'crc'} ne $$rr{'crc'}
4477         100      2      4      8   $$lr{'cnt'} != $$rr{'cnt'} or $$lr{'crc'} ne $$rr{'crc'}
4919         100     28     36     34   not $cycle or not $plugin->pending_changes
5473  ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
5488  ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
5501  ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
5671  ***     33      0      0      5   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
5692  ***     66      5     28      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
5711  ***     66      7     10      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
5735  ***     33      0     12      0   $ms ||= $self->get_master_status($master)
5742  ***     33      0      0     12   $stat eq 'NULL' or $stat < 0 and not $timeoutok
5754  ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
5769  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
5837  ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
5898  ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
5936  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
5990  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
6072  ***      0      0      0      0   $$query{'Command'} || $$query{'command'}
6076  ***      0      0      0      0   $$query{'User'} || $$query{'user'}
6077  ***      0      0      0      0   $$query{'State'} || $$query{'state'}
6412  ***     66      9      0      1   @permit_dbs or @reject_dbs
      ***     66      9      0      1   @permit_dbs or @reject_dbs or @dbs_regex
      ***     66      9      0      1   @permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex
6422  ***     33     10      0      0   $o->has('tables') or $o->has('ignore-tables')
      ***     33     10      0      0   $o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex')
6502  ***     33      0      9      0   $o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines')
6521  ***     33      0      0      9   @permit_tbls or @reject_tbls
      ***     33      0      0      9   @permit_tbls or @reject_tbls or @tbls_regex
      ***     33      0      0      9   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex
      ***     33      0      0      9   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs
      ***     33      0      9      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs
6729  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
6756  ***     33     11      0      0   $suffix || $default_suffix
6781  ***      0      0      0      0   $num =~ /\./ || $n
6929         100      3      2     21   $o->get('replicate') or $o->get('sync-to-master')
6961  ***     33      0      0     26   not @dsns or @dsns == 1 and not $o->get('replicate') and not $o->get('sync-to-master')
6973  ***      0      0      0      0   @dsns != 2 or not $dsns[0]{'t'}
      ***      0      0      0      0   @dsns != 2 or not $dsns[0]{'t'} or not $dsns[1]{'t'}
6980  ***     33      0      0      5   $o->get('replicate') or $o->get('sync-to-master')
6987  ***     33      0      0      5   not $o->get('conflict-column') or not $o->get('conflict-comparison')
7148  ***      0      0      0      0   $$dsns[0]{'dbh'} || get_cxn($$dsns[0], %args)
7155  ***      0      0      0      0   $$dsns[1]{'dbh'} || get_cxn($$dsns[1], %args)
7219  ***     33      0     14      0   $dsns[0]{'dbh'} || get_cxn($dsns[0], %args)
7229  ***     33      0     16      0   $$dsn{'dbh'} || get_cxn($dsn, %args)
      ***     33     16      0      0   $$dsn{'D'} || $$src{'db'}
      ***     33     16      0      0   $$dsn{'t'} || $$src{'tbl'}
7276  ***     33      3      0      0   $$dsns[0]{'dbh'} || get_cxn($$dsns[0], %args)
7294  ***     33      3      0      0   $$dsns[1]{'dbh'} || get_cxn($$dsns[1], %args)
7439  ***     66      2      7      0   $dsns[0]{'dbh'} || get_cxn($dsns[0], %args)
7480  ***     66      2      9      0   $$dsn{'dbh'} || get_cxn($dsn, %args)
7547  ***      0      0      0      0   $$src{'dbh'} ||= get_cxn($$src{'dsn'}, %args)
7548  ***      0      0      0      0   $$dst{'dbh'} ||= get_cxn($$dst{'dsn'}, %args)
7549  ***      0      0      0      0   $$src{'misc_dbh'} ||= get_cxn($$src{'dsn'}, %args)
7629  ***     66      0      4     24   $o->get('replace') || $o->get('replicate')
             100      4      2     22   $o->get('replace') || $o->get('replicate') || $o->get('sync-to-master')
7645  ***     66      4      0     24   $args{'where'} || $o->get('where')
             100      4      2     22   $o->get('replicate') || $o->get('sync-to-master')
             100      6      7     15   $o->get('replicate') || $o->get('sync-to-master') || $o->get('bidirectional')
7707  ***     66      6      0     24   $o->get('sync-to-master') or $o->get('replicate')
7754  ***     66     36     15      0    ||= 
7756  ***     66     36     15      0   $dbh ||= $change_dbh
7770  ***     33     36      0      0   $$dsn{'h'} || $$dsn{'S'}
7934  ***      0      0      0      0   $$tables{$$_{'tbl'}} or $$tables{"$$_{'db'}.$$_{'tbl'}"}
      ***     33      4      0      0   not $tables or ($$tables{$$_{'tbl'}} or $$tables{"$$_{'db'}.$$_{'tbl'}"})
      ***     66      1      3      0   !$databases || $$databases{$$_{'db'}}
7979         100     35      6     12   $cmp eq 'newest' or $cmp eq 'oldest'
             100      2      3      7   $cmp eq 'greatest' or $cmp eq 'least'
8073  ***     33      0      0      2   $cmp eq 'equals' or $cmp eq 'matches'


Covered Subroutines
-------------------

Subroutine                   Count Location                                                 
---------------------------- ----- ---------------------------------------------------------
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1070
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1071
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1072
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1073
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1082
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1425
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1426
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1428
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1430
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1479
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1480
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1482
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1484
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1599
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1600
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1601
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1602
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1607
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1992
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1993
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1994
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1996
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2178
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2179
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2181
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2183
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:23  
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:24  
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2484
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2485
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2486
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2491
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2806
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2807
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2808
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2810
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2811
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2812
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2817
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3523
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3524
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3525
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3526
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3528
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3905
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3906
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3908
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3909
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3910
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3915
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:40  
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:41  
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4210
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4211
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4213
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4214
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4215
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4220
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:43  
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:44  
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:45  
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4572
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4573
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4575
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4577
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:47  
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4728
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4729
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4731
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4732
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4737
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5188
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5189
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5191
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5193
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5446
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5447
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5451
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5452
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5453
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5457
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6180
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6181
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6183
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6184
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6186
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6366
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6367
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6369
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6370
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6375
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6658
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6659
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6660
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6661
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6662
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6664
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6897
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6898
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6899
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6903
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7971
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7972
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7973
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7974
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:993 
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:994 
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:995 
BEGIN                           36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:997 
DSNParser                       26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:174 
__ANON__                       234 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:134 
__ANON__                       124 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:483 
__ANON__                        18 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6579
__ANON__                        18 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6618
__ANON__                        51 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7754
__ANON__                        73 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7765
__ANON__                        26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:8044
__ANON__                         7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:8102
__ANON__                         7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:8108
__get_boundaries                40 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4378
__get_explain_index              2 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4460
__make_boundary_sql             14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4435
__queue                         37 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2593
_check_opts                     26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:526 
_get_participants               52 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:383 
_get_valid_end_point            28 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3366
_make_filter                    62 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6623
_parse_attribs                1560 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:960 
_parse_specs                    26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:273 
_pod_to_specs                   52 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:184 
_read_config_file              104 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:859 
_set_option                    124 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:429 
_take_action                    73 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2554
_use_db                         62 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2275
_validate_type                1560 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:599 
any_unix_timestamp              22 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6832
as_string                       10 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1190
best_algorithm                  40 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3592
calculate_chunks                14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2898
can_sync                         3 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1500
can_sync                        20 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3937
can_sync                         7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4236
can_sync                         5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4593
change                          76 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2563
choose_hash_func                40 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3633
cmp_conflict_col                53 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7976
compare_sets                    98 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2006
disconnect                      56 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7942
done                             6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1561
done                            83 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4153
done                            26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4517
done                            10 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4690
done_with_rows                   3 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1556
done_with_rows                  69 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4138
done_with_rows                  20 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4502
done_with_rows                   5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4685
fetch_back                      56 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2518
filter_diffs                     3 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7933
find_best_index                  7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1712
find_chunk_columns              20 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2835
find_replication_differences     6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3861
generate_asc_stmt                6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5206
generate_cmp_where              24 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5269
get                           2456 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:668 
get_best_plugin                 28 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4750
get_change_dbh                  30 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7697
get_changes                     27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2722
get_connected_slaves             5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5594
get_crc_type                    20 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3572
get_crc_wid                     20 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3560
get_create_table                62 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2287
get_cxn                        112 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7797
get_cxn_params                 174 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1218
get_db_itr                       9 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6558
get_dbh                        174 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1252
get_defaults_files              26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:179 
get_engine                      62 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1823
get_keys                        31 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1830
get_master_dsn                   5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5683
get_master_status               17 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5709
get_opts                        26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:446 
get_range_statistics            14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3115
get_slave_status                33 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5690
get_specs                       26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:119 
get_sql                          6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1532
get_sql                        140 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4041
get_sql                         40 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4351
get_sql                         10 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4632
get_tbl_itr                      9 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6584
get_triggers                    30 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2356
get_valid_end_points            14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3324
got                            144 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:676 
has                            346 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:684 
have_all_privs                  59 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5141
inject_chunks                  112 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3169
is_master_of                     5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5645
key_cmp                        371 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2079
key_cols                         8 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1566
key_cols                       180 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4174
key_cols                        45 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4536
key_cols                        13 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4695
literal_like                     6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1035
lock_and_wait                   92 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5051
lock_server                     30 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7510
lock_table                       8 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5017
main                            26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6910
make_DELETE                      6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2640
make_INSERT                     33 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2675
make_REPLACE                     9 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2684
make_UPDATE                     25 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2648
make_action_subs                28 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7744
make_checksum_queries           20 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4949
make_checksum_query             20 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3804
make_fetch_back_query           55 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2754
make_filter                     10 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6391
make_row                        42 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2690
make_row_checksum               40 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3730
make_where_clause               65 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2712
make_xor_slices                  3 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3701
name                             3 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1496
name                            13 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3927
name                             6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4232
name                             5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4589
new                             26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1000
new                             58 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1085
new                             39 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1433
new                             15 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1487
new                             26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1611
new                             28 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1999
new                             26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2210
new                             28 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2494
new                             26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2820
new                             26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3537
new                             19 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3918
new                             16 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4223
new                             16 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4580
new                             26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4740
new                             26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5196
new                             52 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:52  
new                             26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5460
new                              9 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6378
not_in_left                      8 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4117
not_in_left                      4 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4496
not_in_left                      1 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4675
not_in_right                     5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1546
not_in_right                    10 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4096
not_in_right                     8 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4490
not_in_right                     7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4665
ok_to_sync                      31 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7862
optimize_xor                     1 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3660
parse                          144 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1121
parse                          186 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1438
parse                           31 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1622
parse_options                   26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1177
pending_changes                 56 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4162
pending_changes                 14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4524
prepare_sync_cycle               6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1527
prepare_sync_cycle             140 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4033
prepare_sync_cycle              40 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4343
prepare_sync_cycle              10 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4627
prepare_to_sync                  3 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1504
prepare_to_sync                 14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3983
prepare_to_sync                  6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4291
prepare_to_sync                  5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4597
print_err                        4 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7783
print_sql                       12 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7959
process_rows                   124 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2602
prop                           613 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1112
quote                         1243 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1005
quote_val                      419 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1013
range_func_for                  14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3238
range_num                       39 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3254
read_para_after                  5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:893 
same_row                         3 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1541
same_row                       223 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4067
same_row                       120 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4475
same_row                         3 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4643
set                             21 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:690 
set_bidirectional_callbacks      5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:8028
set_callback                    15 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3931
set_checksum_queries            14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4024
set_checksum_queries             6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4334
set_filter                       9 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6551
set_src                         36 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2525
size_to_rows                    20 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3078
sort_cols                       67 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2727
sort_indexes                     7 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1693
split_unquote                   31 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1024
sync_a_table                    31 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7577
sync_all                         9 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7428
sync_one_table                  14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7208
sync_table                      28 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4768
sync_via_replication             3 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7262
time_to_secs                    11 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6752
unix_timestamp                  12 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6817
unlock                          27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5025
unlock_server                   30 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7536
usage_or_errors                 26 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:726 
uses_checksum                    3 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1519
uses_checksum                   14 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4020
uses_checksum                    6 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4330
uses_checksum                    5 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4619
value_to_number                 28 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3200
version_ge                     132 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1445
wait_for_master                 12 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5730

Uncovered Subroutines
---------------------

Subroutine                   Count Location                                                 
---------------------------- ----- ---------------------------------------------------------
DESTROY                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6335
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3469
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7360
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1402
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1456
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1576
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1969
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2155
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2461
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2782
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3500
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3882
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4187
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4549
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4705
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5165
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5425
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6156
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6343
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6634
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6874
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:8117
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:970 
_find_slaves_by_hosts            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5567
_find_slaves_by_processlist      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5547
_make_PID_file                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6300
_parse_size                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:935 
_remove_PID_file                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6322
_validate_temporal_value         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3442
catchup_to_master                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5777
catchup_to_same_pos              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5818
change_master_to                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5847
check_PID_file                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6259
check_table                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1758
clone                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:912 
copy                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1384
crc32                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3546
daemonize                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6207
db_cmp                           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2133
descr                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:714 
detach_slave                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5999
disconnect                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1367
dst                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2549
dump                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2218
errors                           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:704 
fill_in_dsn                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1240
find_possible_keys               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1730
find_slave_hosts                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5517
generate_del_stmt                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5339
generate_ins_stmt                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5401
get_columns                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2325
get_databases                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2390
get_defaults                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:419 
get_first_chunkable_column       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3031
get_first_valid_value            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3397
get_fks                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1897
get_groups                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:424 
get_hostname                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1357
get_nonzero_value                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3459
get_replication_filters          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6108
get_slave_lag                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6038
get_table_list                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2435
get_table_status                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2409
get_tmp_table                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2345
has_slave_updates                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6014
is_hash_algorithm                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3628
is_replication_thread            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6063
join_quote                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1042
lock_and_rename                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:7136
make_PID_file                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6290
make_checksum                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6867
make_sibling_of_master           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5858
make_slave_of_sibling            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5906
make_slave_of_uncle              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5945
micro_t                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6688
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6189
not_in_left                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1551
opts                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:395 
parse_timestamp                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6805
pending_changes                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1571
pending_changes                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4700
percentage_of                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6718
pos_cmp                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6044
pos_to_string                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6150
print_active_handles             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1373
print_errors                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:739 
print_usage                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:749 
prompt                           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:709 
prompt_noecho                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:824 
range_date                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3280
range_datetime                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3287
range_time                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3273
range_timestamp                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3295
recurse_to_slaves                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5466
remove_auto_increment            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1926
remove_secondary_indexes         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1932
repl_posn                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6022
save_error                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:699 
secs_to_time                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6725
set_checksum_queries             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1523
set_checksum_queries             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4623
set_defaults                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:407 
short_host                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6049
short_opts                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:401 
shorten                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6772
slave_is_running                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6009
src                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2544
start_slave                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5761
stop_slave                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5753
timestampdiff                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3302
ts                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6789
usage                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1201


