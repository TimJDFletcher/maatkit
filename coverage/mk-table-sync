---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...-table-sync/mk-table-sync    9.9    1.2    3.9   28.8    n/a  100.0    8.3
Total                           9.9    1.2    3.9   28.8    n/a  100.0    8.3
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:42:25 2010
Finish:       Thu Jan 28 22:42:25 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:42:26 2010
Finish:       Thu Jan 28 22:42:33 2010

Run:          ./102_triggers.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:42:37 2010
Finish:       Thu Jan 28 22:42:40 2010

Run:          ./103_force_index.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:42:44 2010
Finish:       Thu Jan 28 22:42:45 2010

Run:          ./104_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:42:49 2010
Finish:       Thu Jan 28 22:42:49 2010

Run:          ./105_master_master.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:42:53 2010
Finish:       Thu Jan 28 22:43:07 2010

Run:          ./106_lock_and_rename.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:43:11 2010
Finish:       Thu Jan 28 22:43:13 2010

Run:          ./107_option_sanity.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:43:17 2010
Finish:       Thu Jan 28 22:43:18 2010

Run:          ./108_sync_to_differnt_db.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:43:22 2010
Finish:       Thu Jan 28 22:43:29 2010

Run:          ./109_columns.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:43:33 2010
Finish:       Thu Jan 28 22:43:35 2010

Run:          ./110_replicate_do_db.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:43:39 2010
Finish:       Thu Jan 28 22:43:49 2010

Run:          ./111_lock_level.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:43:53 2010
Finish:       Thu Jan 28 22:43:53 2010

Run:          ./112_float_precision.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:43:57 2010
Finish:       Thu Jan 28 22:43:59 2010

Run:          ./113_specify_column_or_index.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:44:03 2010
Finish:       Thu Jan 28 22:44:04 2010

Run:          ./114_filters.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:44:09 2010
Finish:       Thu Jan 28 22:44:09 2010

Run:          ./201_issue_22.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:44:13 2010
Finish:       Thu Jan 28 22:44:14 2010

Run:          ./202_issue_79.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:44:18 2010
Finish:       Thu Jan 28 22:44:22 2010

Run:          ./203_issue_96.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:44:26 2010
Finish:       Thu Jan 28 22:44:28 2010

Run:          ./204_issue_262.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:44:32 2010
Finish:       Thu Jan 28 22:44:33 2010

Run:          ./205_issue_218.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:44:37 2010
Finish:       Thu Jan 28 22:44:37 2010

Run:          ./206_issue_408.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:44:41 2010
Finish:       Thu Jan 28 22:44:48 2010

Run:          ./207_issue_616.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:44:53 2010
Finish:       Thu Jan 28 22:44:55 2010

Run:          ./208_issue_627.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:44:59 2010
Finish:       Thu Jan 28 22:45:01 2010

Run:          ./209_issue_631.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:45:07 2010
Finish:       Thu Jan 28 22:45:08 2010

Run:          ./210_issue_560.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:45:15 2010
Finish:       Thu Jan 28 22:45:19 2010

Run:          ./211_issue_634.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:45:24 2010
Finish:       Thu Jan 28 22:45:25 2010

Run:          ./212_issue_644.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:45:30 2010
Finish:       Thu Jan 28 22:45:31 2010

Run:          ./213_issue_804.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:45:37 2010
Finish:       Thu Jan 28 22:45:38 2010

/home/daniel/dev/maatkit/mk-table-sync/mk-table-sync

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program synchronizes data efficiently between two MySQL tables, which
4                                                     # can be on different servers.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23            27                   27           165   use strict;
              27                                 69   
              27                                207   
24            27                   27           170   use warnings FATAL => 'all';
              27                                 69   
              27                                190   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5478 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 5266
32                                                    # ###########################################################################
33                                                    package OptionParser;
34                                                    
35            27                   27           175   use strict;
              27                                 80   
              27                                128   
36            27                   27           166   use warnings FATAL => 'all';
              27                                 60   
              27                                139   
37                                                    
38            27                   27           282   use Getopt::Long;
              27                                106   
              27                                187   
39            27                   27           199   use List::Util qw(max);
              27                                 68   
              27                                305   
40            27                   27           183   use English qw(-no_match_vars);
              27                                 70   
              27                                190   
41                                                    
42    ***     27            50     27           202   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 94   
              27                                438   
43                                                    
44                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
45                                                    
46                                                    my %attributes = (
47                                                       'type'       => 1,
48                                                       'short form' => 1,
49                                                       'group'      => 1,
50                                                       'default'    => 1,
51                                                       'cumulative' => 1,
52                                                       'negatable'  => 1,
53                                                    );
54                                                    
55                                                    sub new {
56    ***      0                    0             0      my ( $class, %args ) = @_;
57    ***      0                                  0      foreach my $arg ( qw(description) ) {
58    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
59                                                       }
60    ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
61    ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
62    ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
63                                                    
64    ***      0      0      0                    0      my $self = {
      ***                    0                        
65                                                          description    => $args{description},
66                                                          prompt         => $args{prompt} || '<options>',
67                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
68                                                          dp             => $args{dp}     || undef,
69                                                          program_name   => $program_name,
70                                                          opts           => {},
71                                                          got_opts       => 0,
72                                                          short_opts     => {},
73                                                          defaults       => {},
74                                                          groups         => {},
75                                                          allowed_groups => {},
76                                                          errors         => [],
77                                                          rules          => [],  # desc of rules for --help
78                                                          mutex          => [],  # rule: opts are mutually exclusive
79                                                          atleast1       => [],  # rule: at least one opt is required
80                                                          disables       => {},  # rule: opt disables other opts 
81                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
82                                                          default_files  => [
83                                                             "/etc/maatkit/maatkit.conf",
84                                                             "/etc/maatkit/$program_name.conf",
85                                                             "$home/.maatkit.conf",
86                                                             "$home/.$program_name.conf",
87                                                          ],
88                                                       };
89    ***      0                                  0      return bless $self, $class;
90                                                    }
91                                                    
92                                                    sub get_specs {
93    ***      0                    0             0      my ( $self, $file ) = @_;
94    ***      0                                  0      my @specs = $self->_pod_to_specs($file);
95    ***      0                                  0      $self->_parse_specs(@specs);
96    ***      0                                  0      return;
97                                                    }
98                                                    
99                                                    sub get_defaults_files {
100   ***      0                    0             0      my ( $self ) = @_;
101   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
102                                                   }
103                                                   
104                                                   sub _pod_to_specs {
105   ***      0                    0             0      my ( $self, $file ) = @_;
106   ***      0             0                    0      $file ||= __FILE__;
107   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
108                                                   
109   ***      0                                  0      my %types = (
110                                                         string => 's', # standard Getopt type
111                                                         'int'  => 'i', # standard Getopt type
112                                                         float  => 'f', # standard Getopt type
113                                                         Hash   => 'H', # hash, formed from a comma-separated list
114                                                         hash   => 'h', # hash as above, but only if a value is given
115                                                         Array  => 'A', # array, similar to Hash
116                                                         array  => 'a', # array, similar to hash
117                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
118                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
119                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
120                                                      );
121   ***      0                                  0      my @specs = ();
122   ***      0                                  0      my @rules = ();
123   ***      0                                  0      my $para;
124                                                   
125   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
126   ***      0                                  0      while ( $para = <$fh> ) {
127   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
128   ***      0                                  0         last;
129                                                      }
130                                                   
131   ***      0                                  0      while ( $para = <$fh> ) {
132   ***      0      0                           0         last if $para =~ m/^=over/;
133   ***      0                                  0         chomp $para;
134   ***      0                                  0         $para =~ s/\s+/ /g;
135   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
136   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
137   ***      0                                  0         push @rules, $para;
138                                                      }
139                                                   
140   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
141                                                   
142   ***      0                                  0      do {
143   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
144   ***      0                                  0            chomp $para;
145   ***      0                                  0            MKDEBUG && _d($para);
146   ***      0                                  0            my %attribs;
147                                                   
148   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
149                                                   
150   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
151   ***      0                                  0               $para =~ s/\s+\Z//g;
152   ***      0                                  0               %attribs = map {
153   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
154   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
155                                                                        unless $attributes{$attrib};
156   ***      0                                  0                     ($attrib, $val);
157                                                                  } split(/; /, $para);
158   ***      0      0                           0               if ( $attribs{'short form'} ) {
159   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
160                                                               }
161   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
162                                                            }
163                                                            else {
164   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
165                                                            }
166                                                   
167   ***      0                                  0            $para =~ s/\s+\Z//g;
168   ***      0                                  0            $para =~ s/\s+/ /g;
169   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
170                                                   
171   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
172   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
173                                                   
174   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
175                                                   
176   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
177   ***      0                                  0               $option = $base_option;
178   ***      0                                  0               $attribs{'negatable'} = 1;
179                                                            }
180                                                   
181   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
182                                                               spec  => $option
183                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
184                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
185                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
186                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
187                                                               desc  => $para
188                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
189                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
190                                                            };
191                                                         }
192   ***      0                                  0         while ( $para = <$fh> ) {
193   ***      0      0                           0            last unless $para;
194                                                   
195                                                   
196   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
197   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
198   ***      0                                  0               last;
199                                                            }
200   ***      0      0                           0            last if $para =~ m/^=item --/;
201                                                         }
202                                                      } while ( $para );
203                                                   
204   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
205                                                   
206   ***      0                                  0      close $fh;
207   ***      0                                  0      return @specs, @rules;
208                                                   }
209                                                   
210                                                   sub _parse_specs {
211   ***      0                    0             0      my ( $self, @specs ) = @_;
212   ***      0                                  0      my %disables; # special rule that requires deferred checking
213                                                   
214   ***      0                                  0      foreach my $opt ( @specs ) {
215   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
216                                                            MKDEBUG && _d('Parsing opt spec:',
217   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
218                                                   
219   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
220   ***      0      0                           0            if ( !$long ) {
221   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
222                                                            }
223   ***      0                                  0            $opt->{long} = $long;
224                                                   
225   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
226   ***      0                                  0            $self->{opts}->{$long} = $opt;
227                                                   
228   ***      0      0                           0            if ( length $long == 1 ) {
229   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
230   ***      0                                  0               $self->{short_opts}->{$long} = $long;
231                                                            }
232                                                   
233   ***      0      0                           0            if ( $short ) {
234   ***      0      0                           0               die "Duplicate short option -$short"
235                                                                  if exists $self->{short_opts}->{$short};
236   ***      0                                  0               $self->{short_opts}->{$short} = $long;
237   ***      0                                  0               $opt->{short} = $short;
238                                                            }
239                                                            else {
240   ***      0                                  0               $opt->{short} = undef;
241                                                            }
242                                                   
243   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
244   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
245   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
246                                                   
247   ***      0             0                    0            $opt->{group} ||= 'default';
248   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
249                                                   
250   ***      0                                  0            $opt->{value} = undef;
251   ***      0                                  0            $opt->{got}   = 0;
252                                                   
253   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
254   ***      0                                  0            $opt->{type} = $type;
255   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
256                                                   
257   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
258   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
259                                                                  . "was given when this OptionParser object was created";
260                                                            }
261                                                   
262   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
263                                                   
264   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
265   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
266   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
267                                                            }
268                                                   
269   ***      0      0                           0            if ( $long eq 'config' ) {
270   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
271                                                            }
272                                                   
273   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
274   ***      0                                  0               $disables{$long} = $dis;
275   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
276                                                            }
277                                                   
278   ***      0                                  0            $self->{opts}->{$long} = $opt;
279                                                         }
280                                                         else { # It's an option rule, not a spec.
281   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
282   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
283   ***      0                                  0            my @participants = $self->_get_participants($opt);
284   ***      0                                  0            my $rule_ok = 0;
285                                                   
286   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
287   ***      0                                  0               $rule_ok = 1;
288   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
289   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
290                                                            }
291   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
292   ***      0                                  0               $rule_ok = 1;
293   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
294   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
295                                                            }
296   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
297   ***      0                                  0               $rule_ok = 1;
298   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
299   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
300                                                            }
301   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
302   ***      0                                  0               $rule_ok = 1;
303   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
304   ***      0                                  0               my @groups = split(',', $groups);
305   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
306   ***      0                                  0                  s/\s+//;
307   ***      0                                  0                  $_ => 1;
308                                                               } @groups;
309                                                            }
310                                                   
311   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
312                                                         }
313                                                      }
314                                                   
315   ***      0                                  0      foreach my $long ( keys %disables ) {
316   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
317   ***      0                                  0         $self->{disables}->{$long} = \@participants;
318   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
319                                                      }
320                                                   
321   ***      0                                  0      return; 
322                                                   }
323                                                   
324                                                   sub _get_participants {
325   ***      0                    0             0      my ( $self, $str ) = @_;
326   ***      0                                  0      my @participants;
327   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
328   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
329                                                            unless exists $self->{opts}->{$long};
330   ***      0                                  0         push @participants, $long;
331                                                      }
332   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
333   ***      0                                  0      return @participants;
334                                                   }
335                                                   
336                                                   sub opts {
337   ***      0                    0             0      my ( $self ) = @_;
338   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
339   ***      0                                  0      return %opts;
340                                                   }
341                                                   
342                                                   sub short_opts {
343   ***      0                    0             0      my ( $self ) = @_;
344   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
345   ***      0                                  0      return %short_opts;
346                                                   }
347                                                   
348                                                   sub set_defaults {
349   ***      0                    0             0      my ( $self, %defaults ) = @_;
350   ***      0                                  0      $self->{defaults} = {};
351   ***      0                                  0      foreach my $long ( keys %defaults ) {
352   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
353                                                            unless exists $self->{opts}->{$long};
354   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
355   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
356                                                      }
357   ***      0                                  0      return;
358                                                   }
359                                                   
360                                                   sub get_defaults {
361   ***      0                    0             0      my ( $self ) = @_;
362   ***      0                                  0      return $self->{defaults};
363                                                   }
364                                                   
365                                                   sub get_groups {
366   ***      0                    0             0      my ( $self ) = @_;
367   ***      0                                  0      return $self->{groups};
368                                                   }
369                                                   
370                                                   sub _set_option {
371   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
372   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
373                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
374                                                               : die "Getopt::Long gave a nonexistent option: $opt";
375                                                   
376   ***      0                                  0      $opt = $self->{opts}->{$long};
377   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
378   ***      0                                  0         $opt->{value}++;
379                                                      }
380                                                      else {
381   ***      0                                  0         $opt->{value} = $val;
382                                                      }
383   ***      0                                  0      $opt->{got} = 1;
384   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
385                                                   }
386                                                   
387                                                   sub get_opts {
388   ***      0                    0             0      my ( $self ) = @_; 
389                                                   
390   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
391   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
392   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
393                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
394                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
395                                                            : undef;
396                                                      }
397   ***      0                                  0      $self->{got_opts} = 0;
398                                                   
399   ***      0                                  0      $self->{errors} = [];
400                                                   
401   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
402   ***      0                                  0         shift @ARGV;
403   ***      0                                  0         $self->_set_option('config', shift @ARGV);
404                                                      }
405   ***      0      0                           0      if ( $self->has('config') ) {
406   ***      0                                  0         my @extra_args;
407   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
408   ***      0                                  0            eval {
409   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
410                                                            };
411   ***      0      0                           0            if ( $EVAL_ERROR ) {
412   ***      0      0                           0               if ( $self->got('config') ) {
413   ***      0                                  0                  die $EVAL_ERROR;
414                                                               }
415                                                               elsif ( MKDEBUG ) {
416                                                                  _d($EVAL_ERROR);
417                                                               }
418                                                            }
419                                                         }
420   ***      0                                  0         unshift @ARGV, @extra_args;
421                                                      }
422                                                   
423   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
424                                                      GetOptions(
425   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
426   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
427   ***      0      0                           0         values %{$self->{opts}}
428                                                      ) or $self->save_error('Error parsing options');
429                                                   
430   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
431   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
432                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
433                                                               or die "Cannot print: $OS_ERROR";
434   ***      0                                  0         exit 0;
435                                                      }
436                                                   
437   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
438   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
439                                                      }
440                                                   
441   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
442   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
443   ***      0      0                           0         if ( @set > 1 ) {
444   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
445   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
446                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
447                                                                    . ' are mutually exclusive.';
448   ***      0                                  0            $self->save_error($err);
449                                                         }
450                                                      }
451                                                   
452   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
453   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
454   ***      0      0                           0         if ( @set == 0 ) {
455   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
456   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
457                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
458   ***      0                                  0            $self->save_error("Specify at least one of $err");
459                                                         }
460                                                      }
461                                                   
462   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
463   ***      0                                  0         my $opt = $self->{opts}->{$long};
464   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
465   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
466   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
467   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
468   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
469                                                                  'because', $long,'disables them');
470                                                            }
471                                                   
472   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
473                                                   
474   ***      0                                  0               my @restricted_groups = grep {
475   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
476   ***      0                                  0               } keys %{$self->{groups}};
477                                                   
478   ***      0                                  0               my @restricted_opts;
479   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
480   ***      0                                  0                  RESTRICTED_OPT:
481   ***      0                                  0                  foreach my $restricted_opt (
482                                                                     keys %{$self->{groups}->{$restricted_group}} )
483                                                                  {
484   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
485   ***      0      0                           0                     push @restricted_opts, $restricted_opt
486                                                                        if $self->{opts}->{$restricted_opt}->{got};
487                                                                  }
488                                                               }
489                                                   
490   ***      0      0                           0               if ( @restricted_opts ) {
491   ***      0                                  0                  my $err;
492   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
493   ***      0                                  0                     $err = "--$restricted_opts[0]";
494                                                                  }
495                                                                  else {
496   ***      0                                  0                     $err = join(', ',
497   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
498   ***      0                                  0                               grep { $_ } 
499                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
500                                                                            )
501                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
502                                                                  }
503   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
504                                                               }
505                                                            }
506                                                   
507                                                         }
508                                                         elsif ( $opt->{is_required} ) { 
509   ***      0                                  0            $self->save_error("Required option --$long must be specified");
510                                                         }
511                                                   
512   ***      0                                  0         $self->_validate_type($opt);
513                                                      }
514                                                   
515   ***      0                                  0      $self->{got_opts} = 1;
516   ***      0                                  0      return;
517                                                   }
518                                                   
519                                                   sub _validate_type {
520   ***      0                    0             0      my ( $self, $opt ) = @_;
521   ***      0      0      0                    0      return unless $opt && $opt->{type};
522   ***      0                                  0      my $val = $opt->{value};
523                                                   
524   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
525   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
526   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
527   ***      0      0                           0         if ( !$suffix ) {
528   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
529   ***      0             0                    0            $suffix = $s || 's';
530   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
531                                                               $opt->{long}, '(value:', $val, ')');
532                                                         }
533   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
534   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
535                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
536                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
537                                                                 :                  $num * 86400;   # Days
538   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
539   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
540                                                         }
541                                                         else {
542   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
543                                                         }
544                                                      }
545                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
546   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
547   ***      0                                  0         my $prev = {};
548   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
549   ***      0      0                           0         if ( $from_key ) {
550   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
551   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
552                                                         }
553   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
554   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
555                                                      }
556                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
557   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
558   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
559   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
560   ***      0      0                           0         if ( defined $num ) {
561   ***      0      0                           0            if ( $factor ) {
562   ***      0                                  0               $num *= $factor_for{$factor};
563   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
564                                                                  'to num', $num, '* factor', $factor);
565                                                            }
566   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
567                                                         }
568                                                         else {
569   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
570                                                         }
571                                                      }
572                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
573   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
574                                                      }
575                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
576   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
577                                                      }
578                                                      else {
579   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
580                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
581                                                      }
582                                                   
583   ***      0                                  0      return;
584                                                   }
585                                                   
586                                                   sub get {
587   ***      0                    0             0      my ( $self, $opt ) = @_;
588   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
589   ***      0      0      0                    0      die "Option $opt does not exist"
590                                                         unless $long && exists $self->{opts}->{$long};
591   ***      0                                  0      return $self->{opts}->{$long}->{value};
592                                                   }
593                                                   
594                                                   sub got {
595   ***      0                    0             0      my ( $self, $opt ) = @_;
596   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
597   ***      0      0      0                    0      die "Option $opt does not exist"
598                                                         unless $long && exists $self->{opts}->{$long};
599   ***      0                                  0      return $self->{opts}->{$long}->{got};
600                                                   }
601                                                   
602                                                   sub has {
603   ***      0                    0             0      my ( $self, $opt ) = @_;
604   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
605   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
606                                                   }
607                                                   
608                                                   sub set {
609   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
610   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
611   ***      0      0      0                    0      die "Option $opt does not exist"
612                                                         unless $long && exists $self->{opts}->{$long};
613   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
614   ***      0                                  0      return;
615                                                   }
616                                                   
617                                                   sub save_error {
618   ***      0                    0             0      my ( $self, $error ) = @_;
619   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
620                                                   }
621                                                   
622                                                   sub errors {
623   ***      0                    0             0      my ( $self ) = @_;
624   ***      0                                  0      return $self->{errors};
625                                                   }
626                                                   
627                                                   sub prompt {
628   ***      0                    0             0      my ( $self ) = @_;
629   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
630                                                   }
631                                                   
632                                                   sub descr {
633   ***      0                    0             0      my ( $self ) = @_;
634   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
635                                                                 . "  For more details, please use the --help option, "
636                                                                 . "or try 'perldoc $PROGRAM_NAME' "
637                                                                 . "for complete documentation.";
638   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
639   ***      0                                  0      $descr =~ s/ +$//mg;
640   ***      0                                  0      return $descr;
641                                                   }
642                                                   
643                                                   sub usage_or_errors {
644   ***      0                    0             0      my ( $self ) = @_;
645   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
646   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
647   ***      0                                  0         exit 0;
648                                                      }
649                                                      elsif ( scalar @{$self->{errors}} ) {
650   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
651   ***      0                                  0         exit 0;
652                                                      }
653   ***      0                                  0      return;
654                                                   }
655                                                   
656                                                   sub print_errors {
657   ***      0                    0             0      my ( $self ) = @_;
658   ***      0                                  0      my $usage = $self->prompt() . "\n";
659   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
660   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
661                                                                 . "\n";
662                                                      }
663   ***      0                                  0      return $usage . "\n" . $self->descr();
664                                                   }
665                                                   
666                                                   sub print_usage {
667   ***      0                    0             0      my ( $self ) = @_;
668   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
669   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
670                                                   
671   ***      0      0                           0      my $maxl = max(
672   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
673                                                         @opts);
674                                                   
675   ***      0      0                           0      my $maxs = max(0,
676   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
677   ***      0                                  0         values %{$self->{short_opts}});
678                                                   
679   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
680   ***      0                                  0      my $rcol = 80 - $lcol - 6;
681   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
682                                                   
683   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
684                                                   
685   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
686                                                   
687   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
688   ***      0                                  0      push @groups, 'default';
689                                                   
690   ***      0                                  0      foreach my $group ( reverse @groups ) {
691   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
692   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
693   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
694                                                            grep { $_->{group} eq $group }
695                                                            @opts )
696                                                         {
697   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
698   ***      0                                  0            my $short = $opt->{short};
699   ***      0                                  0            my $desc  = $opt->{desc};
700   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
701   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
702   ***      0             0                    0               $s    ||= 's';
703   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
704   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
705                                                                      . "d=days; if no suffix, $s is used.";
706                                                            }
707   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
708   ***      0                                  0            $desc =~ s/ +$//mg;
709   ***      0      0                           0            if ( $short ) {
710   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
711                                                            }
712                                                            else {
713   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
714                                                            }
715                                                         }
716                                                      }
717                                                   
718   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
719   ***      0                                  0         $usage .= "\nRules:\n\n";
720   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
721                                                      }
722   ***      0      0                           0      if ( $self->{dp} ) {
723   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
724                                                      }
725   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
726   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
727   ***      0                                  0         my $val   = $opt->{value};
728   ***      0             0                    0         my $type  = $opt->{type} || '';
729   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
730   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
731                                                                   : !defined $val             ? '(No value)'
732                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
733                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
734                                                                   : $type =~ m/A|a/           ? join(',', @$val)
735                                                                   :                             $val;
736   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
737                                                      }
738   ***      0                                  0      return $usage;
739                                                   }
740                                                   
741                                                   sub prompt_noecho {
742   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
743   ***      0                                  0      my ( $prompt ) = @_;
744   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
745   ***      0      0                           0      print $prompt
746                                                         or die "Cannot print: $OS_ERROR";
747   ***      0                                  0      my $response;
748   ***      0                                  0      eval {
749   ***      0                                  0         require Term::ReadKey;
750   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
751   ***      0                                  0         chomp($response = <STDIN>);
752   ***      0                                  0         Term::ReadKey::ReadMode('normal');
753   ***      0      0                           0         print "\n"
754                                                            or die "Cannot print: $OS_ERROR";
755                                                      };
756   ***      0      0                           0      if ( $EVAL_ERROR ) {
757   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
758                                                      }
759   ***      0                                  0      return $response;
760                                                   }
761                                                   
762                                                   if ( MKDEBUG ) {
763                                                      print '# ', $^X, ' ', $], "\n";
764                                                      my $uname = `uname -a`;
765                                                      if ( $uname ) {
766                                                         $uname =~ s/\s+/ /g;
767                                                         print "# $uname\n";
768                                                      }
769                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
770                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
771                                                         ($main::SVN_REV || ''), __LINE__);
772                                                      print('# Arguments: ',
773                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
774                                                   }
775                                                   
776                                                   sub _read_config_file {
777   ***      0                    0             0      my ( $self, $filename ) = @_;
778   ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
779   ***      0                                  0      my @args;
780   ***      0                                  0      my $prefix = '--';
781   ***      0                                  0      my $parse  = 1;
782                                                   
783                                                      LINE:
784   ***      0                                  0      while ( my $line = <$fh> ) {
785   ***      0                                  0         chomp $line;
786   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
787   ***      0                                  0         $line =~ s/\s+#.*$//g;
788   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
789   ***      0      0                           0         if ( $line eq '--' ) {
790   ***      0                                  0            $prefix = '';
791   ***      0                                  0            $parse  = 0;
792   ***      0                                  0            next LINE;
793                                                         }
794   ***      0      0      0                    0         if ( $parse
      ***             0                               
795                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
796                                                         ) {
797   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
798                                                         }
799                                                         elsif ( $line =~ m/./ ) {
800   ***      0                                  0            push @args, $line;
801                                                         }
802                                                         else {
803   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
804                                                         }
805                                                      }
806   ***      0                                  0      close $fh;
807   ***      0                                  0      return @args;
808                                                   }
809                                                   
810                                                   sub read_para_after {
811   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
812   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
813   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
814   ***      0                                  0      my $para;
815   ***      0                                  0      while ( $para = <$fh> ) {
816   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
817   ***      0                                  0         last;
818                                                      }
819   ***      0                                  0      while ( $para = <$fh> ) {
820   ***      0      0                           0         next unless $para =~ m/$regex/;
821   ***      0                                  0         last;
822                                                      }
823   ***      0                                  0      $para = <$fh>;
824   ***      0                                  0      chomp($para);
825   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
826   ***      0                                  0      return $para;
827                                                   }
828                                                   
829                                                   sub clone {
830   ***      0                    0             0      my ( $self ) = @_;
831                                                   
832   ***      0                                  0      my %clone = map {
833   ***      0                                  0         my $hashref  = $self->{$_};
834   ***      0                                  0         my $val_copy = {};
835   ***      0                                  0         foreach my $key ( keys %$hashref ) {
836   ***      0                                  0            my $ref = ref $hashref->{$key};
837   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
838   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
839   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
840                                                                              : $hashref->{$key};
841                                                         }
842   ***      0                                  0         $_ => $val_copy;
843                                                      } qw(opts short_opts defaults);
844                                                   
845   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
846   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
847                                                      }
848                                                   
849   ***      0                                  0      return bless \%clone;     
850                                                   }
851                                                   
852                                                   sub _d {
853   ***      0                    0             0      my ($package, undef, $line) = caller 0;
854   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
855   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
856                                                           @_;
857   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
858                                                   }
859                                                   
860                                                   1;
861                                                   
862                                                   # ###########################################################################
863                                                   # End OptionParser package
864                                                   # ###########################################################################
865                                                   
866                                                   # ###########################################################################
867                                                   # Quoter package 5266
868                                                   # ###########################################################################
869           27                   27           310   use strict;
              27                                 95   
              27                                234   
870           27                   27           176   use warnings FATAL => 'all';
              27                                 84   
              27                                196   
871                                                   
872                                                   package Quoter;
873                                                   
874           27                   27           180   use English qw(-no_match_vars);
              27                                 78   
              27                                194   
875                                                   
876   ***     27            50     27           198   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 70   
              27                                605   
877                                                   
878                                                   sub new {
879   ***      0                    0             0      my ( $class ) = @_;
880   ***      0                                  0      bless {}, $class;
881                                                   }
882                                                   
883                                                   sub quote {
884   ***      0                    0             0      my ( $self, @vals ) = @_;
885   ***      0                                  0      foreach my $val ( @vals ) {
886   ***      0                                  0         $val =~ s/`/``/g;
887                                                      }
888   ***      0                                  0      return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                  0   
889                                                   }
890                                                   
891                                                   sub quote_val {
892   ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
893                                                   
894   ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
895   ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
896                                                   
897   ***      0      0                           0      if ( !defined $is_numeric ) {
898   ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
899                                                      }
900                                                   
901   ***      0      0                           0      return $val if $is_numeric;
902                                                   
903   ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
904   ***      0                                  0      return "'$val'";
905                                                   }
906                                                   
907                                                   sub split_unquote {
908   ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
909   ***      0                                  0      $db_tbl =~ s/`//g;
910   ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
911   ***      0      0                           0      if ( !$tbl ) {
912   ***      0                                  0         $tbl = $db;
913   ***      0                                  0         $db  = $default_db;
914                                                      }
915   ***      0                                  0      return ($db, $tbl);
916                                                   }
917                                                   
918                                                   sub literal_like {
919   ***      0                    0             0      my ( $self, $like ) = @_;
920   ***      0      0                           0      return unless $like;
921   ***      0                                  0      $like =~ s/([%_])/\\$1/g;
922   ***      0                                  0      return "'$like'";
923                                                   }
924                                                   
925                                                   1;
926                                                   
927                                                   # ###########################################################################
928                                                   # End Quoter package
929                                                   # ###########################################################################
930                                                   
931                                                   # ###########################################################################
932                                                   # DSNParser package 5266
933                                                   # ###########################################################################
934                                                   package DSNParser;
935                                                   
936           27                   27           202   use strict;
              27                                 74   
              27                                153   
937           27                   27           162   use warnings FATAL => 'all';
              27                                 76   
              27                                161   
938           27                   27           180   use English qw(-no_match_vars);
              27                                 75   
              27                                184   
939           27                   27           200   use Data::Dumper;
              27                                 76   
              27                                279   
940                                                   $Data::Dumper::Indent    = 0;
941                                                   $Data::Dumper::Quotekeys = 0;
942                                                   
943                                                   eval {
944                                                      require DBI;
945                                                   };
946                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
947                                                   
948   ***     27            50     27           188   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 80   
              27                                382   
949                                                   
950                                                   sub new {
951           24                   24           162      my ( $class, @opts ) = @_;
952           24                                633      my $self = {
953                                                         opts => {
954                                                            A => {
955                                                               desc => 'Default character set',
956                                                               dsn  => 'charset',
957                                                               copy => 1,
958                                                            },
959                                                            D => {
960                                                               desc => 'Database to use',
961                                                               dsn  => 'database',
962                                                               copy => 1,
963                                                            },
964                                                            F => {
965                                                               desc => 'Only read default options from the given file',
966                                                               dsn  => 'mysql_read_default_file',
967                                                               copy => 1,
968                                                            },
969                                                            h => {
970                                                               desc => 'Connect to host',
971                                                               dsn  => 'host',
972                                                               copy => 1,
973                                                            },
974                                                            p => {
975                                                               desc => 'Password to use when connecting',
976                                                               dsn  => 'password',
977                                                               copy => 1,
978                                                            },
979                                                            P => {
980                                                               desc => 'Port number to use for connection',
981                                                               dsn  => 'port',
982                                                               copy => 1,
983                                                            },
984                                                            S => {
985                                                               desc => 'Socket file to use for connection',
986                                                               dsn  => 'mysql_socket',
987                                                               copy => 1,
988                                                            },
989                                                            u => {
990                                                               desc => 'User for login if not current user',
991                                                               dsn  => 'user',
992                                                               copy => 1,
993                                                            },
994                                                         },
995                                                      };
996           24                                115      foreach my $opt ( @opts ) {
997   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
998   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
999                                                      }
1000          24                                299      return bless $self, $class;
1001                                                  }
1002                                                  
1003                                                  sub prop {
1004         138                  138           683      my ( $self, $prop, $value ) = @_;
1005  ***    138     50                         778      if ( @_ > 2 ) {
1006  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1007  ***      0                                  0         $self->{$prop} = $value;
1008                                                     }
1009         138                               1111      return $self->{$prop};
1010                                                  }
1011                                                  
1012                                                  sub parse {
1013          46                   46        5938633      my ( $self, $dsn, $prev, $defaults ) = @_;
1014  ***     46     50                         299      if ( !$dsn ) {
1015  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1016  ***      0                                  0         return;
1017                                                     }
1018          46                                140      MKDEBUG && _d('Parsing', $dsn);
1019  ***     46            50                  546      $prev     ||= {};
1020  ***     46            50                  284      $defaults ||= {};
1021          46                                156      my %given_props;
1022          46                                147      my %final_props;
1023          46                                184      my %opts = %{$self->{opts}};
              46                                770   
1024                                                  
1025          46                                509      foreach my $dsn_part ( split(/,/, $dsn) ) {
1026  ***    184     50                        1757         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1027         184                                913            $given_props{$prop_key} = $prop_val;
1028                                                        }
1029                                                        else {
1030  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1031  ***      0                                  0            $given_props{h} = $dsn_part;
1032                                                        }
1033                                                     }
1034                                                  
1035          46                                310      foreach my $key ( keys %opts ) {
1036         368                                812         MKDEBUG && _d('Finding value for', $key);
1037         368                               1343         $final_props{$key} = $given_props{$key};
1038  ***    368     50     66                 3201         if (   !defined $final_props{$key}
      ***                   33                        
1039                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1040                                                        {
1041  ***      0                                  0            $final_props{$key} = $prev->{$key};
1042  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1043                                                        }
1044         368    100                        1667         if ( !defined $final_props{$key} ) {
1045         184                                635            $final_props{$key} = $defaults->{$key};
1046         184                                531            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1047                                                        }
1048                                                     }
1049                                                  
1050          46                                274      foreach my $key ( keys %given_props ) {
1051  ***    184     50                         851         die "Unrecognized DSN part '$key' in '$dsn'\n"
1052                                                           unless exists $opts{$key};
1053                                                     }
1054  ***     46     50                         281      if ( (my $required = $self->prop('required')) ) {
1055  ***      0                                  0         foreach my $key ( keys %$required ) {
1056  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1057                                                        }
1058                                                     }
1059                                                  
1060          46                                366      return \%final_props;
1061                                                  }
1062                                                  
1063                                                  sub parse_options {
1064  ***      0                    0             0      my ( $self, $o ) = @_;
1065  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1066  ***      0                                  0      my $dsn_string
1067                                                        = join(',',
1068  ***      0      0                           0             map  { "$_=".$o->get($_); }
1069  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1070  ***      0                                  0             keys %{$self->{opts}}
1071                                                          );
1072  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1073  ***      0                                  0      return $self->parse($dsn_string);
1074                                                  }
1075                                                  
1076                                                  sub as_string {
1077  ***      0                    0             0      my ( $self, $dsn ) = @_;
1078  ***      0      0                           0      return $dsn unless ref $dsn;
1079  ***      0      0                           0      return join(',',
1080  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1081  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1082                                                        sort keys %$dsn );
1083                                                  }
1084                                                  
1085                                                  sub usage {
1086  ***      0                    0             0      my ( $self ) = @_;
1087  ***      0                                  0      my $usage
1088                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1089                                                        . "  KEY  COPY  MEANING\n"
1090                                                        . "  ===  ====  =============================================\n";
1091  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1092  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1093  ***      0      0      0                    0         $usage .= "  $key    "
1094                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1095                                                               .  ($opts{$key}->{desc} || '[No description]')
1096                                                               . "\n";
1097                                                     }
1098  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1099  ***      0                                  0      return $usage;
1100                                                  }
1101                                                  
1102                                                  sub get_cxn_params {
1103          46                   46           732      my ( $self, $info ) = @_;
1104          46                                143      my $dsn;
1105          46                                143      my %opts = %{$self->{opts}};
              46                                436   
1106  ***     46            50                  263      my $driver = $self->prop('dbidriver') || '';
1107  ***     46     50                         243      if ( $driver eq 'Pg' ) {
1108  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1109  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1110  ***      0             0                    0                        grep { defined $info->{$_} }
1111                                                                       qw(h P));
1112                                                     }
1113                                                     else {
1114          92                                722         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1115         230                                923            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1116  ***     46            50                  632                        grep { defined $info->{$_} }
1117                                                                       qw(F h P S A))
1118                                                           . ';mysql_read_default_group=client';
1119                                                     }
1120          46                                156      MKDEBUG && _d($dsn);
1121          46                                441      return ($dsn, $info->{u}, $info->{p});
1122                                                  }
1123                                                  
1124                                                  sub fill_in_dsn {
1125  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1126  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1127  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1128  ***      0                                  0      $user =~ s/@.*//;
1129  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1130  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1131  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1132  ***      0             0                    0      $dsn->{u} ||= $user;
1133  ***      0             0                    0      $dsn->{D} ||= $db;
1134                                                  }
1135                                                  
1136                                                  sub get_dbh {
1137          46                   46           373      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1138  ***     46            50                  230      $opts ||= {};
1139  ***     46     50                         532      my $defaults = {
1140                                                        AutoCommit         => 0,
1141                                                        RaiseError         => 1,
1142                                                        PrintError         => 0,
1143                                                        ShowErrorStatement => 1,
1144                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1145                                                     };
1146          46                                281      @{$defaults}{ keys %$opts } = values %$opts;
              46                                217   
1147                                                  
1148  ***     46     50                         241      if ( !$have_dbi ) {
1149  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1150                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1151                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1152                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1153                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1154                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1155                                                  
1156                                                     }
1157                                                  
1158          46                                137      my $dbh;
1159          46                                162      my $tries = 2;
1160  ***     46            66                  546      while ( !$dbh && $tries-- ) {
1161                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1162          46                                125            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1163                                                  
1164          46                                142         eval {
1165          46                                388            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1166                                                  
1167  ***     46     50                         513            if ( $cxn_string =~ m/mysql/i ) {
1168          46                                144               my $sql;
1169                                                  
1170          46                                193               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1171                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1172          46                                119               MKDEBUG && _d($dbh, ':', $sql);
1173          46                               5559               $dbh->do($sql);
1174                                                  
1175  ***     46     50                         409               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1176  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1177  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1178  ***      0                                  0                  $dbh->do($sql);
1179  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1180  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1181  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1182                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1183                                                                 }
1184                                                                 else {
1185  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1186                                                                 }
1187                                                              }
1188                                                  
1189  ***     46     50                         307               if ( $self->prop('set-vars') ) {
1190  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1191  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1192  ***      0                                  0                  $dbh->do($sql);
1193                                                              }
1194                                                           }
1195                                                        };
1196  ***     46     50     33                  521         if ( !$dbh && $EVAL_ERROR ) {
1197  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1198  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1199  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1200  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1201                                                           }
1202                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1203  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1204                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1205                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1206                                                                 . "DBD::mysql is not installed, try:\n"
1207                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1208                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1209                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1210                                                           }
1211  ***      0      0                           0            if ( !$tries ) {
1212  ***      0                                  0               die $EVAL_ERROR;
1213                                                           }
1214                                                        }
1215                                                     }
1216                                                  
1217          46                                119      MKDEBUG && _d('DBH info: ',
1218                                                        $dbh,
1219                                                        Dumper($dbh->selectrow_hashref(
1220                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1221                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1222                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1223                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1224                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1225                                                        '$DBI::VERSION:',        $DBI::VERSION,
1226                                                     );
1227                                                  
1228          46                                310      return $dbh;
1229                                                  }
1230                                                  
1231                                                  sub get_hostname {
1232  ***      0                    0             0      my ( $self, $dbh ) = @_;
1233  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1234  ***      0                                  0         return $host;
1235                                                     }
1236  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1237                                                        'SELECT /*!50038 @@hostname, */ 1');
1238  ***      0                                  0      return $hostname;
1239                                                  }
1240                                                  
1241                                                  sub disconnect {
1242  ***      0                    0             0      my ( $self, $dbh ) = @_;
1243  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1244  ***      0                                  0      $dbh->disconnect;
1245                                                  }
1246                                                  
1247                                                  sub print_active_handles {
1248  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1249  ***      0             0                    0      $level ||= 0;
1250  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1251                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1252                                                        or die "Cannot print: $OS_ERROR";
1253  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1254  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1255                                                     }
1256                                                  }
1257                                                  
1258                                                  sub copy {
1259  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1260  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1261  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1262  ***      0                                  0      my %new_dsn = map {
1263  ***      0                                  0         my $key = $_;
1264  ***      0                                  0         my $val;
1265  ***      0      0                           0         if ( $args{overwrite} ) {
1266  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1267                                                        }
1268                                                        else {
1269  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1270                                                        }
1271  ***      0                                  0         $key => $val;
1272  ***      0                                  0      } keys %{$self->{opts}};
1273  ***      0                                  0      return \%new_dsn;
1274                                                  }
1275                                                  
1276                                                  sub _d {
1277  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1278  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1279  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1280                                                          @_;
1281  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1282                                                  }
1283                                                  
1284                                                  1;
1285                                                  
1286                                                  # ###########################################################################
1287                                                  # End DSNParser package
1288                                                  # ###########################################################################
1289                                                  
1290                                                  # ###########################################################################
1291                                                  # VersionParser package 5266
1292                                                  # ###########################################################################
1293                                                  package VersionParser;
1294                                                  
1295          27                   27           249   use strict;
              27                                 74   
              27                                195   
1296          27                   27           175   use warnings FATAL => 'all';
              27                                 65   
              27                                173   
1297                                                  
1298          27                   27           166   use English qw(-no_match_vars);
              27                                 78   
              27                                659   
1299                                                  
1300  ***     27            50     27           198   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                110   
              27                                421   
1301                                                  
1302                                                  sub new {
1303          10                   10            77      my ( $class ) = @_;
1304          10                                122      bless {}, $class;
1305                                                  }
1306                                                  
1307                                                  sub parse {
1308           2                    2           182      my ( $self, $str ) = @_;
1309           2                                 22      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1310           2                                  9      MKDEBUG && _d($str, 'parses to', $result);
1311           2                                 15      return $result;
1312                                                  }
1313                                                  
1314                                                  sub version_ge {
1315           1                    1            26      my ( $self, $dbh, $target ) = @_;
1316  ***      1     50                           8      if ( !$self->{$dbh} ) {
1317           1                                  3         $self->{$dbh} = $self->parse(
1318                                                           $dbh->selectrow_array('SELECT VERSION()'));
1319                                                     }
1320  ***      1     50                          26      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1321           1                                  2      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
1322           1                                  5      return $result;
1323                                                  }
1324                                                  
1325                                                  sub _d {
1326  ***      0                    0                    my ($package, undef, $line) = caller 0;
1327  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1328  ***      0                                              map { defined $_ ? $_ : 'undef' }
1329                                                          @_;
1330  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1331                                                  }
1332                                                  
1333                                                  1;
1334                                                  
1335                                                  # ###########################################################################
1336                                                  # End VersionParser package
1337                                                  # ###########################################################################
1338                                                  
1339                                                  # ###########################################################################
1340                                                  # TableSyncStream package 5266
1341                                                  # ###########################################################################
1342                                                  package TableSyncStream;
1343                                                  
1344          27                   27           205   use strict;
              27                                 75   
              27                                159   
1345          27                   27           184   use warnings FATAL => 'all';
              27                                 71   
              27                                161   
1346                                                  
1347          27                   27           167   use English qw(-no_match_vars);
              27                                 69   
              27                                155   
1348                                                  
1349  ***     27            50     27           207   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 74   
              27                                375   
1350                                                  
1351                                                  sub new {
1352  ***      0                    0                    my ( $class, %args ) = @_;
1353  ***      0                                         foreach my $arg ( qw(Quoter) ) {
1354  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1355                                                     }
1356  ***      0                                         my $self = { %args };
1357  ***      0                                         return bless $self, $class;
1358                                                  }
1359                                                  
1360                                                  sub name {
1361  ***      0                    0                    return 'Stream';
1362                                                  }
1363                                                  
1364                                                  sub can_sync {
1365  ***      0                    0                    return 1;  # We can sync anything.
1366                                                  }
1367                                                  
1368                                                  sub prepare_to_sync {
1369  ***      0                    0                    my ( $self, %args ) = @_;
1370  ***      0                                         my @required_args = qw(cols ChangeHandler);
1371  ***      0                                         foreach my $arg ( @required_args ) {
1372  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1373                                                     }
1374  ***      0                                         $self->{cols}            = $args{cols};
1375  ***      0                                         $self->{buffer_in_mysql} = $args{buffer_in_mysql};
1376  ***      0                                         $self->{ChangeHandler}   = $args{ChangeHandler};
1377                                                  
1378  ***      0                                         $self->{done}  = 0;
1379                                                  
1380  ***      0                                         return;
1381                                                  }
1382                                                  
1383                                                  sub uses_checksum {
1384  ***      0                    0                    return 0;  # We don't need checksum queries.
1385                                                  }
1386                                                  
1387                                                  sub set_checksum_queries {
1388  ***      0                    0                    return;  # This shouldn't be called, but just in case.
1389                                                  }
1390                                                  
1391                                                  sub prepare_sync_cycle {
1392  ***      0                    0                    my ( $self, $host ) = @_;
1393  ***      0                                         return;
1394                                                  }
1395                                                  
1396                                                  sub get_sql {
1397  ***      0                    0                    my ( $self, %args ) = @_;
1398  ***      0                                         return "SELECT "
1399                                                        . ($self->{buffer_in_mysql} ? 'SQL_BUFFER_RESULT ' : '')
1400  ***      0      0      0                              . join(', ', map { $self->{Quoter}->quote($_) } @{$self->{cols}})
      ***      0                                      
1401                                                        . ' FROM ' . $self->{Quoter}->quote(@args{qw(database table)})
1402                                                        . ' WHERE ' . ( $args{where} || '1=1' );
1403                                                  }
1404                                                  
1405                                                  sub same_row {
1406  ***      0                    0                    my ( $self, $lr, $rr ) = @_;
1407  ***      0                                         return;
1408                                                  }
1409                                                  
1410                                                  sub not_in_right {
1411  ***      0                    0                    my ( $self, $lr ) = @_;
1412  ***      0                                         $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
1413                                                  }
1414                                                  
1415                                                  sub not_in_left {
1416  ***      0                    0                    my ( $self, $rr ) = @_;
1417  ***      0                                         $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
1418                                                  }
1419                                                  
1420                                                  sub done_with_rows {
1421  ***      0                    0                    my ( $self ) = @_;
1422  ***      0                                         $self->{done} = 1;
1423                                                  }
1424                                                  
1425                                                  sub done {
1426  ***      0                    0                    my ( $self ) = @_;
1427  ***      0                                         return $self->{done};
1428                                                  }
1429                                                  
1430                                                  sub key_cols {
1431  ***      0                    0                    my ( $self ) = @_;
1432  ***      0                                         return $self->{cols};
1433                                                  }
1434                                                  
1435                                                  sub pending_changes {
1436  ***      0                    0                    my ( $self ) = @_;
1437  ***      0                                         return;
1438                                                  }
1439                                                  
1440                                                  sub _d {
1441  ***      0                    0                    my ($package, undef, $line) = caller 0;
1442  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1443  ***      0                                              map { defined $_ ? $_ : 'undef' }
1444                                                          @_;
1445  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1446                                                  }
1447                                                  
1448                                                  1;
1449                                                  
1450                                                  # ###########################################################################
1451                                                  # End TableSyncStream package
1452                                                  # ###########################################################################
1453                                                  
1454                                                  # ###########################################################################
1455                                                  # TableParser package 5266
1456                                                  # ###########################################################################
1457                                                  package TableParser;
1458                                                  
1459          27                   27           206   use strict;
              27                                 75   
              27                                157   
1460          27                   27           168   use warnings FATAL => 'all';
              27                                312   
              27                                156   
1461          27                   27           169   use English qw(-no_match_vars);
              27                                 80   
              27                                155   
1462          27                   27           209   use Data::Dumper;
              27                                 86   
              27                                161   
1463                                                  $Data::Dumper::Indent    = 1;
1464                                                  $Data::Dumper::Sortkeys  = 1;
1465                                                  $Data::Dumper::Quotekeys = 0;
1466                                                  
1467  ***     27            50     27           173   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 78   
              27                                375   
1468                                                  
1469                                                  
1470                                                  sub new {
1471  ***      0                    0                    my ( $class, %args ) = @_;
1472  ***      0                                         my @required_args = qw(Quoter);
1473  ***      0                                         foreach my $arg ( @required_args ) {
1474  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1475                                                     }
1476  ***      0                                         my $self = { %args };
1477  ***      0                                         return bless $self, $class;
1478                                                  }
1479                                                  
1480                                                  
1481                                                  sub parse {
1482  ***      0                    0                    my ( $self, $ddl, $opts ) = @_;
1483  ***      0      0                                  return unless $ddl;
1484  ***      0      0                                  if ( ref $ddl eq 'ARRAY' ) {
1485  ***      0      0                                     if ( lc $ddl->[0] eq 'table' ) {
1486  ***      0                                               $ddl = $ddl->[1];
1487                                                        }
1488                                                        else {
1489                                                           return {
1490  ***      0                                                  engine => 'VIEW',
1491                                                           };
1492                                                        }
1493                                                     }
1494                                                  
1495  ***      0      0                                  if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
1496  ***      0                                            die "Cannot parse table definition; is ANSI quoting "
1497                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
1498                                                     }
1499                                                  
1500  ***      0                                         my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
1501  ***      0      0                                  (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
1502                                                  
1503  ***      0                                         $ddl =~ s/(`[^`]+`)/\L$1/g;
1504                                                  
1505  ***      0                                         my $engine = $self->get_engine($ddl);
1506                                                  
1507  ***      0                                         my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
1508  ***      0                                         my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                      
1509  ***      0                                         MKDEBUG && _d('Columns:', join(', ', @cols));
1510                                                  
1511  ***      0                                         my %def_for;
1512  ***      0                                         @def_for{@cols} = @defs;
1513                                                  
1514  ***      0                                         my (@nums, @null);
1515  ***      0                                         my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
1516  ***      0                                         foreach my $col ( @cols ) {
1517  ***      0                                            my $def = $def_for{$col};
1518  ***      0                                            my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
1519  ***      0      0                                     die "Can't determine column type for $def" unless $type;
1520  ***      0                                            $type_for{$col} = $type;
1521  ***      0      0                                     if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
1522  ***      0                                               push @nums, $col;
1523  ***      0                                               $is_numeric{$col} = 1;
1524                                                        }
1525  ***      0      0                                     if ( $def !~ m/NOT NULL/ ) {
1526  ***      0                                               push @null, $col;
1527  ***      0                                               $is_nullable{$col} = 1;
1528                                                        }
1529  ***      0      0                                     $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
1530                                                     }
1531                                                  
1532  ***      0                                         my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
1533                                                  
1534                                                     return {
1535  ***      0                                            name           => $name,
1536                                                        cols           => \@cols,
1537  ***      0                                            col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
1538  ***      0                                            is_col         => { map { $_ => 1 } @cols },
1539                                                        null_cols      => \@null,
1540                                                        is_nullable    => \%is_nullable,
1541                                                        is_autoinc     => \%is_autoinc,
1542                                                        clustered_key  => $clustered_key,
1543                                                        keys           => $keys,
1544                                                        defs           => \%def_for,
1545                                                        numeric_cols   => \@nums,
1546                                                        is_numeric     => \%is_numeric,
1547                                                        engine         => $engine,
1548                                                        type_for       => \%type_for,
1549                                                     };
1550                                                  }
1551                                                  
1552                                                  sub sort_indexes {
1553  ***      0                    0                    my ( $self, $tbl ) = @_;
1554                                                  
1555                                                     my @indexes
1556  ***      0                                            = sort {
1557  ***      0                                               (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
1558                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
1559                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
1560  ***      0      0      0                                 || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                        
1561                                                        }
1562                                                        grep {
1563  ***      0                                               $tbl->{keys}->{$_}->{type} eq 'BTREE'
1564                                                        }
1565  ***      0                                            sort keys %{$tbl->{keys}};
1566                                                  
1567  ***      0                                         MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
1568  ***      0                                         return @indexes;
1569                                                  }
1570                                                  
1571                                                  sub find_best_index {
1572  ***      0                    0                    my ( $self, $tbl, $index ) = @_;
1573  ***      0                                         my $best;
1574  ***      0      0                                  if ( $index ) {
1575  ***      0                                            ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                      
      ***      0                                      
1576                                                     }
1577  ***      0      0                                  if ( !$best ) {
1578  ***      0      0                                     if ( $index ) {
1579  ***      0                                               die "Index '$index' does not exist in table";
1580                                                        }
1581                                                        else {
1582  ***      0                                               ($best) = $self->sort_indexes($tbl);
1583                                                        }
1584                                                     }
1585  ***      0                                         MKDEBUG && _d('Best index found is', $best);
1586  ***      0                                         return $best;
1587                                                  }
1588                                                  
1589                                                  sub find_possible_keys {
1590  ***      0                    0                    my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
1591  ***      0      0                                  return () unless $where;
1592  ***      0                                         my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
1593                                                        . ' WHERE ' . $where;
1594  ***      0                                         MKDEBUG && _d($sql);
1595  ***      0                                         my $expl = $dbh->selectrow_hashref($sql);
1596  ***      0                                         $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                      
1597  ***      0      0                                  if ( $expl->{possible_keys} ) {
1598  ***      0                                            MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
1599  ***      0                                            my @candidates = split(',', $expl->{possible_keys});
1600  ***      0                                            my %possible   = map { $_ => 1 } @candidates;
      ***      0                                      
1601  ***      0      0                                     if ( $expl->{key} ) {
1602  ***      0                                               MKDEBUG && _d('MySQL chose', $expl->{key});
1603  ***      0                                               unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                      
1604  ***      0                                               MKDEBUG && _d('Before deduping:', join(', ', @candidates));
1605  ***      0                                               my %seen;
1606  ***      0                                               @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                      
1607                                                        }
1608  ***      0                                            MKDEBUG && _d('Final list:', join(', ', @candidates));
1609  ***      0                                            return @candidates;
1610                                                     }
1611                                                     else {
1612  ***      0                                            MKDEBUG && _d('No keys in possible_keys');
1613  ***      0                                            return ();
1614                                                     }
1615                                                  }
1616                                                  
1617                                                  sub check_table {
1618  ***      0                    0                    my ( $self, %args ) = @_;
1619  ***      0                                         my @required_args = qw(dbh db tbl);
1620  ***      0                                         foreach my $arg ( @required_args ) {
1621  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1622                                                     }
1623  ***      0                                         my ($dbh, $db, $tbl) = @args{@required_args};
1624  ***      0                                         my $q      = $self->{Quoter};
1625  ***      0                                         my $db_tbl = $q->quote($db, $tbl);
1626  ***      0                                         MKDEBUG && _d('Checking', $db_tbl);
1627                                                  
1628  ***      0                                         my $sql = "SHOW TABLES FROM " . $q->quote($db)
1629                                                             . ' LIKE ' . $q->literal_like($tbl);
1630  ***      0                                         MKDEBUG && _d($sql);
1631  ***      0                                         my $row;
1632  ***      0                                         eval {
1633  ***      0                                            $row = $dbh->selectrow_arrayref($sql);
1634                                                     };
1635  ***      0      0                                  if ( $EVAL_ERROR ) {
1636  ***      0                                            MKDEBUG && _d($EVAL_ERROR);
1637  ***      0                                            return 0;
1638                                                     }
1639  ***      0      0      0                           if ( !$row->[0] || $row->[0] ne $tbl ) {
1640  ***      0                                            MKDEBUG && _d('Table does not exist');
1641  ***      0                                            return 0;
1642                                                     }
1643                                                  
1644  ***      0                                         MKDEBUG && _d('Table exists; no privs to check');
1645  ***      0      0                                  return 1 unless $args{all_privs};
1646                                                  
1647  ***      0                                         $sql = "SHOW FULL COLUMNS FROM $db_tbl";
1648  ***      0                                         MKDEBUG && _d($sql);
1649  ***      0                                         eval {
1650  ***      0                                            $row = $dbh->selectrow_hashref($sql);
1651                                                     };
1652  ***      0      0                                  if ( $EVAL_ERROR ) {
1653  ***      0                                            MKDEBUG && _d($EVAL_ERROR);
1654  ***      0                                            return 0;
1655                                                     }
1656  ***      0      0                                  if ( !scalar keys %$row ) {
1657  ***      0                                            MKDEBUG && _d('Table has no columns:', Dumper($row));
1658  ***      0                                            return 0;
1659                                                     }
1660  ***      0             0                           my $privs = $row->{privileges} || $row->{Privileges};
1661                                                  
1662  ***      0                                         $sql = "DELETE FROM $db_tbl LIMIT 0";
1663  ***      0                                         MKDEBUG && _d($sql);
1664  ***      0                                         eval {
1665  ***      0                                            $dbh->do($sql);
1666                                                     };
1667  ***      0      0                                  my $can_delete = $EVAL_ERROR ? 0 : 1;
1668                                                  
1669  ***      0                                         MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
1670                                                        ($can_delete ? 'delete' : ''));
1671                                                  
1672  ***      0      0      0                           if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
1673                                                            && $can_delete) ) {
1674  ***      0                                            MKDEBUG && _d('User does not have all privs');
1675  ***      0                                            return 0;
1676                                                     }
1677                                                  
1678  ***      0                                         MKDEBUG && _d('User has all privs');
1679  ***      0                                         return 1;
1680                                                  }
1681                                                  
1682                                                  sub get_engine {
1683  ***      0                    0                    my ( $self, $ddl, $opts ) = @_;
1684  ***      0                                         my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
1685  ***      0                                         MKDEBUG && _d('Storage engine:', $engine);
1686  ***      0             0                           return $engine || undef;
1687                                                  }
1688                                                  
1689                                                  sub get_keys {
1690  ***      0                    0                    my ( $self, $ddl, $opts, $is_nullable ) = @_;
1691  ***      0                                         my $engine        = $self->get_engine($ddl);
1692  ***      0                                         my $keys          = {};
1693  ***      0                                         my $clustered_key = undef;
1694                                                  
1695                                                     KEY:
1696  ***      0                                         foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
1697                                                  
1698  ***      0      0                                     next KEY if $key =~ m/FOREIGN/;
1699                                                  
1700  ***      0                                            my $key_ddl = $key;
1701  ***      0                                            MKDEBUG && _d('Parsed key:', $key_ddl);
1702                                                  
1703  ***      0      0                                     if ( $engine !~ m/MEMORY|HEAP/ ) {
1704  ***      0                                               $key =~ s/USING HASH/USING BTREE/;
1705                                                        }
1706                                                  
1707  ***      0                                            my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
1708  ***      0                                            my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
1709  ***      0             0                              $type = $type || $special || 'BTREE';
      ***                    0                        
1710  ***      0      0      0                              if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
1711                                                           && $engine =~ m/HEAP|MEMORY/i )
1712                                                        {
1713  ***      0                                               $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
1714                                                        }
1715                                                  
1716  ***      0                                            my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
1717  ***      0      0                                     my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
1718  ***      0                                            my @cols;
1719  ***      0                                            my @col_prefixes;
1720  ***      0                                            foreach my $col_def ( split(',', $cols) ) {
1721  ***      0                                               my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
1722  ***      0                                               push @cols, $name;
1723  ***      0                                               push @col_prefixes, $prefix;
1724                                                        }
1725  ***      0                                            $name =~ s/`//g;
1726                                                  
1727  ***      0                                            MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
1728                                                  
1729  ***      0                                            $keys->{$name} = {
1730                                                           name         => $name,
1731                                                           type         => $type,
1732                                                           colnames     => $cols,
1733                                                           cols         => \@cols,
1734                                                           col_prefixes => \@col_prefixes,
1735                                                           is_unique    => $unique,
1736  ***      0                                               is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
1737  ***      0                                               is_col       => { map { $_ => 1 } @cols },
1738                                                           ddl          => $key_ddl,
1739                                                        };
1740                                                  
1741  ***      0      0      0                              if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
1742  ***      0                                               my $this_key = $keys->{$name};
1743  ***      0      0      0                                 if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
1744  ***      0                                                  $clustered_key = 'PRIMARY';
1745                                                           }
1746                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
1747  ***      0                                                  $clustered_key = $this_key->{name};
1748                                                           }
1749  ***      0                                               MKDEBUG && $clustered_key && _d('This key is the clustered key');
1750                                                        }
1751                                                     }
1752                                                  
1753  ***      0                                         return $keys, $clustered_key;
1754                                                  }
1755                                                  
1756                                                  sub get_fks {
1757  ***      0                    0                    my ( $self, $ddl, $opts ) = @_;
1758  ***      0                                         my $fks = {};
1759                                                  
1760  ***      0                                         foreach my $fk (
1761                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
1762                                                     {
1763  ***      0                                            my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
1764  ***      0                                            my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
1765  ***      0                                            my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
1766                                                  
1767  ***      0      0      0                              if ( $parent !~ m/\./ && $opts->{database} ) {
1768  ***      0                                               $parent = "`$opts->{database}`.$parent";
1769                                                        }
1770                                                  
1771  ***      0                                            $fks->{$name} = {
1772                                                           name           => $name,
1773                                                           colnames       => $cols,
1774  ***      0                                               cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                      
1775                                                           parent_tbl     => $parent,
1776                                                           parent_colnames=> $parent_cols,
1777  ***      0                                               parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                      
1778                                                           ddl            => $fk,
1779                                                        };
1780                                                     }
1781                                                  
1782  ***      0                                         return $fks;
1783                                                  }
1784                                                  
1785                                                  sub remove_auto_increment {
1786  ***      0                    0                    my ( $self, $ddl ) = @_;
1787  ***      0                                         $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
1788  ***      0                                         return $ddl;
1789                                                  }
1790                                                  
1791                                                  sub remove_secondary_indexes {
1792  ***      0                    0                    my ( $self, $ddl ) = @_;
1793  ***      0                                         my $sec_indexes_ddl;
1794  ***      0                                         my $tbl_struct = $self->parse($ddl);
1795                                                  
1796  ***      0      0      0                           if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
1797  ***      0                                            my $clustered_key = $tbl_struct->{clustered_key};
1798  ***      0             0                              $clustered_key  ||= '';
1799                                                  
1800  ***      0                                            my @sec_indexes   = map {
1801  ***      0                                               my $key_def = $_->{ddl};
1802  ***      0                                               $key_def =~ s/([\(\)])/\\$1/g;
1803  ***      0                                               $ddl =~ s/\s+$key_def//;
1804  ***      0                                               "ADD $_->{ddl}";
1805                                                        }
1806  ***      0                                            grep { $_->{name} ne $clustered_key }
1807  ***      0                                            values %{$tbl_struct->{keys}};
1808  ***      0                                            MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
1809                                                  
1810  ***      0      0                                     if ( @sec_indexes ) {
1811  ***      0                                               $sec_indexes_ddl = join(' ', @sec_indexes);
1812  ***      0                                               $sec_indexes_ddl =~ s/,$//;
1813                                                        }
1814                                                  
1815  ***      0                                            $ddl =~ s/,(\n\) )/$1/s;
1816                                                     }
1817                                                     else {
1818  ***      0                                            MKDEBUG && _d('Not removing secondary indexes from',
1819                                                           $tbl_struct->{engine}, 'table');
1820                                                     }
1821                                                  
1822  ***      0                                         return $ddl, $sec_indexes_ddl, $tbl_struct;
1823                                                  }
1824                                                  
1825                                                  sub _d {
1826  ***      0                    0                    my ($package, undef, $line) = caller 0;
1827  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1828  ***      0                                              map { defined $_ ? $_ : 'undef' }
1829                                                          @_;
1830  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1831                                                  }
1832                                                  
1833                                                  1;
1834                                                  
1835                                                  # ###########################################################################
1836                                                  # End TableParser package
1837                                                  # ###########################################################################
1838                                                  
1839                                                  # ###########################################################################
1840                                                  # RowDiff package 5266
1841                                                  # ###########################################################################
1842          27                   27           266   use strict;
              27                                 79   
              27                               4873   
1843          27                   27          1454   use warnings FATAL => 'all';
              27                                640   
              27                                170   
1844                                                  
1845                                                  package RowDiff;
1846                                                  
1847          27                   27           419   use English qw(-no_match_vars);
              27                                 62   
              27                                153   
1848                                                  
1849  ***     27            50     27           189   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 65   
              27                                426   
1850                                                  
1851                                                  sub new {
1852  ***      0                    0                    my ( $class, %args ) = @_;
1853  ***      0      0                                  die "I need a dbh" unless $args{dbh};
1854  ***      0                                         my $self = \%args;
1855  ***      0                                         return bless $self, $class;
1856                                                  }
1857                                                  
1858                                                  sub compare_sets {
1859  ***      0                    0                    my ( $self, %args ) = @_;
1860  ***      0                                         my ( $left, $right, $syncer, $tbl )
1861                                                        = @args{qw(left right syncer tbl)};
1862                                                  
1863  ***      0                                         my ($lr, $rr);  # Current row from the left/right sources.
1864  ***      0                                         my $done = $self->{done};
1865                                                  
1866  ***      0                                         my ($left_done, $right_done) = (0, 0);
1867                                                  
1868  ***      0             0                           do {
1869  ***      0      0      0                              if ( !$lr && !$left_done ) {
1870  ***      0                                               MKDEBUG && _d('Fetching row from left');
1871  ***      0                                               eval { $lr = $left->fetchrow_hashref(); };
      ***      0                                      
1872  ***      0                                               MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
1873  ***      0      0      0                                 $left_done = !$lr || $EVAL_ERROR ? 1 : 0;
1874                                                        }
1875                                                        elsif ( MKDEBUG ) {
1876                                                           _d('Left still has rows');
1877                                                        }
1878                                                  
1879  ***      0      0      0                              if ( !$rr && !$right_done ) {
1880  ***      0                                               MKDEBUG && _d('Fetching row from right');
1881  ***      0                                               eval { $rr = $right->fetchrow_hashref(); };
      ***      0                                      
1882  ***      0                                               MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
1883  ***      0      0      0                                 $right_done = !$rr || $EVAL_ERROR ? 1 : 0;
1884                                                        }
1885                                                        elsif ( MKDEBUG ) {
1886                                                           _d('Right still has rows');
1887                                                        }
1888                                                  
1889  ***      0                                            my $cmp;
1890  ***      0      0      0                              if ( $lr && $rr ) {
1891  ***      0                                               $cmp = $self->key_cmp($lr, $rr, $syncer->key_cols(), $tbl);
1892  ***      0                                               MKDEBUG && _d('Key comparison on left and right:', $cmp);
1893                                                        }
1894  ***      0      0      0                              if ( $lr || $rr ) {
1895  ***      0      0      0                                 if ( $lr && $rr && defined $cmp && $cmp == 0 ) {
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
1896  ***      0                                                  MKDEBUG && _d('Left and right have the same key');
1897  ***      0                                                  $syncer->same_row($lr, $rr);
1898  ***      0      0                                           $self->{same_row}->($lr, $rr) if $self->{same_row};
1899  ***      0                                                  $lr = $rr = undef; # Fetch another row from each side.
1900                                                           }
1901                                                           elsif ( !$rr || ( defined $cmp && $cmp < 0 ) ) {
1902  ***      0                                                  MKDEBUG && _d('Left is not in right');
1903  ***      0                                                  $syncer->not_in_right($lr);
1904  ***      0      0                                           $self->{not_in_right}->($lr) if $self->{not_in_right};
1905  ***      0                                                  $lr = undef;
1906                                                           }
1907                                                           else {
1908  ***      0                                                  MKDEBUG && _d('Right is not in left');
1909  ***      0                                                  $syncer->not_in_left($rr);
1910  ***      0      0                                           $self->{not_in_left}->($rr) if $self->{not_in_left};
1911  ***      0                                                  $rr = undef;
1912                                                           }
1913                                                        }
1914  ***      0      0      0                              $left_done = $right_done = 1 if $done && $done->($left, $right);
1915                                                     } while ( !($left_done && $right_done) );
1916  ***      0                                         MKDEBUG && _d('No more rows');
1917  ***      0                                         $syncer->done_with_rows();
1918                                                  }
1919                                                  
1920                                                  sub key_cmp {
1921  ***      0                    0                    my ( $self, $lr, $rr, $key_cols, $tbl ) = @_;
1922  ***      0                                         MKDEBUG && _d('Comparing keys using columns:', join(',', @$key_cols));
1923  ***      0                                         my $callback = $self->{key_cmp};
1924  ***      0                                         my $trf      = $self->{trf};
1925  ***      0                                         foreach my $col ( @$key_cols ) {
1926  ***      0                                            my $l = $lr->{$col};
1927  ***      0                                            my $r = $rr->{$col};
1928  ***      0      0      0                              if ( !defined $l || !defined $r ) {
1929  ***      0                                               MKDEBUG && _d($col, 'is not defined in both rows');
1930  ***      0      0                                        return defined $l ? 1 : defined $r ? -1 : 0;
      ***             0                               
1931                                                        }
1932                                                        else {
1933  ***      0      0                                        if ($tbl->{is_numeric}->{$col} ) {   # Numeric column
      ***             0                               
1934  ***      0                                                  MKDEBUG && _d($col, 'is numeric');
1935  ***      0      0                                           ($l, $r) = $trf->($l, $r, $tbl, $col) if $trf;
1936  ***      0                                                  my $cmp = $l <=> $r;
1937  ***      0      0                                           if ( $cmp ) {
1938  ***      0                                                     MKDEBUG && _d('Column', $col, 'differs:', $l, '!=', $r);
1939  ***      0      0                                              $callback->($col, $l, $r) if $callback;
1940  ***      0                                                     return $cmp;
1941                                                              }
1942                                                           }
1943                                                           elsif ( $l ne $r ) {
1944  ***      0                                                  my $cmp;
1945  ***      0                                                  my $coll = $tbl->{collation_for}->{$col};
1946  ***      0      0      0                                    if ( $coll && ( $coll ne 'latin1_swedish_ci'
      ***                    0                        
      ***                    0                        
1947                                                                             || $l =~ m/[^\040-\177]/ || $r =~ m/[^\040-\177]/) ) {
1948  ***      0                                                     MKDEBUG && _d('Comparing', $col, 'via MySQL');
1949  ***      0                                                     $cmp = $self->db_cmp($coll, $l, $r);
1950                                                              }
1951                                                              else {
1952  ***      0                                                     MKDEBUG && _d('Comparing', $col, 'in lowercase');
1953  ***      0                                                     $cmp = lc $l cmp lc $r;
1954                                                              }
1955  ***      0      0                                           if ( $cmp ) {
1956  ***      0                                                     MKDEBUG && _d('Column', $col, 'differs:', $l, 'ne', $r);
1957  ***      0      0                                              $callback->($col, $l, $r) if $callback;
1958  ***      0                                                     return $cmp;
1959                                                              }
1960                                                           }
1961                                                        }
1962                                                     }
1963  ***      0                                         return 0;
1964                                                  }
1965                                                  
1966                                                  sub db_cmp {
1967  ***      0                    0                    my ( $self, $collation, $l, $r ) = @_;
1968  ***      0      0                                  if ( !$self->{sth}->{$collation} ) {
1969  ***      0      0                                     if ( !$self->{charset_for} ) {
1970  ***      0                                               MKDEBUG && _d('Fetching collations from MySQL');
1971  ***      0                                               my @collations = @{$self->{dbh}->selectall_arrayref(
      ***      0                                      
1972                                                              'SHOW COLLATION', {Slice => { collation => 1, charset => 1 }})};
1973  ***      0                                               foreach my $collation ( @collations ) {
1974  ***      0                                                  $self->{charset_for}->{$collation->{collation}}
1975                                                                 = $collation->{charset};
1976                                                           }
1977                                                        }
1978  ***      0                                            my $sql = "SELECT STRCMP(_$self->{charset_for}->{$collation}? COLLATE $collation, "
1979                                                           . "_$self->{charset_for}->{$collation}? COLLATE $collation) AS res";
1980  ***      0                                            MKDEBUG && _d($sql);
1981  ***      0                                            $self->{sth}->{$collation} = $self->{dbh}->prepare($sql);
1982                                                     }
1983  ***      0                                         my $sth = $self->{sth}->{$collation};
1984  ***      0                                         $sth->execute($l, $r);
1985  ***      0                                         return $sth->fetchall_arrayref()->[0]->[0];
1986                                                  }
1987                                                  
1988                                                  sub _d {
1989  ***      0                    0                    my ($package, undef, $line) = caller 0;
1990  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1991  ***      0                                              map { defined $_ ? $_ : 'undef' }
1992                                                          @_;
1993  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1994                                                  }
1995                                                  
1996                                                  1;
1997                                                  
1998                                                  # ###########################################################################
1999                                                  # End RowDiff package
2000                                                  # ###########################################################################
2001                                                  
2002                                                  # ###########################################################################
2003                                                  # MySQLDump package 5266
2004                                                  # ###########################################################################
2005                                                  package MySQLDump;
2006                                                  
2007          27                   27           215   use strict;
              27                                 73   
              27                                154   
2008          27                   27           167   use warnings FATAL => 'all';
              27                                 61   
              27                                140   
2009                                                  
2010          27                   27           163   use English qw(-no_match_vars);
              27                                 70   
              27                                143   
2011                                                  
2012  ***     27            50     27           178   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 68   
              27                                372   
2013                                                  
2014                                                  ( our $before = <<'EOF') =~ s/^   //gm;
2015                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
2016                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
2017                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
2018                                                     /*!40101 SET NAMES utf8 */;
2019                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
2020                                                     /*!40103 SET TIME_ZONE='+00:00' */;
2021                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
2022                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2023                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2024                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2025                                                  EOF
2026                                                  
2027                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2028                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2029                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2030                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2031                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2032                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2033                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2034                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2035                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2036                                                  EOF
2037                                                  
2038                                                  sub new {
2039  ***      0                    0                    my ( $class, %args ) = @_;
2040  ***      0      0                                  $args{cache} = 1 unless defined $args{cache};
2041  ***      0                                         my $self = bless \%args, $class;
2042  ***      0                                         return $self;
2043                                                  }
2044                                                  
2045                                                  sub dump {
2046  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2047                                                  
2048  ***      0      0                                  if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2049  ***      0                                            my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2050  ***      0      0                                     return unless $ddl;
2051  ***      0      0                                     if ( $ddl->[0] eq 'table' ) {
2052  ***      0                                               return $before
2053                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2054                                                              . $ddl->[1] . ";\n";
2055                                                        }
2056                                                        else {
2057  ***      0                                               return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2058                                                              . '/*!50001 DROP VIEW IF EXISTS '
2059                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2060                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2061                                                        }
2062                                                     }
2063                                                     elsif ( $what eq 'triggers' ) {
2064  ***      0                                            my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2065  ***      0      0      0                              if ( $trgs && @$trgs ) {
2066  ***      0                                               my $result = $before . "\nDELIMITER ;;\n";
2067  ***      0                                               foreach my $trg ( @$trgs ) {
2068  ***      0      0                                           if ( $trg->{sql_mode} ) {
2069  ***      0                                                     $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2070                                                              }
2071  ***      0                                                  $result .= "/*!50003 CREATE */ ";
2072  ***      0      0                                           if ( $trg->{definer} ) {
2073  ***      0                                                     my ( $user, $host )
2074  ***      0                                                        = map { s/'/''/g; "'$_'"; }
      ***      0                                      
2075                                                                      split('@', $trg->{definer}, 2);
2076  ***      0                                                     $result .= "/*!50017 DEFINER=$user\@$host */ ";
2077                                                              }
2078  ***      0                                                  $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2079                                                                 $quoter->quote($trg->{trigger}),
2080  ***      0                                                     @{$trg}{qw(timing event)},
2081                                                                 $quoter->quote($trg->{table}),
2082                                                                 $trg->{statement});
2083                                                           }
2084  ***      0                                               $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2085  ***      0                                               return $result;
2086                                                        }
2087                                                        else {
2088  ***      0                                               return undef;
2089                                                        }
2090                                                     }
2091                                                     elsif ( $what eq 'view' ) {
2092  ***      0                                            my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2093  ***      0                                            return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2094                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2095                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2096                                                     }
2097                                                     else {
2098  ***      0                                            die "You didn't say what to dump.";
2099                                                     }
2100                                                  }
2101                                                  
2102                                                  sub _use_db {
2103  ***      0                    0                    my ( $self, $dbh, $quoter, $new ) = @_;
2104  ***      0      0                                  if ( !$new ) {
2105  ***      0                                            MKDEBUG && _d('No new DB to use');
2106  ***      0                                            return;
2107                                                     }
2108  ***      0                                         my $sql = 'SELECT DATABASE()';
2109  ***      0                                         MKDEBUG && _d($sql);
2110  ***      0                                         my $curr = $dbh->selectrow_array($sql);
2111  ***      0      0      0                           if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
2112  ***      0                                            MKDEBUG && _d('Current and new DB are the same');
2113  ***      0                                            return $curr;
2114                                                     }
2115  ***      0                                         $sql = 'USE ' . $quoter->quote($new);
2116  ***      0                                         MKDEBUG && _d($sql);
2117  ***      0                                         $dbh->do($sql);
2118  ***      0                                         return $curr;
2119                                                  }
2120                                                  
2121                                                  sub get_create_table {
2122  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2123  ***      0      0      0                           if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2124  ***      0                                            my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2125                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2126                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2127                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2128  ***      0                                            MKDEBUG && _d($sql);
2129  ***      0                                            eval { $dbh->do($sql); };
      ***      0                                      
2130  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2131  ***      0                                            my $curr_db = $self->_use_db($dbh, $quoter, $db);
2132  ***      0                                            $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2133  ***      0                                            MKDEBUG && _d($sql);
2134  ***      0                                            my $href;
2135  ***      0                                            eval { $href = $dbh->selectrow_hashref($sql); };
      ***      0                                      
2136  ***      0      0                                     if ( $EVAL_ERROR ) {
2137  ***      0                                               warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2138  ***      0                                               return;
2139                                                        }
2140  ***      0                                            $self->_use_db($dbh, $quoter, $curr_db);
2141  ***      0                                            $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2142                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2143  ***      0                                            MKDEBUG && _d($sql);
2144  ***      0                                            $dbh->do($sql);
2145  ***      0                                            my ($key) = grep { m/create table/i } keys %$href;
      ***      0                                      
2146  ***      0      0                                     if ( $key ) {
2147  ***      0                                               MKDEBUG && _d('This table is a base table');
2148  ***      0                                               $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2149                                                        }
2150                                                        else {
2151  ***      0                                               MKDEBUG && _d('This table is a view');
2152  ***      0                                               ($key) = grep { m/create view/i } keys %$href;
      ***      0                                      
2153  ***      0                                               $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2154                                                        }
2155                                                     }
2156  ***      0                                         return $self->{tables}->{$db}->{$tbl};
2157                                                  }
2158                                                  
2159                                                  sub get_columns {
2160  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2161  ***      0                                         MKDEBUG && _d('Get columns for', $db, $tbl);
2162  ***      0      0      0                           if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2163  ***      0                                            my $curr_db = $self->_use_db($dbh, $quoter, $db);
2164  ***      0                                            my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2165  ***      0                                            MKDEBUG && _d($sql);
2166  ***      0                                            my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2167  ***      0                                            $self->_use_db($dbh, $quoter, $curr_db);
2168  ***      0                                            $self->{columns}->{$db}->{$tbl} = [
2169                                                           map {
2170  ***      0                                                  my %row;
2171  ***      0                                                  @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
2172  ***      0                                                  \%row;
2173                                                           } @$cols
2174                                                        ];
2175                                                     }
2176  ***      0                                         return $self->{columns}->{$db}->{$tbl};
2177                                                  }
2178                                                  
2179                                                  sub get_tmp_table {
2180  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2181  ***      0                                         my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2182  ***      0                                         $result .= join(",\n",
2183  ***      0                                            map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2184  ***      0                                            @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2185  ***      0                                         $result .= "\n)";
2186  ***      0                                         MKDEBUG && _d($result);
2187  ***      0                                         return $result;
2188                                                  }
2189                                                  
2190                                                  sub get_triggers {
2191  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2192  ***      0      0      0                           if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2193  ***      0                                            $self->{triggers}->{$db} = {};
2194  ***      0                                            my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2195                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2196                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2197                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2198  ***      0                                            MKDEBUG && _d($sql);
2199  ***      0                                            eval { $dbh->do($sql); };
      ***      0                                      
2200  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2201  ***      0                                            $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2202  ***      0                                            MKDEBUG && _d($sql);
2203  ***      0                                            my $sth = $dbh->prepare($sql);
2204  ***      0                                            $sth->execute();
2205  ***      0      0                                     if ( $sth->rows ) {
2206  ***      0                                               my $trgs = $sth->fetchall_arrayref({});
2207  ***      0                                               foreach my $trg (@$trgs) {
2208  ***      0                                                  my %trg;
2209  ***      0                                                  @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                      
2210  ***      0                                                  push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                      
2211                                                           }
2212                                                        }
2213  ***      0                                            $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2214                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2215  ***      0                                            MKDEBUG && _d($sql);
2216  ***      0                                            $dbh->do($sql);
2217                                                     }
2218  ***      0      0                                  if ( $tbl ) {
2219  ***      0                                            return $self->{triggers}->{$db}->{$tbl};
2220                                                     }
2221  ***      0                                         return values %{$self->{triggers}->{$db}};
      ***      0                                      
2222                                                  }
2223                                                  
2224                                                  sub get_databases {
2225  ***      0                    0                    my ( $self, $dbh, $quoter, $like ) = @_;
2226  ***      0      0      0                           if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2227  ***      0                                            my $sql = 'SHOW DATABASES';
2228  ***      0                                            my @params;
2229  ***      0      0                                     if ( $like ) {
2230  ***      0                                               $sql .= ' LIKE ?';
2231  ***      0                                               push @params, $like;
2232                                                        }
2233  ***      0                                            my $sth = $dbh->prepare($sql);
2234  ***      0                                            MKDEBUG && _d($sql, @params);
2235  ***      0                                            $sth->execute( @params );
2236  ***      0                                            my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                      
      ***      0                                      
2237  ***      0      0                                     $self->{databases} = \@dbs unless $like;
2238  ***      0                                            return @dbs;
2239                                                     }
2240  ***      0                                         return @{$self->{databases}};
      ***      0                                      
2241                                                  }
2242                                                  
2243                                                  sub get_table_status {
2244  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $like ) = @_;
2245  ***      0      0      0                           if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2246  ***      0                                            my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2247  ***      0                                            my @params;
2248  ***      0      0                                     if ( $like ) {
2249  ***      0                                               $sql .= ' LIKE ?';
2250  ***      0                                               push @params, $like;
2251                                                        }
2252  ***      0                                            MKDEBUG && _d($sql, @params);
2253  ***      0                                            my $sth = $dbh->prepare($sql);
2254  ***      0                                            $sth->execute(@params);
2255  ***      0                                            my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                      
2256  ***      0                                            @tables = map {
2257  ***      0                                               my %tbl; # Make a copy with lowercased keys
2258  ***      0                                               @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
2259  ***      0             0                                 $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2260  ***      0                                               delete $tbl{type};
2261  ***      0                                               \%tbl;
2262                                                        } @tables;
2263  ***      0      0                                     $self->{table_status}->{$db} = \@tables unless $like;
2264  ***      0                                            return @tables;
2265                                                     }
2266  ***      0                                         return @{$self->{table_status}->{$db}};
      ***      0                                      
2267                                                  }
2268                                                  
2269                                                  sub get_table_list {
2270  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $like ) = @_;
2271  ***      0      0      0                           if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2272  ***      0                                            my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2273  ***      0                                            my @params;
2274  ***      0      0                                     if ( $like ) {
2275  ***      0                                               $sql .= ' LIKE ?';
2276  ***      0                                               push @params, $like;
2277                                                        }
2278  ***      0                                            MKDEBUG && _d($sql, @params);
2279  ***      0                                            my $sth = $dbh->prepare($sql);
2280  ***      0                                            $sth->execute(@params);
2281  ***      0                                            my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                      
2282  ***      0      0      0                              @tables = map {
2283  ***      0                                               my %tbl = (
2284                                                              name   => $_->[0],
2285                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2286                                                           );
2287  ***      0                                               \%tbl;
2288                                                        } @tables;
2289  ***      0      0                                     $self->{table_list}->{$db} = \@tables unless $like;
2290  ***      0                                            return @tables;
2291                                                     }
2292  ***      0                                         return @{$self->{table_list}->{$db}};
      ***      0                                      
2293                                                  }
2294                                                  
2295                                                  sub _d {
2296  ***      0                    0                    my ($package, undef, $line) = caller 0;
2297  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2298  ***      0                                              map { defined $_ ? $_ : 'undef' }
2299                                                          @_;
2300  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2301                                                  }
2302                                                  
2303                                                  1;
2304                                                  
2305                                                  # ###########################################################################
2306                                                  # End MySQLDump package
2307                                                  # ###########################################################################
2308                                                  
2309                                                  # ###########################################################################
2310                                                  # ChangeHandler package 5266
2311                                                  # ###########################################################################
2312          27                   27           250   use strict;
              27                                 74   
              27                                172   
2313          27                   27           163   use warnings FATAL => 'all';
              27                                 74   
              27                                177   
2314                                                  
2315                                                  package ChangeHandler;
2316                                                  
2317          27                   27           163   use English qw(-no_match_vars);
              27                                 77   
              27                                149   
2318                                                  
2319                                                  my $DUPE_KEY  = qr/Duplicate entry/;
2320                                                  our @ACTIONS  = qw(DELETE REPLACE INSERT UPDATE);
2321                                                  
2322  ***     27            50     27           207   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 71   
              27                                421   
2323                                                  
2324                                                  sub new {
2325  ***      0                    0                    my ( $class, %args ) = @_;
2326  ***      0                                         foreach my $arg ( qw(Quoter dst_db dst_tbl src_db src_tbl replace queue) ) {
2327  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
2328                                                     }
2329  ***      0                                         my $self = { %args, map { $_ => [] } @ACTIONS };
      ***      0                                      
2330  ***      0                                         $self->{dst_db_tbl} = $self->{Quoter}->quote(@args{qw(dst_db dst_tbl)});
2331  ***      0                                         $self->{src_db_tbl} = $self->{Quoter}->quote(@args{qw(src_db src_tbl)});
2332  ***      0                                         $self->{changes} = { map { $_ => 0 } @ACTIONS };
      ***      0                                      
2333  ***      0                                         return bless $self, $class;
2334                                                  }
2335                                                  
2336                                                  sub fetch_back {
2337  ***      0                    0                    my ( $self, $dbh ) = @_;
2338  ***      0                                         $self->{fetch_back} = $dbh;
2339  ***      0                                         MKDEBUG && _d('Will fetch rows from source when updating destination');
2340                                                  }
2341                                                  
2342                                                  sub take_action {
2343  ***      0                    0                    my ( $self, @sql ) = @_;
2344  ***      0                                         MKDEBUG && _d('Calling subroutines on', @sql);
2345  ***      0                                         foreach my $action ( @{$self->{actions}} ) {
      ***      0                                      
2346  ***      0                                            $action->(@sql);
2347                                                     }
2348                                                  }
2349                                                  
2350                                                  sub change {
2351  ***      0                    0                    my ( $self, $action, $row, $cols ) = @_;
2352  ***      0                                         MKDEBUG && _d($action, 'where', $self->make_where_clause($row, $cols));
2353                                                     $self->{changes}->{
2354  ***      0      0      0                              $self->{replace} && $action ne 'DELETE' ? 'REPLACE' : $action
2355                                                     }++;
2356  ***      0      0                                  if ( $self->{queue} ) {
2357  ***      0                                            $self->__queue($action, $row, $cols);
2358                                                     }
2359                                                     else {
2360  ***      0                                            eval {
2361  ***      0                                               my $func = "make_$action";
2362  ***      0                                               $self->take_action($self->$func($row, $cols));
2363                                                        };
2364  ***      0      0                                     if ( $EVAL_ERROR =~ m/$DUPE_KEY/ ) {
      ***             0                               
2365  ***      0                                               MKDEBUG && _d('Duplicate key violation; will queue and rewrite');
2366  ***      0                                               $self->{queue}++;
2367  ***      0                                               $self->{replace} = 1;
2368  ***      0                                               $self->__queue($action, $row, $cols);
2369                                                        }
2370                                                        elsif ( $EVAL_ERROR ) {
2371  ***      0                                               die $EVAL_ERROR;
2372                                                        }
2373                                                     }
2374                                                  }
2375                                                  
2376                                                  sub __queue {
2377  ***      0                    0                    my ( $self, $action, $row, $cols ) = @_;
2378  ***      0                                         MKDEBUG && _d('Queueing change for later');
2379  ***      0      0                                  if ( $self->{replace} ) {
2380  ***      0      0                                     $action = $action eq 'DELETE' ? $action : 'REPLACE';
2381                                                     }
2382  ***      0                                         push @{$self->{$action}}, [ $row, $cols ];
      ***      0                                      
2383                                                  }
2384                                                  
2385                                                  sub process_rows {
2386  ***      0                    0                    my ( $self, $queue_level ) = @_;
2387  ***      0                                         my $error_count = 0;
2388                                                     TRY: {
2389  ***      0      0      0                              if ( $queue_level && $queue_level < $self->{queue} ) { # see redo below!
      ***      0                                      
2390  ***      0                                               MKDEBUG && _d('Not processing now', $queue_level, '<', $self->{queue});
2391  ***      0                                               return;
2392                                                        }
2393  ***      0                                            MKDEBUG && _d('Processing rows:');
2394  ***      0                                            my ($row, $cur_act);
2395  ***      0                                            eval {
2396  ***      0                                               foreach my $action ( @ACTIONS ) {
2397  ***      0                                                  my $func = "make_$action";
2398  ***      0                                                  my $rows = $self->{$action};
2399  ***      0                                                  MKDEBUG && _d(scalar(@$rows), 'to', $action);
2400  ***      0                                                  $cur_act = $action;
2401  ***      0                                                  while ( @$rows ) {
2402  ***      0                                                     $row = shift @$rows;
2403  ***      0                                                     $self->take_action($self->$func(@$row));
2404                                                              }
2405                                                           }
2406  ***      0                                               $error_count = 0;
2407                                                        };
2408  ***      0      0      0                              if ( !$error_count++ && $EVAL_ERROR =~ m/$DUPE_KEY/ ) {
      ***             0                               
2409  ***      0                                               MKDEBUG
2410                                                              && _d('Duplicate key violation; re-queueing and rewriting');
2411  ***      0                                               $self->{queue}++; # Defer rows to the very end
2412  ***      0                                               $self->{replace} = 1;
2413  ***      0                                               $self->__queue($cur_act, @$row);
2414  ***      0                                               redo TRY;
2415                                                        }
2416                                                        elsif ( $EVAL_ERROR ) {
2417  ***      0                                               die $EVAL_ERROR;
2418                                                        }
2419                                                     }
2420                                                  }
2421                                                  
2422                                                  sub make_DELETE {
2423  ***      0                    0                    my ( $self, $row, $cols ) = @_;
2424  ***      0                                         MKDEBUG && _d('Make DELETE');
2425  ***      0                                         return "DELETE FROM $self->{dst_db_tbl} WHERE "
2426                                                        . $self->make_where_clause($row, $cols)
2427                                                        . ' LIMIT 1';
2428                                                  }
2429                                                  
2430                                                  sub make_UPDATE {
2431  ***      0                    0                    my ( $self, $row, $cols ) = @_;
2432  ***      0                                         MKDEBUG && _d('Make UPDATE');
2433  ***      0      0                                  if ( $self->{replace} ) {
2434  ***      0                                            return $self->make_row('REPLACE', $row, $cols);
2435                                                     }
2436  ***      0                                         my %in_where = map { $_ => 1 } @$cols;
      ***      0                                      
2437  ***      0                                         my $where = $self->make_where_clause($row, $cols);
2438  ***      0                                         my @cols;
2439  ***      0      0                                  if ( my $dbh = $self->{fetch_back} ) {
2440  ***      0                                            my $sql = "SELECT * FROM $self->{src_db_tbl} WHERE $where LIMIT 1";
2441  ***      0                                            MKDEBUG && _d('Fetching data for UPDATE:', $sql);
2442  ***      0                                            my $res = $dbh->selectrow_hashref($sql);
2443  ***      0                                            @{$row}{keys %$res} = values %$res;
      ***      0                                      
2444  ***      0                                            @cols = $self->sort_cols($res);
2445                                                     }
2446                                                     else {
2447  ***      0                                            @cols = $self->sort_cols($row);
2448                                                     }
2449  ***      0                                         return "UPDATE $self->{dst_db_tbl} SET "
2450                                                        . join(', ', map {
2451  ***      0                                                  $self->{Quoter}->quote($_)
2452                                                              . '=' .  $self->{Quoter}->quote_val($row->{$_})
2453  ***      0                                               } grep { !$in_where{$_} } @cols)
2454                                                        . " WHERE $where LIMIT 1";
2455                                                  }
2456                                                  
2457                                                  sub make_INSERT {
2458  ***      0                    0                    my ( $self, $row, $cols ) = @_;
2459  ***      0                                         MKDEBUG && _d('Make INSERT');
2460  ***      0      0                                  if ( $self->{replace} ) {
2461  ***      0                                            return $self->make_row('REPLACE', $row, $cols);
2462                                                     }
2463  ***      0                                         return $self->make_row('INSERT', $row, $cols);
2464                                                  }
2465                                                  
2466                                                  sub make_REPLACE {
2467  ***      0                    0                    my ( $self, $row, $cols ) = @_;
2468  ***      0                                         MKDEBUG && _d('Make REPLACE');
2469  ***      0                                         return $self->make_row('REPLACE', $row, $cols);
2470                                                  }
2471                                                  
2472                                                  sub make_row {
2473  ***      0                    0                    my ( $self, $verb, $row, $cols ) = @_;
2474  ***      0                                         my @cols; 
2475  ***      0      0                                  if ( my $dbh = $self->{fetch_back} ) {
2476  ***      0                                            my $where = $self->make_where_clause($row, $cols);
2477  ***      0                                            my $sql = "SELECT * FROM $self->{src_db_tbl} WHERE $where LIMIT 1";
2478  ***      0                                            MKDEBUG && _d('Fetching data for UPDATE:', $sql);
2479  ***      0                                            my $res = $dbh->selectrow_hashref($sql);
2480  ***      0                                            @{$row}{keys %$res} = values %$res;
      ***      0                                      
2481  ***      0                                            @cols = $self->sort_cols($res);
2482                                                     }
2483                                                     else {
2484  ***      0                                            @cols = $self->sort_cols($row);
2485                                                     }
2486  ***      0                                         my $q = $self->{Quoter};
2487  ***      0                                         return "$verb INTO $self->{dst_db_tbl}("
2488  ***      0                                            . join(', ', map { $q->quote($_) } @cols)
2489                                                        . ') VALUES ('
2490  ***      0                                            . join(', ', map { $q->quote_val($_) } @{$row}{@cols} )
      ***      0                                      
2491                                                        . ')';
2492                                                  }
2493                                                  
2494                                                  sub make_where_clause {
2495  ***      0                    0                    my ( $self, $row, $cols ) = @_;
2496  ***      0                                         my @clauses = map {
2497  ***      0                                            my $val = $row->{$_};
2498  ***      0      0                                     my $sep = defined $val ? '=' : ' IS ';
2499  ***      0                                            $self->{Quoter}->quote($_) . $sep . $self->{Quoter}->quote_val($val);
2500                                                     } @$cols;
2501  ***      0                                         return join(' AND ', @clauses);
2502                                                  }
2503                                                  
2504                                                  sub get_changes {
2505  ***      0                    0                    my ( $self ) = @_;
2506  ***      0                                         return %{$self->{changes}};
      ***      0                                      
2507                                                  }
2508                                                  
2509                                                  sub sort_cols {
2510  ***      0                    0                    my ( $self, $row ) = @_;
2511  ***      0                                         my @cols;
2512  ***      0      0                                  if ( $self->{tbl_struct} ) { 
2513  ***      0                                            my $pos = $self->{tbl_struct}->{col_posn};
2514  ***      0                                            my @not_in_tbl;
2515  ***      0                                            @cols = sort {
2516                                                              $pos->{$a} <=> $pos->{$b}
2517                                                           }
2518                                                           grep {
2519  ***      0      0                                           if ( !defined $pos->{$_} ) {
      ***      0                                      
2520  ***      0                                                     push @not_in_tbl, $_;
2521  ***      0                                                     0;
2522                                                              }
2523                                                              else {
2524  ***      0                                                     1;
2525                                                              }
2526                                                           }
2527                                                           keys %$row;
2528  ***      0      0                                     push @cols, @not_in_tbl if @not_in_tbl;
2529                                                     }
2530                                                     else {
2531  ***      0                                            @cols = sort keys %$row;
2532                                                     }
2533  ***      0                                         return @cols;
2534                                                  }
2535                                                  
2536                                                  sub _d {
2537  ***      0                    0                    my ($package, undef, $line) = caller 0;
2538  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2539  ***      0                                              map { defined $_ ? $_ : 'undef' }
2540                                                          @_;
2541  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2542                                                  }
2543                                                  
2544                                                  1;
2545                                                  
2546                                                  # ###########################################################################
2547                                                  # End ChangeHandler package
2548                                                  # ###########################################################################
2549                                                  
2550                                                  # ###########################################################################
2551                                                  # TableChunker package 5266
2552                                                  # ###########################################################################
2553          27                   27           229   use strict;
              27                                 84   
              27                                173   
2554          27                   27           165   use warnings FATAL => 'all';
              27                                 81   
              27                                162   
2555                                                  
2556                                                  package TableChunker;
2557                                                  
2558          27                   27           237   use English qw(-no_match_vars);
              27                                 68   
              27                                152   
2559          27                   27           204   use POSIX qw(ceil);
              27                                 68   
              27                                204   
2560          27                   27           180   use List::Util qw(min max);
              27                                 69   
              27                                159   
2561          27                   27           178   use Data::Dumper;
              27                                 69   
              27                                276   
2562                                                  $Data::Dumper::Indent    = 1;
2563                                                  $Data::Dumper::Sortkeys  = 1;
2564                                                  $Data::Dumper::Quotekeys = 0;
2565                                                  
2566  ***     27            50     27           184   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 65   
              27                                411   
2567                                                  
2568                                                  sub new {
2569  ***      0                    0                    my ( $class, %args ) = @_;
2570  ***      0                                         foreach my $arg ( qw(Quoter MySQLDump) ) {
2571  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2572                                                     }
2573  ***      0                                         my $self = { %args };
2574  ***      0                                         return bless $self, $class;
2575                                                  }
2576                                                  
2577                                                  my $EPOCH      = '1970-01-01';
2578                                                  my %int_types  = map { $_ => 1 }
2579                                                     qw(bigint date datetime int mediumint smallint time timestamp tinyint year);
2580                                                  my %real_types = map { $_ => 1 }
2581                                                     qw(decimal double float);
2582                                                  
2583                                                  sub find_chunk_columns {
2584  ***      0                    0                    my ( $self, %args ) = @_;
2585  ***      0                                         foreach my $arg ( qw(tbl_struct) ) {
2586  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2587                                                     }
2588  ***      0                                         my $tbl_struct = $args{tbl_struct};
2589                                                  
2590  ***      0                                         my @possible_indexes;
2591  ***      0                                         foreach my $index ( values %{ $tbl_struct->{keys} } ) {
      ***      0                                      
2592                                                  
2593  ***      0      0                                     next unless $index->{type} eq 'BTREE';
2594                                                  
2595  ***      0             0                              defined $_ && next for @{ $index->{col_prefixes} };
      ***      0                                      
      ***      0                                      
2596                                                  
2597  ***      0      0                                     if ( $args{exact} ) {
2598  ***      0      0      0                                 next unless $index->{is_unique} && @{$index->{cols}} == 1;
      ***      0                                      
2599                                                        }
2600                                                  
2601  ***      0                                            push @possible_indexes, $index;
2602                                                     }
2603                                                     MKDEBUG && _d('Possible chunk indexes in order:',
2604  ***      0                                            join(', ', map { $_->{name} } @possible_indexes));
2605                                                  
2606  ***      0                                         my $can_chunk_exact = 0;
2607  ***      0                                         my @candidate_cols;
2608  ***      0                                         foreach my $index ( @possible_indexes ) { 
2609  ***      0                                            my $col = $index->{cols}->[0];
2610                                                  
2611  ***      0      0      0                              next unless ( $int_types{$tbl_struct->{type_for}->{$col}}
2612                                                                      || $real_types{$tbl_struct->{type_for}->{$col}} );
2613                                                  
2614  ***      0                                            push @candidate_cols, { column => $col, index => $index->{name} };
2615                                                     }
2616                                                  
2617  ***      0      0      0                           $can_chunk_exact = 1 if $args{exact} && scalar @candidate_cols;
2618                                                  
2619  ***      0                                         if ( MKDEBUG ) {
2620                                                        my $chunk_type = $args{exact} ? 'Exact' : 'Inexact';
2621                                                        _d($chunk_type, 'chunkable:',
2622                                                           join(', ', map { "$_->{column} on $_->{index}" } @candidate_cols));
2623                                                     }
2624                                                  
2625  ***      0                                         my @result;
2626  ***      0                                         MKDEBUG && _d('Ordering columns by order in tbl, PK first');
2627  ***      0      0                                  if ( $tbl_struct->{keys}->{PRIMARY} ) {
2628  ***      0                                            my $pk_first_col = $tbl_struct->{keys}->{PRIMARY}->{cols}->[0];
2629  ***      0                                            @result          = grep { $_->{column} eq $pk_first_col } @candidate_cols;
      ***      0                                      
2630  ***      0                                            @candidate_cols  = grep { $_->{column} ne $pk_first_col } @candidate_cols;
      ***      0                                      
2631                                                     }
2632  ***      0                                         my $i = 0;
2633  ***      0                                         my %col_pos = map { $_ => $i++ } @{$tbl_struct->{cols}};
      ***      0                                      
      ***      0                                      
2634  ***      0                                         push @result, sort { $col_pos{$a->{column}} <=> $col_pos{$b->{column}} }
      ***      0                                      
2635                                                                      @candidate_cols;
2636                                                  
2637  ***      0                                         if ( MKDEBUG ) {
2638                                                        _d('Chunkable columns:',
2639                                                           join(', ', map { "$_->{column} on $_->{index}" } @result));
2640                                                        _d('Can chunk exactly:', $can_chunk_exact);
2641                                                     }
2642                                                  
2643  ***      0                                         return ($can_chunk_exact, @result);
2644                                                  }
2645                                                  
2646                                                  sub calculate_chunks {
2647  ***      0                    0                    my ( $self, %args ) = @_;
2648  ***      0                                         foreach my $arg ( qw(dbh tbl_struct chunk_col min max rows_in_range
2649                                                                          chunk_size dbh) ) {
2650  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
2651                                                     }
2652  ***      0                                         MKDEBUG && _d('Calculate chunks for', Dumper(\%args));
2653  ***      0                                         my $dbh = $args{dbh};
2654                                                  
2655  ***      0                                         my @chunks;
2656  ***      0                                         my ($range_func, $start_point, $end_point);
2657  ***      0                                         my $col_type = $args{tbl_struct}->{type_for}->{$args{chunk_col}};
2658  ***      0                                         MKDEBUG && _d('chunk col type:', $col_type);
2659                                                  
2660                                                  
2661  ***      0      0                                  if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
2662  ***      0                                            $start_point = $args{min};
2663  ***      0                                            $end_point   = $args{max};
2664  ***      0                                            $range_func  = 'range_num';
2665                                                     }
2666                                                     elsif ( $col_type eq 'timestamp' ) {
2667  ***      0                                            my $sql = "SELECT UNIX_TIMESTAMP('$args{min}'), UNIX_TIMESTAMP('$args{max}')";
2668  ***      0                                            MKDEBUG && _d($sql);
2669  ***      0                                            ($start_point, $end_point) = $dbh->selectrow_array($sql);
2670  ***      0                                            $range_func  = 'range_timestamp';
2671                                                     }
2672                                                     elsif ( $col_type eq 'date' ) {
2673  ***      0                                            my $sql = "SELECT TO_DAYS('$args{min}'), TO_DAYS('$args{max}')";
2674  ***      0                                            MKDEBUG && _d($sql);
2675  ***      0                                            ($start_point, $end_point) = $dbh->selectrow_array($sql);
2676  ***      0                                            $range_func  = 'range_date';
2677                                                     }
2678                                                     elsif ( $col_type eq 'time' ) {
2679  ***      0                                            my $sql = "SELECT TIME_TO_SEC('$args{min}'), TIME_TO_SEC('$args{max}')";
2680  ***      0                                            MKDEBUG && _d($sql);
2681  ***      0                                            ($start_point, $end_point) = $dbh->selectrow_array($sql);
2682  ***      0                                            $range_func  = 'range_time';
2683                                                     }
2684                                                     elsif ( $col_type eq 'datetime' ) {
2685  ***      0                                            $start_point = $self->timestampdiff($dbh, $args{min});
2686  ***      0                                            $end_point   = $self->timestampdiff($dbh, $args{max});
2687  ***      0                                            $range_func  = 'range_datetime';
2688                                                     }
2689                                                     else {
2690  ***      0                                            die "I don't know how to chunk $col_type\n";
2691                                                     }
2692                                                  
2693  ***      0      0                                  if ( !defined $start_point ) {
2694  ***      0                                            MKDEBUG && _d('Start point is undefined');
2695  ***      0                                            $start_point = 0;
2696                                                     }
2697  ***      0      0      0                           if ( !defined $end_point || $end_point < $start_point ) {
2698  ***      0                                            MKDEBUG && _d('End point is undefined or before start point');
2699  ***      0                                            $end_point = 0;
2700                                                     }
2701  ***      0                                         MKDEBUG && _d('Start and end of chunk range:',$start_point,',', $end_point);
2702                                                  
2703  ***      0                                         my $interval = $args{chunk_size}
2704                                                                  * ($end_point - $start_point)
2705                                                                  / $args{rows_in_range};
2706  ***      0      0                                  if ( $int_types{$col_type} ) {
2707  ***      0                                            $interval = ceil($interval);
2708                                                     }
2709  ***      0             0                           $interval ||= $args{chunk_size};
2710  ***      0      0                                  if ( $args{exact} ) {
2711  ***      0                                            $interval = $args{chunk_size};
2712                                                     }
2713  ***      0                                         MKDEBUG && _d('Chunk interval:', $interval, 'units');
2714                                                  
2715  ***      0                                         my $col = $self->{Quoter}->quote($args{chunk_col});
2716  ***      0      0                                  if ( $start_point < $end_point ) {
2717  ***      0                                            my ( $beg, $end );
2718  ***      0                                            my $iter = 0;
2719                                                        for ( my $i = $start_point; $i < $end_point; $i += $interval ) {
2720  ***      0                                               ( $beg, $end ) = $self->$range_func($dbh, $i, $interval, $end_point);
2721                                                  
2722  ***      0      0                                        if ( $iter++ == 0 ) {
2723  ***      0                                                  push @chunks, "$col < " . $self->quote($end);
2724                                                           }
2725                                                           else {
2726  ***      0                                                  push @chunks, "$col >= " . $self->quote($beg) . " AND $col < " . $self->quote($end);
2727                                                           }
2728  ***      0                                            }
2729                                                  
2730  ***      0                                            my $nullable = $args{tbl_struct}->{is_nullable}->{$args{chunk_col}};
2731  ***      0                                            pop @chunks;
2732  ***      0      0                                     if ( @chunks ) {
2733  ***      0                                               push @chunks, "$col >= " . $self->quote($beg);
2734                                                        }
2735                                                        else {
2736  ***      0      0                                        push @chunks, $nullable ? "$col IS NOT NULL" : '1=1';
2737                                                        }
2738  ***      0      0                                     if ( $nullable ) {
2739  ***      0                                               push @chunks, "$col IS NULL";
2740                                                        }
2741                                                  
2742                                                     }
2743                                                     else {
2744  ***      0                                            MKDEBUG && _d('No chunks; using single chunk 1=1');
2745  ***      0                                            push @chunks, '1=1';
2746                                                     }
2747                                                  
2748  ***      0                                         return @chunks;
2749                                                  }
2750                                                  
2751                                                  sub get_first_chunkable_column {
2752  ***      0                    0                    my ( $self, %args ) = @_;
2753  ***      0                                         foreach my $arg ( qw(tbl_struct) ) {
2754  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2755                                                     }
2756  ***      0                                         my ($exact, @cols) = $self->find_chunk_columns(%args);
2757  ***      0                                         return ( $cols[0]->{column}, $cols[0]->{index} );
2758                                                  }
2759                                                  
2760                                                  sub size_to_rows {
2761  ***      0                    0                    my ( $self, %args ) = @_;
2762  ***      0                                         my @required_args = qw(dbh db tbl chunk_size);
2763  ***      0                                         foreach my $arg ( @required_args ) {
2764  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2765                                                     }
2766  ***      0                                         my ($dbh, $db, $tbl, $chunk_size) = @args{@required_args};
2767  ***      0                                         my $q  = $self->{Quoter};
2768  ***      0                                         my $du = $self->{MySQLDump};
2769                                                  
2770  ***      0                                         my ($n_rows, $avg_row_length);
2771                                                  
2772  ***      0                                         my ( $num, $suffix ) = $chunk_size =~ m/^(\d+)([MGk])?$/;
2773  ***      0      0                                  if ( $suffix ) { # Convert to bytes.
      ***             0                               
2774  ***      0      0                                     $chunk_size = $suffix eq 'k' ? $num * 1_024
      ***             0                               
2775                                                                    : $suffix eq 'M' ? $num * 1_024 * 1_024
2776                                                                    :                  $num * 1_024 * 1_024 * 1_024;
2777                                                     }
2778                                                     elsif ( $num ) {
2779  ***      0                                            $n_rows = $num;
2780                                                     }
2781                                                     else {
2782  ***      0                                            die "Invalid chunk size $chunk_size; must be an integer "
2783                                                           . "with optional suffix kMG";
2784                                                     }
2785                                                  
2786  ***      0      0      0                           if ( $suffix || $args{avg_row_length} ) {
2787  ***      0                                            my ($status) = $du->get_table_status($dbh, $q, $db, $tbl);
2788  ***      0                                            $avg_row_length = $status->{avg_row_length};
2789  ***      0      0                                     if ( !defined $n_rows ) {
2790  ***      0      0                                        $n_rows = $avg_row_length ? ceil($chunk_size / $avg_row_length) : undef;
2791                                                        }
2792                                                     }
2793                                                  
2794  ***      0      0                                  return wantarray ? ($n_rows, $avg_row_length) : $n_rows;
2795                                                  }
2796                                                  
2797                                                  sub get_range_statistics {
2798  ***      0                    0                    my ( $self, %args ) = @_;
2799  ***      0                                         my @required_args = qw(dbh db tbl chunk_col);
2800  ***      0                                         foreach my $arg ( @required_args ) {
2801  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2802                                                     }
2803  ***      0                                         my ($dbh, $db, $tbl, $col) = @args{@required_args};
2804  ***      0                                         my $where = $args{where};
2805  ***      0                                         my $q = $self->{Quoter};
2806  ***      0      0                                  my $sql = "SELECT MIN(" . $q->quote($col) . "), MAX(" . $q->quote($col)
2807                                                        . ") FROM " . $q->quote($db, $tbl)
2808                                                        . ($where ? " WHERE $where" : '');
2809  ***      0                                         MKDEBUG && _d($sql);
2810  ***      0                                         my ( $min, $max );
2811  ***      0                                         eval {
2812  ***      0                                            ( $min, $max ) = $dbh->selectrow_array($sql);
2813                                                     };
2814  ***      0      0                                  if ( $EVAL_ERROR ) {
2815  ***      0                                            chomp $EVAL_ERROR;
2816  ***      0      0                                     if ( $EVAL_ERROR =~ m/in your SQL syntax/ ) {
2817  ***      0                                               die "$EVAL_ERROR (WHERE clause: $where)";
2818                                                        }
2819                                                        else {
2820  ***      0                                               die $EVAL_ERROR;
2821                                                        }
2822                                                     }
2823  ***      0      0                                  $sql = "EXPLAIN SELECT * FROM " . $q->quote($db, $tbl)
2824                                                        . ($where ? " WHERE $where" : '');
2825  ***      0                                         MKDEBUG && _d($sql);
2826  ***      0                                         my $expl = $dbh->selectrow_hashref($sql);
2827                                                     return (
2828  ***      0                                            min           => $min,
2829                                                        max           => $max,
2830                                                        rows_in_range => $expl->{rows},
2831                                                     );
2832                                                  }
2833                                                  
2834                                                  sub quote {
2835  ***      0                    0                    my ( $self, $val ) = @_;
2836  ***      0      0                                  return $val =~ m/\d[:-]/ ? qq{"$val"} : $val;
2837                                                  }
2838                                                  
2839                                                  sub inject_chunks {
2840  ***      0                    0                    my ( $self, %args ) = @_;
2841  ***      0                                         foreach my $arg ( qw(database table chunks chunk_num query) ) {
2842  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
2843                                                     }
2844  ***      0                                         MKDEBUG && _d('Injecting chunk', $args{chunk_num});
2845  ***      0                                         my $query   = $args{query};
2846  ***      0                                         my $comment = sprintf("/*%s.%s:%d/%d*/",
2847                                                        $args{database}, $args{table},
2848  ***      0                                            $args{chunk_num} + 1, scalar @{$args{chunks}});
2849  ***      0                                         $query =~ s!/\*PROGRESS_COMMENT\*/!$comment!;
2850  ***      0                                         my $where = "WHERE (" . $args{chunks}->[$args{chunk_num}] . ')';
2851  ***      0      0      0                           if ( $args{where} && grep { $_ } @{$args{where}} ) {
      ***      0                                      
      ***      0                                      
2852  ***      0                                            $where .= " AND ("
2853  ***      0                                               . join(" AND ", map { "($_)" } grep { $_ } @{$args{where}} )
      ***      0                                      
      ***      0                                      
2854                                                           . ")";
2855                                                     }
2856  ***      0                                         my $db_tbl     = $self->{Quoter}->quote(@args{qw(database table)});
2857  ***      0             0                           my $index_hint = $args{index_hint} || '';
2858                                                  
2859  ***      0                                         MKDEBUG && _d('Parameters:',
2860                                                        Dumper({WHERE => $where, DB_TBL => $db_tbl, INDEX_HINT => $index_hint}));
2861  ***      0                                         $query =~ s!/\*WHERE\*/! $where!;
2862  ***      0                                         $query =~ s!/\*DB_TBL\*/!$db_tbl!;
2863  ***      0                                         $query =~ s!/\*INDEX_HINT\*/! $index_hint!;
2864  ***      0                                         $query =~ s!/\*CHUNK_NUM\*/! $args{chunk_num} AS chunk_num,!;
2865                                                  
2866  ***      0                                         return $query;
2867                                                  }
2868                                                  
2869                                                  sub range_num {
2870  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
2871  ***      0                                         my $end = min($max, $start + $interval);
2872                                                  
2873                                                  
2874  ***      0      0                                  $start = sprintf('%.17f', $start) if $start =~ /e/;
2875  ***      0      0                                  $end   = sprintf('%.17f', $end)   if $end   =~ /e/;
2876                                                  
2877  ***      0                                         $start =~ s/\.(\d{5}).*$/.$1/;
2878  ***      0                                         $end   =~ s/\.(\d{5}).*$/.$1/;
2879                                                  
2880  ***      0      0                                  if ( $end > $start ) {
2881  ***      0                                            return ( $start, $end );
2882                                                     }
2883                                                     else {
2884  ***      0                                            die "Chunk size is too small: $end !> $start\n";
2885                                                     }
2886                                                  }
2887                                                  
2888                                                  sub range_time {
2889  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
2890  ***      0                                         my $sql = "SELECT SEC_TO_TIME($start), SEC_TO_TIME(LEAST($max, $start + $interval))";
2891  ***      0                                         MKDEBUG && _d($sql);
2892  ***      0                                         return $dbh->selectrow_array($sql);
2893                                                  }
2894                                                  
2895                                                  sub range_date {
2896  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
2897  ***      0                                         my $sql = "SELECT FROM_DAYS($start), FROM_DAYS(LEAST($max, $start + $interval))";
2898  ***      0                                         MKDEBUG && _d($sql);
2899  ***      0                                         return $dbh->selectrow_array($sql);
2900                                                  }
2901                                                  
2902                                                  sub range_datetime {
2903  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
2904  ***      0                                         my $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $start SECOND), "
2905                                                         . "DATE_ADD('$EPOCH', INTERVAL LEAST($max, $start + $interval) SECOND)";
2906  ***      0                                         MKDEBUG && _d($sql);
2907  ***      0                                         return $dbh->selectrow_array($sql);
2908                                                  }
2909                                                  
2910                                                  sub range_timestamp {
2911  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
2912  ***      0                                         my $sql = "SELECT FROM_UNIXTIME($start), FROM_UNIXTIME(LEAST($max, $start + $interval))";
2913  ***      0                                         MKDEBUG && _d($sql);
2914  ***      0                                         return $dbh->selectrow_array($sql);
2915                                                  }
2916                                                  
2917                                                  sub timestampdiff {
2918  ***      0                    0                    my ( $self, $dbh, $time ) = @_;
2919  ***      0                                         my $sql = "SELECT (COALESCE(TO_DAYS('$time'), 0) * 86400 + TIME_TO_SEC('$time')) "
2920                                                        . "- TO_DAYS('$EPOCH 00:00:00') * 86400";
2921  ***      0                                         MKDEBUG && _d($sql);
2922  ***      0                                         my ( $diff ) = $dbh->selectrow_array($sql);
2923  ***      0                                         $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $diff SECOND)";
2924  ***      0                                         MKDEBUG && _d($sql);
2925  ***      0                                         my ( $check ) = $dbh->selectrow_array($sql);
2926  ***      0      0                                  die <<"   EOF"
2927                                                     Incorrect datetime math: given $time, calculated $diff but checked to $check.
2928                                                     This is probably because you are using a version of MySQL that overflows on
2929                                                     large interval values to DATE_ADD().  If not, please report this as a bug.
2930                                                     EOF
2931                                                        unless $check eq $time;
2932  ***      0                                         return $diff;
2933                                                  }
2934                                                  
2935                                                  sub _d {
2936  ***      0                    0                    my ($package, undef, $line) = caller 0;
2937  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2938  ***      0                                              map { defined $_ ? $_ : 'undef' }
2939                                                          @_;
2940  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2941                                                  }
2942                                                  
2943                                                  1;
2944                                                  
2945                                                  # ###########################################################################
2946                                                  # End TableChunker package
2947                                                  # ###########################################################################
2948                                                  
2949                                                  # ###########################################################################
2950                                                  # TableChecksum package 5266
2951                                                  # ###########################################################################
2952                                                  package TableChecksum;
2953                                                  
2954          27                   27           241   use strict;
              27                                 74   
              27                                184   
2955          27                   27           170   use warnings FATAL => 'all';
              27                                 67   
              27                                187   
2956          27                   27           167   use English qw(-no_match_vars);
              27                                 70   
              27                                165   
2957          27                   27           213   use List::Util qw(max);
              27                                 63   
              27                                152   
2958                                                  
2959  ***     27            50     27           170   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 77   
              27                                412   
2960                                                  
2961                                                  our %ALGOS = (
2962                                                     CHECKSUM => { pref => 0, hash => 0 },
2963                                                     BIT_XOR  => { pref => 2, hash => 1 },
2964                                                     ACCUM    => { pref => 3, hash => 1 },
2965                                                  );
2966                                                  
2967                                                  sub new {
2968  ***      0                    0                    my ( $class, %args ) = @_;
2969  ***      0                                         foreach my $arg ( qw(Quoter VersionParser) ) {
2970  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
2971                                                     }
2972  ***      0                                         my $self = { %args };
2973  ***      0                                         return bless $self, $class;
2974                                                  }
2975                                                  
2976                                                  sub crc32 {
2977  ***      0                    0                    my ( $self, $string ) = @_;
2978  ***      0                                         my $poly = 0xEDB88320;
2979  ***      0                                         my $crc  = 0xFFFFFFFF;
2980  ***      0                                         foreach my $char ( split(//, $string) ) {
2981  ***      0                                            my $comp = ($crc ^ ord($char)) & 0xFF;
2982  ***      0                                            for ( 1 .. 8 ) {
2983  ***      0      0                                        $comp = $comp & 1 ? $poly ^ ($comp >> 1) : $comp >> 1;
2984                                                        }
2985  ***      0                                            $crc = (($crc >> 8) & 0x00FFFFFF) ^ $comp;
2986                                                     }
2987  ***      0                                         return $crc ^ 0xFFFFFFFF;
2988                                                  }
2989                                                  
2990                                                  sub get_crc_wid {
2991  ***      0                    0                    my ( $self, $dbh, $func ) = @_;
2992  ***      0                                         my $crc_wid = 16;
2993  ***      0      0      0                           if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
2994  ***      0                                            eval {
2995  ***      0                                               my ($val) = $dbh->selectrow_array("SELECT $func('a')");
2996  ***      0                                               $crc_wid = max(16, length($val));
2997                                                        };
2998                                                     }
2999  ***      0                                         return $crc_wid;
3000                                                  }
3001                                                  
3002                                                  sub get_crc_type {
3003  ***      0                    0                    my ( $self, $dbh, $func ) = @_;
3004  ***      0                                         my $type   = '';
3005  ***      0                                         my $length = 0;
3006  ***      0                                         my $sql    = "SELECT $func('a')";
3007  ***      0                                         my $sth    = $dbh->prepare($sql);
3008  ***      0                                         eval {
3009  ***      0                                            $sth->execute();
3010  ***      0                                            $type   = $sth->{mysql_type_name}->[0];
3011  ***      0                                            $length = $sth->{mysql_length}->[0];
3012  ***      0                                            MKDEBUG && _d($sql, $type, $length);
3013  ***      0      0      0                              if ( $type eq 'bigint' && $length < 20 ) {
3014  ***      0                                               $type = 'int';
3015                                                        }
3016                                                     };
3017  ***      0                                         $sth->finish;
3018  ***      0                                         MKDEBUG && _d('crc_type:', $type, 'length:', $length);
3019  ***      0                                         return ($type, $length);
3020                                                  }
3021                                                  
3022                                                  sub best_algorithm {
3023  ***      0                    0                    my ( $self, %args ) = @_;
3024  ***      0                                         my ( $alg, $dbh ) = @args{ qw(algorithm dbh) };
3025  ***      0                                         my $vp = $self->{VersionParser};
3026  ***      0                                         my @choices = sort { $ALGOS{$a}->{pref} <=> $ALGOS{$b}->{pref} } keys %ALGOS;
      ***      0                                      
3027  ***      0      0      0                           die "Invalid checksum algorithm $alg"
3028                                                        if $alg && !$ALGOS{$alg};
3029                                                  
3030  ***      0      0      0                           if (
      ***                    0                        
      ***                    0                        
3031                                                        $args{where} || $args{chunk}        # CHECKSUM does whole table
3032                                                        || $args{replicate}                 # CHECKSUM can't do INSERT.. SELECT
3033                                                        || !$vp->version_ge($dbh, '4.1.1')) # CHECKSUM doesn't exist
3034                                                     {
3035  ***      0                                            MKDEBUG && _d('Cannot use CHECKSUM algorithm');
3036  ***      0                                            @choices = grep { $_ ne 'CHECKSUM' } @choices;
      ***      0                                      
3037                                                     }
3038                                                  
3039  ***      0      0                                  if ( !$vp->version_ge($dbh, '4.1.1') ) {
3040  ***      0                                            MKDEBUG && _d('Cannot use BIT_XOR algorithm because MySQL < 4.1.1');
3041  ***      0                                            @choices = grep { $_ ne 'BIT_XOR' } @choices;
      ***      0                                      
3042                                                     }
3043                                                  
3044  ***      0      0      0                           if ( $alg && grep { $_ eq $alg } @choices ) {
      ***      0                                      
3045  ***      0                                            MKDEBUG && _d('User requested', $alg, 'algorithm');
3046  ***      0                                            return $alg;
3047                                                     }
3048                                                  
3049  ***      0      0      0                           if ( $args{count} && grep { $_ ne 'CHECKSUM' } @choices ) {
      ***      0                                      
3050  ***      0                                            MKDEBUG && _d('Not using CHECKSUM algorithm because COUNT desired');
3051  ***      0                                            @choices = grep { $_ ne 'CHECKSUM' } @choices;
      ***      0                                      
3052                                                     }
3053                                                  
3054  ***      0                                         MKDEBUG && _d('Algorithms, in order:', @choices);
3055  ***      0                                         return $choices[0];
3056                                                  }
3057                                                  
3058                                                  sub is_hash_algorithm {
3059  ***      0                    0                    my ( $self, $algorithm ) = @_;
3060  ***      0             0                           return $ALGOS{$algorithm} && $ALGOS{$algorithm}->{hash};
3061                                                  }
3062                                                  
3063                                                  sub choose_hash_func {
3064  ***      0                    0                    my ( $self, %args ) = @_;
3065  ***      0                                         my @funcs = qw(CRC32 FNV1A_64 FNV_64 MD5 SHA1);
3066  ***      0      0                                  if ( $args{function} ) {
3067  ***      0                                            unshift @funcs, $args{function};
3068                                                     }
3069  ***      0                                         my ($result, $error);
3070  ***      0             0                           do {
3071  ***      0                                            my $func;
3072  ***      0                                            eval {
3073  ***      0                                               $func = shift(@funcs);
3074  ***      0                                               my $sql = "SELECT $func('test-string')";
3075  ***      0                                               MKDEBUG && _d($sql);
3076  ***      0                                               $args{dbh}->do($sql);
3077  ***      0                                               $result = $func;
3078                                                        };
3079  ***      0      0      0                              if ( $EVAL_ERROR && $EVAL_ERROR =~ m/failed: (.*?) at \S+ line/ ) {
3080  ***      0                                               $error .= qq{$func cannot be used because "$1"\n};
3081  ***      0                                               MKDEBUG && _d($func, 'cannot be used because', $1);
3082                                                        }
3083                                                     } while ( @funcs && !$result );
3084                                                  
3085  ***      0      0                                  die $error unless $result;
3086  ***      0                                         MKDEBUG && _d('Chosen hash func:', $result);
3087  ***      0                                         return $result;
3088                                                  }
3089                                                  
3090                                                  sub optimize_xor {
3091  ***      0                    0                    my ( $self, %args ) = @_;
3092  ***      0                                         my ($dbh, $func) = @args{qw(dbh function)};
3093                                                  
3094  ***      0      0                                  die "$func never needs the BIT_XOR optimization"
3095                                                        if $func =~ m/^(?:FNV1A_64|FNV_64|CRC32)$/i;
3096                                                  
3097  ***      0                                         my $opt_slice = 0;
3098  ***      0                                         my $unsliced  = uc $dbh->selectall_arrayref("SELECT $func('a')")->[0]->[0];
3099  ***      0                                         my $sliced    = '';
3100  ***      0                                         my $start     = 1;
3101  ***      0      0                                  my $crc_wid   = length($unsliced) < 16 ? 16 : length($unsliced);
3102                                                  
3103  ***      0             0                           do { # Try different positions till sliced result equals non-sliced.
3104  ***      0                                            MKDEBUG && _d('Trying slice', $opt_slice);
3105  ***      0                                            $dbh->do('SET @crc := "", @cnt := 0');
3106  ***      0                                            my $slices = $self->make_xor_slices(
3107                                                           query     => "\@crc := $func('a')",
3108                                                           crc_wid   => $crc_wid,
3109                                                           opt_slice => $opt_slice,
3110                                                        );
3111                                                  
3112  ***      0                                            my $sql = "SELECT CONCAT($slices) AS TEST FROM (SELECT NULL) AS x";
3113  ***      0                                            $sliced = ($dbh->selectrow_array($sql))[0];
3114  ***      0      0                                     if ( $sliced ne $unsliced ) {
3115  ***      0                                               MKDEBUG && _d('Slice', $opt_slice, 'does not work');
3116  ***      0                                               $start += 16;
3117  ***      0                                               ++$opt_slice;
3118                                                        }
3119                                                     } while ( $start < $crc_wid && $sliced ne $unsliced );
3120                                                  
3121  ***      0      0                                  if ( $sliced eq $unsliced ) {
3122  ***      0                                            MKDEBUG && _d('Slice', $opt_slice, 'works');
3123  ***      0                                            return $opt_slice;
3124                                                     }
3125                                                     else {
3126  ***      0                                            MKDEBUG && _d('No slice works');
3127  ***      0                                            return undef;
3128                                                     }
3129                                                  }
3130                                                  
3131                                                  sub make_xor_slices {
3132  ***      0                    0                    my ( $self, %args ) = @_;
3133  ***      0                                         foreach my $arg ( qw(query crc_wid) ) {
3134  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
3135                                                     }
3136  ***      0                                         my ( $query, $crc_wid, $opt_slice ) = @args{qw(query crc_wid opt_slice)};
3137                                                  
3138  ***      0                                         my @slices;
3139                                                     for ( my $start = 1; $start <= $crc_wid; $start += 16 ) {
3140  ***      0                                            my $len = $crc_wid - $start + 1;
3141  ***      0      0                                     if ( $len > 16 ) {
3142  ***      0                                               $len = 16;
3143                                                        }
3144  ***      0                                            push @slices,
3145                                                           "LPAD(CONV(BIT_XOR("
3146                                                           . "CAST(CONV(SUBSTRING(\@crc, $start, $len), 16, 10) AS UNSIGNED))"
3147                                                           . ", 10, 16), $len, '0')";
3148  ***      0                                         }
3149                                                  
3150  ***      0      0      0                           if ( defined $opt_slice && $opt_slice < @slices ) {
3151  ***      0                                            $slices[$opt_slice] =~ s/\@crc/\@crc := $query/;
3152                                                     }
3153                                                     else {
3154  ***      0                                            map { s/\@crc/$query/ } @slices;
      ***      0                                      
3155                                                     }
3156                                                  
3157  ***      0                                         return join(', ', @slices);
3158                                                  }
3159                                                  
3160                                                  sub make_row_checksum {
3161  ***      0                    0                    my ( $self, %args ) = @_;
3162  ***      0                                         my ( $tbl_struct, $func ) = @args{ qw(tbl_struct function) };
3163  ***      0                                         my $q = $self->{Quoter};
3164                                                  
3165  ***      0             0                           my $sep = $args{sep} || '#';
3166  ***      0                                         $sep =~ s/'//g;
3167  ***      0             0                           $sep ||= '#';
3168                                                  
3169  ***      0                                         my %ignorecols = map { $_ => 1 } @{$args{ignorecols}};
      ***      0                                      
      ***      0                                      
3170                                                  
3171  ***      0                                         my %cols = map { lc($_) => 1 }
      ***      0                                      
3172  ***      0                                                    grep { !exists $ignorecols{$_} }
3173  ***      0      0                                             ($args{cols} ? @{$args{cols}} : @{$tbl_struct->{cols}});
      ***      0                                      
3174  ***      0                                         my @cols =
3175                                                        map {
3176  ***      0                                               my $type = $tbl_struct->{type_for}->{$_};
3177  ***      0                                               my $result = $q->quote($_);
3178  ***      0      0      0                                 if ( $type eq 'timestamp' ) {
      ***             0      0                        
      ***             0                               
3179  ***      0                                                  $result .= ' + 0';
3180                                                           }
3181                                                           elsif ( $type =~ m/float|double/ && $args{float_precision} ) {
3182  ***      0                                                  $result = "ROUND($result, $args{float_precision})";
3183                                                           }
3184                                                           elsif ( $type =~ m/varchar/ && $args{trim} ) {
3185  ***      0                                                  $result = "TRIM($result)";
3186                                                           }
3187  ***      0                                               $result;
3188                                                        }
3189                                                        grep {
3190  ***      0                                               $cols{$_}
3191                                                        }
3192  ***      0                                            @{$tbl_struct->{cols}};
3193                                                  
3194  ***      0                                         my $query;
3195  ***      0      0      0                           if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
3196  ***      0                                            my @nulls = grep { $cols{$_} } @{$tbl_struct->{null_cols}};
      ***      0                                      
      ***      0                                      
3197  ***      0      0                                     if ( @nulls ) {
3198  ***      0                                               my $bitmap = "CONCAT("
3199  ***      0                                                  . join(', ', map { 'ISNULL(' . $q->quote($_) . ')' } @nulls)
3200                                                              . ")";
3201  ***      0                                               push @cols, $bitmap;
3202                                                        }
3203                                                  
3204  ***      0      0                                     $query = @cols > 1
3205                                                               ? "$func(CONCAT_WS('$sep', " . join(', ', @cols) . '))'
3206                                                               : "$func($cols[0])";
3207                                                     }
3208                                                     else {
3209  ***      0                                            my $fnv_func = uc $func;
3210  ***      0                                            $query = "$fnv_func(" . join(', ', @cols) . ')';
3211                                                     }
3212                                                  
3213  ***      0                                         return $query;
3214                                                  }
3215                                                  
3216                                                  sub make_checksum_query {
3217  ***      0                    0                    my ( $self, %args ) = @_;
3218  ***      0                                         my @required_args = qw(db tbl tbl_struct algorithm crc_wid crc_type);
3219  ***      0                                         foreach my $arg( @required_args ) {
3220  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
3221                                                     }
3222  ***      0                                         my ( $db, $tbl, $tbl_struct, $algorithm,
3223                                                          $crc_wid, $crc_type) = @args{@required_args};
3224  ***      0                                         my $func = $args{function};
3225  ***      0                                         my $q = $self->{Quoter};
3226  ***      0                                         my $result;
3227                                                  
3228  ***      0      0      0                           die "Invalid or missing checksum algorithm"
3229                                                        unless $algorithm && $ALGOS{$algorithm};
3230                                                  
3231  ***      0      0                                  if ( $algorithm eq 'CHECKSUM' ) {
3232  ***      0                                            return "CHECKSUM TABLE " . $q->quote($db, $tbl);
3233                                                     }
3234                                                  
3235  ***      0                                         my $expr = $self->make_row_checksum(%args);
3236                                                  
3237  ***      0      0                                  if ( $algorithm eq 'BIT_XOR' ) {
3238  ***      0      0                                     if ( $crc_type =~ m/int$/ ) {
3239  ***      0                                               $result = "LOWER(CONV(BIT_XOR(CAST($expr AS UNSIGNED)), 10, 16)) AS crc ";
3240                                                        }
3241                                                        else {
3242  ***      0                                               my $slices = $self->make_xor_slices( query => $expr, %args );
3243  ***      0                                               $result = "LOWER(CONCAT($slices)) AS crc ";
3244                                                        }
3245                                                     }
3246                                                     else {
3247  ***      0      0                                     if ( $crc_type =~ m/int$/ ) {
3248  ***      0                                               $result = "RIGHT(MAX("
3249                                                              . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
3250                                                              . "CONV(CAST($func(CONCAT(\@crc, $expr)) AS UNSIGNED), 10, 16))"
3251                                                              . "), $crc_wid) AS crc ";
3252                                                        }
3253                                                        else {
3254  ***      0                                               $result = "RIGHT(MAX("
3255                                                              . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
3256                                                              . "$func(CONCAT(\@crc, $expr)))"
3257                                                              . "), $crc_wid) AS crc ";
3258                                                        }
3259                                                     }
3260  ***      0      0                                  if ( $args{replicate} ) {
3261  ***      0                                            $result = "REPLACE /*PROGRESS_COMMENT*/ INTO $args{replicate} "
3262                                                           . "(db, tbl, chunk, boundaries, this_cnt, this_crc) "
3263                                                           . "SELECT ?, ?, /*CHUNK_NUM*/ ?, COUNT(*) AS cnt, $result";
3264                                                     }
3265                                                     else {
3266  ***      0      0                                     $result = "SELECT "
3267                                                           . ($args{buffer} ? 'SQL_BUFFER_RESULT ' : '')
3268                                                           . "/*PROGRESS_COMMENT*//*CHUNK_NUM*/ COUNT(*) AS cnt, $result";
3269                                                     }
3270  ***      0                                         return $result . "FROM /*DB_TBL*//*INDEX_HINT*//*WHERE*/";
3271                                                  }
3272                                                  
3273                                                  sub find_replication_differences {
3274  ***      0                    0                    my ( $self, $dbh, $table ) = @_;
3275                                                  
3276  ***      0                                         (my $sql = <<"   EOF") =~ s/\s+/ /gm;
3277                                                        SELECT db, tbl, chunk, boundaries,
3278                                                           COALESCE(this_cnt-master_cnt, 0) AS cnt_diff,
3279                                                           COALESCE(
3280                                                              this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc),
3281                                                              0
3282                                                           ) AS crc_diff,
3283                                                           this_cnt, master_cnt, this_crc, master_crc
3284                                                        FROM $table
3285                                                        WHERE master_cnt <> this_cnt OR master_crc <> this_crc
3286                                                        OR ISNULL(master_crc) <> ISNULL(this_crc)
3287                                                     EOF
3288                                                  
3289  ***      0                                         MKDEBUG && _d($sql);
3290  ***      0                                         my $diffs = $dbh->selectall_arrayref($sql, { Slice => {} });
3291  ***      0                                         return @$diffs;
3292                                                  }
3293                                                  
3294                                                  sub _d {
3295  ***      0                    0                    my ($package, undef, $line) = caller 0;
3296  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3297  ***      0                                              map { defined $_ ? $_ : 'undef' }
3298                                                          @_;
3299  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3300                                                  }
3301                                                  
3302                                                  1;
3303                                                  
3304                                                  # ###########################################################################
3305                                                  # End TableChecksum package
3306                                                  # ###########################################################################
3307                                                  
3308                                                  # ###########################################################################
3309                                                  # TableSyncChunk package 5266
3310                                                  # ###########################################################################
3311                                                  package TableSyncChunk;
3312                                                  
3313          27                   27           235   use strict;
              27                                 77   
              27                                183   
3314          27                   27           180   use warnings FATAL => 'all';
              27                                 70   
              27                                164   
3315                                                  
3316          27                   27           184   use English qw(-no_match_vars);
              27                                 88   
              27                                159   
3317          27                   27           198   use List::Util qw(max);
              27                                 71   
              27                                151   
3318          27                   27           168   use Data::Dumper;
              27                                 65   
              27                                149   
3319                                                  $Data::Dumper::Indent    = 1;
3320                                                  $Data::Dumper::Sortkeys  = 1;
3321                                                  $Data::Dumper::Quotekeys = 0;
3322                                                  
3323  ***     27            50     27           168   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 72   
              27                                425   
3324                                                  
3325                                                  sub new {
3326  ***      0                    0                    my ( $class, %args ) = @_;
3327  ***      0                                         foreach my $arg ( qw(TableChunker Quoter) ) {
3328  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
3329                                                     }
3330  ***      0                                         my $self = { %args };
3331  ***      0                                         return bless $self, $class;
3332                                                  }
3333                                                  
3334                                                  sub name {
3335  ***      0                    0                    return 'Chunk';
3336                                                  }
3337                                                  
3338                                                  sub can_sync {
3339  ***      0                    0                    my ( $self, %args ) = @_;
3340  ***      0                                         foreach my $arg ( qw(tbl_struct) ) {
3341  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
3342                                                     }
3343                                                  
3344  ***      0                                         my ($exact, @chunkable_cols) = $self->{TableChunker}->find_chunk_columns(
3345                                                        %args,
3346                                                        exact => 1,
3347                                                     );
3348  ***      0      0                                  return unless $exact;
3349                                                  
3350  ***      0                                         my $colno;
3351  ***      0      0      0                           if ( $args{chunk_col} || $args{chunk_index} ) {
3352  ***      0                                            MKDEBUG && _d('Checking requested col', $args{chunk_col},
3353                                                           'and/or index', $args{chunk_index});
3354  ***      0                                            for my $i ( 0..$#chunkable_cols ) {
3355  ***      0      0                                        if ( $args{chunk_col} ) {
3356  ***      0      0                                           next unless $chunkable_cols[$i]->{column} eq $args{chunk_col};
3357                                                           }
3358  ***      0      0                                        if ( $args{chunk_index} ) {
3359  ***      0      0                                           next unless $chunkable_cols[$i]->{index} eq $args{chunk_index};
3360                                                           }
3361  ***      0                                               $colno = $i;
3362  ***      0                                               last;
3363                                                        }
3364                                                  
3365  ***      0      0                                     if ( !$colno ) {
3366  ***      0                                               MKDEBUG && _d('Cannot chunk on column', $args{chunk_col},
3367                                                              'and/or using index', $args{chunk_index});
3368  ***      0                                               return;
3369                                                        }
3370                                                     }
3371                                                     else {
3372  ***      0                                            $colno = 0;  # First, best chunkable column/index.
3373                                                     }
3374                                                  
3375  ***      0                                         MKDEBUG && _d('Can chunk on column', $chunkable_cols[$colno]->{column},
3376                                                        'using index', $chunkable_cols[$colno]->{index});
3377                                                     return (
3378  ***      0                                            1,
3379                                                        chunk_col   => $chunkable_cols[$colno]->{column},
3380                                                        chunk_index => $chunkable_cols[$colno]->{index},
3381                                                     ),
3382                                                  }
3383                                                  
3384                                                  sub prepare_to_sync {
3385  ***      0                    0                    my ( $self, %args ) = @_;
3386  ***      0                                         my @required_args = qw(dbh db tbl tbl_struct cols chunk_col
3387                                                                            chunk_size crc_col ChangeHandler);
3388  ***      0                                         foreach my $arg ( @required_args ) {
3389  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
3390                                                     }
3391  ***      0                                         my $chunker  = $self->{TableChunker};
3392                                                  
3393  ***      0                                         $self->{chunk_col}       = $args{chunk_col};
3394  ***      0                                         $self->{crc_col}         = $args{crc_col};
3395  ***      0                                         $self->{index_hint}      = $args{index_hint};
3396  ***      0                                         $self->{buffer_in_mysql} = $args{buffer_in_mysql};
3397  ***      0                                         $self->{ChangeHandler}   = $args{ChangeHandler};
3398                                                  
3399  ***      0                                         $self->{ChangeHandler}->fetch_back($args{dbh});
3400                                                  
3401  ***      0                                         my @chunks;
3402  ***      0      0                                  if ( !$args{replicate} ) {
3403  ***      0                                            my %range_params = $chunker->get_range_statistics(%args);
3404  ***      0      0                                     if ( !grep { !defined $range_params{$_} } qw(min max rows_in_range) ) {
      ***      0                                      
3405  ***      0                                               $args{chunk_size} = $chunker->size_to_rows(%args);
3406  ***      0                                               @chunks = $chunker->calculate_chunks(%args, %range_params);
3407                                                        }
3408                                                        else {
3409  ***      0                                               MKDEBUG && _d('No range statistics; using single chunk 1=1');
3410  ***      0                                               @chunks = '1=1';
3411                                                        }
3412                                                     }
3413                                                     else {
3414  ***      0                                            MKDEBUG && _d('Using --replicate boundary instead of chunks');
3415  ***      0                                            @chunks = '1=1';
3416                                                     }
3417                                                  
3418  ***      0                                         $self->{chunks}    = \@chunks;
3419  ***      0                                         $self->{chunk_num} = 0;
3420  ***      0                                         $self->{state}     = 0;
3421                                                  
3422  ***      0                                         return;
3423                                                  }
3424                                                  
3425                                                  sub uses_checksum {
3426  ***      0                    0                    return 1;
3427                                                  }
3428                                                  
3429                                                  sub set_checksum_queries {
3430  ***      0                    0                    my ( $self, $chunk_sql, $row_sql ) = @_;
3431  ***      0      0                                  die "I need a chunk_sql argument" unless $chunk_sql;
3432  ***      0      0                                  die "I need a row_sql argument" unless $row_sql;
3433  ***      0                                         $self->{chunk_sql} = $chunk_sql;
3434  ***      0                                         $self->{row_sql} = $row_sql;
3435  ***      0                                         return;
3436                                                  }
3437                                                  
3438                                                  sub prepare_sync_cycle {
3439  ***      0                    0                    my ( $self, $host ) = @_;
3440  ***      0                                         my $sql = 'SET @crc := "", @cnt := 0';
3441  ***      0                                         MKDEBUG && _d($sql);
3442  ***      0                                         $host->{dbh}->do($sql);
3443  ***      0                                         return;
3444                                                  }
3445                                                  
3446                                                  sub get_sql {
3447  ***      0                    0                    my ( $self, %args ) = @_;
3448  ***      0      0                                  if ( $self->{state} ) {  # checksum a chunk of rows
3449  ***      0                                            my $q = $self->{Quoter};
3450  ***      0                                            return 'SELECT /*rows in chunk*/ '
3451                                                           . ($self->{buffer_in_mysql} ? 'SQL_BUFFER_RESULT ' : '')
3452  ***      0                                               . join(', ', map { $q->quote($_) } @{$self->key_cols()})
      ***      0                                      
3453                                                           . ', ' . $self->{row_sql} . " AS $self->{crc_col}"
3454                                                           . ' FROM ' . $self->{Quoter}->quote(@args{qw(database table)})
3455                                                           . ' '. ($self->{index_hint} || '')
3456                                                           . ' WHERE (' . $self->{chunks}->[$self->{chunk_num}] . ')'
3457                                                           . ($args{where} ? " AND ($args{where})" : '')
3458  ***      0      0      0                                 . ' ORDER BY ' . join(', ', map {$q->quote($_) } @{$self->key_cols()});
      ***      0      0                               
3459                                                     }
3460                                                     else {  # checksum the rows
3461  ***      0                                            return $self->{TableChunker}->inject_chunks(
3462                                                           database   => $args{database},
3463                                                           table      => $args{table},
3464                                                           chunks     => $self->{chunks},
3465                                                           chunk_num  => $self->{chunk_num},
3466                                                           query      => $self->{chunk_sql},
3467                                                           index_hint => $self->{index_hint},
3468                                                           where      => [ $args{where} ],
3469                                                        );
3470                                                     }
3471                                                  }
3472                                                  
3473                                                  sub same_row {
3474  ***      0                    0                    my ( $self, $lr, $rr ) = @_;
3475  ***      0      0      0                           if ( $self->{state} ) {  # checksumming rows
      ***             0                               
3476  ***      0      0                                     if ( $lr->{$self->{crc_col}} ne $rr->{$self->{crc_col}} ) {
3477  ***      0                                               $self->{ChangeHandler}->change('UPDATE', $lr, $self->key_cols());
3478                                                        }
3479                                                     }
3480                                                     elsif ( $lr->{cnt} != $rr->{cnt} || $lr->{crc} ne $rr->{crc} ) {
3481  ***      0                                            MKDEBUG && _d('Rows:', Dumper($lr, $rr));
3482  ***      0                                            MKDEBUG && _d('Will examine this chunk before moving to next');
3483  ***      0                                            $self->{state} = 1; # Must examine this chunk row-by-row
3484                                                     }
3485                                                  }
3486                                                  
3487                                                  sub not_in_right {
3488  ***      0                    0                    my ( $self, $lr ) = @_;
3489  ***      0      0                                  die "Called not_in_right in state 0" unless $self->{state};
3490  ***      0                                         $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
3491  ***      0                                         return;
3492                                                  }
3493                                                  
3494                                                  sub not_in_left {
3495  ***      0                    0                    my ( $self, $rr ) = @_;
3496  ***      0      0                                  die "Called not_in_left in state 0" unless $self->{state};
3497  ***      0                                         $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
3498  ***      0                                         return;
3499                                                  }
3500                                                  
3501                                                  sub done_with_rows {
3502  ***      0                    0                    my ( $self ) = @_;
3503  ***      0      0                                  if ( $self->{state} == 1 ) {
3504  ***      0                                            $self->{state} = 2;
3505  ***      0                                            MKDEBUG && _d('Setting state =', $self->{state});
3506                                                     }
3507                                                     else {
3508  ***      0                                            $self->{state} = 0;
3509  ***      0                                            $self->{chunk_num}++;
3510  ***      0                                            MKDEBUG && _d('Setting state =', $self->{state},
3511                                                           'chunk_num =', $self->{chunk_num});
3512                                                     }
3513  ***      0                                         return;
3514                                                  }
3515                                                  
3516                                                  sub done {
3517  ***      0                    0                    my ( $self ) = @_;
3518                                                     MKDEBUG && _d('Done with', $self->{chunk_num}, 'of',
3519  ***      0                                            scalar(@{$self->{chunks}}), 'chunks');
3520  ***      0                                         MKDEBUG && $self->{state} && _d('Chunk differs; must examine rows');
3521  ***      0                                         return $self->{state} == 0
3522  ***      0             0                              && $self->{chunk_num} >= scalar(@{$self->{chunks}})
3523                                                  }
3524                                                  
3525                                                  sub pending_changes {
3526  ***      0                    0                    my ( $self ) = @_;
3527  ***      0      0                                  if ( $self->{state} ) {
3528  ***      0                                            MKDEBUG && _d('There are pending changes');
3529  ***      0                                            return 1;
3530                                                     }
3531                                                     else {
3532  ***      0                                            MKDEBUG && _d('No pending changes');
3533  ***      0                                            return 0;
3534                                                     }
3535                                                  }
3536                                                  
3537                                                  sub key_cols {
3538  ***      0                    0                    my ( $self ) = @_;
3539  ***      0                                         my @cols;
3540  ***      0      0                                  if ( $self->{state} == 0 ) {
3541  ***      0                                            @cols = qw(chunk_num);
3542                                                     }
3543                                                     else {
3544  ***      0                                            @cols = $self->{chunk_col};
3545                                                     }
3546  ***      0                                         MKDEBUG && _d('State', $self->{state},',', 'key cols', join(', ', @cols));
3547  ***      0                                         return \@cols;
3548                                                  }
3549                                                  
3550                                                  sub _d {
3551  ***      0                    0                    my ($package, undef, $line) = caller 0;
3552  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3553  ***      0                                              map { defined $_ ? $_ : 'undef' }
3554                                                          @_;
3555  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3556                                                  }
3557                                                  
3558                                                  1;
3559                                                  
3560                                                  # ###########################################################################
3561                                                  # End TableSyncChunk package
3562                                                  # ###########################################################################
3563                                                  
3564                                                  # ###########################################################################
3565                                                  # TableSyncNibble package 5477
3566                                                  # ###########################################################################
3567                                                  package TableSyncNibble;
3568                                                  
3569          27                   27           237   use strict;
              27                                 79   
              27                                183   
3570          27                   27           164   use warnings FATAL => 'all';
              27                                 70   
              27                                174   
3571                                                  
3572          27                   27           175   use English qw(-no_match_vars);
              27                                 83   
              27                                194   
3573          27                   27           397   use List::Util qw(max);
              27                                 71   
              27                                166   
3574          27                   27           165   use Data::Dumper;
              27                                 71   
              27                                134   
3575                                                  $Data::Dumper::Indent    = 1;
3576                                                  $Data::Dumper::Sortkeys  = 1;
3577                                                  $Data::Dumper::Quotekeys = 0;
3578                                                  
3579  ***     27            50     27           174   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 65   
              27                                408   
3580                                                  
3581                                                  sub new {
3582  ***      0                    0                    my ( $class, %args ) = @_;
3583  ***      0                                         foreach my $arg ( qw(TableNibbler TableChunker TableParser Quoter) ) {
3584  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
3585                                                     }
3586  ***      0                                         my $self = { %args };
3587  ***      0                                         return bless $self, $class;
3588                                                  }
3589                                                  
3590                                                  sub name {
3591  ***      0                    0                    return 'Nibble';
3592                                                  }
3593                                                  
3594                                                  sub can_sync {
3595  ***      0                    0                    my ( $self, %args ) = @_;
3596  ***      0                                         foreach my $arg ( qw(tbl_struct) ) {
3597  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
3598                                                     }
3599                                                  
3600  ***      0                                         my $nibble_index = $self->{TableParser}->find_best_index($args{tbl_struct});
3601  ***      0      0                                  if ( $nibble_index ) {
3602  ***      0                                            MKDEBUG && _d('Best nibble index:', Dumper($nibble_index));
3603  ***      0      0                                     if ( !$args{tbl_struct}->{keys}->{$nibble_index}->{is_unique} ) {
3604  ***      0                                               MKDEBUG && _d('Best nibble index is not unique');
3605  ***      0                                               return;
3606                                                        }
3607  ***      0      0      0                              if ( $args{chunk_index} && $args{chunk_index} ne $nibble_index ) {
3608  ***      0                                               MKDEBUG && _d('Best nibble index is not requested index',
3609                                                              $args{chunk_index});
3610  ***      0                                               return;
3611                                                        }
3612                                                     }
3613                                                     else {
3614  ***      0                                            MKDEBUG && _d('No best nibble index returned');
3615  ***      0                                            return;
3616                                                     }
3617                                                  
3618  ***      0                                         my $small_table = 0;
3619  ***      0      0      0                           if ( $args{src} && $args{src}->{dbh} ) {
3620  ***      0                                            my $dbh = $args{src}->{dbh};
3621  ***      0                                            my $db  = $args{src}->{db};
3622  ***      0                                            my $tbl = $args{src}->{tbl};
3623  ***      0                                            my $table_status;
3624  ***      0                                            eval {
3625  ***      0                                               my $sql = "SHOW TABLE STATUS FROM `$db` LIKE "
3626                                                                   . $self->{Quoter}->literal_like($tbl);
3627  ***      0                                               MKDEBUG && _d($sql);
3628  ***      0                                               $table_status = $dbh->selectrow_hashref($sql);
3629                                                        };
3630  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3631  ***      0      0                                     if ( $table_status ) {
3632  ***      0      0                                        my $n_rows   = defined $table_status->{Rows} ? $table_status->{Rows}
      ***             0                               
3633                                                                        : defined $table_status->{rows} ? $table_status->{rows}
3634                                                                        : undef;
3635  ***      0      0      0                                 $small_table = 1 if defined $n_rows && $n_rows <= 100;
3636                                                        }
3637                                                     }
3638  ***      0                                         MKDEBUG && _d('Small table:', $small_table);
3639                                                  
3640  ***      0                                         MKDEBUG && _d('Can nibble using index', $nibble_index);
3641                                                     return (
3642  ***      0                                            1,
3643                                                        chunk_index => $nibble_index,
3644                                                        key_cols    => $args{tbl_struct}->{keys}->{$nibble_index}->{cols},
3645                                                        small_table => $small_table,
3646                                                     );
3647                                                  }
3648                                                  
3649                                                  sub prepare_to_sync {
3650  ***      0                    0                    my ( $self, %args ) = @_;
3651  ***      0                                         my @required_args = qw(dbh db tbl tbl_struct chunk_index key_cols chunk_size
3652                                                                            crc_col ChangeHandler);
3653  ***      0                                         foreach my $arg ( @required_args ) {
3654  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
3655                                                     }
3656                                                  
3657  ***      0                                         $self->{dbh}             = $args{dbh};
3658  ***      0                                         $self->{tbl_struct}      = $args{tbl_struct};
3659  ***      0                                         $self->{crc_col}         = $args{crc_col};
3660  ***      0                                         $self->{index_hint}      = $args{index_hint};
3661  ***      0                                         $self->{key_cols}        = $args{key_cols};
3662  ***      0                                         $self->{chunk_size}      = $self->{TableChunker}->size_to_rows(%args);
3663  ***      0                                         $self->{buffer_in_mysql} = $args{buffer_in_mysql};
3664  ***      0                                         $self->{small_table}     = $args{small_table};
3665  ***      0                                         $self->{ChangeHandler}   = $args{ChangeHandler};
3666                                                  
3667  ***      0                                         $self->{ChangeHandler}->fetch_back($args{dbh});
3668                                                  
3669  ***      0      0                                  if ( !$args{replicate} ) {
3670  ***      0                                            $self->{sel_stmt} = $self->{TableNibbler}->generate_asc_stmt(
3671                                                           %args,
3672                                                           index    => $args{chunk_index}, # expects an index arg, not chunk_index
3673                                                           asc_only => 1,
3674                                                        );
3675                                                     }
3676                                                     else {
3677  ***      0                                            MKDEBUG && _d('Using --replicate boundary instead of nibble boundaries');
3678  ***      0                                            $self->{sel_stmt} = undef;
3679                                                     }
3680                                                  
3681  ***      0                                         $self->{nibble}            = 0;
3682  ***      0                                         $self->{cached_row}        = undef;
3683  ***      0                                         $self->{cached_nibble}     = undef;
3684  ***      0                                         $self->{cached_boundaries} = undef;
3685  ***      0                                         $self->{state}             = 0;
3686                                                  
3687  ***      0                                         return;
3688                                                  }
3689                                                  
3690                                                  sub uses_checksum {
3691  ***      0                    0                    return 1;
3692                                                  }
3693                                                  
3694                                                  sub set_checksum_queries {
3695  ***      0                    0                    my ( $self, $nibble_sql, $row_sql ) = @_;
3696  ***      0      0                                  die "I need a nibble_sql argument" unless $nibble_sql;
3697  ***      0      0                                  die "I need a row_sql argument" unless $row_sql;
3698  ***      0                                         $self->{nibble_sql} = $nibble_sql;
3699  ***      0                                         $self->{row_sql} = $row_sql;
3700  ***      0                                         return;
3701                                                  }
3702                                                  
3703                                                  sub prepare_sync_cycle {
3704  ***      0                    0                    my ( $self, $host ) = @_;
3705  ***      0                                         my $sql = 'SET @crc := "", @cnt := 0';
3706  ***      0                                         MKDEBUG && _d($sql);
3707  ***      0                                         $host->{dbh}->do($sql);
3708  ***      0                                         return;
3709                                                  }
3710                                                  
3711                                                  sub get_sql {
3712  ***      0                    0                    my ( $self, %args ) = @_;
3713  ***      0      0                                  if ( $self->{state} ) {
3714  ***      0                                            my $q = $self->{Quoter};
3715  ***      0                                            return 'SELECT /*rows in nibble*/ '
3716                                                           . ($self->{buffer_in_mysql} ? 'SQL_BUFFER_RESULT ' : '')
3717  ***      0                                               . join(', ', map { $q->quote($_) } @{$self->key_cols()})
      ***      0                                      
3718                                                           . ', ' . $self->{row_sql} . " AS $self->{crc_col}"
3719                                                           . ' FROM ' . $q->quote(@args{qw(database table)})
3720                                                           . ' ' . ($self->{index_hint} ? $self->{index_hint} : '')
3721                                                           . ' WHERE (' . $self->__get_boundaries(%args) . ')'
3722                                                           . ($args{where} ? " AND ($args{where})" : '')
3723  ***      0      0                                        . ' ORDER BY ' . join(', ', map {$q->quote($_) } @{$self->key_cols()});
      ***      0      0                               
      ***             0                               
3724                                                     }
3725                                                     else {
3726  ***      0                                            my $where = $self->__get_boundaries(%args);
3727  ***      0                                            return $self->{TableChunker}->inject_chunks(
3728                                                           database   => $args{database},
3729                                                           table      => $args{table},
3730                                                           chunks     => [ $where ],
3731                                                           chunk_num  => 0,
3732                                                           query      => $self->{nibble_sql},
3733                                                           index_hint => $self->{index_hint},
3734                                                           where      => [ $args{where} ],
3735                                                        );
3736                                                     }
3737                                                  }
3738                                                  
3739                                                  sub __get_boundaries {
3740  ***      0                    0                    my ( $self, %args ) = @_;
3741  ***      0                                         my $q = $self->{Quoter};
3742  ***      0                                         my $s = $self->{sel_stmt};
3743                                                  
3744  ***      0      0                                  if ( !$s ) {
3745  ***      0                                            MKDEBUG && _d('No sel_stmt so WHERE clause 1=1 (for --replicate)');
3746  ***      0                                            return '1=1';
3747                                                     }
3748                                                  
3749  ***      0                                         my $lb;   # Lower boundary part of WHERE
3750  ***      0                                         my $ub;   # Upper boundary part of WHERE
3751  ***      0                                         my $row;  # Next upper boundary row or cached_row
3752                                                  
3753  ***      0      0                                  if ( $self->{cached_boundaries} ) {
3754  ***      0                                            MKDEBUG && _d('Using cached boundaries');
3755  ***      0                                            return $self->{cached_boundaries};
3756                                                     }
3757                                                  
3758  ***      0      0      0                           if ( $self->{cached_row} && $self->{cached_nibble} == $self->{nibble} ) {
3759  ***      0                                            MKDEBUG && _d('Using cached row for boundaries');
3760  ***      0                                            $row = $self->{cached_row};
3761                                                     }
3762                                                     else {
3763  ***      0                                            MKDEBUG && _d('Getting next upper boundary row');
3764  ***      0                                            my $sql;
3765  ***      0                                            ($sql, $lb) = $self->__make_boundary_sql(%args);  # $lb from outer scope!
3766                                                  
3767  ***      0      0      0                              if ( $self->{nibble} == 0 && !$self->{small_table} ) {
3768  ***      0                                               my $explain_index = $self->__get_explain_index($sql);
3769  ***      0      0      0                                 if ( lc($explain_index || '') ne lc($s->{index}) ) {
3770  ***      0      0                                           die 'Cannot nibble table '.$q->quote($args{database}, $args{table})
3771                                                                 . " because MySQL chose "
3772                                                                 . ($explain_index ? "the `$explain_index`" : 'no') . ' index'
3773                                                                 . " instead of the `$s->{index}` index";
3774                                                           }
3775                                                        }
3776                                                  
3777  ***      0                                            $row = $self->{dbh}->selectrow_hashref($sql);
3778  ***      0                                            MKDEBUG && _d($row ? 'Got a row' : "Didn't get a row");
3779                                                     }
3780                                                  
3781  ***      0      0                                  if ( $row ) {
3782  ***      0                                            my $i = 0;
3783  ***      0                                            $ub   = $s->{boundaries}->{'<='};
3784  ***      0             0                              $ub   =~ s/\?/$q->quote_val($row->{$s->{scols}->[$i]}, $self->{tbl_struct}->{is_numeric}->{$s->{scols}->[$i++]} || 0)/eg;
      ***      0                                      
3785                                                     }
3786                                                     else {
3787  ***      0                                            MKDEBUG && _d('No upper boundary');
3788  ***      0                                            $ub = '1=1';
3789                                                     }
3790                                                  
3791  ***      0      0                                  my $where = $lb ? "($lb AND $ub)" : $ub;
3792                                                  
3793  ***      0                                         $self->{cached_row}        = $row;
3794  ***      0                                         $self->{cached_nibble}     = $self->{nibble};
3795  ***      0                                         $self->{cached_boundaries} = $where;
3796                                                  
3797  ***      0                                         MKDEBUG && _d('WHERE clause:', $where);
3798  ***      0                                         return $where;
3799                                                  }
3800                                                  
3801                                                  sub __make_boundary_sql {
3802  ***      0                    0                    my ( $self, %args ) = @_;
3803  ***      0                                         my $lb;
3804  ***      0                                         my $q   = $self->{Quoter};
3805  ***      0                                         my $s   = $self->{sel_stmt};
3806  ***      0                                         my $sql = "SELECT /*nibble boundary $self->{nibble}*/ "
3807  ***      0             0                              . join(',', map { $q->quote($_) } @{$s->{cols}})
      ***      0                                      
3808                                                        . " FROM " . $q->quote($args{database}, $args{table})
3809                                                        . ' ' . ($self->{index_hint} || '');
3810                                                  
3811  ***      0      0                                  if ( $self->{nibble} ) {
3812  ***      0                                            my $tmp = $self->{cached_row};
3813  ***      0                                            my $i   = 0;
3814  ***      0                                            $lb     = $s->{boundaries}->{'>'};
3815  ***      0             0                              $lb     =~ s/\?/$q->quote_val($tmp->{$s->{scols}->[$i]}, $self->{tbl_struct}->{is_numeric}->{$s->{scols}->[$i++]} || 0)/eg;
      ***      0                                      
3816  ***      0                                            $sql   .= ' WHERE ' . $lb;
3817                                                     }
3818  ***      0                                         $sql .= " ORDER BY " . join(',', map { $q->quote($_) } @{$self->{key_cols}})
      ***      0                                      
      ***      0                                      
3819                                                           . ' LIMIT ' . ($self->{chunk_size} - 1) . ', 1';
3820  ***      0                                         MKDEBUG && _d('Lower boundary:', $lb);
3821  ***      0                                         MKDEBUG && _d('Next boundary sql:', $sql);
3822  ***      0                                         return $sql, $lb;
3823                                                  }
3824                                                  
3825                                                  sub __get_explain_index {
3826  ***      0                    0                    my ( $self, $sql ) = @_;
3827  ***      0      0                                  return unless $sql;
3828  ***      0                                         my $explain;
3829  ***      0                                         eval {
3830  ***      0                                            $explain = $self->{dbh}->selectall_arrayref("EXPLAIN $sql",{Slice => {}});
3831                                                     };
3832  ***      0      0                                  if ( $EVAL_ERROR ) {
3833  ***      0                                            MKDEBUG && _d($EVAL_ERROR);
3834  ***      0                                            return;
3835                                                     }
3836  ***      0                                         MKDEBUG && _d('EXPLAIN key:', $explain->[0]->{key}); 
3837  ***      0                                         return $explain->[0]->{key};
3838                                                  }
3839                                                  
3840                                                  sub same_row {
3841  ***      0                    0                    my ( $self, $lr, $rr ) = @_;
3842  ***      0      0      0                           if ( $self->{state} ) {
      ***             0      0                        
      ***                    0                        
3843  ***      0      0                                     if ( $lr->{$self->{crc_col}} ne $rr->{$self->{crc_col}} ) {
3844  ***      0                                               $self->{ChangeHandler}->change('UPDATE', $lr, $self->key_cols());
3845                                                        }
3846                                                     }
3847                                                     elsif ( $lr->{cnt} != $rr->{cnt} || ($lr->{crc} || 0) ne ($rr->{crc} || 0) ) 
3848                                                     {
3849  ***      0                                            MKDEBUG && _d('Rows:', Dumper($lr, $rr));
3850  ***      0                                            MKDEBUG && _d('Will examine this nibble before moving to next');
3851  ***      0                                            $self->{state} = 1; # Must examine this nibble row-by-row
3852                                                     }
3853                                                  }
3854                                                  
3855                                                  sub not_in_right {
3856  ***      0                    0                    my ( $self, $lr ) = @_;
3857  ***      0      0                                  die "Called not_in_right in state 0" unless $self->{state};
3858  ***      0                                         $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
3859                                                  }
3860                                                  
3861                                                  sub not_in_left {
3862  ***      0                    0                    my ( $self, $rr ) = @_;
3863  ***      0      0                                  die "Called not_in_left in state 0" unless $self->{state};
3864  ***      0                                         $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
3865                                                  }
3866                                                  
3867                                                  sub done_with_rows {
3868  ***      0                    0                    my ( $self ) = @_;
3869  ***      0      0                                  if ( $self->{state} == 1 ) {
3870  ***      0                                            $self->{state} = 2;
3871  ***      0                                            MKDEBUG && _d('Setting state =', $self->{state});
3872                                                     }
3873                                                     else {
3874  ***      0                                            $self->{state} = 0;
3875  ***      0                                            $self->{nibble}++;
3876  ***      0                                            delete $self->{cached_boundaries};
3877  ***      0                                            MKDEBUG && _d('Setting state =', $self->{state},
3878                                                           ', nibble =', $self->{nibble});
3879                                                     }
3880                                                  }
3881                                                  
3882                                                  sub done {
3883  ***      0                    0                    my ( $self ) = @_;
3884  ***      0                                         MKDEBUG && _d('Done with nibble', $self->{nibble});
3885  ***      0                                         MKDEBUG && $self->{state} && _d('Nibble differs; must examine rows');
3886  ***      0             0                           return $self->{state} == 0 && $self->{nibble} && !$self->{cached_row};
      ***                    0                        
3887                                                  }
3888                                                  
3889                                                  sub pending_changes {
3890  ***      0                    0                    my ( $self ) = @_;
3891  ***      0      0                                  if ( $self->{state} ) {
3892  ***      0                                            MKDEBUG && _d('There are pending changes');
3893  ***      0                                            return 1;
3894                                                     }
3895                                                     else {
3896  ***      0                                            MKDEBUG && _d('No pending changes');
3897  ***      0                                            return 0;
3898                                                     }
3899                                                  }
3900                                                  
3901                                                  sub key_cols {
3902  ***      0                    0                    my ( $self ) = @_;
3903  ***      0                                         my @cols;
3904  ***      0      0                                  if ( $self->{state} == 0 ) {
3905  ***      0                                            @cols = qw(chunk_num);
3906                                                     }
3907                                                     else {
3908  ***      0                                            @cols = @{$self->{key_cols}};
      ***      0                                      
3909                                                     }
3910  ***      0                                         MKDEBUG && _d('State', $self->{state},',', 'key cols', join(', ', @cols));
3911  ***      0                                         return \@cols;
3912                                                  }
3913                                                  
3914                                                  sub _d {
3915  ***      0                    0                    my ($package, undef, $line) = caller 0;
3916  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3917  ***      0                                              map { defined $_ ? $_ : 'undef' }
3918                                                          @_;
3919  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3920                                                  }
3921                                                  
3922                                                  1;
3923                                                  
3924                                                  # ###########################################################################
3925                                                  # End TableSyncNibble package
3926                                                  # ###########################################################################
3927                                                  
3928                                                  # ###########################################################################
3929                                                  # TableSyncGroupBy package 5266
3930                                                  # ###########################################################################
3931                                                  package TableSyncGroupBy;
3932                                                  
3933          27                   27           248   use strict;
              27                                 89   
              27                                179   
3934          27                   27           165   use warnings FATAL => 'all';
              27                                 85   
              27                                188   
3935                                                  
3936          27                   27           161   use English qw(-no_match_vars);
              27                                 73   
              27                                161   
3937                                                  
3938  ***     27            50     27           214   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 80   
              27                                479   
3939                                                  
3940                                                  sub new {
3941  ***      0                    0                    my ( $class, %args ) = @_;
3942  ***      0                                         foreach my $arg ( qw(Quoter) ) {
3943  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
3944                                                     }
3945  ***      0                                         my $self = { %args };
3946  ***      0                                         return bless $self, $class;
3947                                                  }
3948                                                  
3949                                                  sub name {
3950  ***      0                    0                    return 'GroupBy';
3951                                                  }
3952                                                  
3953                                                  sub can_sync {
3954  ***      0                    0                    return 1;  # We can sync anything.
3955                                                  }
3956                                                  
3957                                                  sub prepare_to_sync {
3958  ***      0                    0                    my ( $self, %args ) = @_;
3959  ***      0                                         my @required_args = qw(tbl_struct cols ChangeHandler);
3960  ***      0                                         foreach my $arg ( @required_args ) {
3961  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
3962                                                     }
3963                                                  
3964  ***      0                                         $self->{cols}            = $args{cols};
3965  ***      0                                         $self->{buffer_in_mysql} = $args{buffer_in_mysql};
3966  ***      0                                         $self->{ChangeHandler}   = $args{ChangeHandler};
3967                                                  
3968  ***      0                                         $self->{count_col} = '__maatkit_count';
3969  ***      0                                         while ( $args{tbl_struct}->{is_col}->{$self->{count_col}} ) {
3970  ***      0                                            $self->{count_col} = "_$self->{count_col}";
3971                                                     }
3972  ***      0                                         MKDEBUG && _d('COUNT column will be named', $self->{count_col});
3973                                                  
3974  ***      0                                         $self->{done} = 0;
3975                                                  
3976  ***      0                                         return;
3977                                                  }
3978                                                  
3979                                                  sub uses_checksum {
3980  ***      0                    0                    return 0;  # We don't need checksum queries.
3981                                                  }
3982                                                  
3983                                                  sub set_checksum_queries {
3984  ***      0                    0                    return;  # This shouldn't be called, but just in case.
3985                                                  }
3986                                                  
3987                                                  sub prepare_sync_cycle {
3988  ***      0                    0                    my ( $self, $host ) = @_;
3989  ***      0                                         return;
3990                                                  }
3991                                                  
3992                                                  sub get_sql {
3993  ***      0                    0                    my ( $self, %args ) = @_;
3994  ***      0                                         my $cols = join(', ', map { $self->{Quoter}->quote($_) } @{$self->{cols}});
      ***      0                                      
      ***      0                                      
3995  ***      0      0      0                           return "SELECT"
3996                                                        . ($self->{buffer_in_mysql} ? ' SQL_BUFFER_RESULT' : '')
3997                                                        . " $cols, COUNT(*) AS $self->{count_col}"
3998                                                        . ' FROM ' . $self->{Quoter}->quote(@args{qw(database table)})
3999                                                        . ' WHERE ' . ( $args{where} || '1=1' )
4000                                                        . " GROUP BY $cols ORDER BY $cols";
4001                                                  }
4002                                                  
4003                                                  sub same_row {
4004  ***      0                    0                    my ( $self, $lr, $rr ) = @_;
4005  ***      0                                         my $cc = $self->{count_col};
4006  ***      0                                         my $lc = $lr->{$cc};
4007  ***      0                                         my $rc = $rr->{$cc};
4008  ***      0                                         my $diff = abs($lc - $rc);
4009  ***      0      0                                  return unless $diff;
4010  ***      0                                         $lr = { %$lr };
4011  ***      0                                         delete $lr->{$cc};
4012  ***      0                                         $rr = { %$rr };
4013  ***      0                                         delete $rr->{$cc};
4014  ***      0                                         foreach my $i ( 1 .. $diff ) {
4015  ***      0      0                                     if ( $lc > $rc ) {
4016  ***      0                                               $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
4017                                                        }
4018                                                        else {
4019  ***      0                                               $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
4020                                                        }
4021                                                     }
4022                                                  }
4023                                                  
4024                                                  sub not_in_right {
4025  ***      0                    0                    my ( $self, $lr ) = @_;
4026  ***      0                                         $lr = { %$lr };
4027  ***      0                                         my $cnt = delete $lr->{$self->{count_col}};
4028  ***      0                                         foreach my $i ( 1 .. $cnt ) {
4029  ***      0                                            $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
4030                                                     }
4031                                                  }
4032                                                  
4033                                                  sub not_in_left {
4034  ***      0                    0                    my ( $self, $rr ) = @_;
4035  ***      0                                         $rr = { %$rr };
4036  ***      0                                         my $cnt = delete $rr->{$self->{count_col}};
4037  ***      0                                         foreach my $i ( 1 .. $cnt ) {
4038  ***      0                                            $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
4039                                                     }
4040                                                  }
4041                                                  
4042                                                  sub done_with_rows {
4043  ***      0                    0                    my ( $self ) = @_;
4044  ***      0                                         $self->{done} = 1;
4045                                                  }
4046                                                  
4047                                                  sub done {
4048  ***      0                    0                    my ( $self ) = @_;
4049  ***      0                                         return $self->{done};
4050                                                  }
4051                                                  
4052                                                  sub key_cols {
4053  ***      0                    0                    my ( $self ) = @_;
4054  ***      0                                         return $self->{cols};
4055                                                  }
4056                                                  
4057                                                  sub pending_changes {
4058  ***      0                    0                    my ( $self ) = @_;
4059  ***      0                                         return;
4060                                                  }
4061                                                  
4062                                                  sub _d {
4063  ***      0                    0                    my ($package, undef, $line) = caller 0;
4064  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4065  ***      0                                              map { defined $_ ? $_ : 'undef' }
4066                                                          @_;
4067  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4068                                                  }
4069                                                  
4070                                                  1;
4071                                                  
4072                                                  # ###########################################################################
4073                                                  # End TableSyncGroupBy package
4074                                                  # ###########################################################################
4075                                                  
4076                                                  # ###########################################################################
4077                                                  # TableSyncer package 5266
4078                                                  # ###########################################################################
4079                                                  package TableSyncer;
4080                                                  
4081          27                   27           213   use strict;
              27                                 75   
              27                                199   
4082          27                   27           165   use warnings FATAL => 'all';
              27                                 67   
              27                                160   
4083                                                  
4084          27                   27           174   use English qw(-no_match_vars);
              27                                203   
              27                                154   
4085          27                   27           205   use Data::Dumper;
              27                                 77   
              27                                163   
4086                                                  $Data::Dumper::Indent    = 1;
4087                                                  $Data::Dumper::Sortkeys  = 1;
4088                                                  $Data::Dumper::Quotekeys = 0;
4089                                                  
4090  ***     27            50     27           213   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 91   
              27                                791   
4091                                                  
4092                                                  sub new {
4093  ***      0                    0                    my ( $class, %args ) = @_;
4094  ***      0                                         my @required_args = qw(MasterSlave Quoter VersionParser TableChecksum);
4095  ***      0                                         foreach my $arg ( @required_args ) {
4096  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
4097                                                     }
4098  ***      0                                         my $self = { %args };
4099  ***      0                                         return bless $self, $class;
4100                                                  }
4101                                                  
4102                                                  sub get_best_plugin {
4103  ***      0                    0                    my ( $self, %args ) = @_;
4104  ***      0                                         foreach my $arg ( qw(plugins tbl_struct) ) {
4105  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4106                                                     }
4107  ***      0                                         MKDEBUG && _d('Getting best plugin');
4108  ***      0                                         foreach my $plugin ( @{$args{plugins}} ) {
      ***      0                                      
4109  ***      0                                            MKDEBUG && _d('Trying plugin', $plugin->name());
4110  ***      0                                            my ($can_sync, %plugin_args) = $plugin->can_sync(%args);
4111  ***      0      0                                     if ( $can_sync ) {
4112  ***      0                                              MKDEBUG && _d('Can sync with', $plugin->name(), Dumper(\%plugin_args));
4113  ***      0                                              return $plugin, %plugin_args;
4114                                                        }
4115                                                     }
4116  ***      0                                         MKDEBUG && _d('No plugin can sync the table');
4117  ***      0                                         return;
4118                                                  }
4119                                                  
4120                                                  sub sync_table {
4121  ***      0                    0                    my ( $self, %args ) = @_;
4122  ***      0                                         my @required_args = qw(plugins src dst tbl_struct cols chunk_size
4123                                                                            RowDiff ChangeHandler);
4124  ***      0                                         foreach my $arg ( @required_args ) {
4125  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4126                                                     }
4127  ***      0                                         MKDEBUG && _d('Syncing table with args', Dumper(\%args));
4128  ***      0                                         my ($plugins, $src, $dst, $tbl_struct, $cols, $chunk_size, $rd, $ch)
4129                                                        = @args{@required_args};
4130                                                  
4131  ***      0      0                                  $args{index_hint}    = 1 unless defined $args{index_hint};
4132  ***      0             0                           $args{lock}        ||= 0;
4133  ***      0             0                           $args{wait}        ||= 0;
4134  ***      0             0                           $args{transaction} ||= 0;
4135  ***      0             0                           $args{timeout_ok}  ||= 0;
4136                                                  
4137  ***      0                                         my $q  = $self->{Quoter};
4138  ***      0                                         my $vp = $self->{VersionParser};
4139                                                  
4140  ***      0                                         my ($plugin, %plugin_args) = $self->get_best_plugin(%args);
4141  ***      0      0                                  die "No plugin can sync $src->{db}.$src->{tbl}" unless $plugin;
4142                                                  
4143  ***      0                                         my $crc_col = '__crc';
4144  ***      0                                         while ( $tbl_struct->{is_col}->{$crc_col} ) {
4145  ***      0                                            $crc_col = "_$crc_col"; # Prepend more _ until not a column.
4146                                                     }
4147  ***      0                                         MKDEBUG && _d('CRC column:', $crc_col);
4148                                                  
4149  ***      0                                         my $index_hint;
4150  ***      0      0                                  if ( !$args{replicate} ) {
4151  ***      0      0      0                              my $hint = ($vp->version_ge($src->{dbh}, '4.0.9')
4152                                                                    && $vp->version_ge($dst->{dbh}, '4.0.9') ? 'FORCE' : 'USE')
4153                                                                 . ' INDEX';
4154  ***      0      0      0                              if ( $args{chunk_index} ) {
      ***             0                               
4155  ***      0                                               MKDEBUG && _d('Using given chunk index for index hint');
4156  ***      0                                               $index_hint = "$hint (" . $q->quote($args{chunk_index}) . ")";
4157                                                        }
4158                                                        elsif ( $plugin_args{chunk_index} && $args{index_hint} ) {
4159  ***      0                                               MKDEBUG && _d('Using chunk index chosen by plugin for index hint');
4160  ***      0                                               $index_hint = "$hint (" . $q->quote($plugin_args{chunk_index}) . ")";
4161                                                        }
4162  ***      0                                            MKDEBUG && _d('Index hint:', $index_hint);
4163                                                     }
4164                                                     else {
4165  ***      0                                            MKDEBUG && _d('No index hint for --replicate');
4166                                                     }
4167                                                  
4168  ***      0                                         eval {
4169  ***      0                                            $plugin->prepare_to_sync(
4170                                                           %args,
4171                                                           %plugin_args,
4172                                                           dbh         => $src->{dbh},
4173                                                           db          => $src->{db},
4174                                                           tbl         => $src->{tbl},
4175                                                           crc_col     => $crc_col,
4176                                                           index_hint  => $index_hint,
4177                                                        );
4178                                                     };
4179  ***      0      0                                  if ( $EVAL_ERROR ) {
4180  ***      0                                            die 'Failed to prepare TableSync', $plugin->name(), ' plugin: ',
4181                                                           $EVAL_ERROR;
4182                                                     }
4183                                                  
4184  ***      0      0                                  if ( $plugin->uses_checksum() ) {
4185  ***      0                                            eval {
4186  ***      0                                               my ($chunk_sql, $row_sql) = $self->make_checksum_queries(%args);
4187  ***      0                                               $plugin->set_checksum_queries($chunk_sql, $row_sql);
4188                                                        };
4189  ***      0      0                                     if ( $EVAL_ERROR ) {
4190  ***      0                                               die "Failed to make checksum queries: $EVAL_ERROR";
4191                                                        }
4192                                                     } 
4193                                                  
4194  ***      0      0                                  if ( $args{dry_run} ) {
4195  ***      0                                            return $ch->get_changes(), ALGORITHM => $plugin->name();
4196                                                     }
4197                                                  
4198                                                  
4199  ***      0                                         eval {
4200  ***      0                                            $src->{dbh}->do("USE `$src->{db}`");
4201  ***      0                                            $dst->{dbh}->do("USE `$dst->{db}`");
4202                                                     };
4203  ***      0      0                                  if ( $EVAL_ERROR ) {
4204  ***      0                                            die "Failed to USE database on source or destination: $EVAL_ERROR";
4205                                                     }
4206                                                  
4207  ***      0                                         $self->lock_and_wait(%args, lock_level => 2);  # per-table lock
4208                                                     
4209  ***      0                                         my $callback = $args{callback};
4210  ***      0                                         my $cycle    = 0;
4211  ***      0                                         while ( !$plugin->done() ) {
4212                                                  
4213  ***      0                                            MKDEBUG && _d('Beginning sync cycle', $cycle);
4214  ***      0                                            my $src_sql = $plugin->get_sql(
4215                                                           database   => $src->{db},
4216                                                           table      => $src->{tbl},
4217                                                           where      => $args{where},
4218                                                        );
4219  ***      0                                            my $dst_sql = $plugin->get_sql(
4220                                                           database   => $dst->{db},
4221                                                           table      => $dst->{tbl},
4222                                                           where      => $args{where},
4223                                                        );
4224  ***      0      0                                     if ( $args{transaction} ) {
4225  ***      0      0                                        if ( $args{changing_src} ) {
4226  ***      0                                                  $src_sql .= ' FOR UPDATE';
4227  ***      0                                                  $dst_sql .= ' LOCK IN SHARE MODE';
4228                                                           }
4229                                                           else {
4230  ***      0                                                  $src_sql .= ' LOCK IN SHARE MODE';
4231  ***      0                                                  $dst_sql .= ' FOR UPDATE';
4232                                                           }
4233                                                        }
4234  ***      0                                            $plugin->prepare_sync_cycle($src);
4235  ***      0                                            $plugin->prepare_sync_cycle($dst);
4236  ***      0                                            MKDEBUG && _d('src:', $src_sql);
4237  ***      0                                            MKDEBUG && _d('dst:', $dst_sql);
4238  ***      0      0                                     $callback->($src_sql, $dst_sql) if $callback;
4239  ***      0                                            my $src_sth = $src->{dbh}->prepare($src_sql);
4240  ***      0                                            my $dst_sth = $dst->{dbh}->prepare($dst_sql);
4241  ***      0      0                                     if ( $args{buffer_to_client} ) {
4242  ***      0                                               $src_sth->{mysql_use_result} = 1;
4243  ***      0                                               $dst_sth->{mysql_use_result} = 1;
4244                                                        }
4245                                                  
4246  ***      0                                            my $executed_src = 0;
4247  ***      0      0      0                              if ( !$cycle || !$plugin->pending_changes() ) {
4248  ***      0                                               $executed_src
4249                                                              = $self->lock_and_wait(%args, src_sth => $src_sth, lock_level => 1);
4250                                                        }
4251                                                  
4252  ***      0      0                                     $src_sth->execute() unless $executed_src;
4253  ***      0                                            $dst_sth->execute();
4254                                                  
4255  ***      0                                            $rd->compare_sets(
4256                                                           left   => $src_sth,
4257                                                           right  => $dst_sth,
4258                                                           syncer => $plugin,
4259                                                           tbl    => $tbl_struct,
4260                                                        );
4261  ***      0                                            MKDEBUG && _d('Finished sync cycle', $cycle);
4262  ***      0                                            $ch->process_rows(1);
4263                                                  
4264  ***      0                                            $cycle++;
4265                                                     }
4266                                                  
4267  ***      0                                         $ch->process_rows();
4268                                                  
4269  ***      0                                         $self->unlock(%args, lock_level => 2);
4270                                                  
4271  ***      0                                         return $ch->get_changes(), ALGORITHM => $plugin->name();
4272                                                  }
4273                                                  
4274                                                  sub make_checksum_queries {
4275  ***      0                    0                    my ( $self, %args ) = @_;
4276  ***      0                                         my @required_args = qw(src dst tbl_struct);
4277  ***      0                                         foreach my $arg ( @required_args ) {
4278  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4279                                                     }
4280  ***      0                                         my ($src, $dst, $tbl_struct) = @args{@required_args};
4281  ***      0                                         my $checksum = $self->{TableChecksum};
4282                                                  
4283  ***      0                                         my $src_algo = $checksum->best_algorithm(
4284                                                        algorithm => 'BIT_XOR',
4285                                                        dbh       => $src->{dbh},
4286                                                        where     => 1,
4287                                                        chunk     => 1,
4288                                                        count     => 1,
4289                                                     );
4290  ***      0                                         my $dst_algo = $checksum->best_algorithm(
4291                                                        algorithm => 'BIT_XOR',
4292                                                        dbh       => $dst->{dbh},
4293                                                        where     => 1,
4294                                                        chunk     => 1,
4295                                                        count     => 1,
4296                                                     );
4297  ***      0      0                                  if ( $src_algo ne $dst_algo ) {
4298  ***      0                                            die "Source and destination checksum algorithms are different: ",
4299                                                           "$src_algo on source, $dst_algo on destination"
4300                                                     }
4301  ***      0                                         MKDEBUG && _d('Chosen algo:', $src_algo);
4302                                                  
4303  ***      0                                         my $src_func = $checksum->choose_hash_func(dbh => $src->{dbh}, %args);
4304  ***      0                                         my $dst_func = $checksum->choose_hash_func(dbh => $dst->{dbh}, %args);
4305  ***      0      0                                  if ( $src_func ne $dst_func ) {
4306  ***      0                                            die "Source and destination hash functions are different: ",
4307                                                        "$src_func on source, $dst_func on destination";
4308                                                     }
4309  ***      0                                         MKDEBUG && _d('Chosen hash func:', $src_func);
4310                                                  
4311                                                  
4312  ***      0                                         my $crc_wid    = $checksum->get_crc_wid($src->{dbh}, $src_func);
4313  ***      0                                         my ($crc_type) = $checksum->get_crc_type($src->{dbh}, $src_func);
4314  ***      0                                         my $opt_slice;
4315  ***      0      0      0                           if ( $src_algo eq 'BIT_XOR' && $crc_type !~ m/int$/ ) {
4316  ***      0                                            $opt_slice = $checksum->optimize_xor(
4317                                                           dbh      => $src->{dbh},
4318                                                           function => $src_func
4319                                                        );
4320                                                     }
4321                                                  
4322  ***      0                                         my $chunk_sql = $checksum->make_checksum_query(
4323                                                        %args,
4324                                                        db        => $src->{db},
4325                                                        tbl       => $src->{tbl},
4326                                                        algorithm => $src_algo,
4327                                                        function  => $src_func,
4328                                                        crc_wid   => $crc_wid,
4329                                                        crc_type  => $crc_type,
4330                                                        opt_slice => $opt_slice,
4331                                                        replicate => undef, # replicate means something different to this sub
4332                                                     );                     # than what we use it for; do not pass it!
4333  ***      0                                         MKDEBUG && _d('Chunk sql:', $chunk_sql);
4334  ***      0                                         my $row_sql = $checksum->make_row_checksum(
4335                                                        %args,
4336                                                        function => $src_func,
4337                                                     );
4338  ***      0                                         MKDEBUG && _d('Row sql:', $row_sql);
4339  ***      0                                         return $chunk_sql, $row_sql;
4340                                                  }
4341                                                  
4342                                                  sub lock_table {
4343  ***      0                    0                    my ( $self, $dbh, $where, $db_tbl, $mode ) = @_;
4344  ***      0                                         my $query = "LOCK TABLES $db_tbl $mode";
4345  ***      0                                         MKDEBUG && _d($query);
4346  ***      0                                         $dbh->do($query);
4347  ***      0                                         MKDEBUG && _d('Acquired table lock on', $where, 'in', $mode, 'mode');
4348                                                  }
4349                                                  
4350                                                  sub unlock {
4351  ***      0                    0                    my ( $self, %args ) = @_;
4352                                                  
4353  ***      0                                         foreach my $arg ( qw(src dst lock transaction lock_level) ) {
4354  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
4355                                                     }
4356  ***      0                                         my $src = $args{src};
4357  ***      0                                         my $dst = $args{dst};
4358                                                  
4359  ***      0      0      0                           return unless $args{lock} && $args{lock} <= $args{lock_level};
4360                                                  
4361  ***      0                                         foreach my $dbh ( $src->{dbh}, $dst->{dbh} ) {
4362  ***      0      0                                     if ( $args{transaction} ) {
4363  ***      0                                               MKDEBUG && _d('Committing', $dbh);
4364  ***      0                                               $dbh->commit();
4365                                                        }
4366                                                        else {
4367  ***      0                                               my $sql = 'UNLOCK TABLES';
4368  ***      0                                               MKDEBUG && _d($dbh, $sql);
4369  ***      0                                               $dbh->do($sql);
4370                                                        }
4371                                                     }
4372                                                  
4373  ***      0                                         return;
4374                                                  }
4375                                                  
4376                                                  sub lock_and_wait {
4377  ***      0                    0                    my ( $self, %args ) = @_;
4378  ***      0                                         my $result = 0;
4379                                                  
4380  ***      0                                         foreach my $arg ( qw(src dst lock lock_level) ) {
4381  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
4382                                                     }
4383  ***      0                                         my $src = $args{src};
4384  ***      0                                         my $dst = $args{dst};
4385                                                  
4386  ***      0      0      0                           return unless $args{lock} && $args{lock} == $args{lock_level};
4387                                                  
4388  ***      0                                         foreach my $dbh ( $src->{dbh}, $dst->{dbh} ) {
4389  ***      0      0                                     if ( $args{transaction} ) {
4390  ***      0                                               MKDEBUG && _d('Committing', $dbh);
4391  ***      0                                               $dbh->commit();
4392                                                        }
4393                                                        else {
4394  ***      0                                               my $sql = 'UNLOCK TABLES';
4395  ***      0                                               MKDEBUG && _d($dbh, $sql);
4396  ***      0                                               $dbh->do($sql);
4397                                                        }
4398                                                     }
4399                                                  
4400  ***      0      0                                  if ( $args{lock} == 3 ) {
4401  ***      0                                            my $sql = 'FLUSH TABLES WITH READ LOCK';
4402  ***      0                                            MKDEBUG && _d($src->{dbh}, ',', $sql);
4403  ***      0                                            $src->{dbh}->do($sql);
4404                                                     }
4405                                                     else {
4406  ***      0      0                                     if ( $args{transaction} ) {
4407  ***      0      0                                        if ( $args{src_sth} ) {
4408  ***      0                                                  MKDEBUG && _d('Executing statement on source to lock rows');
4409  ***      0                                                  $args{src_sth}->execute();
4410  ***      0                                                  $result = 1;
4411                                                           }
4412                                                        }
4413                                                        else {
4414  ***      0      0                                        $self->lock_table($src->{dbh}, 'source',
4415                                                              $self->{Quoter}->quote($src->{db}, $src->{tbl}),
4416                                                              $args{changing_src} ? 'WRITE' : 'READ');
4417                                                        }
4418                                                     }
4419                                                  
4420  ***      0                                         eval {
4421  ***      0      0                                     if ( $args{wait} ) {
4422  ***      0                                               $self->{MasterSlave}->wait_for_master(
4423                                                              $src->{misc_dbh}, $dst->{dbh}, $args{wait}, $args{timeout_ok});
4424                                                        }
4425                                                  
4426  ***      0      0                                     if ( $args{changing_src} ) {
4427  ***      0                                               MKDEBUG && _d('Not locking destination because changing source ',
4428                                                              '(syncing via replication or sync-to-master)');
4429                                                        }
4430                                                        else {
4431  ***      0      0                                        if ( $args{lock} == 3 ) {
      ***             0                               
4432  ***      0                                                  my $sql = 'FLUSH TABLES WITH READ LOCK';
4433  ***      0                                                  MKDEBUG && _d($dst->{dbh}, ',', $sql);
4434  ***      0                                                  $dst->{dbh}->do($sql);
4435                                                           }
4436                                                           elsif ( !$args{transaction} ) {
4437  ***      0      0                                           $self->lock_table($dst->{dbh}, 'dest',
4438                                                                 $self->{Quoter}->quote($dst->{db}, $dst->{tbl}),
4439                                                                 $args{execute} ? 'WRITE' : 'READ');
4440                                                           }
4441                                                        }
4442                                                     };
4443                                                  
4444  ***      0      0                                  if ( $EVAL_ERROR ) {
4445  ***      0      0                                     if ( $args{src_sth}->{Active} ) {
4446  ***      0                                               $args{src_sth}->finish();
4447                                                        }
4448  ***      0                                            foreach my $dbh ( $src->{dbh}, $dst->{dbh}, $src->{misc_dbh} ) {
4449  ***      0      0                                        next unless $dbh;
4450  ***      0                                               MKDEBUG && _d('Caught error, unlocking/committing on', $dbh);
4451  ***      0                                               $dbh->do('UNLOCK TABLES');
4452  ***      0      0                                        $dbh->commit() unless $dbh->{AutoCommit};
4453                                                        }
4454  ***      0                                            die $EVAL_ERROR;
4455                                                     }
4456                                                  
4457  ***      0                                         return $result;
4458                                                  }
4459                                                  
4460                                                  sub have_all_privs {
4461  ***      0                    0                    my ( $self, $dbh, $db, $tbl ) = @_;
4462  ***      0                                         my $db_tbl = $self->{Quoter}->quote($db, $tbl);
4463  ***      0                                         my $sql    = "SHOW FULL COLUMNS FROM $db_tbl";
4464  ***      0                                         MKDEBUG && _d('Permissions check:', $sql);
4465  ***      0                                         my $cols       = $dbh->selectall_arrayref($sql, {Slice => {}});
4466  ***      0                                         my ($hdr_name) = grep { m/privileges/i } keys %{$cols->[0]};
      ***      0                                      
      ***      0                                      
4467  ***      0                                         my $privs      = $cols->[0]->{$hdr_name};
4468  ***      0                                         $sql = "DELETE FROM $db_tbl LIMIT 0"; # FULL COLUMNS doesn't show all privs
4469  ***      0                                         MKDEBUG && _d('Permissions check:', $sql);
4470  ***      0                                         eval { $dbh->do($sql); };
      ***      0                                      
4471  ***      0      0                                  my $can_delete = $EVAL_ERROR ? 0 : 1;
4472                                                  
4473  ***      0                                         MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
4474                                                        ($can_delete ? 'delete' : ''));
4475  ***      0      0      0                           if ( $privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/ 
      ***                    0                        
      ***                    0                        
4476                                                          && $can_delete ) {
4477  ***      0                                            MKDEBUG && _d('User has all privs');
4478  ***      0                                            return 1;
4479                                                     }
4480  ***      0                                         MKDEBUG && _d('User does not have all privs');
4481  ***      0                                         return 0;
4482                                                  }
4483                                                  
4484                                                  sub _d {
4485  ***      0                    0                    my ($package, undef, $line) = caller 0;
4486  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4487  ***      0                                              map { defined $_ ? $_ : 'undef' }
4488                                                          @_;
4489  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4490                                                  }
4491                                                  
4492                                                  1;
4493                                                  
4494                                                  # ###########################################################################
4495                                                  # End TableSyncer package
4496                                                  # ###########################################################################
4497                                                  
4498                                                  # ###########################################################################
4499                                                  # TableNibbler package 5266
4500                                                  # ###########################################################################
4501                                                  package TableNibbler;
4502                                                  
4503          27                   27           236   use strict;
              27                                 76   
              27                                359   
4504          27                   27           172   use warnings FATAL => 'all';
              27                                 74   
              27                                250   
4505                                                  
4506          27                   27           166   use English qw(-no_match_vars);
              27                                 64   
              27                                158   
4507                                                  
4508  ***     27            50     27           181   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 76   
              27                                557   
4509                                                  
4510                                                  sub new {
4511  ***      0                    0                    my ( $class, %args ) = @_;
4512  ***      0                                         my @required_args = qw(TableParser Quoter);
4513  ***      0                                         foreach my $arg ( @required_args ) {
4514  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4515                                                     }
4516  ***      0                                         my $self = { %args };
4517  ***      0                                         return bless $self, $class;
4518                                                  }
4519                                                  
4520                                                  sub generate_asc_stmt {
4521  ***      0                    0                    my ( $self, %args ) = @_;
4522  ***      0                                         my @required_args = qw(tbl_struct index);
4523  ***      0                                         foreach my $arg ( @required_args ) {
4524  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
4525                                                     }
4526  ***      0                                         my ($tbl_struct, $index) = @args{@required_args};
4527  ***      0      0                                  my @cols = $args{cols}  ? @{$args{cols}} : @{$tbl_struct->{cols}};
      ***      0                                      
      ***      0                                      
4528  ***      0                                         my $q    = $self->{Quoter};
4529                                                  
4530  ***      0      0                                  die "Index '$index' does not exist in table"
4531                                                        unless exists $tbl_struct->{keys}->{$index};
4532                                                  
4533  ***      0                                         my @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
      ***      0                                      
4534  ***      0                                         my @asc_slice;
4535                                                  
4536  ***      0                                         @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
      ***      0                                      
4537  ***      0                                         MKDEBUG && _d('Will ascend index', $index);
4538  ***      0                                         MKDEBUG && _d('Will ascend columns', join(', ', @asc_cols));
4539  ***      0      0                                  if ( $args{asc_first} ) {
4540  ***      0                                            @asc_cols = $asc_cols[0];
4541  ***      0                                            MKDEBUG && _d('Ascending only first column');
4542                                                     }
4543                                                  
4544  ***      0                                         my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
      ***      0                                      
      ***      0                                      
      ***      0                                      
4545  ***      0                                         foreach my $col ( @asc_cols ) {
4546  ***      0      0                                     if ( !exists $col_posn{$col} ) {
4547  ***      0                                               push @cols, $col;
4548  ***      0                                               $col_posn{$col} = $#cols;
4549                                                        }
4550  ***      0                                            push @asc_slice, $col_posn{$col};
4551                                                     }
4552  ***      0                                         MKDEBUG && _d('Will ascend, in ordinal position:', join(', ', @asc_slice));
4553                                                  
4554  ***      0                                         my $asc_stmt = {
4555                                                        cols  => \@cols,
4556                                                        index => $index,
4557                                                        where => '',
4558                                                        slice => [],
4559                                                        scols => [],
4560                                                     };
4561                                                  
4562  ***      0      0                                  if ( @asc_slice ) {
4563  ***      0                                            my $cmp_where;
4564  ***      0                                            foreach my $cmp ( qw(< <= >= >) ) {
4565  ***      0                                               $cmp_where = $self->generate_cmp_where(
4566                                                              type        => $cmp,
4567                                                              slice       => \@asc_slice,
4568                                                              cols        => \@cols,
4569                                                              quoter      => $q,
4570                                                              is_nullable => $tbl_struct->{is_nullable},
4571                                                           );
4572  ***      0                                               $asc_stmt->{boundaries}->{$cmp} = $cmp_where->{where};
4573                                                        }
4574  ***      0      0                                     my $cmp = $args{asc_only} ? '>' : '>=';
4575  ***      0                                            $asc_stmt->{where} = $asc_stmt->{boundaries}->{$cmp};
4576  ***      0                                            $asc_stmt->{slice} = $cmp_where->{slice};
4577  ***      0                                            $asc_stmt->{scols} = $cmp_where->{scols};
4578                                                     }
4579                                                  
4580  ***      0                                         return $asc_stmt;
4581                                                  }
4582                                                  
4583                                                  sub generate_cmp_where {
4584  ***      0                    0                    my ( $self, %args ) = @_;
4585  ***      0                                         foreach my $arg ( qw(type slice cols is_nullable) ) {
4586  ***      0      0                                     die "I need a $arg arg" unless defined $args{$arg};
4587                                                     }
4588  ***      0                                         my @slice       = @{$args{slice}};
      ***      0                                      
4589  ***      0                                         my @cols        = @{$args{cols}};
      ***      0                                      
4590  ***      0                                         my $is_nullable = $args{is_nullable};
4591  ***      0                                         my $type        = $args{type};
4592  ***      0                                         my $q           = $self->{Quoter};
4593                                                  
4594  ***      0                                         (my $cmp = $type) =~ s/=//;
4595                                                  
4596  ***      0                                         my @r_slice;    # Resulting slice columns, by ordinal
4597  ***      0                                         my @r_scols;    # Ditto, by name
4598                                                  
4599  ***      0                                         my @clauses;
4600  ***      0                                         foreach my $i ( 0 .. $#slice ) {
4601  ***      0                                            my @clause;
4602                                                  
4603  ***      0                                            foreach my $j ( 0 .. $i - 1 ) {
4604  ***      0                                               my $ord = $slice[$j];
4605  ***      0                                               my $col = $cols[$ord];
4606  ***      0                                               my $quo = $q->quote($col);
4607  ***      0      0                                        if ( $is_nullable->{$col} ) {
4608  ***      0                                                  push @clause, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
4609  ***      0                                                  push @r_slice, $ord, $ord;
4610  ***      0                                                  push @r_scols, $col, $col;
4611                                                           }
4612                                                           else {
4613  ***      0                                                  push @clause, "$quo = ?";
4614  ***      0                                                  push @r_slice, $ord;
4615  ***      0                                                  push @r_scols, $col;
4616                                                           }
4617                                                        }
4618                                                  
4619  ***      0                                            my $ord = $slice[$i];
4620  ***      0                                            my $col = $cols[$ord];
4621  ***      0                                            my $quo = $q->quote($col);
4622  ***      0                                            my $end = $i == $#slice; # Last clause of the whole group.
4623  ***      0      0                                     if ( $is_nullable->{$col} ) {
4624  ***      0      0      0                                 if ( $type =~ m/=/ && $end ) {
      ***             0                               
4625  ***      0                                                  push @clause, "(? IS NULL OR $quo $type ?)";
4626                                                           }
4627                                                           elsif ( $type =~ m/>/ ) {
4628  ***      0                                                  push @clause, "((? IS NULL AND $quo IS NOT NULL) OR ($quo $cmp ?))";
4629                                                           }
4630                                                           else { # If $type =~ m/</ ) {
4631  ***      0                                                  push @clause, "((? IS NOT NULL AND $quo IS NULL) OR ($quo $cmp ?))";
4632                                                           }
4633  ***      0                                               push @r_slice, $ord, $ord;
4634  ***      0                                               push @r_scols, $col, $col;
4635                                                        }
4636                                                        else {
4637  ***      0                                               push @r_slice, $ord;
4638  ***      0                                               push @r_scols, $col;
4639  ***      0      0      0                                 push @clause, ($type =~ m/=/ && $end ? "$quo $type ?" : "$quo $cmp ?");
4640                                                        }
4641                                                  
4642  ***      0                                            push @clauses, '(' . join(' AND ', @clause) . ')';
4643                                                     }
4644  ***      0                                         my $result = '(' . join(' OR ', @clauses) . ')';
4645  ***      0                                         my $where = {
4646                                                        slice => \@r_slice,
4647                                                        scols => \@r_scols,
4648                                                        where => $result,
4649                                                     };
4650  ***      0                                         return $where;
4651                                                  }
4652                                                  
4653                                                  sub generate_del_stmt {
4654  ***      0                    0                    my ( $self, %args ) = @_;
4655                                                  
4656  ***      0                                         my $tbl  = $args{tbl_struct};
4657  ***      0      0                                  my @cols = $args{cols} ? @{$args{cols}} : ();
      ***      0                                      
4658  ***      0                                         my $tp   = $self->{TableParser};
4659  ***      0                                         my $q    = $self->{Quoter};
4660                                                  
4661  ***      0                                         my @del_cols;
4662  ***      0                                         my @del_slice;
4663                                                  
4664  ***      0                                         my $index = $tp->find_best_index($tbl, $args{index});
4665  ***      0      0                                  die "Cannot find an ascendable index in table" unless $index;
4666                                                  
4667  ***      0      0                                  if ( $index ) {
4668  ***      0                                            @del_cols = @{$tbl->{keys}->{$index}->{cols}};
      ***      0                                      
4669                                                     }
4670                                                     else {
4671  ***      0                                            @del_cols = @{$tbl->{cols}};
      ***      0                                      
4672                                                     }
4673  ***      0                                         MKDEBUG && _d('Columns needed for DELETE:', join(', ', @del_cols));
4674                                                  
4675  ***      0                                         my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
      ***      0                                      
      ***      0                                      
      ***      0                                      
4676  ***      0                                         foreach my $col ( @del_cols ) {
4677  ***      0      0                                     if ( !exists $col_posn{$col} ) {
4678  ***      0                                               push @cols, $col;
4679  ***      0                                               $col_posn{$col} = $#cols;
4680                                                        }
4681  ***      0                                            push @del_slice, $col_posn{$col};
4682                                                     }
4683  ***      0                                         MKDEBUG && _d('Ordinals needed for DELETE:', join(', ', @del_slice));
4684                                                  
4685  ***      0                                         my $del_stmt = {
4686                                                        cols  => \@cols,
4687                                                        index => $index,
4688                                                        where => '',
4689                                                        slice => [],
4690                                                        scols => [],
4691                                                     };
4692                                                  
4693  ***      0                                         my @clauses;
4694  ***      0                                         foreach my $i ( 0 .. $#del_slice ) {
4695  ***      0                                            my $ord = $del_slice[$i];
4696  ***      0                                            my $col = $cols[$ord];
4697  ***      0                                            my $quo = $q->quote($col);
4698  ***      0      0                                     if ( $tbl->{is_nullable}->{$col} ) {
4699  ***      0                                               push @clauses, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
4700  ***      0                                               push @{$del_stmt->{slice}}, $ord, $ord;
      ***      0                                      
4701  ***      0                                               push @{$del_stmt->{scols}}, $col, $col;
      ***      0                                      
4702                                                        }
4703                                                        else {
4704  ***      0                                               push @clauses, "$quo = ?";
4705  ***      0                                               push @{$del_stmt->{slice}}, $ord;
      ***      0                                      
4706  ***      0                                               push @{$del_stmt->{scols}}, $col;
      ***      0                                      
4707                                                        }
4708                                                     }
4709                                                  
4710  ***      0                                         $del_stmt->{where} = '(' . join(' AND ', @clauses) . ')';
4711                                                  
4712  ***      0                                         return $del_stmt;
4713                                                  }
4714                                                  
4715                                                  sub generate_ins_stmt {
4716  ***      0                    0                    my ( $self, %args ) = @_;
4717  ***      0                                         foreach my $arg ( qw(ins_tbl sel_cols) ) {
4718  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4719                                                     }
4720  ***      0                                         my $ins_tbl  = $args{ins_tbl};
4721  ***      0                                         my @sel_cols = @{$args{sel_cols}};
      ***      0                                      
4722                                                  
4723  ***      0      0                                  die "You didn't specify any SELECT columns" unless @sel_cols;
4724                                                  
4725  ***      0                                         my @ins_cols;
4726  ***      0                                         my @ins_slice;
4727  ***      0                                         for my $i ( 0..$#sel_cols ) {
4728  ***      0      0                                     next unless $ins_tbl->{is_col}->{$sel_cols[$i]};
4729  ***      0                                            push @ins_cols, $sel_cols[$i];
4730  ***      0                                            push @ins_slice, $i;
4731                                                     }
4732                                                  
4733                                                     return {
4734  ***      0                                            cols  => \@ins_cols,
4735                                                        slice => \@ins_slice,
4736                                                     };
4737                                                  }
4738                                                  
4739                                                  sub _d {
4740  ***      0                    0                    my ($package, undef, $line) = caller 0;
4741  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4742  ***      0                                              map { defined $_ ? $_ : 'undef' }
4743                                                          @_;
4744  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4745                                                  }
4746                                                  
4747                                                  1;
4748                                                  
4749                                                  # ###########################################################################
4750                                                  # End TableNibbler package
4751                                                  # ###########################################################################
4752                                                  
4753                                                  # ###########################################################################
4754                                                  # MasterSlave package 5362
4755                                                  # ###########################################################################
4756          27                   27           312   use strict;
              27                                 72   
              27                                160   
4757          27                   27           164   use warnings FATAL => 'all';
              27                                 62   
              27                                154   
4758                                                  
4759                                                  package MasterSlave;
4760                                                  
4761          27                   27           183   use English qw(-no_match_vars);
              27                                 81   
              27                                146   
4762          27                   27           202   use List::Util qw(min max);
              27                                 64   
              27                                232   
4763          27                   27           171   use Data::Dumper;
              27                                 69   
              27                                158   
4764                                                  $Data::Dumper::Quotekeys = 0;
4765                                                  $Data::Dumper::Indent    = 0;
4766                                                  
4767  ***     27            50     27           171   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 79   
              27                                403   
4768                                                  
4769                                                  sub new {
4770  ***      0                    0                    bless {}, shift;
4771                                                  }
4772                                                  
4773                                                  sub recurse_to_slaves {
4774  ***      0                    0                    my ( $self, $args, $level ) = @_;
4775  ***      0             0                           $level ||= 0;
4776  ***      0                                         my $dp   = $args->{dsn_parser};
4777  ***      0                                         my $dsn  = $args->{dsn};
4778                                                  
4779  ***      0                                         my $dbh;
4780  ***      0                                         eval {
4781  ***      0             0                              $dbh = $args->{dbh} || $dp->get_dbh(
4782                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
4783  ***      0                                            MKDEBUG && _d('Connected to', $dp->as_string($dsn));
4784                                                     };
4785  ***      0      0                                  if ( $EVAL_ERROR ) {
4786  ***      0      0                                     print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
4787                                                           or die "Cannot print: $OS_ERROR";
4788  ***      0                                            return;
4789                                                     }
4790                                                  
4791  ***      0                                         my $sql  = 'SELECT @@SERVER_ID';
4792  ***      0                                         MKDEBUG && _d($sql);
4793  ***      0                                         my ($id) = $dbh->selectrow_array($sql);
4794  ***      0                                         MKDEBUG && _d('Working on server ID', $id);
4795  ***      0                                         my $master_thinks_i_am = $dsn->{server_id};
4796  ***      0      0      0                           if ( !defined $id
      ***                    0                        
      ***                    0                        
4797                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
4798                                                         || $args->{server_ids_seen}->{$id}++
4799                                                     ) {
4800  ***      0                                            MKDEBUG && _d('Server ID seen, or not what master said');
4801  ***      0      0                                     if ( $args->{skip_callback} ) {
4802  ***      0                                               $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
4803                                                        }
4804  ***      0                                            return;
4805                                                     }
4806                                                  
4807  ***      0                                         $args->{callback}->($dsn, $dbh, $level, $args->{parent});
4808                                                  
4809  ***      0      0      0                           if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
4810                                                  
4811  ***      0      0                                     my @slaves =
4812  ***      0                                               grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
4813                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
4814                                                  
4815  ***      0                                            foreach my $slave ( @slaves ) {
4816  ***      0                                               MKDEBUG && _d('Recursing from',
4817                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
4818  ***      0                                               $self->recurse_to_slaves(
4819                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
4820                                                        }
4821                                                     }
4822                                                  }
4823                                                  
4824                                                  sub find_slave_hosts {
4825  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
4826                                                  
4827  ***      0                                         my @methods = qw(processlist hosts);
4828  ***      0      0                                  if ( $method ) {
4829  ***      0                                            @methods = grep { $_ ne $method } @methods;
      ***      0                                      
4830  ***      0                                            unshift @methods, $method;
4831                                                     }
4832                                                     else {
4833  ***      0      0      0                              if ( ($dsn->{P} || 3306) != 3306 ) {
4834  ***      0                                               MKDEBUG && _d('Port number is non-standard; using only hosts method');
4835  ***      0                                               @methods = qw(hosts);
4836                                                        }
4837                                                     }
4838  ***      0                                         MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
4839                                                        'using methods', @methods);
4840                                                  
4841  ***      0                                         my @slaves;
4842                                                     METHOD:
4843  ***      0                                         foreach my $method ( @methods ) {
4844  ***      0                                            my $find_slaves = "_find_slaves_by_$method";
4845  ***      0                                            MKDEBUG && _d('Finding slaves with', $find_slaves);
4846  ***      0                                            @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
4847  ***      0      0                                     last METHOD if @slaves;
4848                                                     }
4849                                                  
4850  ***      0                                         MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
4851  ***      0                                         return @slaves;
4852                                                  }
4853                                                  
4854                                                  sub _find_slaves_by_processlist {
4855  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
4856                                                  
4857  ***      0                                         my @slaves = map  {
4858  ***      0                                            my $slave        = $dsn_parser->parse("h=$_", $dsn);
4859  ***      0                                            $slave->{source} = 'processlist';
4860  ***      0                                            $slave;
4861                                                     }
4862  ***      0                                         grep { $_ }
4863                                                     map  {
4864  ***      0                                            my ( $host ) = $_->{host} =~ m/^([^:]+):/;
4865  ***      0      0                                     if ( $host eq 'localhost' ) {
4866  ***      0                                               $host = '127.0.0.1'; # Replication never uses sockets.
4867                                                        }
4868  ***      0                                            $host;
4869                                                     } $self->get_connected_slaves($dbh);
4870                                                  
4871  ***      0                                         return @slaves;
4872                                                  }
4873                                                  
4874                                                  sub _find_slaves_by_hosts {
4875  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
4876                                                  
4877  ***      0                                         my @slaves;
4878  ***      0                                         my $sql = 'SHOW SLAVE HOSTS';
4879  ***      0                                         MKDEBUG && _d($dbh, $sql);
4880  ***      0                                         @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                      
4881                                                  
4882  ***      0      0                                  if ( @slaves ) {
4883  ***      0                                            MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
4884  ***      0                                            @slaves = map {
4885  ***      0                                               my %hash;
4886  ***      0                                               @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
4887  ***      0      0                                        my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
4888                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
4889                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
4890  ***      0                                               my $dsn           = $dsn_parser->parse($spec, $dsn);
4891  ***      0                                               $dsn->{server_id} = $hash{server_id};
4892  ***      0                                               $dsn->{master_id} = $hash{master_id};
4893  ***      0                                               $dsn->{source}    = 'hosts';
4894  ***      0                                               $dsn;
4895                                                        } @slaves;
4896                                                     }
4897                                                  
4898  ***      0                                         return @slaves;
4899                                                  }
4900                                                  
4901                                                  sub get_connected_slaves {
4902  ***      0                    0                    my ( $self, $dbh ) = @_;
4903                                                  
4904  ***      0                                         my $proc =
4905  ***      0                                            grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
4906  ***      0                                            @{$dbh->selectcol_arrayref('SHOW GRANTS')};
4907  ***      0      0                                  if ( !$proc ) {
4908  ***      0                                            die "You do not have the PROCESS privilege";
4909                                                     }
4910                                                  
4911  ***      0                                         my $sql = 'SHOW PROCESSLIST';
4912  ***      0                                         MKDEBUG && _d($dbh, $sql);
4913  ***      0                                         grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                      
4914                                                     map  { # Lowercase the column names
4915  ***      0                                            my %hash;
4916  ***      0                                            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
4917  ***      0                                            \%hash;
4918                                                     }
4919  ***      0                                         @{$dbh->selectall_arrayref($sql, { Slice => {} })};
4920                                                  }
4921                                                  
4922                                                  sub is_master_of {
4923  ***      0                    0                    my ( $self, $master, $slave ) = @_;
4924  ***      0      0                                  my $master_status = $self->get_master_status($master)
4925                                                        or die "The server specified as a master is not a master";
4926  ***      0      0                                  my $slave_status  = $self->get_slave_status($slave)
4927                                                        or die "The server specified as a slave is not a slave";
4928  ***      0      0                                  my @connected     = $self->get_connected_slaves($master)
4929                                                        or die "The server specified as a master has no connected slaves";
4930  ***      0                                         my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
4931                                                  
4932  ***      0      0                                  if ( $port != $slave_status->{master_port} ) {
4933  ***      0                                            die "The slave is connected to $slave_status->{master_port} "
4934                                                           . "but the master's port is $port";
4935                                                     }
4936                                                  
4937  ***      0      0                                  if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                      
4938  ***      0                                            die "I don't see any slave I/O thread connected with user "
4939                                                           . $slave_status->{master_user};
4940                                                     }
4941                                                  
4942  ***      0      0      0                           if ( ($slave_status->{slave_io_state} || '')
4943                                                        eq 'Waiting for master to send event' )
4944                                                     {
4945  ***      0                                            my ( $master_log_name, $master_log_num )
4946                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
4947  ***      0                                            my ( $slave_log_name, $slave_log_num )
4948                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
4949  ***      0      0      0                              if ( $master_log_name ne $slave_log_name
4950                                                           || abs($master_log_num - $slave_log_num) > 1 )
4951                                                        {
4952  ***      0                                               die "The slave thinks it is reading from "
4953                                                              . "$slave_status->{master_log_file},  but the "
4954                                                              . "master is writing to $master_status->{file}";
4955                                                        }
4956                                                     }
4957  ***      0                                         return 1;
4958                                                  }
4959                                                  
4960                                                  sub get_master_dsn {
4961  ***      0                    0                    my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
4962  ***      0      0                                  my $master = $self->get_slave_status($dbh) or return undef;
4963  ***      0                                         my $spec   = "h=$master->{master_host},P=$master->{master_port}";
4964  ***      0                                         return       $dsn_parser->parse($spec, $dsn);
4965                                                  }
4966                                                  
4967                                                  sub get_slave_status {
4968  ***      0                    0                    my ( $self, $dbh ) = @_;
4969  ***      0      0                                  if ( !$self->{not_a_slave}->{$dbh} ) {
4970  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
4971                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
4972  ***      0                                            MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
4973  ***      0                                            $sth->execute();
4974  ***      0                                            my ($ss) = @{$sth->fetchall_arrayref({})};
      ***      0                                      
4975                                                  
4976  ***      0      0      0                              if ( $ss && %$ss ) {
4977  ***      0                                               $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
      ***      0                                      
4978  ***      0                                               return $ss;
4979                                                        }
4980                                                  
4981  ***      0                                            MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
4982  ***      0                                            $self->{not_a_slave}->{$dbh}++;
4983                                                     }
4984                                                  }
4985                                                  
4986                                                  sub get_master_status {
4987  ***      0                    0                    my ( $self, $dbh ) = @_;
4988  ***      0      0                                  if ( !$self->{not_a_master}->{$dbh} ) {
4989  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
4990                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
4991  ***      0                                            MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
4992  ***      0                                            $sth->execute();
4993  ***      0                                            my ($ms) = @{$sth->fetchall_arrayref({})};
      ***      0                                      
4994                                                  
4995  ***      0      0      0                              if ( $ms && %$ms ) {
4996  ***      0                                               $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
      ***      0                                      
4997  ***      0      0      0                                 if ( $ms->{file} && $ms->{position} ) {
4998  ***      0                                                  return $ms;
4999                                                           }
5000                                                        }
5001                                                  
5002  ***      0                                            MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
5003  ***      0                                            $self->{not_a_master}->{$dbh}++;
5004                                                     }
5005                                                  }
5006                                                  
5007                                                  sub wait_for_master {
5008  ***      0                    0                    my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
5009  ***      0                                         my $result;
5010  ***      0      0                                  $time = 60 unless defined $time;
5011  ***      0                                         MKDEBUG && _d('Waiting for slave to catch up to master timeout ok:',
5012                                                        $timeoutok);
5013  ***      0             0                           $ms ||= $self->get_master_status($master);
5014  ***      0      0                                  if ( $ms ) {
5015  ***      0                                            my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
5016  ***      0                                            MKDEBUG && _d($slave, $query);
5017  ***      0                                            ($result) = $slave->selectrow_array($query);
5018  ***      0      0                                     my $stat = defined $result ? $result : 'NULL';
5019  ***      0                                            MKDEBUG && _d('Result of waiting:', $stat);
5020  ***      0      0      0                              if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                    0                        
5021  ***      0                                               die "MASTER_POS_WAIT returned $stat";
5022                                                        }
5023                                                     }
5024                                                     else {
5025  ***      0                                            MKDEBUG && _d('Not waiting: this server is not a master');
5026                                                     }
5027  ***      0                                         return $result;
5028                                                  }
5029                                                  
5030                                                  sub stop_slave {
5031  ***      0                    0                    my ( $self, $dbh ) = @_;
5032  ***      0             0                           my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
5033                                                           ||= $dbh->prepare('STOP SLAVE');
5034  ***      0                                         MKDEBUG && _d($dbh, $sth->{Statement});
5035  ***      0                                         $sth->execute();
5036                                                  }
5037                                                  
5038                                                  sub start_slave {
5039  ***      0                    0                    my ( $self, $dbh, $pos ) = @_;
5040  ***      0      0                                  if ( $pos ) {
5041  ***      0                                            my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
5042                                                                . "MASTER_LOG_POS=$pos->{position}";
5043  ***      0                                            MKDEBUG && _d($dbh, $sql);
5044  ***      0                                            $dbh->do($sql);
5045                                                     }
5046                                                     else {
5047  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
5048                                                              ||= $dbh->prepare('START SLAVE');
5049  ***      0                                            MKDEBUG && _d($dbh, $sth->{Statement});
5050  ***      0                                            $sth->execute();
5051                                                     }
5052                                                  }
5053                                                  
5054                                                  sub catchup_to_master {
5055  ***      0                    0                    my ( $self, $slave, $master, $time ) = @_;
5056  ***      0                                         $self->stop_slave($master);
5057  ***      0                                         $self->stop_slave($slave);
5058  ***      0                                         my $slave_status  = $self->get_slave_status($slave);
5059  ***      0                                         my $slave_pos     = $self->repl_posn($slave_status);
5060  ***      0                                         my $master_status = $self->get_master_status($master);
5061  ***      0                                         my $master_pos    = $self->repl_posn($master_status);
5062  ***      0                                         MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
5063                                                        'Slave position:', $self->pos_to_string($slave_pos));
5064  ***      0      0                                  if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
5065  ***      0                                            MKDEBUG && _d('Waiting for slave to catch up to master');
5066  ***      0                                            $self->start_slave($slave, $master_pos);
5067  ***      0                                            eval {
5068  ***      0                                               $self->wait_for_master($master, $slave, $time, 0, $master_status);
5069                                                        };
5070  ***      0      0                                     if ( $EVAL_ERROR ) {
5071  ***      0                                               MKDEBUG && _d($EVAL_ERROR);
5072  ***      0      0                                        if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
5073  ***      0                                                  $slave_status = $self->get_slave_status($slave);
5074  ***      0      0                                           if ( !$self->slave_is_running($slave_status) ) {
5075  ***      0                                                     MKDEBUG && _d('Master position:',
5076                                                                    $self->pos_to_string($master_pos),
5077                                                                    'Slave position:', $self->pos_to_string($slave_pos));
5078  ***      0                                                     $slave_pos = $self->repl_posn($slave_status);
5079  ***      0      0                                              if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
5080  ***      0                                                        die "$EVAL_ERROR but slave has not caught up to master";
5081                                                                 }
5082  ***      0                                                     MKDEBUG && _d('Slave is caught up to master and stopped');
5083                                                              }
5084                                                              else {
5085  ***      0                                                     die "$EVAL_ERROR but slave was still running";
5086                                                              }
5087                                                           }
5088                                                           else {
5089  ***      0                                                  die $EVAL_ERROR;
5090                                                           }
5091                                                        }
5092                                                     }
5093                                                  }
5094                                                  
5095                                                  sub catchup_to_same_pos {
5096  ***      0                    0                    my ( $self, $s1_dbh, $s2_dbh ) = @_;
5097  ***      0                                         $self->stop_slave($s1_dbh);
5098  ***      0                                         $self->stop_slave($s2_dbh);
5099  ***      0                                         my $s1_status = $self->get_slave_status($s1_dbh);
5100  ***      0                                         my $s2_status = $self->get_slave_status($s2_dbh);
5101  ***      0                                         my $s1_pos    = $self->repl_posn($s1_status);
5102  ***      0                                         my $s2_pos    = $self->repl_posn($s2_status);
5103  ***      0      0                                  if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
5104  ***      0                                            $self->start_slave($s1_dbh, $s2_pos);
5105                                                     }
5106                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
5107  ***      0                                            $self->start_slave($s2_dbh, $s1_pos);
5108                                                     }
5109                                                  
5110  ***      0                                         $s1_status = $self->get_slave_status($s1_dbh);
5111  ***      0                                         $s2_status = $self->get_slave_status($s2_dbh);
5112  ***      0                                         $s1_pos    = $self->repl_posn($s1_status);
5113  ***      0                                         $s2_pos    = $self->repl_posn($s2_status);
5114                                                  
5115  ***      0      0      0                           if ( $self->slave_is_running($s1_status)
      ***                    0                        
5116                                                       || $self->slave_is_running($s2_status)
5117                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
5118                                                     {
5119  ***      0                                            die "The servers aren't both stopped at the same position";
5120                                                     }
5121                                                  
5122                                                  }
5123                                                  
5124                                                  sub change_master_to {
5125  ***      0                    0                    my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
5126  ***      0                                         $self->stop_slave($dbh);
5127  ***      0                                         MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
5128  ***      0                                         my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
5129                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
5130                                                        . "MASTER_LOG_POS=$master_pos->{position}";
5131  ***      0                                         MKDEBUG && _d($dbh, $sql);
5132  ***      0                                         $dbh->do($sql);
5133                                                  }
5134                                                  
5135                                                  sub make_sibling_of_master {
5136  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
5137                                                  
5138  ***      0      0                                  my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5139                                                        or die "This server is not a slave";
5140  ***      0                                         my $master_dbh  = $dsn_parser->get_dbh(
5141                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
5142  ***      0      0                                  my $gmaster_dsn
5143                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5144                                                        or die "This server's master is not a slave";
5145  ***      0                                         my $gmaster_dbh = $dsn_parser->get_dbh(
5146                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
5147  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
5148  ***      0                                            die "The slave's master's master is the slave: master-master replication";
5149                                                     }
5150                                                  
5151  ***      0                                         $self->stop_slave($master_dbh);
5152  ***      0                                         $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
5153  ***      0                                         $self->stop_slave($slave_dbh);
5154                                                  
5155  ***      0                                         my $master_status = $self->get_master_status($master_dbh);
5156  ***      0                                         my $mslave_status = $self->get_slave_status($master_dbh);
5157  ***      0                                         my $slave_status  = $self->get_slave_status($slave_dbh);
5158  ***      0                                         my $master_pos    = $self->repl_posn($master_status);
5159  ***      0                                         my $slave_pos     = $self->repl_posn($slave_status);
5160                                                  
5161  ***      0      0      0                           if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
5162                                                       && !$self->slave_is_running($slave_status)
5163                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
5164                                                     {
5165  ***      0                                            $self->change_master_to($slave_dbh, $gmaster_dsn,
5166                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
5167                                                     }
5168                                                     else {
5169  ***      0                                            die "The servers aren't both stopped at the same position";
5170                                                     }
5171                                                  
5172  ***      0                                         $mslave_status = $self->get_slave_status($master_dbh);
5173  ***      0                                         $slave_status  = $self->get_slave_status($slave_dbh);
5174  ***      0                                         my $mslave_pos = $self->repl_posn($mslave_status);
5175  ***      0                                         $slave_pos     = $self->repl_posn($slave_status);
5176  ***      0      0      0                           if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
5177                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
5178                                                     {
5179  ***      0                                            die "The servers don't have the same master/position after the change";
5180                                                     }
5181                                                  }
5182                                                  
5183                                                  sub make_slave_of_sibling {
5184  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
5185                                                          $dsn_parser, $timeout) = @_;
5186                                                  
5187  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
5188  ***      0                                            die "You are trying to make the slave a slave of itself";
5189                                                     }
5190                                                  
5191  ***      0      0                                  my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5192                                                        or die "This server is not a slave";
5193  ***      0                                         my $master_dbh1 = $dsn_parser->get_dbh(
5194                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
5195  ***      0      0                                  my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5196                                                        or die "The sibling is not a slave";
5197  ***      0      0                                  if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
5198  ***      0                                            die "This server isn't a sibling of the slave";
5199                                                     }
5200  ***      0      0                                  my $sib_master_stat = $self->get_master_status($sib_dbh)
5201                                                        or die "Binary logging is not enabled on the sibling";
5202  ***      0      0                                  die "The log_slave_updates option is not enabled on the sibling"
5203                                                        unless $self->has_slave_updates($sib_dbh);
5204                                                  
5205  ***      0                                         $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
5206                                                  
5207  ***      0                                         $sib_master_stat = $self->get_master_status($sib_dbh);
5208  ***      0                                         $self->change_master_to($slave_dbh, $sib_dsn,
5209                                                           $self->repl_posn($sib_master_stat));
5210                                                  
5211  ***      0                                         my $slave_status = $self->get_slave_status($slave_dbh);
5212  ***      0                                         my $slave_pos    = $self->repl_posn($slave_status);
5213  ***      0                                         $sib_master_stat = $self->get_master_status($sib_dbh);
5214  ***      0      0      0                           if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
5215                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
5216                                                     {
5217  ***      0                                            die "After changing the slave's master, it isn't a slave of the sibling, "
5218                                                           . "or it has a different replication position than the sibling";
5219                                                     }
5220                                                  }
5221                                                  
5222                                                  sub make_slave_of_uncle {
5223  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
5224                                                          $dsn_parser, $timeout) = @_;
5225                                                  
5226  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
5227  ***      0                                            die "You are trying to make the slave a slave of itself";
5228                                                     }
5229                                                  
5230  ***      0      0                                  my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5231                                                        or die "This server is not a slave";
5232  ***      0                                         my $master_dbh = $dsn_parser->get_dbh(
5233                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
5234  ***      0      0                                  my $gmaster_dsn
5235                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5236                                                        or die "The master is not a slave";
5237  ***      0      0                                  my $unc_master_dsn
5238                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
5239                                                        or die "The uncle is not a slave";
5240  ***      0      0                                  if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
5241  ***      0                                            die "The uncle isn't really the slave's uncle";
5242                                                     }
5243                                                  
5244  ***      0      0                                  my $unc_master_stat = $self->get_master_status($unc_dbh)
5245                                                        or die "Binary logging is not enabled on the uncle";
5246  ***      0      0                                  die "The log_slave_updates option is not enabled on the uncle"
5247                                                        unless $self->has_slave_updates($unc_dbh);
5248                                                  
5249  ***      0                                         $self->catchup_to_same_pos($master_dbh, $unc_dbh);
5250  ***      0                                         $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
5251                                                  
5252  ***      0                                         my $slave_status  = $self->get_slave_status($slave_dbh);
5253  ***      0                                         my $master_status = $self->get_master_status($master_dbh);
5254  ***      0      0                                  if ( $self->pos_cmp(
5255                                                           $self->repl_posn($slave_status),
5256                                                           $self->repl_posn($master_status)) != 0 )
5257                                                     {
5258  ***      0                                            die "The slave is not caught up to its master";
5259                                                     }
5260                                                  
5261  ***      0                                         $unc_master_stat = $self->get_master_status($unc_dbh);
5262  ***      0                                         $self->change_master_to($slave_dbh, $unc_dsn,
5263                                                        $self->repl_posn($unc_master_stat));
5264                                                  
5265                                                  
5266  ***      0                                         $slave_status    = $self->get_slave_status($slave_dbh);
5267  ***      0                                         my $slave_pos    = $self->repl_posn($slave_status);
5268  ***      0      0      0                           if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
5269                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
5270                                                     {
5271  ***      0                                            die "After changing the slave's master, it isn't a slave of the uncle, "
5272                                                           . "or it has a different replication position than the uncle";
5273                                                     }
5274                                                  }
5275                                                  
5276                                                  sub detach_slave {
5277  ***      0                    0                    my ( $self, $dbh ) = @_;
5278  ***      0                                         $self->stop_slave($dbh);
5279  ***      0      0                                  my $stat = $self->get_slave_status($dbh)
5280                                                        or die "This server is not a slave";
5281  ***      0                                         $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
5282  ***      0                                         $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
5283  ***      0                                         return $stat;
5284                                                  }
5285                                                  
5286                                                  sub slave_is_running {
5287  ***      0                    0                    my ( $self, $slave_status ) = @_;
5288  ***      0             0                           return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
5289                                                  }
5290                                                  
5291                                                  sub has_slave_updates {
5292  ***      0                    0                    my ( $self, $dbh ) = @_;
5293  ***      0                                         my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
5294  ***      0                                         MKDEBUG && _d($dbh, $sql);
5295  ***      0                                         my ($name, $value) = $dbh->selectrow_array($sql);
5296  ***      0             0                           return $value && $value =~ m/^(1|ON)$/;
5297                                                  }
5298                                                  
5299                                                  sub repl_posn {
5300  ***      0                    0                    my ( $self, $status ) = @_;
5301  ***      0      0      0                           if ( exists $status->{file} && exists $status->{position} ) {
5302                                                        return {
5303  ***      0                                               file     => $status->{file},
5304                                                           position => $status->{position},
5305                                                        };
5306                                                     }
5307                                                     else {
5308                                                        return {
5309  ***      0                                               file     => $status->{relay_master_log_file},
5310                                                           position => $status->{exec_master_log_pos},
5311                                                        };
5312                                                     }
5313                                                  }
5314                                                  
5315                                                  sub get_slave_lag {
5316  ***      0                    0                    my ( $self, $dbh ) = @_;
5317  ***      0                                         my $stat = $self->get_slave_status($dbh);
5318  ***      0                                         return $stat->{seconds_behind_master};
5319                                                  }
5320                                                  
5321                                                  sub pos_cmp {
5322  ***      0                    0                    my ( $self, $a, $b ) = @_;
5323  ***      0                                         return $self->pos_to_string($a) cmp $self->pos_to_string($b);
5324                                                  }
5325                                                  
5326                                                  sub short_host {
5327  ***      0                    0                    my ( $self, $dsn ) = @_;
5328  ***      0                                         my ($host, $port);
5329  ***      0      0                                  if ( $dsn->{master_host} ) {
5330  ***      0                                            $host = $dsn->{master_host};
5331  ***      0                                            $port = $dsn->{master_port};
5332                                                     }
5333                                                     else {
5334  ***      0                                            $host = $dsn->{h};
5335  ***      0                                            $port = $dsn->{P};
5336                                                     }
5337  ***      0      0      0                           return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
5338                                                  }
5339                                                  
5340                                                  sub pos_to_string {
5341  ***      0                    0                    my ( $self, $pos ) = @_;
5342  ***      0                                         my $fmt  = '%s/%020d';
5343  ***      0                                         return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                      
5344                                                  }
5345                                                  
5346                                                  sub _d {
5347  ***      0                    0                    my ($package, undef, $line) = caller 0;
5348  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
5349  ***      0                                              map { defined $_ ? $_ : 'undef' }
5350                                                          @_;
5351  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5352                                                  }
5353                                                  
5354                                                  1;
5355                                                  
5356                                                  # ###########################################################################
5357                                                  # End MasterSlave package
5358                                                  # ###########################################################################
5359                                                  
5360                                                  # ###########################################################################
5361                                                  # Daemon package 5266
5362                                                  # ###########################################################################
5363                                                  
5364                                                  package Daemon;
5365                                                  
5366          27                   27           253   use strict;
              27                                 80   
              27                                191   
5367          27                   27           164   use warnings FATAL => 'all';
              27                                 77   
              27                                169   
5368                                                  
5369          27                   27           246   use POSIX qw(setsid);
              27                                 76   
              27                                195   
5370          27                   27           175   use English qw(-no_match_vars);
              27                                194   
              27                                181   
5371                                                  
5372  ***     27            50     27           187   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 80   
              27                                453   
5373                                                  
5374                                                  sub new {
5375  ***      0                    0                    my ( $class, %args ) = @_;
5376  ***      0                                         foreach my $arg ( qw(o) ) {
5377  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5378                                                     }
5379  ***      0                                         my $o = $args{o};
5380  ***      0      0                                  my $self = {
      ***             0                               
5381                                                        o        => $o,
5382                                                        log_file => $o->has('log') ? $o->get('log') : undef,
5383                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
5384                                                     };
5385                                                  
5386  ***      0                                         check_PID_file(undef, $self->{PID_file});
5387                                                  
5388  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
5389  ***      0                                         return bless $self, $class;
5390                                                  }
5391                                                  
5392                                                  sub daemonize {
5393  ***      0                    0                    my ( $self ) = @_;
5394                                                  
5395  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
5396  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
5397  ***      0      0                                  if ( $pid ) {
5398  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
5399  ***      0                                            exit;
5400                                                     }
5401                                                  
5402  ***      0                                         $self->{child} = 1;
5403                                                  
5404  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
5405  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
5406                                                  
5407  ***      0                                         $self->_make_PID_file();
5408                                                  
5409  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
5410                                                  
5411  ***      0      0                                  if ( -t STDIN ) {
5412  ***      0                                            close STDIN;
5413  ***      0      0                                     open  STDIN, '/dev/null'
5414                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
5415                                                     }
5416                                                  
5417  ***      0      0                                  if ( $self->{log_file} ) {
5418  ***      0                                            close STDOUT;
5419  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
5420                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
5421                                                  
5422  ***      0                                            close STDERR;
5423  ***      0      0                                     open  STDERR, ">&STDOUT"
5424                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
5425                                                     }
5426                                                     else {
5427  ***      0      0                                     if ( -t STDOUT ) {
5428  ***      0                                               close STDOUT;
5429  ***      0      0                                        open  STDOUT, '>', '/dev/null'
5430                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
5431                                                        }
5432  ***      0      0                                     if ( -t STDERR ) {
5433  ***      0                                               close STDERR;
5434  ***      0      0                                        open  STDERR, '>', '/dev/null'
5435                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
5436                                                        }
5437                                                     }
5438                                                  
5439  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
5440  ***      0                                         return;
5441                                                  }
5442                                                  
5443                                                  sub check_PID_file {
5444  ***      0                    0                    my ( $self, $file ) = @_;
5445  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
5446  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
5447  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
5448  ***      0                                            my $pid;
5449  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
5450  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
5451  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
5452  ***      0      0                                     if ( $pid ) {
5453  ***      0                                               my $pid_is_alive = kill 0, $pid;
5454  ***      0      0                                        if ( $pid_is_alive ) {
5455  ***      0                                                  die "The PID file $PID_file already exists "
5456                                                                 . " and the PID that it contains, $pid, is running";
5457                                                           }
5458                                                           else {
5459  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
5460                                                                 . "contains, $pid, is not running";
5461                                                           }
5462                                                        }
5463                                                        else {
5464  ***      0                                               die "The PID file $PID_file already exists but it does not "
5465                                                              . "contain a PID";
5466                                                        }
5467                                                     }
5468                                                     else {
5469  ***      0                                            MKDEBUG && _d('No PID file');
5470                                                     }
5471  ***      0                                         return;
5472                                                  }
5473                                                  
5474                                                  sub make_PID_file {
5475  ***      0                    0                    my ( $self ) = @_;
5476  ***      0      0                                  if ( exists $self->{child} ) {
5477  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
5478                                                     }
5479  ***      0                                         $self->_make_PID_file();
5480  ***      0                                         $self->{rm_PID_file} = 1;
5481  ***      0                                         return;
5482                                                  }
5483                                                  
5484                                                  sub _make_PID_file {
5485  ***      0                    0                    my ( $self ) = @_;
5486                                                  
5487  ***      0                                         my $PID_file = $self->{PID_file};
5488  ***      0      0                                  if ( !$PID_file ) {
5489  ***      0                                            MKDEBUG && _d('No PID file to create');
5490  ***      0                                            return;
5491                                                     }
5492                                                  
5493  ***      0                                         $self->check_PID_file();
5494                                                  
5495  ***      0      0                                  open my $PID_FH, '>', $PID_file
5496                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
5497  ***      0      0                                  print $PID_FH $PID
5498                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
5499  ***      0      0                                  close $PID_FH
5500                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
5501                                                  
5502  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
5503  ***      0                                         return;
5504                                                  }
5505                                                  
5506                                                  sub _remove_PID_file {
5507  ***      0                    0                    my ( $self ) = @_;
5508  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
5509  ***      0      0                                     unlink $self->{PID_file}
5510                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
5511  ***      0                                            MKDEBUG && _d('Removed PID file');
5512                                                     }
5513                                                     else {
5514  ***      0                                            MKDEBUG && _d('No PID to remove');
5515                                                     }
5516  ***      0                                         return;
5517                                                  }
5518                                                  
5519                                                  sub DESTROY {
5520  ***      0                    0                    my ( $self ) = @_;
5521  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
5522  ***      0                                         return;
5523                                                  }
5524                                                  
5525                                                  sub _d {
5526  ***      0                    0                    my ($package, undef, $line) = caller 0;
5527  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
5528  ***      0                                              map { defined $_ ? $_ : 'undef' }
5529                                                          @_;
5530  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5531                                                  }
5532                                                  
5533                                                  1;
5534                                                  
5535                                                  # ###########################################################################
5536                                                  # End Daemon package
5537                                                  # ###########################################################################
5538                                                  
5539                                                  # ###########################################################################
5540                                                  # SchemaIterator package 5473
5541                                                  # ###########################################################################
5542                                                  package SchemaIterator;
5543                                                  
5544          27                   27           216   use strict;
              27                                 68   
              27                                171   
5545          27                   27           169   use warnings FATAL => 'all';
              27                                 68   
              27                                157   
5546                                                  
5547          27                   27           162   use English qw(-no_match_vars);
              27                                 67   
              27                                156   
5548          27                   27           187   use Data::Dumper;
              27                                 68   
              27                                155   
5549                                                  $Data::Dumper::Indent    = 1;
5550                                                  $Data::Dumper::Sortkeys  = 1;
5551                                                  $Data::Dumper::Quotekeys = 0;
5552                                                  
5553  ***     27            50     27           175   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                842   
              27                                585   
5554                                                  
5555                                                  sub new {
5556  ***      0                    0                    my ( $class, %args ) = @_;
5557  ***      0                                         foreach my $arg ( qw(Quoter) ) {
5558  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5559                                                     }
5560  ***      0                                         my $self = {
5561                                                        %args,
5562                                                        filter => undef,
5563                                                        dbs    => [],
5564                                                     };
5565  ***      0                                         return bless $self, $class;
5566                                                  }
5567                                                  
5568                                                  sub make_filter {
5569  ***      0                    0                    my ( $self, $o ) = @_;
5570  ***      0                                         my @lines = (
5571                                                        'sub {',
5572                                                        '   my ( $dbh, $db, $tbl ) = @_;',
5573                                                        '   my $engine = undef;',
5574                                                     );
5575                                                  
5576                                                  
5577  ***      0      0                                  my @permit_dbs = _make_filter('unless', '$db', $o->get('databases'))
5578                                                        if $o->has('databases');
5579  ***      0      0                                  my @reject_dbs = _make_filter('if', '$db', $o->get('ignore-databases'))
5580                                                        if $o->has('ignore-databases');
5581  ***      0                                         my @dbs_regex;
5582  ***      0      0      0                           if ( $o->has('databases-regex') && (my $p = $o->get('databases-regex')) ) {
5583  ***      0                                            push @dbs_regex, "      return 0 unless \$db && (\$db =~ m/$p/o);";
5584                                                     }
5585  ***      0                                         my @reject_dbs_regex;
5586  ***      0      0      0                           if ( $o->has('ignore-databases-regex')
5587                                                          && (my $p = $o->get('ignore-databases-regex')) ) {
5588  ***      0                                            push @reject_dbs_regex, "      return 0 if \$db && (\$db =~ m/$p/o);";
5589                                                     }
5590  ***      0      0      0                           if ( @permit_dbs || @reject_dbs || @dbs_regex || @reject_dbs_regex ) {
      ***                    0                        
      ***                    0                        
5591  ***      0      0                                     push @lines,
      ***             0                               
      ***             0                               
      ***             0                               
5592                                                           '   if ( $db ) {',
5593                                                              (@permit_dbs        ? @permit_dbs       : ()),
5594                                                              (@reject_dbs        ? @reject_dbs       : ()),
5595                                                              (@dbs_regex         ? @dbs_regex        : ()),
5596                                                              (@reject_dbs_regex  ? @reject_dbs_regex : ()),
5597                                                           '   }';
5598                                                     }
5599                                                  
5600  ***      0      0      0                           if ( $o->has('tables') || $o->has('ignore-tables')
      ***                    0                        
5601                                                          || $o->has('ignore-tables-regex') ) {
5602                                                  
5603  ***      0                                            my $have_qtbl       = 0;
5604  ***      0                                            my $have_only_qtbls = 0;
5605  ***      0                                            my %qtbls;
5606                                                  
5607  ***      0                                            my @permit_tbls;
5608  ***      0                                            my @permit_qtbls;
5609  ***      0                                            my %permit_qtbls;
5610  ***      0      0                                     if ( $o->get('tables') ) {
5611  ***      0                                               my %tbls;
5612                                                           map {
5613  ***      0      0                                           if ( $_ =~ m/\./ ) {
      ***      0                                      
5614  ***      0                                                     $permit_qtbls{$_} = 1;
5615                                                              }
5616                                                              else {
5617  ***      0                                                     $tbls{$_} = 1;
5618                                                              }
5619  ***      0                                               } keys %{ $o->get('tables') };
5620  ***      0                                               @permit_tbls  = _make_filter('unless', '$tbl', \%tbls);
5621  ***      0                                               @permit_qtbls = _make_filter('unless', '$qtbl', \%permit_qtbls);
5622                                                  
5623  ***      0      0                                        if ( @permit_qtbls ) {
5624  ***      0                                                  push @lines,
5625                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
5626  ***      0                                                  $have_qtbl = 1;
5627                                                           }
5628                                                        }
5629                                                  
5630  ***      0                                            my @reject_tbls;
5631  ***      0                                            my @reject_qtbls;
5632  ***      0                                            my %reject_qtbls;
5633  ***      0      0                                     if ( $o->get('ignore-tables') ) {
5634  ***      0                                               my %tbls;
5635                                                           map {
5636  ***      0      0                                           if ( $_ =~ m/\./ ) {
      ***      0                                      
5637  ***      0                                                     $reject_qtbls{$_} = 1;
5638                                                              }
5639                                                              else {
5640  ***      0                                                     $tbls{$_} = 1;
5641                                                              }
5642  ***      0                                               } keys %{ $o->get('ignore-tables') };
5643  ***      0                                               @reject_tbls= _make_filter('if', '$tbl', \%tbls);
5644  ***      0                                               @reject_qtbls = _make_filter('if', '$qtbl', \%reject_qtbls);
5645                                                  
5646  ***      0      0      0                                 if ( @reject_qtbls && !$have_qtbl ) {
5647  ***      0                                                  push @lines,
5648                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
5649                                                           }
5650                                                        }
5651                                                  
5652  ***      0      0      0                              if ( keys %permit_qtbls  && !@permit_dbs ) {
5653  ***      0                                               my $dbs = {};
5654  ***      0                                               map {
5655  ***      0                                                  my ($db, undef) = split(/\./, $_);
5656  ***      0                                                  $dbs->{$db} = 1;
5657                                                           } keys %permit_qtbls;
5658  ***      0                                               MKDEBUG && _d('Adding restriction "--databases',
5659                                                                 (join(',', keys %$dbs) . '"'));
5660  ***      0      0                                        if ( keys %$dbs ) {
5661  ***      0                                                  $o->set('databases', $dbs);
5662  ***      0                                                  return $self->make_filter($o);
5663                                                           }
5664                                                        }
5665                                                  
5666  ***      0                                            my @tbls_regex;
5667  ***      0      0      0                              if ( $o->has('tables-regex') && (my $p = $o->get('tables-regex')) ) {
5668  ***      0                                               push @tbls_regex, "      return 0 unless \$tbl && (\$tbl =~ m/$p/o);";
5669                                                        }
5670  ***      0                                            my @reject_tbls_regex;
5671  ***      0      0      0                              if ( $o->has('ignore-tables-regex')
5672                                                             && (my $p = $o->get('ignore-tables-regex')) ) {
5673  ***      0                                               push @reject_tbls_regex,
5674                                                              "      return 0 if \$tbl && (\$tbl =~ m/$p/o);";
5675                                                        }
5676                                                  
5677  ***      0                                            my @get_eng;
5678  ***      0                                            my @permit_engs;
5679  ***      0                                            my @reject_engs;
5680  ***      0      0      0                              if ( ($o->has('engines') && $o->get('engines'))
      ***                    0                        
      ***                    0                        
5681                                                             || ($o->has('ignore-engines') && $o->get('ignore-engines')) ) {
5682  ***      0                                               push @get_eng,
5683                                                              '      my $sql = "SHOW TABLE STATUS "',
5684                                                              '              . ($db ? "FROM `$db`" : "")',
5685                                                              '              . " LIKE \'$tbl\'";',
5686                                                              '      MKDEBUG && _d($sql);',
5687                                                              '      eval {',
5688                                                              '         $engine = $dbh->selectrow_hashref($sql)->{engine};',
5689                                                              '      };',
5690                                                              '      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);',
5691                                                              '      MKDEBUG && _d($tbl, "uses engine", $engine);',
5692                                                              '      $engine = lc $engine if $engine;',
5693                                                           @permit_engs
5694                                                              = _make_filter('unless', '$engine', $o->get('engines'), 1);
5695                                                           @reject_engs
5696  ***      0                                                  = _make_filter('if', '$engine', $o->get('ignore-engines'), 1)
5697                                                        }
5698                                                  
5699  ***      0      0      0                              if ( @permit_tbls || @reject_tbls || @tbls_regex || @reject_tbls_regex
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
5700                                                             || @permit_engs || @reject_engs ) {
5701  ***      0      0                                        push @lines,
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
5702                                                              '   if ( $tbl ) {',
5703                                                                 (@permit_tbls       ? @permit_tbls        : ()),
5704                                                                 (@reject_tbls       ? @reject_tbls        : ()),
5705                                                                 (@tbls_regex        ? @tbls_regex         : ()),
5706                                                                 (@reject_tbls_regex ? @reject_tbls_regex  : ()),
5707                                                                 (@permit_qtbls      ? @permit_qtbls       : ()),
5708                                                                 (@reject_qtbls      ? @reject_qtbls       : ()),
5709                                                                 (@get_eng           ? @get_eng            : ()),
5710                                                                 (@permit_engs       ? @permit_engs        : ()),
5711                                                                 (@reject_engs       ? @reject_engs        : ()),
5712                                                              '   }';
5713                                                        }
5714                                                     }
5715                                                  
5716  ***      0                                         push @lines,
5717                                                        '   MKDEBUG && _d(\'Passes filters:\', $db, $tbl, $engine, $dbh);',
5718                                                        '   return 1;',  '}';
5719                                                  
5720  ***      0                                         my $code = join("\n", @lines);
5721  ***      0                                         MKDEBUG && _d('filter sub:', $code);
5722  ***      0      0                                  my $filter_sub= eval $code
5723                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
5724                                                  
5725  ***      0                                         return $filter_sub;
5726                                                  }
5727                                                  
5728                                                  sub set_filter {
5729  ***      0                    0                    my ( $self, $filter_sub ) = @_;
5730  ***      0                                         $self->{filter} = $filter_sub;
5731  ***      0                                         MKDEBUG && _d('Set filter sub');
5732  ***      0                                         return;
5733                                                  }
5734                                                  
5735                                                  sub get_db_itr {
5736  ***      0                    0                    my ( $self, %args ) = @_;
5737  ***      0                                         my @required_args = qw(dbh);
5738  ***      0                                         foreach my $arg ( @required_args ) {
5739  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5740                                                     }
5741  ***      0                                         my ($dbh) = @args{@required_args};
5742                                                  
5743  ***      0                                         my $filter = $self->{filter};
5744  ***      0                                         my @dbs;
5745  ***      0                                         eval {
5746  ***      0                                            my $sql = 'SHOW DATABASES';
5747  ***      0                                            MKDEBUG && _d($sql);
5748  ***      0      0                                     @dbs =  grep {
5749  ***      0                                               my $ok = $filter ? $filter->($dbh, $_, undef) : 1;
5750  ***      0      0                                        $ok = 0 if $_ =~ m/information_schema|lost\+found/;
5751  ***      0                                               $ok;
5752  ***      0                                            } @{ $dbh->selectcol_arrayref($sql) };
5753  ***      0                                            MKDEBUG && _d('Found', scalar @dbs, 'databases');
5754                                                     };
5755  ***      0                                         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
5756                                                     return sub {
5757  ***      0                    0                       return shift @dbs;
5758  ***      0                                         };
5759                                                  }
5760                                                  
5761                                                  sub get_tbl_itr {
5762  ***      0                    0                    my ( $self, %args ) = @_;
5763  ***      0                                         my @required_args = qw(dbh db);
5764  ***      0                                         foreach my $arg ( @required_args ) {
5765  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5766                                                     }
5767  ***      0                                         my ($dbh, $db, $views) = @args{@required_args, 'views'};
5768                                                  
5769  ***      0                                         my $filter = $self->{filter};
5770  ***      0                                         my @tbls;
5771  ***      0      0                                  if ( $db ) {
5772  ***      0                                            eval {
5773  ***      0                                               my $sql = 'SHOW /*!50002 FULL*/ TABLES FROM '
5774                                                                   . $self->{Quoter}->quote($db);
5775  ***      0                                               MKDEBUG && _d($sql);
5776  ***      0                                               @tbls = map {
5777  ***      0                                                  $_->[0]
5778                                                           }
5779                                                           grep {
5780  ***      0                                                  my ($tbl, $type) = @$_;
5781  ***      0      0                                           my $ok = $filter ? $filter->($dbh, $db, $tbl) : 1;
5782  ***      0      0                                           if ( !$views ) {
5783  ***      0      0      0                                       $ok = 0 if ($type || '') eq 'VIEW';
5784                                                              }
5785  ***      0                                                  $ok;
5786                                                           }
5787  ***      0                                               @{ $dbh->selectall_arrayref($sql) };
5788  ***      0                                               MKDEBUG && _d('Found', scalar @tbls, 'tables in', $db);
5789                                                        };
5790  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
5791                                                     }
5792                                                     else {
5793  ***      0                                            MKDEBUG && _d('No db given so no tables');
5794                                                     }
5795                                                     return sub {
5796  ***      0                    0                       return shift @tbls;
5797  ***      0                                         };
5798                                                  }
5799                                                  
5800                                                  sub _make_filter {
5801  ***      0                    0                    my ( $cond, $var_name, $objs, $lc ) = @_;
5802  ***      0                                         my @lines;
5803  ***      0      0                                  if ( scalar keys %$objs ) {
5804  ***      0      0                                     my $test = join(' || ',
5805  ***      0                                               map { "$var_name eq '" . ($lc ? lc $_ : $_) ."'" } keys %$objs);
5806  ***      0                                            push @lines, "      return 0 $cond $var_name && ($test);",
5807                                                     }
5808  ***      0                                         return @lines;
5809                                                  }
5810                                                  
5811                                                  sub _d {
5812  ***      0                    0                    my ($package, undef, $line) = caller 0;
5813  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
5814  ***      0                                              map { defined $_ ? $_ : 'undef' }
5815                                                          @_;
5816  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5817                                                  }
5818                                                  
5819                                                  1;
5820                                                  
5821                                                  # ###########################################################################
5822                                                  # End SchemaIterator package
5823                                                  # ###########################################################################
5824                                                  
5825                                                  # ###########################################################################
5826                                                  # This is a combination of modules and programs in one -- a runnable module.
5827                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
5828                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
5829                                                  #
5830                                                  # Check at the end of this package for the call to main() which actually runs
5831                                                  # the program.
5832                                                  # ###########################################################################
5833                                                  package mk_table_sync;
5834                                                  
5835          27                   27           227   use English qw(-no_match_vars);
              27                                 80   
              27                                173   
5836          27                   27           209   use List::Util qw(sum max min);
              27                                 70   
              27                                179   
5837          27                   27           174   use POSIX qw(ceil);
              27                                 81   
              27                                170   
5838                                                  
5839  ***     27            50     27           165   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 70   
              27                                415   
5840                                                  
5841                                                  $OUTPUT_AUTOFLUSH = 1;
5842                                                  
5843                                                  sub main {
5844  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
5845                                                  
5846                                                     # ########################################################################
5847                                                     # Get configuration information.
5848                                                     # ########################################################################
5849  ***      0                                         my $dp = new DSNParser(
5850                                                        {
5851                                                           key  => 'D',
5852                                                           desc => 'Database containing the table to be synced',
5853                                                           dsn  => 'database',
5854                                                           copy => 1,
5855                                                        },
5856                                                        {
5857                                                           key  => 't',
5858                                                           desc => 'Table to be synced',
5859                                                           dsn  => undef,
5860                                                           copy => 1,
5861                                                        },
5862                                                     );
5863                                                  
5864  ***      0                                         my $o = new OptionParser(
5865                                                        dp          => $dp,
5866                                                        strict      => 0,
5867                                                        prompt      => '[OPTION]... DSN [DSN]...',
5868                                                        description => 'synchronizes data efficiently between MySQL tables.',
5869                                                     );
5870  ***      0                                         $o->get_specs();
5871  ***      0                                         $o->get_opts();
5872                                                  
5873  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
5874                                                  
5875  ***      0      0      0                           if ( $o->get('replicate') || $o->get('sync-to-master') ) {
5876  ***      0      0                                     $o->set('wait', 60) unless $o->got('wait');
5877                                                     }
5878  ***      0      0                                  if ( $o->get('wait') ) {
5879  ***      0      0                                     $o->set('lock', 1) unless $o->got('lock');
5880                                                     }
5881  ***      0      0                                  if ( $o->get('dry-run') ) {
5882  ***      0                                            $o->set('verbose', 1);
5883                                                     }
5884                                                  
5885                                                     # There's a conflict of interests: we added 't' and 'D' parts to dp,
5886                                                     # and there are -t and -D options (--tables, --databases), so parse_options()
5887                                                     # is going to return a DSN with the default values from -t and -D,
5888                                                     # but these are not actually be default dsn vals, they're filters.
5889                                                     # So we have to remove them from $dsn_defaults.
5890  ***      0                                         my $dsn_defaults = $dp->parse_options($o);
5891  ***      0                                         $dsn_defaults->{D} = undef;
5892  ***      0                                         $dsn_defaults->{t} = undef;
5893                                                  
5894  ***      0                                         my @dsns;
5895  ***      0                                         while ( my $arg = shift(@ARGV) ) {
5896  ***      0                                            my $dsn = $dp->parse($arg, $dsns[0], $dsn_defaults);
5897  ***      0      0      0                              die "You specified a t part, but not a D part in $arg"
5898                                                           if ($dsn->{t} && !$dsn->{D});
5899  ***      0      0      0                              if ( $dsn->{D} && !$dsn->{t} ) {
5900  ***      0                                               die "You specified a database but not a table in $arg.  Are you "
5901                                                              . "trying to sync only tables in the '$dsn->{D}' database?  "
5902                                                              . "If so, use '--databases $dsn->{D}' instead.\n";
5903                                                        }
5904  ***      0                                            push @dsns, $dsn;
5905                                                     }
5906                                                  
5907  ***      0      0      0                           if ( !@dsns
      ***                    0                        
      ***                    0                        
5908                                                          || (@dsns ==1 && !$o->get('replicate') && !$o->get('sync-to-master'))) {
5909  ***      0                                            $o->save_error('At least one DSN is required, and at least two are '
5910                                                           . 'required unless --sync-to-master or --replicate is specified');
5911                                                     }
5912                                                  
5913  ***      0      0      0                           if ( @dsns > 1 && $o->get('sync-to-master') && $o->get('replicate') ) {
      ***                    0                        
5914  ***      0                                            $o->save_error('--sync-to-master and --replicate require only one DSN ',
5915                                                           ' but ', scalar @dsns, ' where given');
5916                                                     }
5917                                                  
5918  ***      0      0                                  if ( $o->get('lock-and-rename') ) {
5919  ***      0      0      0                              if ( @dsns != 2 || !$dsns[0]->{t} || !$dsns[1]->{t} ) {
      ***                    0                        
5920  ***      0                                               $o->save_error("--lock-and-rename requires exactly two DSNs and they "
5921                                                              . "must each specify a table.");
5922                                                        }
5923                                                     }
5924                                                  
5925  ***      0      0                                  if ( $o->get('explain-hosts') ) {
5926  ***      0                                            foreach my $host ( @dsns ) {
5927  ***      0                                               print "# DSN: ", $dp->as_string($host), "\n";
5928                                                        }
5929  ***      0                                            return 0;
5930                                                     }
5931                                                  
5932  ***      0                                         $o->usage_or_errors();
5933                                                  
5934                                                     # ########################################################################
5935                                                     # If --pid, check it first since we'll die if it already exits.
5936                                                     # ########################################################################
5937  ***      0                                         my $daemon;
5938  ***      0      0                                  if ( $o->get('pid') ) {
5939                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
5940                                                        # in the the scope of main() because when it's destroyed it automatically
5941                                                        # removes the PID file.
5942  ***      0                                            $daemon = new Daemon(o=>$o);
5943  ***      0                                            $daemon->make_PID_file();
5944                                                     }
5945                                                  
5946                                                     # ########################################################################
5947                                                     # Do the work.
5948                                                     # ########################################################################
5949  ***      0                                         my $q         = new Quoter();
5950  ***      0                                         my $tp        = new TableParser( Quoter => $q );
5951  ***      0                                         my $vp        = new VersionParser();
5952  ***      0                                         my $ms        = new MasterSlave();
5953  ***      0                                         my $du        = new MySQLDump( cache => 0 );
5954  ***      0                                         my $chunker   = new TableChunker( Quoter => $q, MySQLDump => $du );
5955  ***      0                                         my $nibbler   = new TableNibbler( Quoter => $q, TableParser => $tp );
5956  ***      0                                         my $checksum  = new TableChecksum( Quoter => $q, VersionParser => $vp );
5957  ***      0                                         my $syncer    = new TableSyncer(
5958                                                        Quoter        => $q,
5959                                                        VersionParser => $vp,
5960                                                        MasterSlave   => $ms,
5961                                                        TableChecksum => $checksum,
5962                                                     );
5963  ***      0                                         my %modules = (
5964                                                        OptionParser   => $o,
5965                                                        DSNParser      => $dp,
5966                                                        MySQLDump      => $du,
5967                                                        TableParser    => $tp,
5968                                                        Quoter         => $q,
5969                                                        VersionParser  => $vp,
5970                                                        TableChunker   => $chunker,
5971                                                        TableNibbler   => $nibbler,
5972                                                        TableChecksum  => $checksum,
5973                                                        MasterSlave    => $ms,
5974                                                        TableSyncer    => $syncer,
5975                                                     );
5976                                                  
5977                                                     # Create the sync plugins.
5978  ***      0                                         my $plugins = [];
5979  ***      0                                         foreach my $plugin_name ( split(',', $o->get('algorithms')) ) {
5980  ***      0                                            $plugin_name = "TableSync$plugin_name";
5981  ***      0                                            MKDEBUG && _d('Loading', $plugin_name);
5982  ***      0                                            my $plugin;
5983  ***      0                                            eval {
5984  ***      0                                               $plugin = $plugin_name->new(%modules);
5985                                                        };
5986  ***      0      0                                     die "Cannot load $plugin_name for --algorithm: $EVAL_ERROR"
5987                                                           if $EVAL_ERROR;
5988  ***      0                                            push @$plugins, $plugin;
5989                                                     }
5990                                                  
5991  ***      0                                         my $hdr         = "# %6s %7s %6s %6s %-9s %-4s %s.%s\n";
5992  ***      0                                         my $exit_status = 0; # 1: internal error, 2: tables differed, 3: both
5993                                                  
5994                                                     # dsn[0] is expected to be the master (i.e. the source).  So if
5995                                                     # --sync-to-master, then dsn[0] is a slave.  Find its master and
5996                                                     # make the master dsn[0] and the slave dsn[1].
5997  ***      0      0                                  if ( $o->get('sync-to-master') ) {
5998  ***      0                                            MKDEBUG && _d('Getting master of', $dp->as_string($dsns[0]));
5999  ***      0                                            $dsns[0]->{dbh} = get_cxn($dsns[0], %modules);
6000  ***      0      0                                     my $master = $ms->get_master_dsn($dsns[0]->{dbh}, $dsns[0], $dp)
6001                                                           or die "Can't determine master of " . $dp->as_string($dsns[0]);
6002  ***      0                                            unshift @dsns, $master;  # dsn[0]=master, dsn[1]=slave
6003  ***      0                                            $dsns[0]->{dbh} = get_cxn($dsns[0], %modules);
6004  ***      0      0                                     if ( $o->get('check-master') ) {
6005  ***      0                                               $ms->is_master_of($dsns[0]->{dbh}, $dsns[1]->{dbh});
6006                                                        }
6007                                                     }
6008                                                  
6009  ***      0                                         my %args = (
6010                                                        dsns    => \@dsns,
6011                                                        plugins => $plugins,
6012                                                        hdr     => $hdr,
6013                                                        %modules,
6014                                                     );
6015                                                  
6016  ***      0      0                                  if ( $o->get('dry-run') ) {
6017  ***      0                                            print "# NOTE: --dry-run does not show if data needs to be synced because it\n"
6018                                                           .  "#       does not access, compare or sync data.  --dry-run only shows\n"
6019                                                           .  "#       the work that would be done.\n";
6020                                                  
6021                                                     }
6022                                                  
6023  ***      0      0                                  if ( $o->get('lock-and-rename') ) {
      ***             0                               
      ***             0                               
6024  ***      0                                            $exit_status = lock_and_rename(%args);
6025                                                     }
6026                                                     elsif ( $dsns[0]->{t} ) {
6027  ***      0                                            $exit_status = sync_one_table(%args);
6028                                                     }
6029                                                     elsif ( $o->get('replicate') ) {
6030  ***      0                                            $exit_status = sync_via_replication(%args);
6031                                                     }
6032                                                     else {
6033  ***      0                                            $exit_status = sync_all(%args);
6034                                                     }
6035                                                  
6036  ***      0                                         return $exit_status;
6037                                                  }
6038                                                  
6039                                                  # ############################################################################
6040                                                  # Subroutines
6041                                                  # ############################################################################
6042                                                  
6043                                                  sub lock_and_rename {
6044  ***      0                    0                    my ( %args ) = @_;
6045  ***      0                                         my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
6046                                                                            VersionParser);
6047  ***      0                                         foreach my $arg ( @required_args ) {
6048  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6049                                                     }
6050  ***      0                                         my $dsns = $args{dsns};
6051  ***      0                                         my $o    = $args{OptionParser};
6052  ***      0                                         my $dp   = $args{DSNParser};
6053  ***      0                                         my $q    = $args{Quoter};
6054                                                  
6055  ***      0                                         MKDEBUG && _d('Locking and syncing ONE TABLE with rename');
6056  ***      0             0                           my $src = {
6057                                                        dsn      => $dsns->[0],
6058                                                        dbh      => $dsns->[0]->{dbh} || get_cxn($dsns->[0], %args),
6059                                                        misc_dbh => get_cxn($dsns->[0], %args),
6060                                                        db       => $dsns->[0]->{D},
6061                                                        tbl      => $dsns->[0]->{t},
6062                                                     };
6063  ***      0             0                           my $dst = {
6064                                                        dsn      => $dsns->[1],
6065                                                        dbh      => $dsns->[1]->{dbh} || get_cxn($dsns->[1], %args),
6066                                                        misc_dbh => get_cxn($dsns->[1], %args),
6067                                                        db       => $dsns->[1]->{D},
6068                                                        tbl      => $dsns->[1]->{t},
6069                                                     };
6070                                                  
6071  ***      0      0                                  if ( $o->get('verbose') ) {
6072  ***      0                                            print "# Lock and rename ", $dp->as_string($src->{dsn}), "\n";
6073  ***      0                                            printf $args{hdr}, @ChangeHandler::ACTIONS,
6074                                                           qw(ALGORITHM EXIT DATABASE TABLE);
6075                                                     }
6076                                                  
6077                                                     # We don't use lock_server() here because it does the usual stuff wrt
6078                                                     # waiting for slaves to catch up to master, etc, etc.
6079  ***      0                                         my $src_db_tbl = $q->quote($src->{db}, $src->{tbl});
6080  ***      0                                         my $dst_db_tbl = $q->quote($dst->{db}, $dst->{tbl});
6081  ***      0                                         my $tmp_db_tbl = $q->quote($src->{db}, $src->{tbl} . "_tmp_$PID");
6082  ***      0                                         my $sql = "LOCK TABLES $src_db_tbl WRITE";
6083  ***      0                                         MKDEBUG && _d($sql);
6084  ***      0                                         $src->{dbh}->do($sql);
6085  ***      0                                         $sql = "LOCK TABLES $dst_db_tbl WRITE";
6086  ***      0                                         MKDEBUG && _d($sql);
6087  ***      0                                         $dst->{dbh}->do($sql);
6088                                                  
6089  ***      0                                         my $exit_status = sync_a_table(
6090                                                        src  => $src,
6091                                                        dst  => $dst,
6092                                                        %args,
6093                                                     );
6094                                                  
6095                                                     # Now rename the tables to swap them.
6096  ***      0                                         $sql = "ALTER TABLE $src_db_tbl RENAME $tmp_db_tbl";
6097  ***      0                                         MKDEBUG && _d($sql);
6098  ***      0                                         $src->{dbh}->do($sql);
6099  ***      0                                         $sql = "ALTER TABLE $dst_db_tbl RENAME $src_db_tbl";
6100  ***      0                                         MKDEBUG && _d($sql);
6101  ***      0                                         $dst->{dbh}->do($sql);
6102  ***      0                                         $sql = "UNLOCK TABLES";
6103  ***      0                                         MKDEBUG && _d($sql);
6104  ***      0                                         $src->{dbh}->do($sql);
6105  ***      0                                         $sql = "ALTER TABLE $tmp_db_tbl RENAME $dst_db_tbl";
6106  ***      0                                         MKDEBUG && _d($sql);
6107  ***      0                                         $src->{dbh}->do($sql);
6108                                                  
6109  ***      0                                         unlock_server(src => $src, dst => $dst, %args);
6110                                                  
6111  ***      0                                         disconnect($src, $dst);
6112  ***      0                                         return $exit_status;
6113                                                  }
6114                                                  
6115                                                  sub sync_one_table {
6116  ***      0                    0                    my ( %args ) = @_;
6117  ***      0                                         my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
6118                                                                            VersionParser);
6119  ***      0                                         foreach my $arg ( @required_args ) {
6120  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6121                                                     }
6122  ***      0                                         my @dsns = @{$args{dsns}};
      ***      0                                      
6123  ***      0                                         my $o    = $args{OptionParser};
6124  ***      0                                         my $dp   = $args{DSNParser};
6125                                                  
6126  ***      0                                         MKDEBUG && _d('DSN has t part; syncing ONE TABLE between servers');
6127  ***      0             0                           my $src = {
6128                                                        dsn      => $dsns[0],
6129                                                        dbh      => $dsns[0]->{dbh} || get_cxn($dsns[0], %args),
6130                                                        misc_dbh => get_cxn($dsns[0], %args),
6131                                                        db       => $dsns[0]->{D},
6132                                                        tbl      => $dsns[0]->{t},
6133                                                     };
6134                                                  
6135  ***      0                                         my $exit_status = 0;
6136  ***      0                                         foreach my $dsn ( @dsns[1 .. $#dsns] ) {
6137  ***      0             0                              my $dst = {
      ***                    0                        
      ***                    0                        
6138                                                           dsn      => $dsn,
6139                                                           dbh      => $dsn->{dbh} || get_cxn($dsn, %args),
6140                                                           misc_dbh => get_cxn($dsn, %args),
6141                                                           db       => $dsn->{D} || $src->{db},
6142                                                           tbl      => $dsn->{t} || $src->{tbl},
6143                                                        };
6144                                                  
6145  ***      0      0                                     if ( $o->get('verbose') ) {
6146  ***      0      0                                        print "# Syncing ", $dp->as_string($dsn),
6147                                                              ($o->get('dry-run') ? ' in dry-run mode, without accessing or '
6148                                                                 . 'comparing data' : '') , "\n";
6149  ***      0                                               printf $args{hdr}, @ChangeHandler::ACTIONS,
6150                                                              qw(ALGORITHM EXIT DATABASE TABLE);
6151                                                        }
6152                                                  
6153  ***      0                                            lock_server(src => $src, dst => $dst, %args);
6154                                                  
6155  ***      0                                            $exit_status |= sync_a_table(
6156                                                           src   => $src,
6157                                                           dst   => $dst,
6158                                                           %args,
6159                                                        );
6160                                                  
6161  ***      0                                            unlock_server(src => $src, dst => $dst, %args);
6162  ***      0                                            disconnect($dst);
6163                                                     }
6164                                                  
6165  ***      0                                         disconnect($src);
6166  ***      0                                         return $exit_status;
6167                                                  }
6168                                                  
6169                                                  sub sync_via_replication {
6170  ***      0                    0                    my ( %args ) = @_;
6171  ***      0                                         my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
6172                                                                            VersionParser TableChecksum MasterSlave);
6173  ***      0                                         foreach my $arg ( @required_args ) {
6174  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6175                                                     }
6176  ***      0                                         my $dsns     = $args{dsns};
6177  ***      0                                         my $o        = $args{OptionParser};
6178  ***      0                                         my $dp       = $args{DSNParser};
6179  ***      0                                         my $q        = $args{Quoter};
6180  ***      0                                         my $checksum = $args{TableChecksum};
6181  ***      0                                         my $ms       = $args{MasterSlave};
6182                                                  
6183  ***      0                                         MKDEBUG && _d('Syncing via replication');
6184  ***      0             0                           my $src = {
6185                                                        dsn      => $dsns->[0],
6186                                                        dbh      => $dsns->[0]->{dbh} || get_cxn($dsns->[0], %args),
6187                                                        misc_dbh => get_cxn($dsns->[0], %args),
6188                                                        db       => undef,  # set later
6189                                                        tbl      => undef,  # set later
6190                                                     };
6191                                                  
6192                                                     # Filters for --databases and --tables.  We have to do these manually
6193                                                     # since we don't use MySQLFind for --replicate.
6194  ***      0                                         my $databases = $o->get('databases');
6195  ***      0                                         my $tables    = $o->get('tables');
6196                                                  
6197  ***      0                                         my $exit_status = 0;
6198                                                  
6199                                                     # Connect to the master and treat it as the source, then find
6200                                                     # differences on the slave and sync them.
6201  ***      0      0                                  if ( $o->get('sync-to-master') ) {
6202  ***      0             0                              my $dst = {
6203                                                           dsn      => $dsns->[1],
6204                                                           dbh      => $dsns->[1]->{dbh} || get_cxn($dsns->[1], %args),
6205                                                           misc_dbh => get_cxn($dsns->[1], %args),
6206                                                           db       => undef,  # set later
6207                                                           tbl      => undef,  # set later
6208                                                        };
6209                                                  
6210                                                        # First, check that the master (source) has no discrepancies itself,
6211                                                        # and ignore tables that do.
6212  ***      0                                            my %skip_table;
6213  ***      0                                            map { $skip_table{$_->{db}}->{$_->{tbl}}++ }
      ***      0                                      
6214                                                           $checksum->find_replication_differences(
6215                                                              $src->{dbh}, $o->get('replicate'));
6216                                                  
6217                                                        # Now check the slave for differences and sync them if necessary.
6218  ***      0                                            my @diffs =  filter_diffs(
6219                                                           \%skip_table,
6220                                                           $databases,
6221                                                           $tables,
6222                                                           $checksum->find_replication_differences(
6223                                                              $dst->{dbh}, $o->get('replicate'))
6224                                                        );
6225                                                  
6226  ***      0      0                                     if ( $o->get('verbose') ) {
6227  ***      0      0                                        print "# Syncing via replication ", $dp->as_string($dst->{dsn}),
6228                                                              ($o->get('dry-run') ? ' in dry-run mode, without accessing or '
6229                                                                 . 'comparing data' : '') , "\n";
6230  ***      0                                               printf $args{hdr}, @ChangeHandler::ACTIONS,
6231                                                              qw(ALGORITHM EXIT DATABASE TABLE);
6232                                                        }
6233                                                  
6234  ***      0      0                                     if ( @diffs ) {
6235  ***      0                                               lock_server(src => $src, dst => $dst, %args);
6236                                                  
6237  ***      0                                               foreach my $diff ( @diffs ) {
6238  ***      0                                                  $src->{db}  = $dst->{db}  = $diff->{db};
6239  ***      0                                                  $src->{tbl} = $dst->{tbl} = $diff->{tbl};
6240                                                  
6241  ***      0                                                  $exit_status |= sync_a_table(
6242                                                                 src   => $src,
6243                                                                 dst   => $dst,
6244                                                                 where => $diff->{boundaries},
6245                                                                 %args,
6246                                                              );
6247                                                           }
6248                                                  
6249  ***      0                                               unlock_server(src => $src, dst => $dst, %args);
6250                                                        }
6251                                                        else {
6252  ***      0                                               MKDEBUG && _d('No checksum differences');
6253                                                        }
6254                                                  
6255  ***      0                                            disconnect($dst);
6256                                                     } # sync-to-master
6257                                                  
6258                                                     # The DSN is the master.  Connect to each slave, find differences,
6259                                                     # then sync them.
6260                                                     else {
6261  ***      0                                            my %skip_table;
6262                                                        $ms->recurse_to_slaves(
6263                                                           {  dbh        => $src->{dbh},
6264                                                              dsn        => $src->{dsn},
6265                                                              dsn_parser => $dp,
6266                                                              recurse    => 1,
6267                                                              callback   => sub {
6268  ***      0                    0                                my ( $dsn, $dbh, $level, $parent ) = @_;
6269  ***      0                                                     my @diffs = $checksum
6270                                                                    ->find_replication_differences($dbh, $o->get('replicate'));
6271  ***      0      0                                              if ( !$level ) {
6272                                                                    # This is the master; don't sync any tables that are wrong
6273                                                                    # here, for obvious reasons.
6274  ***      0                                                        map { $skip_table{$_->{db}}->{$_->{tbl}}++ } @diffs;
      ***      0                                      
6275                                                                 }
6276                                                                 else {
6277                                                                    # This is a slave.
6278  ***      0                                                        @diffs = filter_diffs(
6279                                                                       \%skip_table,
6280                                                                       $databases,
6281                                                                       $tables,
6282                                                                       @diffs
6283                                                                    );
6284                                                  
6285  ***      0      0                                                 if ( $o->get('verbose') ) {
6286  ***      0      0                                                    print "# Syncing via replication ", $dp->as_string($dsn),
6287                                                                          ($o->get('dry-run') ? ' in dry-run mode, without '
6288                                                                             . 'accessing or comparing data' : '') , "\n";
6289  ***      0                                                           printf $args{hdr}, @ChangeHandler::ACTIONS,
6290                                                                          qw(ALGORITHM EXIT DATABASE TABLE);
6291                                                                    }
6292                                                  
6293  ***      0      0                                                 if ( @diffs ) {
6294  ***      0                                                           my $dst = {
6295                                                                          dsn      => $dsn,
6296                                                                          dbh      => $dbh,
6297                                                                          misc_dbh => get_cxn($dsn, %args),
6298                                                                          db       => undef,  # set later
6299                                                                          tbl      => undef,  # set later
6300                                                                       };
6301                                                  
6302  ***      0                                                           lock_server(src => $src, dst => $dst, %args);
6303                                                  
6304  ***      0                                                           foreach my $diff ( @diffs ) {
6305  ***      0                                                              $src->{db}  = $dst->{db}  = $diff->{db};
6306  ***      0                                                              $src->{tbl} = $dst->{tbl} = $diff->{tbl};
6307                                                  
6308  ***      0                                                              $exit_status |= sync_a_table(
6309                                                                             src   => $src,
6310                                                                             dst   => $dst,
6311                                                                             where => $diff->{boundaries},
6312                                                                             %args,
6313                                                                          );
6314                                                                       } 
6315                                                  
6316  ***      0                                                           unlock_server(src => $src, dst => $dst, %args);
6317  ***      0                                                           disconnect($dst);
6318                                                                    }
6319                                                                    else {
6320  ***      0                                                           MKDEBUG && _d('No checksum differences');
6321                                                                    }
6322                                                                 }  # this is a slave
6323                                                  
6324  ***      0                                                     return;
6325                                                              },  # recurse_to_slaves() callback
6326  ***      0                                                  method => $o->get('recursion-method'),
6327                                                           },
6328                                                        );
6329                                                     } # DSN is master
6330                                                  
6331  ***      0                                         disconnect($src);
6332  ***      0                                         return $exit_status;
6333                                                  }
6334                                                  
6335                                                  sub sync_all {
6336  ***      0                    0                    my ( %args ) = @_;
6337  ***      0                                         my @required_args = qw(dsns plugins hdr OptionParser DSNParser Quoter
6338                                                                            VersionParser TableParser MySQLDump);
6339  ***      0                                         foreach my $arg ( @required_args ) {
6340  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6341                                                     }
6342  ***      0                                         my @dsns = @{$args{dsns}};
      ***      0                                      
6343  ***      0                                         my $o    = $args{OptionParser};
6344  ***      0                                         my $dp   = $args{DSNParser};
6345                                                  
6346  ***      0                                         MKDEBUG && _d('Syncing all dbs and tbls');
6347  ***      0             0                           my $src = {
6348                                                        dsn      => $dsns[0],
6349                                                        dbh      => $dsns[0]->{dbh} || get_cxn($dsns[0], %args),
6350                                                        misc_dbh => get_cxn($dsns[0], %args),
6351                                                        db       => undef,  # set later
6352                                                        tbl      => undef,  # set later
6353                                                     };
6354                                                  
6355  ***      0                                         my $si = new SchemaIterator(
6356                                                        Quoter => $args{Quoter},
6357                                                     );
6358  ***      0                                         $si->set_filter($si->make_filter($o));
6359                                                  
6360                                                     # Make a list of all dbs.tbls on the source.  It's more efficient this
6361                                                     # way because it avoids open/closing a dbh for each tbl and dsn, unless
6362                                                     # we pre-opened the dsn.  It would also cause confusing verbose output.
6363  ***      0                                         my @dbs_tbls;
6364  ***      0                                         my $next_db = $si->get_db_itr(dbh => $src->{dbh});
6365  ***      0                                         while ( my $db = $next_db->() ) {
6366  ***      0                                            MKDEBUG && _d('Getting tables from', $db);
6367  ***      0                                            my $next_tbl = $si->get_tbl_itr(
6368                                                           dbh   => $src->{dbh},
6369                                                           db    => $db,
6370                                                           views => 0,
6371                                                        );
6372  ***      0                                            while ( my $tbl = $next_tbl->() ) {
6373  ***      0                                               MKDEBUG && _d('Got table', $tbl);
6374  ***      0                                               push @dbs_tbls, { db => $db, tbl => $tbl };
6375                                                        }
6376                                                     }
6377                                                  
6378  ***      0                                         my $exit_status = 0;
6379  ***      0                                         foreach my $dsn ( @dsns[1 .. $#dsns] ) {
6380  ***      0      0                                     if ( $o->get('verbose') ) {
6381  ***      0      0                                        print "# Syncing ", $dp->as_string($dsn),
6382                                                              ($o->get('dry-run') ? ' in dry-run mode, without accessing or '
6383                                                                 . 'comparing data' : '') , "\n";
6384  ***      0                                               printf $args{hdr}, @ChangeHandler::ACTIONS,
6385                                                              qw(ALGORITHM EXIT DATABASE TABLE);
6386                                                        }
6387                                                  
6388  ***      0             0                              my $dst = {
6389                                                           dsn      => $dsn,
6390                                                           dbh      => $dsn->{dbh} || get_cxn($dsn, %args),
6391                                                           misc_dbh => get_cxn($dsn, %args),
6392                                                           db       => undef,  # set later
6393                                                           tbl      => undef,  # set later
6394                                                        };
6395                                                  
6396  ***      0                                            lock_server(src => $src, dst => $dst, %args);
6397                                                  
6398  ***      0                                            foreach my $db_tbl ( @dbs_tbls ) {
6399  ***      0                                               $src->{db}  = $dst->{db}  = $db_tbl->{db};
6400  ***      0                                               $src->{tbl} = $dst->{tbl} = $db_tbl->{tbl};
6401                                                  
6402  ***      0                                               $exit_status |= sync_a_table(
6403                                                              src => $src,
6404                                                              dst => $dst,
6405                                                              %args,
6406                                                           );
6407                                                        }
6408                                                  
6409  ***      0                                            unlock_server(src => $src, dst => $dst, %args);
6410  ***      0                                            disconnect($dst);
6411                                                     }
6412                                                  
6413  ***      0                                         disconnect($src);
6414  ***      0                                         return $exit_status;
6415                                                  }
6416                                                  
6417                                                  sub lock_server {
6418  ***      0                    0                    my ( %args ) = @_;
6419  ***      0                                         foreach my $arg ( qw(src dst OptionParser DSNParser TableSyncer) ) {
6420  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6421                                                     }
6422  ***      0                                         my $o = $args{OptionParser};
6423                                                  
6424  ***      0      0      0                           return unless $o->get('lock') && $o->get('lock') == 3;
6425                                                  
6426  ***      0                                         eval {
6427  ***      0                                            $args{TableSyncer}->lock_and_wait(
6428                                                           %args,
6429                                                           lock         => 3,
6430                                                           lock_level   => 3,
6431                                                           replicate    => $o->get('replicate'),
6432                                                           timeout_ok   => $o->get('timeout-ok'),
6433                                                           transaction  => $o->get('transaction'),
6434                                                           wait         => $o->get('wait'),
6435                                                        );
6436                                                     };
6437  ***      0      0                                  if ( $EVAL_ERROR ) {
6438  ***      0                                            die "Failed to lock server: $EVAL_ERROR";
6439                                                     }
6440  ***      0                                         return;
6441                                                  }
6442                                                  
6443                                                  sub unlock_server {
6444  ***      0                    0                    my ( %args ) = @_;
6445  ***      0                                         my @required_args = qw(src dst OptionParser DSNParser TableSyncer);
6446  ***      0                                         foreach my $arg ( @required_args ) {
6447  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6448                                                     }
6449  ***      0                                         my ($src, $dst, $o) = @args{@required_args};
6450                                                  
6451  ***      0      0      0                           return unless $o->get('lock') && $o->get('lock') == 3;
6452                                                  
6453  ***      0                                         eval {
6454                                                        # Open connections as needed.
6455  ***      0             0                              $src->{dbh}      ||= get_cxn($src->{dsn}, %args);
6456  ***      0             0                              $dst->{dbh}      ||= get_cxn($dst->{dsn}, %args);
6457  ***      0             0                              $src->{misc_dbh} ||= get_cxn($src->{dsn}, %args);
6458  ***      0             0                              $args{TableSyncer}->unlock(
      ***                    0                        
      ***                    0                        
      ***                    0                        
6459                                                           src_dbh      => $src->{dbh},
6460                                                           src_db       => '',
6461                                                           src_tbl      => '',
6462                                                           dst_dbh      => $dst->{dbh},
6463                                                           dst_db       => '',
6464                                                           dst_tbl      => '',
6465                                                           misc_dbh     => $src->{misc_dbh},
6466                                                           replicate    => $o->get('replicate')   || 0,
6467                                                           timeout_ok   => $o->get('timeout-ok')  || 0,
6468                                                           transaction  => $o->get('transaction') || 0,
6469                                                           wait         => $o->get('wait')        || 0,
6470                                                           lock         => 3,
6471                                                           lock_level   => 3,
6472                                                        );
6473                                                     };
6474  ***      0      0                                  if ( $EVAL_ERROR ) {
6475  ***      0                                            die "Failed to unlock server: $EVAL_ERROR";
6476                                                     }
6477  ***      0                                         return;
6478                                                  }
6479                                                  
6480                                                  # This is the primary subroutine which actually makes the table syncs
6481                                                  # happen by calling $syncer->sync_table().  It is, therefore, a big
6482                                                  # wrapper around $syncer->sync_table(); it does pre- and post-sync
6483                                                  # stuff.  It returns an exit status; see EXIT STATUS in the POD.
6484                                                  sub sync_a_table {
6485  ***      0                    0                    my ( %args ) = @_;
6486  ***      0                                         my @required_args = qw(src dst plugins OptionParser Quoter TableParser
6487                                                                            MySQLDump TableSyncer);
6488  ***      0                                         foreach my $arg ( @required_args ) {
6489  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6490                                                     }
6491  ***      0                                         my ($src, $dst, undef, $o, $q, $tp, $du, $syncer) = @args{@required_args};
6492                                                  
6493  ***      0                                         my $exit_status = 0; 
6494  ***      0                                         my %status;
6495  ***      0                                         eval {
6496                                                        # This will either die if there's a problem or return the tbl struct.
6497  ***      0                                            my $tbl_struct = ok_to_sync($src, $dst, %args);
6498                                                  
6499                                                        # If the table is InnoDB, prefer to sync it with transactions, unless
6500                                                        # the user explicitly said not to.
6501  ***      0      0                                     my $use_txn = $o->got('transaction')            ? $o->get('transaction')
      ***             0                               
6502                                                                    : $tbl_struct->{engine} eq 'InnoDB' ? 1
6503                                                                    :                                     0;
6504                                                  
6505                                                        # Turn off AutoCommit if we're using transactions.
6506  ***      0                                            $src->{dbh}->{AutoCommit}      = !$use_txn;
6507  ***      0                                            $src->{misc_dbh}->{AutoCommit} = !$use_txn;
6508  ***      0                                            $dst->{dbh}->{AutoCommit}      = !$use_txn;
6509  ***      0                                            $dst->{misc_dbh}->{AutoCommit} = !$use_txn;
6510                                                  
6511                                                        # Determine which columns to compare.
6512  ***      0                                            my $ignore_columns  = $o->get('ignore-columns');
6513  ***      0                                            my @compare_columns = grep {
6514  ***      0      0                                        !$ignore_columns->{lc $_};
6515  ***      0                                            } @{$o->get('columns') || $tbl_struct->{cols}};
6516                                                  
6517                                                        # --print --verbose --verbose is the magic formula for having
6518                                                        # all src/dst sql printed so we can see the chunk/row sql.
6519  ***      0                                            my $callback;
6520  ***      0      0      0                              if ( $o->get('print') && $o->get('verbose') >= 2 ) {
6521  ***      0                                               $callback = \&print_sql;
6522                                                        }
6523                                                  
6524                                                        # get_change_dbh() may die if, for example, the destination is
6525                                                        # not a slave.  Perhaps its work should be part of can_sync()?
6526  ***      0                                            my $change_dbh = get_change_dbh(tbl_struct => $tbl_struct, %args);
6527  ***      0                                            my $actions    = make_action_subs(change_dbh => $change_dbh, %args);
6528                                                  
6529  ***      0                                            my $rd = new RowDiff(dbh => $src->{misc_dbh});
6530  ***      0      0      0                              my $ch = new ChangeHandler(
      ***                    0                        
      ***                    0                        
6531                                                           src_db     => $src->{db},
6532                                                           src_tbl    => $src->{tbl},
6533                                                           dst_db     => $dst->{db},
6534                                                           dst_tbl    => $dst->{tbl}, 
6535                                                           tbl_struct => $tbl_struct,
6536                                                           queue      => $o->get('buffer-to-client') ? 1 : 0,
6537                                                           replace    => $o->get('replace') || $o->get('replicate')
6538                                                                         || $o->get('sync-to-master') || 0,
6539                                                           actions    => $actions,
6540                                                           Quoter     => $args{Quoter},
6541                                                        );
6542                                                  
6543  ***      0             0                              %status = $syncer->sync_table(
      ***                    0                        
6544                                                           %args,
6545                                                           tbl_struct        => $tbl_struct,
6546                                                           cols              => \@compare_columns,
6547                                                           chunk_size        => $o->get('chunk-size'),
6548                                                           RowDiff           => $rd,
6549                                                           ChangeHandler     => $ch,
6550                                                           transaction       => $use_txn,
6551                                                           callback          => $callback,
6552                                                           where             => $args{where} || $o->get('where'),
6553                                                           buffer_in_mysql   => $o->get('buffer-in-mysql'),
6554                                                           buffer_to_client  => $o->get('buffer-to-client'),
6555                                                           changing_src      => $o->get('replicate') || $o->get('sync-to-master'),
6556                                                           float_precision   => $o->get('float-precision'),
6557                                                           index_hint        => $o->get('index-hint'),
6558                                                           chunk_index       => $o->get('chunk-index'),
6559                                                           chunk_col         => $o->get('chunk-column'),
6560                                                           lock              => $o->get('lock'),
6561                                                           replace           => $o->get('replace'),
6562                                                           replicate         => $o->get('replicate'),
6563                                                           dry_run           => $o->get('dry-run'),
6564                                                           timeout_ok        => $o->get('timeout-ok'),
6565                                                           trim              => $o->get('trim'),
6566                                                           wait              => $o->get('wait'),
6567                                                           function          => $o->get('function'),
6568                                                        );
6569                                                  
6570  ***      0      0                                     if ( sum(@status{@ChangeHandler::ACTIONS}) ) {
6571  ***      0                                               $exit_status |= 2;
6572                                                        }
6573                                                     };
6574                                                  
6575  ***      0      0                                  if ( $EVAL_ERROR ) {
6576  ***      0                                            print_err($EVAL_ERROR, $dst->{db}, $dst->{tbl}, $dst->{dsn}->{h});
6577  ***      0                                            $exit_status |= 1;
6578                                                     }
6579                                                  
6580                                                     # Print this last so that the exit status is its final result.
6581  ***      0      0                                  if ( $o->get('verbose') ) {
6582  ***      0      0                                     printf($args{hdr},
6583  ***      0                                               map { $_ || '0' } @status{@ChangeHandler::ACTIONS, 'ALGORITHM'},
6584                                                           $exit_status, $src->{db}, $src->{tbl});
6585                                                     }
6586                                                  
6587  ***      0                                         return $exit_status;
6588                                                  }
6589                                                  
6590                                                  sub get_change_dbh {
6591  ***      0                    0                    my ( %args ) = @_;
6592  ***      0                                         my @required_args = qw(src dst tbl_struct OptionParser DSNParser
6593                                                                            MasterSlave);
6594  ***      0                                         foreach my $arg ( @required_args ) {
6595  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6596                                                     }
6597  ***      0                                         my ($src, $dst, $tbl_struct, $o, $dp, $ms) = @args{@required_args};
6598                                                  
6599  ***      0                                         my $change_dbh = $dst->{dbh};  # The default case: making changes on dst.
6600                                                  
6601  ***      0      0      0                           if ( $o->get('sync-to-master') || $o->get('replicate') ) {
      ***             0                               
6602                                                        # Is it possible to make changes on the master (i.e. the source)?
6603                                                        # Only if REPLACE will work.
6604  ***      0                                            my $can_replace = grep { $_->{is_unique} } values %{$tbl_struct->{keys}};
      ***      0                                      
      ***      0                                      
6605  ***      0                                            MKDEBUG && _d("This table's replace-ability:", $can_replace);
6606  ***      0      0                                     die "Can't make changes on the master because no unique index exists"
6607                                                           unless $can_replace;
6608  ***      0                                            $change_dbh = $src->{dbh};  # The alternate case.
6609  ***      0                                            MKDEBUG && _d('Will make changes on source', $change_dbh);
6610                                                     }
6611                                                     elsif ( $o->get('check-slave') ) {
6612                                                        # Is it safe to change data on the destination?  Only if it's *not*
6613                                                        # a slave.  We don't change tables on slaves directly.  If we are
6614                                                        # forced to change data on a slave, we require either that 1) binary
6615                                                        # logging is disabled, or 2) the check is bypassed.  By the way, just
6616                                                        # because the server is a slave doesn't mean it's not also the master
6617                                                        # of the master (master-master replication).
6618  ***      0                                            my $slave_status = $ms->get_slave_status($dst->{dbh});
6619  ***      0                                            my (undef, $log_bin) = $dst->{dbh}->selectrow_array(
6620                                                           'SHOW VARIABLES LIKE "log_bin"');
6621  ***      0                                            my ($sql_log_bin) = $dst->{dbh}->selectrow_array(
6622                                                           'SELECT @@SQL_LOG_BIN');
6623  ***      0                                            MKDEBUG && _d('Variables on destination:',
6624                                                           'log_bin=', (defined $log_bin ? $log_bin : 'NULL'),
6625                                                           ' @@SQL_LOG_BIN=', (defined $sql_log_bin ? $sql_log_bin : 'NULL'));
6626  ***      0      0      0                              if ( $slave_status && $sql_log_bin && ($log_bin || 'OFF') eq 'ON' ) {
      ***                    0                        
      ***                    0                        
6627  ***      0                                               die "Can't make changes on ", $dp->as_string($dst->{dsn}),
6628                                                              " because it's a slave.  See the documentation section",
6629                                                              " 'REPLICATION SAFETY' for solutions to this problem.";
6630                                                        }
6631  ***      0                                            MKDEBUG && _d('Will make changes on destination', $change_dbh);
6632                                                     }
6633                                                  
6634  ***      0                                         return $change_dbh;
6635                                                  }
6636                                                  
6637                                                  sub make_action_subs {
6638  ***      0                    0                    my ( %args ) = @_;
6639  ***      0                                         my @required_args = qw(change_dbh OptionParser);
6640  ***      0                                         foreach my $arg ( @required_args ) {
6641  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6642                                                     }
6643  ***      0                                         my ($change_dbh, $o) = @args{@required_args};
6644                                                  
6645  ***      0                                         my @actions;
6646  ***      0      0                                  if ( $o->get('execute') ) {
6647                                                        push @actions, sub {
6648  ***      0                                               map {
6649  ***      0                    0                             MKDEBUG && _d('About to execute:', $_);
6650  ***      0                                                  $change_dbh->do($_);
6651                                                           } @_;
6652  ***      0                                            };
6653                                                     }
6654  ***      0      0                                  if ( $o->get('print') ) {
6655                                                        # Print AFTER executing, so the print isn't misleading in case of an
6656                                                        # index violation etc that doesn't actually get executed.
6657                                                        push @actions, sub { 
6658  ***      0      0             0                          print(@_, ";\n") or die "Cannot print: $OS_ERROR"
6659  ***      0                                            };
6660                                                     }
6661                                                  
6662  ***      0                                         return \@actions;
6663                                                  }
6664                                                  
6665                                                  # Tries to extract the MySQL error message and print it
6666                                                  sub print_err {
6667  ***      0                    0                    my ( $msg, $database, $table, $host ) = @_;
6668  ***      0      0                                  return if !defined $msg;
6669  ***      0                                         $msg =~ s/^.*?failed: (.*?) at \S+ line (\d+).*$/$1 at line $2/s;
6670  ***      0                                         $msg =~ s/\s+/ /g;
6671  ***      0      0      0                           if ( $database && $table ) {
6672  ***      0                                            $msg .= " while doing $database.$table";
6673                                                     }
6674  ***      0      0                                  if ( $host ) {
6675  ***      0                                            $msg .= " on $host";
6676                                                     }
6677  ***      0                                         print STDERR $msg, "\n";
6678                                                  }
6679                                                  
6680                                                  sub get_cxn {
6681  ***      0                    0                    my ( $dsn, %args ) = @_;
6682  ***      0                                         my @required_args = qw(OptionParser DSNParser);
6683  ***      0                                         foreach my $arg ( @required_args ) {
6684  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6685                                                     }
6686  ***      0                                         my ($o, $dp) = @args{@required_args};
6687                                                  
6688  ***      0      0      0                           if ( !$dsn->{p} && $o->get('ask-pass') ) {
6689  ***      0                                            $dsn->{p} = OptionParser::prompt_noecho("Enter password for $dsn->{h}: ");
6690                                                     }
6691  ***      0                                         my $dbh = $dp->get_dbh(
6692                                                        $dp->get_cxn_params($dsn, {})  # get_cxn_params needs the 2nd arg
6693                                                     );
6694                                                  
6695  ***      0                                         my $sql;
6696  ***      0      0                                  if ( !$o->get('bin-log') ) {
6697  ***      0                                            $sql = "/*!32316 SET SQL_LOG_BIN=0 */";
6698  ***      0                                            MKDEBUG && _d($dbh, $sql);
6699  ***      0                                            $dbh->do($sql);
6700                                                     }
6701  ***      0      0                                  if ( !$o->get('unique-checks') ) {
6702  ***      0                                            $sql = "/*!40014 SET UNIQUE_CHECKS=0 */";
6703  ***      0                                            MKDEBUG && _d($dbh, $sql);
6704  ***      0                                            $dbh->do($sql);
6705                                                     }
6706  ***      0      0                                  if ( !$o->get('foreign-key-checks') ) {
6707  ***      0                                            $sql = "/*!40014 SET FOREIGN_KEY_CHECKS=0 */";
6708  ***      0                                            MKDEBUG && _d($dbh, $sql);
6709  ***      0                                            $dbh->do($sql);
6710                                                     }
6711                                                     # Disable auto-increment on zero (bug #1919897).
6712  ***      0                                         $sql = '/*!40101 SET @@SQL_MODE := CONCAT(@@SQL_MODE, '
6713                                                          . '",NO_AUTO_VALUE_ON_ZERO")*/';
6714  ***      0                                         MKDEBUG && _d($dbh, $sql);
6715  ***      0                                         $dbh->do($sql);
6716                                                  
6717  ***      0                                         MKDEBUG && _d('Opened dbh', $dbh);
6718  ***      0                                         return $dbh;
6719                                                  }
6720                                                  
6721                                                  sub ok_to_sync {
6722  ***      0                    0                    my ( %args ) = @_;
6723  ***      0                                         my @required_args = qw(src dst DSNParser Quoter VersionParser TableParser
6724                                                                            MySQLDump TableSyncer OptionParser);
6725  ***      0                                         foreach my $arg ( @required_args ) {
6726  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6727                                                     }
6728  ***      0                                         my ($src, $dst, $dp, $q, $vp, $tp, $du, $syncer, $o) = @args{@required_args};
6729                                                  
6730                                                     # First things first: check that the src and dst dbs and tbls exist.
6731                                                     # This can fail in cases like h=host,D=bad,t=also_bad (i.e. simple
6732                                                     # user error).  It can also fail when syncing all dbs/tbls with sync_all()
6733                                                     # because the dst db/tbl is assumed to be the same as the src but
6734                                                     # this isn't always the case.
6735  ***      0                                         my $src_tbl_ddl;
6736  ***      0                                         eval {
6737                                                        # FYI: get_create_table() does USE db but doesn't eval it.
6738  ***      0                                            $src->{dbh}->do("USE `$src->{db}`");
6739  ***      0                                            $src_tbl_ddl = $du->get_create_table($src->{dbh}, $q,
6740                                                           $src->{db}, $src->{tbl});
6741                                                     };
6742  ***      0      0                                  die $EVAL_ERROR if $EVAL_ERROR;
6743                                                  
6744  ***      0                                         my $dst_tbl_ddl;
6745  ***      0                                         eval {
6746                                                        # FYI: get_create_table() does USE db but doesn't eval it.
6747  ***      0                                            $dst->{dbh}->do("USE `$dst->{db}`");
6748  ***      0                                            $dst_tbl_ddl = $du->get_create_table($dst->{dbh}, $q,
6749                                                           $dst->{db}, $dst->{tbl});
6750                                                     };
6751  ***      0      0                                  die $EVAL_ERROR if $EVAL_ERROR;
6752                                                  
6753                                                     # This doesn't work at the moment when syncing different table names.
6754                                                     # Check that src.db.tbl has the exact same schema as dst.db.tbl.
6755                                                     # if ( $o->get('check-schema') && ($src_tbl_ddl ne $dst_tbl_ddl) ) {
6756                                                     #   die "Source and destination tables have different schemas";
6757                                                     # }
6758  ***      0                                         my $tbl_struct = $tp->parse($src_tbl_ddl);
6759                                                  
6760                                                     # Check that the user has all the necessary privs on the tbls.
6761  ***      0      0                                  if ( $o->get('check-privileges') ) {
6762  ***      0                                            MKDEBUG && _d('Checking privileges');
6763  ***      0      0                                     if ( !$syncer->have_all_privs($src->{dbh}, $src->{db}, $src->{tbl}) ) {
6764  ***      0                                               die "User does not have all necessary privileges on ",
6765                                                              $q->quote($src->{db}, $src->{tbl});
6766                                                        }
6767  ***      0      0                                     if ( !$syncer->have_all_privs($dst->{dbh}, $dst->{db}, $dst->{tbl}) ) {
6768  ***      0                                               die "User does not have all necessary privileges on ",
6769                                                              $q->quote($dst->{db}, $dst->{tbl});
6770                                                        }
6771                                                     }
6772                                                  
6773                                                     # Check that no triggers are defined on the dst tbl.
6774  ***      0      0                                  if ( $o->get('check-triggers') ) {
6775  ***      0                                            MKDEBUG && _d('Checking for triggers');
6776  ***      0      0                                     if ( !defined $dst->{supports_triggers} ) {
6777  ***      0                                               $dst->{supports_triggers} = $vp->version_ge($dst->{dbh}, '5.0.2');
6778                                                        }
6779  ***      0      0      0                              if ( $dst->{supports_triggers}
6780                                                             && $du->get_triggers($dst->{dbh}, $q, $dst->{db}, $dst->{tbl}) ) {
6781  ***      0                                               die "Triggers are defined on the table";
6782                                                        }
6783                                                        else {
6784  ***      0                                               MKDEBUG && _d('Destination does not support triggers',
6785                                                              $dp->as_string($dst->{dsn}));
6786                                                        }
6787                                                     }
6788                                                  
6789  ***      0                                         return $tbl_struct;
6790                                                  }
6791                                                  
6792                                                  sub filter_diffs {
6793  ***      0                    0                    my ( $skip_table, $databases, $tables, @diffs ) = @_;
6794  ***      0      0      0                           return grep {
      ***                    0                        
      ***                    0                        
      ***                    0                        
6795  ***      0                                            !$skip_table->{$_->{db}}->{$_->{tbl}}
6796                                                        && (!$databases || $databases->{$_->{db}})
6797                                                        && (!$tables || ($tables->{$_->{tbl}} || $tables->{"$_->{db}.$_->{tbl}"}))
6798                                                     } @diffs;
6799                                                  }
6800                                                  
6801                                                  sub disconnect {
6802  ***      0                    0                    my ( @hosts ) = @_;
6803  ***      0                                         foreach my $host ( @hosts ) {
6804  ***      0                                            foreach my $thing ( qw(dbh misc_dbh) ) {
6805  ***      0                                               my $dbh = $host->{$thing};
6806  ***      0      0                                        next unless $dbh;
6807  ***      0      0                                        $dbh->commit() unless $dbh->{AutoCommit};
6808  ***      0                                               $dbh->disconnect();
6809  ***      0                                               MKDEBUG && _d('Disconnected dbh', $dbh);
6810                                                        }
6811                                                     }
6812  ***      0                                         return;
6813                                                  }
6814                                                  
6815                                                  # This is passed as the callback for TableSyncer::sync_table()
6816                                                  # if --print --verbose --verbose is specified.
6817                                                  sub print_sql {
6818  ***      0                    0                    my ( $src_sql, $dst_sql ) = @_;
6819  ***      0      0                                  print "# $src_sql\n" if $src_sql;
6820  ***      0      0                                  print "# $dst_sql\n" if $dst_sql;
6821  ***      0                                         return;
6822                                                  }
6823                                                  
6824                                                  sub _d {
6825  ***      0                    0                    my ($package, undef, $line) = caller 0;
6826  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
6827  ***      0                                              map { defined $_ ? $_ : 'undef' }
6828                                                          @_;
6829  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6830                                                  }
6831                                                  
6832                                                  # ############################################################################
6833                                                  # Run the program.
6834                                                  # ############################################################################
6835                                                  if ( !caller ) { exit main(@ARGV); }
6836                                                  
6837                                                  1; # Because this is a module as well as a script.
6838                                                  
6839                                                  # ############################################################################
6840                                                  # Documentation
6841                                                  # ############################################################################
6842                                                  =pod
6843                                                  
6844                                                  =head1 NAME
6845                                                  
6846                                                  mk-table-sync - Synchronize MySQL tables efficiently.
6847                                                  
6848                                                  =head1 SYNOPSIS
6849                                                  
6850                                                  This tool changes data, so for maximum safety, you should back up your data
6851                                                  before you use it.
6852                                                  
6853                                                  To sync db.tbl1 from host1 to host2:
6854                                                  
6855                                                   mk-table-sync --execute u=user,p=pass,h=host1,D=db,t=tbl host2
6856                                                  
6857                                                  Sync all tables in host1 to host2 and host3:
6858                                                  
6859                                                   mk-table-sync --execute host1 host2 host3
6860                                                  
6861                                                  Resolve differences L<mk-table-checksum> found on this master's slaves:
6862                                                  
6863                                                   mk-table-sync --execute --replicate test.checksum master1
6864                                                  
6865                                                  Make slave1 have the same data as its replication master:
6866                                                  
6867                                                   mk-table-sync --execute --sync-to-master slave1
6868                                                  
6869                                                  Ditto, resolving differences L<mk-table-checksum> found:
6870                                                  
6871                                                   mk-table-sync --execute --sync-to-master \
6872                                                     --replicate test.checksum slave1
6873                                                  
6874                                                  Sync server2 in a master-master replication configuration, where server2's copy
6875                                                  of db1.tbl1 is known or suspected to be incorrect:
6876                                                  
6877                                                   mk-table-sync --execute --sync-to-master h=server2,D=db1,t=tbl1
6878                                                  
6879                                                  Note that in the master-master configuration, the following will NOT do what you
6880                                                  want, because it will make changes directly on server2, which will then flow
6881                                                  through replication and change server1's data:
6882                                                  
6883                                                   # Don't do this in a master-master setup!
6884                                                   mk-table-sync --execute h=server1,D=db1,t=tbl1 h=server2
6885                                                  
6886                                                  =head1 RISKS
6887                                                  
6888                                                  The following section is included to inform users about the potential risks,
6889                                                  whether known or unknown, of using this tool.  The two main categories of risks
6890                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
6891                                                  tools) and those created by bugs.
6892                                                  
6893                                                  With great power comes great responsibility!  This tool changes data, so it is a
6894                                                  good idea to back up your data.  It is also very powerful, which means it is
6895                                                  very complex, so you should run it with the L<"--dry-run"> option to see what it
6896                                                  will do, until you're familiar with its operation.  If you want to see which
6897                                                  rows are different, without changing any data, use L<"--print"> instead of
6898                                                  L<"--execute">.  
6899                                                  
6900                                                  Be careful when using mk-table-sync in any master-master setup.  Master-master
6901                                                  replication is inherently tricky, and it's easy to make mistakes.  Yyou need to
6902                                                  be sure you're using the tool correctly for master-master replication.  See the
6903                                                  L<"SYNOPSIS"> for the overview of the correct usage.
6904                                                  
6905                                                  In general, this tool is best suited when your tables have a primary key or
6906                                                  unique index.  Although it can synchronize data in tables lacking a primary key
6907                                                  or unique index, it might be best to sychronize that data by another means.
6908                                                  
6909                                                  At the time of this release, there is a bug that causes invalid SQL when
6910                                                  syncing columns with binary data, and a potential bug using
6911                                                  L<"--lock-and-rename"> with MySQL 5.1.
6912                                                  
6913                                                  The authoritative source for updated information is always the online issue
6914                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
6915                                                  see a list of such issues at the following URL:
6916                                                  L<http://www.maatkit.org/bugs/mk-table-sync>.
6917                                                  
6918                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
6919                                                  
6920                                                  =head1 DESCRIPTION
6921                                                  
6922                                                  B<WARNING> this tool is unfinished and could perform slowly.  The Chunk
6923                                                  algorithm is great when it can be used, and so is Nibble, but otherwise GroupBy
6924                                                  is the default choice and it may not perform very well.  Please run with
6925                                                  L<"--dry-run"> before subjecting your servers to this tool, and make backups of
6926                                                  your data!
6927                                                  
6928                                                  This tool is designed to do one-way synchronization of data (two-way sync is
6929                                                  planned for the future).  It finds differences efficiently with one of several
6930                                                  algorithms (see L<"ALGORITHMS">).  It makes changes on the destination table(s)
6931                                                  so it matches the source.
6932                                                  
6933                                                  It does B<not> synchronize table structures, indexes, or any other schema
6934                                                  changes.  It synchronizes only data.
6935                                                  
6936                                                  It can operate through replication by comparing a slave with its master and
6937                                                  making changes on the master.  These changes will flow through replication and
6938                                                  correct any differences found on the slave.
6939                                                  
6940                                                  It accepts a list of DSNs (see the L<"--help"> output) to tell it where and how
6941                                                  to connect.
6942                                                  
6943                                                  There are many ways to invoke it.  The following is the abbreviated logic:
6944                                                  
6945                                                     if DSN has a t part, sync only that table:
6946                                                        if 1 DSN:
6947                                                           if --sync-to-master:
6948                                                              The DSN is a slave.  Connect to its master and sync.
6949                                                        if more than 1 DSN:
6950                                                           The first DSN is the source.  Sync each DSN in turn.
6951                                                     else if --replicate:
6952                                                        if --sync-to-master:
6953                                                           The DSN is a slave.  Connect to its master, find records
6954                                                           of differences, and fix.
6955                                                        else:
6956                                                           The DSN is the master.  Find slaves and connect to each,
6957                                                           find records of differences, and fix.
6958                                                     else:
6959                                                        if only 1 DSN and --sync-to-master:
6960                                                           The DSN is a slave.  Connect to its master, find tables and
6961                                                           filter with --databases etc, and sync each table to the master.
6962                                                        else:
6963                                                           find tables, filtering with --databases etc, and sync each
6964                                                           DSN to the first.
6965                                                  
6966                                                  If you're confused about how it the DSNs are interpreted, use the
6967                                                  L<"--explain-hosts"> option and it will tell you.
6968                                                  
6969                                                  =head1 OUTPUT
6970                                                  
6971                                                  If you specify the L<"--verbose"> option, you'll see information about the 
6972                                                  differences between the tables.  There is one row per table.  Each server is
6973                                                  printed separately.  For example,
6974                                                  
6975                                                     # Syncing h=host1,D=test,t=test1
6976                                                     # DELETE REPLACE INSERT UPDATE ALGORITHM EXIT DATABASE.TABLE
6977                                                     #      0       0      3      0 Chunk     2    test.test1
6978                                                  
6979                                                  Table test.test1 on host1 required 3 C<INSERT> statements to synchronize
6980                                                  and it used the Chunk algorithm (see L<"ALGORITHMS">).  Because differences were
6981                                                  found, its L<"EXIT STATUS"> was 2.
6982                                                  
6983                                                  If you specify the L<"--print"> option, you'll see the actual SQL statements
6984                                                  that the script uses to synchronize the table if L<"--execute"> is also
6985                                                  specified.
6986                                                  
6987                                                  If you want to see the SQL statements that mk-table-sync is using to select
6988                                                  chunks, nibbles, rows, etc., then specify L<"--print"> once and L<"--verbose">
6989                                                  twice.  Be careful though: this can print a lot of SQL statements.
6990                                                  
6991                                                  There are cases where no combination of C<INSERT>, C<UPDATE> or C<DELETE>
6992                                                  statements can resolve differences without violating some unique key.  For
6993                                                  example, suppose there's a primary key on column a and a unique key on column b.
6994                                                  Then there is no way to sync these two tables with straightforward UPDATE
6995                                                  statements:
6996                                                  
6997                                                   +---+---+  +---+---+
6998                                                   | a | b |  | a | b |
6999                                                   +---+---+  +---+---+
7000                                                   | 1 | 2 |  | 1 | 1 |
7001                                                   | 2 | 1 |  | 2 | 2 |
7002                                                   +---+---+  +---+---+
7003                                                  
7004                                                  The tool rewrites queries to C<DELETE> and C<REPLACE> in this case.  This is
7005                                                  automatically handled after the first index violation, so you don't have to
7006                                                  worry about it.
7007                                                  
7008                                                  =head1 REPLICATION SAFETY
7009                                                  
7010                                                  Synchronizing a replication master and slave safely is a non-trivial problem, in
7011                                                  general.  There are all sorts of issues to think about, such as other processes
7012                                                  changing data, trying to change data on the slave, whether the destination and
7013                                                  source are a master-master pair, and much more.
7014                                                  
7015                                                  In general, the safe way to do it is to change the data on the master, and let
7016                                                  the changes flow through replication to the slave like any other changes.
7017                                                  However, this works only if it's possible to REPLACE into the table on the
7018                                                  master.  REPLACE works only if there's a unique index on the table (otherwise it
7019                                                  just acts like an ordinary INSERT).
7020                                                  
7021                                                  If your table has unique keys, you should use the L<"--sync-to-master"> and/or
7022                                                  L<"--replicate"> options to sync a slave to its master.  This will generally do
7023                                                  the right thing.  When there is no unique key on the table, there is no choice
7024                                                  but to change the data on the slave, and mk-table-sync will detect that you're
7025                                                  trying to do so.  It will complain and die unless you specify
7026                                                  C<--no-check-slave> (see L<"--[no]check-slave">).
7027                                                  
7028                                                  If you're syncing a table without a primary or unique key on a master-master
7029                                                  pair, you must change the data on the destination server.  Therefore, you need
7030                                                  to specify C<--no-bin-log> for safety (see L<"--[no]bin-log">).  If you don't,
7031                                                  the changes you make on the destination server will replicate back to the
7032                                                  source server and change the data there!
7033                                                  
7034                                                  The generally safe thing to do on a master-master pair is to use the
7035                                                  L<"--sync-to-master"> option so you don't change the data on the destination
7036                                                  server.  You will also need to specify C<--no-check-slave> to keep
7037                                                  mk-table-sync from complaining that it is changing data on a slave.
7038                                                  
7039                                                  =head1 ALGORITHMS
7040                                                  
7041                                                  This tool has a generic data-syncing framework, within which it is possible to
7042                                                  use any number of different algorithms to actually find differences.  It chooses
7043                                                  the best algorithm automatically.  While I plan to add more algorithms in the
7044                                                  future, the following are implemented now:
7045                                                  
7046                                                  =over
7047                                                  
7048                                                  =item Chunk
7049                                                  
7050                                                  Finds an index whose first column is numeric (including date and time types),
7051                                                  and divides the column's range of values into chunks of approximately
7052                                                  L<"--chunk-size"> rows.  Syncs a chunk at a time by checksumming the entire
7053                                                  chunk.  If the chunk differs on the source and destination, checksums each
7054                                                  chunk's rows individually to find the rows that differ.
7055                                                  
7056                                                  It is efficient when the column has sufficient cardinality to make the chunks
7057                                                  end up about the right size.
7058                                                  
7059                                                  The initial per-chunk checksum is quite small and results in minimal network
7060                                                  traffic and memory consumption.  If a chunk's rows must be examined, only the
7061                                                  primary key columns and a checksum are sent over the network, not the entire
7062                                                  row.  If a row is found to be different, the entire row will be fetched, but not
7063                                                  before.
7064                                                  
7065                                                  =item Nibble
7066                                                  
7067                                                  Finds an index and ascends the index in fixed-size nibbles of L<"--chunk-size">
7068                                                  rows, using a non-backtracking algorithm (see L<mk-archiver> for more on this
7069                                                  algorithm).  It is very similar to L<"Chunk">, but instead of pre-calculating
7070                                                  the boundaries of each piece of the table based on index cardinality, it uses
7071                                                  C<LIMIT> to define each nibble's upper limit, and the previous nibble's upper
7072                                                  limit to define the lower limit.
7073                                                  
7074                                                  It works in steps: one query finds the row that will define the next nibble's
7075                                                  upper boundary, and the next query checksums the entire nibble.  If the nibble
7076                                                  differs between the source and destination, it examines the nibble row-by-row,
7077                                                  just as L<"Chunk"> does.
7078                                                  
7079                                                  =item GroupBy
7080                                                  
7081                                                  Selects the entire table grouped by all columns, with a COUNT(*) column added.
7082                                                  Compares all columns, and if they're the same, compares the COUNT(*) column's
7083                                                  value to determine how many rows to insert or delete into the destination.
7084                                                  Works on tables with no primary key or unique index.
7085                                                  
7086                                                  =item Stream
7087                                                  
7088                                                  Selects the entire table in one big stream and compares all columns.  Selects
7089                                                  all columns.  Much less efficient than the other algorithms, but works when
7090                                                  there is no suitable index for them to use.
7091                                                  
7092                                                  =item Future Plans
7093                                                  
7094                                                  Possibilities for future algorithms are TempTable (what I originally called
7095                                                  bottom-up in earlier versions of this tool), DrillDown (what I originallly
7096                                                  called top-down), and GroupByPrefix (similar to how SqlYOG Job Agent works).
7097                                                  Each algorithm has strengths and weaknesses.  If you'd like to implement your
7098                                                  favorite technique for finding differences between two sources of data on
7099                                                  possibly different servers, I'm willing to help.  The algorithms adhere to a
7100                                                  simple interface that makes it pretty easy to write your own.
7101                                                  
7102                                                  =back
7103                                                  
7104                                                  =head1 EXIT STATUS
7105                                                  
7106                                                  Exit status is as follows:
7107                                                  
7108                                                     STATUS  MEANING
7109                                                     ======  =======================================================
7110                                                     0       Success.
7111                                                     1       Internal error.
7112                                                     2       At least one table differed on the destination.
7113                                                     3       Combination of 1 and 2.
7114                                                  
7115                                                  =head1 OPTIONS
7116                                                  
7117                                                  Specify at least one of L<"--print">, L<"--execute">, or L<"--dry-run">.
7118                                                  
7119                                                  L<"--where"> and L<"--replicate"> are mutually exclusive.
7120                                                  
7121                                                  =over
7122                                                  
7123                                                  =item --algorithms
7124                                                  
7125                                                  type: string; default: Chunk,Nibble,GroupBy,Stream
7126                                                  
7127                                                  Algorithm to use when comparing the tables, in order of preference.
7128                                                  
7129                                                  For each table, mk-table-sync will check if the table can be synced with
7130                                                  the given algorithms in the order that they're given.  The first algorithm
7131                                                  that can sync the table is used.  See L<"ALGORITHMS">.
7132                                                  
7133                                                  =item --ask-pass
7134                                                  
7135                                                  Prompt for a password when connecting to MySQL.
7136                                                  
7137                                                  =item --[no]bin-log
7138                                                  
7139                                                  default: yes
7140                                                  
7141                                                  Log to the binary log (C<SET SQL_LOG_BIN=1>).
7142                                                  
7143                                                  Specifying C<--no-bin-log> will C<SET SQL_LOG_BIN=0>.
7144                                                  
7145                                                  =item --buffer-in-mysql
7146                                                  
7147                                                  Instruct MySQL to buffer queries in its memory.
7148                                                  
7149                                                  This option adds the C<SQL_BUFFER_RESULT> option to the comparison queries.
7150                                                  This causes MySQL to execute the queries and place them in a temporary table
7151                                                  internally before sending the results back to mk-table-sync.  The advantage of
7152                                                  this strategy is that mk-table-sync can fetch rows as desired without using a
7153                                                  lot of memory inside the Perl process, while releasing locks on the MySQL table
7154                                                  (to reduce contention with other queries).  The disadvantage is that it uses
7155                                                  more memory on the MySQL server instead.
7156                                                  
7157                                                  You probably want to leave L<"--[no]buffer-to-client"> enabled too, because
7158                                                  buffering into a temp table and then fetching it all into Perl's memory is
7159                                                  probably a silly thing to do.  This option is most useful for the GroupBy and
7160                                                  Stream algorithms, which may fetch a lot of data from the server.
7161                                                  
7162                                                  =item --[no]buffer-to-client
7163                                                  
7164                                                  default: yes
7165                                                  
7166                                                  Fetch rows one-by-one from MySQL while comparing.
7167                                                  
7168                                                  This is disabled by default.  If enabled, all rows will be fetched into memory
7169                                                  for comparing.  This may result in the results "cursor" being held open for a
7170                                                  shorter time on the server, but if the tables are large, it could take a long
7171                                                  time anyway, and eat all your memory.  For most non-trivial data sizes, you
7172                                                  want to leave this disabled.
7173                                                  
7174                                                  =item --charset
7175                                                  
7176                                                  short form: -A; type: string
7177                                                  
7178                                                  Default character set.  If the value is utf8, sets Perl's binmode on
7179                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
7180                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
7181                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
7182                                                  connecting to MySQL.
7183                                                  
7184                                                  =item --[no]check-master
7185                                                  
7186                                                  default: yes
7187                                                  
7188                                                  With L<"--sync-to-master">, try to verify that the detected
7189                                                  master is the real master.
7190                                                  
7191                                                  =item --[no]check-privileges
7192                                                  
7193                                                  default: yes
7194                                                  
7195                                                  Check that user has all necessary privileges on source and destination table.
7196                                                  
7197                                                  =item --[no]check-slave
7198                                                  
7199                                                  default: yes
7200                                                  
7201                                                  Check whether the destination server is a slave.
7202                                                  
7203                                                  If the destination server is a slave, it's generally unsafe to make changes on
7204                                                  it.  However, sometimes you have to; L<"--replace"> won't work unless there's a
7205                                                  unique index, for example, so you can't make changes on the master in that
7206                                                  scenario.  By default mk-table-sync will complain if you try to change data on
7207                                                  a slave.  Specify C<--no-slave-check> to disable this check.  Use it at your own
7208                                                  risk.
7209                                                  
7210                                                  =item --[no]check-triggers
7211                                                  
7212                                                  default: yes
7213                                                  
7214                                                  Check that no triggers are defined on the destination table.
7215                                                  
7216                                                  Triggers were introduced in MySQL v5.0.2, so for older versions this option
7217                                                  has no effect because triggers will not be checked.
7218                                                  
7219                                                  =item --chunk-column
7220                                                  
7221                                                  type: string
7222                                                  
7223                                                  Chunk the table on this column.
7224                                                  
7225                                                  =item --chunk-index
7226                                                  
7227                                                  type: string
7228                                                  
7229                                                  Chunk the table using this index.
7230                                                  
7231                                                  =item --chunk-size
7232                                                  
7233                                                  type: string; default: 1000
7234                                                  
7235                                                  Number of rows or data size per chunk.
7236                                                  
7237                                                  The size of each chunk of rows for the L<"Chunk"> and L<"Nibble"> algorithms.
7238                                                  The size can be either a number of rows, or a data size.  Data sizes are
7239                                                  specified with a suffix of k=kibibytes, M=mebibytes, G=gibibytes.  Data sizes
7240                                                  are converted to a number of rows by dividing by the average row length.
7241                                                  
7242                                                  =item --columns
7243                                                  
7244                                                  short form: -c; type: array
7245                                                  
7246                                                  Compare this comma-separated list of columns.
7247                                                  
7248                                                  =item --config
7249                                                  
7250                                                  type: Array
7251                                                  
7252                                                  Read this comma-separated list of config files; if specified, this must be the
7253                                                  first option on the command line.
7254                                                  
7255                                                  =item --databases
7256                                                  
7257                                                  short form: -d; type: hash
7258                                                  
7259                                                  Sync only this comma-separated list of databases.
7260                                                  
7261                                                  A common request is to sync tables from one database with tables from another
7262                                                  database on the same or different server.  This is not yet possible.
7263                                                  L<"--databases"> will not do it, and you can't do it with the D part of the DSN
7264                                                  either because in the absence of a table name it assumes the whole server
7265                                                  should be synced and the D part controls only the connection's default database.
7266                                                  
7267                                                  =item --defaults-file
7268                                                  
7269                                                  short form: -F; type: string
7270                                                  
7271                                                  Only read mysql options from the given file.  You must give an absolute pathname.
7272                                                  
7273                                                  =item --dry-run
7274                                                  
7275                                                  Analyze, decide the sync algorithm to use, print and exit.
7276                                                  
7277                                                  Implies L<"--verbose"> so you can see the results.  The results are in the same
7278                                                  output format that you'll see from actually running the tool, but there will be
7279                                                  zeros for rows affected.  This is because the tool actually executes, but stops
7280                                                  before it compares any data and just returns zeros.  The zeros do not mean there
7281                                                  are no changes to be made.
7282                                                  
7283                                                  =item --engines
7284                                                  
7285                                                  short form: -e; type: hash
7286                                                  
7287                                                  Sync only this comma-separated list of storage engines.
7288                                                  
7289                                                  =item --execute
7290                                                  
7291                                                  Execute queries to make the tables have identical data.
7292                                                  
7293                                                  This option makes mk-table-sync actually sync table data by executing all
7294                                                  the queries that it created to resolve table differences.  Therefore, B<the
7295                                                  tables will be changed!>  And unless you also specify L<"--verbose">, the
7296                                                  changes will be made silently.  If this is not what you want, see
7297                                                  L<"--print"> or L<"--dry-run">.
7298                                                  
7299                                                  =item --explain-hosts
7300                                                  
7301                                                  Print connection information and exit.
7302                                                  
7303                                                  Print out a list of hosts to which mk-table-sync will connect, with all
7304                                                  the various connection options, and exit.
7305                                                  
7306                                                  =item --float-precision
7307                                                  
7308                                                  type: int
7309                                                  
7310                                                  Precision for C<FLOAT> and C<DOUBLE> column comparisons.
7311                                                  
7312                                                  If you specify this option, FLOAT and DOUBLE columns will be rounded to the
7313                                                  specified number of digits after the decimal point for the checksum.  This can
7314                                                  avoid mismatches due to different floating-point representations of
7315                                                  the same values on different MySQL versions and hardware.
7316                                                  
7317                                                  =item --[no]foreign-key-checks
7318                                                  
7319                                                  default: yes
7320                                                  
7321                                                  Enable foreign key checks (C<SET FOREIGN_KEY_CHECKS=1>).
7322                                                  
7323                                                  Specifying C<--no-foreign-key-checks> will C<SET FOREIGN_KEY_CHECKS=0>.
7324                                                  
7325                                                  =item --function
7326                                                  
7327                                                  type: string
7328                                                  
7329                                                  Which hash function you'd like to use for checksums.
7330                                                  
7331                                                  The default is C<CRC32>.  Other good choices include C<MD5> and C<SHA1>.  If you
7332                                                  have installed the C<FNV_64> user-defined function, C<mk-table-sync> will detect
7333                                                  it and prefer to use it, because it is much faster than the built-ins.  You can
7334                                                  also use MURMUR_HASH if you've installed that user-defined function.  Both of
7335                                                  these are distributed with Maatkit.  See L<mk-table-checksum> for more
7336                                                  information and benchmarks.
7337                                                  
7338                                                  =item --help
7339                                                  
7340                                                  Show help and exit.
7341                                                  
7342                                                  =item --host
7343                                                  
7344                                                  short form: -h; type: string
7345                                                  
7346                                                  Connect to host.
7347                                                  
7348                                                  =item --ignore-columns
7349                                                  
7350                                                  type: Hash
7351                                                  
7352                                                  Ignore this comma-separated list of column names in comparisons.
7353                                                  
7354                                                  This option causes columns not to be compared.  However, if a row is determined
7355                                                  to differ between tables, all columns in that row will be synced, regardless.
7356                                                  (It is not currently possible to exclude columns from the sync process itself,
7357                                                  only from the comparison.)
7358                                                  
7359                                                  =item --ignore-databases
7360                                                  
7361                                                  type: Hash
7362                                                  
7363                                                  Ignore this comma-separated list of databases.
7364                                                  
7365                                                  =item --ignore-engines
7366                                                  
7367                                                  type: Hash; default: FEDERATED,MRG_MyISAM
7368                                                  
7369                                                  Ignore this comma-separated list of storage engines.
7370                                                  
7371                                                  =item --ignore-tables
7372                                                  
7373                                                  type: Hash
7374                                                  
7375                                                  Ignore this comma-separated list of tables.
7376                                                  
7377                                                  Table names may be qualified with the database name.
7378                                                  
7379                                                  =item --[no]index-hint
7380                                                  
7381                                                  default: yes
7382                                                  
7383                                                  Add FORCE/USE INDEX hints to the chunk and row queries.
7384                                                  
7385                                                  By default C<mk-table-sync> adds a FORCE/USE INDEX hint to each SQL statement
7386                                                  to coerce MySQL into using the index chosen by the sync algorithm or specified
7387                                                  by L<"--chunk-index">.  This is usually a good thing, but in rare cases the
7388                                                  index may not be the best for the query so you can suppress the index hint
7389                                                  by specifying C<--no-index-hint> and let MySQL choose the index.
7390                                                  
7391                                                  This does not affect the queries printed by L<"--print">; it only affects the
7392                                                  chunk and row queries that C<mk-table-sync> uses to select and compare rows.
7393                                                  
7394                                                  =item --lock
7395                                                  
7396                                                  type: int
7397                                                  
7398                                                  Lock tables: 0=none, 1=per sync cycle, 2=per table, or 3=globally.
7399                                                  
7400                                                  This uses C<LOCK TABLES>.  This can help prevent tables being changed while
7401                                                  you're examining them.  The possible values are as follows:
7402                                                  
7403                                                    VALUE  MEANING
7404                                                    =====  =======================================================
7405                                                    0      Never lock tables.
7406                                                    1      Lock and unlock one time per sync cycle (as implemented
7407                                                           by the syncing algorithm).  This is the most granular
7408                                                           level of locking available.  For example, the Chunk
7409                                                           algorithm will lock each chunk of C<N> rows, and then
7410                                                           unlock them if they are the same on the source and the
7411                                                           destination, before moving on to the next chunk.
7412                                                    2      Lock and unlock before and after each table.
7413                                                    3      Lock and unlock once for every server (DSN) synced, with
7414                                                           C<FLUSH TABLES WITH READ LOCK>.
7415                                                  
7416                                                  A replication slave is never locked if L<"--replicate"> or L<"--sync-to-master">
7417                                                  is specified, since in theory locking the table on the master should prevent any
7418                                                  changes from taking place.  (You are not changing data on your slave, right?)
7419                                                  If L<"--wait"> is given, the master (source) is locked and then the tool waits
7420                                                  for the slave to catch up to the master before continuing.
7421                                                  
7422                                                  If C<--transaction> is specified, C<LOCK TABLES> is not used.  Instead, lock
7423                                                  and unlock are implemented by beginning and committing transactions.
7424                                                  The exception is if L<"--lock"> is 3.
7425                                                  
7426                                                  If C<--no-transaction> is specified, then C<LOCK TABLES> is used for any
7427                                                  value of L<"--lock">. See L<"--[no]transaction">.
7428                                                  
7429                                                  =item --lock-and-rename
7430                                                  
7431                                                  Lock the source and destination table, sync, then swap names.  This is useful as
7432                                                  a less-blocking ALTER TABLE, once the tables are reasonably in sync with each
7433                                                  other (which you may choose to accomplish via any number of means, including
7434                                                  dump and reload or even something like L<mk-archiver>).  It requires exactly two
7435                                                  DSNs and assumes they are on the same server, so it does no waiting for
7436                                                  replication or the like.  Tables are locked with LOCK TABLES.
7437                                                  
7438                                                  =item --password
7439                                                  
7440                                                  short form: -p; type: string
7441                                                  
7442                                                  Password to use when connecting.
7443                                                  
7444                                                  =item --pid
7445                                                  
7446                                                  type: string
7447                                                  
7448                                                  Create the given PID file.  The file contains the process ID of the script.
7449                                                  The PID file is removed when the script exits.  Before starting, the script
7450                                                  checks if the PID file already exists.  If it does not, then the script creates
7451                                                  and writes its own PID to it.  If it does, then the script checks the following:
7452                                                  if the file contains a PID and a process is running with that PID, then
7453                                                  the script dies; or, if there is no process running with that PID, then the
7454                                                  script overwrites the file with its own PID and starts; else, if the file
7455                                                  contains no PID, then the script dies.
7456                                                  
7457                                                  =item --port
7458                                                  
7459                                                  short form: -P; type: int
7460                                                  
7461                                                  Port number to use for connection.
7462                                                  
7463                                                  =item --print
7464                                                  
7465                                                  Print queries that will resolve differences.
7466                                                  
7467                                                  If you don't trust C<mk-table-sync>, or just want to see what it will do, this
7468                                                  is a good way to be safe.  These queries are valid SQL and you can run them
7469                                                  yourself if you want to sync the tables manually.
7470                                                  
7471                                                  =item --recursion-method
7472                                                  
7473                                                  type: string
7474                                                  
7475                                                  Preferred recursion method used to find slaves.
7476                                                  
7477                                                  Possible methods are:
7478                                                  
7479                                                    METHOD       USES
7480                                                    ===========  ================
7481                                                    processlist  SHOW PROCESSLIST
7482                                                    hosts        SHOW SLAVE HOSTS
7483                                                  
7484                                                  The processlist method is preferred because SHOW SLAVE HOSTS is not reliable.
7485                                                  However, the hosts method is required if the server uses a non-standard
7486                                                  port (not 3306).  Usually mk-table-sync does the right thing and finds
7487                                                  the slaves, but you may give a preferred method and it will be used first.
7488                                                  If it doesn't find any slaves, the other methods will be tried.
7489                                                  
7490                                                  
7491                                                  =item --replace
7492                                                  
7493                                                  Write all C<INSERT> and C<UPDATE> statements as C<REPLACE>.
7494                                                  
7495                                                  This is automatically switched on as needed when there are unique index
7496                                                  violations.
7497                                                  
7498                                                  =item --replicate
7499                                                  
7500                                                  type: string
7501                                                  
7502                                                  Sync tables listed as different in this table.
7503                                                  
7504                                                  Specifies that C<mk-table-sync> should examine the specified table to find data
7505                                                  that differs.  The table is exactly the same as the argument of the same name to
7506                                                  L<mk-table-checksum>.  That is, it contains records of which tables (and ranges
7507                                                  of values) differ between the master and slave.
7508                                                  
7509                                                  For each table and range of values that shows differences between the master and
7510                                                  slave, C<mk-table-checksum> will sync that table, with the appropriate C<WHERE>
7511                                                  clause, to its master.
7512                                                  
7513                                                  This automatically sets L<"--wait"> to 60 and causes changes to be made on the
7514                                                  master instead of the slave.
7515                                                  
7516                                                  If L<"--sync-to-master"> is specified, the tool will assume the server you
7517                                                  specified is the slave, and connect to the master as usual to sync.
7518                                                  
7519                                                  Otherwise, it will try to use C<SHOW PROCESSLIST> to find slaves of the server
7520                                                  you specified.  If it is unable to find any slaves via C<SHOW PROCESSLIST>, it
7521                                                  will inspect C<SHOW SLAVE HOSTS> instead.  You must configure each slave's
7522                                                  C<report-host>, C<report-port> and other options for this to work right.  After
7523                                                  finding slaves, it will inspect the specified table on each slave to find data
7524                                                  that needs to be synced, and sync it. 
7525                                                  
7526                                                  The tool examines the master's copy of the table first, assuming that the master
7527                                                  is potentially a slave as well.  Any table that shows differences there will
7528                                                  B<NOT> be synced on the slave(s).  For example, suppose your replication is set
7529                                                  up as A->B, B->C, B->D.  Suppose you use this argument and specify server B.
7530                                                  The tool will examine server B's copy of the table.  If it looks like server B's
7531                                                  data in table C<test.tbl1> is different from server A's copy, the tool will not
7532                                                  sync that table on servers C and D.
7533                                                  
7534                                                  =item --set-vars
7535                                                  
7536                                                  type: string; default: wait_timeout=10000
7537                                                  
7538                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
7539                                                  string will be appended to SET and executed.
7540                                                  
7541                                                  =item --socket
7542                                                  
7543                                                  short form: -S; type: string
7544                                                  
7545                                                  Socket file to use for connection.
7546                                                  
7547                                                  =item --sync-to-master
7548                                                  
7549                                                  Treat the DSN as a slave and sync it to its master.
7550                                                  
7551                                                  Treat the server you specified as a slave.  Inspect C<SHOW SLAVE STATUS>,
7552                                                  connect to the server's master, and treat the master as the source and the slave
7553                                                  as the destination.  Causes changes to be made on the master.  Sets L<"--wait">
7554                                                  to 60 by default, sets L<"--lock"> to 1 by default, and disables
7555                                                  L<"--[no]transaction"> by default.  See also L<"--replicate">, which changes
7556                                                  this option's behavior.
7557                                                  
7558                                                  =item --tables
7559                                                  
7560                                                  short form: -t; type: hash
7561                                                  
7562                                                  Sync only this comma-separated list of tables.
7563                                                  
7564                                                  Table names may be qualified with the database name.
7565                                                  
7566                                                  =item --timeout-ok
7567                                                  
7568                                                  Keep going if L<"--wait"> fails.
7569                                                  
7570                                                  If you specify L<"--wait"> and the slave doesn't catch up to the master's
7571                                                  position before the wait times out, the default behavior is to abort.  This
7572                                                  option makes the tool keep going anyway.  B<Warning>: if you are trying to get a
7573                                                  consistent comparision between the two servers, you probably don't want to keep
7574                                                  going after a timeout.
7575                                                  
7576                                                  =item --[no]transaction
7577                                                  
7578                                                  Use transactions instead of C<LOCK TABLES>.
7579                                                  
7580                                                  The granularity of beginning and committing transactions is controlled by
7581                                                  L<"--lock">.  This is enabled by default, but since L<"--lock"> is disabled by
7582                                                  default, it has no effect.
7583                                                  
7584                                                  Most options that enable locking also disable transactions by default, so if
7585                                                  you want to use transactional locking (via C<LOCK IN SHARE MODE> and C<FOR
7586                                                  UPDATE>, you must specify C<--transaction> explicitly.
7587                                                  
7588                                                  If you don't specify C<--transaction> explicitly C<mk-table-sync> will decide on
7589                                                  a per-table basis whether to use transactions or table locks.  It currently
7590                                                  uses transactions on InnoDB tables, and table locks on all others.
7591                                                  
7592                                                  If C<--no-transaction> is specified, then C<mk-table-sync> will not use
7593                                                  transactions at all (not even for InnoDB tables) and locking is controlled
7594                                                  by L<"--lock">.
7595                                                  
7596                                                  =item --trim
7597                                                  
7598                                                  C<TRIM()> C<VARCHAR> columns in C<BIT_XOR> and C<ACCUM> modes.  Helps when
7599                                                  comparing MySQL 4.1 to >= 5.0.
7600                                                  
7601                                                  This is useful when you don't care about the trailing space differences between
7602                                                  MySQL versions which vary in their handling of trailing spaces. MySQL 5.0 and 
7603                                                  later all retain trailing spaces in C<VARCHAR>, while previous versions would 
7604                                                  remove them.
7605                                                  
7606                                                  =item --[no]unique-checks
7607                                                  
7608                                                  default: yes
7609                                                  
7610                                                  Enable unique key checks (C<SET UNIQUE_CHECKS=1>).
7611                                                  
7612                                                  Specifying C<--no-unique-checks> will C<SET UNIQUE_CHECKS=0>.
7613                                                  
7614                                                  =item --user
7615                                                  
7616                                                  short form: -u; type: string
7617                                                  
7618                                                  User for login if not current user.
7619                                                  
7620                                                  =item --verbose
7621                                                  
7622                                                  short form: -v; cumulative: yes
7623                                                  
7624                                                  Print results of sync operations.
7625                                                  
7626                                                  See L<"OUTPUT"> for more details about the output.
7627                                                  
7628                                                  =item --version
7629                                                  
7630                                                  Show version and exit.
7631                                                  
7632                                                  =item --wait
7633                                                  
7634                                                  short form: -w; type: time
7635                                                  
7636                                                  How long to wait for slaves to catch up to their master.
7637                                                  
7638                                                  Make the master wait for the slave to catch up in replication before comparing
7639                                                  the tables.  The value is the number of seconds to wait before timing out (see
7640                                                  also L<"--timeout-ok">).  Sets L<"--lock"> to 1 and L<"--[no]transaction"> to 0
7641                                                  by default.  If you see an error such as the following,
7642                                                  
7643                                                    MASTER_POS_WAIT returned -1
7644                                                  
7645                                                  It means the timeout was exceeded and you need to increase it.
7646                                                  
7647                                                  The default value of this option is influenced by other options.  To see what
7648                                                  value is in effect, run with L<"--help">.
7649                                                  
7650                                                  =item --where
7651                                                  
7652                                                  type: string
7653                                                  
7654                                                  C<WHERE> clause to restrict syncing to part of the table.
7655                                                  
7656                                                  =back
7657                                                  
7658                                                  =head1 DOWNLOADING
7659                                                  
7660                                                  You can download Maatkit from Google Code at
7661                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
7662                                                  easily with a command like the following:
7663                                                  
7664                                                     wget http://www.maatkit.org/get/toolname
7665                                                     or
7666                                                     wget http://www.maatkit.org/trunk/toolname
7667                                                  
7668                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
7669                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
7670                                                  needed.  The first URL gets the latest released version of the tool, and the
7671                                                  second gets the latest trunk code from Subversion.
7672                                                  
7673                                                  =head1 ENVIRONMENT
7674                                                  
7675                                                  The environment variable MKDEBUG enables verbose debugging output in all of the
7676                                                  Maatkit tools:
7677                                                  
7678                                                     MKDEBUG=1 mk-....
7679                                                  
7680                                                  =head1 SYSTEM REQUIREMENTS
7681                                                  
7682                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
7683                                                  installed in any reasonably new version of Perl.
7684                                                  
7685                                                  =head1 BUGS
7686                                                  
7687                                                  For a list of known bugs see: L<http://www.maatkit.org/bugs/mk-table-sync>.
7688                                                  
7689                                                  Please use Google Code Issues and Groups to report bugs or request support:
7690                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
7691                                                  discuss Maatkit.
7692                                                  
7693                                                  Please include the complete command-line used to reproduce the problem you are
7694                                                  seeing, the version of all MySQL servers involved, the complete output of the
7695                                                  tool when run with L<"--version">, and if possible, debugging output produced by
7696                                                  running with the C<MKDEBUG=1> environment variable.
7697                                                  
7698                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
7699                                                  
7700                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7701                                                  Feedback and improvements are welcome.
7702                                                  
7703                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7704                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
7705                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
7706                                                  
7707                                                  This program is free software; you can redistribute it and/or modify it under
7708                                                  the terms of the GNU General Public License as published by the Free Software
7709                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
7710                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
7711                                                  licenses.
7712                                                  
7713                                                  You should have received a copy of the GNU General Public License along with
7714                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
7715                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
7716                                                  
7717                                                  =head1 AUTHOR
7718                                                  
7719                                                  Baron Schwartz
7720                                                  
7721                                                  =head1 ABOUT MAATKIT
7722                                                  
7723                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
7724                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
7725                                                  code contributors.  Both are employed by Percona.  Financial support for
7726                                                  Maatkit development is primarily provided by Percona and its clients. 
7727                                                  
7728                                                  =head1 HISTORY AND ACKNOWLEDGEMENTS
7729                                                  
7730                                                  My work is based in part on Giuseppe Maxia's work on distributed databases,
7731                                                  L<http://www.sysadminmag.com/articles/2004/0408/> and code derived from that
7732                                                  article.  There is more explanation, and a link to the code, at
7733                                                  L<http://www.perlmonks.org/?node_id=381053>.
7734                                                  
7735                                                  Another programmer extended Maxia's work even further.  Fabien Coelho changed
7736                                                  and generalized Maxia's technique, introducing symmetry and avoiding some
7737                                                  problems that might have caused too-frequent checksum collisions.  This work
7738                                                  grew into pg_comparator, L<http://www.coelho.net/pg_comparator/>.  Coelho also
7739                                                  explained the technique further in a paper titled "Remote Comparison of Database
7740                                                  Tables" (L<http://cri.ensmp.fr/classement/doc/A-375.pdf>).
7741                                                  
7742                                                  This existing literature mostly addressed how to find the differences between
7743                                                  the tables, not how to resolve them once found.  I needed a tool that would not
7744                                                  only find them efficiently, but would then resolve them.  I first began thinking
7745                                                  about how to improve the technique further with my article
7746                                                  L<http://tinyurl.com/mysql-data-diff-algorithm>,
7747                                                  where I discussed a number of problems with the Maxia/Coelho "bottom-up"
7748                                                  algorithm.  After writing that article, I began to write this tool.  I wanted to
7749                                                  actually implement their algorithm with some improvements so I was sure I
7750                                                  understood it completely.  I discovered it is not what I thought it was, and is
7751                                                  considerably more complex than it appeared to me at first.  Fabien Coelho was
7752                                                  kind enough to address some questions over email.
7753                                                  
7754                                                  The first versions of this tool implemented a version of the Coelho/Maxia
7755                                                  algorithm, which I called "bottom-up", and my own, which I called "top-down."
7756                                                  Those algorithms are considerably more complex than the current algorithms and
7757                                                  I have removed them from this tool, and may add them back later.  The
7758                                                  improvements to the bottom-up algorithm are my original work, as is the
7759                                                  top-down algorithm.  The techniques to actually resolve the differences are
7760                                                  also my own work.
7761                                                  
7762                                                  Another tool that can synchronize tables is the SQLyog Job Agent from webyog.
7763                                                  Thanks to Rohit Nadhani, SJA's author, for the conversations about the general
7764                                                  techniques.  There is a comparison of mk-table-sync and SJA at
7765                                                  L<http://tinyurl.com/maatkit-vs-sqlyog>
7766                                                  
7767                                                  Thanks to the following people and organizations for helping in many ways:
7768                                                  
7769                                                  The Rimm-Kaufman Group L<http://www.rimmkaufman.com/>,
7770                                                  MySQL AB L<http://www.mysql.com/>,
7771                                                  Blue Ridge InternetWorks L<http://www.briworks.com/>,
7772                                                  Percona L<http://www.percona.com/>,
7773                                                  Fabien Coelho,
7774                                                  Giuseppe Maxia and others at MySQL AB,
7775                                                  Kristian Koehntopp (MySQL AB),
7776                                                  Rohit Nadhani (WebYog),
7777                                                  The helpful monks at Perlmonks,
7778                                                  And others too numerous to mention.
7779                                                  
7780                                                  =head1 VERSION
7781                                                  
7782                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5478 $.
7783                                                  
7784                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
58    ***      0      0      0   unless $args{$arg}
64    ***      0      0      0   exists $args{'strict'} ? :
107   ***      0      0      0   unless open my $fh, '<', $file
127   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
132   ***      0      0      0   if $para =~ /^=over/
140   ***      0      0      0   unless $para
143   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
150   ***      0      0      0   if ($para =~ /: /) { }
154   ***      0      0      0   unless $attributes{$attrib}
158   ***      0      0      0   if ($attribs{'short form'})
174   ***      0      0      0   if $para =~ /^=item/
176   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
181   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
193   ***      0      0      0   unless $para
196   ***      0      0      0   if ($para =~ /^=head1/)
200   ***      0      0      0   if $para =~ /^=item --/
204   ***      0      0      0   unless @specs
215   ***      0      0      0   if (ref $opt) { }
220   ***      0      0      0   if (not $long)
225   ***      0      0      0   if exists $$self{'opts'}{$long}
228   ***      0      0      0   if (length $long == 1)
233   ***      0      0      0   if ($short) { }
234   ***      0      0      0   if exists $$self{'short_opts'}{$short}
243   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
244   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
245   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
257   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
262   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
264   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
265   ***      0      0      0   defined $def ? :
269   ***      0      0      0   if ($long eq 'config')
273   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
286   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
291   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
296   ***      0      0      0   if ($opt =~ /default to/)
301   ***      0      0      0   if ($opt =~ /restricted to option groups/)
311   ***      0      0      0   unless $rule_ok
328   ***      0      0      0   unless exists $$self{'opts'}{$long}
352   ***      0      0      0   unless exists $$self{'opts'}{$long}
372   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
377   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
392   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
401   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
405   ***      0      0      0   if ($self->has('config'))
411   ***      0      0      0   if ($EVAL_ERROR)
412   ***      0      0      0   $self->got('config') ? :
427   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
430   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
431   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
437   ***      0      0      0   if (@ARGV and $$self{'strict'})
443   ***      0      0      0   if (@set > 1)
454   ***      0      0      0   if (@set == 0)
464   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
465   ***      0      0      0   if (exists $$self{'disables'}{$long})
472   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
484   ***      0      0      0   if $restricted_opt eq $long
485   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
490   ***      0      0      0   if (@restricted_opts)
492   ***      0      0      0   if (@restricted_opts == 1) { }
521   ***      0      0      0   unless $opt and $$opt{'type'}
524   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
527   ***      0      0      0   if (not $suffix)
533   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
534   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
549   ***      0      0      0   if ($from_key)
560   ***      0      0      0   if (defined $num) { }
561   ***      0      0      0   if ($factor)
588   ***      0      0      0   length $opt == 1 ? :
589   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
596   ***      0      0      0   length $opt == 1 ? :
597   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
604   ***      0      0      0   length $opt == 1 ? :
605   ***      0      0      0   defined $long ? :
610   ***      0      0      0   length $opt == 1 ? :
611   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
645   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
646   ***      0      0      0   unless print $self->print_usage
650   ***      0      0      0   unless print $self->print_errors
659   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
668   ***      0      0      0   unless $$self{'got_opts'}
671   ***      0      0      0   $$_{'is_negatable'} ? :
675   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
691   ***      0      0      0   $group eq 'default' ? :
697   ***      0      0      0   $$opt{'is_negatable'} ? :
700   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
709   ***      0      0      0   if ($short) { }
718   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
722   ***      0      0      0   if ($$self{'dp'})
730   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
742   ***      0      0      0   if ref $_[0] eq 'OptionParser'
745   ***      0      0      0   unless print $prompt
753   ***      0      0      0   unless print "\n"
756   ***      0      0      0   if ($EVAL_ERROR)
778   ***      0      0      0   unless open my $fh, '<', $filename
786   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
789   ***      0      0      0   if ($line eq '--')
794   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
812   ***      0      0      0   unless open my $fh, '<', $file
816   ***      0      0      0   unless $para =~ /^=pod$/m
820   ***      0      0      0   unless $para =~ /$regex/
825   ***      0      0      0   unless close $fh
839   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
854   ***      0      0      0   defined $_ ? :
894   ***      0      0      0   unless defined $val
895   ***      0      0      0   if $val eq ''
897   ***      0      0      0   if (not defined $is_numeric)
898   ***      0      0      0   $val =~ /^0|\D/ ? :
901   ***      0      0      0   if $is_numeric
911   ***      0      0      0   if (not $tbl)
920   ***      0      0      0   unless $like
1005  ***     50      0    138   if (@_ > 2)
1014  ***     50      0     46   if (not $dsn)
1026  ***     50    184      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1038  ***     50      0    368   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1044         100    184    184   if (not defined $final_props{$key})
1051  ***     50      0    184   unless exists $opts{$key}
1054  ***     50      0     46   if (my $required = $self->prop('required'))
1056  ***      0      0      0   unless $final_props{$key}
1065  ***      0      0      0   unless ref $o eq 'OptionParser'
1068  ***      0      0      0   if $o->has($_)
1078  ***      0      0      0   unless ref $dsn
1079  ***      0      0      0   $_ eq 'p' ? :
1080  ***      0      0      0   if defined $$dsn{$_}
1093  ***      0      0      0   $opts{$key}{'copy'} ? :
1107  ***     50      0     46   if ($driver eq 'Pg') { }
1139  ***     50      0     46   $cxn_string =~ /charset=utf8/ ? :
1148  ***     50      0     46   if (not $have_dbi)
1167  ***     50     46      0   if ($cxn_string =~ /mysql/i)
1175  ***     50      0     46   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1180  ***      0      0      0   if ($charset eq 'utf8') { }
1181  ***      0      0      0   unless binmode STDOUT, ':utf8'
1185  ***      0      0      0   unless binmode STDOUT
1189  ***     50      0     46   if ($self->prop('set-vars'))
1196  ***     50      0     46   if (not $dbh and $EVAL_ERROR)
1198  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1211  ***      0      0      0   if (not $tries)
1233  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1250  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1260  ***      0      0      0   unless $dsn_1
1261  ***      0      0      0   unless $dsn_2
1265  ***      0      0      0   if ($args{'overwrite'}) { }
1266  ***      0      0      0   defined $$dsn_1{$key} ? :
1269  ***      0      0      0   defined $$dsn_2{$key} ? :
1278  ***      0      0      0   defined $_ ? :
1316  ***     50      1      0   if (not $$self{$dbh})
1320  ***     50      1      0   $$self{$dbh} ge $self->parse($target) ? :
1327  ***      0      0      0   defined $_ ? :
1354  ***      0      0      0   unless $args{$arg}
1372  ***      0      0      0   unless $args{$arg}
1400  ***      0      0      0   $$self{'buffer_in_mysql'} ? :
1442  ***      0      0      0   defined $_ ? :
1474  ***      0      0      0   unless $args{$arg}
1483  ***      0      0      0   unless $ddl
1484  ***      0      0      0   if (ref $ddl eq 'ARRAY')
1485  ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
1495  ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
1501  ***      0      0      0   if $name
1519  ***      0      0      0   unless $type
1521  ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
1525  ***      0      0      0   if (not $def =~ /NOT NULL/)
1529  ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
1560  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1574  ***      0      0      0   if ($index)
1577  ***      0      0      0   if (not $best)
1578  ***      0      0      0   if ($index) { }
1591  ***      0      0      0   unless $where
1597  ***      0      0      0   if ($$expl{'possible_keys'}) { }
1601  ***      0      0      0   if ($$expl{'key'})
1621  ***      0      0      0   unless $args{$arg}
1635  ***      0      0      0   if ($EVAL_ERROR)
1639  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
1645  ***      0      0      0   unless $args{'all_privs'}
1652  ***      0      0      0   if ($EVAL_ERROR)
1656  ***      0      0      0   if (not scalar keys %$row)
1667  ***      0      0      0   $EVAL_ERROR ? :
1672  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
1698  ***      0      0      0   if $key =~ /FOREIGN/
1703  ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
1710  ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
1717  ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
1741  ***      0      0      0   if ($engine =~ /InnoDB/i and not $clustered_key)
1743  ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
1767  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
1796  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
1810  ***      0      0      0   if (@sec_indexes)
1827  ***      0      0      0   defined $_ ? :
1853  ***      0      0      0   unless $args{'dbh'}
1869  ***      0      0      0   !$lr && !$left_done ? :
1873  ***      0      0      0   !$lr || $EVAL_ERROR ? :
1879  ***      0      0      0   !$rr && !$right_done ? :
1883  ***      0      0      0   !$rr || $EVAL_ERROR ? :
1890  ***      0      0      0   if ($lr and $rr)
1894  ***      0      0      0   if ($lr or $rr)
1895  ***      0      0      0   if ($lr and $rr and defined $cmp and $cmp == 0) { }
      ***      0      0      0   elsif (not $rr or defined $cmp and $cmp < 0) { }
1898  ***      0      0      0   if $$self{'same_row'}
1904  ***      0      0      0   if $$self{'not_in_right'}
1910  ***      0      0      0   if $$self{'not_in_left'}
1914  ***      0      0      0   if $done and &$done($left, $right)
1928  ***      0      0      0   if (not defined $l or not defined $r) { }
1930  ***      0      0      0   defined $r ? :
      ***      0      0      0   defined $l ? :
1933  ***      0      0      0   if ($$tbl{'is_numeric'}{$col}) { }
      ***      0      0      0   elsif ($l ne $r) { }
1935  ***      0      0      0   if $trf
1937  ***      0      0      0   if ($cmp)
1939  ***      0      0      0   if $callback
1946  ***      0      0      0   if ($coll and $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/) { }
1955  ***      0      0      0   if ($cmp)
1957  ***      0      0      0   if $callback
1968  ***      0      0      0   if (not $$self{'sth'}{$collation})
1969  ***      0      0      0   if (not $$self{'charset_for'})
1990  ***      0      0      0   defined $_ ? :
2040  ***      0      0      0   unless defined $args{'cache'}
2048  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2050  ***      0      0      0   unless $ddl
2051  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2065  ***      0      0      0   if ($trgs and @$trgs) { }
2068  ***      0      0      0   if ($$trg{'sql_mode'})
2072  ***      0      0      0   if ($$trg{'definer'})
2104  ***      0      0      0   if (not $new)
2111  ***      0      0      0   if ($curr and $new and $curr eq $new)
2123  ***      0      0      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2136  ***      0      0      0   if ($EVAL_ERROR)
2146  ***      0      0      0   if ($key) { }
2162  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2192  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2205  ***      0      0      0   if ($sth->rows)
2218  ***      0      0      0   if ($tbl)
2226  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2229  ***      0      0      0   if ($like)
2237  ***      0      0      0   unless $like
2245  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2248  ***      0      0      0   if ($like)
2263  ***      0      0      0   unless $like
2271  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2274  ***      0      0      0   if ($like)
2282  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2289  ***      0      0      0   unless $like
2297  ***      0      0      0   defined $_ ? :
2327  ***      0      0      0   unless defined $args{$arg}
2354  ***      0      0      0   $$self{'replace'} && $action ne 'DELETE' ? :
2356  ***      0      0      0   if ($$self{'queue'}) { }
2364  ***      0      0      0   if ($EVAL_ERROR =~ /$DUPE_KEY/) { }
      ***      0      0      0   elsif ($EVAL_ERROR) { }
2379  ***      0      0      0   if ($$self{'replace'})
2380  ***      0      0      0   $action eq 'DELETE' ? :
2389  ***      0      0      0   if ($queue_level and $queue_level < $$self{'queue'})
2408  ***      0      0      0   if (not $error_count++ and $EVAL_ERROR =~ /$DUPE_KEY/) { }
      ***      0      0      0   elsif ($EVAL_ERROR) { }
2433  ***      0      0      0   if ($$self{'replace'})
2439  ***      0      0      0   if (my $dbh = $$self{'fetch_back'}) { }
2460  ***      0      0      0   if ($$self{'replace'})
2475  ***      0      0      0   if (my $dbh = $$self{'fetch_back'}) { }
2498  ***      0      0      0   defined $val ? :
2512  ***      0      0      0   if ($$self{'tbl_struct'}) { }
2519  ***      0      0      0   if (not defined $$pos{$_}) { }
2528  ***      0      0      0   if @not_in_tbl
2538  ***      0      0      0   defined $_ ? :
2571  ***      0      0      0   unless $args{$arg}
2586  ***      0      0      0   unless $args{$arg}
2593  ***      0      0      0   unless $$index{'type'} eq 'BTREE'
2597  ***      0      0      0   if ($args{'exact'})
2598  ***      0      0      0   unless $$index{'is_unique'} and @{$$index{'cols'};} == 1
2611  ***      0      0      0   unless $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2617  ***      0      0      0   if $args{'exact'} and scalar @candidate_cols
2627  ***      0      0      0   if ($$tbl_struct{'keys'}{'PRIMARY'})
2650  ***      0      0      0   unless defined $args{$arg}
2661  ***      0      0      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type eq 'timestamp') { }
      ***      0      0      0   elsif ($col_type eq 'date') { }
      ***      0      0      0   elsif ($col_type eq 'time') { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
2693  ***      0      0      0   if (not defined $start_point)
2697  ***      0      0      0   if (not defined $end_point or $end_point < $start_point)
2706  ***      0      0      0   if ($int_types{$col_type})
2710  ***      0      0      0   if ($args{'exact'})
2716  ***      0      0      0   if ($start_point < $end_point) { }
2722  ***      0      0      0   if ($iter++ == 0) { }
2732  ***      0      0      0   if (@chunks) { }
2736  ***      0      0      0   $nullable ? :
2738  ***      0      0      0   if ($nullable)
2754  ***      0      0      0   unless $args{$arg}
2764  ***      0      0      0   unless $args{$arg}
2773  ***      0      0      0   if ($suffix) { }
      ***      0      0      0   elsif ($num) { }
2774  ***      0      0      0   $suffix eq 'M' ? :
      ***      0      0      0   $suffix eq 'k' ? :
2786  ***      0      0      0   if ($suffix or $args{'avg_row_length'})
2789  ***      0      0      0   if (not defined $n_rows)
2790  ***      0      0      0   $avg_row_length ? :
2794  ***      0      0      0   wantarray ? :
2801  ***      0      0      0   unless $args{$arg}
2806  ***      0      0      0   $where ? :
2814  ***      0      0      0   if ($EVAL_ERROR)
2816  ***      0      0      0   if ($EVAL_ERROR =~ /in your SQL syntax/) { }
2823  ***      0      0      0   $where ? :
2836  ***      0      0      0   $val =~ /\d[:-]/ ? :
2842  ***      0      0      0   unless defined $args{$arg}
2851  ***      0      0      0   if ($args{'where'} and grep {$_;} @{$args{'where'};})
2874  ***      0      0      0   if $start =~ /e/
2875  ***      0      0      0   if $end =~ /e/
2880  ***      0      0      0   if ($end > $start) { }
2926  ***      0      0      0   unless $check eq $time
2937  ***      0      0      0   defined $_ ? :
2970  ***      0      0      0   unless defined $args{$arg}
2983  ***      0      0      0   $comp & 1 ? :
2993  ***      0      0      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64')
3013  ***      0      0      0   if ($type eq 'bigint' and $length < 20)
3027  ***      0      0      0   if $alg and not $ALGOS{$alg}
3030  ***      0      0      0   if ($args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1'))
3039  ***      0      0      0   if (not $vp->version_ge($dbh, '4.1.1'))
3044  ***      0      0      0   if ($alg and grep {$_ eq $alg;} @choices)
3049  ***      0      0      0   if ($args{'count'} and grep {$_ ne 'CHECKSUM';} @choices)
3066  ***      0      0      0   if ($args{'function'})
3079  ***      0      0      0   if ($EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/)
3085  ***      0      0      0   unless $result
3094  ***      0      0      0   if $func =~ /^(?:FNV1A_64|FNV_64|CRC32)$/i
3101  ***      0      0      0   length $unsliced < 16 ? :
3114  ***      0      0      0   if ($sliced ne $unsliced)
3121  ***      0      0      0   if ($sliced eq $unsliced) { }
3134  ***      0      0      0   unless defined $args{$arg}
3141  ***      0      0      0   if ($len > 16)
3150  ***      0      0      0   if (defined $opt_slice and $opt_slice < @slices) { }
3173  ***      0      0      0   $args{'cols'} ? :
3178  ***      0      0      0   if ($type eq 'timestamp') { }
      ***      0      0      0   elsif ($type =~ /float|double/ and $args{'float_precision'}) { }
      ***      0      0      0   elsif ($type =~ /varchar/ and $args{'trim'}) { }
3195  ***      0      0      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64') { }
3197  ***      0      0      0   if (@nulls)
3204  ***      0      0      0   @cols > 1 ? :
3220  ***      0      0      0   unless $args{$arg}
3228  ***      0      0      0   unless $algorithm and $ALGOS{$algorithm}
3231  ***      0      0      0   if ($algorithm eq 'CHECKSUM')
3237  ***      0      0      0   if ($algorithm eq 'BIT_XOR') { }
3238  ***      0      0      0   if ($crc_type =~ /int$/) { }
3247  ***      0      0      0   if ($crc_type =~ /int$/) { }
3260  ***      0      0      0   if ($args{'replicate'}) { }
3266  ***      0      0      0   $args{'buffer'} ? :
3296  ***      0      0      0   defined $_ ? :
3328  ***      0      0      0   unless defined $args{$arg}
3341  ***      0      0      0   unless defined $args{$arg}
3348  ***      0      0      0   unless $exact
3351  ***      0      0      0   if ($args{'chunk_col'} or $args{'chunk_index'}) { }
3355  ***      0      0      0   if ($args{'chunk_col'})
3356  ***      0      0      0   unless $chunkable_cols[$i]{'column'} eq $args{'chunk_col'}
3358  ***      0      0      0   if ($args{'chunk_index'})
3359  ***      0      0      0   unless $chunkable_cols[$i]{'index'} eq $args{'chunk_index'}
3365  ***      0      0      0   if (not $colno)
3389  ***      0      0      0   unless defined $args{$arg}
3402  ***      0      0      0   if (not $args{'replicate'}) { }
3404  ***      0      0      0   if (not grep {not defined $range_params{$_};} 'min', 'max', 'rows_in_range') { }
3431  ***      0      0      0   unless $chunk_sql
3432  ***      0      0      0   unless $row_sql
3448  ***      0      0      0   if ($$self{'state'}) { }
3458  ***      0      0      0   $$self{'buffer_in_mysql'} ? :
      ***      0      0      0   $args{'where'} ? :
3475  ***      0      0      0   if ($$self{'state'}) { }
      ***      0      0      0   elsif ($$lr{'cnt'} != $$rr{'cnt'} or $$lr{'crc'} ne $$rr{'crc'}) { }
3476  ***      0      0      0   if ($$lr{$$self{'crc_col'}} ne $$rr{$$self{'crc_col'}})
3489  ***      0      0      0   unless $$self{'state'}
3496  ***      0      0      0   unless $$self{'state'}
3503  ***      0      0      0   if ($$self{'state'} == 1) { }
3527  ***      0      0      0   if ($$self{'state'}) { }
3540  ***      0      0      0   if ($$self{'state'} == 0) { }
3552  ***      0      0      0   defined $_ ? :
3584  ***      0      0      0   unless defined $args{$arg}
3597  ***      0      0      0   unless defined $args{$arg}
3601  ***      0      0      0   if ($nibble_index) { }
3603  ***      0      0      0   if (not $args{'tbl_struct'}{'keys'}{$nibble_index}{'is_unique'})
3607  ***      0      0      0   if ($args{'chunk_index'} and $args{'chunk_index'} ne $nibble_index)
3619  ***      0      0      0   if ($args{'src'} and $args{'src'}{'dbh'})
3631  ***      0      0      0   if ($table_status)
3632  ***      0      0      0   defined $$table_status{'rows'} ? :
      ***      0      0      0   defined $$table_status{'Rows'} ? :
3635  ***      0      0      0   if defined $n_rows and $n_rows <= 100
3654  ***      0      0      0   unless defined $args{$arg}
3669  ***      0      0      0   if (not $args{'replicate'}) { }
3696  ***      0      0      0   unless $nibble_sql
3697  ***      0      0      0   unless $row_sql
3713  ***      0      0      0   if ($$self{'state'}) { }
3723  ***      0      0      0   $$self{'buffer_in_mysql'} ? :
      ***      0      0      0   $$self{'index_hint'} ? :
      ***      0      0      0   $args{'where'} ? :
3744  ***      0      0      0   if (not $s)
3753  ***      0      0      0   if ($$self{'cached_boundaries'})
3758  ***      0      0      0   if ($$self{'cached_row'} and $$self{'cached_nibble'} == $$self{'nibble'}) { }
3767  ***      0      0      0   if ($$self{'nibble'} == 0 and not $$self{'small_table'})
3769  ***      0      0      0   if (lc($explain_index || '') ne lc $$s{'index'})
3770  ***      0      0      0   $explain_index ? :
3781  ***      0      0      0   if ($row) { }
3791  ***      0      0      0   $lb ? :
3811  ***      0      0      0   if ($$self{'nibble'})
3827  ***      0      0      0   unless $sql
3832  ***      0      0      0   if ($EVAL_ERROR)
3842  ***      0      0      0   if ($$self{'state'}) { }
      ***      0      0      0   elsif ($$lr{'cnt'} != $$rr{'cnt'} or ($$lr{'crc'} || 0) ne ($$rr{'crc'} || 0)) { }
3843  ***      0      0      0   if ($$lr{$$self{'crc_col'}} ne $$rr{$$self{'crc_col'}})
3857  ***      0      0      0   unless $$self{'state'}
3863  ***      0      0      0   unless $$self{'state'}
3869  ***      0      0      0   if ($$self{'state'} == 1) { }
3891  ***      0      0      0   if ($$self{'state'}) { }
3904  ***      0      0      0   if ($$self{'state'} == 0) { }
3916  ***      0      0      0   defined $_ ? :
3943  ***      0      0      0   unless $args{$arg}
3961  ***      0      0      0   unless defined $args{$arg}
3995  ***      0      0      0   $$self{'buffer_in_mysql'} ? :
4009  ***      0      0      0   unless $diff
4015  ***      0      0      0   if ($lc > $rc) { }
4064  ***      0      0      0   defined $_ ? :
4096  ***      0      0      0   unless defined $args{$arg}
4105  ***      0      0      0   unless $args{$arg}
4111  ***      0      0      0   if ($can_sync)
4125  ***      0      0      0   unless $args{$arg}
4131  ***      0      0      0   unless defined $args{'index_hint'}
4141  ***      0      0      0   unless $plugin
4150  ***      0      0      0   if (not $args{'replicate'}) { }
4151  ***      0      0      0   $vp->version_ge($$src{'dbh'}, '4.0.9') && $vp->version_ge($$dst{'dbh'}, '4.0.9') ? :
4154  ***      0      0      0   if ($args{'chunk_index'}) { }
      ***      0      0      0   elsif ($plugin_args{'chunk_index'} and $args{'index_hint'}) { }
4179  ***      0      0      0   if ($EVAL_ERROR)
4184  ***      0      0      0   if ($plugin->uses_checksum)
4189  ***      0      0      0   if ($EVAL_ERROR)
4194  ***      0      0      0   if ($args{'dry_run'})
4203  ***      0      0      0   if ($EVAL_ERROR)
4224  ***      0      0      0   if ($args{'transaction'})
4225  ***      0      0      0   if ($args{'changing_src'}) { }
4238  ***      0      0      0   if $callback
4241  ***      0      0      0   if ($args{'buffer_to_client'})
4247  ***      0      0      0   if (not $cycle or not $plugin->pending_changes)
4252  ***      0      0      0   unless $executed_src
4278  ***      0      0      0   unless $args{$arg}
4297  ***      0      0      0   if ($src_algo ne $dst_algo)
4305  ***      0      0      0   if ($src_func ne $dst_func)
4315  ***      0      0      0   if ($src_algo eq 'BIT_XOR' and not $crc_type =~ /int$/)
4354  ***      0      0      0   unless defined $args{$arg}
4359  ***      0      0      0   unless $args{'lock'} and $args{'lock'} <= $args{'lock_level'}
4362  ***      0      0      0   if ($args{'transaction'}) { }
4381  ***      0      0      0   unless defined $args{$arg}
4386  ***      0      0      0   unless $args{'lock'} and $args{'lock'} == $args{'lock_level'}
4389  ***      0      0      0   if ($args{'transaction'}) { }
4400  ***      0      0      0   if ($args{'lock'} == 3) { }
4406  ***      0      0      0   if ($args{'transaction'}) { }
4407  ***      0      0      0   if ($args{'src_sth'})
4414  ***      0      0      0   $args{'changing_src'} ? :
4421  ***      0      0      0   if ($args{'wait'})
4426  ***      0      0      0   if ($args{'changing_src'}) { }
4431  ***      0      0      0   if ($args{'lock'} == 3) { }
      ***      0      0      0   elsif (not $args{'transaction'}) { }
4437  ***      0      0      0   $args{'execute'} ? :
4444  ***      0      0      0   if ($EVAL_ERROR)
4445  ***      0      0      0   if ($args{'src_sth'}{'Active'})
4449  ***      0      0      0   unless $dbh
4452  ***      0      0      0   unless $$dbh{'AutoCommit'}
4471  ***      0      0      0   $EVAL_ERROR ? :
4475  ***      0      0      0   if ($privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/ and $can_delete)
4486  ***      0      0      0   defined $_ ? :
4514  ***      0      0      0   unless $args{$arg}
4524  ***      0      0      0   unless defined $args{$arg}
4527  ***      0      0      0   $args{'cols'} ? :
4530  ***      0      0      0   unless exists $$tbl_struct{'keys'}{$index}
4539  ***      0      0      0   if ($args{'asc_first'})
4546  ***      0      0      0   if (not exists $col_posn{$col})
4562  ***      0      0      0   if (@asc_slice)
4574  ***      0      0      0   $args{'asc_only'} ? :
4586  ***      0      0      0   unless defined $args{$arg}
4607  ***      0      0      0   if ($$is_nullable{$col}) { }
4623  ***      0      0      0   if ($$is_nullable{$col}) { }
4624  ***      0      0      0   if ($type =~ /=/ and $end) { }
      ***      0      0      0   elsif ($type =~ />/) { }
4639  ***      0      0      0   $type =~ /=/ && $end ? :
4657  ***      0      0      0   $args{'cols'} ? :
4665  ***      0      0      0   unless $index
4667  ***      0      0      0   if ($index) { }
4677  ***      0      0      0   if (not exists $col_posn{$col})
4698  ***      0      0      0   if ($$tbl{'is_nullable'}{$col}) { }
4718  ***      0      0      0   unless $args{$arg}
4723  ***      0      0      0   unless @sel_cols
4728  ***      0      0      0   unless $$ins_tbl{'is_col'}{$sel_cols[$i]}
4741  ***      0      0      0   defined $_ ? :
4785  ***      0      0      0   if ($EVAL_ERROR)
4786  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
4796  ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
4801  ***      0      0      0   if ($$args{'skip_callback'})
4809  ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
4811  ***      0      0      0   unless not $$_{'master_id'}
4828  ***      0      0      0   if ($method) { }
4833  ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
4847  ***      0      0      0   if @slaves
4865  ***      0      0      0   if ($host eq 'localhost')
4882  ***      0      0      0   if (@slaves)
4887  ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
4907  ***      0      0      0   if (not $proc)
4924  ***      0      0      0   unless my $master_status = $self->get_master_status($master)
4926  ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
4928  ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
4932  ***      0      0      0   if ($port != $$slave_status{'master_port'})
4937  ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
4942  ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
4949  ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
4962  ***      0      0      0   unless my $master = $self->get_slave_status($dbh)
4969  ***      0      0      0   if (not $$self{'not_a_slave'}{$dbh})
4976  ***      0      0      0   if ($ss and %$ss)
4988  ***      0      0      0   if (not $$self{'not_a_master'}{$dbh})
4995  ***      0      0      0   if ($ms and %$ms)
4997  ***      0      0      0   if ($$ms{'file'} and $$ms{'position'})
5010  ***      0      0      0   unless defined $time
5014  ***      0      0      0   if ($ms) { }
5018  ***      0      0      0   defined $result ? :
5020  ***      0      0      0   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
5040  ***      0      0      0   if ($pos) { }
5064  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
5070  ***      0      0      0   if ($EVAL_ERROR)
5072  ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
5074  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
5079  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
5103  ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
5115  ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
5138  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5142  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5147  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
5161  ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
5176  ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
5187  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
5191  ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5195  ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5197  ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
5200  ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
5202  ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
5214  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
5226  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
5230  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
5234  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
5237  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
5240  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
5244  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
5246  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
5254  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
5268  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
5279  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
5301  ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
5329  ***      0      0      0   if ($$dsn{'master_host'}) { }
5337  ***      0      0      0   ($port || 3306) == 3306 ? :
5348  ***      0      0      0   defined $_ ? :
5377  ***      0      0      0   unless $args{$arg}
5380  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
5396  ***      0      0      0   unless defined(my $pid = fork)
5397  ***      0      0      0   if ($pid)
5404  ***      0      0      0   unless POSIX::setsid()
5405  ***      0      0      0   unless chdir '/'
5411  ***      0      0      0   if (-t STDIN)
5413  ***      0      0      0   unless open STDIN, '/dev/null'
5417  ***      0      0      0   if ($$self{'log_file'}) { }
5419  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
5423  ***      0      0      0   unless open STDERR, '>&STDOUT'
5427  ***      0      0      0   if (-t STDOUT)
5429  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
5432  ***      0      0      0   if (-t STDERR)
5434  ***      0      0      0   unless open STDERR, '>', '/dev/null'
5445  ***      0      0      0   $self ? :
5447  ***      0      0      0   if ($PID_file and -f $PID_file) { }
5450  ***      0      0      0   if $EVAL_ERROR
5452  ***      0      0      0   if ($pid) { }
5454  ***      0      0      0   if ($pid_is_alive) { }
5476  ***      0      0      0   if (exists $$self{'child'})
5488  ***      0      0      0   if (not $PID_file)
5495  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
5497  ***      0      0      0   unless print $PID_FH $PID
5499  ***      0      0      0   unless close $PID_FH
5508  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
5509  ***      0      0      0   unless unlink $$self{'PID_file'}
5521  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
5527  ***      0      0      0   defined $_ ? :
5558  ***      0      0      0   unless $args{$arg}
5577  ***      0      0      0   if $o->has('databases')
5579  ***      0      0      0   if $o->has('ignore-databases')
5582  ***      0      0      0   if ($o->has('databases-regex') and my $p = $o->get('databases-regex'))
5586  ***      0      0      0   if ($o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex'))
5590  ***      0      0      0   if (@permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex)
5591  ***      0      0      0   @permit_dbs ? :
      ***      0      0      0   @reject_dbs ? :
      ***      0      0      0   @dbs_regex ? :
      ***      0      0      0   @reject_dbs_regex ? :
5600  ***      0      0      0   if ($o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex'))
5610  ***      0      0      0   if ($o->get('tables'))
5613  ***      0      0      0   if ($_ =~ /\./) { }
5623  ***      0      0      0   if (@permit_qtbls)
5633  ***      0      0      0   if ($o->get('ignore-tables'))
5636  ***      0      0      0   if ($_ =~ /\./) { }
5646  ***      0      0      0   if (@reject_qtbls and not $have_qtbl)
5652  ***      0      0      0   if (keys %permit_qtbls and not @permit_dbs)
5660  ***      0      0      0   if (keys %$dbs)
5667  ***      0      0      0   if ($o->has('tables-regex') and my $p = $o->get('tables-regex'))
5671  ***      0      0      0   if ($o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex'))
5680  ***      0      0      0   if ($o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines'))
5699  ***      0      0      0   if (@permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs)
5701  ***      0      0      0   @permit_tbls ? :
      ***      0      0      0   @reject_tbls ? :
      ***      0      0      0   @tbls_regex ? :
      ***      0      0      0   @reject_tbls_regex ? :
      ***      0      0      0   @permit_qtbls ? :
      ***      0      0      0   @reject_qtbls ? :
      ***      0      0      0   @get_eng ? :
      ***      0      0      0   @permit_engs ? :
      ***      0      0      0   @reject_engs ? :
5722  ***      0      0      0   unless my $filter_sub = eval $code
5739  ***      0      0      0   unless $args{$arg}
5748  ***      0      0      0   $filter ? :
5750  ***      0      0      0   if $_ =~ /information_schema|lost\+found/
5765  ***      0      0      0   unless $args{$arg}
5771  ***      0      0      0   if ($db) { }
5781  ***      0      0      0   $filter ? :
5782  ***      0      0      0   if (not $views)
5783  ***      0      0      0   if ($type || '') eq 'VIEW'
5803  ***      0      0      0   if (scalar keys %$objs)
5804  ***      0      0      0   $lc ? :
5813  ***      0      0      0   defined $_ ? :
5875  ***      0      0      0   if ($o->get('replicate') or $o->get('sync-to-master'))
5876  ***      0      0      0   unless $o->got('wait')
5878  ***      0      0      0   if ($o->get('wait'))
5879  ***      0      0      0   unless $o->got('lock')
5881  ***      0      0      0   if ($o->get('dry-run'))
5897  ***      0      0      0   if $$dsn{'t'} and not $$dsn{'D'}
5899  ***      0      0      0   if ($$dsn{'D'} and not $$dsn{'t'})
5907  ***      0      0      0   if (not @dsns or @dsns == 1 and not $o->get('replicate') and not $o->get('sync-to-master'))
5913  ***      0      0      0   if (@dsns > 1 and $o->get('sync-to-master') and $o->get('replicate'))
5918  ***      0      0      0   if ($o->get('lock-and-rename'))
5919  ***      0      0      0   if (@dsns != 2 or not $dsns[0]{'t'} or not $dsns[1]{'t'})
5925  ***      0      0      0   if ($o->get('explain-hosts'))
5938  ***      0      0      0   if ($o->get('pid'))
5986  ***      0      0      0   if $EVAL_ERROR
5997  ***      0      0      0   if ($o->get('sync-to-master'))
6000  ***      0      0      0   unless my $master = $ms->get_master_dsn($dsns[0]{'dbh'}, $dsns[0], $dp)
6004  ***      0      0      0   if ($o->get('check-master'))
6016  ***      0      0      0   if ($o->get('dry-run'))
6023  ***      0      0      0   if ($o->get('lock-and-rename')) { }
      ***      0      0      0   elsif ($dsns[0]{'t'}) { }
      ***      0      0      0   elsif ($o->get('replicate')) { }
6048  ***      0      0      0   unless $args{$arg}
6071  ***      0      0      0   if ($o->get('verbose'))
6120  ***      0      0      0   unless $args{$arg}
6145  ***      0      0      0   if ($o->get('verbose'))
6146  ***      0      0      0   $o->get('dry-run') ? :
6174  ***      0      0      0   unless $args{$arg}
6201  ***      0      0      0   if ($o->get('sync-to-master')) { }
6226  ***      0      0      0   if ($o->get('verbose'))
6227  ***      0      0      0   $o->get('dry-run') ? :
6234  ***      0      0      0   if (@diffs) { }
6271  ***      0      0      0   if (not $level) { }
6285  ***      0      0      0   if ($o->get('verbose'))
6286  ***      0      0      0   $o->get('dry-run') ? :
6293  ***      0      0      0   if (@diffs) { }
6340  ***      0      0      0   unless $args{$arg}
6380  ***      0      0      0   if ($o->get('verbose'))
6381  ***      0      0      0   $o->get('dry-run') ? :
6420  ***      0      0      0   unless $args{$arg}
6424  ***      0      0      0   unless $o->get('lock') and $o->get('lock') == 3
6437  ***      0      0      0   if ($EVAL_ERROR)
6447  ***      0      0      0   unless $args{$arg}
6451  ***      0      0      0   unless $o->get('lock') and $o->get('lock') == 3
6474  ***      0      0      0   if ($EVAL_ERROR)
6489  ***      0      0      0   unless $args{$arg}
6501  ***      0      0      0   $$tbl_struct{'engine'} eq 'InnoDB' ? :
      ***      0      0      0   $o->got('transaction') ? :
6514  ***      0      0      0   unless $o->get('columns')
6520  ***      0      0      0   if ($o->get('print') and $o->get('verbose') >= 2)
6530  ***      0      0      0   $o->get('buffer-to-client') ? :
6570  ***      0      0      0   if (sum @status{@ChangeHandler::ACTIONS})
6575  ***      0      0      0   if ($EVAL_ERROR)
6581  ***      0      0      0   if ($o->get('verbose'))
6582  ***      0      0      0   unless $_
6595  ***      0      0      0   unless $args{$arg}
6601  ***      0      0      0   if ($o->get('sync-to-master') or $o->get('replicate')) { }
      ***      0      0      0   elsif ($o->get('check-slave')) { }
6606  ***      0      0      0   unless $can_replace
6626  ***      0      0      0   if ($slave_status and $sql_log_bin and ($log_bin || 'OFF') eq 'ON')
6641  ***      0      0      0   unless $args{$arg}
6646  ***      0      0      0   if ($o->get('execute'))
6654  ***      0      0      0   if ($o->get('print'))
6658  ***      0      0      0   unless print @_, ";\n"
6668  ***      0      0      0   if not defined $msg
6671  ***      0      0      0   if ($database and $table)
6674  ***      0      0      0   if ($host)
6684  ***      0      0      0   unless $args{$arg}
6688  ***      0      0      0   if (not $$dsn{'p'} and $o->get('ask-pass'))
6696  ***      0      0      0   if (not $o->get('bin-log'))
6701  ***      0      0      0   if (not $o->get('unique-checks'))
6706  ***      0      0      0   if (not $o->get('foreign-key-checks'))
6726  ***      0      0      0   unless $args{$arg}
6742  ***      0      0      0   if $EVAL_ERROR
6751  ***      0      0      0   if $EVAL_ERROR
6761  ***      0      0      0   if ($o->get('check-privileges'))
6763  ***      0      0      0   if (not $syncer->have_all_privs($$src{'dbh'}, $$src{'db'}, $$src{'tbl'}))
6767  ***      0      0      0   if (not $syncer->have_all_privs($$dst{'dbh'}, $$dst{'db'}, $$dst{'tbl'}))
6774  ***      0      0      0   if ($o->get('check-triggers'))
6776  ***      0      0      0   if (not defined $$dst{'supports_triggers'})
6779  ***      0      0      0   if ($$dst{'supports_triggers'} and $du->get_triggers($$dst{'dbh'}, $q, $$dst{'db'}, $$dst{'tbl'})) { }
6794  ***      0      0      0   if not $$skip_table{$$_{'db'}}{$$_{'tbl'}} and !$databases || $$databases{$$_{'db'}}
6806  ***      0      0      0   unless $dbh
6807  ***      0      0      0   unless $$dbh{'AutoCommit'}
6819  ***      0      0      0   if $src_sql
6820  ***      0      0      0   if $dst_sql
6826  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
2617  ***      0      0      0   $args{'exact'} and scalar @candidate_cols

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
257   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
262   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
401   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
430   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
437   ***      0      0      0      0   @ARGV and $$self{'strict'}
521   ***      0      0      0      0   $opt and $$opt{'type'}
524   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
589   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
597   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
611   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
700   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
794   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1038  ***     66    184    184      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33    368      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1160  ***     66     46      0     46   not $dbh and $tries--
1196  ***     33     46      0      0   not $dbh and $EVAL_ERROR
1672  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
1710  ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
1741  ***      0      0      0      0   $engine =~ /InnoDB/i and not $clustered_key
1743  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
1767  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
1868  ***      0      0      0      0   $left_done && $right_done
1869  ***      0      0      0      0   !$lr && !$left_done
1879  ***      0      0      0      0   !$rr && !$right_done
1890  ***      0      0      0      0   $lr and $rr
1895  ***      0      0      0      0   $lr and $rr
      ***      0      0      0      0   $lr and $rr and defined $cmp
      ***      0      0      0      0   $lr and $rr and defined $cmp and $cmp == 0
      ***      0      0      0      0   defined $cmp and $cmp < 0
1914  ***      0      0      0      0   $done and &$done($left, $right)
1946  ***      0      0      0      0   $coll and $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/
2065  ***      0      0      0      0   $trgs and @$trgs
2111  ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
2354  ***      0      0      0      0   $$self{'replace'} && $action ne 'DELETE'
2389  ***      0      0      0      0   $queue_level and $queue_level < $$self{'queue'}
2408  ***      0      0      0      0   not $error_count++ and $EVAL_ERROR =~ /$DUPE_KEY/
2595  ***      0      0      0      0   defined $_ and next
2598  ***      0      0      0      0   $$index{'is_unique'} and @{$$index{'cols'};} == 1
2851  ***      0      0      0      0   $args{'where'} and grep {$_;} @{$args{'where'};}
2993  ***      0      0      0      0   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
3013  ***      0      0      0      0   $type eq 'bigint' and $length < 20
3027  ***      0      0      0      0   $alg and not $ALGOS{$alg}
3044  ***      0      0      0      0   $alg and grep {$_ eq $alg;} @choices
3049  ***      0      0      0      0   $args{'count'} and grep {$_ ne 'CHECKSUM';} @choices
3060  ***      0      0      0      0   $ALGOS{$algorithm} && $ALGOS{$algorithm}{'hash'}
3070  ***      0      0      0      0   @funcs and not $result
3079  ***      0      0      0      0   $EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/
3103  ***      0      0      0      0   $start < $crc_wid and $sliced ne $unsliced
3150  ***      0      0      0      0   defined $opt_slice and $opt_slice < @slices
3178  ***      0      0      0      0   $type =~ /float|double/ and $args{'float_precision'}
      ***      0      0      0      0   $type =~ /varchar/ and $args{'trim'}
3195  ***      0      0      0      0   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
3228  ***      0      0      0      0   $algorithm and $ALGOS{$algorithm}
3522  ***      0      0      0      0   $$self{'state'} == 0 && $$self{'chunk_num'} >= scalar @{$$self{'chunks'};}
3607  ***      0      0      0      0   $args{'chunk_index'} and $args{'chunk_index'} ne $nibble_index
3619  ***      0      0      0      0   $args{'src'} and $args{'src'}{'dbh'}
3635  ***      0      0      0      0   defined $n_rows and $n_rows <= 100
3758  ***      0      0      0      0   $$self{'cached_row'} and $$self{'cached_nibble'} == $$self{'nibble'}
3767  ***      0      0      0      0   $$self{'nibble'} == 0 and not $$self{'small_table'}
3886  ***      0      0      0      0   $$self{'state'} == 0 && $$self{'nibble'}
      ***      0      0      0      0   $$self{'state'} == 0 && $$self{'nibble'} && !$$self{'cached_row'}
4151  ***      0      0      0      0   $vp->version_ge($$src{'dbh'}, '4.0.9') && $vp->version_ge($$dst{'dbh'}, '4.0.9')
4154  ***      0      0      0      0   $plugin_args{'chunk_index'} and $args{'index_hint'}
4315  ***      0      0      0      0   $src_algo eq 'BIT_XOR' and not $crc_type =~ /int$/
4359  ***      0      0      0      0   $args{'lock'} and $args{'lock'} <= $args{'lock_level'}
4386  ***      0      0      0      0   $args{'lock'} and $args{'lock'} == $args{'lock_level'}
4475  ***      0      0      0      0   $privs =~ /select/ and $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/ and $can_delete
4624  ***      0      0      0      0   $type =~ /=/ and $end
4639  ***      0      0      0      0   $type =~ /=/ && $end
4796  ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
4976  ***      0      0      0      0   $ss and %$ss
4995  ***      0      0      0      0   $ms and %$ms
4997  ***      0      0      0      0   $$ms{'file'} and $$ms{'position'}
5020  ***      0      0      0      0   $stat < 0 and not $timeoutok
5161  ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
5296  ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
5301  ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
5447  ***      0      0      0      0   $PID_file and -f $PID_file
5508  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
5582  ***      0      0      0      0   $o->has('databases-regex') and my $p = $o->get('databases-regex')
5586  ***      0      0      0      0   $o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex')
5646  ***      0      0      0      0   @reject_qtbls and not $have_qtbl
5652  ***      0      0      0      0   keys %permit_qtbls and not @permit_dbs
5667  ***      0      0      0      0   $o->has('tables-regex') and my $p = $o->get('tables-regex')
5671  ***      0      0      0      0   $o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex')
5680  ***      0      0      0      0   $o->has('engines') and $o->get('engines')
      ***      0      0      0      0   $o->has('ignore-engines') and $o->get('ignore-engines')
5897  ***      0      0      0      0   $$dsn{'t'} and not $$dsn{'D'}
5899  ***      0      0      0      0   $$dsn{'D'} and not $$dsn{'t'}
5907  ***      0      0      0      0   @dsns == 1 and not $o->get('replicate')
      ***      0      0      0      0   @dsns == 1 and not $o->get('replicate') and not $o->get('sync-to-master')
5913  ***      0      0      0      0   @dsns > 1 and $o->get('sync-to-master')
      ***      0      0      0      0   @dsns > 1 and $o->get('sync-to-master') and $o->get('replicate')
6424  ***      0      0      0      0   $o->get('lock') and $o->get('lock') == 3
6451  ***      0      0      0      0   $o->get('lock') and $o->get('lock') == 3
6520  ***      0      0      0      0   $o->get('print') and $o->get('verbose') >= 2
6626  ***      0      0      0      0   $slave_status and $sql_log_bin
      ***      0      0      0      0   $slave_status and $sql_log_bin and ($log_bin || 'OFF') eq 'ON'
6671  ***      0      0      0      0   $database and $table
6688  ***      0      0      0      0   not $$dsn{'p'} and $o->get('ask-pass')
6779  ***      0      0      0      0   $$dst{'supports_triggers'} and $du->get_triggers($$dst{'dbh'}, $q, $$dst{'db'}, $$dst{'tbl'})
6794  ***      0      0      0      0   not $$skip_table{$$_{'db'}}{$$_{'tbl'}} and !$databases || $$databases{$$_{'db'}}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0     27   $ENV{'MKDEBUG'} || 0
62    ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
64    ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
106   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-table-sync/mk-table-sync'
247   ***      0      0      0   $$opt{'group'} ||= 'default'
529   ***      0      0      0   $s || 's'
538   ***      0      0      0   $prefix || ''
566   ***      0      0      0   $pre || ''
573   ***      0      0      0   $val || ''
576   ***      0      0      0   $val || ''
634   ***      0      0      0   $$self{'description'} || ''
702   ***      0      0      0   $s ||= 's'
728   ***      0      0      0   $$opt{'type'} || ''
876   ***     50      0     27   $ENV{'MKDEBUG'} || 0
948   ***     50      0     27   $ENV{'MKDEBUG'} || 0
1019  ***     50      0     46   $prev ||= {}
1020  ***     50      0     46   $defaults ||= {}
1093  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1106  ***     50      0     46   $self->prop('dbidriver') || ''
1110  ***      0      0      0   $$info{'D'} || ''
1116  ***     50      0     46   $$info{'D'} || ''
1138  ***     50     46      0   $opts ||= {}
1233  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1249  ***      0      0      0   $level ||= 0
1250  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1300  ***     50      0     27   $ENV{'MKDEBUG'} || 0
1349  ***     50      0     27   $ENV{'MKDEBUG'} || 0
1400  ***      0      0      0   $args{'where'} || '1=1'
1467  ***     50      0     27   $ENV{'MKDEBUG'} || 0
1686  ***      0      0      0   $engine || undef
1709  ***      0      0      0   $type || $special || 'BTREE'
1796  ***      0      0      0   $$tbl_struct{'engine'} || ''
1798  ***      0      0      0   $clustered_key ||= ''
1849  ***     50      0     27   $ENV{'MKDEBUG'} || 0
2012  ***     50      0     27   $ENV{'MKDEBUG'} || 0
2282  ***      0      0      0   $$_[1] || ''
2322  ***     50      0     27   $ENV{'MKDEBUG'} || 0
2566  ***     50      0     27   $ENV{'MKDEBUG'} || 0
2857  ***      0      0      0   $args{'index_hint'} || ''
2959  ***     50      0     27   $ENV{'MKDEBUG'} || 0
3165  ***      0      0      0   $args{'sep'} || '#'
3167  ***      0      0      0   $sep ||= '#'
3323  ***     50      0     27   $ENV{'MKDEBUG'} || 0
3458  ***      0      0      0   $$self{'index_hint'} || ''
3579  ***     50      0     27   $ENV{'MKDEBUG'} || 0
3769  ***      0      0      0   $explain_index || ''
3784  ***      0      0      0   $$self{'tbl_struct'}{'is_numeric'}{$$s{'scols'}[$i++]} || 0
3807  ***      0      0      0   $$self{'index_hint'} || ''
3815  ***      0      0      0   $$self{'tbl_struct'}{'is_numeric'}{$$s{'scols'}[$i++]} || 0
3842  ***      0      0      0   $$lr{'crc'} || 0
      ***      0      0      0   $$rr{'crc'} || 0
3938  ***     50      0     27   $ENV{'MKDEBUG'} || 0
3995  ***      0      0      0   $args{'where'} || '1=1'
4090  ***     50      0     27   $ENV{'MKDEBUG'} || 0
4132  ***      0      0      0   $args{'lock'} ||= 0
4133  ***      0      0      0   $args{'wait'} ||= 0
4134  ***      0      0      0   $args{'transaction'} ||= 0
4135  ***      0      0      0   $args{'timeout_ok'} ||= 0
4508  ***     50      0     27   $ENV{'MKDEBUG'} || 0
4767  ***     50      0     27   $ENV{'MKDEBUG'} || 0
4775  ***      0      0      0   $level ||= 0
4833  ***      0      0      0   $$dsn{'P'} || 3306
4942  ***      0      0      0   $$slave_status{'slave_io_state'} || ''
5288  ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
5337  ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
5372  ***     50      0     27   $ENV{'MKDEBUG'} || 0
5553  ***     50      0     27   $ENV{'MKDEBUG'} || 0
5783  ***      0      0      0   $type || ''
5839  ***     50      0     27   $ENV{'MKDEBUG'} || 0
6458  ***      0      0      0   $o->get('replicate') || 0
      ***      0      0      0   $o->get('timeout-ok') || 0
      ***      0      0      0   $o->get('transaction') || 0
      ***      0      0      0   $o->get('wait') || 0
6530  ***      0      0      0   $o->get('replace') || $o->get('replicate') || $o->get('sync-to-master') || 0
6626  ***      0      0      0   $log_bin || 'OFF'

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
61    ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
62    ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
524   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1129  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1130  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1131  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1132  ***      0      0      0      0   $$dsn{'u'} ||= $user
1133  ***      0      0      0      0   $$dsn{'D'} ||= $db
1560  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1639  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
1660  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
1709  ***      0      0      0      0   $type || $special
1873  ***      0      0      0      0   !$lr || $EVAL_ERROR
1883  ***      0      0      0      0   !$rr || $EVAL_ERROR
1894  ***      0      0      0      0   $lr or $rr
1895  ***      0      0      0      0   not $rr or defined $cmp and $cmp < 0
1928  ***      0      0      0      0   not defined $l or not defined $r
1946  ***      0      0      0      0   $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/
      ***      0      0      0      0   $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/
2123  ***      0      0      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2162  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2192  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2226  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2245  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2259  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2271  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2611  ***      0      0      0      0   $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2697  ***      0      0      0      0   not defined $end_point or $end_point < $start_point
2709  ***      0      0      0      0   $interval ||= $args{'chunk_size'}
2786  ***      0      0      0      0   $suffix or $args{'avg_row_length'}
3030  ***      0      0      0      0   $args{'where'} or $args{'chunk'}
      ***      0      0      0      0   $args{'where'} or $args{'chunk'} or $args{'replicate'}
      ***      0      0      0      0   $args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1')
3351  ***      0      0      0      0   $args{'chunk_col'} or $args{'chunk_index'}
3475  ***      0      0      0      0   $$lr{'cnt'} != $$rr{'cnt'} or $$lr{'crc'} ne $$rr{'crc'}
3842  ***      0      0      0      0   $$lr{'cnt'} != $$rr{'cnt'} or ($$lr{'crc'} || 0) ne ($$rr{'crc'} || 0)
4247  ***      0      0      0      0   not $cycle or not $plugin->pending_changes
4781  ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
4796  ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
4809  ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
4949  ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
4970  ***      0      0      0      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
4989  ***      0      0      0      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
5013  ***      0      0      0      0   $ms ||= $self->get_master_status($master)
5020  ***      0      0      0      0   $stat eq 'NULL' or $stat < 0 and not $timeoutok
5032  ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
5047  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
5115  ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
5176  ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
5214  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
5268  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
5521  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
5590  ***      0      0      0      0   @permit_dbs or @reject_dbs
      ***      0      0      0      0   @permit_dbs or @reject_dbs or @dbs_regex
      ***      0      0      0      0   @permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex
5600  ***      0      0      0      0   $o->has('tables') or $o->has('ignore-tables')
      ***      0      0      0      0   $o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex')
5680  ***      0      0      0      0   $o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines')
5699  ***      0      0      0      0   @permit_tbls or @reject_tbls
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs
5875  ***      0      0      0      0   $o->get('replicate') or $o->get('sync-to-master')
5907  ***      0      0      0      0   not @dsns or @dsns == 1 and not $o->get('replicate') and not $o->get('sync-to-master')
5919  ***      0      0      0      0   @dsns != 2 or not $dsns[0]{'t'}
      ***      0      0      0      0   @dsns != 2 or not $dsns[0]{'t'} or not $dsns[1]{'t'}
6056  ***      0      0      0      0   $$dsns[0]{'dbh'} || get_cxn($$dsns[0], %args)
6063  ***      0      0      0      0   $$dsns[1]{'dbh'} || get_cxn($$dsns[1], %args)
6127  ***      0      0      0      0   $dsns[0]{'dbh'} || get_cxn($dsns[0], %args)
6137  ***      0      0      0      0   $$dsn{'dbh'} || get_cxn($dsn, %args)
      ***      0      0      0      0   $$dsn{'D'} || $$src{'db'}
      ***      0      0      0      0   $$dsn{'t'} || $$src{'tbl'}
6184  ***      0      0      0      0   $$dsns[0]{'dbh'} || get_cxn($$dsns[0], %args)
6202  ***      0      0      0      0   $$dsns[1]{'dbh'} || get_cxn($$dsns[1], %args)
6347  ***      0      0      0      0   $dsns[0]{'dbh'} || get_cxn($dsns[0], %args)
6388  ***      0      0      0      0   $$dsn{'dbh'} || get_cxn($dsn, %args)
6455  ***      0      0      0      0   $$src{'dbh'} ||= get_cxn($$src{'dsn'}, %args)
6456  ***      0      0      0      0   $$dst{'dbh'} ||= get_cxn($$dst{'dsn'}, %args)
6457  ***      0      0      0      0   $$src{'misc_dbh'} ||= get_cxn($$src{'dsn'}, %args)
6530  ***      0      0      0      0   $o->get('replace') || $o->get('replicate')
      ***      0      0      0      0   $o->get('replace') || $o->get('replicate') || $o->get('sync-to-master')
6543  ***      0      0      0      0   $args{'where'} || $o->get('where')
      ***      0      0      0      0   $o->get('replicate') || $o->get('sync-to-master')
6601  ***      0      0      0      0   $o->get('sync-to-master') or $o->get('replicate')
6794  ***      0      0      0      0   $$tables{$$_{'tbl'}} or $$tables{"$$_{'db'}.$$_{'tbl'}"}
      ***      0      0      0      0   not $tables or ($$tables{$$_{'tbl'}} or $$tables{"$$_{'db'}.$$_{'tbl'}"})
      ***      0      0      0      0   !$databases || $$databases{$$_{'db'}}


Covered Subroutines
-------------------

Subroutine                   Count Location                                                 
---------------------------- ----- ---------------------------------------------------------
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1295
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1296
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1298
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1300
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1344
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1345
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1347
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1349
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1459
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1460
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1461
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1462
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1467
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1842
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1843
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1847
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1849
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2007
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2008
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2010
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2012
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:23  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2312
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2313
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2317
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2322
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:24  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2553
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2554
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2558
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2559
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2560
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2561
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2566
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2954
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2955
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2956
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2957
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2959
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3313
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3314
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3316
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3317
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3318
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3323
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:35  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3569
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3570
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3572
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3573
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3574
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3579
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:36  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:38  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:39  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3933
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3934
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3936
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3938
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:40  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4081
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4082
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4084
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4085
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4090
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:42  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4503
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4504
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4506
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4508
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4756
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4757
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4761
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4762
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4763
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4767
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5366
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5367
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5369
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5370
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5372
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5544
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5545
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5547
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5548
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5553
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5835
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5836
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5837
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5839
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:869 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:870 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:874 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:876 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:936 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:937 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:938 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:939 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:948 
get_cxn_params                  46 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1103
get_dbh                         46 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1137
new                             10 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1303
new                             24 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:951 
parse                           46 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1013
parse                            2 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1308
prop                           138 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1004
version_ge                       1 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1315

Uncovered Subroutines
---------------------

Subroutine                   Count Location                                                 
---------------------------- ----- ---------------------------------------------------------
DESTROY                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5520
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:425 
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5757
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5796
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6268
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6649
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6658
__get_boundaries                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3740
__get_explain_index              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3826
__make_boundary_sql              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3802
__queue                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2377
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1277
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1326
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1441
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1826
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1989
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2296
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2537
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2936
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3295
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3551
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3915
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4063
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4485
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4740
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5347
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5526
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5812
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6825
_d                               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:853 
_find_slaves_by_hosts            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4875
_find_slaves_by_processlist      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4855
_get_participants                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:325 
_make_PID_file                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5485
_make_filter                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5801
_parse_specs                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:211 
_pod_to_specs                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:105 
_read_config_file                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:777 
_remove_PID_file                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5507
_set_option                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:371 
_use_db                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2103
_validate_type                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:520 
as_string                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1077
best_algorithm                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3023
calculate_chunks                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2647
can_sync                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1365
can_sync                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3339
can_sync                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3595
can_sync                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3954
catchup_to_master                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5055
catchup_to_same_pos              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5096
change                           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2351
change_master_to                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5125
check_PID_file                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5444
check_table                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1618
choose_hash_func                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3064
clone                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:830 
compare_sets                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1859
copy                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1259
crc32                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2977
daemonize                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5393
db_cmp                           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1967
descr                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:633 
detach_slave                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5277
disconnect                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1242
disconnect                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6802
done                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1426
done                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3517
done                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3883
done                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4048
done_with_rows                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1421
done_with_rows                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3502
done_with_rows                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3868
done_with_rows                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4043
dump                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2046
errors                           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:623 
fetch_back                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2337
fill_in_dsn                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1125
filter_diffs                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6793
find_best_index                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1572
find_chunk_columns               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2584
find_possible_keys               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1590
find_replication_differences     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3274
find_slave_hosts                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4825
generate_asc_stmt                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4521
generate_cmp_where               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4584
generate_del_stmt                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4654
generate_ins_stmt                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4716
get                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:587 
get_best_plugin                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4103
get_change_dbh                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6591
get_changes                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2505
get_columns                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2160
get_connected_slaves             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4902
get_crc_type                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3003
get_crc_wid                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2991
get_create_table                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2122
get_cxn                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6681
get_databases                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2225
get_db_itr                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5736
get_defaults                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:361 
get_defaults_files               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:100 
get_engine                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1683
get_first_chunkable_column       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2752
get_fks                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1757
get_groups                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:366 
get_hostname                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1232
get_keys                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1690
get_master_dsn                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4961
get_master_status                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4987
get_opts                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:388 
get_range_statistics             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2798
get_slave_lag                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5316
get_slave_status                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4968
get_specs                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:93  
get_sql                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1397
get_sql                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3447
get_sql                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3712
get_sql                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3993
get_table_list                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2270
get_table_status                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2244
get_tbl_itr                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5762
get_tmp_table                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2180
get_triggers                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2191
got                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:595 
has                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:603 
has_slave_updates                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5292
have_all_privs                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4461
inject_chunks                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2840
is_hash_algorithm                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3059
is_master_of                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4923
key_cmp                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1921
key_cols                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1431
key_cols                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3538
key_cols                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3902
key_cols                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4053
literal_like                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:919 
lock_and_rename                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6044
lock_and_wait                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4377
lock_server                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6418
lock_table                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4343
main                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5844
make_DELETE                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2423
make_INSERT                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2458
make_PID_file                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5475
make_REPLACE                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2467
make_UPDATE                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2431
make_action_subs                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6638
make_checksum_queries            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4275
make_checksum_query              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3217
make_filter                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5569
make_row                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2473
make_row_checksum                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3161
make_sibling_of_master           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5136
make_slave_of_sibling            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5184
make_slave_of_uncle              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5223
make_where_clause                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2495
make_xor_slices                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3132
name                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1361
name                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3335
name                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3591
name                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3950
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1352
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1471
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1852
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2039
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2325
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2569
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2968
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3326
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3582
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3941
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4093
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4511
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4770
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5375
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5556
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:56  
new                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:879 
not_in_left                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1416
not_in_left                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3495
not_in_left                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3862
not_in_left                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4034
not_in_right                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1411
not_in_right                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3488
not_in_right                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3856
not_in_right                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4025
ok_to_sync                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6722
optimize_xor                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3091
opts                             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:337 
parse                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1482
parse_options                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1064
pending_changes                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1436
pending_changes                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3526
pending_changes                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3890
pending_changes                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4058
pos_cmp                          0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5322
pos_to_string                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5341
prepare_sync_cycle               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1392
prepare_sync_cycle               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3439
prepare_sync_cycle               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3704
prepare_sync_cycle               0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3988
prepare_to_sync                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1369
prepare_to_sync                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3385
prepare_to_sync                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3650
prepare_to_sync                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3958
print_active_handles             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1248
print_err                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6667
print_errors                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:657 
print_sql                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6818
print_usage                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:667 
process_rows                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2386
prompt                           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:628 
prompt_noecho                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:742 
quote                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2835
quote                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:884 
quote_val                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:892 
range_date                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2896
range_datetime                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2903
range_num                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2870
range_time                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2889
range_timestamp                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2911
read_para_after                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:811 
recurse_to_slaves                0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4774
remove_auto_increment            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1786
remove_secondary_indexes         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1792
repl_posn                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5300
same_row                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1406
same_row                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3474
same_row                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3841
same_row                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4004
save_error                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:618 
set                              0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:609 
set_checksum_queries             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1388
set_checksum_queries             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3430
set_checksum_queries             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3695
set_checksum_queries             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3984
set_defaults                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:349 
set_filter                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5729
short_host                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5327
short_opts                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:343 
size_to_rows                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2761
slave_is_running                 0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5287
sort_cols                        0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2510
sort_indexes                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1553
split_unquote                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:908 
start_slave                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5039
stop_slave                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5031
sync_a_table                     0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6485
sync_all                         0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6336
sync_one_table                   0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6116
sync_table                       0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4121
sync_via_replication             0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6170
take_action                      0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2343
timestampdiff                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:2918
unlock                           0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:4351
unlock_server                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:6444
usage                            0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1086
usage_or_errors                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:644 
uses_checksum                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:1384
uses_checksum                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3426
uses_checksum                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3691
uses_checksum                    0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:3980
wait_for_master                  0 /home/daniel/dev/maatkit/mk-table-sync/mk-table-sync:5008


