---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...how-grants/mk-show-grants   47.3   34.3   36.4   56.6    n/a  100.0   42.9
Total                          47.3   34.3   36.4   56.6    n/a  100.0   42.9
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:30:48 2010
Finish:       Thu Jan 28 22:30:48 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:30:49 2010
Finish:       Thu Jan 28 22:30:50 2010

Run:          ./102_all_grants.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:30:52 2010
Finish:       Thu Jan 28 22:30:53 2010

Run:          ./103_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:30:55 2010
Finish:       Thu Jan 28 22:30:55 2010

Run:          ./201_issue_445.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:30:58 2010
Finish:       Thu Jan 28 22:30:58 2010

/home/daniel/dev/maatkit/mk-show-grants/mk-show-grants

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # mk-show-grants canonicalizes and prints MySQL grants so you can effectively
4                                                     # replicate, compare and version-control them.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
26                                                    
27             4                    4            47   use strict;
               4                                 10   
               4                                 32   
28             4                    4            34   use warnings FATAL => 'all';
               4                                 12   
               4                                 30   
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 5266
32                                                    # ###########################################################################
33                                                    package OptionParser;
34                                                    
35             4                    4            27   use strict;
               4                                 11   
               4                                 18   
36             4                    4            24   use warnings FATAL => 'all';
               4                                 11   
               4                                 19   
37                                                    
38             4                    4            59   use Getopt::Long;
               4                                 16   
               4                                 32   
39             4                    4            35   use List::Util qw(max);
               4                                 12   
               4                                 53   
40             4                    4            26   use English qw(-no_match_vars);
               4                                 10   
               4                                 28   
41                                                    
42    ***      4            50      4            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 19   
               4                                 81   
43                                                    
44                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
45                                                    
46                                                    my %attributes = (
47                                                       'type'       => 1,
48                                                       'short form' => 1,
49                                                       'group'      => 1,
50                                                       'default'    => 1,
51                                                       'cumulative' => 1,
52                                                       'negatable'  => 1,
53                                                    );
54                                                    
55                                                    sub new {
56             6                    6            49      my ( $class, %args ) = @_;
57             6                                 41      foreach my $arg ( qw(description) ) {
58    ***      6     50                          51         die "I need a $arg argument" unless $args{$arg};
59                                                       }
60             6                                 93      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
61    ***      6            33                   30      $program_name ||= $PROGRAM_NAME;
62    ***      6            33                   68      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
63                                                    
64    ***      6     50     50                  344      my $self = {
      ***                   50                        
65                                                          description    => $args{description},
66                                                          prompt         => $args{prompt} || '<options>',
67                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
68                                                          dp             => $args{dp}     || undef,
69                                                          program_name   => $program_name,
70                                                          opts           => {},
71                                                          got_opts       => 0,
72                                                          short_opts     => {},
73                                                          defaults       => {},
74                                                          groups         => {},
75                                                          allowed_groups => {},
76                                                          errors         => [],
77                                                          rules          => [],  # desc of rules for --help
78                                                          mutex          => [],  # rule: opts are mutually exclusive
79                                                          atleast1       => [],  # rule: at least one opt is required
80                                                          disables       => {},  # rule: opt disables other opts 
81                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
82                                                          default_files  => [
83                                                             "/etc/maatkit/maatkit.conf",
84                                                             "/etc/maatkit/$program_name.conf",
85                                                             "$home/.maatkit.conf",
86                                                             "$home/.$program_name.conf",
87                                                          ],
88                                                       };
89             6                                105      return bless $self, $class;
90                                                    }
91                                                    
92                                                    sub get_specs {
93             6                    6            27      my ( $self, $file ) = @_;
94             6                                 45      my @specs = $self->_pod_to_specs($file);
95             6                                161      $self->_parse_specs(@specs);
96             6                                 31      return;
97                                                    }
98                                                    
99                                                    sub get_defaults_files {
100            6                    6            25      my ( $self ) = @_;
101            6                                 18      return @{$self->{default_files}};
               6                                 76   
102                                                   }
103                                                   
104                                                   sub _pod_to_specs {
105            6                    6            26      my ( $self, $file ) = @_;
106   ***      6            50                   37      $file ||= __FILE__;
107   ***      6     50                         256      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
108                                                   
109            6                                109      my %types = (
110                                                         string => 's', # standard Getopt type
111                                                         'int'  => 'i', # standard Getopt type
112                                                         float  => 'f', # standard Getopt type
113                                                         Hash   => 'H', # hash, formed from a comma-separated list
114                                                         hash   => 'h', # hash as above, but only if a value is given
115                                                         Array  => 'A', # array, similar to Hash
116                                                         array  => 'a', # array, similar to hash
117                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
118                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
119                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
120                                                      );
121            6                                 24      my @specs = ();
122            6                                 20      my @rules = ();
123            6                                 16      my $para;
124                                                   
125            6                                 47      local $INPUT_RECORD_SEPARATOR = '';
126            6                                155      while ( $para = <$fh> ) {
127         1374    100                        8860         next unless $para =~ m/^=head1 OPTIONS/;
128            6                                 35         last;
129                                                      }
130                                                   
131            6                                 58      while ( $para = <$fh> ) {
132   ***      6     50                          37         last if $para =~ m/^=over/;
133   ***      0                                  0         chomp $para;
134   ***      0                                  0         $para =~ s/\s+/ /g;
135   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
136   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
137   ***      0                                  0         push @rules, $para;
138                                                      }
139                                                   
140   ***      6     50                          27      die 'POD has no OPTIONS section' unless $para;
141                                                   
142            6                                 22      do {
143          138    100                        1222         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
144          132                                352            chomp $para;
145          132                                283            MKDEBUG && _d($para);
146          132                                320            my %attribs;
147                                                   
148          132                                462            $para = <$fh>; # read next paragraph, possibly attributes
149                                                   
150          132    100                        1389            if ( $para =~ m/: / ) { # attributes
151           90                                424               $para =~ s/\s+\Z//g;
152          144                                652               %attribs = map {
153           90                                435                     my ( $attrib, $val) = split(/: /, $_);
154   ***    144     50                         625                     die "Unrecognized attribute for --$option: $attrib"
155                                                                        unless $attributes{$attrib};
156          144                               1583                     ($attrib, $val);
157                                                                  } split(/; /, $para);
158           90    100                         412               if ( $attribs{'short form'} ) {
159           48                                228                  $attribs{'short form'} =~ s/-//;
160                                                               }
161           90                                444               $para = <$fh>; # read next paragraph, probably short help desc
162                                                            }
163                                                            else {
164           42                                101               MKDEBUG && _d('Option has no attributes');
165                                                            }
166                                                   
167          132                                896            $para =~ s/\s+\Z//g;
168          132                                886            $para =~ s/\s+/ /g;
169          132                                540            $para =~ s/$POD_link_re/$1/go;
170                                                   
171          132                                510            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
172          132                                287            MKDEBUG && _d('Short help:', $para);
173                                                   
174   ***    132     50                         549            die "No description after option spec $option" if $para =~ m/^=item/;
175                                                   
176          132    100                         616            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
177           12                                 43               $option = $base_option;
178           12                                 49               $attribs{'negatable'} = 1;
179                                                            }
180                                                   
181          132    100                        5388            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
182                                                               spec  => $option
183                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
184                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
185                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
186                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
187                                                               desc  => $para
188                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
189                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
190                                                            };
191                                                         }
192          138                                857         while ( $para = <$fh> ) {
193   ***    180     50                         594            last unless $para;
194                                                   
195                                                   
196          180    100                         700            if ( $para =~ m/^=head1/ ) {
197            6                                 25               $para = undef; # Can't 'last' out of a do {} block.
198            6                                 32               last;
199                                                            }
200          174    100                        1106            last if $para =~ m/^=item --/;
201                                                         }
202                                                      } while ( $para );
203                                                   
204   ***      6     50                          31      die 'No valid specs in POD OPTIONS' unless @specs;
205                                                   
206            6                                126      close $fh;
207            6                                 27      return @specs, @rules;
208                                                   }
209                                                   
210                                                   sub _parse_specs {
211            6                    6            52      my ( $self, @specs ) = @_;
212            6                                 24      my %disables; # special rule that requires deferred checking
213                                                   
214            6                                 38      foreach my $opt ( @specs ) {
215   ***    132     50                         465         if ( ref $opt ) { # It's an option spec, not a rule.
216                                                            MKDEBUG && _d('Parsing opt spec:',
217          132                                291               map { ($_, '=>', $opt->{$_}) } keys %$opt);
218                                                   
219          132                                942            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
220   ***    132     50                         537            if ( !$long ) {
221   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
222                                                            }
223          132                                447            $opt->{long} = $long;
224                                                   
225   ***    132     50                         573            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
226          132                                571            $self->{opts}->{$long} = $opt;
227                                                   
228   ***    132     50                         515            if ( length $long == 1 ) {
229   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
230   ***      0                                  0               $self->{short_opts}->{$long} = $long;
231                                                            }
232                                                   
233          132    100                         431            if ( $short ) {
234   ***     48     50                         222               die "Duplicate short option -$short"
235                                                                  if exists $self->{short_opts}->{$short};
236           48                                230               $self->{short_opts}->{$short} = $long;
237           48                                163               $opt->{short} = $short;
238                                                            }
239                                                            else {
240           84                                288               $opt->{short} = undef;
241                                                            }
242                                                   
243          132    100                         658            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
244   ***    132     50                         626            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
245   ***    132     50                         693            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
246                                                   
247   ***    132            50                  522            $opt->{group} ||= 'default';
248          132                                609            $self->{groups}->{ $opt->{group} }->{$long} = 1;
249                                                   
250          132                                411            $opt->{value} = undef;
251          132                                406            $opt->{got}   = 0;
252                                                   
253          132                                666            my ( $type ) = $opt->{spec} =~ m/=(.)/;
254          132                                451            $opt->{type} = $type;
255          132                                288            MKDEBUG && _d($long, 'type:', $type);
256                                                   
257   ***    132     50     66                 1007            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
258   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
259                                                                  . "was given when this OptionParser object was created";
260                                                            }
261                                                   
262          132    100    100                  894            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
263                                                   
264          132    100                         731            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
265   ***     18     50                         108               $self->{defaults}->{$long} = defined $def ? $def : 1;
266           18                                 45               MKDEBUG && _d($long, 'default:', $def);
267                                                            }
268                                                   
269          132    100                         507            if ( $long eq 'config' ) {
270            6                                 40               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
271                                                            }
272                                                   
273   ***    132     50                         626            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
274   ***      0                                  0               $disables{$long} = $dis;
275   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
276                                                            }
277                                                   
278          132                                614            $self->{opts}->{$long} = $opt;
279                                                         }
280                                                         else { # It's an option rule, not a spec.
281   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
282   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
283   ***      0                                  0            my @participants = $self->_get_participants($opt);
284   ***      0                                  0            my $rule_ok = 0;
285                                                   
286   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
287   ***      0                                  0               $rule_ok = 1;
288   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
289   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
290                                                            }
291   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
292   ***      0                                  0               $rule_ok = 1;
293   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
294   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
295                                                            }
296   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
297   ***      0                                  0               $rule_ok = 1;
298   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
299   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
300                                                            }
301   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
302   ***      0                                  0               $rule_ok = 1;
303   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
304   ***      0                                  0               my @groups = split(',', $groups);
305   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
306   ***      0                                  0                  s/\s+//;
307   ***      0                                  0                  $_ => 1;
308                                                               } @groups;
309                                                            }
310                                                   
311   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
312                                                         }
313                                                      }
314                                                   
315            6                                 93      foreach my $long ( keys %disables ) {
316   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
317   ***      0                                  0         $self->{disables}->{$long} = \@participants;
318   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
319                                                      }
320                                                   
321            6                                 46      return; 
322                                                   }
323                                                   
324                                                   sub _get_participants {
325   ***      0                    0             0      my ( $self, $str ) = @_;
326   ***      0                                  0      my @participants;
327   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
328   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
329                                                            unless exists $self->{opts}->{$long};
330   ***      0                                  0         push @participants, $long;
331                                                      }
332   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
333   ***      0                                  0      return @participants;
334                                                   }
335                                                   
336                                                   sub opts {
337   ***      0                    0             0      my ( $self ) = @_;
338   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
339   ***      0                                  0      return %opts;
340                                                   }
341                                                   
342                                                   sub short_opts {
343   ***      0                    0             0      my ( $self ) = @_;
344   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
345   ***      0                                  0      return %short_opts;
346                                                   }
347                                                   
348                                                   sub set_defaults {
349   ***      0                    0             0      my ( $self, %defaults ) = @_;
350   ***      0                                  0      $self->{defaults} = {};
351   ***      0                                  0      foreach my $long ( keys %defaults ) {
352   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
353                                                            unless exists $self->{opts}->{$long};
354   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
355   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
356                                                      }
357   ***      0                                  0      return;
358                                                   }
359                                                   
360                                                   sub get_defaults {
361   ***      0                    0             0      my ( $self ) = @_;
362   ***      0                                  0      return $self->{defaults};
363                                                   }
364                                                   
365                                                   sub get_groups {
366   ***      0                    0             0      my ( $self ) = @_;
367   ***      0                                  0      return $self->{groups};
368                                                   }
369                                                   
370                                                   sub _set_option {
371           21                   21            94      my ( $self, $opt, $val ) = @_;
372   ***     21      0                          50      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
373                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
374                                                               : die "Getopt::Long gave a nonexistent option: $opt";
375                                                   
376           21                                 43      $opt = $self->{opts}->{$long};
377   ***     21     50                         160      if ( $opt->{is_cumulative} ) {
378   ***      0                                  0         $opt->{value}++;
379                                                      }
380                                                      else {
381           21                                 88         $opt->{value} = $val;
382                                                      }
383           21                                 69      $opt->{got} = 1;
384           21                                 77      MKDEBUG && _d('Got option', $long, '=', $val);
385                                                   }
386                                                   
387                                                   sub get_opts {
388            6                    6            29      my ( $self ) = @_; 
389                                                   
390            6                                 18      foreach my $long ( keys %{$self->{opts}} ) {
               6                                 63   
391          132                                512         $self->{opts}->{$long}->{got} = 0;
392   ***    132     50                        1010         $self->{opts}->{$long}->{value}
                    100                               
393                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
394                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
395                                                            : undef;
396                                                      }
397            6                                 39      $self->{got_opts} = 0;
398                                                   
399            6                                 29      $self->{errors} = [];
400                                                   
401   ***      6     50     33                   94      if ( @ARGV && $ARGV[0] eq "--config" ) {
402   ***      0                                  0         shift @ARGV;
403   ***      0                                  0         $self->_set_option('config', shift @ARGV);
404                                                      }
405   ***      6     50                          45      if ( $self->has('config') ) {
406            6                                 19         my @extra_args;
407            6                                 53         foreach my $filename ( split(',', $self->get('config')) ) {
408           24                                 73            eval {
409           24                                123               push @extra_args, $self->_read_config_file($filename);
410                                                            };
411   ***     24     50                         129            if ( $EVAL_ERROR ) {
412   ***     24     50                         111               if ( $self->got('config') ) {
413   ***      0                                  0                  die $EVAL_ERROR;
414                                                               }
415                                                               elsif ( MKDEBUG ) {
416                                                                  _d($EVAL_ERROR);
417                                                               }
418                                                            }
419                                                         }
420            6                                 36         unshift @ARGV, @extra_args;
421                                                      }
422                                                   
423            6                                168      Getopt::Long::Configure('no_ignore_case', 'bundling');
424                                                      GetOptions(
425          126                   21           990         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              21                                125   
             132                              13728   
426            6                                 53         grep   { $_->{long} ne 'config' } # --config is handled specially above.
427   ***      6     50                          22         values %{$self->{opts}}
428                                                      ) or $self->save_error('Error parsing options');
429                                                   
430   ***      6     50     33                  296      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
431   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
432                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
433                                                               or die "Cannot print: $OS_ERROR";
434   ***      0                                  0         exit 0;
435                                                      }
436                                                   
437   ***      6     50     33                   40      if ( @ARGV && $self->{strict} ) {
438   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
439                                                      }
440                                                   
441            6                                 18      foreach my $mutex ( @{$self->{mutex}} ) {
               6                                 44   
442   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
443   ***      0      0                           0         if ( @set > 1 ) {
444   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
445   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
446                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
447                                                                    . ' are mutually exclusive.';
448   ***      0                                  0            $self->save_error($err);
449                                                         }
450                                                      }
451                                                   
452            6                                 20      foreach my $required ( @{$self->{atleast1}} ) {
               6                                 34   
453   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
454   ***      0      0                           0         if ( @set == 0 ) {
455   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
456   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
457                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
458   ***      0                                  0            $self->save_error("Specify at least one of $err");
459                                                         }
460                                                      }
461                                                   
462            6                                 16      foreach my $long ( keys %{$self->{opts}} ) {
               6                                 73   
463          132                                492         my $opt = $self->{opts}->{$long};
464          132    100                         714         if ( $opt->{got} ) {
      ***            50                               
465   ***     21     50                          96            if ( exists $self->{disables}->{$long} ) {
466   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
467   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
468   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
469                                                                  'because', $long,'disables them');
470                                                            }
471                                                   
472   ***     21     50                         105            if ( exists $self->{allowed_groups}->{$long} ) {
473                                                   
474   ***      0                                  0               my @restricted_groups = grep {
475   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
476   ***      0                                  0               } keys %{$self->{groups}};
477                                                   
478   ***      0                                  0               my @restricted_opts;
479   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
480   ***      0                                  0                  RESTRICTED_OPT:
481   ***      0                                  0                  foreach my $restricted_opt (
482                                                                     keys %{$self->{groups}->{$restricted_group}} )
483                                                                  {
484   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
485   ***      0      0                           0                     push @restricted_opts, $restricted_opt
486                                                                        if $self->{opts}->{$restricted_opt}->{got};
487                                                                  }
488                                                               }
489                                                   
490   ***      0      0                           0               if ( @restricted_opts ) {
491   ***      0                                  0                  my $err;
492   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
493   ***      0                                  0                     $err = "--$restricted_opts[0]";
494                                                                  }
495                                                                  else {
496   ***      0                                  0                     $err = join(', ',
497   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
498   ***      0                                  0                               grep { $_ } 
499                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
500                                                                            )
501                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
502                                                                  }
503   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
504                                                               }
505                                                            }
506                                                   
507                                                         }
508                                                         elsif ( $opt->{is_required} ) { 
509   ***      0                                  0            $self->save_error("Required option --$long must be specified");
510                                                         }
511                                                   
512          132                                497         $self->_validate_type($opt);
513                                                      }
514                                                   
515            6                                 38      $self->{got_opts} = 1;
516            6                                 23      return;
517                                                   }
518                                                   
519                                                   sub _validate_type {
520          132                  132           493      my ( $self, $opt ) = @_;
521   ***    132    100     66                 1119      return unless $opt && $opt->{type};
522           78                                260      my $val = $opt->{value};
523                                                   
524   ***     78     50     66                 1915      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
                           100                        
                           100                        
525   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
526   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
527   ***      0      0                           0         if ( !$suffix ) {
528   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
529   ***      0             0                    0            $suffix = $s || 's';
530   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
531                                                               $opt->{long}, '(value:', $val, ')');
532                                                         }
533   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
534   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
535                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
536                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
537                                                                 :                  $num * 86400;   # Days
538   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
539   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
540                                                         }
541                                                         else {
542   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
543                                                         }
544                                                      }
545                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
546   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
547   ***      0                                  0         my $prev = {};
548   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
549   ***      0      0                           0         if ( $from_key ) {
550   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
551   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
552                                                         }
553   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
554   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
555                                                      }
556                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
557   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
558   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
559   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
560   ***      0      0                           0         if ( defined $num ) {
561   ***      0      0                           0            if ( $factor ) {
562   ***      0                                  0               $num *= $factor_for{$factor};
563   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
564                                                                  'to num', $num, '* factor', $factor);
565                                                            }
566   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
567                                                         }
568                                                         else {
569   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
570                                                         }
571                                                      }
572                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
573   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
574                                                      }
575                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
576   ***      9            50                  159         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
577                                                      }
578                                                      else {
579           69                                167         MKDEBUG && _d('Nothing to validate for option',
580                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
581                                                      }
582                                                   
583           78                                264      return;
584                                                   }
585                                                   
586                                                   sub get {
587          212                  212          1075      my ( $self, $opt ) = @_;
588          212    100                        1445      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
589   ***    212     50     33                 2212      die "Option $opt does not exist"
590                                                         unless $long && exists $self->{opts}->{$long};
591          212                               3429      return $self->{opts}->{$long}->{value};
592                                                   }
593                                                   
594                                                   sub got {
595           24                   24           103      my ( $self, $opt ) = @_;
596   ***     24     50                         113      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
597   ***     24     50     33                  235      die "Option $opt does not exist"
598                                                         unless $long && exists $self->{opts}->{$long};
599           24                                150      return $self->{opts}->{$long}->{got};
600                                                   }
601                                                   
602                                                   sub has {
603           54                   54           240      my ( $self, $opt ) = @_;
604           54    100                         286      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
605   ***     54     50                         475      return defined $long ? exists $self->{opts}->{$long} : 0;
606                                                   }
607                                                   
608                                                   sub set {
609            3                    3            17      my ( $self, $opt, $val ) = @_;
610   ***      3     50                          17      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
611   ***      3     50     33                   37      die "Option $opt does not exist"
612                                                         unless $long && exists $self->{opts}->{$long};
613            3                                 14      $self->{opts}->{$long}->{value} = $val;
614            3                                 12      return;
615                                                   }
616                                                   
617                                                   sub save_error {
618   ***      0                    0             0      my ( $self, $error ) = @_;
619   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
620                                                   }
621                                                   
622                                                   sub errors {
623   ***      0                    0             0      my ( $self ) = @_;
624   ***      0                                  0      return $self->{errors};
625                                                   }
626                                                   
627                                                   sub prompt {
628   ***      0                    0             0      my ( $self ) = @_;
629   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
630                                                   }
631                                                   
632                                                   sub descr {
633   ***      0                    0             0      my ( $self ) = @_;
634   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
635                                                                 . "  For more details, please use the --help option, "
636                                                                 . "or try 'perldoc $PROGRAM_NAME' "
637                                                                 . "for complete documentation.";
638   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
639   ***      0                                  0      $descr =~ s/ +$//mg;
640   ***      0                                  0      return $descr;
641                                                   }
642                                                   
643                                                   sub usage_or_errors {
644            6                    6            24      my ( $self ) = @_;
645   ***      6     50                          42      if ( $self->{opts}->{help}->{got} ) {
      ***      6     50                          36   
646   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
647   ***      0                                  0         exit 0;
648                                                      }
649                                                      elsif ( scalar @{$self->{errors}} ) {
650   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
651   ***      0                                  0         exit 0;
652                                                      }
653            6                                 20      return;
654                                                   }
655                                                   
656                                                   sub print_errors {
657   ***      0                    0             0      my ( $self ) = @_;
658   ***      0                                  0      my $usage = $self->prompt() . "\n";
659   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
660   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
661                                                                 . "\n";
662                                                      }
663   ***      0                                  0      return $usage . "\n" . $self->descr();
664                                                   }
665                                                   
666                                                   sub print_usage {
667   ***      0                    0             0      my ( $self ) = @_;
668   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
669   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
670                                                   
671   ***      0      0                           0      my $maxl = max(
672   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
673                                                         @opts);
674                                                   
675   ***      0      0                           0      my $maxs = max(0,
676   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
677   ***      0                                  0         values %{$self->{short_opts}});
678                                                   
679   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
680   ***      0                                  0      my $rcol = 80 - $lcol - 6;
681   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
682                                                   
683   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
684                                                   
685   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
686                                                   
687   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
688   ***      0                                  0      push @groups, 'default';
689                                                   
690   ***      0                                  0      foreach my $group ( reverse @groups ) {
691   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
692   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
693   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
694                                                            grep { $_->{group} eq $group }
695                                                            @opts )
696                                                         {
697   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
698   ***      0                                  0            my $short = $opt->{short};
699   ***      0                                  0            my $desc  = $opt->{desc};
700   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
701   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
702   ***      0             0                    0               $s    ||= 's';
703   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
704   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
705                                                                      . "d=days; if no suffix, $s is used.";
706                                                            }
707   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
708   ***      0                                  0            $desc =~ s/ +$//mg;
709   ***      0      0                           0            if ( $short ) {
710   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
711                                                            }
712                                                            else {
713   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
714                                                            }
715                                                         }
716                                                      }
717                                                   
718   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
719   ***      0                                  0         $usage .= "\nRules:\n\n";
720   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
721                                                      }
722   ***      0      0                           0      if ( $self->{dp} ) {
723   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
724                                                      }
725   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
726   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
727   ***      0                                  0         my $val   = $opt->{value};
728   ***      0             0                    0         my $type  = $opt->{type} || '';
729   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
730   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
731                                                                   : !defined $val             ? '(No value)'
732                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
733                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
734                                                                   : $type =~ m/A|a/           ? join(',', @$val)
735                                                                   :                             $val;
736   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
737                                                      }
738   ***      0                                  0      return $usage;
739                                                   }
740                                                   
741                                                   sub prompt_noecho {
742   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
743   ***      0                                  0      my ( $prompt ) = @_;
744   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
745   ***      0      0                           0      print $prompt
746                                                         or die "Cannot print: $OS_ERROR";
747   ***      0                                  0      my $response;
748   ***      0                                  0      eval {
749   ***      0                                  0         require Term::ReadKey;
750   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
751   ***      0                                  0         chomp($response = <STDIN>);
752   ***      0                                  0         Term::ReadKey::ReadMode('normal');
753   ***      0      0                           0         print "\n"
754                                                            or die "Cannot print: $OS_ERROR";
755                                                      };
756   ***      0      0                           0      if ( $EVAL_ERROR ) {
757   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
758                                                      }
759   ***      0                                  0      return $response;
760                                                   }
761                                                   
762                                                   if ( MKDEBUG ) {
763                                                      print '# ', $^X, ' ', $], "\n";
764                                                      my $uname = `uname -a`;
765                                                      if ( $uname ) {
766                                                         $uname =~ s/\s+/ /g;
767                                                         print "# $uname\n";
768                                                      }
769                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
770                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
771                                                         ($main::SVN_REV || ''), __LINE__);
772                                                      print('# Arguments: ',
773                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
774                                                   }
775                                                   
776                                                   sub _read_config_file {
777           24                   24           105      my ( $self, $filename ) = @_;
778   ***     24     50                          66      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
779   ***      0                                  0      my @args;
780   ***      0                                  0      my $prefix = '--';
781   ***      0                                  0      my $parse  = 1;
782                                                   
783                                                      LINE:
784   ***      0                                  0      while ( my $line = <$fh> ) {
785   ***      0                                  0         chomp $line;
786   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
787   ***      0                                  0         $line =~ s/\s+#.*$//g;
788   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
789   ***      0      0                           0         if ( $line eq '--' ) {
790   ***      0                                  0            $prefix = '';
791   ***      0                                  0            $parse  = 0;
792   ***      0                                  0            next LINE;
793                                                         }
794   ***      0      0      0                    0         if ( $parse
      ***             0                               
795                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
796                                                         ) {
797   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
798                                                         }
799                                                         elsif ( $line =~ m/./ ) {
800   ***      0                                  0            push @args, $line;
801                                                         }
802                                                         else {
803   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
804                                                         }
805                                                      }
806   ***      0                                  0      close $fh;
807   ***      0                                  0      return @args;
808                                                   }
809                                                   
810                                                   sub read_para_after {
811   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
812   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
813   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
814   ***      0                                  0      my $para;
815   ***      0                                  0      while ( $para = <$fh> ) {
816   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
817   ***      0                                  0         last;
818                                                      }
819   ***      0                                  0      while ( $para = <$fh> ) {
820   ***      0      0                           0         next unless $para =~ m/$regex/;
821   ***      0                                  0         last;
822                                                      }
823   ***      0                                  0      $para = <$fh>;
824   ***      0                                  0      chomp($para);
825   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
826   ***      0                                  0      return $para;
827                                                   }
828                                                   
829                                                   sub clone {
830   ***      0                    0             0      my ( $self ) = @_;
831                                                   
832   ***      0                                  0      my %clone = map {
833   ***      0                                  0         my $hashref  = $self->{$_};
834   ***      0                                  0         my $val_copy = {};
835   ***      0                                  0         foreach my $key ( keys %$hashref ) {
836   ***      0                                  0            my $ref = ref $hashref->{$key};
837   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
838   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
839   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
840                                                                              : $hashref->{$key};
841                                                         }
842   ***      0                                  0         $_ => $val_copy;
843                                                      } qw(opts short_opts defaults);
844                                                   
845   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
846   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
847                                                      }
848                                                   
849   ***      0                                  0      return bless \%clone;     
850                                                   }
851                                                   
852                                                   sub _d {
853   ***      0                    0             0      my ($package, undef, $line) = caller 0;
854   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
855   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
856                                                           @_;
857   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
858                                                   }
859                                                   
860                                                   1;
861                                                   
862                                                   # ###########################################################################
863                                                   # End OptionParser package
864                                                   # ###########################################################################
865                                                   
866                                                   # ###########################################################################
867                                                   # DSNParser package 5266
868                                                   # ###########################################################################
869                                                   package DSNParser;
870                                                   
871            4                    4            68   use strict;
               4                                 18   
               4                                 41   
872            4                    4            28   use warnings FATAL => 'all';
               4                                 12   
               4                                 44   
873            4                    4            35   use English qw(-no_match_vars);
               4                                 12   
               4                                 33   
874            4                    4            53   use Data::Dumper;
               4                                 11   
               4                                 59   
875                                                   $Data::Dumper::Indent    = 0;
876                                                   $Data::Dumper::Quotekeys = 0;
877                                                   
878                                                   eval {
879                                                      require DBI;
880                                                   };
881                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
882                                                   
883   ***      4            50      4            29   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 12   
               4                                 83   
884                                                   
885                                                   sub new {
886            9                    9           108      my ( $class, @opts ) = @_;
887            9                                293      my $self = {
888                                                         opts => {
889                                                            A => {
890                                                               desc => 'Default character set',
891                                                               dsn  => 'charset',
892                                                               copy => 1,
893                                                            },
894                                                            D => {
895                                                               desc => 'Database to use',
896                                                               dsn  => 'database',
897                                                               copy => 1,
898                                                            },
899                                                            F => {
900                                                               desc => 'Only read default options from the given file',
901                                                               dsn  => 'mysql_read_default_file',
902                                                               copy => 1,
903                                                            },
904                                                            h => {
905                                                               desc => 'Connect to host',
906                                                               dsn  => 'host',
907                                                               copy => 1,
908                                                            },
909                                                            p => {
910                                                               desc => 'Password to use when connecting',
911                                                               dsn  => 'password',
912                                                               copy => 1,
913                                                            },
914                                                            P => {
915                                                               desc => 'Port number to use for connection',
916                                                               dsn  => 'port',
917                                                               copy => 1,
918                                                            },
919                                                            S => {
920                                                               desc => 'Socket file to use for connection',
921                                                               dsn  => 'mysql_socket',
922                                                               copy => 1,
923                                                            },
924                                                            u => {
925                                                               desc => 'User for login if not current user',
926                                                               dsn  => 'user',
927                                                               copy => 1,
928                                                            },
929                                                         },
930                                                      };
931            9                                 53      foreach my $opt ( @opts ) {
932   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
933   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
934                                                      }
935            9                                116      return bless $self, $class;
936                                                   }
937                                                   
938                                                   sub prop {
939           39                   39           203      my ( $self, $prop, $value ) = @_;
940           39    100                         247      if ( @_ > 2 ) {
941            6                                 20         MKDEBUG && _d('Setting', $prop, 'property');
942            6                                 27         $self->{$prop} = $value;
943                                                      }
944           39                                310      return $self->{$prop};
945                                                   }
946                                                   
947                                                   sub parse {
948            9                    9           426      my ( $self, $dsn, $prev, $defaults ) = @_;
949   ***      9     50                          50      if ( !$dsn ) {
950   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
951   ***      0                                  0         return;
952                                                      }
953            9                                 29      MKDEBUG && _d('Parsing', $dsn);
954   ***      9            50                   50      $prev     ||= {};
955   ***      9            50                   52      $defaults ||= {};
956            9                                 30      my %given_props;
957            9                                 28      my %final_props;
958            9                                 39      my %opts = %{$self->{opts}};
               9                                294   
959                                                   
960            9                                 95      foreach my $dsn_part ( split(/,/, $dsn) ) {
961   ***     18     50                         232         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
962           18                                 95            $given_props{$prop_key} = $prop_val;
963                                                         }
964                                                         else {
965   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
966   ***      0                                  0            $given_props{h} = $dsn_part;
967                                                         }
968                                                      }
969                                                   
970            9                                 52      foreach my $key ( keys %opts ) {
971           72                                160         MKDEBUG && _d('Finding value for', $key);
972           72                                246         $final_props{$key} = $given_props{$key};
973   ***     72     50     66                  648         if (   !defined $final_props{$key}
      ***                   33                        
974                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
975                                                         {
976   ***      0                                  0            $final_props{$key} = $prev->{$key};
977   ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
978                                                         }
979           72    100                         304         if ( !defined $final_props{$key} ) {
980           54                                178            $final_props{$key} = $defaults->{$key};
981           54                                158            MKDEBUG && _d('Copying value for', $key, 'from defaults');
982                                                         }
983                                                      }
984                                                   
985            9                                 51      foreach my $key ( keys %given_props ) {
986   ***     18     50                          93         die "Unrecognized DSN part '$key' in '$dsn'\n"
987                                                            unless exists $opts{$key};
988                                                      }
989   ***      9     50                          55      if ( (my $required = $self->prop('required')) ) {
990   ***      0                                  0         foreach my $key ( keys %$required ) {
991   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
992                                                         }
993                                                      }
994                                                   
995            9                                 74      return \%final_props;
996                                                   }
997                                                   
998                                                   sub parse_options {
999            6                    6            24      my ( $self, $o ) = @_;
1000  ***      6     50                          40      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1001           6                                 36      my $dsn_string
1002                                                        = join(',',
1003  ***     48     50                         207             map  { "$_=".$o->get($_); }
1004           6                                 54             grep { $o->has($_) && $o->get($_) }
1005           6                                 21             keys %{$self->{opts}}
1006                                                          );
1007           6                                 25      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1008           6                                 41      return $self->parse($dsn_string);
1009                                                  }
1010                                                  
1011                                                  sub as_string {
1012  ***      0                    0             0      my ( $self, $dsn ) = @_;
1013  ***      0      0                           0      return $dsn unless ref $dsn;
1014  ***      0      0                           0      return join(',',
1015  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1016  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1017                                                        sort keys %$dsn );
1018                                                  }
1019                                                  
1020                                                  sub usage {
1021  ***      0                    0             0      my ( $self ) = @_;
1022  ***      0                                  0      my $usage
1023                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1024                                                        . "  KEY  COPY  MEANING\n"
1025                                                        . "  ===  ====  =============================================\n";
1026  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1027  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1028  ***      0      0      0                    0         $usage .= "  $key    "
1029                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1030                                                               .  ($opts{$key}->{desc} || '[No description]')
1031                                                               . "\n";
1032                                                     }
1033  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1034  ***      0                                  0      return $usage;
1035                                                  }
1036                                                  
1037                                                  sub get_cxn_params {
1038           9                    9           164      my ( $self, $info ) = @_;
1039           9                                 27      my $dsn;
1040           9                                 31      my %opts = %{$self->{opts}};
               9                                 86   
1041  ***      9            50                   51      my $driver = $self->prop('dbidriver') || '';
1042  ***      9     50                          50      if ( $driver eq 'Pg' ) {
1043  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1044  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1045  ***      0             0                    0                        grep { defined $info->{$_} }
1046                                                                       qw(h P));
1047                                                     }
1048                                                     else {
1049          12                                104         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1050          45                                172            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1051  ***      9            50                  120                        grep { defined $info->{$_} }
1052                                                                       qw(F h P S A))
1053                                                           . ';mysql_read_default_group=client';
1054                                                     }
1055           9                                 28      MKDEBUG && _d($dsn);
1056           9                                105      return ($dsn, $info->{u}, $info->{p});
1057                                                  }
1058                                                  
1059                                                  sub fill_in_dsn {
1060  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1061  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1062  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1063  ***      0                                  0      $user =~ s/@.*//;
1064  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1065  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1066  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1067  ***      0             0                    0      $dsn->{u} ||= $user;
1068  ***      0             0                    0      $dsn->{D} ||= $db;
1069                                                  }
1070                                                  
1071                                                  sub get_dbh {
1072           9                    9            63      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1073  ***      9            50                   45      $opts ||= {};
1074  ***      9     50                         112      my $defaults = {
1075                                                        AutoCommit         => 0,
1076                                                        RaiseError         => 1,
1077                                                        PrintError         => 0,
1078                                                        ShowErrorStatement => 1,
1079                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1080                                                     };
1081           9                                 50      @{$defaults}{ keys %$opts } = values %$opts;
               9                                 42   
1082                                                  
1083  ***      9     50                          45      if ( !$have_dbi ) {
1084  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1085                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1086                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1087                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1088                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1089                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1090                                                  
1091                                                     }
1092                                                  
1093           9                                 33      my $dbh;
1094           9                                 27      my $tries = 2;
1095  ***      9            66                  105      while ( !$dbh && $tries-- ) {
1096                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1097           9                                 27            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1098                                                  
1099           9                                 33         eval {
1100           9                                116            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1101                                                  
1102  ***      9     50                         207            if ( $cxn_string =~ m/mysql/i ) {
1103           9                                 27               my $sql;
1104                                                  
1105           9                                 39               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1106                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1107           9                                 25               MKDEBUG && _d($dbh, ':', $sql);
1108           9                               1048               $dbh->do($sql);
1109                                                  
1110  ***      9     50                         124               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1111  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1112  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1113  ***      0                                  0                  $dbh->do($sql);
1114  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1115  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1116  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1117                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1118                                                                 }
1119                                                                 else {
1120  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1121                                                                 }
1122                                                              }
1123                                                  
1124           9    100                          70               if ( $self->prop('set-vars') ) {
1125           6                                 38                  $sql = "SET " . $self->prop('set-vars');
1126           6                                 17                  MKDEBUG && _d($dbh, ':', $sql);
1127           6                                406                  $dbh->do($sql);
1128                                                              }
1129                                                           }
1130                                                        };
1131  ***      9     50     33                  147         if ( !$dbh && $EVAL_ERROR ) {
1132  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1133  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1134  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1135  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1136                                                           }
1137                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1138  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1139                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1140                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1141                                                                 . "DBD::mysql is not installed, try:\n"
1142                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1143                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1144                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1145                                                           }
1146  ***      0      0                           0            if ( !$tries ) {
1147  ***      0                                  0               die $EVAL_ERROR;
1148                                                           }
1149                                                        }
1150                                                     }
1151                                                  
1152           9                                 30      MKDEBUG && _d('DBH info: ',
1153                                                        $dbh,
1154                                                        Dumper($dbh->selectrow_hashref(
1155                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1156                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1157                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1158                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1159                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1160                                                        '$DBI::VERSION:',        $DBI::VERSION,
1161                                                     );
1162                                                  
1163           9                                 98      return $dbh;
1164                                                  }
1165                                                  
1166                                                  sub get_hostname {
1167  ***      0                    0             0      my ( $self, $dbh ) = @_;
1168  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1169  ***      0                                  0         return $host;
1170                                                     }
1171  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1172                                                        'SELECT /*!50038 @@hostname, */ 1');
1173  ***      0                                  0      return $hostname;
1174                                                  }
1175                                                  
1176                                                  sub disconnect {
1177  ***      0                    0             0      my ( $self, $dbh ) = @_;
1178  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1179  ***      0                                  0      $dbh->disconnect;
1180                                                  }
1181                                                  
1182                                                  sub print_active_handles {
1183  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1184  ***      0             0                    0      $level ||= 0;
1185  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1186                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1187                                                        or die "Cannot print: $OS_ERROR";
1188  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1189  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1190                                                     }
1191                                                  }
1192                                                  
1193                                                  sub copy {
1194  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1195  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1196  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1197  ***      0                                  0      my %new_dsn = map {
1198  ***      0                                  0         my $key = $_;
1199  ***      0                                  0         my $val;
1200  ***      0      0                           0         if ( $args{overwrite} ) {
1201  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1202                                                        }
1203                                                        else {
1204  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1205                                                        }
1206  ***      0                                  0         $key => $val;
1207  ***      0                                  0      } keys %{$self->{opts}};
1208  ***      0                                  0      return \%new_dsn;
1209                                                  }
1210                                                  
1211                                                  sub _d {
1212  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1213  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1214  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1215                                                          @_;
1216  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1217                                                  }
1218                                                  
1219                                                  1;
1220                                                  
1221                                                  # ###########################################################################
1222                                                  # End DSNParser package
1223                                                  # ###########################################################################
1224                                                  
1225                                                  # ###########################################################################
1226                                                  # Daemon package 5266
1227                                                  # ###########################################################################
1228                                                  
1229                                                  package Daemon;
1230                                                  
1231           4                    4            59   use strict;
               4                                 12   
               4                                 36   
1232           4                    4            27   use warnings FATAL => 'all';
               4                                 14   
               4                                 32   
1233                                                  
1234           4                    4            26   use POSIX qw(setsid);
               4                                 10   
               4                                 28   
1235           4                    4            27   use English qw(-no_match_vars);
               4                                 11   
               4                                 32   
1236                                                  
1237  ***      4            50      4            41   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 11   
               4                                 73   
1238                                                  
1239                                                  sub new {
1240  ***      0                    0             0      my ( $class, %args ) = @_;
1241  ***      0                                  0      foreach my $arg ( qw(o) ) {
1242  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1243                                                     }
1244  ***      0                                  0      my $o = $args{o};
1245  ***      0      0                           0      my $self = {
      ***             0                               
1246                                                        o        => $o,
1247                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1248                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1249                                                     };
1250                                                  
1251  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1252                                                  
1253  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1254  ***      0                                  0      return bless $self, $class;
1255                                                  }
1256                                                  
1257                                                  sub daemonize {
1258  ***      0                    0             0      my ( $self ) = @_;
1259                                                  
1260  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1261  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1262  ***      0      0                           0      if ( $pid ) {
1263  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1264  ***      0                                  0         exit;
1265                                                     }
1266                                                  
1267  ***      0                                  0      $self->{child} = 1;
1268                                                  
1269  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1270  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1271                                                  
1272  ***      0                                  0      $self->_make_PID_file();
1273                                                  
1274  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
1275                                                  
1276  ***      0      0                           0      if ( -t STDIN ) {
1277  ***      0                                  0         close STDIN;
1278  ***      0      0                           0         open  STDIN, '/dev/null'
1279                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1280                                                     }
1281                                                  
1282  ***      0      0                           0      if ( $self->{log_file} ) {
1283  ***      0                                  0         close STDOUT;
1284  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1285                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1286                                                  
1287  ***      0                                  0         close STDERR;
1288  ***      0      0                           0         open  STDERR, ">&STDOUT"
1289                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1290                                                     }
1291                                                     else {
1292  ***      0      0                           0         if ( -t STDOUT ) {
1293  ***      0                                  0            close STDOUT;
1294  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
1295                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1296                                                        }
1297  ***      0      0                           0         if ( -t STDERR ) {
1298  ***      0                                  0            close STDERR;
1299  ***      0      0                           0            open  STDERR, '>', '/dev/null'
1300                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1301                                                        }
1302                                                     }
1303                                                  
1304  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1305  ***      0                                  0      return;
1306                                                  }
1307                                                  
1308                                                  sub check_PID_file {
1309  ***      0                    0             0      my ( $self, $file ) = @_;
1310  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1311  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1312  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1313  ***      0                                  0         my $pid;
1314  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1315  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1316  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1317  ***      0      0                           0         if ( $pid ) {
1318  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1319  ***      0      0                           0            if ( $pid_is_alive ) {
1320  ***      0                                  0               die "The PID file $PID_file already exists "
1321                                                                 . " and the PID that it contains, $pid, is running";
1322                                                           }
1323                                                           else {
1324  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1325                                                                 . "contains, $pid, is not running";
1326                                                           }
1327                                                        }
1328                                                        else {
1329  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1330                                                              . "contain a PID";
1331                                                        }
1332                                                     }
1333                                                     else {
1334  ***      0                                  0         MKDEBUG && _d('No PID file');
1335                                                     }
1336  ***      0                                  0      return;
1337                                                  }
1338                                                  
1339                                                  sub make_PID_file {
1340  ***      0                    0             0      my ( $self ) = @_;
1341  ***      0      0                           0      if ( exists $self->{child} ) {
1342  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1343                                                     }
1344  ***      0                                  0      $self->_make_PID_file();
1345  ***      0                                  0      $self->{rm_PID_file} = 1;
1346  ***      0                                  0      return;
1347                                                  }
1348                                                  
1349                                                  sub _make_PID_file {
1350  ***      0                    0             0      my ( $self ) = @_;
1351                                                  
1352  ***      0                                  0      my $PID_file = $self->{PID_file};
1353  ***      0      0                           0      if ( !$PID_file ) {
1354  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1355  ***      0                                  0         return;
1356                                                     }
1357                                                  
1358  ***      0                                  0      $self->check_PID_file();
1359                                                  
1360  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1361                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1362  ***      0      0                           0      print $PID_FH $PID
1363                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1364  ***      0      0                           0      close $PID_FH
1365                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1366                                                  
1367  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1368  ***      0                                  0      return;
1369                                                  }
1370                                                  
1371                                                  sub _remove_PID_file {
1372  ***      0                    0             0      my ( $self ) = @_;
1373  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1374  ***      0      0                           0         unlink $self->{PID_file}
1375                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1376  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1377                                                     }
1378                                                     else {
1379  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1380                                                     }
1381  ***      0                                  0      return;
1382                                                  }
1383                                                  
1384                                                  sub DESTROY {
1385  ***      0                    0             0      my ( $self ) = @_;
1386  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1387  ***      0                                  0      return;
1388                                                  }
1389                                                  
1390                                                  sub _d {
1391  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1392  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1393  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1394                                                          @_;
1395  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1396                                                  }
1397                                                  
1398                                                  1;
1399                                                  
1400                                                  # ###########################################################################
1401                                                  # End Daemon package
1402                                                  # ###########################################################################
1403                                                  
1404                                                  # ###########################################################################
1405                                                  # This is a combination of modules and programs in one -- a runnable module.
1406                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1407                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1408                                                  #
1409                                                  # Check at the end of this package for the call to main() which actually runs
1410                                                  # the program.
1411                                                  # ###########################################################################
1412                                                  package mk_show_grants;
1413                                                  
1414           4                    4            46   use English qw(-no_match_vars);
               4                                 14   
               4                                 36   
1415                                                  
1416  ***      4            50      4            42   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 16   
               4                                 82   
1417                                                  
1418                                                  sub main {
1419           6                    6          8614      @ARGV = @_;  # set global ARGV for this package
1420                                                  
1421                                                     # ########################################################################
1422                                                     # Get configuration information.
1423                                                     # ########################################################################
1424           6                                107      my $o = new OptionParser( 
1425                                                        description => q{shows grants (user privileges) from a MySQL server.},
1426                                                     );
1427           6                                 52      $o->get_specs();
1428           6                                 55      $o->get_opts();
1429                                                  
1430           6                                 96      my $dp = new DSNParser();
1431           6                                 41      $dp->prop('set-vars', $o->get('set-vars'));
1432                                                  
1433           6                                 47      $o->usage_or_errors();
1434                                                  
1435                                                     # ########################################################################
1436                                                     # If --pid, check it first since we'll die if it already exits.
1437                                                     # ########################################################################
1438           6                                 18      my $daemon;
1439  ***      6     50                          30      if ( $o->get('pid') ) {
1440                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
1441                                                        # in the the scope of main() because when it's destroyed it automatically
1442                                                        # removes the PID file.
1443  ***      0                                  0         $daemon = new Daemon(o=>$o);
1444  ***      0                                  0         $daemon->make_PID_file();
1445                                                     }
1446                                                  
1447                                                     # ########################################################################
1448                                                     # Parse --only and --ignore users.
1449                                                     # ######################################################################## 
1450           6                                 19      my @all_hosts;
1451           6    100                          26      if ( my $users = $o->get('only') ) {
1452           1                                 25         my @users = map {
1453                                                           my ( $user, $host ) = parse_user($_);
1454           1                                  3            MKDEBUG && _d('Parsed only', $_, 'as user', $user, 'and host', $host);
1455           1                                  7            { User => $user, Host => $host };
1456                                                        }
1457                                                        grep {
1458           2    100                          16            if ( $_ !~ /\@/ ) {
               2                                 18   
1459                                                              # If the user does not have an @, then get all grants for
1460                                                              # the user on all hosts (issue 551).
1461           1                                  3               MKDEBUG && _d('Will get all grants for', $_, 'on all hosts');
1462           1                                  4               push @all_hosts, $_;
1463           1                                  5               0;
1464                                                           }
1465                                                           else {
1466           1                                  5               $_;
1467                                                           }
1468                                                        }
1469           2                                 10         grep { $_ =~ m/\S/ }
1470                                                        @$users;
1471           2                                 16         $o->set('only', \@users);
1472                                                     }
1473           6    100                          28      if ( my $users = $o->get('ignore') ) {
1474           5                                 19         my %users = map {
1475           5                                 22            my ( $user, $host ) = parse_user($_);
1476           5                                 12            MKDEBUG && _d('Parsed ignore', $_, 'as user', $user, 'and host',$host);
1477           5                                 21            my $user_host = "'$user'\@'$host'";
1478           5                                 24            $user_host => 1;
1479                                                        }
1480           1                                  4         grep { $_ =~ m/\S/ }
1481                                                        @$users;
1482           1                                  7         $o->set('ignore', \%users);
1483                                                     }
1484                                                  
1485                                                     # ########################################################################
1486                                                     # Connect to the database.
1487                                                     # ########################################################################
1488  ***      6     50                          28      if ( $o->get('ask-pass') ) {
1489  ***      0                                  0         $o->set('password', OptionParser::prompt_noecho("Enter password: "));
1490                                                     }
1491                                                  
1492           6                                 43      my $dsn = $dp->parse_options($o);
1493           6                                 48      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1 });
1494                                                  
1495           6                                 23      my ( $version, $ts ) = $dbh->selectrow_array("SELECT VERSION(), NOW()");
1496  ***      6    100     50                 2413      print join("\n",
                    100                               
1497                                                        "-- Grants dumped by mk-show-grants $VERSION",
1498                                                        "-- Dumped from server " . ($dbh->{mysql_hostinfo} || '')
1499                                                        . ($o->get('timestamp') ? ", MySQL $version at $ts" : ", MySQL $version"),
1500                                                        ), "\n" if $o->get('header');
1501                                                  
1502  ***      6            66                   55      my $users = $o->get('only') || $dbh->selectall_arrayref(
1503                                                        'SELECT DISTINCT User, Host FROM mysql.user ORDER BY User, Host',
1504                                                        { Slice => {} });
1505           6    100                          71      if ( scalar @all_hosts ) {
1506           1                                 10         my $where = join(' OR ', map { "User='$_'" } @all_hosts);
               1                                 10   
1507           1                                  6         my $sql   = "SELECT DISTINCT User, Host FROM mysql.user WHERE $where "
1508                                                                  . "ORDER BY User, Host";
1509           1                                  3         MKDEBUG && _d($sql);
1510           1                                  5         push @$users, @{ $dbh->selectall_arrayref($sql, { Slice => {} }) };
               1                                 47   
1511                                                     }
1512           6                                 57      my $ignore_users = $o->get('ignore');
1513                                                  
1514           6                                 23      my $exit_status = 0;
1515                                                     USER:
1516           6                                 38      foreach my $u ( @$users ) {
1517          21                                134         my $user_host = "'$u->{User}'\@'$u->{Host}'";
1518  ***     21    100     66                  123         if ( $ignore_users && $ignore_users->{$user_host} ) {
1519           4                                  9            MKDEBUG && _d('Ignoring user', $user_host);
1520           4                                 13            next USER;
1521                                                        }
1522                                                        else {
1523          17                                 45            MKDEBUG && _d('Checking user', $user_host);
1524                                                        }
1525                                                  
1526          17                                 43         my @grants;
1527          17                                 46         eval {
1528          17                                 51            @grants = @{ $dbh->selectcol_arrayref("SHOW GRANTS FOR $user_host") };
              17                                 40   
1529                                                        };
1530  ***     17     50                         169         if ( $EVAL_ERROR ) {
1531  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1532  ***      0                                  0            $exit_status = 1;
1533                                                        }
1534  ***     17     50                          73         next unless @grants;
1535                                                  
1536          17    100                          87         if ( $o->get('separate') ) { # List each grant separately.
1537          10                                128            @grants = map {
1538           8                                 34               my ( $grants, $on_what ) = $_ =~ m/GRANT (.*?) ON ((?:`|\*).*)$/;
1539          10                                 55               map { "GRANT $_ ON $on_what" } split(', ', $grants);
              10                                 59   
1540                                                           } @grants;
1541           8                                 24            my $count;
1542                                                           # If the row with IDENTIFIED BY has multiple grants, this will
1543                                                           # create many such rows; strip it from all but the first.
1544                                                           @grants = map {
1545           8    100                          26               if ( $_ =~ m/IDENTIFIED BY/ ) {
              10                                 45   
1546  ***      4     50                          20                  if ( $count++ ) {
1547  ***      0                                  0                     $_ =~ s/ IDENTIFIED BY.*//;
1548                                                                 }
1549                                                              }
1550          10                                 51               $_;
1551                                                           } @grants;
1552                                                        }
1553                                                        else { # Sort the actual grants lexically within each row for consistency.
1554          10                                171            @grants = map {
1555           9                                 37               $_ =~ s/GRANT (.*?) ON (`|\*)/"GRANT " . join(', ', sort(split(', ', $1))) . " ON $2"/e;
              10                                177   
1556          10                                 63               $_;
1557                                                           } @grants;
1558                                                        }
1559                                                  
1560                                                        # Sort the grant rows for consistency too, but the one with the password
1561                                                        # should always come first.
1562  ***      3     50                          49         @grants = sort {
1563          17                                 73            $b =~ m/IDENTIFIED BY/ <=> $a =~ m/IDENTIFIED BY/ || $a cmp $b
1564                                                        } @grants;
1565                                                  
1566                                                        # Print REVOKE statements.
1567          17    100                          77         if ( $o->get('revoke') ) {
1568          16                                 57            my @revoke = map {
1569          13                                 41               my $grant = $_;
1570          16                                 37               MKDEBUG && _d($grant);
1571          16                                185               my ( $grants, $on_what, $user ) = $grant
1572                                                                 =~ m/GRANT (.*?) ON ((?:`|\*).*?) TO ('[^']*'\@'[^']+')?/;
1573          16                                 47               MKDEBUG && _d('grants:', $grants, 'on_what:', $on_what,
1574                                                                 'user:', $user);
1575                                                  
1576          16    100                          62               if ( !$user ) {
1577                                                                 # Anonymous user: ''@'' (issue 445).
1578           1                                  2                  MKDEBUG && _d('Anonymous user');
1579           1                                  4                  $user = "''\@''";
1580                                                              }
1581                                                  
1582          16                                 40               my @result;
1583          16    100                          62               if ( $o->get('separate') ) {
1584          10                                 45                  @result = map { "REVOKE $grant ON $on_what FROM $user" }
              10                                 67   
1585                                                                    split(', ', $grants);
1586                                                              }
1587                                                              else {
1588           6                                 34                  @result = "REVOKE $grants ON $on_what FROM $user";
1589                                                              }
1590                                                  
1591                                                              # The WITH GRANT OPTION must be revoked separately.
1592          16    100                          79               if ( $grant =~ m/WITH GRANT OPTION/ ) { 
1593  ***      3     50                          23                  push @result, "REVOKE GRANT OPTION ON *.* FROM $user" if $user;
1594                                                              }
1595                                                  
1596          16                                 73               @result;
1597                                                           } @grants;
1598                                                  
1599          19                                135            print join(
1600                                                              "\n",
1601                                                              "-- Revoke statements for $user_host",
1602          13                                 68               map {"$_;"} @revoke),
1603                                                              "\n";
1604                                                        }
1605                                                  
1606          17    100                          73         if ( $o->get('drop') ) {
1607           8                                 71            print join("\n",
1608                                                              "DROP USER $user_host;",
1609                                                              "DELETE FROM `mysql`.`user` WHERE `User`='$u->{User}' AND `Host`='$u->{Host}';",
1610                                                              ), "\n";
1611                                                        }
1612                                                        
1613          20                                737         print join( "\n", "-- Grants for $user_host",
1614          17                                 80            map {"$_;"} @grants ), "\n";
1615                                                  
1616  ***     17    100     66                   81         if ( $o->get('flush') && $o->get('separate') ) {
1617           8                                 27            print "FLUSH PRIVILEGES;\n";
1618                                                        }
1619                                                  
1620          17                                 81         $exit_status = 0;
1621                                                     }
1622                                                  
1623  ***      6     50     66                   35      if ( $o->get('flush') && !$o->get('separate') ) {
1624  ***      0                                  0         print "FLUSH PRIVILEGES;\n";
1625                                                     }
1626                                                  
1627           6                                600      $dbh->disconnect();
1628           6                                953      return $exit_status;
1629                                                  }
1630                                                  
1631                                                  # ############################################################################
1632                                                  # Subroutines
1633                                                  # ############################################################################
1634                                                  sub parse_user {
1635           6                    6            24      my ( $spec ) = @_;
1636           6                                 55      my ( $user, $host )
1637                                                        = $spec =~ m/
1638                                                           ^               # Beginning of line
1639                                                           '?([^'@]*)'?    # Username optionally enclosed by '
1640                                                           (?:
1641                                                              @            # Followed by @
1642                                                              '?([^']*?)'? # And host optionally enclosed by '
1643                                                           )?              # ... which is all optional
1644                                                           $               # End of line
1645                                                           /xms;
1646           6           100                   29      $host ||= '%';
1647           6                                 28      return ( $user, $host );
1648                                                  }
1649                                                  
1650                                                  sub _d {
1651  ***      0                    0                    my ($package, undef, $line) = caller 0;
1652  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1653  ***      0                                              map { defined $_ ? $_ : 'undef' }
1654                                                          @_;
1655  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1656                                                  }
1657                                                  
1658                                                  # ############################################################################
1659                                                  # Run the program.
1660                                                  # ############################################################################
1661                                                  if ( !caller ) { exit main(@ARGV); }
1662                                                  
1663                                                  1; # Because this is a module as well as a script.
1664                                                  
1665                                                  # ############################################################################
1666                                                  # Documentation
1667                                                  # ############################################################################
1668                                                  
1669                                                  =pod
1670                                                  
1671                                                  =head1 NAME
1672                                                  
1673                                                  mk-show-grants - Canonicalize and print MySQL grants so you can effectively
1674                                                  replicate, compare and version-control them.
1675                                                  
1676                                                  =head1 SYNOPSIS
1677                                                  
1678                                                     mk-show-grants
1679                                                     mk-show-grants --separate --revoke | diff othergrants.sql -
1680                                                  
1681                                                  =head1 RISKS
1682                                                  
1683                                                  The following section is included to inform users about the potential risks,
1684                                                  whether known or unknown, of using this tool.  The two main categories of risks
1685                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
1686                                                  tools) and those created by bugs.
1687                                                  
1688                                                  mk-show-grants is read-only by default, and very low-risk.  If you specify
1689                                                  L<"--flush">, it will execute C<FLUSH PRIVILEGES>.
1690                                                  
1691                                                  At the time of this release, we know of no bugs that could cause serious harm to
1692                                                  users.
1693                                                  
1694                                                  The authoritative source for updated information is always the online issue
1695                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
1696                                                  see a list of such issues at the following URL:
1697                                                  L<http://www.maatkit.org/bugs/mk-show-grants>.
1698                                                  
1699                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
1700                                                  
1701                                                  =head1 DESCRIPTION
1702                                                  
1703                                                  mk-show-grants extracts, orders, and then prints grants for MySQL user
1704                                                  accounts.
1705                                                  
1706                                                  Why would you want this?  There are several reasons.
1707                                                  
1708                                                  The first is to easily replicate users from one server to another; you can
1709                                                  simply extract the grants from the first server and pipe the output directly
1710                                                  into another server.
1711                                                  
1712                                                  The second use is to place your grants into version control.  If you do a daily
1713                                                  automated grant dump into version control, you'll get lots of spurious
1714                                                  changesets for grants that don't change, because MySQL prints the actual grants
1715                                                  out in a seemingly random order.  For instance, one day it'll say
1716                                                  
1717                                                    GRANT DELETE, INSERT, UPDATE ON `test`.* TO 'foo'@'%';
1718                                                  
1719                                                  And then another day it'll say
1720                                                  
1721                                                    GRANT INSERT, DELETE, UPDATE ON `test`.* TO 'foo'@'%';
1722                                                  
1723                                                  The grants haven't changed, but the order has.  This script sorts the grants
1724                                                  within the line, between 'GRANT' and 'ON'.  If there are multiple rows from SHOW
1725                                                  GRANTS, it sorts the rows too, except that it always prints the row with the
1726                                                  user's password first, if it exists.  This removes three kinds of inconsistency
1727                                                  you'll get from running SHOW GRANTS, and avoids spurious changesets in version
1728                                                  control.
1729                                                  
1730                                                  Third, if you want to diff grants across servers, it will be hard without
1731                                                  "canonicalizing" them, which mk-show-grants does.  The output is fully
1732                                                  diff-able.
1733                                                  
1734                                                  With the L<"--revoke">, L<"--separate"> and other options, mk-show-grants
1735                                                  also makes it easy to revoke specific privileges from users.  This is tedious
1736                                                  otherwise.
1737                                                  
1738                                                  =head1 OPTIONS
1739                                                  
1740                                                  =over
1741                                                  
1742                                                  =item --ask-pass
1743                                                  
1744                                                  Prompt for a password when connecting to MySQL.
1745                                                  
1746                                                  =item --charset
1747                                                  
1748                                                  short form: -A; type: string
1749                                                  
1750                                                  Default character set.  If the value is utf8, sets Perl's binmode on
1751                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
1752                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
1753                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
1754                                                  connecting to MySQL.
1755                                                  
1756                                                  =item --config
1757                                                  
1758                                                  type: Array
1759                                                  
1760                                                  Read this comma-separated list of config files; if specified, this must be the
1761                                                  first option on the command line.
1762                                                  
1763                                                  =item --database
1764                                                  
1765                                                  short form: -D; type: string
1766                                                  
1767                                                  The database to use for the connection.
1768                                                  
1769                                                  =item --defaults-file
1770                                                  
1771                                                  short form: -F; type: string
1772                                                  
1773                                                  Only read mysql options from the given file.  You must give an absolute
1774                                                  pathname.
1775                                                  
1776                                                  =item --drop
1777                                                  
1778                                                  Add DROP USER before each user in the output.
1779                                                  
1780                                                  =item --flush
1781                                                  
1782                                                  Add FLUSH PRIVILEGES after output.
1783                                                  
1784                                                  You might need this on pre-4.1.1 servers if you want to drop a user completely.
1785                                                  
1786                                                  =item --[no]header
1787                                                  
1788                                                  default: yes
1789                                                  
1790                                                  Print dump header.
1791                                                  
1792                                                  The header precedes the dumped grants.  It looks like:
1793                                                  
1794                                                    -- Grants dumped by mk-show-grants 1.0.19
1795                                                    -- Dumped from server Localhost via UNIX socket, MySQL 5.0.82-log at 2009-10-26 10:01:04
1796                                                  
1797                                                  See also L<"--[no]timestamp">.
1798                                                  
1799                                                  =item --help
1800                                                  
1801                                                  Show help and exit.
1802                                                  
1803                                                  =item --host
1804                                                  
1805                                                  short form: -h; type: string
1806                                                  
1807                                                  Connect to host.
1808                                                  
1809                                                  =item --ignore
1810                                                  
1811                                                  type: array
1812                                                  
1813                                                  Ignore this comma-separated list of users.
1814                                                  
1815                                                  =item --only
1816                                                  
1817                                                  type: array
1818                                                  
1819                                                  Only show grants for this comma-separated list of users.
1820                                                  
1821                                                  =item --password
1822                                                  
1823                                                  short form: -p; type: string
1824                                                  
1825                                                  Password to use when connecting.
1826                                                  
1827                                                  =item --pid
1828                                                  
1829                                                  type: string
1830                                                  
1831                                                  Create the given PID file.  The file contains the process ID of the script.
1832                                                  The PID file is removed when the script exits.  Before starting, the script
1833                                                  checks if the PID file already exists.  If it does not, then the script creates
1834                                                  and writes its own PID to it.  If it does, then the script checks the following:
1835                                                  if the file contains a PID and a process is running with that PID, then
1836                                                  the script dies; or, if there is no process running with that PID, then the
1837                                                  script overwrites the file with its own PID and starts; else, if the file
1838                                                  contains no PID, then the script dies.
1839                                                  
1840                                                  =item --port
1841                                                  
1842                                                  short form: -P; type: int
1843                                                  
1844                                                  Port number to use for connection.
1845                                                  
1846                                                  =item --revoke
1847                                                  
1848                                                  Add REVOKE statements for each GRANT statement.
1849                                                  
1850                                                  =item --separate
1851                                                  
1852                                                  List each GRANT or REVOKE separately.
1853                                                  
1854                                                  The default output from MySQL's SHOW GRANTS command lists many privileges on a
1855                                                  single line.  With L<"--flush">, places a FLUSH PRIVILEGES after each user,
1856                                                  instead of once at the end of all the output.
1857                                                  
1858                                                  =item --set-vars
1859                                                  
1860                                                  type: string; default: wait_timeout=10000
1861                                                  
1862                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
1863                                                  string will be appended to SET and executed.
1864                                                  
1865                                                  =item --socket
1866                                                  
1867                                                  short form: -S; type: string
1868                                                  
1869                                                  Socket file to use for connection.
1870                                                  
1871                                                  =item --[no]timestamp
1872                                                  
1873                                                  default: yes
1874                                                  
1875                                                  Add timestamp to the dump header.
1876                                                  
1877                                                  See also L<"--[no]header">.
1878                                                  
1879                                                  =item --user
1880                                                  
1881                                                  short form: -u; type: string
1882                                                  
1883                                                  User for login if not current user.
1884                                                  
1885                                                  =item --version
1886                                                  
1887                                                  Show version and exit.
1888                                                  
1889                                                  =back
1890                                                  
1891                                                  =head1 DOWNLOADING
1892                                                  
1893                                                  You can download Maatkit from Google Code at
1894                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
1895                                                  easily with a command like the following:
1896                                                  
1897                                                     wget http://www.maatkit.org/get/toolname
1898                                                     or
1899                                                     wget http://www.maatkit.org/trunk/toolname
1900                                                  
1901                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
1902                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
1903                                                  needed.  The first URL gets the latest released version of the tool, and the
1904                                                  second gets the latest trunk code from Subversion.
1905                                                  
1906                                                  =head1 ENVIRONMENT
1907                                                  
1908                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
1909                                                  the Maatkit tools:
1910                                                  
1911                                                     MKDEBUG=1 mk-....
1912                                                  
1913                                                  =head1 SYSTEM REQUIREMENTS
1914                                                  
1915                                                  You need the following Perl modules: DBI and DBD::mysql.
1916                                                  
1917                                                  =head1 BUGS
1918                                                  
1919                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-show-grants>.
1920                                                  
1921                                                  Please use Google Code Issues and Groups to report bugs or request support:
1922                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
1923                                                  discuss Maatkit.
1924                                                  
1925                                                  Please include the complete command-line used to reproduce the problem you are
1926                                                  seeing, the version of all MySQL servers involved, the complete output of the
1927                                                  tool when run with L<"--version">, and if possible, debugging output produced by
1928                                                  running with the C<MKDEBUG=1> environment variable.
1929                                                  
1930                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
1931                                                  
1932                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
1933                                                  Feedback and improvements are welcome.
1934                                                  
1935                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
1936                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
1937                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
1938                                                  
1939                                                  This program is free software; you can redistribute it and/or modify it under
1940                                                  the terms of the GNU General Public License as published by the Free Software
1941                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
1942                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
1943                                                  licenses.
1944                                                  
1945                                                  You should have received a copy of the GNU General Public License along with
1946                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
1947                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
1948                                                  
1949                                                  =head1 SEE ALSO
1950                                                  
1951                                                  Someone pointed out that this has been done before (not surprising, as it's
1952                                                  not all that complicated).  Visit L<http://www.futhark.ch/mysql/139.html> for
1953                                                  a simpler implementation of the same general concept, though without the
1954                                                  canonicalization.  I borrowed the idea of adding DROP USER from that script,
1955                                                  and it inspired me to add the REVOKE functionality too.
1956                                                  
1957                                                  =head1 AUTHOR
1958                                                  
1959                                                  Baron Schwartz
1960                                                  
1961                                                  =head1 ABOUT MAATKIT
1962                                                  
1963                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
1964                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
1965                                                  code contributors.  Both are employed by Percona.  Financial support for
1966                                                  Maatkit development is primarily provided by Percona and its clients. 
1967                                                  
1968                                                  =head1 VERSION
1969                                                  
1970                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
1971                                                  
1972                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
58    ***     50      0      6   unless $args{$arg}
64    ***     50      0      6   exists $args{'strict'} ? :
107   ***     50      0      6   unless open my $fh, '<', $file
127          100   1368      6   unless $para =~ /^=head1 OPTIONS/
132   ***     50      6      0   if $para =~ /^=over/
140   ***     50      0      6   unless $para
143          100    132      6   if (my($option) = $para =~ /^=item --(.*)/)
150          100     90     42   if ($para =~ /: /) { }
154   ***     50      0    144   unless $attributes{$attrib}
158          100     48     42   if ($attribs{'short form'})
174   ***     50      0    132   if $para =~ /^=item/
176          100     12    120   if (my($base_option) = $option =~ /^\[no\](.*)/)
181          100     48     84   $attribs{'short form'} ? :
             100     12    120   $attribs{'negatable'} ? :
      ***     50      0    132   $attribs{'cumulative'} ? :
             100     78     54   $attribs{'type'} ? :
             100     18    114   $attribs{'default'} ? :
      ***     50      0    132   $attribs{'group'} ? :
193   ***     50      0    180   unless $para
196          100      6    174   if ($para =~ /^=head1/)
200          100    132     42   if $para =~ /^=item --/
204   ***     50      0      6   unless @specs
215   ***     50    132      0   if (ref $opt) { }
220   ***     50      0    132   if (not $long)
225   ***     50      0    132   if exists $$self{'opts'}{$long}
228   ***     50      0    132   if (length $long == 1)
233          100     48     84   if ($short) { }
234   ***     50      0     48   if exists $$self{'short_opts'}{$short}
243          100     12    120   $$opt{'spec'} =~ /!/ ? :
244   ***     50      0    132   $$opt{'spec'} =~ /\+/ ? :
245   ***     50      0    132   $$opt{'desc'} =~ /required/ ? :
257   ***     50      0    132   if ($type and $type eq 'd' and not $$self{'dp'})
262          100     18    114   if $type and $type =~ /[HhAadzm]/
264          100     18    114   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
265   ***     50     18      0   defined $def ? :
269          100      6    126   if ($long eq 'config')
273   ***     50      0    132   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
286   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
291   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
296   ***      0      0      0   if ($opt =~ /default to/)
301   ***      0      0      0   if ($opt =~ /restricted to option groups/)
311   ***      0      0      0   unless $rule_ok
328   ***      0      0      0   unless exists $$self{'opts'}{$long}
352   ***      0      0      0   unless exists $$self{'opts'}{$long}
372   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     21      0   exists $$self{'opts'}{$opt} ? :
377   ***     50      0     21   if ($$opt{'is_cumulative'}) { }
392   ***     50      0    108   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     24    108   exists $$self{'defaults'}{$long} ? :
401   ***     50      0      6   if (@ARGV and $ARGV[0] eq '--config')
405   ***     50      6      0   if ($self->has('config'))
411   ***     50     24      0   if ($EVAL_ERROR)
412   ***     50      0     24   $self->got('config') ? :
427   ***     50      0      6   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
430   ***     50      0      6   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
431   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
437   ***     50      0      6   if (@ARGV and $$self{'strict'})
443   ***      0      0      0   if (@set > 1)
454   ***      0      0      0   if (@set == 0)
464          100     21    111   if ($$opt{'got'}) { }
      ***     50      0    111   elsif ($$opt{'is_required'}) { }
465   ***     50      0     21   if (exists $$self{'disables'}{$long})
472   ***     50      0     21   if (exists $$self{'allowed_groups'}{$long})
484   ***      0      0      0   if $restricted_opt eq $long
485   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
490   ***      0      0      0   if (@restricted_opts)
492   ***      0      0      0   if (@restricted_opts == 1) { }
521          100     54     78   unless $opt and $$opt{'type'}
524   ***     50      0     78   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0     78   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     78   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0     78   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      9     69   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
527   ***      0      0      0   if (not $suffix)
533   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
534   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
549   ***      0      0      0   if ($from_key)
560   ***      0      0      0   if (defined $num) { }
561   ***      0      0      0   if ($factor)
588          100     54    158   length $opt == 1 ? :
589   ***     50      0    212   unless $long and exists $$self{'opts'}{$long}
596   ***     50      0     24   length $opt == 1 ? :
597   ***     50      0     24   unless $long and exists $$self{'opts'}{$long}
604          100     48      6   length $opt == 1 ? :
605   ***     50     54      0   defined $long ? :
610   ***     50      0      3   length $opt == 1 ? :
611   ***     50      0      3   unless $long and exists $$self{'opts'}{$long}
645   ***     50      0      6   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      6   elsif (scalar @{$$self{'errors'};}) { }
646   ***      0      0      0   unless print $self->print_usage
650   ***      0      0      0   unless print $self->print_errors
659   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
668   ***      0      0      0   unless $$self{'got_opts'}
671   ***      0      0      0   $$_{'is_negatable'} ? :
675   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
691   ***      0      0      0   $group eq 'default' ? :
697   ***      0      0      0   $$opt{'is_negatable'} ? :
700   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
709   ***      0      0      0   if ($short) { }
718   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
722   ***      0      0      0   if ($$self{'dp'})
730   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
742   ***      0      0      0   if ref $_[0] eq 'OptionParser'
745   ***      0      0      0   unless print $prompt
753   ***      0      0      0   unless print "\n"
756   ***      0      0      0   if ($EVAL_ERROR)
778   ***     50     24      0   unless open my $fh, '<', $filename
786   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
789   ***      0      0      0   if ($line eq '--')
794   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
812   ***      0      0      0   unless open my $fh, '<', $file
816   ***      0      0      0   unless $para =~ /^=pod$/m
820   ***      0      0      0   unless $para =~ /$regex/
825   ***      0      0      0   unless close $fh
839   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
854   ***      0      0      0   defined $_ ? :
940          100      6     33   if (@_ > 2)
949   ***     50      0      9   if (not $dsn)
961   ***     50     18      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
973   ***     50      0     72   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
979          100     54     18   if (not defined $final_props{$key})
986   ***     50      0     18   unless exists $opts{$key}
989   ***     50      0      9   if (my $required = $self->prop('required'))
991   ***      0      0      0   unless $final_props{$key}
1000  ***     50      0      6   unless ref $o eq 'OptionParser'
1003  ***     50     48      0   if $o->has($_)
1013  ***      0      0      0   unless ref $dsn
1014  ***      0      0      0   $_ eq 'p' ? :
1015  ***      0      0      0   if defined $$dsn{$_}
1028  ***      0      0      0   $opts{$key}{'copy'} ? :
1042  ***     50      0      9   if ($driver eq 'Pg') { }
1074  ***     50      0      9   $cxn_string =~ /charset=utf8/ ? :
1083  ***     50      0      9   if (not $have_dbi)
1102  ***     50      9      0   if ($cxn_string =~ /mysql/i)
1110  ***     50      0      9   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1115  ***      0      0      0   if ($charset eq 'utf8') { }
1116  ***      0      0      0   unless binmode STDOUT, ':utf8'
1120  ***      0      0      0   unless binmode STDOUT
1124         100      6      3   if ($self->prop('set-vars'))
1131  ***     50      0      9   if (not $dbh and $EVAL_ERROR)
1133  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1146  ***      0      0      0   if (not $tries)
1168  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1185  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1195  ***      0      0      0   unless $dsn_1
1196  ***      0      0      0   unless $dsn_2
1200  ***      0      0      0   if ($args{'overwrite'}) { }
1201  ***      0      0      0   defined $$dsn_1{$key} ? :
1204  ***      0      0      0   defined $$dsn_2{$key} ? :
1213  ***      0      0      0   defined $_ ? :
1242  ***      0      0      0   unless $args{$arg}
1245  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1261  ***      0      0      0   unless defined(my $pid = fork)
1262  ***      0      0      0   if ($pid)
1269  ***      0      0      0   unless POSIX::setsid()
1270  ***      0      0      0   unless chdir '/'
1276  ***      0      0      0   if (-t STDIN)
1278  ***      0      0      0   unless open STDIN, '/dev/null'
1282  ***      0      0      0   if ($$self{'log_file'}) { }
1284  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1288  ***      0      0      0   unless open STDERR, '>&STDOUT'
1292  ***      0      0      0   if (-t STDOUT)
1294  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1297  ***      0      0      0   if (-t STDERR)
1299  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1310  ***      0      0      0   $self ? :
1312  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1315  ***      0      0      0   if $EVAL_ERROR
1317  ***      0      0      0   if ($pid) { }
1319  ***      0      0      0   if ($pid_is_alive) { }
1341  ***      0      0      0   if (exists $$self{'child'})
1353  ***      0      0      0   if (not $PID_file)
1360  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1362  ***      0      0      0   unless print $PID_FH $PID
1364  ***      0      0      0   unless close $PID_FH
1373  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1374  ***      0      0      0   unless unlink $$self{'PID_file'}
1386  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1392  ***      0      0      0   defined $_ ? :
1439  ***     50      0      6   if ($o->get('pid'))
1451         100      2      4   if (my $users = $o->get('only'))
1458         100      1      1   if (not $_ =~ /\@/) { }
1473         100      1      5   if (my $users = $o->get('ignore'))
1488  ***     50      0      6   if ($o->get('ask-pass'))
1496         100      3      1   $o->get('timestamp') ? :
             100      4      2   if $o->get('header')
1505         100      1      5   if (scalar @all_hosts)
1518         100      4     17   if ($ignore_users and $$ignore_users{$user_host}) { }
1530  ***     50      0     17   if ($EVAL_ERROR)
1534  ***     50      0     17   unless @grants
1536         100      8      9   if ($o->get('separate')) { }
1545         100      4      6   if ($_ =~ /IDENTIFIED BY/)
1546  ***     50      0      4   if ($count++)
1562  ***     50      3      0   unless $b =~ /IDENTIFIED BY/ <=> $a =~ /IDENTIFIED BY/
1567         100     13      4   if ($o->get('revoke'))
1576         100      1     15   if (not $user)
1583         100     10      6   if ($o->get('separate')) { }
1592         100      3     13   if ($grant =~ /WITH GRANT OPTION/)
1593  ***     50      3      0   if $user
1606         100      8      9   if ($o->get('drop'))
1616         100      8      9   if ($o->get('flush') and $o->get('separate'))
1623  ***     50      0      6   if ($o->get('flush') and not $o->get('separate'))
1652  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
257   ***     66     54     78      0   $type and $type eq 'd'
      ***     33    132      0      0   $type and $type eq 'd' and not $$self{'dp'}
262          100     54     60     18   $type and $type =~ /[HhAadzm]/
401   ***     33      0      6      0   @ARGV and $ARGV[0] eq '--config'
430   ***     33      0      6      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
437   ***     33      6      0      0   @ARGV and $$self{'strict'}
521   ***     66      0     54     78   $opt and $$opt{'type'}
524   ***     66     57     21      0   $val and $$opt{'type'} eq 'm'
      ***     66     57     21      0   $val and $$opt{'type'} eq 'd'
      ***     66     57     21      0   $val and $$opt{'type'} eq 'z'
      ***     66     57     21      0   defined $val and $$opt{'type'} eq 'h'
             100     57     12      3   defined $val and $$opt{'type'} eq 'a'
589   ***     33      0      0    212   $long and exists $$self{'opts'}{$long}
597   ***     33      0      0     24   $long and exists $$self{'opts'}{$long}
611   ***     33      0      0      3   $long and exists $$self{'opts'}{$long}
700   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
794   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
973   ***     66     18     54      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     72      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1095  ***     66      9      0      9   not $dbh and $tries--
1131  ***     33      9      0      0   not $dbh and $EVAL_ERROR
1312  ***      0      0      0      0   $PID_file and -f $PID_file
1373  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1518  ***     66     17      0      4   $ignore_users and $$ignore_users{$user_host}
1616  ***     66      9      0      8   $o->get('flush') and $o->get('separate')
1623  ***     66      4      2      0   $o->get('flush') and not $o->get('separate')

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0      4   $ENV{'MKDEBUG'} || 0
61    ***     33      6      0   0
62    ***     50      6      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
64    ***     50      0      6   $args{'prompt'} || '<options>'
      ***     50      0      6   $args{'dp'} || undef
106   ***     50      0      6   $file ||= '/home/daniel/dev/maatkit/mk-show-grants/mk-show-grants'
247   ***     50    132      0   $$opt{'group'} ||= 'default'
529   ***      0      0      0   $s || 's'
538   ***      0      0      0   $prefix || ''
566   ***      0      0      0   $pre || ''
573   ***      0      0      0   $val || ''
576   ***     50      9      0   $val || ''
634   ***      0      0      0   $$self{'description'} || ''
702   ***      0      0      0   $s ||= 's'
728   ***      0      0      0   $$opt{'type'} || ''
883   ***     50      0      4   $ENV{'MKDEBUG'} || 0
954   ***     50      0      9   $prev ||= {}
955   ***     50      0      9   $defaults ||= {}
1028  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1041  ***     50      0      9   $self->prop('dbidriver') || ''
1045  ***      0      0      0   $$info{'D'} || ''
1051  ***     50      0      9   $$info{'D'} || ''
1073  ***     50      9      0   $opts ||= {}
1168  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1184  ***      0      0      0   $level ||= 0
1185  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1237  ***     50      0      4   $ENV{'MKDEBUG'} || 0
1416  ***     50      0      4   $ENV{'MKDEBUG'} || 0
1496  ***     50      4      0   $$dbh{'mysql_hostinfo'} || ''
1646         100      2      4   $host ||= '%'

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
62    ***     33      6      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33      6      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
524   ***     33      0      0     78   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
             100      6      3     69   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1064  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1065  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1066  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1067  ***      0      0      0      0   $$dsn{'u'} ||= $user
1068  ***      0      0      0      0   $$dsn{'D'} ||= $db
1386  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1502  ***     66      2      4      0   $o->get('only') || $dbh->selectall_arrayref('SELECT DISTINCT User, Host FROM mysql.user ORDER BY User, Host', {'Slice', {}})


Covered Subroutines
-------------------

Subroutine           Count Location                                                   
-------------------- ----- -----------------------------------------------------------
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1231
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1232
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1234
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1235
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1237
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1414
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1416
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:27  
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:28  
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:35  
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:36  
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:38  
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:39  
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:40  
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:42  
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:871 
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:872 
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:873 
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:874 
BEGIN                    4 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:883 
__ANON__                21 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:425 
_parse_specs             6 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:211 
_pod_to_specs            6 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:105 
_read_config_file       24 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:777 
_set_option             21 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:371 
_validate_type         132 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:520 
get                    212 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:587 
get_cxn_params           9 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1038
get_dbh                  9 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1072
get_defaults_files       6 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:100 
get_opts                 6 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:388 
get_specs                6 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:93  
got                     24 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:595 
has                     54 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:603 
main                     6 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1419
new                      6 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:56  
new                      9 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:886 
parse                    9 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:948 
parse_options            6 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:999 
parse_user               6 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1635
prop                    39 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:939 
set                      3 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:609 
usage_or_errors          6 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:644 

Uncovered Subroutines
---------------------

Subroutine           Count Location                                                   
-------------------- ----- -----------------------------------------------------------
DESTROY                  0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1385
_d                       0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1212
_d                       0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1391
_d                       0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1651
_d                       0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:853 
_get_participants        0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:325 
_make_PID_file           0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1350
_remove_PID_file         0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1372
as_string                0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1012
check_PID_file           0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1309
clone                    0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:830 
copy                     0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1194
daemonize                0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1258
descr                    0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:633 
disconnect               0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1177
errors                   0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:623 
fill_in_dsn              0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1060
get_defaults             0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:361 
get_groups               0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:366 
get_hostname             0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1167
make_PID_file            0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1340
new                      0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1240
opts                     0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:337 
print_active_handles     0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1183
print_errors             0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:657 
print_usage              0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:667 
prompt                   0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:628 
prompt_noecho            0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:742 
read_para_after          0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:811 
save_error               0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:618 
set_defaults             0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:349 
short_opts               0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:343 
usage                    0 /home/daniel/dev/maatkit/mk-show-grants/mk-show-grants:1021


