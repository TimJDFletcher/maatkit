---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...mk-error-log/mk-error-log   55.4   38.0   41.7   66.2    n/a  100.0   50.3
Total                          55.4   38.0   41.7   66.2    n/a  100.0   50.3
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 18:05:05 2010
Finish:       Thu Jan 28 18:05:05 2010

Run:          ./101_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 18:05:07 2010
Finish:       Thu Jan 28 18:05:07 2010

/home/daniel/dev/maatkit/mk-error-log/mk-error-log

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             1                    1            12   use strict;
               1                                  3   
               1                                  7   
21             1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  7   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # OptionParser package 5568
29                                                    # ###########################################################################
30                                                    package OptionParser;
31                                                    
32             1                    1             6   use strict;
               1                                  2   
               1                                  5   
33             1                    1             5   use warnings FATAL => 'all';
               1                                  6   
               1                                  5   
34                                                    
35             1                    1            10   use Getopt::Long;
               1                                  3   
               1                                  7   
36             1                    1             7   use List::Util qw(max);
               1                                  2   
               1                                 11   
37             1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
38                                                    
39    ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 22   
40                                                    
41                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
42                                                    
43                                                    my %attributes = (
44                                                       'type'       => 1,
45                                                       'short form' => 1,
46                                                       'group'      => 1,
47                                                       'default'    => 1,
48                                                       'cumulative' => 1,
49                                                       'negatable'  => 1,
50                                                    );
51                                                    
52                                                    sub new {
53             9                    9           201      my ( $class, %args ) = @_;
54             9                                 80      foreach my $arg ( qw(description) ) {
55    ***      9     50                         115         die "I need a $arg argument" unless $args{$arg};
56                                                       }
57             9                                214      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
58    ***      9            50                   92      $program_name ||= $PROGRAM_NAME;
59    ***      9            33                  128      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
60                                                    
61    ***      9     50     50                  713      my $self = {
      ***                   50                        
62                                                          description    => $args{description},
63                                                          prompt         => $args{prompt} || '<options>',
64                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
65                                                          dp             => $args{dp}     || undef,
66                                                          program_name   => $program_name,
67                                                          opts           => {},
68                                                          got_opts       => 0,
69                                                          short_opts     => {},
70                                                          defaults       => {},
71                                                          groups         => {},
72                                                          allowed_groups => {},
73                                                          errors         => [],
74                                                          rules          => [],  # desc of rules for --help
75                                                          mutex          => [],  # rule: opts are mutually exclusive
76                                                          atleast1       => [],  # rule: at least one opt is required
77                                                          disables       => {},  # rule: opt disables other opts 
78                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
79                                                          default_files  => [
80                                                             "/etc/maatkit/maatkit.conf",
81                                                             "/etc/maatkit/$program_name.conf",
82                                                             "$home/.maatkit.conf",
83                                                             "$home/.$program_name.conf",
84                                                          ],
85                                                       };
86             9                                 78      return bless $self, $class;
87                                                    }
88                                                    
89                                                    sub get_specs {
90             9                    9            51      my ( $self, $file ) = @_;
91             9                                 72      my @specs = $self->_pod_to_specs($file);
92             9                                180      $self->_parse_specs(@specs);
93             9                                 33      return;
94                                                    }
95                                                    
96                                                    sub get_defaults_files {
97             9                    9            34      my ( $self ) = @_;
98             9                                 27      return @{$self->{default_files}};
               9                                 97   
99                                                    }
100                                                   
101                                                   sub _pod_to_specs {
102            9                    9            40      my ( $self, $file ) = @_;
103   ***      9            50                   46      $file ||= __FILE__;
104   ***      9     50                         314      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
105                                                   
106            9                                209      my %types = (
107                                                         string => 's', # standard Getopt type
108                                                         'int'  => 'i', # standard Getopt type
109                                                         float  => 'f', # standard Getopt type
110                                                         Hash   => 'H', # hash, formed from a comma-separated list
111                                                         hash   => 'h', # hash as above, but only if a value is given
112                                                         Array  => 'A', # array, similar to Hash
113                                                         array  => 'a', # array, similar to hash
114                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
115                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
116                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
117                                                      );
118            9                                 31      my @specs = ();
119            9                                 32      my @rules = ();
120            9                                 26      my $para;
121                                                   
122            9                                 75      local $INPUT_RECORD_SEPARATOR = '';
123            9                                176      while ( $para = <$fh> ) {
124         1944    100                       12826         next unless $para =~ m/^=head1 OPTIONS/;
125            9                                 28         last;
126                                                      }
127                                                   
128            9                                 53      while ( $para = <$fh> ) {
129   ***      9     50                          94         last if $para =~ m/^=over/;
130   ***      0                                  0         chomp $para;
131   ***      0                                  0         $para =~ s/\s+/ /g;
132   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
133   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
134   ***      0                                  0         push @rules, $para;
135                                                      }
136                                                   
137   ***      9     50                          37      die 'POD has no OPTIONS section' unless $para;
138                                                   
139            9                                 29      do {
140          144    100                         967         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
141          135                                389            chomp $para;
142          135                                303            MKDEBUG && _d($para);
143          135                                311            my %attribs;
144                                                   
145          135                                472            $para = <$fh>; # read next paragraph, possibly attributes
146                                                   
147          135    100                         533            if ( $para =~ m/: / ) { # attributes
148          108                                506               $para =~ s/\s+\Z//g;
149          180                                919               %attribs = map {
150          108                                532                     my ( $attrib, $val) = split(/: /, $_);
151   ***    180     50                         797                     die "Unrecognized attribute for --$option: $attrib"
152                                                                        unless $attributes{$attrib};
153          180                               1014                     ($attrib, $val);
154                                                                  } split(/; /, $para);
155          108    100                         502               if ( $attribs{'short form'} ) {
156           63                                313                  $attribs{'short form'} =~ s/-//;
157                                                               }
158          108                                465               $para = <$fh>; # read next paragraph, probably short help desc
159                                                            }
160                                                            else {
161           27                                 68               MKDEBUG && _d('Option has no attributes');
162                                                            }
163                                                   
164          135                                988            $para =~ s/\s+\Z//g;
165          135                                984            $para =~ s/\s+/ /g;
166          135                                623            $para =~ s/$POD_link_re/$1/go;
167                                                   
168          135                                520            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
169          135                                296            MKDEBUG && _d('Short help:', $para);
170                                                   
171   ***    135     50                         540            die "No description after option spec $option" if $para =~ m/^=item/;
172                                                   
173          135    100                         669            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
174            9                                 27               $option = $base_option;
175            9                                 36               $attribs{'negatable'} = 1;
176                                                            }
177                                                   
178          135    100                        2417            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
179                                                               spec  => $option
180                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
181                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
182                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
183                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
184                                                               desc  => $para
185                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
186                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
187                                                            };
188                                                         }
189          144                                815         while ( $para = <$fh> ) {
190   ***    153     50                         523            last unless $para;
191                                                   
192                                                   
193          153    100                         635            if ( $para =~ m/^=head1/ ) {
194            9                                 25               $para = undef; # Can't 'last' out of a do {} block.
195            9                                 84               last;
196                                                            }
197          144    100                         945            last if $para =~ m/^=item --/;
198                                                         }
199                                                      } while ( $para );
200                                                   
201   ***      9     50                          37      die 'No valid specs in POD OPTIONS' unless @specs;
202                                                   
203            9                                 90      close $fh;
204            9                                 32      return @specs, @rules;
205                                                   }
206                                                   
207                                                   sub _parse_specs {
208            9                    9            56      my ( $self, @specs ) = @_;
209            9                                 31      my %disables; # special rule that requires deferred checking
210                                                   
211            9                                 47      foreach my $opt ( @specs ) {
212   ***    135     50                         491         if ( ref $opt ) { # It's an option spec, not a rule.
213                                                            MKDEBUG && _d('Parsing opt spec:',
214          135                                287               map { ($_, '=>', $opt->{$_}) } keys %$opt);
215                                                   
216          135                               1009            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
217   ***    135     50                         564            if ( !$long ) {
218   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
219                                                            }
220          135                                478            $opt->{long} = $long;
221                                                   
222   ***    135     50                         613            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
223          135                                629            $self->{opts}->{$long} = $opt;
224                                                   
225   ***    135     50                         515            if ( length $long == 1 ) {
226   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
227   ***      0                                  0               $self->{short_opts}->{$long} = $long;
228                                                            }
229                                                   
230          135    100                         425            if ( $short ) {
231   ***     63     50                         286               die "Duplicate short option -$short"
232                                                                  if exists $self->{short_opts}->{$short};
233           63                                283               $self->{short_opts}->{$short} = $long;
234           63                                219               $opt->{short} = $short;
235                                                            }
236                                                            else {
237           72                                261               $opt->{short} = undef;
238                                                            }
239                                                   
240          135    100                         723            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
241   ***    135     50                         676            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
242   ***    135     50                         754            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
243                                                   
244   ***    135            50                  538            $opt->{group} ||= 'default';
245          135                                670            $self->{groups}->{ $opt->{group} }->{$long} = 1;
246                                                   
247          135                                456            $opt->{value} = undef;
248          135                                444            $opt->{got}   = 0;
249                                                   
250          135                                724            my ( $type ) = $opt->{spec} =~ m/=(.)/;
251          135                                498            $opt->{type} = $type;
252          135                                293            MKDEBUG && _d($long, 'type:', $type);
253                                                   
254   ***    135     50     66                 1725            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
255   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
256                                                                  . "was given when this OptionParser object was created";
257                                                            }
258                                                   
259          135    100    100                 1005            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
260                                                   
261          135    100                         811            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
262   ***     18     50                          98               $self->{defaults}->{$long} = defined $def ? $def : 1;
263           18                                 46               MKDEBUG && _d($long, 'default:', $def);
264                                                            }
265                                                   
266          135    100                         526            if ( $long eq 'config' ) {
267            9                                 47               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
268                                                            }
269                                                   
270   ***    135     50                         720            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
271   ***      0                                  0               $disables{$long} = $dis;
272   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
273                                                            }
274                                                   
275          135                                652            $self->{opts}->{$long} = $opt;
276                                                         }
277                                                         else { # It's an option rule, not a spec.
278   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
279   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
280   ***      0                                  0            my @participants = $self->_get_participants($opt);
281   ***      0                                  0            my $rule_ok = 0;
282                                                   
283   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
284   ***      0                                  0               $rule_ok = 1;
285   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
286   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
287                                                            }
288   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
289   ***      0                                  0               $rule_ok = 1;
290   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
291   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
292                                                            }
293   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
294   ***      0                                  0               $rule_ok = 1;
295   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
296   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
297                                                            }
298   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
299   ***      0                                  0               $rule_ok = 1;
300   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
301   ***      0                                  0               my @groups = split(',', $groups);
302   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
303   ***      0                                  0                  s/\s+//;
304   ***      0                                  0                  $_ => 1;
305                                                               } @groups;
306                                                            }
307                                                   
308   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
309                                                         }
310                                                      }
311                                                   
312            9                                 61      foreach my $long ( keys %disables ) {
313   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
314   ***      0                                  0         $self->{disables}->{$long} = \@participants;
315   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
316                                                      }
317                                                   
318            9                                 41      return; 
319                                                   }
320                                                   
321                                                   sub _get_participants {
322   ***      0                    0             0      my ( $self, $str ) = @_;
323   ***      0                                  0      my @participants;
324   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
325   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
326                                                            unless exists $self->{opts}->{$long};
327   ***      0                                  0         push @participants, $long;
328                                                      }
329   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
330   ***      0                                  0      return @participants;
331                                                   }
332                                                   
333                                                   sub opts {
334   ***      0                    0             0      my ( $self ) = @_;
335   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
336   ***      0                                  0      return %opts;
337                                                   }
338                                                   
339                                                   sub short_opts {
340   ***      0                    0             0      my ( $self ) = @_;
341   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
342   ***      0                                  0      return %short_opts;
343                                                   }
344                                                   
345                                                   sub set_defaults {
346   ***      0                    0             0      my ( $self, %defaults ) = @_;
347   ***      0                                  0      $self->{defaults} = {};
348   ***      0                                  0      foreach my $long ( keys %defaults ) {
349   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
350                                                            unless exists $self->{opts}->{$long};
351   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
352   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
353                                                      }
354   ***      0                                  0      return;
355                                                   }
356                                                   
357                                                   sub get_defaults {
358   ***      0                    0             0      my ( $self ) = @_;
359   ***      0                                  0      return $self->{defaults};
360                                                   }
361                                                   
362                                                   sub get_groups {
363   ***      0                    0             0      my ( $self ) = @_;
364   ***      0                                  0      return $self->{groups};
365                                                   }
366                                                   
367                                                   sub _set_option {
368   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
369   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
370                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
371                                                               : die "Getopt::Long gave a nonexistent option: $opt";
372                                                   
373   ***      0                                  0      $opt = $self->{opts}->{$long};
374   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
375   ***      0                                  0         $opt->{value}++;
376                                                      }
377                                                      else {
378   ***      0                                  0         $opt->{value} = $val;
379                                                      }
380   ***      0                                  0      $opt->{got} = 1;
381   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
382                                                   }
383                                                   
384                                                   sub get_opts {
385            9                    9            40      my ( $self ) = @_; 
386                                                   
387            9                                 31      foreach my $long ( keys %{$self->{opts}} ) {
               9                                111   
388          135                                567         $self->{opts}->{$long}->{got} = 0;
389   ***    135     50                        1217         $self->{opts}->{$long}->{value}
                    100                               
390                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
391                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
392                                                            : undef;
393                                                      }
394            9                                 43      $self->{got_opts} = 0;
395                                                   
396            9                                 49      $self->{errors} = [];
397                                                   
398   ***      9     50     33                  145      if ( @ARGV && $ARGV[0] eq "--config" ) {
399   ***      0                                  0         shift @ARGV;
400   ***      0                                  0         $self->_set_option('config', shift @ARGV);
401                                                      }
402   ***      9     50                         136      if ( $self->has('config') ) {
403            9                                 27         my @extra_args;
404            9                                 83         foreach my $filename ( split(',', $self->get('config')) ) {
405           36                                 94            eval {
406           36                                188               push @extra_args, $self->_read_config_file($filename);
407                                                            };
408   ***     36     50                         186            if ( $EVAL_ERROR ) {
409   ***     36     50                         164               if ( $self->got('config') ) {
410   ***      0                                  0                  die $EVAL_ERROR;
411                                                               }
412                                                               elsif ( MKDEBUG ) {
413                                                                  _d($EVAL_ERROR);
414                                                               }
415                                                            }
416                                                         }
417            9                                 46         unshift @ARGV, @extra_args;
418                                                      }
419                                                   
420            9                                112      Getopt::Long::Configure('no_ignore_case', 'bundling');
421                                                      GetOptions(
422   ***    126                    0           984         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
             135                                528   
423            9                                 51         grep   { $_->{long} ne 'config' } # --config is handled specially above.
424   ***      9     50                          34         values %{$self->{opts}}
425                                                      ) or $self->save_error('Error parsing options');
426                                                   
427   ***      9     50     33                  308      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
428   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
429                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
430                                                               or die "Cannot print: $OS_ERROR";
431   ***      0                                  0         exit 0;
432                                                      }
433                                                   
434   ***      9     50     33                   91      if ( @ARGV && $self->{strict} ) {
435   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
436                                                      }
437                                                   
438            9                                 25      foreach my $mutex ( @{$self->{mutex}} ) {
               9                                 53   
439   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
440   ***      0      0                           0         if ( @set > 1 ) {
441   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
442   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
443                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
444                                                                    . ' are mutually exclusive.';
445   ***      0                                  0            $self->save_error($err);
446                                                         }
447                                                      }
448                                                   
449            9                                 25      foreach my $required ( @{$self->{atleast1}} ) {
               9                                 49   
450   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
451   ***      0      0                           0         if ( @set == 0 ) {
452   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
453   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
454                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
455   ***      0                                  0            $self->save_error("Specify at least one of $err");
456                                                         }
457                                                      }
458                                                   
459            9                                 23      foreach my $long ( keys %{$self->{opts}} ) {
               9                                 81   
460          135                                501         my $opt = $self->{opts}->{$long};
461   ***    135     50                         724         if ( $opt->{got} ) {
      ***            50                               
462   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
463   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
464   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
465   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
466                                                                  'because', $long,'disables them');
467                                                            }
468                                                   
469   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
470                                                   
471   ***      0                                  0               my @restricted_groups = grep {
472   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
473   ***      0                                  0               } keys %{$self->{groups}};
474                                                   
475   ***      0                                  0               my @restricted_opts;
476   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
477   ***      0                                  0                  RESTRICTED_OPT:
478   ***      0                                  0                  foreach my $restricted_opt (
479                                                                     keys %{$self->{groups}->{$restricted_group}} )
480                                                                  {
481   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
482   ***      0      0                           0                     push @restricted_opts, $restricted_opt
483                                                                        if $self->{opts}->{$restricted_opt}->{got};
484                                                                  }
485                                                               }
486                                                   
487   ***      0      0                           0               if ( @restricted_opts ) {
488   ***      0                                  0                  my $err;
489   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
490   ***      0                                  0                     $err = "--$restricted_opts[0]";
491                                                                  }
492                                                                  else {
493   ***      0                                  0                     $err = join(', ',
494   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
495   ***      0                                  0                               grep { $_ } 
496                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
497                                                                            )
498                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
499                                                                  }
500   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
501                                                               }
502                                                            }
503                                                   
504                                                         }
505                                                         elsif ( $opt->{is_required} ) { 
506   ***      0                                  0            $self->save_error("Required option --$long must be specified");
507                                                         }
508                                                   
509          135                                506         $self->_validate_type($opt);
510                                                      }
511                                                   
512            9                                 45      $self->{got_opts} = 1;
513            9                                 27      return;
514                                                   }
515                                                   
516                                                   sub _validate_type {
517          135                  135           468      my ( $self, $opt ) = @_;
518   ***    135    100     66                 1126      return unless $opt && $opt->{type};
519           99                                327      my $val = $opt->{value};
520                                                   
521   ***     99     50     66                 2320      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
522   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
523   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
524   ***      0      0                           0         if ( !$suffix ) {
525   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
526   ***      0             0                    0            $suffix = $s || 's';
527   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
528                                                               $opt->{long}, '(value:', $val, ')');
529                                                         }
530   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
531   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
532                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
533                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
534                                                                 :                  $num * 86400;   # Days
535   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
536   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
537                                                         }
538                                                         else {
539   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
540                                                         }
541                                                      }
542                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
543   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
544   ***      0                                  0         my $prev = {};
545   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
546   ***      0      0                           0         if ( $from_key ) {
547   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
548   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
549                                                         }
550   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
551   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
552                                                      }
553                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
554   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
555   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
556   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
557   ***      0      0                           0         if ( defined $num ) {
558   ***      0      0                           0            if ( $factor ) {
559   ***      0                                  0               $num *= $factor_for{$factor};
560   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
561                                                                  'to num', $num, '* factor', $factor);
562                                                            }
563   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
564                                                         }
565                                                         else {
566   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
567                                                         }
568                                                      }
569                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
570   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
571                                                      }
572                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
573   ***      9            50                  157         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
574                                                      }
575                                                      else {
576           90                                209         MKDEBUG && _d('Nothing to validate for option',
577                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
578                                                      }
579                                                   
580           99                                343      return;
581                                                   }
582                                                   
583                                                   sub get {
584           36                   36           171      my ( $self, $opt ) = @_;
585   ***     36     50                         170      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
586   ***     36     50     33                  348      die "Option $opt does not exist"
587                                                         unless $long && exists $self->{opts}->{$long};
588           36                                298      return $self->{opts}->{$long}->{value};
589                                                   }
590                                                   
591                                                   sub got {
592           36                   36           168      my ( $self, $opt ) = @_;
593   ***     36     50                         160      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
594   ***     36     50     33                  314      die "Option $opt does not exist"
595                                                         unless $long && exists $self->{opts}->{$long};
596           36                                223      return $self->{opts}->{$long}->{got};
597                                                   }
598                                                   
599                                                   sub has {
600            9                    9            54      my ( $self, $opt ) = @_;
601   ***      9     50                          54      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
602   ***      9     50                         105      return defined $long ? exists $self->{opts}->{$long} : 0;
603                                                   }
604                                                   
605                                                   sub set {
606   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
607   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
608   ***      0      0      0                    0      die "Option $opt does not exist"
609                                                         unless $long && exists $self->{opts}->{$long};
610   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
611   ***      0                                  0      return;
612                                                   }
613                                                   
614                                                   sub save_error {
615   ***      0                    0             0      my ( $self, $error ) = @_;
616   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
617                                                   }
618                                                   
619                                                   sub errors {
620   ***      0                    0             0      my ( $self ) = @_;
621   ***      0                                  0      return $self->{errors};
622                                                   }
623                                                   
624                                                   sub prompt {
625   ***      0                    0             0      my ( $self ) = @_;
626   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
627                                                   }
628                                                   
629                                                   sub descr {
630   ***      0                    0             0      my ( $self ) = @_;
631   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
632                                                                 . "  For more details, please use the --help option, "
633                                                                 . "or try 'perldoc $PROGRAM_NAME' "
634                                                                 . "for complete documentation.";
635   ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
636                                                         unless $ENV{DONT_BREAK_LINES};
637   ***      0                                  0      $descr =~ s/ +$//mg;
638   ***      0                                  0      return $descr;
639                                                   }
640                                                   
641                                                   sub usage_or_errors {
642            9                    9            36      my ( $self ) = @_;
643   ***      9     50                          56      if ( $self->{opts}->{help}->{got} ) {
      ***      9     50                          47   
644   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
645   ***      0                                  0         exit 0;
646                                                      }
647                                                      elsif ( scalar @{$self->{errors}} ) {
648   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
649   ***      0                                  0         exit 0;
650                                                      }
651            9                                 24      return;
652                                                   }
653                                                   
654                                                   sub print_errors {
655   ***      0                    0             0      my ( $self ) = @_;
656   ***      0                                  0      my $usage = $self->prompt() . "\n";
657   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
658   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
659                                                                 . "\n";
660                                                      }
661   ***      0                                  0      return $usage . "\n" . $self->descr();
662                                                   }
663                                                   
664                                                   sub print_usage {
665   ***      0                    0             0      my ( $self ) = @_;
666   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
667   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
668                                                   
669   ***      0      0                           0      my $maxl = max(
670   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
671                                                         @opts);
672                                                   
673   ***      0      0                           0      my $maxs = max(0,
674   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
675   ***      0                                  0         values %{$self->{short_opts}});
676                                                   
677   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
678   ***      0                                  0      my $rcol = 80 - $lcol - 6;
679   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
680                                                   
681   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
682                                                   
683   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
684                                                   
685   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
686   ***      0                                  0      push @groups, 'default';
687                                                   
688   ***      0                                  0      foreach my $group ( reverse @groups ) {
689   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
690   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
691   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
692                                                            grep { $_->{group} eq $group }
693                                                            @opts )
694                                                         {
695   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
696   ***      0                                  0            my $short = $opt->{short};
697   ***      0                                  0            my $desc  = $opt->{desc};
698   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
699   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
700   ***      0             0                    0               $s    ||= 's';
701   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
702   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
703                                                                      . "d=days; if no suffix, $s is used.";
704                                                            }
705   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
706   ***      0                                  0            $desc =~ s/ +$//mg;
707   ***      0      0                           0            if ( $short ) {
708   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
709                                                            }
710                                                            else {
711   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
712                                                            }
713                                                         }
714                                                      }
715                                                   
716   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
717   ***      0                                  0         $usage .= "\nRules:\n\n";
718   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
719                                                      }
720   ***      0      0                           0      if ( $self->{dp} ) {
721   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
722                                                      }
723   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
724   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
725   ***      0                                  0         my $val   = $opt->{value};
726   ***      0             0                    0         my $type  = $opt->{type} || '';
727   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
728   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
729                                                                   : !defined $val             ? '(No value)'
730                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
731                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
732                                                                   : $type =~ m/A|a/           ? join(',', @$val)
733                                                                   :                             $val;
734   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
735                                                      }
736   ***      0                                  0      return $usage;
737                                                   }
738                                                   
739                                                   sub prompt_noecho {
740   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
741   ***      0                                  0      my ( $prompt ) = @_;
742   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
743   ***      0      0                           0      print $prompt
744                                                         or die "Cannot print: $OS_ERROR";
745   ***      0                                  0      my $response;
746   ***      0                                  0      eval {
747   ***      0                                  0         require Term::ReadKey;
748   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
749   ***      0                                  0         chomp($response = <STDIN>);
750   ***      0                                  0         Term::ReadKey::ReadMode('normal');
751   ***      0      0                           0         print "\n"
752                                                            or die "Cannot print: $OS_ERROR";
753                                                      };
754   ***      0      0                           0      if ( $EVAL_ERROR ) {
755   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
756                                                      }
757   ***      0                                  0      return $response;
758                                                   }
759                                                   
760                                                   if ( MKDEBUG ) {
761                                                      print '# ', $^X, ' ', $], "\n";
762                                                      my $uname = `uname -a`;
763                                                      if ( $uname ) {
764                                                         $uname =~ s/\s+/ /g;
765                                                         print "# $uname\n";
766                                                      }
767                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
768                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
769                                                         ($main::SVN_REV || ''), __LINE__);
770                                                      print('# Arguments: ',
771                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
772                                                   }
773                                                   
774                                                   sub _read_config_file {
775           36                   36           150      my ( $self, $filename ) = @_;
776   ***     36     50                         100      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
777   ***      0                                  0      my @args;
778   ***      0                                  0      my $prefix = '--';
779   ***      0                                  0      my $parse  = 1;
780                                                   
781                                                      LINE:
782   ***      0                                  0      while ( my $line = <$fh> ) {
783   ***      0                                  0         chomp $line;
784   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
785   ***      0                                  0         $line =~ s/\s+#.*$//g;
786   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
787   ***      0      0                           0         if ( $line eq '--' ) {
788   ***      0                                  0            $prefix = '';
789   ***      0                                  0            $parse  = 0;
790   ***      0                                  0            next LINE;
791                                                         }
792   ***      0      0      0                    0         if ( $parse
      ***             0                               
793                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
794                                                         ) {
795   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
796                                                         }
797                                                         elsif ( $line =~ m/./ ) {
798   ***      0                                  0            push @args, $line;
799                                                         }
800                                                         else {
801   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
802                                                         }
803                                                      }
804   ***      0                                  0      close $fh;
805   ***      0                                  0      return @args;
806                                                   }
807                                                   
808                                                   sub read_para_after {
809   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
810   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
811   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
812   ***      0                                  0      my $para;
813   ***      0                                  0      while ( $para = <$fh> ) {
814   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
815   ***      0                                  0         last;
816                                                      }
817   ***      0                                  0      while ( $para = <$fh> ) {
818   ***      0      0                           0         next unless $para =~ m/$regex/;
819   ***      0                                  0         last;
820                                                      }
821   ***      0                                  0      $para = <$fh>;
822   ***      0                                  0      chomp($para);
823   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
824   ***      0                                  0      return $para;
825                                                   }
826                                                   
827                                                   sub clone {
828   ***      0                    0             0      my ( $self ) = @_;
829                                                   
830   ***      0                                  0      my %clone = map {
831   ***      0                                  0         my $hashref  = $self->{$_};
832   ***      0                                  0         my $val_copy = {};
833   ***      0                                  0         foreach my $key ( keys %$hashref ) {
834   ***      0                                  0            my $ref = ref $hashref->{$key};
835   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
836   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
837   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
838                                                                              : $hashref->{$key};
839                                                         }
840   ***      0                                  0         $_ => $val_copy;
841                                                      } qw(opts short_opts defaults);
842                                                   
843   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
844   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
845                                                      }
846                                                   
847   ***      0                                  0      return bless \%clone;     
848                                                   }
849                                                   
850                                                   sub _d {
851   ***      0                    0             0      my ($package, undef, $line) = caller 0;
852   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
853   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
854                                                           @_;
855   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
856                                                   }
857                                                   
858                                                   1;
859                                                   
860                                                   # ###########################################################################
861                                                   # End OptionParser package
862                                                   # ###########################################################################
863                                                   
864                                                   # ###########################################################################
865                                                   # ReportFormatter package 5266
866                                                   # ###########################################################################
867                                                   package ReportFormatter;
868                                                   
869            1                    1            11   use strict;
               1                                  2   
               1                                  7   
870            1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  7   
871            1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  9   
872            1                    1             7   use List::Util qw(min max);
               1                                  2   
               1                                  5   
873                                                   
874   ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 20   
875                                                   
876            1                    1             7   use Data::Dumper;
               1                                  2   
               1                                  9   
877                                                   $Data::Dumper::Indent    = 1;
878                                                   $Data::Dumper::Sortkeys  = 1;
879                                                   $Data::Dumper::Quotekeys = 0;
880                                                   
881                                                   sub new {
882            9                    9            61      my ( $class, %args ) = @_;
883            9                                 33      my @required_args = qw();
884            9                                 54      foreach my $arg ( @required_args ) {
885   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
886                                                      }
887            9                                 82      my $self = {
888                                                         underline_header  => 1,
889                                                         line_prefix        => '# ',
890                                                         line_width         => 78,
891                                                         truncate_underline => 1,
892                                                         %args,
893                                                      };
894            9                                 76      return bless $self, $class;
895                                                   }
896                                                   
897                                                   sub set_title {
898   ***      0                    0             0      my ( $self, $title ) = @_;
899   ***      0                                  0      $self->{title} = $title;
900   ***      0                                  0      return;
901                                                   }
902                                                   
903                                                   sub set_columns {
904            9                    9            40      my ( $self, @cols ) = @_;
905            9                                 47      push @{$self->{cols}}, map {
              27                                 78   
906            9                                 33         my $col = $_;
907   ***     27     50                         122         die "Column does not have a name" unless defined $col->{name};
908   ***     27     50     33                  127         if ( $col->{fixed_wdith} && $col->{fixed_width} < length $col->{name} ) { 
909   ***      0                                  0            die "Fixed width is less than the column name";
910                                                         }
911           27                                116         $col->{min_val_width} = length $col->{name};
912           27                                103         $col->{max_val_width} = length $col->{name};
913           27                                 87         $col;
914                                                      } @cols;
915            9                                 30      return;
916                                                   }
917                                                   
918                                                   sub add_line {
919           50                   50           247      my ( $self, @vals ) = @_;
920                                                   
921           50                                136      my $n_cols = scalar @{$self->{cols}};
              50                                180   
922           50                                144      my $n_vals = scalar @vals;
923   ***     50     50                         190      die "Number of columns ($n_cols) and values ($n_vals) do not match"
924                                                         unless $n_cols == $n_vals;
925                                                   
926           50                                116      my @line;
927           50                                251      for my $i ( 0..$#vals ) {
928          150                                545         my $col = $self->{cols}->[$i];
929          150                                439         my $val = $vals[$i];
930          150                                399         my $width = length $val;
931   ***    150     50     66                  932         if ( $col->{fixed_width} && $width > $col->{fixed_width} ) {
932   ***      0      0                           0            if ( $col->{truncate} ) {
933   ***      0                                  0               $val  = substr($val, 0, $col->{fixed_width} - 3);
934   ***      0                                  0               $val .= '...';
935   ***      0                                  0               MKDEBUG && _d('Truncated', $vals[$i], 'to', $val);
936                                                            }
937                                                            else {
938   ***      0                                  0               die "Value '$val' is too wide for column $col->{name}";
939                                                            }
940                                                         }
941          150                                757         $col->{max_val_width} = max($width, $col->{max_val_width});
942          150                                567         push @line, $val;
943                                                      }
944           50                                144      push @{$self->{lines}}, \@line;
              50                                206   
945                                                   
946           50                                176      return;
947                                                   }
948                                                   
949                                                   sub get_report {
950            9                    9            36      my ( $self ) = @_;
951            9                                 22      my @lines;
952   ***      9            50                   77      my $p = $self->{line_prefix} || '';
953                                                   
954   ***      9     50                          25      my $n_cols = scalar @{$self->{cols}}
               9                                 53   
955                                                                 - ($self->{long_last_column} ? 2 : 1);
956                                                   
957            9                                 24      my $fmt = $p;
958            9                                 25      my @col_fmts;
959            9                                 54      for my $i ( 0..$n_cols ) {
960           27                                 99         my $col = $self->{cols}->[$i];
961           27    100                         383         my $col_fmt = '%'
962                                                                     . ($col->{right_justify} ? '' : '-')
963                                                                     . "$col->{max_val_width}"
964                                                                     . 's';
965           27                                112         push @col_fmts, $col_fmt;
966                                                      }
967   ***      9     50                          46      if ( $self->{long_last_column} ) {
968   ***      0                                  0         push @col_fmts, '%s';
969                                                      }
970            9                                 38      $fmt .= join(' ', @col_fmts);
971            9                                 23      MKDEBUG && _d('Format:', $fmt);
972                                                   
973   ***      9     50                          41      push @lines, sprintf "${p}$self->{title}" if $self->{title};
974                                                   
975            9                                123      (my $hdr_fmt = $fmt) =~ s/%([^-])/%-$1/g;
976            9                                 35      push @lines, sprintf $hdr_fmt, map { $_->{name} } @{$self->{cols}};
              27                                172   
               9                                 39   
977                                                   
978   ***      9     50                          49      if ( $self->{underline_header} ) {
979            9                                 26         my $underline_len = 0;
980           27                                112         my @underlines = map {
981            9                                 41            my $underline = '=' x $_->{max_val_width};
982           27                                 74            $underline_len += length $underline;
983           27                                 99            $underline;
984            9                                 25         } @{$self->{cols}};
985            9                                 39         $underline_len += (scalar @underlines) - 1;
986   ***      9     50     33                  109         if ( $self->{truncate_underline}
987                                                              && (2 + $underline_len) > $self->{line_width} ) {
988   ***      0                                  0            my $over = $self->{line_width} - (2 + $underline_len);
989   ***      0                                  0            $underlines[-1] = substr($underlines[-1], 0, $over);
990                                                         }
991                                                   
992            9                                 55         push @lines, sprintf $fmt, @underlines;
993                                                      }
994                                                   
995            9                                 23      foreach my $line ( @{$self->{lines}} ) {
               9                                 41   
996           50                                242         push @lines, sprintf $fmt, @$line;
997                                                      }
998                                                   
999            9                                144      return join("\n", @lines) . "\n";
1000                                                  }
1001                                                  
1002                                                  sub _d {
1003  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1004  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1005  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1006                                                          @_;
1007  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1008                                                  }
1009                                                  
1010                                                  1;
1011                                                  
1012                                                  # ###########################################################################
1013                                                  # End ReportFormatter package
1014                                                  # ###########################################################################
1015                                                  
1016                                                  # ###########################################################################
1017                                                  # ErrorLogParser package 5401
1018                                                  # ###########################################################################
1019                                                  package ErrorLogParser;
1020                                                  
1021           1                    1             8   use strict;
               1                                  2   
               1                                  5   
1022           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  9   
1023           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
1024                                                  
1025           1                    1             6   use Data::Dumper;
               1                                  2   
               1                                  5   
1026                                                  $Data::Dumper::Indent    = 1;
1027                                                  $Data::Dumper::Sortkeys  = 1;
1028                                                  $Data::Dumper::Quotekeys = 0;
1029                                                  
1030  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 12   
1031                                                  
1032                                                  my $ts = qr/(\d{6}\s{1,2}[\d:]+)\s*/;
1033                                                  my $ml = qr{\A(?:
1034                                                     InnoDB:\s
1035                                                     |-\smysqld\sgot\ssignal
1036                                                     |Status\sinformation
1037                                                     |Memory\sstatus
1038                                                  )}x;
1039                                                  
1040                                                  sub new {
1041           9                    9            48      my ( $class, %args ) = @_;
1042           9                                 58      my $self = {
1043                                                        %args,
1044                                                        pending => [],
1045                                                     };
1046           9                                 74      return bless $self, $class;
1047                                                  }
1048                                                  
1049                                                  sub parse_event {
1050          74                   74           361      my ( $self, %args ) = @_;
1051          74                                260      my @required_args = qw(fh);
1052          74                                254      foreach my $arg ( @required_args ) {
1053  ***     74     50                         371         die "I need a $arg argument" unless $args{$arg};
1054                                                     }
1055          74                                274      my ($fh) = @args{@required_args};
1056                                                  
1057          74                                238      my $pending = $self->{pending};
1058                                                  
1059          74                                248      my $pos_in_log = tell($fh);
1060          74                                172      my $line;
1061                                                     EVENT:
1062          74           100                  920      while ( defined($line = shift @$pending) or defined($line = <$fh>) ) {
1063          74    100                         477         next if $line =~ m/^\s*$/;  # lots of blank lines in error logs
1064          65                                175         chomp $line;
1065          65                                248         my @properties = ('pos_in_log', $pos_in_log);
1066          65                                195         $pos_in_log = tell($fh);
1067                                                  
1068          65    100                         519         if ( my ($ts) = $line =~ /^$ts/o ) {
1069          56                                121            MKDEBUG && _d('Got ts:', $ts);
1070          56                                184            push @properties, 'ts', $ts;
1071          56                                590            $line =~ s/^$ts//;
1072                                                        }
1073                                                  
1074          65                                172         my $level;
1075          65    100                         379         if ( ($level) = $line =~ /\[((?:ERROR|Warning|Note))\]/ ) {
1076          29    100                         159            $level = $level =~ m/error/i   ? 'error'
                    100                               
1077                                                                  : $level =~ m/warning/i ? 'warning'
1078                                                                  :                         'info';
1079                                                        }
1080                                                        else {
1081          36                                108            $level = 'unknown';
1082                                                        }
1083          65                                147         MKDEBUG && _d('Level:', $level);
1084          65                                224         push @properties, 'Level', $level;
1085                                                  
1086          65    100                         318         if ( my ($level) = $line =~ /InnoDB: Error/ ) {
1087           1                                  3            MKDEBUG && _d('Got serious InnoDB error');
1088           1                                  3            push @properties, 'Level', 'error';
1089                                                        }
1090                                                  
1091          65                                241         $line =~ s/^\s+//;
1092          65                                292         $line =~ s/\s{2,}/ /;
1093          65                                520         $line =~ s/\s+$//;
1094                                                  
1095                                                  
1096          65    100                         373         if ( $line =~ m/$ml/o ) {
                    100                               
1097          20                                 45            MKDEBUG && _d('Multi-line message:', $line);
1098          20                                 65            $line =~ s/- //; # Trim "- msyqld got signal" special case.
1099          20                                 48            my $next_line;
1100          20           100                  271            while ( defined($next_line = <$fh>)
1101                                                                   && $next_line !~ m/^$ts/o ) {
1102        3313                               8343               chomp $next_line;
1103        3313    100                       14270               next if $next_line eq '';
1104        2980                               8177               $next_line =~ s/^InnoDB: //; # InnoDB special-case.
1105        2980                              30490               $line     .= " " . $next_line;
1106                                                           }
1107          20                                 42            MKDEBUG && _d('Pending next line:', $next_line);
1108          20                                 87            push @$pending, $next_line;
1109                                                        }
1110                                                        elsif ( $line =~ m/\bQuery: '/ ) {
1111           1                                  9            MKDEBUG && _d('Error query:', $line);
1112           1                                  6            my $next_line;
1113           1                                  3            my $last_line = 0;
1114  ***      1            66                   18            while ( !$last_line && defined($next_line = <$fh>) ) {
1115           3                                  8               chomp $next_line;
1116           3                                  6               MKDEBUG && _d('Error query:', $next_line);
1117           3                                  9               $line     .= $next_line;
1118           3    100                          28               $last_line = 1 if $next_line =~ m/, Error_code:/;
1119                                                           }
1120                                                        }
1121                                                  
1122          65                                195         chomp $line;
1123          65                                389         push @properties, 'arg', $line;
1124                                                  
1125          65                                136         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
1126          65                                494         my $event = { @properties };
1127          65                                473         return $event;
1128                                                  
1129                                                     } # EVENT
1130                                                  
1131           9                                 34      @$pending = ();
1132  ***      9     50                          46      $args{oktorun}->(0) if $args{oktorun};
1133           9                                 52      return;
1134                                                  }
1135                                                  
1136                                                  sub _d {
1137  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1138  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1139  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1140                                                          @_;
1141  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1142                                                  }
1143                                                  
1144                                                  1;
1145                                                  
1146                                                  # ###########################################################################
1147                                                  # End ErrorLogParser package
1148                                                  # ###########################################################################
1149                                                  
1150                                                  # ###########################################################################
1151                                                  # ErrorLogPatternMatcher package 5573
1152                                                  # ###########################################################################
1153                                                  package ErrorLogPatternMatcher;
1154                                                  
1155           1                    1             7   use strict;
               1                                  2   
               1                                  5   
1156           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
1157           1                    1            10   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
1158           1                    1             7   use Data::Dumper;
               1                                  2   
               1                                  4   
1159                                                  $Data::Dumper::Indent    = 1;
1160                                                  $Data::Dumper::Sortkeys  = 1;
1161                                                  $Data::Dumper::Quotekeys = 0;
1162                                                  
1163  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 13   
1164                                                  
1165                                                  sub new {
1166           9                    9            43      my ( $class, %args ) = @_;
1167           9                                 72      my $self = {
1168                                                        %args,
1169                                                        patterns => [],
1170                                                        compiled => [],
1171                                                        level    => [],
1172                                                        name     => [],
1173                                                     };
1174           9                                 64      return bless $self, $class;
1175                                                  }
1176                                                  
1177                                                  sub add_patterns {
1178          39                   39           142      my ( $self, $patterns ) = @_;
1179          39                                153      foreach my $p ( @$patterns ) {
1180  ***    210     50     50                 1624         next unless $p && scalar @$p;
1181         210                               1029         my ($name, $level, $regex) = @$p;
1182         210                                603         push @{$self->{names}},    $name;
             210                                873   
1183         210                                522         push @{$self->{levels}},   $level;
             210                                765   
1184         210                                521         push @{$self->{patterns}}, $regex;
             210                                782   
1185         210                                521         push @{$self->{compiled}}, qr/$regex/;
             210                               2991   
1186         210                                665         MKDEBUG && _d('Added new pattern:', $name, $level, $regex,
1187                                                           $self->{compiled}->[-1]);
1188                                                     }
1189          39                                201      return;
1190                                                  }
1191                                                  
1192                                                  sub load_patterns_file {
1193  ***      0                    0             0      my ( $self, $fh ) = @_;
1194  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1195  ***      0                                  0      my %seen;
1196  ***      0                                  0      my $pattern;
1197  ***      0                                  0      while ( defined($pattern = <$fh>) ) {
1198  ***      0                                  0         my ($name, $level, $regex) = split("\n", $pattern);
1199  ***      0      0      0                    0         if ( !($name && $level && $regex) ) {
      ***                    0                        
1200  ***      0                                  0            warn "Pattern missing name, level or regex:\n$pattern";
1201  ***      0                                  0            next;
1202                                                        }
1203  ***      0      0                           0         if ( $seen{$name}++ ) {
1204  ***      0                                  0            warn "Duplicate pattern: $name";
1205  ***      0                                  0            next;
1206                                                        }
1207  ***      0                                  0         $self->add_patterns( [[$name, $level, $regex]] );
1208                                                     }
1209  ***      0                                  0      return;
1210                                                  }
1211                                                  
1212                                                  sub reset_patterns {
1213  ***      0                    0             0      my ( $self ) = @_;
1214  ***      0                                  0      $self->{names}    = [];
1215  ***      0                                  0      $self->{levels}   = [];
1216  ***      0                                  0      $self->{patterns} = [];
1217  ***      0                                  0      $self->{compiled} = [];
1218  ***      0                                  0      MKDEBUG && _d('Reset patterns');
1219  ***      0                                  0      return;
1220                                                  }
1221                                                  
1222                                                  sub patterns {
1223  ***      0                    0             0      my ( $self ) = @_;
1224  ***      0                                  0      return @{$self->{patterns}};
      ***      0                                  0   
1225                                                  }
1226                                                  
1227                                                  sub names {
1228           9                    9            33      my ( $self ) = @_;
1229           9                                 27      return @{$self->{names}};
               9                                191   
1230                                                  }
1231                                                  
1232                                                  sub levels {
1233           9                    9            34      my ( $self ) = @_;
1234           9                                 26      return @{$self->{levels}};
               9                                146   
1235                                                  }
1236                                                  
1237                                                  sub match {
1238          65                   65           353      my ( $self, %args ) = @_;
1239          65                                237      my @required_args = qw(event);
1240          65                                230      foreach my $arg ( @required_args ) {
1241  ***     65     50                         322         die "I need a $arg argument" unless $args{$arg};
1242                                                     }
1243          65                                223      my $event = @args{@required_args};
1244          65                                304      my $err   = $event->{arg};
1245  ***     65     50                         241      return unless $err;
1246                                                  
1247  ***     65     50     33                  340      if ( $self->{QueryRewriter}
1248                                                          && (my ($query) = $err =~ m/Statement: (.+)$/) ) {
1249  ***      0                                  0         $query = $self->{QueryRewriter}->fingerprint($query);
1250  ***      0                                  0         $err =~ s/Statement: .+$/Statement: $query/;
1251                                                     }
1252                                                  
1253          65                                211      my $compiled = $self->{compiled};
1254          65                                218      my $n        = (scalar @$compiled) - 1;
1255          65                                146      my $pno;
1256                                                     PATTERN:
1257          65                                232      for my $i ( 0..$n ) {
1258        1095    100                        6297         if ( $err =~ m/$compiled->[$i]/ ) {
1259          35                                 89            $pno = $i;
1260          35                                101            last PATTERN;
1261                                                        } 
1262                                                     }
1263                                                  
1264          65    100                         234      if ( defined $pno ) {
1265          35                                 75         MKDEBUG && _d($err, 'matches', $self->{patterns}->[$pno]);
1266          35                                139         $event->{New_pattern} = 'No';
1267          35                                118         $event->{Pattern_no}  = $pno;
1268                                                  
1269  ***     35     50     33                  249         if ( !$event->{Level} && $self->{levels}->[$pno] ) {
1270  ***      0                                  0            $event->{Level} = $self->{levels}->[$pno];
1271                                                        }
1272                                                     }
1273                                                     else {
1274          30                                 63         MKDEBUG && _d('New pattern');
1275          30                                132         my $regex = $self->fingerprint($err);
1276          30                                103         my $name  = substr($err, 0, 50);
1277          30                                195         $self->add_patterns( [ [$name, $event->{Level}, $regex] ] );
1278          30                                140         $event->{New_pattern} = 'Yes';
1279          30                                 75         $event->{Pattern_no}  = (scalar @{$self->{patterns}}) - 1;
              30                                159   
1280                                                     }
1281                                                  
1282          65                                347      $event->{Pattern} = $self->{patterns}->[ $event->{Pattern_no} ];
1283                                                  
1284          65                                283      return $event;
1285                                                  }
1286                                                  
1287                                                  sub fingerprint {
1288          30                   30           142      my ( $self, $err ) = @_;
1289                                                  
1290          30                                412      $err =~ s/([\(\)\[\].+?*\{\}])/\\$1/g;
1291                                                  
1292          30                                395      $err =~ s/\b\d+\b/\\d+/g;              # numbers
1293          30                                 94      $err =~ s/\b0x[0-9a-zA-Z]+\b/0x\\S+/g; # hex values
1294                                                  
1295          30                                129      return $err;
1296                                                  }
1297                                                  
1298                                                  sub _d {
1299  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1300  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1301  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1302                                                          @_;
1303  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1304                                                  }
1305                                                  
1306                                                  1;
1307                                                  
1308                                                  # ###########################################################################
1309                                                  # End ErrorLogPatternMatcher package
1310                                                  # ###########################################################################
1311                                                  
1312                                                  # ###########################################################################
1313                                                  # This is a combination of modules and programs in one -- a runnable module.
1314                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1315                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1316                                                  #
1317                                                  # Check at the end of this package for the call to main() which actually runs
1318                                                  # the program.
1319                                                  # ###########################################################################
1320                                                  package mk_error_log;
1321                                                  
1322           1                    1             7   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
1323           1                    1             6   use Data::Dumper;
               1                                  3   
               1                                  5   
1324                                                  $Data::Dumper::Indent    = 1;
1325                                                  $Data::Dumper::Sortkeys  = 1;
1326                                                  $Data::Dumper::Quotekeys = 0;
1327                                                  
1328  ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                253   
1329                                                  
1330                                                  sub main {
1331           9                    9          1876      @ARGV = @_;  # set global ARGV for this package
1332                                                  
1333                                                     # ########################################################################
1334                                                     # Get configuration information.
1335                                                     # ########################################################################
1336           9                                215      my $o  = new OptionParser(
1337                                                        strict      => 0,
1338                                                        prompt      => '[OPTION...] FILE [FILE...]',
1339                                                        description => q{parses and aggregates MySQL error log statements.},
1340                                                     );
1341           9                                 86      $o->get_specs();
1342           9                                 83      $o->get_opts();
1343                                                  
1344           9                                 78      $o->usage_or_errors();
1345                                                  
1346                                                  
1347                                                     # ##########################################################################
1348                                                     # Get ready to do the main work.
1349                                                     # ##########################################################################
1350           9                                100      my $parser  = new ErrorLogParser();
1351           9                                111      my $matcher = new ErrorLogPatternMatcher();
1352                                                  
1353                                                     # ##########################################################################
1354                                                     # Load saved patterns.
1355                                                     # ##########################################################################
1356  ***      9     50                          42      if ( my $file = $o->get('patterns') ) {
1357  ***      0      0                           0         open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
1358  ***      0                                  0         $matcher->load_patterns_file($fh);
1359                                                     }
1360  ***      9     50                          40      load_known_patterns($matcher) if $o->get('known-patterns');
1361                                                  
1362  ***      9     50                          43      if ( @ARGV == 0 ) {
1363  ***      0                                  0         push @ARGV, '-'; # Magical STDIN filename.
1364                                                     }
1365                                                  
1366                                                     # ##########################################################################
1367                                                     # Here's the main work.
1368                                                     # ##########################################################################
1369           9                                 22      my %cnt;
1370           9                                 25      my $file;
1371           9                                 45      while ( $file = shift @ARGV ) {
1372           9                                 24         my $fh;
1373  ***      9     50                          37         if ( $file eq '-' ) {
1374  ***      0                                  0            MKDEBUG && _d('Reading from STDIN');
1375  ***      0                                  0            $fh = *STDIN;
1376                                                        }
1377                                                        else {
1378  ***      9     50                         395            open $fh, '<', $file or warn "Cannot open $file: $OS_ERROR";
1379  ***      9     50                          39            next unless $fh;
1380                                                        }
1381                                                  
1382           9                                 25         my $event;
1383           9                                 54         while ( $event = $parser->parse_event(fh => $fh) ) {
1384          65                                464            $event = $matcher->match(
1385                                                              event       => $event,
1386                                                              new_pattern => \&new_pattern,
1387                                                           );
1388          65                                415            $cnt{ $event->{Pattern_no} }++;
1389                                                        }
1390                                                  
1391           9                                 32         close $fh;
1392                                                     }
1393                                                  
1394                                                     # ##########################################################################
1395                                                     # Do the report.
1396                                                     # ##########################################################################
1397           9                                170      my $reporter = new ReportFormatter(
1398                                                        line_prefix => '',
1399                                                     );
1400           9                                151      $reporter->set_columns(
1401                                                        { name => 'Count',   right_justify => 1,              },
1402                                                        { name => 'Level',                                    },
1403                                                        { name => 'Message', fixed_width => 60, truncate => 1 },
1404                                                     );
1405                                                  
1406                                                     # Save patterns while doing the report.
1407           9                                 23      my @patterns;
1408           9                                 27      my $fh;
1409  ***      9     50                          43      if ( my $file = $o->get('patterns') ) {
1410  ***      0      0                           0         open $fh, '>', $file or die "Cannot write to $file: $OS_ERROR";
1411  ***      0                                  0         @patterns = $matcher->patterns;
1412                                                     }
1413                                                  
1414           9                                 48      my @names  = $matcher->names;
1415           9                                 70      my @levels = $matcher->levels;
1416                                                  
1417           9                                 26      foreach my $pno ( sort { $cnt{$b} <=> $cnt{$a} } keys %cnt ) {
              97                                306   
1418  ***     50            50                  460         $reporter->add_line($cnt{$pno}, $levels[$pno] || '', $names[$pno] || '');
      ***                   50                        
1419  ***     50     50                         203         if ( $fh ) {
1420  ***      0                                  0            print $fh "$names[$pno]\n$levels[$pno]\n$patterns[$pno]\n\n";
1421                                                        }
1422                                                     }
1423                                                  
1424           9                                 51      print $reporter->get_report();
1425                                                  
1426  ***      9     50                          41      close $fh if $fh;
1427                                                  
1428           9                                845      return 0;
1429                                                  }
1430                                                  
1431                                                  # ##########################################################################
1432                                                  # Subroutines
1433                                                  # ##########################################################################
1434                                                  
1435                                                  # ##########################################################################
1436                                                  # This is a good place to add your own rules to match log events you're
1437                                                  # familiar with.  Each pattern/rule is a name, level and regular expression.
1438                                                  # The name will be printed out in the output, so make it representative of
1439                                                  # the log event.
1440                                                  # ##########################################################################
1441                                                  sub load_known_patterns {
1442           9                    9            36      my ( $matcher ) = @_;
1443           9                                314      my @known_patterns = (
1444                                                        [ 'mysqld started',
1445                                                          'info',
1446                                                          'mysqld started'
1447                                                        ],
1448                                                        [ 'mysqld ended',
1449                                                           'info',
1450                                                           'mysqld ended'
1451                                                        ],
1452                                                        [ 'mysqld version info',
1453                                                           'info',
1454                                                           '^Version: \S+ '
1455                                                        ],
1456                                                        [ 'mysqladmin debug memory status',
1457                                                           'info',
1458                                                           '^Memory status:'
1459                                                        ],
1460                                                        [ 'mysqladmin debug',
1461                                                           'info',
1462                                                           '^Status information:'
1463                                                        ],
1464                                                        [ 'InnoDB: Started',
1465                                                           'info',
1466                                                           '^InnoDB: Started; log sequence number'
1467                                                        ],
1468                                                        [ 'InnoDB: Starting an apply batch',
1469                                                           'info',
1470                                                           '^InnoDB: Starting an apply batch of log'
1471                                                        ],
1472                                                        [ 'InnoDB: Starting log scan',
1473                                                           'info',
1474                                                           '^InnoDB: Starting log scan based on'
1475                                                        ],
1476                                                        [ 'InnoDB: Database was not shut down properly!',
1477                                                           'error',
1478                                                           '^InnoDB: Database was not shut down'
1479                                                        ],
1480                                                        [ 'InnoDB: Starting shutdown',
1481                                                           'info',
1482                                                           '^InnoDB: Starting shutdown...'
1483                                                        ],
1484                                                        [ 'InnoDB: Shutdown completed',
1485                                                           'info',
1486                                                           '^InnoDB: Shutdown completed;'
1487                                                        ],
1488                                                        [ 'InnoDB: Rolling back trx',
1489                                                           'info',
1490                                                           '^InnoDB: Rolling back trx with id',
1491                                                        ],
1492                                                        [  'mysqld got signal',
1493                                                           'error',
1494                                                           'mysqld got signal \d',
1495                                                        ],
1496                                                        [  'InnoDB: Assertion failure',
1497                                                           'error',
1498                                                           'InnoDB: Assertion failure in thread',
1499                                                        ],
1500                                                        [  'InnoDB: Log file did not exist!',
1501                                                           'info',
1502                                                           'InnoDB: Log file .*? did not exist',
1503                                                        ],
1504                                                        [  'InnoDB: Setting file size',
1505                                                           'info',
1506                                                           'InnoDB: Setting file \S+ size',
1507                                                        ],
1508                                                        [  'InnoDB: The first specified data file did not exist!',
1509                                                           'info',
1510                                                           'InnoDB: The first specified data file \S+',
1511                                                        ],
1512                                                        [  'InnoDB: Warning: cannot find a free slot',
1513                                                           'warning',
1514                                                           'InnoDB: Warning: cannot find a free slot',
1515                                                        ],
1516                                                        [  'InnoDB: Rolling back of trx complete',
1517                                                           'info',
1518                                                           'InnoDB: Rolling back of trx id .*?complete',
1519                                                        ],
1520                                                        [  'mysqld restarted',
1521                                                           'info',
1522                                                           'mysqld restarted',
1523                                                        ],
1524                                                     );
1525           9                                 72      $matcher->add_patterns(\@known_patterns);
1526           9                                 86      return;
1527                                                  }
1528                                                  
1529                                                  sub _d {
1530  ***      0                    0                    my ($package, undef, $line) = caller 0;
1531  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1532  ***      0                                              map { defined $_ ? $_ : 'undef' }
1533                                                          @_;
1534  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1535                                                  }
1536                                                  
1537                                                  # ############################################################################
1538                                                  # Run the program.
1539                                                  # ############################################################################
1540                                                  if ( !caller ) { exit main(@ARGV); }
1541                                                  
1542                                                  1; # Because this is a module as well as a script.
1543                                                  
1544                                                  # ############################################################################
1545                                                  # Documentation
1546                                                  # ############################################################################
1547                                                  
1548                                                  =pod
1549                                                  
1550                                                  =head1 NAME
1551                                                  
1552                                                  mk-error-log - Find new and different MySQL error log entries.
1553                                                  
1554                                                  =head1 SYNOPSIS
1555                                                  
1556                                                     mk-error-log
1557                                                  
1558                                                  =head1 RISKS
1559                                                  
1560                                                  The following section is included to inform users about the potential risks,
1561                                                  whether known or unknown, of using this tool.  The two main categories of risks
1562                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
1563                                                  tools) and those created by bugs.
1564                                                  
1565                                                  mk-error-log merely reads files given on the command line, and should be very
1566                                                  low-risk.
1567                                                  
1568                                                  At the time of this release, we know of no bugs that could cause serious harm to
1569                                                  users.
1570                                                  
1571                                                  The authoritative source for updated information is always the online issue
1572                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
1573                                                  see a list of such issues at the following URL:
1574                                                  L<http://www.maatkit.org/bugs/mk-error-log>.
1575                                                  
1576                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
1577                                                  
1578                                                  =head1 DESCRIPTION
1579                                                  
1580                                                  mk-error-log finds new and different MySQL error log entries.
1581                                                  
1582                                                  =head1 OPTIONS
1583                                                  
1584                                                  =over
1585                                                  
1586                                                  =item --ask-pass
1587                                                  
1588                                                  Prompt for a password when connecting to MySQL.
1589                                                  
1590                                                  =item --charset
1591                                                  
1592                                                  short form: -A; type: string
1593                                                  
1594                                                  Default character set.  If the value is utf8, sets Perl's binmode on
1595                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
1596                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
1597                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
1598                                                  connecting to MySQL.
1599                                                  
1600                                                  =item --config
1601                                                  
1602                                                  type: Array
1603                                                  
1604                                                  Read this comma-separated list of config files; if specified, this must be the
1605                                                  first option on the command line.
1606                                                  
1607                                                  =item --defaults-file
1608                                                  
1609                                                  short form: -F; type: string
1610                                                  
1611                                                  Only read mysql options from the given file.  You must give an absolute
1612                                                  pathname.
1613                                                  
1614                                                  =item --help
1615                                                  
1616                                                  Show help and exit.
1617                                                  
1618                                                  =item --host
1619                                                  
1620                                                  short form: -h; type: string
1621                                                  
1622                                                  Connect to host.
1623                                                  
1624                                                  =item --[no]known-patterns
1625                                                  
1626                                                  default: yes
1627                                                  
1628                                                  Load known patterns.
1629                                                  
1630                                                  =item --password
1631                                                  
1632                                                  short form: -p; type: string
1633                                                  
1634                                                  Password to use when connecting.
1635                                                  
1636                                                  =item --patterns
1637                                                  
1638                                                  type: string
1639                                                  
1640                                                  Read old patterns and write new patterns to this file.
1641                                                  
1642                                                  =item --pid
1643                                                  
1644                                                  type: string
1645                                                  
1646                                                  Create the given PID file when daemonized.  The file contains the process
1647                                                  ID of the daemonized instance.  The PID file is removed when the
1648                                                  daemonized instance exits.  The program checks for the existence of the
1649                                                  PID file when starting; if it exists and the process with the matching PID
1650                                                  exists, the program exits.
1651                                                  
1652                                                  =item --port
1653                                                  
1654                                                  short form: -P; type: int
1655                                                  
1656                                                  Port number to use for connection.
1657                                                  
1658                                                  =item --set-vars
1659                                                  
1660                                                  type: string; default: wait_timeout=10000
1661                                                  
1662                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
1663                                                  will be appended to SET and executed.
1664                                                  
1665                                                  =item --socket
1666                                                  
1667                                                  short form: -S; type: string
1668                                                  
1669                                                  Socket file to use for connection.
1670                                                  
1671                                                  =item --user
1672                                                  
1673                                                  short form: -u; type: string
1674                                                  
1675                                                  User for login if not current user.
1676                                                  
1677                                                  =item --version
1678                                                  
1679                                                  Show version and exit.
1680                                                  
1681                                                  =back
1682                                                  
1683                                                  =head1 DOWNLOADING
1684                                                  
1685                                                  You can download Maatkit from Google Code at
1686                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
1687                                                  easily with a command like the following:
1688                                                  
1689                                                     wget http://www.maatkit.org/get/toolname
1690                                                     or
1691                                                     wget http://www.maatkit.org/trunk/toolname
1692                                                  
1693                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
1694                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
1695                                                  needed.  The first URL gets the latest released version of the tool, and the
1696                                                  second gets the latest trunk code from Subversion.
1697                                                  
1698                                                  =head1 ENVIRONMENT
1699                                                  
1700                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
1701                                                  the Maatkit tools:
1702                                                  
1703                                                     MKDEBUG=1 mk-....
1704                                                  
1705                                                  =head1 SYSTEM REQUIREMENTS
1706                                                  
1707                                                  You need the following Perl modules: DBI and DBD::mysql.
1708                                                  
1709                                                  =head1 BUGS
1710                                                  
1711                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-error-log>.
1712                                                  
1713                                                  Please use Google Code Issues and Groups to report bugs or request support:
1714                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
1715                                                  discuss Maatkit.
1716                                                  
1717                                                  Please include the complete command-line used to reproduce the problem you are
1718                                                  seeing, the version of all MySQL servers involved, the complete output of the
1719                                                  tool when run with L<"--version">, and if possible, debugging output produced by
1720                                                  running with the C<MKDEBUG=1> environment variable.
1721                                                  
1722                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
1723                                                  
1724                                                  This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
1725                                                  Feedback and improvements are welcome.
1726                                                  
1727                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
1728                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
1729                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
1730                                                  
1731                                                  This program is free software; you can redistribute it and/or modify it under
1732                                                  the terms of the GNU General Public License as published by the Free Software
1733                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
1734                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
1735                                                  licenses.
1736                                                  
1737                                                  You should have received a copy of the GNU General Public License along with
1738                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
1739                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
1740                                                  
1741                                                  =head1 AUTHOR
1742                                                  
1743                                                  Daniel Nichter
1744                                                  
1745                                                  =head1 ABOUT MAATKIT
1746                                                  
1747                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
1748                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
1749                                                  code contributors.  Both are employed by Percona.  Financial support for
1750                                                  Maatkit development is primarily provided by Percona and its clients. 
1751                                                  
1752                                                  =head1 VERSION
1753                                                  
1754                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
1755                                                  
1756                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
55    ***     50      0      9   unless $args{$arg}
61    ***     50      9      0   exists $args{'strict'} ? :
104   ***     50      0      9   unless open my $fh, '<', $file
124          100   1935      9   unless $para =~ /^=head1 OPTIONS/
129   ***     50      9      0   if $para =~ /^=over/
137   ***     50      0      9   unless $para
140          100    135      9   if (my($option) = $para =~ /^=item --(.*)/)
147          100    108     27   if ($para =~ /: /) { }
151   ***     50      0    180   unless $attributes{$attrib}
155          100     63     45   if ($attribs{'short form'})
171   ***     50      0    135   if $para =~ /^=item/
173          100      9    126   if (my($base_option) = $option =~ /^\[no\](.*)/)
178          100     63     72   $attribs{'short form'} ? :
             100      9    126   $attribs{'negatable'} ? :
      ***     50      0    135   $attribs{'cumulative'} ? :
             100     99     36   $attribs{'type'} ? :
             100     18    117   $attribs{'default'} ? :
      ***     50      0    135   $attribs{'group'} ? :
190   ***     50      0    153   unless $para
193          100      9    144   if ($para =~ /^=head1/)
197          100    135      9   if $para =~ /^=item --/
201   ***     50      0      9   unless @specs
212   ***     50    135      0   if (ref $opt) { }
217   ***     50      0    135   if (not $long)
222   ***     50      0    135   if exists $$self{'opts'}{$long}
225   ***     50      0    135   if (length $long == 1)
230          100     63     72   if ($short) { }
231   ***     50      0     63   if exists $$self{'short_opts'}{$short}
240          100      9    126   $$opt{'spec'} =~ /!/ ? :
241   ***     50      0    135   $$opt{'spec'} =~ /\+/ ? :
242   ***     50      0    135   $$opt{'desc'} =~ /required/ ? :
254   ***     50      0    135   if ($type and $type eq 'd' and not $$self{'dp'})
259          100      9    126   if $type and $type =~ /[HhAadzm]/
261          100     18    117   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
262   ***     50     18      0   defined $def ? :
266          100      9    126   if ($long eq 'config')
270   ***     50      0    135   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
283   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
288   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
293   ***      0      0      0   if ($opt =~ /default to/)
298   ***      0      0      0   if ($opt =~ /restricted to option groups/)
308   ***      0      0      0   unless $rule_ok
325   ***      0      0      0   unless exists $$self{'opts'}{$long}
349   ***      0      0      0   unless exists $$self{'opts'}{$long}
369   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
374   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
389   ***     50      0    108   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     27    108   exists $$self{'defaults'}{$long} ? :
398   ***     50      0      9   if (@ARGV and $ARGV[0] eq '--config')
402   ***     50      9      0   if ($self->has('config'))
408   ***     50     36      0   if ($EVAL_ERROR)
409   ***     50      0     36   $self->got('config') ? :
424   ***     50      0      9   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
427   ***     50      0      9   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
428   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
434   ***     50      0      9   if (@ARGV and $$self{'strict'})
440   ***      0      0      0   if (@set > 1)
451   ***      0      0      0   if (@set == 0)
461   ***     50      0    135   if ($$opt{'got'}) { }
      ***     50      0    135   elsif ($$opt{'is_required'}) { }
462   ***      0      0      0   if (exists $$self{'disables'}{$long})
469   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
481   ***      0      0      0   if $restricted_opt eq $long
482   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
487   ***      0      0      0   if (@restricted_opts)
489   ***      0      0      0   if (@restricted_opts == 1) { }
518          100     36     99   unless $opt and $$opt{'type'}
521   ***     50      0     99   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0     99   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     99   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0     99   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      9     90   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
524   ***      0      0      0   if (not $suffix)
530   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
531   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
546   ***      0      0      0   if ($from_key)
557   ***      0      0      0   if (defined $num) { }
558   ***      0      0      0   if ($factor)
585   ***     50      0     36   length $opt == 1 ? :
586   ***     50      0     36   unless $long and exists $$self{'opts'}{$long}
593   ***     50      0     36   length $opt == 1 ? :
594   ***     50      0     36   unless $long and exists $$self{'opts'}{$long}
601   ***     50      0      9   length $opt == 1 ? :
602   ***     50      9      0   defined $long ? :
607   ***      0      0      0   length $opt == 1 ? :
608   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
635   ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
643   ***     50      0      9   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      9   elsif (scalar @{$$self{'errors'};}) { }
644   ***      0      0      0   unless print $self->print_usage
648   ***      0      0      0   unless print $self->print_errors
657   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
666   ***      0      0      0   unless $$self{'got_opts'}
669   ***      0      0      0   $$_{'is_negatable'} ? :
673   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
689   ***      0      0      0   $group eq 'default' ? :
695   ***      0      0      0   $$opt{'is_negatable'} ? :
698   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
707   ***      0      0      0   if ($short) { }
716   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
720   ***      0      0      0   if ($$self{'dp'})
728   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
740   ***      0      0      0   if ref $_[0] eq 'OptionParser'
743   ***      0      0      0   unless print $prompt
751   ***      0      0      0   unless print "\n"
754   ***      0      0      0   if ($EVAL_ERROR)
776   ***     50     36      0   unless open my $fh, '<', $filename
784   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
787   ***      0      0      0   if ($line eq '--')
792   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
810   ***      0      0      0   unless open my $fh, '<', $file
814   ***      0      0      0   unless $para =~ /^=pod$/m
818   ***      0      0      0   unless $para =~ /$regex/
823   ***      0      0      0   unless close $fh
837   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
852   ***      0      0      0   defined $_ ? :
885   ***      0      0      0   unless $args{$arg}
907   ***     50      0     27   unless defined $$col{'name'}
908   ***     50      0     27   if ($$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'})
923   ***     50      0     50   unless $n_cols == $n_vals
931   ***     50      0    150   if ($$col{'fixed_width'} and $width > $$col{'fixed_width'})
932   ***      0      0      0   if ($$col{'truncate'}) { }
954   ***     50      0      9   $$self{'long_last_column'} ? :
961          100      9     18   $$col{'right_justify'} ? :
967   ***     50      0      9   if ($$self{'long_last_column'})
973   ***     50      0      9   if $$self{'title'}
978   ***     50      9      0   if ($$self{'underline_header'})
986   ***     50      0      9   if ($$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'})
1004  ***      0      0      0   defined $_ ? :
1053  ***     50      0     74   unless $args{$arg}
1063         100      9     65   if $line =~ /^\s*$/
1068         100     56      9   if (my($ts) = $line =~ /^$ts/o)
1075         100     29     36   if (($level) = $line =~ /\[((?:ERROR|Warning|Note))\]/) { }
1076         100     10     11   $level =~ /warning/i ? :
             100      8     21   $level =~ /error/i ? :
1086         100      1     64   if (my($level) = $line =~ /InnoDB: Error/)
1096         100     20     45   if ($line =~ /$ml/o) { }
             100      1     44   elsif ($line =~ /\bQuery: '/) { }
1103         100    333   2980   if $next_line eq ''
1118         100      1      2   if $next_line =~ /, Error_code:/
1132  ***     50      0      9   if $args{'oktorun'}
1138  ***      0      0      0   defined $_ ? :
1180  ***     50      0    210   unless $p and scalar @$p
1199  ***      0      0      0   if (not $name && $level && $regex)
1203  ***      0      0      0   if ($seen{$name}++)
1241  ***     50      0     65   unless $args{$arg}
1245  ***     50      0     65   unless $err
1247  ***     50      0     65   if ($$self{'QueryRewriter'} and my($query) = $err =~ /Statement: (.+)$/)
1258         100     35   1060   if ($err =~ /$$compiled[$i]/)
1264         100     35     30   if (defined $pno) { }
1269  ***     50      0     35   if (not $$event{'Level'} and $$self{'levels'}[$pno])
1300  ***      0      0      0   defined $_ ? :
1356  ***     50      0      9   if (my $file = $o->get('patterns'))
1357  ***      0      0      0   unless open my $fh, '<', $file
1360  ***     50      9      0   if $o->get('known-patterns')
1362  ***     50      0      9   if (@ARGV == 0)
1373  ***     50      0      9   if ($file eq '-') { }
1378  ***     50      0      9   unless open $fh, '<', $file
1379  ***     50      0      9   unless $fh
1409  ***     50      0      9   if (my $file = $o->get('patterns'))
1410  ***      0      0      0   unless open $fh, '>', $file
1419  ***     50      0     50   if ($fh)
1426  ***     50      0      9   if $fh
1531  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
1180  ***     50      0    210   $p and scalar @$p

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
254   ***     66     36     99      0   $type and $type eq 'd'
      ***     33    135      0      0   $type and $type eq 'd' and not $$self{'dp'}
259          100     36     90      9   $type and $type =~ /[HhAadzm]/
398   ***     33      0      9      0   @ARGV and $ARGV[0] eq '--config'
427   ***     33      0      9      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
434   ***     33      0      9      0   @ARGV and $$self{'strict'}
518   ***     66      0     36     99   $opt and $$opt{'type'}
521   ***     66     81     18      0   $val and $$opt{'type'} eq 'm'
      ***     66     81     18      0   $val and $$opt{'type'} eq 'd'
      ***     66     81     18      0   $val and $$opt{'type'} eq 'z'
      ***     66     81     18      0   defined $val and $$opt{'type'} eq 'h'
      ***     66     81      9      0   defined $val and $$opt{'type'} eq 'a'
586   ***     33      0      0     36   $long and exists $$self{'opts'}{$long}
594   ***     33      0      0     36   $long and exists $$self{'opts'}{$long}
608   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
698   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
792   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
908   ***     33     27      0      0   $$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'}
931   ***     66    100     50      0   $$col{'fixed_width'} and $width > $$col{'fixed_width'}
986   ***     33      0      9      0   $$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'}
1100         100      2     18   3313   defined($next_line = <$fh>) and not $next_line =~ /^$ts/o
1114  ***     66      1      0      3   not $last_line and defined($next_line = <$fh>)
1199  ***      0      0      0      0   $name && $level
      ***      0      0      0      0   $name && $level && $regex
1247  ***     33     65      0      0   $$self{'QueryRewriter'} and my($query) = $err =~ /Statement: (.+)$/
1269  ***     33     35      0      0   not $$event{'Level'} and $$self{'levels'}[$pno]

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
39    ***     50      0      1   $ENV{'MKDEBUG'} || 0
58    ***     50      9      0   $program_name ||= $PROGRAM_NAME
59    ***     50      9      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
61    ***     50      9      0   $args{'prompt'} || '<options>'
      ***     50      0      9   $args{'dp'} || undef
103   ***     50      0      9   $file ||= '/home/daniel/dev/maatkit/mk-error-log/mk-error-log'
244   ***     50    135      0   $$opt{'group'} ||= 'default'
526   ***      0      0      0   $s || 's'
535   ***      0      0      0   $prefix || ''
563   ***      0      0      0   $pre || ''
570   ***      0      0      0   $val || ''
573   ***     50      9      0   $val || ''
631   ***      0      0      0   $$self{'description'} || ''
700   ***      0      0      0   $s ||= 's'
726   ***      0      0      0   $$opt{'type'} || ''
874   ***     50      0      1   $ENV{'MKDEBUG'} || 0
952   ***     50      0      9   $$self{'line_prefix'} || ''
1030  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1163  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1328  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1418  ***     50     50      0   $levels[$pno] || ''
      ***     50     50      0   $names[$pno] || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
59    ***     33      9      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33      9      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
521   ***     33      0      0     99   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      9      0     90   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1062         100     18     56      9   defined($line = shift @$pending) or defined($line = <$fh>)


Covered Subroutines
-------------------

Subroutine          Count Location                                               
------------------- ----- -------------------------------------------------------
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1021
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1022
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1023
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1025
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1030
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1155
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1156
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1157
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1158
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1163
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1322
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1323
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1328
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:20  
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:21  
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:32  
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:33  
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:35  
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:36  
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:37  
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:39  
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:869 
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:870 
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:871 
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:872 
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:874 
BEGIN                   1 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:876 
_parse_specs            9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:208 
_pod_to_specs           9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:102 
_read_config_file      36 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:775 
_validate_type        135 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:517 
add_line               50 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:919 
add_patterns           39 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1178
fingerprint            30 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1288
get                    36 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:584 
get_defaults_files      9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:97  
get_opts                9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:385 
get_report              9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:950 
get_specs               9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:90  
got                    36 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:592 
has                     9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:600 
levels                  9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1233
load_known_patterns     9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1442
main                    9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1331
match                  65 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1238
names                   9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1228
new                     9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1041
new                     9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1166
new                     9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:53  
new                     9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:882 
parse_event            74 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1050
set_columns             9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:904 
usage_or_errors         9 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:642 

Uncovered Subroutines
---------------------

Subroutine          Count Location                                               
------------------- ----- -------------------------------------------------------
__ANON__                0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:422 
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1003
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1137
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1299
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1530
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:851 
_get_participants       0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:322 
_set_option             0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:368 
clone                   0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:828 
descr                   0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:630 
errors                  0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:620 
get_defaults            0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:358 
get_groups              0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:363 
load_patterns_file      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1193
opts                    0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:334 
patterns                0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1223
print_errors            0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:655 
print_usage             0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:665 
prompt                  0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:625 
prompt_noecho           0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:740 
read_para_after         0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:809 
reset_patterns          0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1213
save_error              0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:615 
set                     0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:606 
set_defaults            0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:346 
set_title               0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:898 
short_opts              0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:340 


