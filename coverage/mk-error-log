---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...mk-error-log/mk-error-log   56.7   39.3   36.1   68.0    n/a  100.0   50.8
Total                          56.7   39.3   36.1   68.0    n/a  100.0   50.8
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 20:32:40 2010
Finish:       Thu Jan 28 20:32:40 2010

Run:          ./101_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 20:32:42 2010
Finish:       Thu Jan 28 20:32:42 2010

Run:          ./102_since_until.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 20:32:45 2010
Finish:       Thu Jan 28 20:32:45 2010

/home/daniel/dev/maatkit/mk-error-log/mk-error-log

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             2                    2            17   use strict;
               2                                  8   
               2                                 13   
21             2                    2            16   use warnings FATAL => 'all';
               2                                  5   
               2                                 13   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5577 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # OptionParser package 5568
29                                                    # ###########################################################################
30                                                    package OptionParser;
31                                                    
32             2                    2            12   use strict;
               2                                  6   
               2                                  8   
33             2                    2            13   use warnings FATAL => 'all';
               2                                  5   
               2                                 16   
34                                                    
35             2                    2            22   use Getopt::Long;
               2                                  6   
               2                                 13   
36             2                    2            13   use List::Util qw(max);
               2                                  5   
               2                                 21   
37             2                    2            12   use English qw(-no_match_vars);
               2                                  4   
               2                                 14   
38                                                    
39    ***      2            50      2            18   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  4   
               2                                 43   
40                                                    
41                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
42                                                    
43                                                    my %attributes = (
44                                                       'type'       => 1,
45                                                       'short form' => 1,
46                                                       'group'      => 1,
47                                                       'default'    => 1,
48                                                       'cumulative' => 1,
49                                                       'negatable'  => 1,
50                                                    );
51                                                    
52                                                    sub new {
53            14                   14           311      my ( $class, %args ) = @_;
54            14                                133      foreach my $arg ( qw(description) ) {
55    ***     14     50                         183         die "I need a $arg argument" unless $args{$arg};
56                                                       }
57            14                                256      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
58    ***     14            50                  134      $program_name ||= $PROGRAM_NAME;
59    ***     14            33                  249      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
60                                                    
61    ***     14     50     50                 1154      my $self = {
      ***                   50                        
62                                                          description    => $args{description},
63                                                          prompt         => $args{prompt} || '<options>',
64                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
65                                                          dp             => $args{dp}     || undef,
66                                                          program_name   => $program_name,
67                                                          opts           => {},
68                                                          got_opts       => 0,
69                                                          short_opts     => {},
70                                                          defaults       => {},
71                                                          groups         => {},
72                                                          allowed_groups => {},
73                                                          errors         => [],
74                                                          rules          => [],  # desc of rules for --help
75                                                          mutex          => [],  # rule: opts are mutually exclusive
76                                                          atleast1       => [],  # rule: at least one opt is required
77                                                          disables       => {},  # rule: opt disables other opts 
78                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
79                                                          default_files  => [
80                                                             "/etc/maatkit/maatkit.conf",
81                                                             "/etc/maatkit/$program_name.conf",
82                                                             "$home/.maatkit.conf",
83                                                             "$home/.$program_name.conf",
84                                                          ],
85                                                       };
86            14                                160      return bless $self, $class;
87                                                    }
88                                                    
89                                                    sub get_specs {
90            14                   14            76      my ( $self, $file ) = @_;
91            14                                126      my @specs = $self->_pod_to_specs($file);
92            14                                265      $self->_parse_specs(@specs);
93            14                                 53      return;
94                                                    }
95                                                    
96                                                    sub get_defaults_files {
97            14                   14            53      my ( $self ) = @_;
98            14                                 36      return @{$self->{default_files}};
              14                                137   
99                                                    }
100                                                   
101                                                   sub _pod_to_specs {
102           14                   14            72      my ( $self, $file ) = @_;
103   ***     14            50                   88      $file ||= __FILE__;
104   ***     14     50                         457      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
105                                                   
106           14                                369      my %types = (
107                                                         string => 's', # standard Getopt type
108                                                         'int'  => 'i', # standard Getopt type
109                                                         float  => 'f', # standard Getopt type
110                                                         Hash   => 'H', # hash, formed from a comma-separated list
111                                                         hash   => 'h', # hash as above, but only if a value is given
112                                                         Array  => 'A', # array, similar to Hash
113                                                         array  => 'a', # array, similar to hash
114                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
115                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
116                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
117                                                      );
118           14                                 61      my @specs = ();
119           14                                 43      my @rules = ();
120           14                                 36      my $para;
121                                                   
122           14                                114      local $INPUT_RECORD_SEPARATOR = '';
123           14                                284      while ( $para = <$fh> ) {
124         3654    100                       23093         next unless $para =~ m/^=head1 OPTIONS/;
125           14                                 54         last;
126                                                      }
127                                                   
128           14                                 81      while ( $para = <$fh> ) {
129   ***     14     50                         104         last if $para =~ m/^=over/;
130   ***      0                                  0         chomp $para;
131   ***      0                                  0         $para =~ s/\s+/ /g;
132   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
133   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
134   ***      0                                  0         push @rules, $para;
135                                                      }
136                                                   
137   ***     14     50                          60      die 'POD has no OPTIONS section' unless $para;
138                                                   
139           14                                 43      do {
140          280    100                        1779         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
141          266                                693            chomp $para;
142          266                                558            MKDEBUG && _d($para);
143          266                                604            my %attribs;
144                                                   
145          266                               1003            $para = <$fh>; # read next paragraph, possibly attributes
146                                                   
147          266    100                         993            if ( $para =~ m/: / ) { # attributes
148          224                                991               $para =~ s/\s+\Z//g;
149          336                               1731               %attribs = map {
150          224                               1013                     my ( $attrib, $val) = split(/: /, $_);
151   ***    336     50                        1428                     die "Unrecognized attribute for --$option: $attrib"
152                                                                        unless $attributes{$attrib};
153          336                               1830                     ($attrib, $val);
154                                                                  } split(/; /, $para);
155          224    100                        1006               if ( $attribs{'short form'} ) {
156           98                                459                  $attribs{'short form'} =~ s/-//;
157                                                               }
158          224                                851               $para = <$fh>; # read next paragraph, probably short help desc
159                                                            }
160                                                            else {
161           42                                103               MKDEBUG && _d('Option has no attributes');
162                                                            }
163                                                   
164          266                               1715            $para =~ s/\s+\Z//g;
165          266                               1722            $para =~ s/\s+/ /g;
166          266                                925            $para =~ s/$POD_link_re/$1/go;
167                                                   
168          266                                983            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
169          266                                632            MKDEBUG && _d('Short help:', $para);
170                                                   
171   ***    266     50                        1039            die "No description after option spec $option" if $para =~ m/^=item/;
172                                                   
173          266    100                        1223            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
174           28                                148               $option = $base_option;
175           28                                133               $attribs{'negatable'} = 1;
176                                                            }
177                                                   
178          266    100                        4594            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
179                                                               spec  => $option
180                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
181                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
182                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
183                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
184                                                               desc  => $para
185                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
186                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
187                                                            };
188                                                         }
189          280                               1604         while ( $para = <$fh> ) {
190   ***    518     50                        1705            last unless $para;
191                                                   
192                                                   
193          518    100                        1891            if ( $para =~ m/^=head1/ ) {
194           14                                 48               $para = undef; # Can't 'last' out of a do {} block.
195           14                                 72               last;
196                                                            }
197          504    100                        3074            last if $para =~ m/^=item --/;
198                                                         }
199                                                      } while ( $para );
200                                                   
201   ***     14     50                          62      die 'No valid specs in POD OPTIONS' unless @specs;
202                                                   
203           14                                146      close $fh;
204           14                                 48      return @specs, @rules;
205                                                   }
206                                                   
207                                                   sub _parse_specs {
208           14                   14           108      my ( $self, @specs ) = @_;
209           14                                 45      my %disables; # special rule that requires deferred checking
210                                                   
211           14                                 77      foreach my $opt ( @specs ) {
212   ***    266     50                         981         if ( ref $opt ) { # It's an option spec, not a rule.
213                                                            MKDEBUG && _d('Parsing opt spec:',
214          266                                557               map { ($_, '=>', $opt->{$_}) } keys %$opt);
215                                                   
216          266                               2196            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
217   ***    266     50                        1071            if ( !$long ) {
218   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
219                                                            }
220          266                                926            $opt->{long} = $long;
221                                                   
222   ***    266     50                        1204            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
223          266                               1188            $self->{opts}->{$long} = $opt;
224                                                   
225   ***    266     50                        1002            if ( length $long == 1 ) {
226   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
227   ***      0                                  0               $self->{short_opts}->{$long} = $long;
228                                                            }
229                                                   
230          266    100                         835            if ( $short ) {
231   ***     98     50                         427               die "Duplicate short option -$short"
232                                                                  if exists $self->{short_opts}->{$short};
233           98                                434               $self->{short_opts}->{$short} = $long;
234           98                                330               $opt->{short} = $short;
235                                                            }
236                                                            else {
237          168                                574               $opt->{short} = undef;
238                                                            }
239                                                   
240          266    100                        1340            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
241   ***    266     50                        1391            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
242   ***    266     50                        1453            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
243                                                   
244   ***    266            50                 1008            $opt->{group} ||= 'default';
245          266                               1283            $self->{groups}->{ $opt->{group} }->{$long} = 1;
246                                                   
247          266                                855            $opt->{value} = undef;
248          266                                868            $opt->{got}   = 0;
249                                                   
250          266                               1382            my ( $type ) = $opt->{spec} =~ m/=(.)/;
251          266                                942            $opt->{type} = $type;
252          266                                571            MKDEBUG && _d($long, 'type:', $type);
253                                                   
254   ***    266     50     66                 2241            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
255   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
256                                                                  . "was given when this OptionParser object was created";
257                                                            }
258                                                   
259          266    100    100                 1872            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
260                                                   
261          266    100                        1564            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
262   ***     42     50                         227               $self->{defaults}->{$long} = defined $def ? $def : 1;
263           42                                 95               MKDEBUG && _d($long, 'default:', $def);
264                                                            }
265                                                   
266          266    100                         989            if ( $long eq 'config' ) {
267           14                                 76               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
268                                                            }
269                                                   
270   ***    266     50                        1277            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
271   ***      0                                  0               $disables{$long} = $dis;
272   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
273                                                            }
274                                                   
275          266                               1217            $self->{opts}->{$long} = $opt;
276                                                         }
277                                                         else { # It's an option rule, not a spec.
278   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
279   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
280   ***      0                                  0            my @participants = $self->_get_participants($opt);
281   ***      0                                  0            my $rule_ok = 0;
282                                                   
283   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
284   ***      0                                  0               $rule_ok = 1;
285   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
286   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
287                                                            }
288   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
289   ***      0                                  0               $rule_ok = 1;
290   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
291   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
292                                                            }
293   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
294   ***      0                                  0               $rule_ok = 1;
295   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
296   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
297                                                            }
298   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
299   ***      0                                  0               $rule_ok = 1;
300   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
301   ***      0                                  0               my @groups = split(',', $groups);
302   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
303   ***      0                                  0                  s/\s+//;
304   ***      0                                  0                  $_ => 1;
305                                                               } @groups;
306                                                            }
307                                                   
308   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
309                                                         }
310                                                      }
311                                                   
312           14                                 76      foreach my $long ( keys %disables ) {
313   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
314   ***      0                                  0         $self->{disables}->{$long} = \@participants;
315   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
316                                                      }
317                                                   
318           14                                 64      return; 
319                                                   }
320                                                   
321                                                   sub _get_participants {
322   ***      0                    0             0      my ( $self, $str ) = @_;
323   ***      0                                  0      my @participants;
324   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
325   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
326                                                            unless exists $self->{opts}->{$long};
327   ***      0                                  0         push @participants, $long;
328                                                      }
329   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
330   ***      0                                  0      return @participants;
331                                                   }
332                                                   
333                                                   sub opts {
334   ***      0                    0             0      my ( $self ) = @_;
335   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
336   ***      0                                  0      return %opts;
337                                                   }
338                                                   
339                                                   sub short_opts {
340   ***      0                    0             0      my ( $self ) = @_;
341   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
342   ***      0                                  0      return %short_opts;
343                                                   }
344                                                   
345                                                   sub set_defaults {
346   ***      0                    0             0      my ( $self, %defaults ) = @_;
347   ***      0                                  0      $self->{defaults} = {};
348   ***      0                                  0      foreach my $long ( keys %defaults ) {
349   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
350                                                            unless exists $self->{opts}->{$long};
351   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
352   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
353                                                      }
354   ***      0                                  0      return;
355                                                   }
356                                                   
357                                                   sub get_defaults {
358   ***      0                    0             0      my ( $self ) = @_;
359   ***      0                                  0      return $self->{defaults};
360                                                   }
361                                                   
362                                                   sub get_groups {
363   ***      0                    0             0      my ( $self ) = @_;
364   ***      0                                  0      return $self->{groups};
365                                                   }
366                                                   
367                                                   sub _set_option {
368            5                    5            27      my ( $self, $opt, $val ) = @_;
369   ***      5      0                          12      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
370                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
371                                                               : die "Getopt::Long gave a nonexistent option: $opt";
372                                                   
373            5                                 10      $opt = $self->{opts}->{$long};
374   ***      5     50                          34      if ( $opt->{is_cumulative} ) {
375   ***      0                                  0         $opt->{value}++;
376                                                      }
377                                                      else {
378            5                                 21         $opt->{value} = $val;
379                                                      }
380            5                                 18      $opt->{got} = 1;
381            5                                 18      MKDEBUG && _d('Got option', $long, '=', $val);
382                                                   }
383                                                   
384                                                   sub get_opts {
385           14                   14            65      my ( $self ) = @_; 
386                                                   
387           14                                 47      foreach my $long ( keys %{$self->{opts}} ) {
              14                                139   
388          266                               1009         $self->{opts}->{$long}->{got} = 0;
389   ***    266     50                        2021         $self->{opts}->{$long}->{value}
                    100                               
390                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
391                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
392                                                            : undef;
393                                                      }
394           14                                 65      $self->{got_opts} = 0;
395                                                   
396           14                                 58      $self->{errors} = [];
397                                                   
398   ***     14     50     33                  191      if ( @ARGV && $ARGV[0] eq "--config" ) {
399   ***      0                                  0         shift @ARGV;
400   ***      0                                  0         $self->_set_option('config', shift @ARGV);
401                                                      }
402   ***     14     50                         123      if ( $self->has('config') ) {
403           14                                 40         my @extra_args;
404           14                                126         foreach my $filename ( split(',', $self->get('config')) ) {
405           56                                146            eval {
406           56                                345               push @extra_args, $self->_read_config_file($filename);
407                                                            };
408   ***     56     50                         271            if ( $EVAL_ERROR ) {
409   ***     56     50                         245               if ( $self->got('config') ) {
410   ***      0                                  0                  die $EVAL_ERROR;
411                                                               }
412                                                               elsif ( MKDEBUG ) {
413                                                                  _d($EVAL_ERROR);
414                                                               }
415                                                            }
416                                                         }
417           14                                 68         unshift @ARGV, @extra_args;
418                                                      }
419                                                   
420           14                                165      Getopt::Long::Configure('no_ignore_case', 'bundling');
421                                                      GetOptions(
422          252                    5          1821         map    { $_->{spec} => sub { $self->_set_option(@_); } }
               5                                 39   
             266                                979   
423           14                                 87         grep   { $_->{long} ne 'config' } # --config is handled specially above.
424   ***     14     50                          46         values %{$self->{opts}}
425                                                      ) or $self->save_error('Error parsing options');
426                                                   
427   ***     14     50     33                  508      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
428   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
429                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
430                                                               or die "Cannot print: $OS_ERROR";
431   ***      0                                  0         exit 0;
432                                                      }
433                                                   
434   ***     14     50     33                  142      if ( @ARGV && $self->{strict} ) {
435   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
436                                                      }
437                                                   
438           14                                 40      foreach my $mutex ( @{$self->{mutex}} ) {
              14                                 89   
439   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
440   ***      0      0                           0         if ( @set > 1 ) {
441   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
442   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
443                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
444                                                                    . ' are mutually exclusive.';
445   ***      0                                  0            $self->save_error($err);
446                                                         }
447                                                      }
448                                                   
449           14                                 44      foreach my $required ( @{$self->{atleast1}} ) {
              14                                 65   
450   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
451   ***      0      0                           0         if ( @set == 0 ) {
452   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
453   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
454                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
455   ***      0                                  0            $self->save_error("Specify at least one of $err");
456                                                         }
457                                                      }
458                                                   
459           14                                 42      foreach my $long ( keys %{$self->{opts}} ) {
              14                                137   
460          266                                940         my $opt = $self->{opts}->{$long};
461          266    100                        1356         if ( $opt->{got} ) {
      ***            50                               
462   ***      5     50                          24            if ( exists $self->{disables}->{$long} ) {
463   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
464   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
465   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
466                                                                  'because', $long,'disables them');
467                                                            }
468                                                   
469   ***      5     50                          24            if ( exists $self->{allowed_groups}->{$long} ) {
470                                                   
471   ***      0                                  0               my @restricted_groups = grep {
472   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
473   ***      0                                  0               } keys %{$self->{groups}};
474                                                   
475   ***      0                                  0               my @restricted_opts;
476   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
477   ***      0                                  0                  RESTRICTED_OPT:
478   ***      0                                  0                  foreach my $restricted_opt (
479                                                                     keys %{$self->{groups}->{$restricted_group}} )
480                                                                  {
481   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
482   ***      0      0                           0                     push @restricted_opts, $restricted_opt
483                                                                        if $self->{opts}->{$restricted_opt}->{got};
484                                                                  }
485                                                               }
486                                                   
487   ***      0      0                           0               if ( @restricted_opts ) {
488   ***      0                                  0                  my $err;
489   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
490   ***      0                                  0                     $err = "--$restricted_opts[0]";
491                                                                  }
492                                                                  else {
493   ***      0                                  0                     $err = join(', ',
494   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
495   ***      0                                  0                               grep { $_ } 
496                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
497                                                                            )
498                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
499                                                                  }
500   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
501                                                               }
502                                                            }
503                                                   
504                                                         }
505                                                         elsif ( $opt->{is_required} ) { 
506   ***      0                                  0            $self->save_error("Required option --$long must be specified");
507                                                         }
508                                                   
509          266                                957         $self->_validate_type($opt);
510                                                      }
511                                                   
512           14                                 74      $self->{got_opts} = 1;
513           14                                 39      return;
514                                                   }
515                                                   
516                                                   sub _validate_type {
517          266                  266           911      my ( $self, $opt ) = @_;
518   ***    266    100     66                 2150      return unless $opt && $opt->{type};
519          196                                602      my $val = $opt->{value};
520                                                   
521   ***    196     50     66                 4401      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
522   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
523   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
524   ***      0      0                           0         if ( !$suffix ) {
525   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
526   ***      0             0                    0            $suffix = $s || 's';
527   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
528                                                               $opt->{long}, '(value:', $val, ')');
529                                                         }
530   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
531   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
532                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
533                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
534                                                                 :                  $num * 86400;   # Days
535   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
536   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
537                                                         }
538                                                         else {
539   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
540                                                         }
541                                                      }
542                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
543   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
544   ***      0                                  0         my $prev = {};
545   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
546   ***      0      0                           0         if ( $from_key ) {
547   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
548   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
549                                                         }
550   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
551   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
552                                                      }
553                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
554   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
555   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
556   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
557   ***      0      0                           0         if ( defined $num ) {
558   ***      0      0                           0            if ( $factor ) {
559   ***      0                                  0               $num *= $factor_for{$factor};
560   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
561                                                                  'to num', $num, '* factor', $factor);
562                                                            }
563   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
564                                                         }
565                                                         else {
566   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
567                                                         }
568                                                      }
569                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
570   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
571                                                      }
572                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
573   ***     14            50                  225         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
574                                                      }
575                                                      else {
576          182                                431         MKDEBUG && _d('Nothing to validate for option',
577                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
578                                                      }
579                                                   
580          196                                636      return;
581                                                   }
582                                                   
583                                                   sub get {
584           89                   89           382      my ( $self, $opt ) = @_;
585   ***     89     50                         385      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
586   ***     89     50     33                  848      die "Option $opt does not exist"
587                                                         unless $long && exists $self->{opts}->{$long};
588           89                                670      return $self->{opts}->{$long}->{value};
589                                                   }
590                                                   
591                                                   sub got {
592           56                   56           233      my ( $self, $opt ) = @_;
593   ***     56     50                         234      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
594   ***     56     50     33                  516      die "Option $opt does not exist"
595                                                         unless $long && exists $self->{opts}->{$long};
596           56                                340      return $self->{opts}->{$long}->{got};
597                                                   }
598                                                   
599                                                   sub has {
600           14                   14            64      my ( $self, $opt ) = @_;
601   ***     14     50                          73      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
602   ***     14     50                         110      return defined $long ? exists $self->{opts}->{$long} : 0;
603                                                   }
604                                                   
605                                                   sub set {
606   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
607   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
608   ***      0      0      0                    0      die "Option $opt does not exist"
609                                                         unless $long && exists $self->{opts}->{$long};
610   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
611   ***      0                                  0      return;
612                                                   }
613                                                   
614                                                   sub save_error {
615   ***      0                    0             0      my ( $self, $error ) = @_;
616   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
617                                                   }
618                                                   
619                                                   sub errors {
620   ***      0                    0             0      my ( $self ) = @_;
621   ***      0                                  0      return $self->{errors};
622                                                   }
623                                                   
624                                                   sub prompt {
625   ***      0                    0             0      my ( $self ) = @_;
626   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
627                                                   }
628                                                   
629                                                   sub descr {
630   ***      0                    0             0      my ( $self ) = @_;
631   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
632                                                                 . "  For more details, please use the --help option, "
633                                                                 . "or try 'perldoc $PROGRAM_NAME' "
634                                                                 . "for complete documentation.";
635   ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
636                                                         unless $ENV{DONT_BREAK_LINES};
637   ***      0                                  0      $descr =~ s/ +$//mg;
638   ***      0                                  0      return $descr;
639                                                   }
640                                                   
641                                                   sub usage_or_errors {
642           14                   14            59      my ( $self ) = @_;
643   ***     14     50                          78      if ( $self->{opts}->{help}->{got} ) {
      ***     14     50                          68   
644   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
645   ***      0                                  0         exit 0;
646                                                      }
647                                                      elsif ( scalar @{$self->{errors}} ) {
648   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
649   ***      0                                  0         exit 0;
650                                                      }
651           14                                 39      return;
652                                                   }
653                                                   
654                                                   sub print_errors {
655   ***      0                    0             0      my ( $self ) = @_;
656   ***      0                                  0      my $usage = $self->prompt() . "\n";
657   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
658   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
659                                                                 . "\n";
660                                                      }
661   ***      0                                  0      return $usage . "\n" . $self->descr();
662                                                   }
663                                                   
664                                                   sub print_usage {
665   ***      0                    0             0      my ( $self ) = @_;
666   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
667   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
668                                                   
669   ***      0      0                           0      my $maxl = max(
670   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
671                                                         @opts);
672                                                   
673   ***      0      0                           0      my $maxs = max(0,
674   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
675   ***      0                                  0         values %{$self->{short_opts}});
676                                                   
677   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
678   ***      0                                  0      my $rcol = 80 - $lcol - 6;
679   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
680                                                   
681   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
682                                                   
683   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
684                                                   
685   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
686   ***      0                                  0      push @groups, 'default';
687                                                   
688   ***      0                                  0      foreach my $group ( reverse @groups ) {
689   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
690   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
691   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
692                                                            grep { $_->{group} eq $group }
693                                                            @opts )
694                                                         {
695   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
696   ***      0                                  0            my $short = $opt->{short};
697   ***      0                                  0            my $desc  = $opt->{desc};
698   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
699   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
700   ***      0             0                    0               $s    ||= 's';
701   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
702   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
703                                                                      . "d=days; if no suffix, $s is used.";
704                                                            }
705   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
706   ***      0                                  0            $desc =~ s/ +$//mg;
707   ***      0      0                           0            if ( $short ) {
708   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
709                                                            }
710                                                            else {
711   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
712                                                            }
713                                                         }
714                                                      }
715                                                   
716   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
717   ***      0                                  0         $usage .= "\nRules:\n\n";
718   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
719                                                      }
720   ***      0      0                           0      if ( $self->{dp} ) {
721   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
722                                                      }
723   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
724   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
725   ***      0                                  0         my $val   = $opt->{value};
726   ***      0             0                    0         my $type  = $opt->{type} || '';
727   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
728   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
729                                                                   : !defined $val             ? '(No value)'
730                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
731                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
732                                                                   : $type =~ m/A|a/           ? join(',', @$val)
733                                                                   :                             $val;
734   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
735                                                      }
736   ***      0                                  0      return $usage;
737                                                   }
738                                                   
739                                                   sub prompt_noecho {
740   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
741   ***      0                                  0      my ( $prompt ) = @_;
742   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
743   ***      0      0                           0      print $prompt
744                                                         or die "Cannot print: $OS_ERROR";
745   ***      0                                  0      my $response;
746   ***      0                                  0      eval {
747   ***      0                                  0         require Term::ReadKey;
748   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
749   ***      0                                  0         chomp($response = <STDIN>);
750   ***      0                                  0         Term::ReadKey::ReadMode('normal');
751   ***      0      0                           0         print "\n"
752                                                            or die "Cannot print: $OS_ERROR";
753                                                      };
754   ***      0      0                           0      if ( $EVAL_ERROR ) {
755   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
756                                                      }
757   ***      0                                  0      return $response;
758                                                   }
759                                                   
760                                                   if ( MKDEBUG ) {
761                                                      print '# ', $^X, ' ', $], "\n";
762                                                      my $uname = `uname -a`;
763                                                      if ( $uname ) {
764                                                         $uname =~ s/\s+/ /g;
765                                                         print "# $uname\n";
766                                                      }
767                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
768                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
769                                                         ($main::SVN_REV || ''), __LINE__);
770                                                      print('# Arguments: ',
771                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
772                                                   }
773                                                   
774                                                   sub _read_config_file {
775           56                   56           235      my ( $self, $filename ) = @_;
776   ***     56     50                         142      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
777   ***      0                                  0      my @args;
778   ***      0                                  0      my $prefix = '--';
779   ***      0                                  0      my $parse  = 1;
780                                                   
781                                                      LINE:
782   ***      0                                  0      while ( my $line = <$fh> ) {
783   ***      0                                  0         chomp $line;
784   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
785   ***      0                                  0         $line =~ s/\s+#.*$//g;
786   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
787   ***      0      0                           0         if ( $line eq '--' ) {
788   ***      0                                  0            $prefix = '';
789   ***      0                                  0            $parse  = 0;
790   ***      0                                  0            next LINE;
791                                                         }
792   ***      0      0      0                    0         if ( $parse
      ***             0                               
793                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
794                                                         ) {
795   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
796                                                         }
797                                                         elsif ( $line =~ m/./ ) {
798   ***      0                                  0            push @args, $line;
799                                                         }
800                                                         else {
801   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
802                                                         }
803                                                      }
804   ***      0                                  0      close $fh;
805   ***      0                                  0      return @args;
806                                                   }
807                                                   
808                                                   sub read_para_after {
809   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
810   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
811   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
812   ***      0                                  0      my $para;
813   ***      0                                  0      while ( $para = <$fh> ) {
814   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
815   ***      0                                  0         last;
816                                                      }
817   ***      0                                  0      while ( $para = <$fh> ) {
818   ***      0      0                           0         next unless $para =~ m/$regex/;
819   ***      0                                  0         last;
820                                                      }
821   ***      0                                  0      $para = <$fh>;
822   ***      0                                  0      chomp($para);
823   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
824   ***      0                                  0      return $para;
825                                                   }
826                                                   
827                                                   sub clone {
828   ***      0                    0             0      my ( $self ) = @_;
829                                                   
830   ***      0                                  0      my %clone = map {
831   ***      0                                  0         my $hashref  = $self->{$_};
832   ***      0                                  0         my $val_copy = {};
833   ***      0                                  0         foreach my $key ( keys %$hashref ) {
834   ***      0                                  0            my $ref = ref $hashref->{$key};
835   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
836   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
837   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
838                                                                              : $hashref->{$key};
839                                                         }
840   ***      0                                  0         $_ => $val_copy;
841                                                      } qw(opts short_opts defaults);
842                                                   
843   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
844   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
845                                                      }
846                                                   
847   ***      0                                  0      return bless \%clone;     
848                                                   }
849                                                   
850                                                   sub _d {
851   ***      0                    0             0      my ($package, undef, $line) = caller 0;
852   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
853   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
854                                                           @_;
855   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
856                                                   }
857                                                   
858                                                   1;
859                                                   
860                                                   # ###########################################################################
861                                                   # End OptionParser package
862                                                   # ###########################################################################
863                                                   
864                                                   # ###########################################################################
865                                                   # ReportFormatter package 5266
866                                                   # ###########################################################################
867                                                   package ReportFormatter;
868                                                   
869            2                    2            20   use strict;
               2                                  5   
               2                                 15   
870            2                    2            13   use warnings FATAL => 'all';
               2                                  5   
               2                                 15   
871            2                    2            14   use English qw(-no_match_vars);
               2                                  5   
               2                                 12   
872            2                    2            14   use List::Util qw(min max);
               2                                  5   
               2                                 11   
873                                                   
874   ***      2            50      2            14   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  4   
               2                                 40   
875                                                   
876            2                    2            13   use Data::Dumper;
               2                                  5   
               2                                 17   
877                                                   $Data::Dumper::Indent    = 1;
878                                                   $Data::Dumper::Sortkeys  = 1;
879                                                   $Data::Dumper::Quotekeys = 0;
880                                                   
881                                                   sub new {
882           14                   14            91      my ( $class, %args ) = @_;
883           14                                 51      my @required_args = qw();
884           14                                 79      foreach my $arg ( @required_args ) {
885   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
886                                                      }
887           14                                121      my $self = {
888                                                         underline_header  => 1,
889                                                         line_prefix        => '# ',
890                                                         line_width         => 78,
891                                                         truncate_underline => 1,
892                                                         %args,
893                                                      };
894           14                                124      return bless $self, $class;
895                                                   }
896                                                   
897                                                   sub set_title {
898   ***      0                    0             0      my ( $self, $title ) = @_;
899   ***      0                                  0      $self->{title} = $title;
900   ***      0                                  0      return;
901                                                   }
902                                                   
903                                                   sub set_columns {
904           14                   14            74      my ( $self, @cols ) = @_;
905           14                                 80      push @{$self->{cols}}, map {
              42                                112   
906           14                                 43         my $col = $_;
907   ***     42     50                         175         die "Column does not have a name" unless defined $col->{name};
908   ***     42     50     33                  208         if ( $col->{fixed_wdith} && $col->{fixed_width} < length $col->{name} ) { 
909   ***      0                                  0            die "Fixed width is less than the column name";
910                                                         }
911           42                                161         $col->{min_val_width} = length $col->{name};
912           42                                155         $col->{max_val_width} = length $col->{name};
913           42                                135         $col;
914                                                      } @cols;
915           14                                 42      return;
916                                                   }
917                                                   
918                                                   sub add_line {
919          108                  108           498      my ( $self, @vals ) = @_;
920                                                   
921          108                                307      my $n_cols = scalar @{$self->{cols}};
             108                                439   
922          108                                288      my $n_vals = scalar @vals;
923   ***    108     50                         410      die "Number of columns ($n_cols) and values ($n_vals) do not match"
924                                                         unless $n_cols == $n_vals;
925                                                   
926          108                                252      my @line;
927          108                                520      for my $i ( 0..$#vals ) {
928          324                               1130         my $col = $self->{cols}->[$i];
929          324                                907         my $val = $vals[$i];
930          324                                864         my $width = length $val;
931   ***    324     50     66                 1993         if ( $col->{fixed_width} && $width > $col->{fixed_width} ) {
932   ***      0      0                           0            if ( $col->{truncate} ) {
933   ***      0                                  0               $val  = substr($val, 0, $col->{fixed_width} - 3);
934   ***      0                                  0               $val .= '...';
935   ***      0                                  0               MKDEBUG && _d('Truncated', $vals[$i], 'to', $val);
936                                                            }
937                                                            else {
938   ***      0                                  0               die "Value '$val' is too wide for column $col->{name}";
939                                                            }
940                                                         }
941          324                               1554         $col->{max_val_width} = max($width, $col->{max_val_width});
942          324                               1211         push @line, $val;
943                                                      }
944          108                                299      push @{$self->{lines}}, \@line;
             108                                428   
945                                                   
946          108                                376      return;
947                                                   }
948                                                   
949                                                   sub get_report {
950           14                   14            47      my ( $self ) = @_;
951           14                                 37      my @lines;
952   ***     14            50                  122      my $p = $self->{line_prefix} || '';
953                                                   
954   ***     14     50                          41      my $n_cols = scalar @{$self->{cols}}
              14                                 90   
955                                                                 - ($self->{long_last_column} ? 2 : 1);
956                                                   
957           14                                 39      my $fmt = $p;
958           14                                 37      my @col_fmts;
959           14                                 77      for my $i ( 0..$n_cols ) {
960           42                                145         my $col = $self->{cols}->[$i];
961           42    100                         260         my $col_fmt = '%'
962                                                                     . ($col->{right_justify} ? '' : '-')
963                                                                     . "$col->{max_val_width}"
964                                                                     . 's';
965           42                                150         push @col_fmts, $col_fmt;
966                                                      }
967   ***     14     50                          70      if ( $self->{long_last_column} ) {
968   ***      0                                  0         push @col_fmts, '%s';
969                                                      }
970           14                                 59      $fmt .= join(' ', @col_fmts);
971           14                                 35      MKDEBUG && _d('Format:', $fmt);
972                                                   
973   ***     14     50                          63      push @lines, sprintf "${p}$self->{title}" if $self->{title};
974                                                   
975           14                                197      (my $hdr_fmt = $fmt) =~ s/%([^-])/%-$1/g;
976           14                                 49      push @lines, sprintf $hdr_fmt, map { $_->{name} } @{$self->{cols}};
              42                                232   
              14                                 63   
977                                                   
978   ***     14     50                          83      if ( $self->{underline_header} ) {
979           14                                 40         my $underline_len = 0;
980           42                                167         my @underlines = map {
981           14                                 60            my $underline = '=' x $_->{max_val_width};
982           42                                120            $underline_len += length $underline;
983           42                                155            $underline;
984           14                                 40         } @{$self->{cols}};
985           14                                 53         $underline_len += (scalar @underlines) - 1;
986   ***     14     50     33                  162         if ( $self->{truncate_underline}
987                                                              && (2 + $underline_len) > $self->{line_width} ) {
988   ***      0                                  0            my $over = $self->{line_width} - (2 + $underline_len);
989   ***      0                                  0            $underlines[-1] = substr($underlines[-1], 0, $over);
990                                                         }
991                                                   
992           14                                 90         push @lines, sprintf $fmt, @underlines;
993                                                      }
994                                                   
995           14                                 38      foreach my $line ( @{$self->{lines}} ) {
              14                                 64   
996          108                                474         push @lines, sprintf $fmt, @$line;
997                                                      }
998                                                   
999           14                                245      return join("\n", @lines) . "\n";
1000                                                  }
1001                                                  
1002                                                  sub _d {
1003  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1004  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1005  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1006                                                          @_;
1007  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1008                                                  }
1009                                                  
1010                                                  1;
1011                                                  
1012                                                  # ###########################################################################
1013                                                  # End ReportFormatter package
1014                                                  # ###########################################################################
1015                                                  
1016                                                  # ###########################################################################
1017                                                  # ErrorLogParser package 5401
1018                                                  # ###########################################################################
1019                                                  package ErrorLogParser;
1020                                                  
1021           2                    2            18   use strict;
               2                                  5   
               2                                 10   
1022           2                    2            16   use warnings FATAL => 'all';
               2                                  4   
               2                                 12   
1023           2                    2            13   use English qw(-no_match_vars);
               2                                  6   
               2                                  9   
1024                                                  
1025           2                    2            14   use Data::Dumper;
               2                                  5   
               2                                 10   
1026                                                  $Data::Dumper::Indent    = 1;
1027                                                  $Data::Dumper::Sortkeys  = 1;
1028                                                  $Data::Dumper::Quotekeys = 0;
1029                                                  
1030  ***      2            50      2            13   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  5   
               2                                 34   
1031                                                  
1032                                                  my $ts = qr/(\d{6}\s{1,2}[\d:]+)\s*/;
1033                                                  my $ml = qr{\A(?:
1034                                                     InnoDB:\s
1035                                                     |-\smysqld\sgot\ssignal
1036                                                     |Status\sinformation
1037                                                     |Memory\sstatus
1038                                                  )}x;
1039                                                  
1040                                                  sub new {
1041          14                   14            74      my ( $class, %args ) = @_;
1042          14                                 80      my $self = {
1043                                                        %args,
1044                                                        pending => [],
1045                                                     };
1046          14                                113      return bless $self, $class;
1047                                                  }
1048                                                  
1049                                                  sub parse_event {
1050         269                  269          1124      my ( $self, %args ) = @_;
1051         269                               1003      my @required_args = qw(fh);
1052         269                                827      foreach my $arg ( @required_args ) {
1053  ***    269     50                        1325         die "I need a $arg argument" unless $args{$arg};
1054                                                     }
1055         269                               1015      my ($fh) = @args{@required_args};
1056                                                  
1057         269                                833      my $pending = $self->{pending};
1058                                                  
1059         269                                862      my $pos_in_log = tell($fh);
1060         269                                614      my $line;
1061                                                     EVENT:
1062         269           100                 2833      while ( defined($line = shift @$pending) or defined($line = <$fh>) ) {
1063         299    100                        1812         next if $line =~ m/^\s*$/;  # lots of blank lines in error logs
1064         255                                684         chomp $line;
1065         255                                947         my @properties = ('pos_in_log', $pos_in_log);
1066         255                                762         $pos_in_log = tell($fh);
1067                                                  
1068         255    100                        1927         if ( my ($ts) = $line =~ /^$ts/o ) {
1069         221                                470            MKDEBUG && _d('Got ts:', $ts);
1070         221                                706            push @properties, 'ts', $ts;
1071         221                               2261            $line =~ s/^$ts//;
1072                                                        }
1073                                                  
1074         255                                675         my $level;
1075         255    100                        1436         if ( ($level) = $line =~ /\[((?:ERROR|Warning|Note))\]/ ) {
1076         114    100                         576            $level = $level =~ m/error/i   ? 'error'
                    100                               
1077                                                                  : $level =~ m/warning/i ? 'warning'
1078                                                                  :                         'info';
1079                                                        }
1080                                                        else {
1081         141                                400            $level = 'unknown';
1082                                                        }
1083         255                                575         MKDEBUG && _d('Level:', $level);
1084         255                                821         push @properties, 'Level', $level;
1085                                                  
1086         255    100                        1187         if ( my ($level) = $line =~ /InnoDB: Error/ ) {
1087           6                                 15            MKDEBUG && _d('Got serious InnoDB error');
1088           6                                 21            push @properties, 'Level', 'error';
1089                                                        }
1090                                                  
1091         255                                847         $line =~ s/^\s+//;
1092         255                               1044         $line =~ s/\s{2,}/ /;
1093         255                               1128         $line =~ s/\s+$//;
1094                                                  
1095                                                  
1096         255    100                        1379         if ( $line =~ m/$ml/o ) {
                    100                               
1097          60                                130            MKDEBUG && _d('Multi-line message:', $line);
1098          60                                184            $line =~ s/- //; # Trim "- msyqld got signal" special case.
1099          60                                145            my $next_line;
1100          60           100                  813            while ( defined($next_line = <$fh>)
1101                                                                   && $next_line !~ m/^$ts/o ) {
1102        3398                               8530               chomp $next_line;
1103        3398    100                       14893               next if $next_line eq '';
1104        3065                               8341               $next_line =~ s/^InnoDB: //; # InnoDB special-case.
1105        3065                              31141               $line     .= " " . $next_line;
1106                                                           }
1107          60                                127            MKDEBUG && _d('Pending next line:', $next_line);
1108          60                                246            push @$pending, $next_line;
1109                                                        }
1110                                                        elsif ( $line =~ m/\bQuery: '/ ) {
1111           1                                  8            MKDEBUG && _d('Error query:', $line);
1112           1                                  6            my $next_line;
1113           1                                  5            my $last_line = 0;
1114  ***      1            66                   17            while ( !$last_line && defined($next_line = <$fh>) ) {
1115           3                                 10               chomp $next_line;
1116           3                                  6               MKDEBUG && _d('Error query:', $next_line);
1117           3                                  8               $line     .= $next_line;
1118           3    100                          30               $last_line = 1 if $next_line =~ m/, Error_code:/;
1119                                                           }
1120                                                        }
1121                                                  
1122         255                                704         chomp $line;
1123         255                               1025         push @properties, 'arg', $line;
1124                                                  
1125         255                                525         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
1126         255                               1457         my $event = { @properties };
1127         255                               1590         return $event;
1128                                                  
1129                                                     } # EVENT
1130                                                  
1131          14                                 49      @$pending = ();
1132  ***     14     50                          86      $args{oktorun}->(0) if $args{oktorun};
1133          14                                 66      return;
1134                                                  }
1135                                                  
1136                                                  sub _d {
1137  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1138  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1139  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1140                                                          @_;
1141  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1142                                                  }
1143                                                  
1144                                                  1;
1145                                                  
1146                                                  # ###########################################################################
1147                                                  # End ErrorLogParser package
1148                                                  # ###########################################################################
1149                                                  
1150                                                  # ###########################################################################
1151                                                  # ErrorLogPatternMatcher package 5573
1152                                                  # ###########################################################################
1153                                                  package ErrorLogPatternMatcher;
1154                                                  
1155           2                    2            15   use strict;
               2                                  4   
               2                                 11   
1156           2                    2            12   use warnings FATAL => 'all';
               2                                  4   
               2                                 14   
1157           2                    2            12   use English qw(-no_match_vars);
               2                                  6   
               2                                 13   
1158           2                    2            12   use Data::Dumper;
               2                                  5   
               2                                 10   
1159                                                  $Data::Dumper::Indent    = 1;
1160                                                  $Data::Dumper::Sortkeys  = 1;
1161                                                  $Data::Dumper::Quotekeys = 0;
1162                                                  
1163  ***      2            50      2            17   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  4   
               2                                 25   
1164                                                  
1165                                                  sub new {
1166          14                   14            75      my ( $class, %args ) = @_;
1167          14                                132      my $self = {
1168                                                        %args,
1169                                                        patterns => [],
1170                                                        compiled => [],
1171                                                        level    => [],
1172                                                        name     => [],
1173                                                     };
1174          14                                102      return bless $self, $class;
1175                                                  }
1176                                                  
1177                                                  sub add_patterns {
1178          82                   82           303      my ( $self, $patterns ) = @_;
1179          82                                293      foreach my $p ( @$patterns ) {
1180  ***    348     50     50                 2660         next unless $p && scalar @$p;
1181         348                               1539         my ($name, $level, $regex) = @$p;
1182         348                                956         push @{$self->{names}},    $name;
             348                               1338   
1183         348                                849         push @{$self->{levels}},   $level;
             348                               1230   
1184         348                                851         push @{$self->{patterns}}, $regex;
             348                               1231   
1185         348                                834         push @{$self->{compiled}}, qr/$regex/;
             348                               5114   
1186         348                               1073         MKDEBUG && _d('Added new pattern:', $name, $level, $regex,
1187                                                           $self->{compiled}->[-1]);
1188                                                     }
1189          82                                247      return;
1190                                                  }
1191                                                  
1192                                                  sub load_patterns_file {
1193  ***      0                    0             0      my ( $self, $fh ) = @_;
1194  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1195  ***      0                                  0      my %seen;
1196  ***      0                                  0      my $pattern;
1197  ***      0                                  0      while ( defined($pattern = <$fh>) ) {
1198  ***      0                                  0         my ($name, $level, $regex) = split("\n", $pattern);
1199  ***      0      0      0                    0         if ( !($name && $level && $regex) ) {
      ***                    0                        
1200  ***      0                                  0            warn "Pattern missing name, level or regex:\n$pattern";
1201  ***      0                                  0            next;
1202                                                        }
1203  ***      0      0                           0         if ( $seen{$name}++ ) {
1204  ***      0                                  0            warn "Duplicate pattern: $name";
1205  ***      0                                  0            next;
1206                                                        }
1207  ***      0                                  0         $self->add_patterns( [[$name, $level, $regex]] );
1208                                                     }
1209  ***      0                                  0      return;
1210                                                  }
1211                                                  
1212                                                  sub reset_patterns {
1213  ***      0                    0             0      my ( $self ) = @_;
1214  ***      0                                  0      $self->{names}    = [];
1215  ***      0                                  0      $self->{levels}   = [];
1216  ***      0                                  0      $self->{patterns} = [];
1217  ***      0                                  0      $self->{compiled} = [];
1218  ***      0                                  0      MKDEBUG && _d('Reset patterns');
1219  ***      0                                  0      return;
1220                                                  }
1221                                                  
1222                                                  sub patterns {
1223  ***      0                    0             0      my ( $self ) = @_;
1224  ***      0                                  0      return @{$self->{patterns}};
      ***      0                                  0   
1225                                                  }
1226                                                  
1227                                                  sub names {
1228          14                   14            55      my ( $self ) = @_;
1229          14                                 41      return @{$self->{names}};
              14                                304   
1230                                                  }
1231                                                  
1232                                                  sub levels {
1233          14                   14            52      my ( $self ) = @_;
1234          14                                 35      return @{$self->{levels}};
              14                                245   
1235                                                  }
1236                                                  
1237                                                  sub match {
1238         146                  146           618      my ( $self, %args ) = @_;
1239         146                                565      my @required_args = qw(event);
1240         146                                472      foreach my $arg ( @required_args ) {
1241  ***    146     50                         712         die "I need a $arg argument" unless $args{$arg};
1242                                                     }
1243         146                                500      my $event = @args{@required_args};
1244         146                                569      my $err   = $event->{arg};
1245  ***    146     50                         489      return unless $err;
1246                                                  
1247  ***    146     50     33                  740      if ( $self->{QueryRewriter}
1248                                                          && (my ($query) = $err =~ m/Statement: (.+)$/) ) {
1249  ***      0                                  0         $query = $self->{QueryRewriter}->fingerprint($query);
1250  ***      0                                  0         $err =~ s/Statement: .+$/Statement: $query/;
1251                                                     }
1252                                                  
1253         146                                443      my $compiled = $self->{compiled};
1254         146                                471      my $n        = (scalar @$compiled) - 1;
1255         146                                320      my $pno;
1256                                                     PATTERN:
1257         146                                515      for my $i ( 0..$n ) {
1258        2431    100                       13098         if ( $err =~ m/$compiled->[$i]/ ) {
1259          78                                188            $pno = $i;
1260          78                                222            last PATTERN;
1261                                                        } 
1262                                                     }
1263                                                  
1264         146    100                         503      if ( defined $pno ) {
1265          78                                167         MKDEBUG && _d($err, 'matches', $self->{patterns}->[$pno]);
1266          78                                297         $event->{New_pattern} = 'No';
1267          78                                263         $event->{Pattern_no}  = $pno;
1268                                                  
1269  ***     78     50     33                  424         if ( !$event->{Level} && $self->{levels}->[$pno] ) {
1270  ***      0                                  0            $event->{Level} = $self->{levels}->[$pno];
1271                                                        }
1272                                                     }
1273                                                     else {
1274          68                                142         MKDEBUG && _d('New pattern');
1275          68                                281         my $regex = $self->fingerprint($err);
1276          68                                233         my $name  = substr($err, 0, 50);
1277          68                                437         $self->add_patterns( [ [$name, $event->{Level}, $regex] ] );
1278          68                                309         $event->{New_pattern} = 'Yes';
1279          68                                176         $event->{Pattern_no}  = (scalar @{$self->{patterns}}) - 1;
              68                                355   
1280                                                     }
1281                                                  
1282         146                                770      $event->{Pattern} = $self->{patterns}->[ $event->{Pattern_no} ];
1283                                                  
1284         146                                640      return $event;
1285                                                  }
1286                                                  
1287                                                  sub fingerprint {
1288          68                   68           315      my ( $self, $err ) = @_;
1289                                                  
1290          68                                870      $err =~ s/([\(\)\[\].+?*\{\}])/\\$1/g;
1291                                                  
1292          68                                809      $err =~ s/\b\d+\b/\\d+/g;              # numbers
1293          68                                223      $err =~ s/\b0x[0-9a-zA-Z]+\b/0x\\S+/g; # hex values
1294                                                  
1295          68                                305      return $err;
1296                                                  }
1297                                                  
1298                                                  sub _d {
1299  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1300  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1301  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1302                                                          @_;
1303  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1304                                                  }
1305                                                  
1306                                                  1;
1307                                                  
1308                                                  # ###########################################################################
1309                                                  # End ErrorLogPatternMatcher package
1310                                                  # ###########################################################################
1311                                                  
1312                                                  # ###########################################################################
1313                                                  # Transformers package 5266
1314                                                  # ###########################################################################
1315                                                  
1316                                                  # Transformers - Common transformation and beautification subroutines
1317                                                  package Transformers;
1318                                                  
1319           2                    2            15   use strict;
               2                                  5   
               2                                 11   
1320           2                    2            12   use warnings FATAL => 'all';
               2                                  4   
               2                                 12   
1321           2                    2            12   use English qw(-no_match_vars);
               2                                  4   
               2                                234   
1322           2                    2           122   use Time::Local qw(timegm timelocal);
               2                                  7   
               2                                 19   
1323           2                    2            18   use Digest::MD5 qw(md5_hex);
               2                                  5   
               2                                 14   
1324                                                  
1325  ***      2            50      2            12   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  4   
               2                                 25   
1326                                                  
1327                                                  require Exporter;
1328                                                  our @ISA         = qw(Exporter);
1329                                                  our %EXPORT_TAGS = ();
1330                                                  our @EXPORT      = ();
1331                                                  our @EXPORT_OK   = qw(
1332                                                     micro_t
1333                                                     percentage_of
1334                                                     secs_to_time
1335                                                     shorten
1336                                                     ts
1337                                                     parse_timestamp
1338                                                     unix_timestamp
1339                                                     any_unix_timestamp
1340                                                     make_checksum
1341                                                  );
1342                                                  
1343                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1344                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
1345                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1346                                                                                           # like a MySQL YYMMDD without hh:mm:ss.
1347                                                  
1348                                                  sub micro_t {
1349  ***      0                    0             0      my ( $t, %args ) = @_;
1350  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1351  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1352  ***      0                                  0      my $f;
1353                                                  
1354  ***      0      0                           0      $t = 0 if $t < 0;
1355                                                  
1356                                                     # "Remove" scientific notation so the regex below does not make
1357                                                     # 6.123456e+18 into 6.123456.
1358  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1359                                                  
1360                                                     # Truncate after 6 decimal places to avoid 0.9999997 becoming 1
1361                                                     # because sprintf() rounds.
1362  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1363                                                  
1364  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1365  ***      0                                  0         $f = ($t * 1000000) . 'us';
1366                                                     }
1367                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1368  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1369  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1370                                                     }
1371                                                     elsif ($t >= 1) {
1372  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1373  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1374                                                     }
1375                                                     else {
1376  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1377                                                     }
1378                                                  
1379  ***      0                                  0      return $f;
1380                                                  }
1381                                                  
1382                                                  # Returns what percentage $is of $of.
1383                                                  sub percentage_of {
1384  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1385  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1386  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1387  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1388                                                  }
1389                                                  
1390                                                  sub secs_to_time {
1391  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1392  ***      0             0                    0      $secs ||= 0;
1393  ***      0      0                           0      return '00:00' unless $secs;
1394                                                  
1395                                                     # Decide what format to use, if not given
1396  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1397                                                            : $secs >= 3_600  ? 'h'
1398                                                            :                   'm';
1399                                                  
1400                                                     return
1401  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1402                                                           "%d+%02d:%02d:%02d",
1403                                                           int($secs / 86_400),
1404                                                           int(($secs % 86_400) / 3_600),
1405                                                           int(($secs % 3_600) / 60),
1406                                                           $secs % 60)
1407                                                        : $fmt eq 'h' ? sprintf(
1408                                                           "%02d:%02d:%02d",
1409                                                           int(($secs % 86_400) / 3_600),
1410                                                           int(($secs % 3_600) / 60),
1411                                                           $secs % 60)
1412                                                        : sprintf(
1413                                                           "%02d:%02d",
1414                                                           int(($secs % 3_600) / 60),
1415                                                           $secs % 60);
1416                                                  }
1417                                                  
1418                                                  sub shorten {
1419  ***      0                    0             0      my ( $num, %args ) = @_;
1420  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1421  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1422  ***      0                                  0      my $n = 0;
1423  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1424  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1425  ***      0                                  0         $num /= $d;
1426  ***      0                                  0         ++$n;
1427                                                     }
1428  ***      0      0      0                    0      return sprintf(
1429                                                        $num =~ m/\./ || $n
1430                                                           ? "%.${p}f%s"
1431                                                           : '%d',
1432                                                        $num, $units[$n]);
1433                                                  }
1434                                                  
1435                                                  # Turns a unix timestamp into an ISO8601 formatted date and time.  $gmt makes
1436                                                  # this relative to GMT, for test determinism.
1437                                                  sub ts {
1438  ***      0                    0             0      my ( $time, $gmt ) = @_;
1439  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
1440                                                        = $gmt ? gmtime($time) : localtime($time);
1441  ***      0                                  0      $mon  += 1;
1442  ***      0                                  0      $year += 1900;
1443  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1444                                                        $year, $mon, $mday, $hour, $min, $sec);
1445  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
1446  ***      0                                  0         $us = sprintf("%.6f", $us);
1447  ***      0                                  0         $us =~ s/^0\././;
1448  ***      0                                  0         $val .= $us;
1449                                                     }
1450  ***      0                                  0      return $val;
1451                                                  }
1452                                                  
1453                                                  # Turns MySQL's 071015 21:43:52 into a properly formatted timestamp.  Also
1454                                                  # handles a timestamp with fractions after it.
1455                                                  sub parse_timestamp {
1456         164                  164           530      my ( $val ) = @_;
1457  ***    164     50                        1949      if ( my($y, $m, $d, $h, $i, $s, $f)
1458                                                           = $val =~ m/^$mysql_ts$/ )
1459                                                     {
1460  ***    164     50                        1729         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***            50                               
1461                                                                       . (defined $f ? '%02.6f' : '%02d'),
1462                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1463                                                     }
1464  ***      0                                  0      return $val;
1465                                                  }
1466                                                  
1467                                                  # Turns a properly formatted timestamp like 2007-10-15 01:43:52
1468                                                  # into an int (seconds since epoch).  Optional microseconds are printed.  $gmt
1469                                                  # makes it use GMT time instead of local time (to make tests deterministic).
1470                                                  sub unix_timestamp {
1471         165                  165           583      my ( $val, $gmt ) = @_;
1472  ***    165     50                        1941      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
1473  ***    165     50                        1033         $val = $gmt
1474                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
1475                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
1476  ***    165     50                         620         if ( defined $us ) {
1477  ***      0                                  0            $us = sprintf('%.6f', $us);
1478  ***      0                                  0            $us =~ s/^0\././;
1479  ***      0                                  0            $val .= $us;
1480                                                        }
1481                                                     }
1482         165                                791      return $val;
1483                                                  }
1484                                                  
1485                                                  # Turns several different types of timestamps into a unix timestamp.
1486                                                  # Each type is auto-detected.  Supported types are:
1487                                                  #   * N[shdm]                Now - N[shdm]
1488                                                  #   * 071015 21:43:52        MySQL slow log timestamp
1489                                                  #   * 2009-07-01 [3:43:01]   Proper timestamp with options HH:MM:SS
1490                                                  #   * NOW()                  A MySQL time express
1491                                                  # For the last type, the callback arg is required.  It is passed the
1492                                                  # given value/expression and is expected to return a single value
1493                                                  # (the result of the expression).
1494                                                  sub any_unix_timestamp {
1495         165                  165           599      my ( $val, $callback ) = @_;
1496                                                  
1497  ***    165     50                        2137      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
                    100                               
      ***            50                               
1498  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1499                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1500                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1501                                                           : $suffix eq 'd' ? $n * 86400    # Days
1502                                                           :                  $n;           # default: Seconds
1503  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
1504  ***      0                                  0         return time - $n;
1505                                                     }
1506                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
1507         164                                342         MKDEBUG && _d('ts is MySQL slow log timestamp');
1508         164    100                         579         $val .= ' 00:00:00' unless $hms;
1509         164                                576         return unix_timestamp(parse_timestamp($val));
1510                                                     }
1511                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
1512           1                                  3         MKDEBUG && _d('ts is properly formatted timestamp');
1513  ***      1     50                           9         $val .= ' 00:00:00' unless $hms;
1514           1                                  8         return unix_timestamp($val);
1515                                                     }
1516                                                     else {
1517  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
1518  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
1519                                                     }
1520                                                  
1521  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
1522  ***      0                                  0      return;
1523                                                  }
1524                                                  
1525                                                  # Returns the rightmost 64 bits of an MD5 checksum of the value.
1526                                                  sub make_checksum {
1527  ***      0                    0             0      my ( $val ) = @_;
1528  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1529  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1530  ***      0                                  0      return $checksum;
1531                                                  }
1532                                                  
1533                                                  sub _d {
1534  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1535  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1536  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1537                                                          @_;
1538  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1539                                                  }
1540                                                  
1541                                                  1;
1542                                                  
1543                                                  # ###########################################################################
1544                                                  # End Transformers package
1545                                                  # ###########################################################################
1546                                                  
1547                                                  # ###########################################################################
1548                                                  # This is a combination of modules and programs in one -- a runnable module.
1549                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1550                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1551                                                  #
1552                                                  # Check at the end of this package for the call to main() which actually runs
1553                                                  # the program.
1554                                                  # ###########################################################################
1555                                                  package mk_error_log;
1556                                                  
1557           2                    2            13   use English qw(-no_match_vars);
               2                                  5   
               2                                 12   
1558           2                    2            14   use Data::Dumper;
               2                                  4   
               2                                 15   
1559                                                  $Data::Dumper::Indent    = 1;
1560                                                  $Data::Dumper::Sortkeys  = 1;
1561                                                  $Data::Dumper::Quotekeys = 0;
1562                                                  
1563                                                  Transformers->import qw(any_unix_timestamp);
1564                                                  
1565  ***      2            50      2            12   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  4   
               2                                 26   
1566                                                  
1567           2                    2            22   use sigtrap 'handler', \&sig_int, 'normal-signals';
               2                                  5   
               2                                 27   
1568                                                  
1569                                                  my $oktorun = 1;
1570                                                  
1571                                                  sub main {
1572          14                   14          2649      @ARGV = @_;  # set global ARGV for this package
1573                                                  
1574                                                     # ########################################################################
1575                                                     # Get configuration information.
1576                                                     # ########################################################################
1577          14                                342      my $o  = new OptionParser(
1578                                                        strict      => 0,
1579                                                        prompt      => '[OPTION...] FILE [FILE...]',
1580                                                        description => q{parses and aggregates MySQL error log statements.},
1581                                                     );
1582          14                                111      $o->get_specs();
1583          14                                120      $o->get_opts();
1584                                                  
1585          14                                112      $o->usage_or_errors();
1586                                                  
1587                                                     # ##########################################################################
1588                                                     # Get ready to do the main work.
1589                                                     # ##########################################################################
1590          14                                178      my $parser  = new ErrorLogParser();
1591          14                                164      my $matcher = new ErrorLogPatternMatcher();
1592                                                  
1593                                                     # ##########################################################################
1594                                                     # Load saved (user) and known (internal) patterns.
1595                                                     # ##########################################################################
1596  ***     14     50                          62      if ( my $file = $o->get('load-patterns') ) {
1597  ***      0                                  0         MKDEBUG && _d('Loading saved patterns from', $file);
1598  ***      0      0                           0         open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
1599  ***      0                                  0         $matcher->load_patterns_file($fh);
1600                                                     }
1601  ***     14     50                          64      load_known_patterns($matcher) if $o->get('known-patterns');
1602                                                  
1603                                                     # ##########################################################################
1604                                                     # Create the pipeline.  These processes do the main work.
1605                                                     # ##########################################################################
1606          14                                 37      my @pipeline;
1607          14                                 34      my %cnt;       # frequency of patterns
1608                                                  
1609                                                     # Parses the error logs, makes events.
1610                                                     push @pipeline, sub {
1611         269                  269          1452         my ( %args ) = @_;
1612         269                               1400         return $parser->parse_event(%args);
1613          14                                142      };
1614                                                  
1615                                                     # --since and --until filtering.  Do this before pattern matching.
1616          14                                 40      my $past_since;
1617          14                                 34      my $at_until;
1618          14    100                          60      if ( $o->get('since') ) {
1619           3                                 13         my $since = any_unix_timestamp($o->get('since'));
1620  ***      3     50                          16         die "Invalid --since value" unless $since;
1621                                                        push @pipeline, sub {
1622         114                  114           558            my ( %args ) = @_;
1623         114                                395            my $event = $args{event};
1624         114                                234            MKDEBUG && _d('pipeline: --since');
1625         114    100                         376            if ( $past_since ) {
1626           4                                  8               MKDEBUG && _d('Already past --since');
1627           4                                 17               return $event;
1628                                                           }
1629         110    100                         447            if ( $event->{ts} ) {
1630          95                                359               my $ts = any_unix_timestamp($event->{ts});
1631  ***     95    100     50                 2048               if ( ($ts || 0) >= $since ) {
1632           3                                  7                  MKDEBUG && _d('Event is at or past --since');
1633           3                                  9                  $past_since = 1;
1634           3                                 19                  return $event;
1635                                                              }
1636                                                              else {
1637          92                                222                  MKDEBUG && _d('Event is before --since');
1638                                                              }
1639                                                           }
1640         107                                425            return;
1641           3                                 33         };
1642                                                     }
1643          14    100                          59      if ( $o->get('until') ) {
1644           2                                 18         my $until = any_unix_timestamp($o->get('until'));
1645  ***      2     50                          15         die "Invalid --until value" unless $until;
1646                                                        push @pipeline, sub {
1647          76                   76           399            my ( %args ) = @_;
1648          76                                263            my $event = $args{event};
1649          76                                161            MKDEBUG && _d('pipeline: --until');
1650          76    100                         262            if ( $at_until ) {
1651           1                                  6               MKDEBUG && _d('Already past --until');
1652           1                                  4               return;
1653                                                           }
1654          75    100                         299            if ( $event->{ts} ) {
1655          65                                244               my $ts = any_unix_timestamp($event->{ts});
1656  ***     65    100     50                  392               if ( ($ts || 0) >= $until ) {
1657           1                                  8                  MKDEBUG && _d('Event at or after --until');
1658           1                                  6                  $at_until = 1;
1659           1                                  8                  return;
1660                                                              }
1661                                                              else {
1662          64                                154                  MKDEBUG && _d('Event is before --until');
1663                                                              }
1664                                                           }
1665          74                                302            return $event;
1666           2                                 28         };
1667                                                     }
1668                                                  
1669                                                     # Matches events to known patterns or makes new patterns.
1670                                                     push @pipeline, sub {
1671         146                  146           739         my ( %args ) = @_;
1672         146                                375         MKDEBUG && _d('pipeline: match pattern');
1673  ***    146     50                         565         return unless $args{event};
1674         146                                717         my $event = $matcher->match(%args);
1675         146                                674         $cnt{ $event->{Pattern_no} }++;
1676         146                                554         return $event;
1677          14                                131      };
1678                                                  
1679                                                     # Any other pipeline processes?
1680                                                  
1681                                                     # ##########################################################################
1682                                                     # Here's the main work.
1683                                                     # ##########################################################################
1684          14                                 42      my $fh;
1685  ***     14     50                          58      if ( @ARGV == 0 ) {
1686  ***      0                                  0         push @ARGV, '-'; # Magical STDIN filename.
1687                                                     }
1688                                                  
1689                                                     FILE:
1690          14                                 65      while ( $oktorun ) {
1691         283    100                        1064         if ( !$fh ) {
1692          28                                 93            my $file = shift @ARGV;
1693          28    100                         104            if ( !$file ) {
1694          14                                 34               MKDEBUG && _d('No more files to parse');
1695          14                                 44               last FILE;
1696                                                           }
1697                                                  
1698  ***     14     50                          58            if ( $file eq '-' ) {
1699  ***      0                                  0               $fh = *STDIN;
1700  ***      0                                  0               MKDEBUG && _d('Reading STDIN');
1701                                                           }
1702                                                           else {
1703  ***     14     50                         541               if ( !open $fh, "<", $file ) {
1704  ***      0                                  0                  $fh = undef;
1705  ***      0                                  0                  warn "Cannot open $file: $OS_ERROR\n";
1706  ***      0                                  0                  next FILE;
1707                                                              }
1708          14                                 35               MKDEBUG && _d('Reading', $file);
1709                                                  
1710                                                              # Reset these var in case we read two logs out of order by time.
1711          14                                 41               $past_since = 0;
1712          14                                 49               $at_until   = 0;
1713                                                           }
1714                                                        }
1715                                                  
1716         269                                690         eval {
1717                                                           # Run events through the pipeline.  The first pipeline process
1718                                                           # is usually responsible for getting the next event.  The pipeline
1719                                                           # stops if a process does not return the event.  This main loop
1720                                                           # stops if a process sets oktorun to false; it usually does this
1721                                                           # when there are no more events, but it may do it for other reasons.
1722         269                                791            my $event       = {};
1723         269                                713            my $more_events = 1;
1724         269                   14          1317            my $oktorun_sub = sub { $more_events = $_[0]; };
              14                                 46   
1725         269                                917            foreach my $process ( @pipeline ) {
1726  ***    605     50                        2060               last unless $oktorun;  # the global oktorun var
1727         605                               2434               $event = $process->(
1728                                                                 event   => $event,
1729                                                                 oktorun => $oktorun_sub,
1730                                                                 fh      => $fh,
1731                                                              );
1732         605    100                        2849               last unless $event;
1733                                                           }
1734         269    100                        1665            if ( !$more_events ) {
1735          14                                 33               MKDEBUG && _d('No more events');
1736  ***     14     50                         137               close $fh if $fh;
1737          14                                 67               $fh = undef;
1738                                                           }
1739                                                        };
1740  ***    269     50                        1232         if ( $EVAL_ERROR ) {
1741  ***      0                                  0            _d($EVAL_ERROR);
1742                                                  
1743                                                           # Don't ignore failure to open a file, else we'll get
1744                                                           # "tell() on closed filehandle" errors.
1745                                                           # Hm, I don't think we need this any longer...
1746                                                           # last FILE if $EVAL_ERROR =~ m/Cannot open/;
1747                                                  
1748  ***      0      0                           0            last FILE unless $o->get('continue-on-error');
1749                                                        }
1750                                                     }  # FILE
1751                                                  
1752                                                     # ##########################################################################
1753                                                     # Do the report.
1754                                                     # ##########################################################################
1755          14                                166      my $reporter = new ReportFormatter(
1756                                                        line_prefix => '',
1757                                                     );
1758          14                                220      $reporter->set_columns(
1759                                                        { name => 'Count',   right_justify => 1,              },
1760                                                        { name => 'Level',                                    },
1761                                                        { name => 'Message', fixed_width => 60, truncate => 1 },
1762                                                     );
1763                                                  
1764                                                     # Save patterns while doing the report.  Re-uses $fh.
1765          14                                 35      my @patterns;
1766  ***     14     50                         102      if ( my $file = $o->get('save-patterns') ) {
1767  ***      0      0                           0         open $fh, '>', $file or die "Cannot write to $file: $OS_ERROR";
1768  ***      0                                  0         @patterns = $matcher->patterns;
1769                                                     }
1770                                                  
1771          14                                 70      my @names  = $matcher->names;
1772          14                                103      my @levels = $matcher->levels;
1773                                                  
1774          14                                 49      foreach my $pno ( sort { $cnt{$b} <=> $cnt{$a} } keys %cnt ) {
             244                                719   
1775  ***    108            50                  985         $reporter->add_line($cnt{$pno}, $levels[$pno] || '', $names[$pno] || '');
      ***                   50                        
1776                                                  
1777                                                        # Print the pattern to the --save-patterns file.
1778  ***    108     50                         429         if ( $fh ) {
1779  ***      0                                  0            print $fh "$names[$pno]\n$levels[$pno]\n$patterns[$pno]\n\n";
1780                                                        }
1781                                                     }
1782                                                  
1783          14                                 73      print $reporter->get_report();
1784                                                  
1785  ***     14     50                          64      close $fh if $fh;
1786                                                  
1787          14                               1555      return 0;
1788                                                  }
1789                                                  
1790                                                  # ##########################################################################
1791                                                  # Subroutines
1792                                                  # ##########################################################################
1793                                                  
1794                                                  # ##########################################################################
1795                                                  # This is a good place to add your own rules to match log events you're
1796                                                  # familiar with.  Each pattern/rule is a name, level and regular expression.
1797                                                  # The name will be printed out in the output, so make it representative of
1798                                                  # the log event.
1799                                                  # ##########################################################################
1800                                                  sub load_known_patterns {
1801          14                   14            70      my ( $matcher ) = @_;
1802          14                                 36      MKDEBUG && _d('Loading known patterns');
1803          14                                433      my @known_patterns = (
1804                                                        [ 'mysqld started',
1805                                                          'info',
1806                                                          'mysqld started'
1807                                                        ],
1808                                                        [ 'mysqld ended',
1809                                                           'info',
1810                                                           'mysqld ended'
1811                                                        ],
1812                                                        [ 'mysqld version info',
1813                                                           'info',
1814                                                           '^Version: \S+ '
1815                                                        ],
1816                                                        [ 'mysqladmin debug memory status',
1817                                                           'info',
1818                                                           '^Memory status:'
1819                                                        ],
1820                                                        [ 'mysqladmin debug',
1821                                                           'info',
1822                                                           '^Status information:'
1823                                                        ],
1824                                                        [ 'InnoDB: Started',
1825                                                           'info',
1826                                                           '^InnoDB: Started; log sequence number'
1827                                                        ],
1828                                                        [ 'InnoDB: Starting an apply batch',
1829                                                           'info',
1830                                                           '^InnoDB: Starting an apply batch of log'
1831                                                        ],
1832                                                        [ 'InnoDB: Starting log scan',
1833                                                           'info',
1834                                                           '^InnoDB: Starting log scan based on'
1835                                                        ],
1836                                                        [ 'InnoDB: Database was not shut down properly!',
1837                                                           'error',
1838                                                           '^InnoDB: Database was not shut down'
1839                                                        ],
1840                                                        [ 'InnoDB: Starting shutdown',
1841                                                           'info',
1842                                                           '^InnoDB: Starting shutdown...'
1843                                                        ],
1844                                                        [ 'InnoDB: Shutdown completed',
1845                                                           'info',
1846                                                           '^InnoDB: Shutdown completed;'
1847                                                        ],
1848                                                        [ 'InnoDB: Rolling back trx',
1849                                                           'info',
1850                                                           '^InnoDB: Rolling back trx with id',
1851                                                        ],
1852                                                        [  'mysqld got signal',
1853                                                           'error',
1854                                                           'mysqld got signal \d',
1855                                                        ],
1856                                                        [  'InnoDB: Assertion failure',
1857                                                           'error',
1858                                                           'InnoDB: Assertion failure in thread',
1859                                                        ],
1860                                                        [  'InnoDB: Log file did not exist!',
1861                                                           'info',
1862                                                           'InnoDB: Log file .*? did not exist',
1863                                                        ],
1864                                                        [  'InnoDB: Setting file size',
1865                                                           'info',
1866                                                           'InnoDB: Setting file \S+ size',
1867                                                        ],
1868                                                        [  'InnoDB: The first specified data file did not exist!',
1869                                                           'info',
1870                                                           'InnoDB: The first specified data file \S+',
1871                                                        ],
1872                                                        [  'InnoDB: Warning: cannot find a free slot',
1873                                                           'warning',
1874                                                           'InnoDB: Warning: cannot find a free slot',
1875                                                        ],
1876                                                        [  'InnoDB: Rolling back of trx complete',
1877                                                           'info',
1878                                                           'InnoDB: Rolling back of trx id .*?complete',
1879                                                        ],
1880                                                        [  'mysqld restarted',
1881                                                           'info',
1882                                                           'mysqld restarted',
1883                                                        ],
1884                                                     );
1885          14                                162      $matcher->add_patterns(\@known_patterns);
1886          14                                125      return;
1887                                                  }
1888                                                  
1889                                                  # Catches signals so we can exit gracefully.
1890                                                  sub sig_int {
1891  ***      0                    0                    my ( $signal ) = @_;
1892  ***      0      0                                  if ( $oktorun ) {
1893  ***      0                                            print STDERR "# Caught SIG$signal.\n";
1894  ***      0                                            $oktorun = 0;
1895                                                     }
1896                                                     else {
1897  ***      0                                            print STDERR "# Exiting on SIG$signal.\n";
1898  ***      0                                            exit 1;
1899                                                     }
1900                                                  }
1901                                                  
1902                                                  sub _d {
1903  ***      0                    0                    my ($package, undef, $line) = caller 0;
1904  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1905  ***      0                                              map { defined $_ ? $_ : 'undef' }
1906                                                          @_;
1907  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1908                                                  }
1909                                                  
1910                                                  # ############################################################################
1911                                                  # Run the program.
1912                                                  # ############################################################################
1913                                                  if ( !caller ) { exit main(@ARGV); }
1914                                                  
1915                                                  1; # Because this is a module as well as a script.
1916                                                  
1917                                                  # ############################################################################
1918                                                  # Documentation
1919                                                  # ############################################################################
1920                                                  
1921                                                  =pod
1922                                                  
1923                                                  =head1 NAME
1924                                                  
1925                                                  mk-error-log - Find new and different MySQL error log entries.
1926                                                  
1927                                                  =head1 SYNOPSIS
1928                                                  
1929                                                  Analyze and report on an error log:
1930                                                  
1931                                                    mk-error-log error.log
1932                                                  
1933                                                  =head1 RISKS
1934                                                  
1935                                                  The following section is included to inform users about the potential risks,
1936                                                  whether known or unknown, of using this tool.  The two main categories of risks
1937                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
1938                                                  tools) and those created by bugs.
1939                                                  
1940                                                  mk-error-log merely reads files given on the command line, and should be very
1941                                                  low-risk.
1942                                                  
1943                                                  At the time of this release, we know of no bugs that could cause serious harm to
1944                                                  users.
1945                                                  
1946                                                  The authoritative source for updated information is always the online issue
1947                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
1948                                                  see a list of such issues at the following URL:
1949                                                  L<http://www.maatkit.org/bugs/mk-error-log>.
1950                                                  
1951                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
1952                                                  
1953                                                  =head1 DESCRIPTION
1954                                                  
1955                                                  mk-error-log parses MySQL error logs, finding new and different entries, and
1956                                                  reports on the frequency and severity of each common entry.  Regex patterns are
1957                                                  used to detect and group common entries.  These patterns are auto-created by
1958                                                  mk-error-log when an entry does not match any known patterns.  mk-error-log
1959                                                  has a built-in list of known patterns; see L<"--[no]known-patterns">.  You
1960                                                  can also supply your own patterns with the L<"--load-patterns"> option.
1961                                                  
1962                                                  =head1 OUTPUT
1963                                                  
1964                                                  The output is a simple tabular list of error log entires:
1965                                                  
1966                                                    Count Level   Message                                           
1967                                                    ===== ======= ==================================================
1968                                                        5 info    mysqld started                                    
1969                                                        4 info    mysqld version info                               
1970                                                        3 info    InnoDB: Started                                   
1971                                                        2 info    mysqld ended                                      
1972                                                        1 unknown Number of processes running now: 0                
1973                                                        1 error   [ERROR] /usr/sbin/mysqld: unknown variable 'ssl-ke
1974                                                        1 error   [ERROR] Failed to initialize the master info struc
1975                                                  
1976                                                  The log entries (Message) are usually truncated; the full entrie is not
1977                                                  always shown.
1978                                                  
1979                                                  =head1 OPTIONS
1980                                                  
1981                                                  =over
1982                                                  
1983                                                  =item --ask-pass
1984                                                  
1985                                                  Prompt for a password when connecting to MySQL.
1986                                                  
1987                                                  =item --charset
1988                                                  
1989                                                  short form: -A; type: string
1990                                                  
1991                                                  Default character set.  If the value is utf8, sets Perl's binmode on
1992                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
1993                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
1994                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
1995                                                  connecting to MySQL.
1996                                                  
1997                                                  =item --config
1998                                                  
1999                                                  type: Array
2000                                                  
2001                                                  Read this comma-separated list of config files; if specified, this must be the
2002                                                  first option on the command line.
2003                                                  
2004                                                  =item --[no]continue-on-error
2005                                                  
2006                                                  default: yes
2007                                                  
2008                                                  Continue parsing even if there is an error.
2009                                                  
2010                                                  =item --defaults-file
2011                                                  
2012                                                  short form: -F; type: string
2013                                                  
2014                                                  Only read mysql options from the given file.  You must give an absolute
2015                                                  pathname.
2016                                                  
2017                                                  =item --help
2018                                                  
2019                                                  Show help and exit.
2020                                                  
2021                                                  =item --host
2022                                                  
2023                                                  short form: -h; type: string
2024                                                  
2025                                                  Connect to host.
2026                                                  
2027                                                  =item --[no]known-patterns
2028                                                  
2029                                                  default: yes
2030                                                  
2031                                                  Load known, built-in patterns.
2032                                                  
2033                                                  mk-error-log has a built-in list of known patterns.  This are normally loaded
2034                                                  by default, but if you don't want them to be used you can disable them from
2035                                                  being loaded by specifying C<--no-known-patterns>.
2036                                                  
2037                                                  =item --password
2038                                                  
2039                                                  short form: -p; type: string
2040                                                  
2041                                                  Password to use when connecting.
2042                                                  
2043                                                  =item --load-patterns
2044                                                  
2045                                                  type: string
2046                                                  
2047                                                  Load a list of known patterns from this file.
2048                                                  
2049                                                  Patterns in the file should be formatted like this:
2050                                                  
2051                                                    name1
2052                                                    level1
2053                                                    pattern1
2054                                                  
2055                                                    nameN
2056                                                    levelN
2057                                                    patternN
2058                                                  
2059                                                  Each pattern has three parts: name, level and regex pattern.
2060                                                  Patterns are separated by a blank line.  A pattern's name is what is printed
2061                                                  under the Message column in the L<"OUTPUT">.  Likewise, its level is printed
2062                                                  under the Level column.  The regex pattern is what mk-error-log uses to
2063                                                  match this pattern.  Any Perl regular expression should be valid.
2064                                                  
2065                                                  Here is a simple example:
2066                                                  
2067                                                    InnoDB: The first specified data file did not exist!
2068                                                    info
2069                                                    InnoDB: The first specified data file \S+
2070                                                  
2071                                                    InnoDB: Rolling back of trx complete
2072                                                    info
2073                                                    InnoDB: Rolling back of trx id .*?complete
2074                                                  
2075                                                  See also L<"--save-patterns">.
2076                                                  
2077                                                  =item --pid
2078                                                  
2079                                                  type: string
2080                                                  
2081                                                  Create the given PID file when daemonized.  The file contains the process
2082                                                  ID of the daemonized instance.  The PID file is removed when the
2083                                                  daemonized instance exits.  The program checks for the existence of the
2084                                                  PID file when starting; if it exists and the process with the matching PID
2085                                                  exists, the program exits.
2086                                                  
2087                                                  =item --port
2088                                                  
2089                                                  short form: -P; type: int
2090                                                  
2091                                                  Port number to use for connection.
2092                                                  
2093                                                  =item --save-patterns
2094                                                  
2095                                                  type: string
2096                                                  
2097                                                  After running save all new and old patterns to this file.
2098                                                  
2099                                                  This option causes mk-error-log to save every pattern it has to the file.
2100                                                  This file can be used for subsequent runs with L<"--load-patterns">.  The
2101                                                  patterns are saved in descending order of frequency, so the most frequent
2102                                                  patterns are at top.
2103                                                  
2104                                                  =item --set-vars
2105                                                  
2106                                                  type: string; default: wait_timeout=10000
2107                                                  
2108                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2109                                                  will be appended to SET and executed.
2110                                                  
2111                                                  =item --since
2112                                                  
2113                                                  type: string
2114                                                  
2115                                                  Parse only events newer than this value (parse events since this date).
2116                                                  
2117                                                  This option allows you to ignore events older than a certain value and parse
2118                                                  only those events which are more recent than the value.  The value can be
2119                                                  several types:
2120                                                  
2121                                                    * Simple time value N with optional suffix: N[shmd], where
2122                                                      s=seconds, h=hours, m=minutes, d=days (default s if no suffix
2123                                                      given); this is like saying "since N[shmd] ago"
2124                                                    * Full date with optional hours:minutes:seconds: YYYY-MM-DD [HH:MM::SS]
2125                                                    * Short, MySQL-style date: YYMMDD [HH:MM:SS]
2126                                                  
2127                                                  Events are assumed to be in chronological--older events at the beginning of
2128                                                  the log and newer events at the end of the log.  L<"--since"> is strict: it
2129                                                  ignores all events until one is found that is new enough.  Therefore, if
2130                                                  the events are not consistently timestamped, some may be ignored which
2131                                                  are actually new enough.
2132                                                  
2133                                                  See also L<"--until">.
2134                                                  
2135                                                  =item --socket
2136                                                  
2137                                                  short form: -S; type: string
2138                                                  
2139                                                  Socket file to use for connection.
2140                                                  
2141                                                  =item --until
2142                                                  
2143                                                  type: string
2144                                                  
2145                                                  Parse only events older than this value (parse events until this date).
2146                                                  
2147                                                  This option allows you to ignore events newer than a certain value and parse
2148                                                  only those events which are older than the value.  The value can be one of
2149                                                  the same types listed for L<"--since">.
2150                                                  
2151                                                  Unlike L<"--since">, L<"--until"> is not strict: all events are parsed until
2152                                                  one has a timestamp that is equal to or greater than L<"--until">.  Then
2153                                                  all subsequent events are ignored.
2154                                                  
2155                                                  =item --user
2156                                                  
2157                                                  short form: -u; type: string
2158                                                  
2159                                                  User for login if not current user.
2160                                                  
2161                                                  =item --version
2162                                                  
2163                                                  Show version and exit.
2164                                                  
2165                                                  =back
2166                                                  
2167                                                  =head1 DOWNLOADING
2168                                                  
2169                                                  You can download Maatkit from Google Code at
2170                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2171                                                  easily with a command like the following:
2172                                                  
2173                                                     wget http://www.maatkit.org/get/toolname
2174                                                     or
2175                                                     wget http://www.maatkit.org/trunk/toolname
2176                                                  
2177                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2178                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2179                                                  needed.  The first URL gets the latest released version of the tool, and the
2180                                                  second gets the latest trunk code from Subversion.
2181                                                  
2182                                                  =head1 ENVIRONMENT
2183                                                  
2184                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2185                                                  the Maatkit tools:
2186                                                  
2187                                                     MKDEBUG=1 mk-....
2188                                                  
2189                                                  =head1 SYSTEM REQUIREMENTS
2190                                                  
2191                                                  You need the following Perl modules: DBI and DBD::mysql.
2192                                                  
2193                                                  =head1 BUGS
2194                                                  
2195                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-error-log>.
2196                                                  
2197                                                  Please use Google Code Issues and Groups to report bugs or request support:
2198                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2199                                                  discuss Maatkit.
2200                                                  
2201                                                  Please include the complete command-line used to reproduce the problem you are
2202                                                  seeing, the version of all MySQL servers involved, the complete output of the
2203                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2204                                                  running with the C<MKDEBUG=1> environment variable.
2205                                                  
2206                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2207                                                  
2208                                                  This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
2209                                                  Feedback and improvements are welcome.
2210                                                  
2211                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2212                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2213                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2214                                                  
2215                                                  This program is free software; you can redistribute it and/or modify it under
2216                                                  the terms of the GNU General Public License as published by the Free Software
2217                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2218                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2219                                                  licenses.
2220                                                  
2221                                                  You should have received a copy of the GNU General Public License along with
2222                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2223                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2224                                                  
2225                                                  =head1 AUTHOR
2226                                                  
2227                                                  Daniel Nichter
2228                                                  
2229                                                  =head1 ABOUT MAATKIT
2230                                                  
2231                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2232                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2233                                                  code contributors.  Both are employed by Percona.  Financial support for
2234                                                  Maatkit development is primarily provided by Percona and its clients. 
2235                                                  
2236                                                  =head1 VERSION
2237                                                  
2238                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5577 $.
2239                                                  
2240                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
55    ***     50      0     14   unless $args{$arg}
61    ***     50     14      0   exists $args{'strict'} ? :
104   ***     50      0     14   unless open my $fh, '<', $file
124          100   3640     14   unless $para =~ /^=head1 OPTIONS/
129   ***     50     14      0   if $para =~ /^=over/
137   ***     50      0     14   unless $para
140          100    266     14   if (my($option) = $para =~ /^=item --(.*)/)
147          100    224     42   if ($para =~ /: /) { }
151   ***     50      0    336   unless $attributes{$attrib}
155          100     98    126   if ($attribs{'short form'})
171   ***     50      0    266   if $para =~ /^=item/
173          100     28    238   if (my($base_option) = $option =~ /^\[no\](.*)/)
178          100     98    168   $attribs{'short form'} ? :
             100     28    238   $attribs{'negatable'} ? :
      ***     50      0    266   $attribs{'cumulative'} ? :
             100    196     70   $attribs{'type'} ? :
             100     42    224   $attribs{'default'} ? :
      ***     50      0    266   $attribs{'group'} ? :
190   ***     50      0    518   unless $para
193          100     14    504   if ($para =~ /^=head1/)
197          100    266    238   if $para =~ /^=item --/
201   ***     50      0     14   unless @specs
212   ***     50    266      0   if (ref $opt) { }
217   ***     50      0    266   if (not $long)
222   ***     50      0    266   if exists $$self{'opts'}{$long}
225   ***     50      0    266   if (length $long == 1)
230          100     98    168   if ($short) { }
231   ***     50      0     98   if exists $$self{'short_opts'}{$short}
240          100     28    238   $$opt{'spec'} =~ /!/ ? :
241   ***     50      0    266   $$opt{'spec'} =~ /\+/ ? :
242   ***     50      0    266   $$opt{'desc'} =~ /required/ ? :
254   ***     50      0    266   if ($type and $type eq 'd' and not $$self{'dp'})
259          100     14    252   if $type and $type =~ /[HhAadzm]/
261          100     42    224   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
262   ***     50     42      0   defined $def ? :
266          100     14    252   if ($long eq 'config')
270   ***     50      0    266   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
283   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
288   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
293   ***      0      0      0   if ($opt =~ /default to/)
298   ***      0      0      0   if ($opt =~ /restricted to option groups/)
308   ***      0      0      0   unless $rule_ok
325   ***      0      0      0   unless exists $$self{'opts'}{$long}
349   ***      0      0      0   unless exists $$self{'opts'}{$long}
369   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50      5      0   exists $$self{'opts'}{$opt} ? :
374   ***     50      0      5   if ($$opt{'is_cumulative'}) { }
389   ***     50      0    210   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     56    210   exists $$self{'defaults'}{$long} ? :
398   ***     50      0     14   if (@ARGV and $ARGV[0] eq '--config')
402   ***     50     14      0   if ($self->has('config'))
408   ***     50     56      0   if ($EVAL_ERROR)
409   ***     50      0     56   $self->got('config') ? :
424   ***     50      0     14   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
427   ***     50      0     14   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
428   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
434   ***     50      0     14   if (@ARGV and $$self{'strict'})
440   ***      0      0      0   if (@set > 1)
451   ***      0      0      0   if (@set == 0)
461          100      5    261   if ($$opt{'got'}) { }
      ***     50      0    261   elsif ($$opt{'is_required'}) { }
462   ***     50      0      5   if (exists $$self{'disables'}{$long})
469   ***     50      0      5   if (exists $$self{'allowed_groups'}{$long})
481   ***      0      0      0   if $restricted_opt eq $long
482   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
487   ***      0      0      0   if (@restricted_opts)
489   ***      0      0      0   if (@restricted_opts == 1) { }
518          100     70    196   unless $opt and $$opt{'type'}
521   ***     50      0    196   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    196   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    196   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0    196   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     14    182   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
524   ***      0      0      0   if (not $suffix)
530   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
531   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
546   ***      0      0      0   if ($from_key)
557   ***      0      0      0   if (defined $num) { }
558   ***      0      0      0   if ($factor)
585   ***     50      0     89   length $opt == 1 ? :
586   ***     50      0     89   unless $long and exists $$self{'opts'}{$long}
593   ***     50      0     56   length $opt == 1 ? :
594   ***     50      0     56   unless $long and exists $$self{'opts'}{$long}
601   ***     50      0     14   length $opt == 1 ? :
602   ***     50     14      0   defined $long ? :
607   ***      0      0      0   length $opt == 1 ? :
608   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
635   ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
643   ***     50      0     14   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0     14   elsif (scalar @{$$self{'errors'};}) { }
644   ***      0      0      0   unless print $self->print_usage
648   ***      0      0      0   unless print $self->print_errors
657   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
666   ***      0      0      0   unless $$self{'got_opts'}
669   ***      0      0      0   $$_{'is_negatable'} ? :
673   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
689   ***      0      0      0   $group eq 'default' ? :
695   ***      0      0      0   $$opt{'is_negatable'} ? :
698   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
707   ***      0      0      0   if ($short) { }
716   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
720   ***      0      0      0   if ($$self{'dp'})
728   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
740   ***      0      0      0   if ref $_[0] eq 'OptionParser'
743   ***      0      0      0   unless print $prompt
751   ***      0      0      0   unless print "\n"
754   ***      0      0      0   if ($EVAL_ERROR)
776   ***     50     56      0   unless open my $fh, '<', $filename
784   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
787   ***      0      0      0   if ($line eq '--')
792   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
810   ***      0      0      0   unless open my $fh, '<', $file
814   ***      0      0      0   unless $para =~ /^=pod$/m
818   ***      0      0      0   unless $para =~ /$regex/
823   ***      0      0      0   unless close $fh
837   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
852   ***      0      0      0   defined $_ ? :
885   ***      0      0      0   unless $args{$arg}
907   ***     50      0     42   unless defined $$col{'name'}
908   ***     50      0     42   if ($$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'})
923   ***     50      0    108   unless $n_cols == $n_vals
931   ***     50      0    324   if ($$col{'fixed_width'} and $width > $$col{'fixed_width'})
932   ***      0      0      0   if ($$col{'truncate'}) { }
954   ***     50      0     14   $$self{'long_last_column'} ? :
961          100     14     28   $$col{'right_justify'} ? :
967   ***     50      0     14   if ($$self{'long_last_column'})
973   ***     50      0     14   if $$self{'title'}
978   ***     50     14      0   if ($$self{'underline_header'})
986   ***     50      0     14   if ($$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'})
1004  ***      0      0      0   defined $_ ? :
1053  ***     50      0    269   unless $args{$arg}
1063         100     44    255   if $line =~ /^\s*$/
1068         100    221     34   if (my($ts) = $line =~ /^$ts/o)
1075         100    114    141   if (($level) = $line =~ /\[((?:ERROR|Warning|Note))\]/) { }
1076         100     25     56   $level =~ /warning/i ? :
             100     33     81   $level =~ /error/i ? :
1086         100      6    249   if (my($level) = $line =~ /InnoDB: Error/)
1096         100     60    195   if ($line =~ /$ml/o) { }
             100      1    194   elsif ($line =~ /\bQuery: '/) { }
1103         100    333   3065   if $next_line eq ''
1118         100      1      2   if $next_line =~ /, Error_code:/
1132  ***     50     14      0   if $args{'oktorun'}
1138  ***      0      0      0   defined $_ ? :
1180  ***     50      0    348   unless $p and scalar @$p
1199  ***      0      0      0   if (not $name && $level && $regex)
1203  ***      0      0      0   if ($seen{$name}++)
1241  ***     50      0    146   unless $args{$arg}
1245  ***     50      0    146   unless $err
1247  ***     50      0    146   if ($$self{'QueryRewriter'} and my($query) = $err =~ /Statement: (.+)$/)
1258         100     78   2353   if ($err =~ /$$compiled[$i]/)
1264         100     78     68   if (defined $pno) { }
1269  ***     50      0     78   if (not $$event{'Level'} and $$self{'levels'}[$pno])
1300  ***      0      0      0   defined $_ ? :
1350  ***      0      0      0   defined $args{'p_ms'} ? :
1351  ***      0      0      0   defined $args{'p_s'} ? :
1354  ***      0      0      0   if $t < 0
1358  ***      0      0      0   if $t =~ /e/
1364  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1386  ***      0      0      0   $p ? :
1393  ***      0      0      0   unless $secs
1396  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1401  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1420  ***      0      0      0   defined $args{'p'} ? :
1421  ***      0      0      0   defined $args{'d'} ? :
1428  ***      0      0      0   $num =~ /\./ || $n ? :
1439  ***      0      0      0   $gmt ? :
1445  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
1457  ***     50    164      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1460  ***     50      0    164   defined $f ? :
      ***     50      0    164   defined $f ? :
1472  ***     50    165      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
1473  ***     50      0    165   $gmt ? :
1476  ***     50      0    165   if (defined $us)
1497  ***     50      0    165   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
             100    164      1   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***     50      1      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
1498  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1508         100      2    162   unless $hms
1513  ***     50      1      0   unless $hms
1518  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1535  ***      0      0      0   defined $_ ? :
1596  ***     50      0     14   if (my $file = $o->get('load-patterns'))
1598  ***      0      0      0   unless open my $fh, '<', $file
1601  ***     50     14      0   if $o->get('known-patterns')
1618         100      3     11   if ($o->get('since'))
1620  ***     50      0      3   unless $since
1625         100      4    110   if ($past_since)
1629         100     95     15   if ($$event{'ts'})
1631         100      3     92   if (($ts || 0) >= $since) { }
1643         100      2     12   if ($o->get('until'))
1645  ***     50      0      2   unless $until
1650         100      1     75   if ($at_until)
1654         100     65     10   if ($$event{'ts'})
1656         100      1     64   if (($ts || 0) >= $until) { }
1673  ***     50      0    146   unless $args{'event'}
1685  ***     50      0     14   if (@ARGV == 0)
1691         100     28    255   if (not $fh)
1693         100     14     14   if (not $file)
1698  ***     50      0     14   if ($file eq '-') { }
1703  ***     50      0     14   if (not open $fh, '<', $file)
1726  ***     50      0    605   unless $oktorun
1732         100    123    482   unless $event
1734         100     14    255   if (not $more_events)
1736  ***     50     14      0   if $fh
1740  ***     50      0    269   if ($EVAL_ERROR)
1748  ***      0      0      0   unless $o->get('continue-on-error')
1766  ***     50      0     14   if (my $file = $o->get('save-patterns'))
1767  ***      0      0      0   unless open $fh, '>', $file
1778  ***     50      0    108   if ($fh)
1785  ***     50      0     14   if $fh
1892  ***      0      0      0   if ($oktorun) { }
1904  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
1180  ***     50      0    348   $p and scalar @$p

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
254   ***     66     70    196      0   $type and $type eq 'd'
      ***     33    266      0      0   $type and $type eq 'd' and not $$self{'dp'}
259          100     70    182     14   $type and $type =~ /[HhAadzm]/
398   ***     33      0     14      0   @ARGV and $ARGV[0] eq '--config'
427   ***     33      0     14      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
434   ***     33      0     14      0   @ARGV and $$self{'strict'}
518   ***     66      0     70    196   $opt and $$opt{'type'}
521   ***     66    163     33      0   $val and $$opt{'type'} eq 'm'
      ***     66    163     33      0   $val and $$opt{'type'} eq 'd'
      ***     66    163     33      0   $val and $$opt{'type'} eq 'z'
      ***     66    163     33      0   defined $val and $$opt{'type'} eq 'h'
      ***     66    163     19      0   defined $val and $$opt{'type'} eq 'a'
586   ***     33      0      0     89   $long and exists $$self{'opts'}{$long}
594   ***     33      0      0     56   $long and exists $$self{'opts'}{$long}
608   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
698   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
792   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
908   ***     33     42      0      0   $$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'}
931   ***     66    216    108      0   $$col{'fixed_width'} and $width > $$col{'fixed_width'}
986   ***     33      0     14      0   $$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'}
1100         100      2     58   3398   defined($next_line = <$fh>) and not $next_line =~ /^$ts/o
1114  ***     66      1      0      3   not $last_line and defined($next_line = <$fh>)
1199  ***      0      0      0      0   $name && $level
      ***      0      0      0      0   $name && $level && $regex
1247  ***     33    146      0      0   $$self{'QueryRewriter'} and my($query) = $err =~ /Statement: (.+)$/
1269  ***     33     78      0      0   not $$event{'Level'} and $$self{'levels'}[$pno]
1364  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1424  ***      0      0      0      0   $num >= $d and $n < @units - 1
1518  ***      0      0      0      0   $callback and ref $callback eq 'CODE'

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
39    ***     50      0      2   $ENV{'MKDEBUG'} || 0
58    ***     50     14      0   $program_name ||= $PROGRAM_NAME
59    ***     50     14      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
61    ***     50     14      0   $args{'prompt'} || '<options>'
      ***     50      0     14   $args{'dp'} || undef
103   ***     50      0     14   $file ||= '/home/daniel/dev/maatkit/mk-error-log/mk-error-log'
244   ***     50    266      0   $$opt{'group'} ||= 'default'
526   ***      0      0      0   $s || 's'
535   ***      0      0      0   $prefix || ''
563   ***      0      0      0   $pre || ''
570   ***      0      0      0   $val || ''
573   ***     50     14      0   $val || ''
631   ***      0      0      0   $$self{'description'} || ''
700   ***      0      0      0   $s ||= 's'
726   ***      0      0      0   $$opt{'type'} || ''
874   ***     50      0      2   $ENV{'MKDEBUG'} || 0
952   ***     50      0     14   $$self{'line_prefix'} || ''
1030  ***     50      0      2   $ENV{'MKDEBUG'} || 0
1163  ***     50      0      2   $ENV{'MKDEBUG'} || 0
1325  ***     50      0      2   $ENV{'MKDEBUG'} || 0
1385  ***      0      0      0   $args{'p'} || 0
1387  ***      0      0      0   $of ||= 1
1392  ***      0      0      0   $secs ||= 0
1565  ***     50      0      2   $ENV{'MKDEBUG'} || 0
1631  ***     50     95      0   $ts || 0
1656  ***     50     65      0   $ts || 0
1775  ***     50    108      0   $levels[$pno] || ''
      ***     50    108      0   $names[$pno] || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
59    ***     33     14      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     14      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
521   ***     33      0      0    196   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66     14      0    182   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1062         100     58    241     14   defined($line = shift @$pending) or defined($line = <$fh>)
1396  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1428  ***      0      0      0      0   $num =~ /\./ || $n


Covered Subroutines
-------------------

Subroutine          Count Location                                               
------------------- ----- -------------------------------------------------------
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1021
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1022
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1023
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1025
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1030
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1155
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1156
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1157
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1158
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1163
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1319
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1320
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1321
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1322
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1323
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1325
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1557
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1558
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1565
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1567
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:20  
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:21  
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:32  
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:33  
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:35  
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:36  
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:37  
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:39  
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:869 
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:870 
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:871 
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:872 
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:874 
BEGIN                   2 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:876 
__ANON__              269 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1611
__ANON__              114 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1622
__ANON__               76 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1647
__ANON__              146 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1671
__ANON__               14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1724
__ANON__                5 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:422 
_parse_specs           14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:208 
_pod_to_specs          14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:102 
_read_config_file      56 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:775 
_set_option             5 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:368 
_validate_type        266 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:517 
add_line              108 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:919 
add_patterns           82 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1178
any_unix_timestamp    165 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1495
fingerprint            68 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1288
get                    89 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:584 
get_defaults_files     14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:97  
get_opts               14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:385 
get_report             14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:950 
get_specs              14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:90  
got                    56 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:592 
has                    14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:600 
levels                 14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1233
load_known_patterns    14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1801
main                   14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1572
match                 146 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1238
names                  14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1228
new                    14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1041
new                    14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1166
new                    14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:53  
new                    14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:882 
parse_event           269 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1050
parse_timestamp       164 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1456
set_columns            14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:904 
unix_timestamp        165 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1471
usage_or_errors        14 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:642 

Uncovered Subroutines
---------------------

Subroutine          Count Location                                               
------------------- ----- -------------------------------------------------------
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1003
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1137
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1299
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1534
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1903
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:851 
_get_participants       0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:322 
clone                   0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:828 
descr                   0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:630 
errors                  0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:620 
get_defaults            0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:358 
get_groups              0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:363 
load_patterns_file      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1193
make_checksum           0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1527
micro_t                 0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1349
opts                    0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:334 
patterns                0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1223
percentage_of           0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1384
print_errors            0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:655 
print_usage             0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:665 
prompt                  0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:625 
prompt_noecho           0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:740 
read_para_after         0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:809 
reset_patterns          0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1213
save_error              0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:615 
secs_to_time            0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1391
set                     0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:606 
set_defaults            0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:346 
set_title               0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:898 
short_opts              0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:340 
shorten                 0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1419
sig_int                 0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1891
ts                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1438


