---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...mk-error-log/mk-error-log   59.8   42.7   38.7   69.4    n/a  100.0   53.7
Total                          59.8   42.7   38.7   69.4    n/a  100.0   53.7
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Feb 17 20:58:28 2010
Finish:       Wed Feb 17 20:58:28 2010

Run:          ./001_check_resume.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Feb 17 20:58:29 2010
Finish:       Wed Feb 17 20:58:29 2010

Run:          ./101_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Feb 17 20:58:32 2010
Finish:       Wed Feb 17 20:58:32 2010

Run:          ./102_since_until.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Feb 17 20:58:34 2010
Finish:       Wed Feb 17 20:58:35 2010

Run:          ./103_resume.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Feb 17 20:58:37 2010
Finish:       Wed Feb 17 20:58:37 2010

/home/daniel/dev/maatkit/mk-error-log/mk-error-log

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             4                    4            31   use strict;
               4                                 12   
               4                                 27   
21             4                    4            26   use warnings FATAL => 'all';
               4                                 17   
               4                                 24   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5796 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # OptionParser package 5568
29                                                    # ###########################################################################
30                                                    package OptionParser;
31                                                    
32             4                    4            29   use strict;
               4                                 10   
               4                                 18   
33             4                    4            22   use warnings FATAL => 'all';
               4                                 11   
               4                                 27   
34                                                    
35             4                    4            38   use Getopt::Long;
               4                                 16   
               4                                 28   
36             4                    4            29   use List::Util qw(max);
               4                                  9   
               4                                 53   
37             4                    4            26   use English qw(-no_match_vars);
               4                                  9   
               4                                 29   
38                                                    
39    ***      4            50      4            29   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 16   
               4                                 84   
40                                                    
41                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
42                                                    
43                                                    my %attributes = (
44                                                       'type'       => 1,
45                                                       'short form' => 1,
46                                                       'group'      => 1,
47                                                       'default'    => 1,
48                                                       'cumulative' => 1,
49                                                       'negatable'  => 1,
50                                                    );
51                                                    
52                                                    sub new {
53            19                   19           404      my ( $class, %args ) = @_;
54            19                                185      foreach my $arg ( qw(description) ) {
55    ***     19     50                         250         die "I need a $arg argument" unless $args{$arg};
56                                                       }
57            19                                410      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
58    ***     19            33                  190      $program_name ||= $PROGRAM_NAME;
59    ***     19            33                  352      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
60                                                    
61    ***     19     50     50                 1543      my $self = {
      ***                   50                        
62                                                          description    => $args{description},
63                                                          prompt         => $args{prompt} || '<options>',
64                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
65                                                          dp             => $args{dp}     || undef,
66                                                          program_name   => $program_name,
67                                                          opts           => {},
68                                                          got_opts       => 0,
69                                                          short_opts     => {},
70                                                          defaults       => {},
71                                                          groups         => {},
72                                                          allowed_groups => {},
73                                                          errors         => [],
74                                                          rules          => [],  # desc of rules for --help
75                                                          mutex          => [],  # rule: opts are mutually exclusive
76                                                          atleast1       => [],  # rule: at least one opt is required
77                                                          disables       => {},  # rule: opt disables other opts 
78                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
79                                                          default_files  => [
80                                                             "/etc/maatkit/maatkit.conf",
81                                                             "/etc/maatkit/$program_name.conf",
82                                                             "$home/.maatkit.conf",
83                                                             "$home/.$program_name.conf",
84                                                          ],
85                                                       };
86            19                                216      return bless $self, $class;
87                                                    }
88                                                    
89                                                    sub get_specs {
90            19                   19            94      my ( $self, $file ) = @_;
91            19                                168      my @specs = $self->_pod_to_specs($file);
92            19                                367      $self->_parse_specs(@specs);
93            19                                 69      return;
94                                                    }
95                                                    
96                                                    sub get_defaults_files {
97            19                   19            80      my ( $self ) = @_;
98            19                                 55      return @{$self->{default_files}};
              19                                184   
99                                                    }
100                                                   
101                                                   sub _pod_to_specs {
102           19                   19            80      my ( $self, $file ) = @_;
103   ***     19            50                  115      $file ||= __FILE__;
104   ***     19     50                         694      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
105                                                   
106           19                                502      my %types = (
107                                                         string => 's', # standard Getopt type
108                                                         'int'  => 'i', # standard Getopt type
109                                                         float  => 'f', # standard Getopt type
110                                                         Hash   => 'H', # hash, formed from a comma-separated list
111                                                         hash   => 'h', # hash as above, but only if a value is given
112                                                         Array  => 'A', # array, similar to Hash
113                                                         array  => 'a', # array, similar to hash
114                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
115                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
116                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
117                                                      );
118           19                                 70      my @specs = ();
119           19                                 57      my @rules = ();
120           19                                 53      my $para;
121                                                   
122           19                                161      local $INPUT_RECORD_SEPARATOR = '';
123           19                                396      while ( $para = <$fh> ) {
124         5282    100                       35246         next unless $para =~ m/^=head1 OPTIONS/;
125           19                                 70         last;
126                                                      }
127                                                   
128           19                                113      while ( $para = <$fh> ) {
129   ***     19     50                         160         last if $para =~ m/^=over/;
130   ***      0                                  0         chomp $para;
131   ***      0                                  0         $para =~ s/\s+/ /g;
132   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
133   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
134   ***      0                                  0         push @rules, $para;
135                                                      }
136                                                   
137   ***     19     50                          82      die 'POD has no OPTIONS section' unless $para;
138                                                   
139           19                                 63      do {
140          399    100                        2686         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
141          380                               1044            chomp $para;
142          380                                823            MKDEBUG && _d($para);
143          380                                872            my %attribs;
144                                                   
145          380                               1338            $para = <$fh>; # read next paragraph, possibly attributes
146                                                   
147          380    100                        1464            if ( $para =~ m/: / ) { # attributes
148          323                               1588               $para =~ s/\s+\Z//g;
149          475                               2451               %attribs = map {
150          323                               1543                     my ( $attrib, $val) = split(/: /, $_);
151   ***    475     50                        2130                     die "Unrecognized attribute for --$option: $attrib"
152                                                                        unless $attributes{$attrib};
153          475                               2624                     ($attrib, $val);
154                                                                  } split(/; /, $para);
155          323    100                        1562               if ( $attribs{'short form'} ) {
156          133                                644                  $attribs{'short form'} =~ s/-//;
157                                                               }
158          323                               1295               $para = <$fh>; # read next paragraph, probably short help desc
159                                                            }
160                                                            else {
161           57                                144               MKDEBUG && _d('Option has no attributes');
162                                                            }
163                                                   
164          380                               2607            $para =~ s/\s+\Z//g;
165          380                               3066            $para =~ s/\s+/ /g;
166          380                               1446            $para =~ s/$POD_link_re/$1/go;
167                                                   
168          380                               1482            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
169          380                                903            MKDEBUG && _d('Short help:', $para);
170                                                   
171   ***    380     50                        1534            die "No description after option spec $option" if $para =~ m/^=item/;
172                                                   
173          380    100                        1843            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
174           38                                124               $option = $base_option;
175           38                                163               $attribs{'negatable'} = 1;
176                                                            }
177                                                   
178          380    100                        6749            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
179                                                               spec  => $option
180                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
181                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
182                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
183                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
184                                                               desc  => $para
185                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
186                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
187                                                            };
188                                                         }
189          399                               2413         while ( $para = <$fh> ) {
190   ***    836     50                        2860            last unless $para;
191                                                   
192                                                   
193          836    100                        3185            if ( $para =~ m/^=head1/ ) {
194           19                                 58               $para = undef; # Can't 'last' out of a do {} block.
195           19                                103               last;
196                                                            }
197          817    100                        5141            last if $para =~ m/^=item --/;
198                                                         }
199                                                      } while ( $para );
200                                                   
201   ***     19     50                          78      die 'No valid specs in POD OPTIONS' unless @specs;
202                                                   
203           19                                192      close $fh;
204           19                                 64      return @specs, @rules;
205                                                   }
206                                                   
207                                                   sub _parse_specs {
208           19                   19           126      my ( $self, @specs ) = @_;
209           19                                 71      my %disables; # special rule that requires deferred checking
210                                                   
211           19                                107      foreach my $opt ( @specs ) {
212   ***    380     50                        1373         if ( ref $opt ) { # It's an option spec, not a rule.
213                                                            MKDEBUG && _d('Parsing opt spec:',
214          380                                844               map { ($_, '=>', $opt->{$_}) } keys %$opt);
215                                                   
216          380                               2871            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
217   ***    380     50                        1559            if ( !$long ) {
218   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
219                                                            }
220          380                               1359            $opt->{long} = $long;
221                                                   
222   ***    380     50                        1713            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
223          380                               1720            $self->{opts}->{$long} = $opt;
224                                                   
225   ***    380     50                        1519            if ( length $long == 1 ) {
226   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
227   ***      0                                  0               $self->{short_opts}->{$long} = $long;
228                                                            }
229                                                   
230          380    100                        1270            if ( $short ) {
231   ***    133     50                         620               die "Duplicate short option -$short"
232                                                                  if exists $self->{short_opts}->{$short};
233          133                                616               $self->{short_opts}->{$short} = $long;
234          133                                484               $opt->{short} = $short;
235                                                            }
236                                                            else {
237          247                                839               $opt->{short} = undef;
238                                                            }
239                                                   
240          380    100                        1995            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
241   ***    380     50                        1835            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
242   ***    380     50                        2144            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
243                                                   
244   ***    380            50                 1568            $opt->{group} ||= 'default';
245          380                               1884            $self->{groups}->{ $opt->{group} }->{$long} = 1;
246                                                   
247          380                               1258            $opt->{value} = undef;
248          380                               1318            $opt->{got}   = 0;
249                                                   
250          380                               2074            my ( $type ) = $opt->{spec} =~ m/=(.)/;
251          380                               1431            $opt->{type} = $type;
252          380                                813            MKDEBUG && _d($long, 'type:', $type);
253                                                   
254   ***    380     50     66                 3282            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
255   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
256                                                                  . "was given when this OptionParser object was created";
257                                                            }
258                                                   
259          380    100    100                 2806            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
260                                                   
261          380    100                        2268            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
262   ***     57     50                         317               $self->{defaults}->{$long} = defined $def ? $def : 1;
263           57                                136               MKDEBUG && _d($long, 'default:', $def);
264                                                            }
265                                                   
266          380    100                        1469            if ( $long eq 'config' ) {
267           19                                109               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
268                                                            }
269                                                   
270   ***    380     50                        1900            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
271   ***      0                                  0               $disables{$long} = $dis;
272   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
273                                                            }
274                                                   
275          380                               1804            $self->{opts}->{$long} = $opt;
276                                                         }
277                                                         else { # It's an option rule, not a spec.
278   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
279   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
280   ***      0                                  0            my @participants = $self->_get_participants($opt);
281   ***      0                                  0            my $rule_ok = 0;
282                                                   
283   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
284   ***      0                                  0               $rule_ok = 1;
285   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
286   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
287                                                            }
288   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
289   ***      0                                  0               $rule_ok = 1;
290   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
291   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
292                                                            }
293   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
294   ***      0                                  0               $rule_ok = 1;
295   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
296   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
297                                                            }
298   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
299   ***      0                                  0               $rule_ok = 1;
300   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
301   ***      0                                  0               my @groups = split(',', $groups);
302   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
303   ***      0                                  0                  s/\s+//;
304   ***      0                                  0                  $_ => 1;
305                                                               } @groups;
306                                                            }
307                                                   
308   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
309                                                         }
310                                                      }
311                                                   
312           19                                139      foreach my $long ( keys %disables ) {
313   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
314   ***      0                                  0         $self->{disables}->{$long} = \@participants;
315   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
316                                                      }
317                                                   
318           19                                 90      return; 
319                                                   }
320                                                   
321                                                   sub _get_participants {
322   ***      0                    0             0      my ( $self, $str ) = @_;
323   ***      0                                  0      my @participants;
324   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
325   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
326                                                            unless exists $self->{opts}->{$long};
327   ***      0                                  0         push @participants, $long;
328                                                      }
329   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
330   ***      0                                  0      return @participants;
331                                                   }
332                                                   
333                                                   sub opts {
334   ***      0                    0             0      my ( $self ) = @_;
335   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
336   ***      0                                  0      return %opts;
337                                                   }
338                                                   
339                                                   sub short_opts {
340   ***      0                    0             0      my ( $self ) = @_;
341   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
342   ***      0                                  0      return %short_opts;
343                                                   }
344                                                   
345                                                   sub set_defaults {
346   ***      0                    0             0      my ( $self, %defaults ) = @_;
347   ***      0                                  0      $self->{defaults} = {};
348   ***      0                                  0      foreach my $long ( keys %defaults ) {
349   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
350                                                            unless exists $self->{opts}->{$long};
351   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
352   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
353                                                      }
354   ***      0                                  0      return;
355                                                   }
356                                                   
357                                                   sub get_defaults {
358   ***      0                    0             0      my ( $self ) = @_;
359   ***      0                                  0      return $self->{defaults};
360                                                   }
361                                                   
362                                                   sub get_groups {
363   ***      0                    0             0      my ( $self ) = @_;
364   ***      0                                  0      return $self->{groups};
365                                                   }
366                                                   
367                                                   sub _set_option {
368           10                   10            55      my ( $self, $opt, $val ) = @_;
369   ***     10      0                          25      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
370                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
371                                                               : die "Getopt::Long gave a nonexistent option: $opt";
372                                                   
373           10                                 22      $opt = $self->{opts}->{$long};
374   ***     10     50                          70      if ( $opt->{is_cumulative} ) {
375   ***      0                                  0         $opt->{value}++;
376                                                      }
377                                                      else {
378           10                                 41         $opt->{value} = $val;
379                                                      }
380           10                                 35      $opt->{got} = 1;
381           10                                 38      MKDEBUG && _d('Got option', $long, '=', $val);
382                                                   }
383                                                   
384                                                   sub get_opts {
385           19                   19            85      my ( $self ) = @_; 
386                                                   
387           19                                 61      foreach my $long ( keys %{$self->{opts}} ) {
              19                                213   
388          380                               1509         $self->{opts}->{$long}->{got} = 0;
389   ***    380     50                        3094         $self->{opts}->{$long}->{value}
                    100                               
390                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
391                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
392                                                            : undef;
393                                                      }
394           19                                 97      $self->{got_opts} = 0;
395                                                   
396           19                                 83      $self->{errors} = [];
397                                                   
398   ***     19     50     33                  225      if ( @ARGV && $ARGV[0] eq "--config" ) {
399   ***      0                                  0         shift @ARGV;
400   ***      0                                  0         $self->_set_option('config', shift @ARGV);
401                                                      }
402   ***     19     50                         170      if ( $self->has('config') ) {
403           19                                 50         my @extra_args;
404           19                                162         foreach my $filename ( split(',', $self->get('config')) ) {
405           76                                212            eval {
406           76                                388               push @extra_args, $self->_read_config_file($filename);
407                                                            };
408   ***     76     50                         393            if ( $EVAL_ERROR ) {
409   ***     76     50                         342               if ( $self->got('config') ) {
410   ***      0                                  0                  die $EVAL_ERROR;
411                                                               }
412                                                               elsif ( MKDEBUG ) {
413                                                                  _d($EVAL_ERROR);
414                                                               }
415                                                            }
416                                                         }
417           19                                142         unshift @ARGV, @extra_args;
418                                                      }
419                                                   
420           19                                231      Getopt::Long::Configure('no_ignore_case', 'bundling');
421                                                      GetOptions(
422          361                   10          2623         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              10                                 78   
             380                               1477   
423           19                                121         grep   { $_->{long} ne 'config' } # --config is handled specially above.
424   ***     19     50                          71         values %{$self->{opts}}
425                                                      ) or $self->save_error('Error parsing options');
426                                                   
427   ***     19     50     33                  729      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
428   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
429                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
430                                                               or die "Cannot print: $OS_ERROR";
431   ***      0                                  0         exit 0;
432                                                      }
433                                                   
434   ***     19     50     33                  200      if ( @ARGV && $self->{strict} ) {
435   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
436                                                      }
437                                                   
438           19                                 55      foreach my $mutex ( @{$self->{mutex}} ) {
              19                                118   
439   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
440   ***      0      0                           0         if ( @set > 1 ) {
441   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
442   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
443                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
444                                                                    . ' are mutually exclusive.';
445   ***      0                                  0            $self->save_error($err);
446                                                         }
447                                                      }
448                                                   
449           19                                 71      foreach my $required ( @{$self->{atleast1}} ) {
              19                                118   
450   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
451   ***      0      0                           0         if ( @set == 0 ) {
452   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
453   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
454                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
455   ***      0                                  0            $self->save_error("Specify at least one of $err");
456                                                         }
457                                                      }
458                                                   
459           19                                 60      foreach my $long ( keys %{$self->{opts}} ) {
              19                                157   
460          380                               1392         my $opt = $self->{opts}->{$long};
461          380    100                        2038         if ( $opt->{got} ) {
      ***            50                               
462   ***     10     50                          56            if ( exists $self->{disables}->{$long} ) {
463   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
464   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
465   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
466                                                                  'because', $long,'disables them');
467                                                            }
468                                                   
469   ***     10     50                          53            if ( exists $self->{allowed_groups}->{$long} ) {
470                                                   
471   ***      0                                  0               my @restricted_groups = grep {
472   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
473   ***      0                                  0               } keys %{$self->{groups}};
474                                                   
475   ***      0                                  0               my @restricted_opts;
476   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
477   ***      0                                  0                  RESTRICTED_OPT:
478   ***      0                                  0                  foreach my $restricted_opt (
479                                                                     keys %{$self->{groups}->{$restricted_group}} )
480                                                                  {
481   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
482   ***      0      0                           0                     push @restricted_opts, $restricted_opt
483                                                                        if $self->{opts}->{$restricted_opt}->{got};
484                                                                  }
485                                                               }
486                                                   
487   ***      0      0                           0               if ( @restricted_opts ) {
488   ***      0                                  0                  my $err;
489   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
490   ***      0                                  0                     $err = "--$restricted_opts[0]";
491                                                                  }
492                                                                  else {
493   ***      0                                  0                     $err = join(', ',
494   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
495   ***      0                                  0                               grep { $_ } 
496                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
497                                                                            )
498                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
499                                                                  }
500   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
501                                                               }
502                                                            }
503                                                   
504                                                         }
505                                                         elsif ( $opt->{is_required} ) { 
506   ***      0                                  0            $self->save_error("Required option --$long must be specified");
507                                                         }
508                                                   
509          380                               1379         $self->_validate_type($opt);
510                                                      }
511                                                   
512           19                                102      $self->{got_opts} = 1;
513           19                                 59      return;
514                                                   }
515                                                   
516                                                   sub _validate_type {
517          380                  380          1318      my ( $self, $opt ) = @_;
518   ***    380    100     66                 3270      return unless $opt && $opt->{type};
519          285                                905      my $val = $opt->{value};
520                                                   
521   ***    285     50     66                 6679      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
522   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
523   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
524   ***      0      0                           0         if ( !$suffix ) {
525   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
526   ***      0             0                    0            $suffix = $s || 's';
527   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
528                                                               $opt->{long}, '(value:', $val, ')');
529                                                         }
530   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
531   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
532                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
533                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
534                                                                 :                  $num * 86400;   # Days
535   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
536   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
537                                                         }
538                                                         else {
539   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
540                                                         }
541                                                      }
542                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
543   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
544   ***      0                                  0         my $prev = {};
545   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
546   ***      0      0                           0         if ( $from_key ) {
547   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
548   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
549                                                         }
550   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
551   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
552                                                      }
553                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
554   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
555   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
556   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
557   ***      0      0                           0         if ( defined $num ) {
558   ***      0      0                           0            if ( $factor ) {
559   ***      0                                  0               $num *= $factor_for{$factor};
560   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
561                                                                  'to num', $num, '* factor', $factor);
562                                                            }
563   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
564                                                         }
565                                                         else {
566   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
567                                                         }
568                                                      }
569                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
570   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
571                                                      }
572                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
573   ***     19            50                  324         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
574                                                      }
575                                                      else {
576          266                                624         MKDEBUG && _d('Nothing to validate for option',
577                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
578                                                      }
579                                                   
580          285                                960      return;
581                                                   }
582                                                   
583                                                   sub get {
584          157                  157           673      my ( $self, $opt ) = @_;
585   ***    157     50                         693      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
586   ***    157     50     33                 1502      die "Option $opt does not exist"
587                                                         unless $long && exists $self->{opts}->{$long};
588          157                               1196      return $self->{opts}->{$long}->{value};
589                                                   }
590                                                   
591                                                   sub got {
592           76                   76           338      my ( $self, $opt ) = @_;
593   ***     76     50                         342      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
594   ***     76     50     33                  754      die "Option $opt does not exist"
595                                                         unless $long && exists $self->{opts}->{$long};
596           76                                540      return $self->{opts}->{$long}->{got};
597                                                   }
598                                                   
599                                                   sub has {
600           19                   19           102      my ( $self, $opt ) = @_;
601   ***     19     50                         106      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
602   ***     19     50                         152      return defined $long ? exists $self->{opts}->{$long} : 0;
603                                                   }
604                                                   
605                                                   sub set {
606   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
607   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
608   ***      0      0      0                    0      die "Option $opt does not exist"
609                                                         unless $long && exists $self->{opts}->{$long};
610   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
611   ***      0                                  0      return;
612                                                   }
613                                                   
614                                                   sub save_error {
615   ***      0                    0             0      my ( $self, $error ) = @_;
616   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
617                                                   }
618                                                   
619                                                   sub errors {
620   ***      0                    0             0      my ( $self ) = @_;
621   ***      0                                  0      return $self->{errors};
622                                                   }
623                                                   
624                                                   sub prompt {
625   ***      0                    0             0      my ( $self ) = @_;
626   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
627                                                   }
628                                                   
629                                                   sub descr {
630   ***      0                    0             0      my ( $self ) = @_;
631   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
632                                                                 . "  For more details, please use the --help option, "
633                                                                 . "or try 'perldoc $PROGRAM_NAME' "
634                                                                 . "for complete documentation.";
635   ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
636                                                         unless $ENV{DONT_BREAK_LINES};
637   ***      0                                  0      $descr =~ s/ +$//mg;
638   ***      0                                  0      return $descr;
639                                                   }
640                                                   
641                                                   sub usage_or_errors {
642           19                   19            81      my ( $self ) = @_;
643   ***     19     50                         111      if ( $self->{opts}->{help}->{got} ) {
      ***     19     50                         102   
644   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
645   ***      0                                  0         exit 0;
646                                                      }
647                                                      elsif ( scalar @{$self->{errors}} ) {
648   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
649   ***      0                                  0         exit 0;
650                                                      }
651           19                                 49      return;
652                                                   }
653                                                   
654                                                   sub print_errors {
655   ***      0                    0             0      my ( $self ) = @_;
656   ***      0                                  0      my $usage = $self->prompt() . "\n";
657   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
658   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
659                                                                 . "\n";
660                                                      }
661   ***      0                                  0      return $usage . "\n" . $self->descr();
662                                                   }
663                                                   
664                                                   sub print_usage {
665   ***      0                    0             0      my ( $self ) = @_;
666   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
667   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
668                                                   
669   ***      0      0                           0      my $maxl = max(
670   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
671                                                         @opts);
672                                                   
673   ***      0      0                           0      my $maxs = max(0,
674   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
675   ***      0                                  0         values %{$self->{short_opts}});
676                                                   
677   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
678   ***      0                                  0      my $rcol = 80 - $lcol - 6;
679   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
680                                                   
681   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
682                                                   
683   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
684                                                   
685   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
686   ***      0                                  0      push @groups, 'default';
687                                                   
688   ***      0                                  0      foreach my $group ( reverse @groups ) {
689   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
690   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
691   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
692                                                            grep { $_->{group} eq $group }
693                                                            @opts )
694                                                         {
695   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
696   ***      0                                  0            my $short = $opt->{short};
697   ***      0                                  0            my $desc  = $opt->{desc};
698   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
699   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
700   ***      0             0                    0               $s    ||= 's';
701   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
702   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
703                                                                      . "d=days; if no suffix, $s is used.";
704                                                            }
705   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
706   ***      0                                  0            $desc =~ s/ +$//mg;
707   ***      0      0                           0            if ( $short ) {
708   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
709                                                            }
710                                                            else {
711   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
712                                                            }
713                                                         }
714                                                      }
715                                                   
716   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
717   ***      0                                  0         $usage .= "\nRules:\n\n";
718   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
719                                                      }
720   ***      0      0                           0      if ( $self->{dp} ) {
721   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
722                                                      }
723   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
724   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
725   ***      0                                  0         my $val   = $opt->{value};
726   ***      0             0                    0         my $type  = $opt->{type} || '';
727   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
728   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
729                                                                   : !defined $val             ? '(No value)'
730                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
731                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
732                                                                   : $type =~ m/A|a/           ? join(',', @$val)
733                                                                   :                             $val;
734   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
735                                                      }
736   ***      0                                  0      return $usage;
737                                                   }
738                                                   
739                                                   sub prompt_noecho {
740   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
741   ***      0                                  0      my ( $prompt ) = @_;
742   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
743   ***      0      0                           0      print $prompt
744                                                         or die "Cannot print: $OS_ERROR";
745   ***      0                                  0      my $response;
746   ***      0                                  0      eval {
747   ***      0                                  0         require Term::ReadKey;
748   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
749   ***      0                                  0         chomp($response = <STDIN>);
750   ***      0                                  0         Term::ReadKey::ReadMode('normal');
751   ***      0      0                           0         print "\n"
752                                                            or die "Cannot print: $OS_ERROR";
753                                                      };
754   ***      0      0                           0      if ( $EVAL_ERROR ) {
755   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
756                                                      }
757   ***      0                                  0      return $response;
758                                                   }
759                                                   
760                                                   if ( MKDEBUG ) {
761                                                      print '# ', $^X, ' ', $], "\n";
762                                                      my $uname = `uname -a`;
763                                                      if ( $uname ) {
764                                                         $uname =~ s/\s+/ /g;
765                                                         print "# $uname\n";
766                                                      }
767                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
768                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
769                                                         ($main::SVN_REV || ''), __LINE__);
770                                                      print('# Arguments: ',
771                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
772                                                   }
773                                                   
774                                                   sub _read_config_file {
775           76                   76           311      my ( $self, $filename ) = @_;
776   ***     76     50                         192      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
777   ***      0                                  0      my @args;
778   ***      0                                  0      my $prefix = '--';
779   ***      0                                  0      my $parse  = 1;
780                                                   
781                                                      LINE:
782   ***      0                                  0      while ( my $line = <$fh> ) {
783   ***      0                                  0         chomp $line;
784   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
785   ***      0                                  0         $line =~ s/\s+#.*$//g;
786   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
787   ***      0      0                           0         if ( $line eq '--' ) {
788   ***      0                                  0            $prefix = '';
789   ***      0                                  0            $parse  = 0;
790   ***      0                                  0            next LINE;
791                                                         }
792   ***      0      0      0                    0         if ( $parse
      ***             0                               
793                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
794                                                         ) {
795   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
796                                                         }
797                                                         elsif ( $line =~ m/./ ) {
798   ***      0                                  0            push @args, $line;
799                                                         }
800                                                         else {
801   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
802                                                         }
803                                                      }
804   ***      0                                  0      close $fh;
805   ***      0                                  0      return @args;
806                                                   }
807                                                   
808                                                   sub read_para_after {
809   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
810   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
811   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
812   ***      0                                  0      my $para;
813   ***      0                                  0      while ( $para = <$fh> ) {
814   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
815   ***      0                                  0         last;
816                                                      }
817   ***      0                                  0      while ( $para = <$fh> ) {
818   ***      0      0                           0         next unless $para =~ m/$regex/;
819   ***      0                                  0         last;
820                                                      }
821   ***      0                                  0      $para = <$fh>;
822   ***      0                                  0      chomp($para);
823   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
824   ***      0                                  0      return $para;
825                                                   }
826                                                   
827                                                   sub clone {
828   ***      0                    0             0      my ( $self ) = @_;
829                                                   
830   ***      0                                  0      my %clone = map {
831   ***      0                                  0         my $hashref  = $self->{$_};
832   ***      0                                  0         my $val_copy = {};
833   ***      0                                  0         foreach my $key ( keys %$hashref ) {
834   ***      0                                  0            my $ref = ref $hashref->{$key};
835   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
836   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
837   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
838                                                                              : $hashref->{$key};
839                                                         }
840   ***      0                                  0         $_ => $val_copy;
841                                                      } qw(opts short_opts defaults);
842                                                   
843   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
844   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
845                                                      }
846                                                   
847   ***      0                                  0      return bless \%clone;     
848                                                   }
849                                                   
850                                                   sub _d {
851   ***      0                    0             0      my ($package, undef, $line) = caller 0;
852   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
853   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
854                                                           @_;
855   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
856                                                   }
857                                                   
858                                                   1;
859                                                   
860                                                   # ###########################################################################
861                                                   # End OptionParser package
862                                                   # ###########################################################################
863                                                   
864                                                   # ###########################################################################
865                                                   # ReportFormatter package 5266
866                                                   # ###########################################################################
867                                                   package ReportFormatter;
868                                                   
869            4                    4            41   use strict;
               4                                 10   
               4                                 32   
870            4                    4            27   use warnings FATAL => 'all';
               4                                 10   
               4                                 29   
871            4                    4            32   use English qw(-no_match_vars);
               4                                 13   
               4                                 24   
872            4                    4            29   use List::Util qw(min max);
               4                                 10   
               4                                 22   
873                                                   
874   ***      4            50      4            26   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 13   
               4                                 65   
875                                                   
876            4                    4            29   use Data::Dumper;
               4                                  9   
               4                                 35   
877                                                   $Data::Dumper::Indent    = 1;
878                                                   $Data::Dumper::Sortkeys  = 1;
879                                                   $Data::Dumper::Quotekeys = 0;
880                                                   
881                                                   sub new {
882           19                   19           142      my ( $class, %args ) = @_;
883           19                                 68      my @required_args = qw();
884           19                                114      foreach my $arg ( @required_args ) {
885   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
886                                                      }
887           19                                174      my $self = {
888                                                         underline_header  => 1,
889                                                         line_prefix        => '# ',
890                                                         line_width         => 78,
891                                                         truncate_underline => 1,
892                                                         %args,
893                                                      };
894           19                                170      return bless $self, $class;
895                                                   }
896                                                   
897                                                   sub set_title {
898   ***      0                    0             0      my ( $self, $title ) = @_;
899   ***      0                                  0      $self->{title} = $title;
900   ***      0                                  0      return;
901                                                   }
902                                                   
903                                                   sub set_columns {
904           19                   19           101      my ( $self, @cols ) = @_;
905           19                                110      push @{$self->{cols}}, map {
              57                                158   
906           19                                 60         my $col = $_;
907   ***     57     50                         243         die "Column does not have a name" unless defined $col->{name};
908   ***     57     50     33                  289         if ( $col->{fixed_wdith} && $col->{fixed_width} < length $col->{name} ) { 
909   ***      0                                  0            die "Fixed width is less than the column name";
910                                                         }
911           57                                231         $col->{min_val_width} = length $col->{name};
912           57                                227         $col->{max_val_width} = length $col->{name};
913           57                                187         $col;
914                                                      } @cols;
915           19                                 61      return;
916                                                   }
917                                                   
918                                                   sub add_line {
919          119                  119           559      my ( $self, @vals ) = @_;
920                                                   
921          119                                323      my $n_cols = scalar @{$self->{cols}};
             119                                421   
922          119                                325      my $n_vals = scalar @vals;
923   ***    119     50                         446      die "Number of columns ($n_cols) and values ($n_vals) do not match"
924                                                         unless $n_cols == $n_vals;
925                                                   
926          119                                281      my @line;
927          119                                609      for my $i ( 0..$#vals ) {
928          357                               1245         my $col = $self->{cols}->[$i];
929          357                               1023         my $val = $vals[$i];
930          357                                980         my $width = length $val;
931   ***    357     50     66                 2234         if ( $col->{fixed_width} && $width > $col->{fixed_width} ) {
932   ***      0      0                           0            if ( $col->{truncate} ) {
933   ***      0                                  0               $val  = substr($val, 0, $col->{fixed_width} - 3);
934   ***      0                                  0               $val .= '...';
935   ***      0                                  0               MKDEBUG && _d('Truncated', $vals[$i], 'to', $val);
936                                                            }
937                                                            else {
938   ***      0                                  0               die "Value '$val' is too wide for column $col->{name}";
939                                                            }
940                                                         }
941          357                               1724         $col->{max_val_width} = max($width, $col->{max_val_width});
942          357                               1390         push @line, $val;
943                                                      }
944          119                                335      push @{$self->{lines}}, \@line;
             119                                488   
945                                                   
946          119                                421      return;
947                                                   }
948                                                   
949                                                   sub get_report {
950           19                   19            77      my ( $self ) = @_;
951           19                                 51      my @lines;
952   ***     19            50                  198      my $p = $self->{line_prefix} || '';
953                                                   
954   ***     19     50                          56      my $n_cols = scalar @{$self->{cols}}
              19                                122   
955                                                                 - ($self->{long_last_column} ? 2 : 1);
956                                                   
957           19                                 53      my $fmt = $p;
958           19                                 48      my @col_fmts;
959           19                                101      for my $i ( 0..$n_cols ) {
960           57                                208         my $col = $self->{cols}->[$i];
961           57    100                         357         my $col_fmt = '%'
962                                                                     . ($col->{right_justify} ? '' : '-')
963                                                                     . "$col->{max_val_width}"
964                                                                     . 's';
965           57                                246         push @col_fmts, $col_fmt;
966                                                      }
967   ***     19     50                          94      if ( $self->{long_last_column} ) {
968   ***      0                                  0         push @col_fmts, '%s';
969                                                      }
970           19                                 87      $fmt .= join(' ', @col_fmts);
971           19                                 45      MKDEBUG && _d('Format:', $fmt);
972                                                   
973   ***     19     50                          90      push @lines, sprintf "${p}$self->{title}" if $self->{title};
974                                                   
975           19                                309      (my $hdr_fmt = $fmt) =~ s/%([^-])/%-$1/g;
976           19                                 86      push @lines, sprintf $hdr_fmt, map { $_->{name} } @{$self->{cols}};
              57                                287   
              19                                 89   
977                                                   
978   ***     19     50                         102      if ( $self->{underline_header} ) {
979           19                                 55         my $underline_len = 0;
980           57                                243         my @underlines = map {
981           19                                 94            my $underline = '=' x $_->{max_val_width};
982           57                                160            $underline_len += length $underline;
983           57                                210            $underline;
984           19                                 58         } @{$self->{cols}};
985           19                                 78         $underline_len += (scalar @underlines) - 1;
986   ***     19     50     33                  234         if ( $self->{truncate_underline}
987                                                              && (2 + $underline_len) > $self->{line_width} ) {
988   ***      0                                  0            my $over = $self->{line_width} - (2 + $underline_len);
989   ***      0                                  0            $underlines[-1] = substr($underlines[-1], 0, $over);
990                                                         }
991                                                   
992           19                                111         push @lines, sprintf $fmt, @underlines;
993                                                      }
994                                                   
995           19                                 53      foreach my $line ( @{$self->{lines}} ) {
              19                                 91   
996          119                                545         push @lines, sprintf $fmt, @$line;
997                                                      }
998                                                   
999           19                                270      return join("\n", @lines) . "\n";
1000                                                  }
1001                                                  
1002                                                  sub _d {
1003  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1004  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1005  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1006                                                          @_;
1007  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1008                                                  }
1009                                                  
1010                                                  1;
1011                                                  
1012                                                  # ###########################################################################
1013                                                  # End ReportFormatter package
1014                                                  # ###########################################################################
1015                                                  
1016                                                  # ###########################################################################
1017                                                  # ErrorLogParser package 5401
1018                                                  # ###########################################################################
1019                                                  package ErrorLogParser;
1020                                                  
1021           4                    4            29   use strict;
               4                                 11   
               4                                 27   
1022           4                    4            24   use warnings FATAL => 'all';
               4                                  9   
               4                                 23   
1023           4                    4            24   use English qw(-no_match_vars);
               4                                  8   
               4                                 21   
1024                                                  
1025           4                    4            26   use Data::Dumper;
               4                                 11   
               4                                 19   
1026                                                  $Data::Dumper::Indent    = 1;
1027                                                  $Data::Dumper::Sortkeys  = 1;
1028                                                  $Data::Dumper::Quotekeys = 0;
1029                                                  
1030  ***      4            50      4            26   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                  9   
               4                                 64   
1031                                                  
1032                                                  my $ts = qr/(\d{6}\s{1,2}[\d:]+)\s*/;
1033                                                  my $ml = qr{\A(?:
1034                                                     InnoDB:\s
1035                                                     |-\smysqld\sgot\ssignal
1036                                                     |Status\sinformation
1037                                                     |Memory\sstatus
1038                                                  )}x;
1039                                                  
1040                                                  sub new {
1041          19                   19           119      my ( $class, %args ) = @_;
1042          19                                133      my $self = {
1043                                                        %args,
1044                                                        pending => [],
1045                                                     };
1046          19                                156      return bless $self, $class;
1047                                                  }
1048                                                  
1049                                                  sub parse_event {
1050         285                  285          1219      my ( $self, %args ) = @_;
1051         285                               1069      my @required_args = qw(fh);
1052         285                                871      foreach my $arg ( @required_args ) {
1053  ***    285     50                        1426         die "I need a $arg argument" unless $args{$arg};
1054                                                     }
1055         285                               1060      my ($fh) = @args{@required_args};
1056                                                  
1057         285                                924      my $pending = $self->{pending};
1058                                                  
1059         285                                899      my $pos_in_log = tell($fh);
1060         285                                631      my $line;
1061                                                     EVENT:
1062         285           100                 3147      while ( defined($line = shift @$pending) or defined($line = <$fh>) ) {
1063         310    100                        1842         next if $line =~ m/^\s*$/;  # lots of blank lines in error logs
1064         266                                718         chomp $line;
1065         266                                976         my @properties = ('pos_in_log', $pos_in_log);
1066         266                                796         $pos_in_log = tell($fh);
1067                                                  
1068         266    100                        2134         if ( my ($ts) = $line =~ /^$ts/o ) {
1069         232                                494            MKDEBUG && _d('Got ts:', $ts);
1070         232                                755            push @properties, 'ts', $ts;
1071         232                               2409            $line =~ s/^$ts//;
1072                                                        }
1073                                                  
1074         266                                679         my $level;
1075         266    100                        1553         if ( ($level) = $line =~ /\[((?:ERROR|Warning|Note))\]/ ) {
1076         114    100                         580            $level = $level =~ m/error/i   ? 'error'
                    100                               
1077                                                                  : $level =~ m/warning/i ? 'warning'
1078                                                                  :                         'info';
1079                                                        }
1080                                                        else {
1081         152                                433            $level = 'unknown';
1082                                                        }
1083         266                                587         MKDEBUG && _d('Level:', $level);
1084         266                                882         push @properties, 'Level', $level;
1085                                                  
1086         266    100                        1263         if ( my ($level) = $line =~ /InnoDB: Error/ ) {
1087           6                                 14            MKDEBUG && _d('Got serious InnoDB error');
1088           6                                 23            push @properties, 'Level', 'error';
1089                                                        }
1090                                                  
1091         266                                899         $line =~ s/^\s+//;
1092         266                               1071         $line =~ s/\s{2,}/ /;
1093         266                               1173         $line =~ s/\s+$//;
1094                                                  
1095                                                  
1096         266    100                        1503         if ( $line =~ m/$ml/o ) {
                    100                               
1097          66                                151            MKDEBUG && _d('Multi-line message:', $line);
1098          66                                212            $line =~ s/- //; # Trim "- msyqld got signal" special case.
1099          66                                155            my $next_line;
1100          66           100                  904            while ( defined($next_line = <$fh>)
1101                                                                   && $next_line !~ m/^$ts/o ) {
1102        3500                               8693               chomp $next_line;
1103        3500    100                       14751               next if $next_line eq '';
1104        3158                               8772               $next_line =~ s/^InnoDB: //; # InnoDB special-case.
1105        3158                              31881               $line     .= " " . $next_line;
1106                                                           }
1107          66                                143            MKDEBUG && _d('Pending next line:', $next_line);
1108          66                                296            push @$pending, $next_line;
1109                                                        }
1110                                                        elsif ( $line =~ m/\bQuery: '/ ) {
1111           1                                  8            MKDEBUG && _d('Error query:', $line);
1112           1                                  5            my $next_line;
1113           1                                  6            my $last_line = 0;
1114  ***      1            66                   17            while ( !$last_line && defined($next_line = <$fh>) ) {
1115           3                                  8               chomp $next_line;
1116           3                                  6               MKDEBUG && _d('Error query:', $next_line);
1117           3                                  9               $line     .= $next_line;
1118           3    100                          27               $last_line = 1 if $next_line =~ m/, Error_code:/;
1119                                                           }
1120                                                        }
1121                                                  
1122         266                                704         chomp $line;
1123         266                               1098         push @properties, 'arg', $line;
1124                                                  
1125         266                                561         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
1126         266                               1579         my $event = { @properties };
1127         266                               1491         return $event;
1128                                                  
1129                                                     } # EVENT
1130                                                  
1131          19                                 70      @$pending = ();
1132  ***     19     50                         142      $args{oktorun}->(0) if $args{oktorun};
1133          19                                 82      return;
1134                                                  }
1135                                                  
1136                                                  sub _d {
1137  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1138  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1139  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1140                                                          @_;
1141  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1142                                                  }
1143                                                  
1144                                                  1;
1145                                                  
1146                                                  # ###########################################################################
1147                                                  # End ErrorLogParser package
1148                                                  # ###########################################################################
1149                                                  
1150                                                  # ###########################################################################
1151                                                  # ErrorLogPatternMatcher package 5573
1152                                                  # ###########################################################################
1153                                                  package ErrorLogPatternMatcher;
1154                                                  
1155           4                    4            30   use strict;
               4                                 16   
               4                                 27   
1156           4                    4            25   use warnings FATAL => 'all';
               4                                 11   
               4                                 20   
1157           4                    4            24   use English qw(-no_match_vars);
               4                                 10   
               4                                 20   
1158           4                    4            27   use Data::Dumper;
               4                                 11   
               4                                 20   
1159                                                  $Data::Dumper::Indent    = 1;
1160                                                  $Data::Dumper::Sortkeys  = 1;
1161                                                  $Data::Dumper::Quotekeys = 0;
1162                                                  
1163  ***      4            50      4            24   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 11   
               4                                 52   
1164                                                  
1165                                                  sub new {
1166          19                   19            93      my ( $class, %args ) = @_;
1167          19                                224      my $self = {
1168                                                        %args,
1169                                                        patterns => [],
1170                                                        compiled => [],
1171                                                        level    => [],
1172                                                        name     => [],
1173                                                     };
1174          19                                128      return bless $self, $class;
1175                                                  }
1176                                                  
1177                                                  sub add_patterns {
1178          89                   89           339      my ( $self, $patterns ) = @_;
1179          89                                312      foreach my $p ( @$patterns ) {
1180  ***    450     50     50                 3531         next unless $p && scalar @$p;
1181         450                               2120         my ($name, $level, $regex) = @$p;
1182         450                               1313         push @{$self->{names}},    $name;
             450                               1797   
1183         450                               1143         push @{$self->{levels}},   $level;
             450                               1626   
1184         450                               1124         push @{$self->{patterns}}, $regex;
             450                               1632   
1185         450                               1111         push @{$self->{compiled}}, qr/$regex/;
             450                               6323   
1186         450                               1439         MKDEBUG && _d('Added new pattern:', $name, $level, $regex,
1187                                                           $self->{compiled}->[-1]);
1188                                                     }
1189          89                                292      return;
1190                                                  }
1191                                                  
1192                                                  sub load_patterns_file {
1193  ***      0                    0             0      my ( $self, $fh ) = @_;
1194  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1195  ***      0                                  0      my %seen;
1196  ***      0                                  0      my $pattern;
1197  ***      0                                  0      while ( defined($pattern = <$fh>) ) {
1198  ***      0                                  0         my ($name, $level, $regex) = split("\n", $pattern);
1199  ***      0      0      0                    0         if ( !($name && $level && $regex) ) {
      ***                    0                        
1200  ***      0                                  0            warn "Pattern missing name, level or regex:\n$pattern";
1201  ***      0                                  0            next;
1202                                                        }
1203  ***      0      0                           0         if ( $seen{$name}++ ) {
1204  ***      0                                  0            warn "Duplicate pattern: $name";
1205  ***      0                                  0            next;
1206                                                        }
1207  ***      0                                  0         $self->add_patterns( [[$name, $level, $regex]] );
1208                                                     }
1209  ***      0                                  0      return;
1210                                                  }
1211                                                  
1212                                                  sub reset_patterns {
1213  ***      0                    0             0      my ( $self ) = @_;
1214  ***      0                                  0      $self->{names}    = [];
1215  ***      0                                  0      $self->{levels}   = [];
1216  ***      0                                  0      $self->{patterns} = [];
1217  ***      0                                  0      $self->{compiled} = [];
1218  ***      0                                  0      MKDEBUG && _d('Reset patterns');
1219  ***      0                                  0      return;
1220                                                  }
1221                                                  
1222                                                  sub patterns {
1223  ***      0                    0             0      my ( $self ) = @_;
1224  ***      0                                  0      return @{$self->{patterns}};
      ***      0                                  0   
1225                                                  }
1226                                                  
1227                                                  sub names {
1228          19                   19            73      my ( $self ) = @_;
1229          19                                 52      return @{$self->{names}};
              19                                409   
1230                                                  }
1231                                                  
1232                                                  sub levels {
1233          19                   19            71      my ( $self ) = @_;
1234          19                                 52      return @{$self->{levels}};
              19                                331   
1235                                                  }
1236                                                  
1237                                                  sub match {
1238         157                  157           693      my ( $self, %args ) = @_;
1239         157                                640      my @required_args = qw(event);
1240         157                                534      foreach my $arg ( @required_args ) {
1241  ***    157     50                         786         die "I need a $arg argument" unless $args{$arg};
1242                                                     }
1243         157                                541      my $event = @args{@required_args};
1244         157                                609      my $err   = $event->{arg};
1245  ***    157     50                         533      return unless $err;
1246                                                  
1247  ***    157     50     33                  804      if ( $self->{QueryRewriter}
1248                                                          && (my ($query) = $err =~ m/Statement: (.+)$/) ) {
1249  ***      0                                  0         $query = $self->{QueryRewriter}->fingerprint($query);
1250  ***      0                                  0         $err =~ s/Statement: .+$/Statement: $query/;
1251                                                     }
1252                                                  
1253         157                                499      my $compiled = $self->{compiled};
1254         157                                507      my $n        = (scalar @$compiled) - 1;
1255         157                                365      my $pno;
1256                                                     PATTERN:
1257         157                                561      for my $i ( 0..$n ) {
1258        2612    100                       14057         if ( $err =~ m/$compiled->[$i]/ ) {
1259          87                                212            $pno = $i;
1260          87                                247            last PATTERN;
1261                                                        } 
1262                                                     }
1263                                                  
1264         157    100                         565      if ( defined $pno ) {
1265          87                                194         MKDEBUG && _d($err, 'matches', $self->{patterns}->[$pno]);
1266          87                                351         $event->{New_pattern} = 'No';
1267          87                                313         $event->{Pattern_no}  = $pno;
1268                                                  
1269  ***     87     50     33                  490         if ( !$event->{Level} && $self->{levels}->[$pno] ) {
1270  ***      0                                  0            $event->{Level} = $self->{levels}->[$pno];
1271                                                        }
1272                                                     }
1273                                                     else {
1274          70                                148         MKDEBUG && _d('New pattern');
1275          70                                287         my $regex = $self->fingerprint($err);
1276          70                                256         my $name  = substr($err, 0, 50);
1277          70                                454         $self->add_patterns( [ [$name, $event->{Level}, $regex] ] );
1278          70                                316         $event->{New_pattern} = 'Yes';
1279          70                                175         $event->{Pattern_no}  = (scalar @{$self->{patterns}}) - 1;
              70                                373   
1280                                                     }
1281                                                  
1282         157                                843      $event->{Pattern} = $self->{patterns}->[ $event->{Pattern_no} ];
1283                                                  
1284         157                                674      return $event;
1285                                                  }
1286                                                  
1287                                                  sub fingerprint {
1288          70                   70           330      my ( $self, $err ) = @_;
1289                                                  
1290          70                                884      $err =~ s/([\(\)\[\].+?*\{\}])/\\$1/g;
1291                                                  
1292          70                                817      $err =~ s/\b\d+\b/\\d+/g;              # numbers
1293          70                                308      $err =~ s/\b0x[0-9a-zA-Z]+\b/0x\\S+/g; # hex values
1294                                                  
1295          70                                330      return $err;
1296                                                  }
1297                                                  
1298                                                  sub _d {
1299  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1300  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1301  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1302                                                          @_;
1303  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1304                                                  }
1305                                                  
1306                                                  1;
1307                                                  
1308                                                  # ###########################################################################
1309                                                  # End ErrorLogPatternMatcher package
1310                                                  # ###########################################################################
1311                                                  
1312                                                  # ###########################################################################
1313                                                  # Transformers package 5266
1314                                                  # ###########################################################################
1315                                                  
1316                                                  package Transformers;
1317                                                  
1318           4                    4            29   use strict;
               4                                 10   
               4                                 24   
1319           4                    4            28   use warnings FATAL => 'all';
               4                                 10   
               4                                 26   
1320           4                    4            24   use English qw(-no_match_vars);
               4                                 14   
               4                                763   
1321           4                    4           143   use Time::Local qw(timegm timelocal);
               4                                 13   
               4                                 54   
1322           4                    4            25   use Digest::MD5 qw(md5_hex);
               4                                 10   
               4                                 28   
1323                                                  
1324  ***      4            50      4            25   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                  8   
               4                                 63   
1325                                                  
1326                                                  require Exporter;
1327                                                  our @ISA         = qw(Exporter);
1328                                                  our %EXPORT_TAGS = ();
1329                                                  our @EXPORT      = ();
1330                                                  our @EXPORT_OK   = qw(
1331                                                     micro_t
1332                                                     percentage_of
1333                                                     secs_to_time
1334                                                     shorten
1335                                                     ts
1336                                                     parse_timestamp
1337                                                     unix_timestamp
1338                                                     any_unix_timestamp
1339                                                     make_checksum
1340                                                  );
1341                                                  
1342                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1343                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
1344                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1345                                                  
1346                                                  sub micro_t {
1347  ***      0                    0             0      my ( $t, %args ) = @_;
1348  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1349  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1350  ***      0                                  0      my $f;
1351                                                  
1352  ***      0      0                           0      $t = 0 if $t < 0;
1353                                                  
1354  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1355                                                  
1356  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1357                                                  
1358  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1359  ***      0                                  0         $f = ($t * 1000000) . 'us';
1360                                                     }
1361                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1362  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1363  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1364                                                     }
1365                                                     elsif ($t >= 1) {
1366  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1367  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1368                                                     }
1369                                                     else {
1370  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1371                                                     }
1372                                                  
1373  ***      0                                  0      return $f;
1374                                                  }
1375                                                  
1376                                                  sub percentage_of {
1377  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1378  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1379  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1380  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1381                                                  }
1382                                                  
1383                                                  sub secs_to_time {
1384  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1385  ***      0             0                    0      $secs ||= 0;
1386  ***      0      0                           0      return '00:00' unless $secs;
1387                                                  
1388  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1389                                                            : $secs >= 3_600  ? 'h'
1390                                                            :                   'm';
1391                                                  
1392                                                     return
1393  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1394                                                           "%d+%02d:%02d:%02d",
1395                                                           int($secs / 86_400),
1396                                                           int(($secs % 86_400) / 3_600),
1397                                                           int(($secs % 3_600) / 60),
1398                                                           $secs % 60)
1399                                                        : $fmt eq 'h' ? sprintf(
1400                                                           "%02d:%02d:%02d",
1401                                                           int(($secs % 86_400) / 3_600),
1402                                                           int(($secs % 3_600) / 60),
1403                                                           $secs % 60)
1404                                                        : sprintf(
1405                                                           "%02d:%02d",
1406                                                           int(($secs % 3_600) / 60),
1407                                                           $secs % 60);
1408                                                  }
1409                                                  
1410                                                  sub shorten {
1411  ***      0                    0             0      my ( $num, %args ) = @_;
1412  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1413  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1414  ***      0                                  0      my $n = 0;
1415  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1416  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1417  ***      0                                  0         $num /= $d;
1418  ***      0                                  0         ++$n;
1419                                                     }
1420  ***      0      0      0                    0      return sprintf(
1421                                                        $num =~ m/\./ || $n
1422                                                           ? "%.${p}f%s"
1423                                                           : '%d',
1424                                                        $num, $units[$n]);
1425                                                  }
1426                                                  
1427                                                  sub ts {
1428  ***      0                    0             0      my ( $time, $gmt ) = @_;
1429  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
1430                                                        = $gmt ? gmtime($time) : localtime($time);
1431  ***      0                                  0      $mon  += 1;
1432  ***      0                                  0      $year += 1900;
1433  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1434                                                        $year, $mon, $mday, $hour, $min, $sec);
1435  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
1436  ***      0                                  0         $us = sprintf("%.6f", $us);
1437  ***      0                                  0         $us =~ s/^0\././;
1438  ***      0                                  0         $val .= $us;
1439                                                     }
1440  ***      0                                  0      return $val;
1441                                                  }
1442                                                  
1443                                                  sub parse_timestamp {
1444         164                  164           564      my ( $val ) = @_;
1445  ***    164     50                        1876      if ( my($y, $m, $d, $h, $i, $s, $f)
1446                                                           = $val =~ m/^$mysql_ts$/ )
1447                                                     {
1448  ***    164     50                        1730         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***            50                               
1449                                                                       . (defined $f ? '%02.6f' : '%02d'),
1450                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1451                                                     }
1452  ***      0                                  0      return $val;
1453                                                  }
1454                                                  
1455                                                  sub unix_timestamp {
1456         165                  165           597      my ( $val, $gmt ) = @_;
1457  ***    165     50                        1934      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
1458  ***    165     50                         981         $val = $gmt
1459                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
1460                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
1461  ***    165     50                         628         if ( defined $us ) {
1462  ***      0                                  0            $us = sprintf('%.6f', $us);
1463  ***      0                                  0            $us =~ s/^0\././;
1464  ***      0                                  0            $val .= $us;
1465                                                        }
1466                                                     }
1467         165                                767      return $val;
1468                                                  }
1469                                                  
1470                                                  sub any_unix_timestamp {
1471         165                  165           599      my ( $val, $callback ) = @_;
1472                                                  
1473  ***    165     50                        2149      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
                    100                               
      ***            50                               
1474  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1475                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1476                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1477                                                           : $suffix eq 'd' ? $n * 86400    # Days
1478                                                           :                  $n;           # default: Seconds
1479  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
1480  ***      0                                  0         return time - $n;
1481                                                     }
1482                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
1483         164                                351         MKDEBUG && _d('ts is MySQL slow log timestamp');
1484         164    100                         573         $val .= ' 00:00:00' unless $hms;
1485         164                                570         return unix_timestamp(parse_timestamp($val));
1486                                                     }
1487                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
1488           1                                  2         MKDEBUG && _d('ts is properly formatted timestamp');
1489  ***      1     50                           9         $val .= ' 00:00:00' unless $hms;
1490           1                                 11         return unix_timestamp($val);
1491                                                     }
1492                                                     else {
1493  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
1494  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
1495                                                     }
1496                                                  
1497  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
1498  ***      0                                  0      return;
1499                                                  }
1500                                                  
1501                                                  sub make_checksum {
1502  ***      0                    0             0      my ( $val ) = @_;
1503  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1504  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1505  ***      0                                  0      return $checksum;
1506                                                  }
1507                                                  
1508                                                  sub _d {
1509  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1510  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1511  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1512                                                          @_;
1513  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1514                                                  }
1515                                                  
1516                                                  1;
1517                                                  
1518                                                  # ###########################################################################
1519                                                  # End Transformers package
1520                                                  # ###########################################################################
1521                                                  
1522                                                  # ###########################################################################
1523                                                  # This is a combination of modules and programs in one -- a runnable module.
1524                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1525                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1526                                                  #
1527                                                  # Check at the end of this package for the call to main() which actually runs
1528                                                  # the program.
1529                                                  # ###########################################################################
1530                                                  package mk_error_log;
1531                                                  
1532           4                    4            35   use strict;
               4                                  9   
               4                                 22   
1533           4                    4            26   use warnings FATAL => 'all';
               4                                 14   
               4                                 24   
1534           4                    4            23   use English qw(-no_match_vars);
               4                                  8   
               4                                 24   
1535           4                    4            27   use IO::File;
               4                                 11   
               4                                 50   
1536           4                    4            25   use Data::Dumper;
               4                                 10   
               4                                 60   
1537                                                  $Data::Dumper::Indent    = 1;
1538                                                  $Data::Dumper::Sortkeys  = 1;
1539                                                  $Data::Dumper::Quotekeys = 0;
1540                                                  
1541                                                  Transformers->import qw(any_unix_timestamp);
1542                                                  
1543  ***      4            50      4            26   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                  8   
               4                                 54   
1544                                                  
1545           4                    4            57   use sigtrap 'handler', \&sig_int, 'normal-signals';
               4                                 12   
               4                                 57   
1546                                                  
1547                                                  my $oktorun = 1;
1548                                                  
1549                                                  sub main {
1550          19                   19         27863      @ARGV = @_;  # set global ARGV for this package
1551                                                  
1552                                                     # ########################################################################
1553                                                     # Get configuration information.
1554                                                     # ########################################################################
1555          19                                509      my $o  = new OptionParser(
1556                                                        strict      => 0,
1557                                                        prompt      => '[OPTION...] FILE [FILE...]',
1558                                                        description => q{parses and aggregates MySQL error log statements.},
1559                                                     );
1560          19                                153      $o->get_specs();
1561          19                                198      $o->get_opts();
1562                                                  
1563          19    100                          90      if ( $o->get('resume') ) {
1564  ***      5     50                          26         if ( @ARGV == 0 ) {
1565  ***      0                                  0            $o->save_error("Cannot use --resume when reading from STDIN");
1566                                                        }
1567  ***      5     50                          32         if ( @ARGV > 1 ) {
1568  ***      0                                  0            $o->save_error("Cannot use --resume with more than one error log");
1569                                                        }
1570                                                     }
1571                                                  
1572          19                                151      $o->usage_or_errors();
1573                                                  
1574                                                     # ##########################################################################
1575                                                     # Get ready to do the main work.
1576                                                     # ##########################################################################
1577          19                                264      my $parser  = new ErrorLogParser();
1578          19                                245      my $matcher = new ErrorLogPatternMatcher();
1579                                                  
1580                                                     # ##########################################################################
1581                                                     # Load saved (user) and known (internal) patterns.
1582                                                     # ##########################################################################
1583  ***     19     50                          82      if ( my $file = $o->get('load-patterns') ) {
1584  ***      0                                  0         MKDEBUG && _d('Loading saved patterns from', $file);
1585  ***      0      0                           0         open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
1586  ***      0                                  0         $matcher->load_patterns_file($fh);
1587                                                     }
1588  ***     19     50                          90      load_known_patterns($matcher) if $o->get('known-patterns');
1589                                                  
1590                                                     # #########################################################################
1591                                                     # Load resume file and check if we can use it.
1592                                                     # #########################################################################
1593          19                                 53      my $resume;
1594          19    100                          94      if ( my $resume_file = $o->get('resume') ) {
1595           5                                 61         $resume = {
1596                                                           resume_file => $resume_file,
1597                                                           file        => '',
1598                                                           inode       => undef,
1599                                                           pos         => undef,
1600                                                           size        => undef,
1601                                                        };
1602                                                  
1603                                                        # Parse resume file.
1604           5                                 13         MKDEBUG && _d('Reading resume file', $resume_file);
1605           5    100                          79         if ( !-f $resume_file ) {
1606           1                               2984            `touch $resume_file`;
1607           1                                 12            MKDEBUG && _d('Created resume file');
1608                                                        }
1609  ***      5     50                         211         open my $resume_fh, '<', $resume_file
1610                                                           or die "Cannot open resume file $resume_file: $OS_ERROR";
1611           5                                 62         local $INPUT_RECORD_SEPARATOR = '';
1612           5                                123         my $resume_info = <$resume_fh>;
1613           5                                 41         close $resume_fh;
1614           5    100                          28         if ( $resume_info ) {
1615          16                                 48            map {
1616          16                                 84               my $line = $_;
1617          16                                157               my ($k, $v) = $_ =~ m/\s*(\w+):(.+?)\s*$/;
1618          16                                 88               $resume->{$k} = $v;
1619                                                           }
1620           4                                 42            grep { $_ !~ m/^$/ }
1621                                                           split("\n", $resume_info);
1622                                                        }
1623                                                        else {
1624           1                                  3            MKDEBUG && _d('New resume file');
1625           1                                  7            $resume->{file}  = $ARGV[0];
1626           1                                 16            $resume->{inode} = (stat($ARGV[0]))[1];
1627           1                                  4            $resume->{pos}   = 0;
1628           1                                  7            $resume->{size}  = -s $ARGV[0];
1629                                                        }
1630                                                  
1631                                                        # Sanity check resume file.
1632  ***      5     50                          32         die "Resume file $resume_file does not specify a file"
1633                                                           unless $resume->{file};
1634  ***      5     50                          28         die "Resume file $resume_file does not specify a inode"
1635                                                           unless defined $resume->{inode};
1636  ***      5     50                          26         die "Resume file $resume_file does not specify a pos"
1637                                                           unless defined $resume->{pos};
1638                                                  
1639                                                        # We should have checked earlier that --resume is being used with
1640                                                        # only 1 error log and not STDIN.  So $ARGV[0] should be that log.
1641                                                        # check_resume() checks that the current log matches this resume
1642                                                        # info.  If it does then nothing is done.  If it doesn't, then this
1643                                                        # resume info is saved and a new resume file is started and the new
1644                                                        # resume info is returned.
1645           5                                164         $resume = check_resume($resume, $ARGV[0]);
1646                                                  
1647           5                                 20         MKDEBUG && _d('Resume info:', Dumper($resume));
1648                                                     }
1649                                                  
1650                                                     # ##########################################################################
1651                                                     # Create the pipeline.  These processes do the main work.
1652                                                     # ##########################################################################
1653          19                                 83      my @pipeline;
1654          19                                 55      my %cnt;       # frequency of patterns
1655                                                  
1656                                                     # Parses the error logs, makes events.
1657                                                     push @pipeline, sub {
1658         285                  285          1522         my ( %args ) = @_;
1659         285                               1472         my $event = $parser->parse_event(%args);
1660         285    100    100                 1451         $resume->{pos} = $event->{pos_in_log} if $resume && $event;
1661         285                               1067         return $event;
1662          19                                211      };
1663                                                  
1664                                                     # --since and --until filtering.  Do this before pattern matching.
1665          19                                 53      my $past_since;
1666          19                                 45      my $at_until;
1667          19    100                          96      if ( $o->get('since') ) {
1668           3                                 44         my $since = any_unix_timestamp($o->get('since'));
1669  ***      3     50                          14         die "Invalid --since value" unless $since;
1670                                                        push @pipeline, sub {
1671         114                  114           578            my ( %args ) = @_;
1672         114                                386            my $event = $args{event};
1673         114                                246            MKDEBUG && _d('pipeline: --since');
1674         114    100                         386            if ( $past_since ) {
1675           4                                  9               MKDEBUG && _d('Already past --since');
1676           4                                 17               return $event;
1677                                                           }
1678         110    100                         440            if ( $event->{ts} ) {
1679          95                                356               my $ts = any_unix_timestamp($event->{ts});
1680  ***     95    100     50                  552               if ( ($ts || 0) >= $since ) {
1681           3                                  9                  MKDEBUG && _d('Event is at or past --since');
1682           3                                  8                  $past_since = 1;
1683           3                                 15                  return $event;
1684                                                              }
1685                                                              else {
1686          92                                218                  MKDEBUG && _d('Event is before --since');
1687                                                              }
1688                                                           }
1689         107                                418            return;
1690           3                                 34         };
1691                                                     }
1692          19    100                          85      if ( $o->get('until') ) {
1693           2                                 16         my $until = any_unix_timestamp($o->get('until'));
1694  ***      2     50                          15         die "Invalid --until value" unless $until;
1695                                                        push @pipeline, sub {
1696          76                   76           396            my ( %args ) = @_;
1697          76                                253            my $event = $args{event};
1698          76                                159            MKDEBUG && _d('pipeline: --until');
1699          76    100                         258            if ( $at_until ) {
1700           1                                  6               MKDEBUG && _d('Already past --until');
1701           1                                  5               return;
1702                                                           }
1703          75    100                         302            if ( $event->{ts} ) {
1704          65                                244               my $ts = any_unix_timestamp($event->{ts});
1705  ***     65    100     50                  372               if ( ($ts || 0) >= $until ) {
1706           1                                  9                  MKDEBUG && _d('Event at or after --until');
1707           1                                  7                  $at_until = 1;
1708           1                                  8                  return;
1709                                                              }
1710                                                              else {
1711          64                                155                  MKDEBUG && _d('Event is before --until');
1712                                                              }
1713                                                           }
1714          74                                292            return $event;
1715           2                                 30         };
1716                                                     }
1717                                                  
1718                                                     # Matches events to known patterns or makes new patterns.
1719                                                     push @pipeline, sub {
1720         157                  157           812         my ( %args ) = @_;
1721         157                                404         MKDEBUG && _d('pipeline: match pattern');
1722  ***    157     50                         620         return unless $args{event};
1723         157                                771         my $event = $matcher->match(%args);
1724         157                                758         $cnt{ $event->{Pattern_no} }++;
1725         157                                581         return $event;
1726          19                                167      };
1727                                                  
1728                                                     # Any other pipeline processes?
1729                                                  
1730                                                     # ##########################################################################
1731                                                     # Here's the main work.
1732                                                     # ##########################################################################
1733          19                                 51      my $fh;
1734  ***     19     50                          96      if ( @ARGV == 0 ) {
1735  ***      0                                  0         push @ARGV, '-'; # Magical STDIN filename.
1736                                                     }
1737                                                  
1738                                                     FILE:
1739          19                                 88      while ( $oktorun ) {
1740         304    100                        1167         if ( !$fh ) {
1741          38                                146            my $file = shift @ARGV;
1742          38    100                         166            if ( !$file ) {
1743          19                                 50               MKDEBUG && _d('No more files to parse');
1744          19                                 61               last FILE;
1745                                                           }
1746                                                  
1747  ***     19     50                          87            if ( $file eq '-' ) {
1748  ***      0                                  0               $fh = *STDIN;
1749  ***      0                                  0               MKDEBUG && _d('Reading STDIN');
1750                                                           }
1751                                                           else {
1752          19                                406               $fh = new IO::File "< $file";
1753  ***     19     50                        2986               if ( !$fh ) {
1754  ***      0                                  0                  warn "Cannot open $file: $OS_ERROR\n";
1755  ***      0                                  0                  next FILE;
1756                                                              }
1757          19                                 74               my $pos = 0;
1758          19    100                          81               if ( $resume ) {
1759           5                                 19                  $pos = $resume->{pos};
1760           5                                 56                  print "Resuming $file at position $pos\n";
1761                                                              }
1762          19    100                         113               $fh->seek($pos, SEEK_SET) if $pos;
1763          19                                 74               MKDEBUG && _d('Reading', $file, 'at pos', $pos);
1764                                                  
1765                                                              # Reset these var in case we read two logs out of order by time.
1766          19                                 54               $past_since = 0;
1767          19                                 63               $at_until   = 0;
1768                                                           }
1769                                                        }
1770                                                  
1771         285                                704         eval {
1772                                                           # Run events through the pipeline.  The first pipeline process
1773                                                           # is usually responsible for getting the next event.  The pipeline
1774                                                           # stops if a process does not return the event.  This main loop
1775                                                           # stops if a process sets oktorun to false; it usually does this
1776                                                           # when there are no more events, but it may do it for other reasons.
1777         285                                872            my $event       = {};
1778         285                                749            my $more_events = 1;
1779         285                   19          1439            my $oktorun_sub = sub { $more_events = $_[0]; };
              19                                 62   
1780         285                                975            foreach my $process ( @pipeline ) {
1781  ***    632     50                        2196               last unless $oktorun;  # the global oktorun var
1782         632                               2581               $event = $process->(
1783                                                                 event   => $event,
1784                                                                 oktorun => $oktorun_sub,
1785                                                                 fh      => $fh,
1786                                                              );
1787         632    100                        2788               last unless $event;
1788                                                           }
1789         285    100                        1874            if ( !$more_events ) {
1790          19                                 45               MKDEBUG && _d('No more events');
1791  ***     19     50                          77               if ( $fh ) {
1792          19    100                          89                  $resume->{pos} = tell $fh if $resume;
1793          19                                161                  close $fh;
1794          19                                 98                  $fh = undef;
1795                                                              }
1796                                                           }
1797                                                        };
1798  ***    285     50                        1291         if ( $EVAL_ERROR ) {
1799  ***      0                                  0            warn $EVAL_ERROR;
1800  ***      0                                  0            _d($EVAL_ERROR);
1801                                                  
1802                                                           # Don't ignore failure to open a file, else we'll get
1803                                                           # "tell() on closed filehandle" errors.
1804                                                           # Hm, I don't think we need this any longer...
1805                                                           # last FILE if $EVAL_ERROR =~ m/Cannot open/;
1806                                                  
1807  ***      0      0                           0            last FILE unless $o->get('continue-on-error');
1808                                                        }
1809                                                     }  # FILE
1810                                                  
1811          19    100                         101      save_resume($resume, $resume->{resume_file}) if $resume;
1812                                                  
1813                                                     # ##########################################################################
1814                                                     # Do the report.
1815                                                     # ##########################################################################
1816          19                                245      my $reporter = new ReportFormatter(
1817                                                        line_prefix => '',
1818                                                     );
1819          19                                302      $reporter->set_columns(
1820                                                        { name => 'Count',   right_justify => 1,              },
1821                                                        { name => 'Level',                                    },
1822                                                        { name => 'Message', fixed_width => 60, truncate => 1 },
1823                                                     );
1824                                                  
1825                                                     # Save patterns while doing the report.  Re-uses $fh.
1826          19                                 55      my @patterns;
1827  ***     19     50                          95      if ( my $file = $o->get('save-patterns') ) {
1828  ***      0      0                           0         open $fh, '>', $file or die "Cannot write to $file: $OS_ERROR";
1829  ***      0                                  0         @patterns = $matcher->patterns;
1830                                                     }
1831                                                  
1832          19                                100      my @names  = $matcher->names;
1833          19                                142      my @levels = $matcher->levels;
1834                                                  
1835          19                                 70      foreach my $pno ( sort { $cnt{$b} <=> $cnt{$a} } keys %cnt ) {
             253                                760   
1836  ***    119            50                 1013         $reporter->add_line($cnt{$pno}, $levels[$pno] || '', $names[$pno] || '');
      ***                   50                        
1837                                                  
1838                                                        # Print the pattern to the --save-patterns file.
1839  ***    119     50                         475         if ( $fh ) {
1840  ***      0                                  0            print $fh "$names[$pno]\n$levels[$pno]\n$patterns[$pno]\n\n";
1841                                                        }
1842                                                     }
1843                                                  
1844          19                                132      print $reporter->get_report();
1845                                                  
1846  ***     19     50                          83      close $fh if $fh;
1847                                                  
1848          19                               2267      return 0;
1849                                                  }
1850                                                  
1851                                                  # ##########################################################################
1852                                                  # Subroutines
1853                                                  # ##########################################################################
1854                                                  
1855                                                  # ##########################################################################
1856                                                  # This is a good place to add your own rules to match log events you're
1857                                                  # familiar with.  Each pattern/rule is a name, level and regular expression.
1858                                                  # The name will be printed out in the output, so make it representative of
1859                                                  # the log event.
1860                                                  # ##########################################################################
1861                                                  sub load_known_patterns {
1862          19                   19            99      my ( $matcher ) = @_;
1863          19                                 52      MKDEBUG && _d('Loading known patterns');
1864          19                                664      my @known_patterns = (
1865                                                        [ 'mysqld started',
1866                                                          'info',
1867                                                          'mysqld started'
1868                                                        ],
1869                                                        [ 'mysqld ended',
1870                                                           'info',
1871                                                           'mysqld ended'
1872                                                        ],
1873                                                        [ 'mysqld version info',
1874                                                           'info',
1875                                                           '^Version: \S+ '
1876                                                        ],
1877                                                        [ 'mysqladmin debug memory status',
1878                                                           'info',
1879                                                           '^Memory status:'
1880                                                        ],
1881                                                        [ 'mysqladmin debug',
1882                                                           'info',
1883                                                           '^Status information:'
1884                                                        ],
1885                                                        [ 'InnoDB: Started',
1886                                                           'info',
1887                                                           '^InnoDB: Started; log sequence number'
1888                                                        ],
1889                                                        [ 'InnoDB: Starting an apply batch',
1890                                                           'info',
1891                                                           '^InnoDB: Starting an apply batch of log'
1892                                                        ],
1893                                                        [ 'InnoDB: Starting log scan',
1894                                                           'info',
1895                                                           '^InnoDB: Starting log scan based on'
1896                                                        ],
1897                                                        [ 'InnoDB: Database was not shut down properly!',
1898                                                           'error',
1899                                                           '^InnoDB: Database was not shut down'
1900                                                        ],
1901                                                        [ 'InnoDB: Starting shutdown',
1902                                                           'info',
1903                                                           '^InnoDB: Starting shutdown...'
1904                                                        ],
1905                                                        [ 'InnoDB: Shutdown completed',
1906                                                           'info',
1907                                                           '^InnoDB: Shutdown completed;'
1908                                                        ],
1909                                                        [ 'InnoDB: Rolling back trx',
1910                                                           'info',
1911                                                           '^InnoDB: Rolling back trx with id',
1912                                                        ],
1913                                                        [  'mysqld got signal',
1914                                                           'error',
1915                                                           'mysqld got signal \d',
1916                                                        ],
1917                                                        [  'InnoDB: Assertion failure',
1918                                                           'error',
1919                                                           'InnoDB: Assertion failure in thread',
1920                                                        ],
1921                                                        [  'InnoDB: Log file did not exist!',
1922                                                           'info',
1923                                                           'InnoDB: Log file .*? did not exist',
1924                                                        ],
1925                                                        [  'InnoDB: Setting file size',
1926                                                           'info',
1927                                                           'InnoDB: Setting file \S+ size',
1928                                                        ],
1929                                                        [  'InnoDB: The first specified data file did not exist!',
1930                                                           'info',
1931                                                           'InnoDB: The first specified data file \S+',
1932                                                        ],
1933                                                        [  'InnoDB: Warning: cannot find a free slot',
1934                                                           'warning',
1935                                                           'InnoDB: Warning: cannot find a free slot',
1936                                                        ],
1937                                                        [  'InnoDB: Rolling back of trx complete',
1938                                                           'info',
1939                                                           'InnoDB: Rolling back of trx id .*?complete',
1940                                                        ],
1941                                                        [  'mysqld restarted',
1942                                                           'info',
1943                                                           'mysqld restarted',
1944                                                        ],
1945                                                     );
1946          19                                159      $matcher->add_patterns(\@known_patterns);
1947          19                                192      return;
1948                                                  }
1949                                                  
1950                                                  sub check_resume {
1951          10                   10            79      my ( $resume, $file ) = @_;
1952  ***     10     50     33                  216      die "I need a resume argument" unless $resume && ref $resume eq 'HASH';
1953  ***     10     50                          54      die "I need a file argument" unless $file;
1954                                                  
1955          10    100                         108      if ( !-f $file ) {
1956                                                        # Caller should catch this eventually so we dont' need to do anything.
1957           1                                  7         MKDEBUG && _d('File', $file, 'does not exist');
1958           1                                 12         return $resume;
1959                                                     }
1960                                                  
1961           9                                 80      my $file_inode = (stat($file))[1];
1962           9                                 57      my $file_size  = -s $file;
1963           9                                 27      MKDEBUG && _d('Current file size:', $file_size, 'inode:', $file_inode);
1964                                                  
1965           9    100    100                  155      if ( $resume->{file} ne $file || $resume->{inode} != $file_inode ) {
1966           3                                 17         MKDEBUG && _d('Resume file', $resume->{file}, $resume->{inode},
1967                                                           'is not the same as file', $file, $file_inode);
1968                                                  
1969                                                        # Save old resume info.
1970           3                                 50         save_resume($resume, $resume->{resume_file} . '-' . $resume->{inode});
1971                                                  
1972                                                        # Update and save current resume info.
1973           3                                 39         $resume->{file}  = $file;
1974           3                                 19         $resume->{inode} = $file_inode;
1975           3                                 12         $resume->{pos}   = 0;
1976           3                                 11         $resume->{size}  = $file_size;
1977           3                                 15         save_resume($resume, $resume->{resume_file});
1978                                                     }
1979                                                  
1980           9    100    100                  117      if ( ($resume->{size} || 0) > ($file_size || 0) ) {
      ***                   50                        
1981                                                        # This could happen if the file is truncated.
1982           2                                 61         warn "Resume file size $resume->{size} is less than "
1983                                                           . "current file size $file_size; will parse the entire file";
1984           2                                 13         $resume->{pos}  = 0;
1985                                                     }
1986           9                                 38      $resume->{size} = $file_size;
1987                                                  
1988           9                                101      return $resume;
1989                                                  }
1990                                                  
1991                                                  sub save_resume {
1992          11                   11            66      my ( $resume, $file ) = @_;
1993  ***     11     50     33                  152      die "I need a resume argument" unless $resume && ref $resume eq 'HASH';
1994  ***     11     50                          45      die "I need a file argument" unless $file;
1995                                                  
1996  ***     11     50                        1079      open my $fh, '>', $file or die "Cannot open resume file $file: $OS_ERROR";
1997          11                                 73      foreach my $prop ( qw(file inode pos size) ) {
1998  ***     44     50                         214         next unless defined $resume->{$prop};
1999  ***     44     50                         379         print $fh "$prop:$resume->{$prop}\n"
2000                                                           or die "Cannot print to $file: $OS_ERROR";
2001                                                     }
2002          11                                575      close $fh;
2003          11                                 31      return;
2004                                                  }
2005                                                  
2006                                                  # Catches signals so we can exit gracefully.
2007                                                  sub sig_int {
2008  ***      0                    0                    my ( $signal ) = @_;
2009  ***      0      0                                  if ( $oktorun ) {
2010  ***      0                                            print STDERR "# Caught SIG$signal.\n";
2011  ***      0                                            $oktorun = 0;
2012                                                     }
2013                                                     else {
2014  ***      0                                            print STDERR "# Exiting on SIG$signal.\n";
2015  ***      0                                            exit 1;
2016                                                     }
2017                                                  }
2018                                                  
2019                                                  sub _d {
2020  ***      0                    0                    my ($package, undef, $line) = caller 0;
2021  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2022  ***      0                                              map { defined $_ ? $_ : 'undef' }
2023                                                          @_;
2024  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2025                                                  }
2026                                                  
2027                                                  # ############################################################################
2028                                                  # Run the program.
2029                                                  # ############################################################################
2030                                                  if ( !caller ) { exit main(@ARGV); }
2031                                                  
2032                                                  1; # Because this is a module as well as a script.
2033                                                  
2034                                                  # ############################################################################
2035                                                  # Documentation
2036                                                  # ############################################################################
2037                                                  
2038                                                  =pod
2039                                                  
2040                                                  =head1 NAME
2041                                                  
2042                                                  mk-error-log - Find new and different MySQL error log entries.
2043                                                  
2044                                                  =head1 SYNOPSIS
2045                                                  
2046                                                  Analyze and report on an error log:
2047                                                  
2048                                                    mk-error-log error.log
2049                                                  
2050                                                  =head1 RISKS
2051                                                  
2052                                                  The following section is included to inform users about the potential risks,
2053                                                  whether known or unknown, of using this tool.  The two main categories of risks
2054                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2055                                                  tools) and those created by bugs.
2056                                                  
2057                                                  mk-error-log merely reads files given on the command line, and should be very
2058                                                  low-risk.
2059                                                  
2060                                                  At the time of this release, we know of no bugs that could cause serious harm to
2061                                                  users.
2062                                                  
2063                                                  The authoritative source for updated information is always the online issue
2064                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2065                                                  see a list of such issues at the following URL:
2066                                                  L<http://www.maatkit.org/bugs/mk-error-log>.
2067                                                  
2068                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2069                                                  
2070                                                  =head1 DESCRIPTION
2071                                                  
2072                                                  mk-error-log parses MySQL error logs, finding new and different entries, and
2073                                                  reports on the frequency and severity of each common entry.  Regex patterns are
2074                                                  used to detect and group common entries.  These patterns are auto-created by
2075                                                  mk-error-log when an entry does not match any known patterns.  mk-error-log
2076                                                  has a built-in list of known patterns; see L<"--[no]known-patterns">.  You
2077                                                  can also supply your own patterns with the L<"--load-patterns"> option.
2078                                                  
2079                                                  =head1 OUTPUT
2080                                                  
2081                                                  The output is a simple tabular list of error log entires:
2082                                                  
2083                                                    Count Level   Message                                           
2084                                                    ===== ======= ==================================================
2085                                                        5 info    mysqld started                                    
2086                                                        4 info    mysqld version info                               
2087                                                        3 info    InnoDB: Started                                   
2088                                                        2 info    mysqld ended                                      
2089                                                        1 unknown Number of processes running now: 0                
2090                                                        1 error   [ERROR] /usr/sbin/mysqld: unknown variable 'ssl-ke
2091                                                        1 error   [ERROR] Failed to initialize the master info struc
2092                                                  
2093                                                  The log entries (Message) are usually truncated; the full entrie is not
2094                                                  always shown.
2095                                                  
2096                                                  =head1 OPTIONS
2097                                                  
2098                                                  =over
2099                                                  
2100                                                  =item --ask-pass
2101                                                  
2102                                                  Prompt for a password when connecting to MySQL.
2103                                                  
2104                                                  =item --charset
2105                                                  
2106                                                  short form: -A; type: string
2107                                                  
2108                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2109                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
2110                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
2111                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
2112                                                  connecting to MySQL.
2113                                                  
2114                                                  =item --config
2115                                                  
2116                                                  type: Array
2117                                                  
2118                                                  Read this comma-separated list of config files; if specified, this must be the
2119                                                  first option on the command line.
2120                                                  
2121                                                  =item --[no]continue-on-error
2122                                                  
2123                                                  default: yes
2124                                                  
2125                                                  Continue parsing even if there is an error.
2126                                                  
2127                                                  =item --defaults-file
2128                                                  
2129                                                  short form: -F; type: string
2130                                                  
2131                                                  Only read mysql options from the given file.  You must give an absolute
2132                                                  pathname.
2133                                                  
2134                                                  =item --help
2135                                                  
2136                                                  Show help and exit.
2137                                                  
2138                                                  =item --host
2139                                                  
2140                                                  short form: -h; type: string
2141                                                  
2142                                                  Connect to host.
2143                                                  
2144                                                  =item --[no]known-patterns
2145                                                  
2146                                                  default: yes
2147                                                  
2148                                                  Load known, built-in patterns.
2149                                                  
2150                                                  mk-error-log has a built-in list of known patterns.  This are normally loaded
2151                                                  by default, but if you don't want them to be used you can disable them from
2152                                                  being loaded by specifying C<--no-known-patterns>.
2153                                                  
2154                                                  =item --load-patterns
2155                                                  
2156                                                  type: string
2157                                                  
2158                                                  Load a list of known patterns from this file.
2159                                                  
2160                                                  Patterns in the file should be formatted like this:
2161                                                  
2162                                                    name1
2163                                                    level1
2164                                                    pattern1
2165                                                  
2166                                                    nameN
2167                                                    levelN
2168                                                    patternN
2169                                                  
2170                                                  Each pattern has three parts: name, level and regex pattern.
2171                                                  Patterns are separated by a blank line.  A pattern's name is what is printed
2172                                                  under the Message column in the L<"OUTPUT">.  Likewise, its level is printed
2173                                                  under the Level column.  The regex pattern is what mk-error-log uses to
2174                                                  match this pattern.  Any Perl regular expression should be valid.
2175                                                  
2176                                                  Here is a simple example:
2177                                                  
2178                                                    InnoDB: The first specified data file did not exist!
2179                                                    info
2180                                                    InnoDB: The first specified data file \S+
2181                                                  
2182                                                    InnoDB: Rolling back of trx complete
2183                                                    info
2184                                                    InnoDB: Rolling back of trx id .*?complete
2185                                                  
2186                                                  See also L<"--save-patterns">.
2187                                                  
2188                                                  =item --password
2189                                                  
2190                                                  short form: -p; type: string
2191                                                  
2192                                                  Password to use when connecting.
2193                                                  
2194                                                  =item --pid
2195                                                  
2196                                                  type: string
2197                                                  
2198                                                  Create the given PID file when daemonized.  The file contains the process
2199                                                  ID of the daemonized instance.  The PID file is removed when the
2200                                                  daemonized instance exits.  The program checks for the existence of the
2201                                                  PID file when starting; if it exists and the process with the matching PID
2202                                                  exists, the program exits.
2203                                                  
2204                                                  =item --port
2205                                                  
2206                                                  short form: -P; type: int
2207                                                  
2208                                                  Port number to use for connection.
2209                                                  
2210                                                  =item --resume
2211                                                  
2212                                                  type: string
2213                                                  
2214                                                  Read and write resume position to this file; resume parsing from last position.
2215                                                  
2216                                                  By default mk-error-log parses an error logs from start (pos 0) to finish.
2217                                                  This option allows the tool to start parsing an error log from where it
2218                                                  last ended as long as the file has the same name and inode (e.g. it hasn't
2219                                                  been rotated) and its size is larger.  If the log file's name or inode is
2220                                                  different, then a new resume file is started and the old resume file is
2221                                                  saved with the old error log's inode appended to its file name.  If the log
2222                                                  file's size is smaller (e.g. the log was truncated), then parsing begins
2223                                                  from the start.
2224                                                  
2225                                                  A resume file is a simple, four line text file like:
2226                                                  
2227                                                    file:/path/to/err.log
2228                                                    inode:12345
2229                                                    pos:67890
2230                                                    size:987100
2231                                                  
2232                                                  The resume file is read at startup and updated when mk-error-log finishes
2233                                                  parsing the log.  Note that CTRL-C prevents the resume file from being updated.
2234                                                  
2235                                                  If the resume file doesn't exist it is created.
2236                                                  
2237                                                  A line is printed before the main report which tells when and at what position
2238                                                  parsing began for the error log if it was resumed.
2239                                                  
2240                                                  =item --save-patterns
2241                                                  
2242                                                  type: string
2243                                                  
2244                                                  After running save all new and old patterns to this file.
2245                                                  
2246                                                  This option causes mk-error-log to save every pattern it has to the file.
2247                                                  This file can be used for subsequent runs with L<"--load-patterns">.  The
2248                                                  patterns are saved in descending order of frequency, so the most frequent
2249                                                  patterns are at top.
2250                                                  
2251                                                  =item --set-vars
2252                                                  
2253                                                  type: string; default: wait_timeout=10000
2254                                                  
2255                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2256                                                  will be appended to SET and executed.
2257                                                  
2258                                                  =item --since
2259                                                  
2260                                                  type: string
2261                                                  
2262                                                  Parse only events newer than this value (parse events since this date).
2263                                                  
2264                                                  This option allows you to ignore events older than a certain value and parse
2265                                                  only those events which are more recent than the value.  The value can be
2266                                                  several types:
2267                                                  
2268                                                    * Simple time value N with optional suffix: N[shmd], where
2269                                                      s=seconds, h=hours, m=minutes, d=days (default s if no suffix
2270                                                      given); this is like saying "since N[shmd] ago"
2271                                                    * Full date with optional hours:minutes:seconds: YYYY-MM-DD [HH:MM::SS]
2272                                                    * Short, MySQL-style date: YYMMDD [HH:MM:SS]
2273                                                  
2274                                                  Events are assumed to be in chronological--older events at the beginning of
2275                                                  the log and newer events at the end of the log.  L<"--since"> is strict: it
2276                                                  ignores all events until one is found that is new enough.  Therefore, if
2277                                                  the events are not consistently timestamped, some may be ignored which
2278                                                  are actually new enough.
2279                                                  
2280                                                  See also L<"--until">.
2281                                                  
2282                                                  =item --socket
2283                                                  
2284                                                  short form: -S; type: string
2285                                                  
2286                                                  Socket file to use for connection.
2287                                                  
2288                                                  =item --until
2289                                                  
2290                                                  type: string
2291                                                  
2292                                                  Parse only events older than this value (parse events until this date).
2293                                                  
2294                                                  This option allows you to ignore events newer than a certain value and parse
2295                                                  only those events which are older than the value.  The value can be one of
2296                                                  the same types listed for L<"--since">.
2297                                                  
2298                                                  Unlike L<"--since">, L<"--until"> is not strict: all events are parsed until
2299                                                  one has a timestamp that is equal to or greater than L<"--until">.  Then
2300                                                  all subsequent events are ignored.
2301                                                  
2302                                                  =item --user
2303                                                  
2304                                                  short form: -u; type: string
2305                                                  
2306                                                  User for login if not current user.
2307                                                  
2308                                                  =item --version
2309                                                  
2310                                                  Show version and exit.
2311                                                  
2312                                                  =back
2313                                                  
2314                                                  =head1 DOWNLOADING
2315                                                  
2316                                                  You can download Maatkit from Google Code at
2317                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2318                                                  easily with a command like the following:
2319                                                  
2320                                                     wget http://www.maatkit.org/get/toolname
2321                                                     or
2322                                                     wget http://www.maatkit.org/trunk/toolname
2323                                                  
2324                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2325                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2326                                                  needed.  The first URL gets the latest released version of the tool, and the
2327                                                  second gets the latest trunk code from Subversion.
2328                                                  
2329                                                  =head1 ENVIRONMENT
2330                                                  
2331                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2332                                                  the Maatkit tools:
2333                                                  
2334                                                     MKDEBUG=1 mk-....
2335                                                  
2336                                                  =head1 SYSTEM REQUIREMENTS
2337                                                  
2338                                                  You need the following Perl modules: DBI and DBD::mysql.
2339                                                  
2340                                                  =head1 BUGS
2341                                                  
2342                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-error-log>.
2343                                                  
2344                                                  Please use Google Code Issues and Groups to report bugs or request support:
2345                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2346                                                  discuss Maatkit.
2347                                                  
2348                                                  Please include the complete command-line used to reproduce the problem you are
2349                                                  seeing, the version of all MySQL servers involved, the complete output of the
2350                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2351                                                  running with the C<MKDEBUG=1> environment variable.
2352                                                  
2353                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2354                                                  
2355                                                  This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
2356                                                  Feedback and improvements are welcome.
2357                                                  
2358                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2359                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2360                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2361                                                  
2362                                                  This program is free software; you can redistribute it and/or modify it under
2363                                                  the terms of the GNU General Public License as published by the Free Software
2364                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2365                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2366                                                  licenses.
2367                                                  
2368                                                  You should have received a copy of the GNU General Public License along with
2369                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2370                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2371                                                  
2372                                                  =head1 AUTHOR
2373                                                  
2374                                                  Daniel Nichter
2375                                                  
2376                                                  =head1 ABOUT MAATKIT
2377                                                  
2378                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2379                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2380                                                  code contributors.  Both are employed by Percona.  Financial support for
2381                                                  Maatkit development is primarily provided by Percona and its clients. 
2382                                                  
2383                                                  =head1 VERSION
2384                                                  
2385                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5796 $.
2386                                                  
2387                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
55    ***     50      0     19   unless $args{$arg}
61    ***     50     19      0   exists $args{'strict'} ? :
104   ***     50      0     19   unless open my $fh, '<', $file
124          100   5263     19   unless $para =~ /^=head1 OPTIONS/
129   ***     50     19      0   if $para =~ /^=over/
137   ***     50      0     19   unless $para
140          100    380     19   if (my($option) = $para =~ /^=item --(.*)/)
147          100    323     57   if ($para =~ /: /) { }
151   ***     50      0    475   unless $attributes{$attrib}
155          100    133    190   if ($attribs{'short form'})
171   ***     50      0    380   if $para =~ /^=item/
173          100     38    342   if (my($base_option) = $option =~ /^\[no\](.*)/)
178          100    133    247   $attribs{'short form'} ? :
             100     38    342   $attribs{'negatable'} ? :
      ***     50      0    380   $attribs{'cumulative'} ? :
             100    285     95   $attribs{'type'} ? :
             100     57    323   $attribs{'default'} ? :
      ***     50      0    380   $attribs{'group'} ? :
190   ***     50      0    836   unless $para
193          100     19    817   if ($para =~ /^=head1/)
197          100    380    437   if $para =~ /^=item --/
201   ***     50      0     19   unless @specs
212   ***     50    380      0   if (ref $opt) { }
217   ***     50      0    380   if (not $long)
222   ***     50      0    380   if exists $$self{'opts'}{$long}
225   ***     50      0    380   if (length $long == 1)
230          100    133    247   if ($short) { }
231   ***     50      0    133   if exists $$self{'short_opts'}{$short}
240          100     38    342   $$opt{'spec'} =~ /!/ ? :
241   ***     50      0    380   $$opt{'spec'} =~ /\+/ ? :
242   ***     50      0    380   $$opt{'desc'} =~ /required/ ? :
254   ***     50      0    380   if ($type and $type eq 'd' and not $$self{'dp'})
259          100     19    361   if $type and $type =~ /[HhAadzm]/
261          100     57    323   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
262   ***     50     57      0   defined $def ? :
266          100     19    361   if ($long eq 'config')
270   ***     50      0    380   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
283   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
288   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
293   ***      0      0      0   if ($opt =~ /default to/)
298   ***      0      0      0   if ($opt =~ /restricted to option groups/)
308   ***      0      0      0   unless $rule_ok
325   ***      0      0      0   unless exists $$self{'opts'}{$long}
349   ***      0      0      0   unless exists $$self{'opts'}{$long}
369   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     10      0   exists $$self{'opts'}{$opt} ? :
374   ***     50      0     10   if ($$opt{'is_cumulative'}) { }
389   ***     50      0    304   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     76    304   exists $$self{'defaults'}{$long} ? :
398   ***     50      0     19   if (@ARGV and $ARGV[0] eq '--config')
402   ***     50     19      0   if ($self->has('config'))
408   ***     50     76      0   if ($EVAL_ERROR)
409   ***     50      0     76   $self->got('config') ? :
424   ***     50      0     19   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
427   ***     50      0     19   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
428   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
434   ***     50      0     19   if (@ARGV and $$self{'strict'})
440   ***      0      0      0   if (@set > 1)
451   ***      0      0      0   if (@set == 0)
461          100     10    370   if ($$opt{'got'}) { }
      ***     50      0    370   elsif ($$opt{'is_required'}) { }
462   ***     50      0     10   if (exists $$self{'disables'}{$long})
469   ***     50      0     10   if (exists $$self{'allowed_groups'}{$long})
481   ***      0      0      0   if $restricted_opt eq $long
482   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
487   ***      0      0      0   if (@restricted_opts)
489   ***      0      0      0   if (@restricted_opts == 1) { }
518          100     95    285   unless $opt and $$opt{'type'}
521   ***     50      0    285   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    285   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    285   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0    285   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     19    266   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
524   ***      0      0      0   if (not $suffix)
530   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
531   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
546   ***      0      0      0   if ($from_key)
557   ***      0      0      0   if (defined $num) { }
558   ***      0      0      0   if ($factor)
585   ***     50      0    157   length $opt == 1 ? :
586   ***     50      0    157   unless $long and exists $$self{'opts'}{$long}
593   ***     50      0     76   length $opt == 1 ? :
594   ***     50      0     76   unless $long and exists $$self{'opts'}{$long}
601   ***     50      0     19   length $opt == 1 ? :
602   ***     50     19      0   defined $long ? :
607   ***      0      0      0   length $opt == 1 ? :
608   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
635   ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
643   ***     50      0     19   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0     19   elsif (scalar @{$$self{'errors'};}) { }
644   ***      0      0      0   unless print $self->print_usage
648   ***      0      0      0   unless print $self->print_errors
657   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
666   ***      0      0      0   unless $$self{'got_opts'}
669   ***      0      0      0   $$_{'is_negatable'} ? :
673   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
689   ***      0      0      0   $group eq 'default' ? :
695   ***      0      0      0   $$opt{'is_negatable'} ? :
698   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
707   ***      0      0      0   if ($short) { }
716   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
720   ***      0      0      0   if ($$self{'dp'})
728   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
740   ***      0      0      0   if ref $_[0] eq 'OptionParser'
743   ***      0      0      0   unless print $prompt
751   ***      0      0      0   unless print "\n"
754   ***      0      0      0   if ($EVAL_ERROR)
776   ***     50     76      0   unless open my $fh, '<', $filename
784   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
787   ***      0      0      0   if ($line eq '--')
792   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
810   ***      0      0      0   unless open my $fh, '<', $file
814   ***      0      0      0   unless $para =~ /^=pod$/m
818   ***      0      0      0   unless $para =~ /$regex/
823   ***      0      0      0   unless close $fh
837   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
852   ***      0      0      0   defined $_ ? :
885   ***      0      0      0   unless $args{$arg}
907   ***     50      0     57   unless defined $$col{'name'}
908   ***     50      0     57   if ($$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'})
923   ***     50      0    119   unless $n_cols == $n_vals
931   ***     50      0    357   if ($$col{'fixed_width'} and $width > $$col{'fixed_width'})
932   ***      0      0      0   if ($$col{'truncate'}) { }
954   ***     50      0     19   $$self{'long_last_column'} ? :
961          100     19     38   $$col{'right_justify'} ? :
967   ***     50      0     19   if ($$self{'long_last_column'})
973   ***     50      0     19   if $$self{'title'}
978   ***     50     19      0   if ($$self{'underline_header'})
986   ***     50      0     19   if ($$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'})
1004  ***      0      0      0   defined $_ ? :
1053  ***     50      0    285   unless $args{$arg}
1063         100     44    266   if $line =~ /^\s*$/
1068         100    232     34   if (my($ts) = $line =~ /^$ts/o)
1075         100    114    152   if (($level) = $line =~ /\[((?:ERROR|Warning|Note))\]/) { }
1076         100     25     56   $level =~ /warning/i ? :
             100     33     81   $level =~ /error/i ? :
1086         100      6    260   if (my($level) = $line =~ /InnoDB: Error/)
1096         100     66    200   if ($line =~ /$ml/o) { }
             100      1    199   elsif ($line =~ /\bQuery: '/) { }
1103         100    342   3158   if $next_line eq ''
1118         100      1      2   if $next_line =~ /, Error_code:/
1132  ***     50     19      0   if $args{'oktorun'}
1138  ***      0      0      0   defined $_ ? :
1180  ***     50      0    450   unless $p and scalar @$p
1199  ***      0      0      0   if (not $name && $level && $regex)
1203  ***      0      0      0   if ($seen{$name}++)
1241  ***     50      0    157   unless $args{$arg}
1245  ***     50      0    157   unless $err
1247  ***     50      0    157   if ($$self{'QueryRewriter'} and my($query) = $err =~ /Statement: (.+)$/)
1258         100     87   2525   if ($err =~ /$$compiled[$i]/)
1264         100     87     70   if (defined $pno) { }
1269  ***     50      0     87   if (not $$event{'Level'} and $$self{'levels'}[$pno])
1300  ***      0      0      0   defined $_ ? :
1348  ***      0      0      0   defined $args{'p_ms'} ? :
1349  ***      0      0      0   defined $args{'p_s'} ? :
1352  ***      0      0      0   if $t < 0
1354  ***      0      0      0   if $t =~ /e/
1358  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1379  ***      0      0      0   $p ? :
1386  ***      0      0      0   unless $secs
1388  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1393  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1412  ***      0      0      0   defined $args{'p'} ? :
1413  ***      0      0      0   defined $args{'d'} ? :
1420  ***      0      0      0   $num =~ /\./ || $n ? :
1429  ***      0      0      0   $gmt ? :
1435  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
1445  ***     50    164      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1448  ***     50      0    164   defined $f ? :
      ***     50      0    164   defined $f ? :
1457  ***     50    165      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
1458  ***     50      0    165   $gmt ? :
1461  ***     50      0    165   if (defined $us)
1473  ***     50      0    165   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
             100    164      1   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***     50      1      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
1474  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1484         100      2    162   unless $hms
1489  ***     50      1      0   unless $hms
1494  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1510  ***      0      0      0   defined $_ ? :
1563         100      5     14   if ($o->get('resume'))
1564  ***     50      0      5   if (@ARGV == 0)
1567  ***     50      0      5   if (@ARGV > 1)
1583  ***     50      0     19   if (my $file = $o->get('load-patterns'))
1585  ***      0      0      0   unless open my $fh, '<', $file
1588  ***     50     19      0   if $o->get('known-patterns')
1594         100      5     14   if (my $resume_file = $o->get('resume'))
1605         100      1      4   if (not -f $resume_file)
1609  ***     50      0      5   unless open my $resume_fh, '<', $resume_file
1614         100      4      1   if ($resume_info) { }
1632  ***     50      0      5   unless $$resume{'file'}
1634  ***     50      0      5   unless defined $$resume{'inode'}
1636  ***     50      0      5   unless defined $$resume{'pos'}
1660         100     11    274   if $resume and $event
1667         100      3     16   if ($o->get('since'))
1669  ***     50      0      3   unless $since
1674         100      4    110   if ($past_since)
1678         100     95     15   if ($$event{'ts'})
1680         100      3     92   if (($ts || 0) >= $since) { }
1692         100      2     17   if ($o->get('until'))
1694  ***     50      0      2   unless $until
1699         100      1     75   if ($at_until)
1703         100     65     10   if ($$event{'ts'})
1705         100      1     64   if (($ts || 0) >= $until) { }
1722  ***     50      0    157   unless $args{'event'}
1734  ***     50      0     19   if (@ARGV == 0)
1740         100     38    266   if (not $fh)
1742         100     19     19   if (not $file)
1747  ***     50      0     19   if ($file eq '-') { }
1753  ***     50      0     19   if (not $fh)
1758         100      5     14   if ($resume)
1762         100      2     17   if $pos
1781  ***     50      0    632   unless $oktorun
1787         100    128    504   unless $event
1789         100     19    266   if (not $more_events)
1791  ***     50     19      0   if ($fh)
1792         100      5     14   if $resume
1798  ***     50      0    285   if ($EVAL_ERROR)
1807  ***      0      0      0   unless $o->get('continue-on-error')
1811         100      5     14   if $resume
1827  ***     50      0     19   if (my $file = $o->get('save-patterns'))
1828  ***      0      0      0   unless open $fh, '>', $file
1839  ***     50      0    119   if ($fh)
1846  ***     50      0     19   if $fh
1952  ***     50      0     10   unless $resume and ref $resume eq 'HASH'
1953  ***     50      0     10   unless $file
1955         100      1      9   if (not -f $file)
1965         100      3      6   if ($$resume{'file'} ne $file or $$resume{'inode'} != $file_inode)
1980         100      2      7   if (($$resume{'size'} || 0) > ($file_size || 0))
1993  ***     50      0     11   unless $resume and ref $resume eq 'HASH'
1994  ***     50      0     11   unless $file
1996  ***     50      0     11   unless open my $fh, '>', $file
1998  ***     50      0     44   unless defined $$resume{$prop}
1999  ***     50      0     44   unless print $fh "${prop}:$$resume{$prop}\n"
2009  ***      0      0      0   if ($oktorun) { }
2021  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
1180  ***     50      0    450   $p and scalar @$p

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
254   ***     66     95    285      0   $type and $type eq 'd'
      ***     33    380      0      0   $type and $type eq 'd' and not $$self{'dp'}
259          100     95    266     19   $type and $type =~ /[HhAadzm]/
398   ***     33      0     19      0   @ARGV and $ARGV[0] eq '--config'
427   ***     33      0     19      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
434   ***     33      0     19      0   @ARGV and $$self{'strict'}
518   ***     66      0     95    285   $opt and $$opt{'type'}
521   ***     66    237     48      0   $val and $$opt{'type'} eq 'm'
      ***     66    237     48      0   $val and $$opt{'type'} eq 'd'
      ***     66    237     48      0   $val and $$opt{'type'} eq 'z'
      ***     66    237     48      0   defined $val and $$opt{'type'} eq 'h'
      ***     66    237     29      0   defined $val and $$opt{'type'} eq 'a'
586   ***     33      0      0    157   $long and exists $$self{'opts'}{$long}
594   ***     33      0      0     76   $long and exists $$self{'opts'}{$long}
608   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
698   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
792   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
908   ***     33     57      0      0   $$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'}
931   ***     66    238    119      0   $$col{'fixed_width'} and $width > $$col{'fixed_width'}
986   ***     33      0     19      0   $$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'}
1100         100      2     64   3500   defined($next_line = <$fh>) and not $next_line =~ /^$ts/o
1114  ***     66      1      0      3   not $last_line and defined($next_line = <$fh>)
1199  ***      0      0      0      0   $name && $level
      ***      0      0      0      0   $name && $level && $regex
1247  ***     33    157      0      0   $$self{'QueryRewriter'} and my($query) = $err =~ /Statement: (.+)$/
1269  ***     33     87      0      0   not $$event{'Level'} and $$self{'levels'}[$pno]
1358  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1416  ***      0      0      0      0   $num >= $d and $n < @units - 1
1494  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
1660         100    269      5     11   $resume and $event
1952  ***     33      0      0     10   $resume and ref $resume eq 'HASH'
1993  ***     33      0      0     11   $resume and ref $resume eq 'HASH'

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
39    ***     50      0      4   $ENV{'MKDEBUG'} || 0
59    ***     50     19      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
61    ***     50     19      0   $args{'prompt'} || '<options>'
      ***     50      0     19   $args{'dp'} || undef
103   ***     50      0     19   $file ||= '/home/daniel/dev/maatkit/mk-error-log/mk-error-log'
244   ***     50    380      0   $$opt{'group'} ||= 'default'
526   ***      0      0      0   $s || 's'
535   ***      0      0      0   $prefix || ''
563   ***      0      0      0   $pre || ''
570   ***      0      0      0   $val || ''
573   ***     50     19      0   $val || ''
631   ***      0      0      0   $$self{'description'} || ''
700   ***      0      0      0   $s ||= 's'
726   ***      0      0      0   $$opt{'type'} || ''
874   ***     50      0      4   $ENV{'MKDEBUG'} || 0
952   ***     50      0     19   $$self{'line_prefix'} || ''
1030  ***     50      0      4   $ENV{'MKDEBUG'} || 0
1163  ***     50      0      4   $ENV{'MKDEBUG'} || 0
1324  ***     50      0      4   $ENV{'MKDEBUG'} || 0
1378  ***      0      0      0   $args{'p'} || 0
1380  ***      0      0      0   $of ||= 1
1385  ***      0      0      0   $secs ||= 0
1543  ***     50      0      4   $ENV{'MKDEBUG'} || 0
1680  ***     50     95      0   $ts || 0
1705  ***     50     65      0   $ts || 0
1836  ***     50    119      0   $levels[$pno] || ''
      ***     50    119      0   $names[$pno] || ''
1980         100      8      1   $$resume{'size'} || 0
      ***     50      9      0   $file_size || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
58    ***     33     19      0      0   $program_name ||= $PROGRAM_NAME
59    ***     33     19      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     19      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
521   ***     33      0      0    285   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66     19      0    266   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1062         100     64    246     19   defined($line = shift @$pending) or defined($line = <$fh>)
1388  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1420  ***      0      0      0      0   $num =~ /\./ || $n
1965         100      1      2      6   $$resume{'file'} ne $file or $$resume{'inode'} != $file_inode


Covered Subroutines
-------------------

Subroutine          Count Location                                               
------------------- ----- -------------------------------------------------------
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1021
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1022
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1023
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1025
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1030
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1155
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1156
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1157
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1158
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1163
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1318
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1319
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1320
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1321
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1322
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1324
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1532
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1533
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1534
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1535
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1536
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1543
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1545
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:20  
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:21  
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:32  
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:33  
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:35  
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:36  
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:37  
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:39  
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:869 
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:870 
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:871 
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:872 
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:874 
BEGIN                   4 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:876 
__ANON__              285 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1658
__ANON__              114 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1671
__ANON__               76 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1696
__ANON__              157 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1720
__ANON__               19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1779
__ANON__               10 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:422 
_parse_specs           19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:208 
_pod_to_specs          19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:102 
_read_config_file      76 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:775 
_set_option            10 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:368 
_validate_type        380 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:517 
add_line              119 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:919 
add_patterns           89 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1178
any_unix_timestamp    165 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1471
check_resume           10 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1951
fingerprint            70 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1288
get                   157 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:584 
get_defaults_files     19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:97  
get_opts               19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:385 
get_report             19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:950 
get_specs              19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:90  
got                    76 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:592 
has                    19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:600 
levels                 19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1233
load_known_patterns    19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1862
main                   19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1550
match                 157 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1238
names                  19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1228
new                    19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1041
new                    19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1166
new                    19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:53  
new                    19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:882 
parse_event           285 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1050
parse_timestamp       164 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1444
save_resume            11 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1992
set_columns            19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:904 
unix_timestamp        165 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1456
usage_or_errors        19 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:642 

Uncovered Subroutines
---------------------

Subroutine          Count Location                                               
------------------- ----- -------------------------------------------------------
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1003
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1137
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1299
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1509
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:2020
_d                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:851 
_get_participants       0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:322 
clone                   0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:828 
descr                   0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:630 
errors                  0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:620 
get_defaults            0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:358 
get_groups              0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:363 
load_patterns_file      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1193
make_checksum           0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1502
micro_t                 0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1347
opts                    0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:334 
patterns                0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1223
percentage_of           0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1377
print_errors            0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:655 
print_usage             0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:665 
prompt                  0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:625 
prompt_noecho           0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:740 
read_para_after         0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:809 
reset_patterns          0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1213
save_error              0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:615 
secs_to_time            0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1384
set                     0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:606 
set_defaults            0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:346 
set_title               0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:898 
short_opts              0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:340 
shorten                 0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1411
sig_int                 0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:2008
ts                      0 /home/daniel/dev/maatkit/mk-error-log/mk-error-log:1428


