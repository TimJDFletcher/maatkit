---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...explain/mk-visual-explain   49.6   39.0   37.9   66.1    n/a   24.2   46.4
mk-visual-explain.t           100.0   50.0   33.3  100.0    n/a   75.8   92.0
Total                          51.2   39.1   37.8   68.3    n/a  100.0   47.6
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:46:42 2010
Finish:       Thu Jan 28 22:46:42 2010

Run:          ./explain-output.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:46:43 2010
Finish:       Thu Jan 28 22:46:43 2010

Run:          ./explain-parser.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:46:46 2010
Finish:       Thu Jan 28 22:46:47 2010

Run:          ./explain-to-tree.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:46:52 2010
Finish:       Thu Jan 28 22:46:53 2010

Run:          ./mk-visual-explain.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:46:58 2010
Finish:       Thu Jan 28 22:46:58 2010

/home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     # This is mk-visual-explain, a program to transform MySQL's EXPLAIN output
3                                                     # into a query execution plan formatted as a tree.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22             4                    4            27   use strict;
               4                                 13   
               4                                 35   
23             4                    4            26   use warnings FATAL => 'all';
               4                                 10   
               4                                 32   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # Converts text (e.g. saved output) to a "recordset" -- an array of hashrefs
31                                                    # -- just like EXPLAIN does for selectall_arrayref({}).
32                                                    # ###########################################################################
33                                                    package ExplainParser;
34                                                    
35             4                    4            25   use strict;
               4                                 16   
               4                                 19   
36             4                    4            27   use warnings FATAL => 'all';
               4                                 10   
               4                                 18   
37                                                    
38                                                    sub new {
39            64                   64           599      bless {}, shift;
40                                                    }
41                                                    
42                                                    sub parse_tabular {
43           212                  212          1493      my ( $text, @cols ) = @_;
44           212                                657      my %row;
45           212                               4564      my @vals = $text =~ m/\| +([^\|]*?)(?= +\|)/msg;
46           212    100                        1357      return (undef, \@vals) unless @cols;
47           158                               1469      @row{@cols} = @vals;
48           158                                919      return (\%row, undef);
49                                                    }
50                                                    
51                                                    sub parse_tab_sep {
52            27                   27           187      my ( $text, @cols ) = @_;
53            27                                 87      my %row;
54            27                                254      my @vals = split(/\t/, $text);
55            27    100                         164      return (undef, \@vals) unless @cols;
56            17                                178      @row{@cols} = @vals;
57            17                                 99      return (\%row, undef);
58                                                    }
59                                                    
60                                                    sub parse_vertical {
61             3                    3            20      my ( $text, @cols ) = @_;
62             3                                118      my %row = $text =~ m/^ *(\w+): ([^\n]*) *$/msg;
63             3                                 26      return (\%row, undef);
64                                                    }
65                                                    
66                                                    sub parse {
67            68                   68           509      my ($self, $text) = @_;
68            68                                271      my $started = 0;
69            68                                253      my $lines   = 0;
70            68                                278      my @cols    = ();
71            68                                243      my @result  = ();
72                                                    
73                                                       # Detect which kind of input it is
74            68                                232      my ( $line_re, $vals_sub );
75            68    100                         931      if ( $text =~ m/^\+---/m ) { # standard "tabular" output
                    100                               
                    100                               
76            54                                517         $line_re  = qr/^(\| .*)[\r\n]+/m;
77            54                                296         $vals_sub = \&parse_tabular;
78                                                       }
79                                                       elsif ( $text =~ m/^id\tselect_type\t/m ) { # tab-separated
80            10                                 92         $line_re  = qr/^(.*?\t.*)[\r\n]+/m;
81            10                                 53         $vals_sub = \&parse_tab_sep;
82                                                       }
83                                                       elsif ( $text =~ m/\*\*\* 1. row/ ) { # "vertical" output
84             3                                 31         $line_re  = qr/^( *.*?^ *Extra:[^\n]*$)/ms;
85             3                                 15         $vals_sub = \&parse_vertical;
86                                                       }
87                                                    
88            68    100                         394      if ( $line_re ) {
89                                                          # Pull it apart into lines and parse them.
90                                                          LINE:
91            67                               1372         foreach my $line ( $text =~ m/$line_re/g ) {
92           242                               1063            my ($row, $cols) = $vals_sub->($line, @cols);
93           242    100                        1011            if ( $row ) {
94           178                               1073               foreach my $key ( keys %$row ) {
95          1782    100    100                14619                  if ( !$row->{$key} || $row->{$key} eq 'NULL' ) {
96           608                               2184                     $row->{$key} = undef;
97                                                                   }
98                                                                }
99           178                                956               push @result, $row;
100                                                            }
101                                                            else {
102           64                                649               @cols = @$cols;
103                                                            }
104                                                         }
105                                                      }
106                                                   
107           68                                858      return \@result;
108                                                   }
109                                                   
110                                                   # ###########################################################################
111                                                   # Converts output of EXPLAIN into a human-readable tree.
112                                                   # ###########################################################################
113                                                   package ExplainTree;
114                                                   
115            4                    4            39   use List::Util qw(max);
               4                                 13   
               4                                 61   
116            4                    4            34   use Data::Dumper;
               4                                  9   
               4                                 34   
117                                                   
118                                                   sub new {
119            4                    4            20      my ( $class, $options ) = @_;
120            4                                 64      my $self = bless {}, $class;
121            4                                 23      $self->load_options($options);
122            4                                 17      return $self;
123                                                   }
124                                                   
125                                                   sub load_options {
126           67                   67           298      my ( $self, $options ) = @_;
127   ***     67    100     66                  584      if ( $options && ref $options eq 'HASH' ) {
128            3                                 15         @{$self}{keys %$options} = values %$options;
               3                                 15   
129                                                      }
130                                                      else {
131           64                                250         delete @{$self}{keys %$self};
              64                                300   
132                                                      }
133                                                   }
134                                                   
135                                                   sub parse {
136           61                   61          1615      my ( $self, $text, $options ) = @_;
137           61                                808      return $self->process(ExplainParser->new->parse($text), $options);
138                                                   }
139                                                   
140                                                   # The main method that turns a result set into a tree.  Accepts an arrayref of
141                                                   # hashrefs which correspond to the rows in EXPLAIN.  See the ALGORITHM in the
142                                                   # documentation for a small novel about this process.
143                                                   sub process {
144           63                   63           319      my ( $self, $rows, $options ) = @_;
145           63                                363      $self->load_options($options);
146   ***     63    100     66                  704      return unless ref $rows eq 'ARRAY' && @$rows;
147                                                   
148                                                      # Pre-process and sanity check the rows.
149           62                                300      my @rows = @$rows;
150           62                                528      foreach my $i ( 0 .. $#rows ) {
151          170                                575         my $row = $rows[$i];
152          170                                609         $row->{rowid} = $i;
153          170           100                  786         $row->{Extra} ||= '';
154                                                   
155                                                         # The source code says if there are too many tables unioned together, the
156                                                         # table column will get truncated, like "<union1,2,3,4...>".  If this
157                                                         # happens, I've got to bail out.  I'm not going to check all the source
158                                                         # code for all versions, but in 5.0 it looks like I can get this to happen
159                                                         # around table 20.
160          170    100    100                 1523         die "UNION has too many tables: $row->{table}"
161                                                            if $row->{table} && $row->{table} =~ m/\./;
162                                                   
163          169    100                         888         if ( !defined $row->{id} ) {
164   ***     12     50     33                  178            if ( $row->{table} && (my ($id) = $row->{table} =~ m/^<union(\d+)/) ) {
165           12                                 67               $row->{id} = $id;
166                                                            }
167                                                            else {
168   ***      0                                  0               die "Unexpected NULL in id column, please report as a bug";
169                                                            }
170                                                         }
171                                                      }
172                                                   
173                                                      # Re-order the rows so all references are forward.
174           12                                 82      my %union_for
175          147                                750         = map  { $_->{id} => $_ }
176           61                                304           grep { $_->{select_type} eq 'UNION RESULT' }
177                                                           @rows;
178                                                   
179           61                                200      my $last_id = 0;
180           61                                193      my @reordered;
181           61                                234      foreach my $row ( grep { $_->{select_type} ne 'UNION RESULT' } @rows ) {
             147                                700   
182          135    100    100                 1329         if ( $last_id != $row->{id} && $union_for{$row->{id}} ) {
183           12                                 49            push @reordered, $union_for{$row->{id}};
184                                                         }
185          135                                413         push @reordered, $row;
186          135                                547         $last_id = $row->{id};
187                                                      }
188                                                   
189                                                      # Process the rows recursively.
190           61                                368      my $tree = $self->build_query_plan(@reordered);
191                                                   
192           61                                507      return $tree;
193                                                   }
194                                                   
195                                                   sub build_query_plan {
196          120                  120           570      my ( $self, @rows ) = @_;
197                                                   
198   ***    120     50                         527      if ( !@rows ) {
199   ***      0                                  0         die "I got no rows";
200                                                      }
201                                                   
202                                                      # Is it a UNION RESULT?  Split it up into sub-scopes and recurse.
203          120    100                         637      if ( $rows[0]->{select_type} eq 'UNION RESULT' ) {
204           12                                 43         my $row = shift @rows;
205           12                                 32         my @kids;
206           12                                101         my @ids   = $row->{table} =~ m/(\d+)/g;
207           12                                 36         my $enclosing_scope;
208           12    100                          66         if ( $rows[0]->{select_type} =~ m/SUBQUERY/ ) {
209            2                                  6            $enclosing_scope = $rows[0];
210                                                         }
211           12                                 70         foreach my $i ( 0 .. $#ids ) {
212           24                                129            my $start = $self->index_of($ids[$i], @rows);
213           24    100                         159            my $end   = $i < $#ids ? $self->index_of($ids[$i + 1], @rows) : @rows;
214           24                                162            push @kids, $self->build_query_plan(splice(@rows, $start, $end - $start));
215                                                         }
216           12                                 69         $row->{children} = [ @kids ];
217           24    100                         107         $row->{table}    = "union("
218           12                                 46            . join(',', map { $self->recursive_table_name($_) || '<none>' } @kids)
219                                                            . ")";
220           12                                 53         my $tree = $self->transform($row);
221           12    100                          48         if ( $enclosing_scope ) {
222            2                                  9            my $node = $self->transform($enclosing_scope);
223            2                                  8            $node->{children} = [ $tree ];
224            2                                  7            $tree = $node;
225                                                         }
226           12                                 73         return $tree;
227                                                      }
228                                                   
229                                                      # Are there DERIVED tables?  If so, find its children and pull them out of the
230                                                      # list under it.
231          108    100                         388      while ( my ($der) = grep { $_->{table} && $_->{table} =~ m/^<derived\d+>$/ } @rows ) {
             222                               2229   
232                                                   
233                                                         # Figure out the start and end of the derived scope.
234           16                                113         my ($der_id) = $der->{table} =~ m/^<derived(\d+)>$/;
235           16                                 89         my $start    = $self->index_of($der_id, @rows);
236           16                                 48         my $end      = $start;
237           16           100                  174         while ( $end < @rows && $rows[$end]->{id} >= $der_id ) {
238           32                                241            $end++;
239                                                         }
240                                                   
241                                                         # Get the rows that belong to this scope and recurse.
242           16                                101         my @enclosed_scope = splice(@rows, $start, $end - $start);
243           16                                 80         my $kids           = $self->build_query_plan(@enclosed_scope);
244           16                                 79         $der->{children}   = [$kids];
245           16           100                   76         $der->{table}      = "derived(" . ($self->recursive_table_name($kids) || '<none>') . ")";
246                                                      }
247                                                   
248                                                      # Handle the "normal case."  For each node, if the id is the same as the last
249                                                      # one, JOIN and continue.  If the id is greater, it's a subquery, so should
250                                                      # be recursed.
251                                                   
252                                                      # But, filesort/temporary have to be handled specially, because they appear
253                                                      # in the first row, even if they are done later.  Here are the cases,
254                                                      # according to http://s.petrunia.net/blog/?p=24:
255                                                   
256                                                      # ... MySQL has three ways to run a join and produce ordered output:
257                                                      # Method                               EXPLAIN output
258                                                      # ##################################   ####################################
259                                                      # Use index-based access method that   no mention of filesort
260                                                      # produces ordered output
261                                                      # ----------------------------------   ------------------------------------
262                                                      # Use filesort() on 1st non-constant   "Using filesort" in the first row
263                                                      # table
264                                                      # ----------------------------------   ------------------------------------
265                                                      # Put join result into a temporary     "Using temporary; Using filesort" in
266                                                      # table and use filesort() on it       the first row
267                                                      # ----------------------------------   ------------------------------------
268                                                   
269          108                                386      my $first = shift(@rows);
270                                                   
271                                                      # This is "case three" above.
272          108                                307      my $is_temp_filesort;
273          108    100    100                  952      if ( $first->{Extra} =~ m/Using temporary; Using filesort/ ) {
                    100                               
274                                                         # The entire join is being placed into a temporary table and filesorted,
275                                                         # so I'll make a note of that and apply it afterwards.  In the meantime I
276                                                         # must remove mention of it from the node so the node doesn't get extra
277                                                         # transformations in transform().
278            2                                  6         $is_temp_filesort = 1;
279            2                                 17         $first->{Extra} =~ s/Using temporary; Using filesort(?:; )?//;
280                                                      }
281                                                   
282                                                      # This is "case two" above.  Must find first non-constant table and move
283                                                      # the filesort() there.
284                                                      elsif ( $first->{Extra} =~ m/Using filesort/ && $first->{type} =~ m/^(?:system|const)$/ ) {
285            1                                 11         my ( $first_non_const ) = grep { $_->{type} !~ m/^(?:system|const)$/ } @rows;
               2                                 10   
286   ***      1     50                           6         if ( $first_non_const ) {
287            1                                  7            $first->{Extra} =~ s/Using filesort(?:; )?//;
288            1                                  6            $first_non_const->{Extra} .= '; Using filesort';
289                                                         }
290                                                      }
291                                                   
292          108                                398      my $scope = $first->{id};
293          108                                493      my $tree  = $self->transform($first);
294          108                                325      my $i     = 0;
295          108                                561      while ( $i < @rows ) {
296           46                                151         my $row = $rows[$i];
297           46    100                         221         if ( $row->{id} == $scope ) {
298           27                                140            $tree = {
299                                                               type     => 'JOIN',
300                                                               children => [ $tree, $self->transform($row) ],
301                                                            };
302           27                                148            $i++;
303                                                         }
304                                                         else {
305                                                            # It's another kind of "join".  Find the enclosing scope boundaries and
306                                                            # recurse.  The scope starts at $i.
307           19                                 57            my $end = $i;
308           19           100                  210            while ( $end < @rows && $rows[$end]->{id} >= $row->{id} ) {
309           26                                176               $end++;
310                                                            }
311           19                                111            my @enclosed_scope = splice(@rows, $i, $end - $i);
312           19                                149            $tree = {
313                                                               type     => $row->{select_type},
314                                                               children => [ $tree, $self->build_query_plan(@enclosed_scope) ],
315                                                            };
316                                                            # Don't increment the pointer because I just removed rows from @rows.
317                                                            # $i++
318                                                         }
319                                                      }
320                                                   
321          108    100                         395      if ( $is_temp_filesort ) {
322            2                                 13         $tree = $self->filesort(
323                                                            $self->temporary($tree, $self->recursive_table_name($tree)));
324                                                      }
325                                                   
326          108                                531      return $tree;
327                                                   }
328                                                   
329                                                   sub transform {
330          149                  149           598      my ( $self, $row ) = @_;
331                                                   
332          149                                564      my $sub = $row->{type};
333                                                   
334                                                      # ##################################################################
335                                                      # Dispatch to a class method to generate the tree.
336                                                      # ##################################################################
337          149                                717      my $no_matching_row = join('|',
338                                                         "Impossible (?:WHERE|HAVING)(?: noticed after reading const tables)?",
339                                                         'No matching.*row',
340                                                         '(?:unique|const) row not found',
341                                                      );
342          149    100                        1087      my $node
      ***            50                               
                    100                               
                    100                               
                    100                               
343                                                         = $sub
344                                                            ? $self->$sub($row)
345                                                         : $row->{Extra} =~ m/No tables/
346                                                            ? { type => ( $row->{select_type} !~ m/^(?:PRIMARY|SIMPLE)$/
347                                                                        ? $row->{select_type}
348                                                                        : 'DUAL') }
349                                                         : $row->{Extra} =~ m/(?:$no_matching_row)/i
350                                                            ? { type => 'IMPOSSIBLE' }
351                                                         : $row->{Extra} =~ m/optimized away/
352                                                            ? { type => 'CONSTANT' }
353                                                         : die "Can't handle " . Dumper($row);
354                                                   
355          149                               1644      my ($warn) = $row->{Extra} =~ m/($no_matching_row)/;
356          149    100                         573      if ( $warn ) {
357            8                                 37         $node->{warning} = $warn;
358                                                      }
359                                                   
360                                                      # ##################################################################
361                                                      # Apply other tree transformations.
362                                                      # ##################################################################
363          149    100                         732      if ( $row->{Extra} =~ m/Using where/ ) {
364           29                                215         $node = {
365                                                            type     => 'Filter with WHERE',
366                                                            children => [$node],
367                                                         };
368                                                      }
369                                                   
370          149    100                         660      if ( $row->{Extra} =~ m/Using join buffer/ ) {
371            1                                  6         $node = {
372                                                            type     => 'Join buffer',
373                                                            children => [$node],
374                                                         };
375                                                      }
376                                                   
377          149    100                         884      if ( $row->{Extra} =~ m/Distinct|Not exists/ ) {
378            2                                 14         $node = {
379                                                            type     => 'Distinct/Not-Exists',
380                                                            children => [$node],
381                                                         };
382                                                      }
383                                                   
384          149    100                         706      if ( $row->{Extra} =~ m/Range checked for each record \(\w+ map: ([^\)]+)\)/ ) {
385                                                         # (index map: N) is a bitmap of which indexes are used.  For example:
386                                                         #  0x5  base 16 (or base 10)
387                                                         # 0101  base 2
388                                                         # 4321  position of bits
389                                                         #  3 1  indexes used
390            3                                  9         my $bitmap = eval "int($1)";                    # Hex to decimal if it begins with '0x'
391            3                                 45         $bitmap    = unpack("B32", pack("N", $bitmap)); # Convert into binary string of 1/0
392            3                                 16         $bitmap    =~ s/^0+//;                          # Remove leading zeros
393            3                                 12         $bitmap    = reverse $bitmap;                   # Iterate from left-to-right
394            9                                 41         my $possible_keys = join(',',
395            3                                 21            grep { substr($bitmap, $_ - 1, 1) }
396                                                           ( 1 .. length($bitmap) ));
397            3                                 22         $node = {
398                                                            type          => 'Re-evaluate indexes each row',
399                                                            possible_keys => $possible_keys,
400                                                            children      => [$node],
401                                                         };
402                                                      }
403                                                   
404          149    100                         669      if ( $row->{Extra} =~ m/Using filesort/ ) {
405            3                                 16         $node = $self->filesort($node);
406                                                      }
407                                                   
408          149    100                         634      if ( $row->{Extra} =~ m/Using temporary/ ) {
409            1                                  9         $node = $self->temporary($node, $row->{table}, 1);
410                                                      }
411                                                   
412                                                      # Add some data that will help me keep track of nodes as I manipulate
413                                                      # them later
414          149                                688      $node->{id}    = $row->{id};
415          149                                564      $node->{rowid} = $row->{rowid};
416                                                   
417          149                                584      return $node;
418                                                   }
419                                                   
420                                                   sub index_of {
421           52                   52           254      my ( $self, $id, @rows ) = @_;
422           52                                157      my $i = 0;
423           52                                169      foreach my $row ( @rows ) {
424   ***     96    100     66                  879         if ( $row->{id} && $row->{id} == $id ) {
425           52                                211            return $i;
426                                                         }
427           44                                139         $i++;
428                                                      }
429   ***      0      0                           0      die "Can't find row $id in "
430   ***      0                                  0         . join(',', map { $_->{id} || '' } @rows);
431                                                   }
432                                                   
433                                                   sub pretty_print {
434            8                    8            36      my ( $self, $node, $prefix ) = @_;
435            8           100                   34      $prefix ||= '';
436            8    100                          48      my $branch = $prefix ? substr($prefix, 0, length($prefix) -3) . '+- ' : '';
437            8                                 35      my $output = $branch . $node->{type} . "\n";
438                                                   
439            8                                 24      my @kids;
440            8    100                          38      if ( $node->{children} ) {
441            4                                 14         @kids   = reverse @{$node->{children}};
               4                                 23   
442                                                      }
443            8    100                          35      my $suffix = (@kids > 1) ? '|  ' : '   ';
444                                                   
445            8                                 34      foreach my $thing ( qw(table key partitions possible_keys method key_len ref rows warning) ) {
446           72    100                         331         if ( defined $node->{$thing} ) {
447           15                                 95            $output .= $prefix . sprintf('%-14s %s', $thing, $node->{$thing}) . "\n";
448                                                         }
449                                                      }
450                                                   
451            8                                 28      my $last_child = pop @kids;
452            8                                 27      foreach my $child ( @kids ) {
453            2                                 21         $output .= $self->pretty_print($child, $prefix . $suffix);
454                                                      }
455            8    100                          35      if ( $last_child ) {
456            4                                 25         $output .= $self->pretty_print($last_child, $prefix . '   ');
457                                                      }
458            8                                 53      return $output;
459                                                   }
460                                                   
461                                                   #############################################################################
462                                                   # Each method in this section corresponds to a value you will find in the 'type'
463                                                   # column in EXPLAIN.
464                                                   #############################################################################
465                                                   
466                                                   sub ALL {
467           38                   38           151      my ( $self, $row ) = @_;
468                                                      return {
469           38                                257         type     => 'Table scan',
470                                                         rows     => $row->{rows},
471                                                         children => [$self->table($row)],
472                                                      };
473                                                   }
474                                                   
475                                                   sub fulltext {
476            1                    1             4      my ( $self, $row ) = @_;
477            1                                  6      return $self->index_access($row, 'Fulltext scan');
478                                                   }
479                                                   
480                                                   sub range {
481            3                    3            14      my ( $self, $row ) = @_;
482            3                                 15      return $self->index_access($row, 'Index range scan');
483                                                   }
484                                                   
485                                                   sub index {
486           45                   45           180      my ( $self, $row ) = @_;
487           45                                240      return $self->index_access($row, 'Index scan');
488                                                   }
489                                                   
490                                                   sub eq_ref {
491           10                   10            43      my ( $self, $row ) = @_;
492           10                                 46      return $self->index_access($row, 'Unique index lookup');
493                                                   }
494                                                   
495                                                   sub ref {
496           17                   17            77      my ( $self, $row ) = @_;
497           17                                 84      return $self->index_access($row, 'Index lookup');
498                                                   }
499                                                   
500                                                   sub ref_or_null {
501            1                    1             5      my ( $self, $row ) = @_;
502            1                                  6      return $self->index_access($row, 'Index lookup with extra null lookup');
503                                                   }
504                                                   
505                                                   sub const {
506            7                    7            35      my ( $self, $row ) = @_;
507            7                                 40      return $self->index_access($row, 'Constant index lookup');
508                                                   }
509                                                   
510                                                   sub system {
511            8                    8            35      my ( $self, $row ) = @_;
512                                                      return {
513            8                                 51         type => 'Constant table access',
514                                                         rows     => $row->{rows},
515                                                         children => [$self->table($row)],
516                                                      };
517                                                   }
518                                                   
519                                                   sub unique_subquery {
520            1                    1             4      my ( $self, $row ) = @_;
521            1                                  4      return $self->index_access($row, 'Unique subquery');
522                                                   }
523                                                   
524                                                   sub index_subquery {
525            1                    1             5      my ( $self, $row ) = @_;
526            1                                  5      return $self->index_access($row, 'Index subquery');
527                                                   }
528                                                   
529                                                   # From the manual: "The Index Merge method is used to retrieve rows with
530                                                   # several range scans and to merge their results into one."  Therefore each
531                                                   # index access should be shown as an index range scan.  The unions and
532                                                   # intersections can be recursive, as in
533                                                   # union(intersect(key1,key2),intersect(key3,key4))
534                                                   sub index_merge {
535            4                    4            18      my ( $self, $row ) = @_;
536            4                                 54      my ( $merge_spec )
537                                                         = $row->{Extra} =~ m/Using ((?:intersect|union|sort_union)\(.*?\))(?=;|$)/;
538            4                                 25      my ($merge, $num) = $self->recurse_index_merge($row, $merge_spec, 0);
539                                                   
540                                                      # index_merge_bookmark_lookup note:
541                                                      # From the manual, "If the used indexes don't cover all columns used in the
542                                                      # query, full rows are retrieved only when the range conditions for all
543                                                      # used keys are satisfied."  So a bookmark lookup shouldn't be shown for
544                                                      # all indexes; it should be shown from the merge results.
545            4                                 23      return $self->bookmark_lookup($merge, $row);
546                                                   }
547                                                   
548                                                   # ###########################################################################
549                                                   # Helper subroutines.
550                                                   # ###########################################################################
551                                                   
552                                                   sub recursive_table_name {
553           79                   79           293      my ( $self, $node ) = @_;
554           79    100                         336      if ( $node->{table} ) {
555           13                                 65         return $node->{table};
556                                                      }
557           66    100                         286      if ( $node->{key} ) {
558           34                                247         my ( $table ) = $node->{key} =~ m/(.*?)->/;
559           34                                204         return $table;
560                                                      }
561           32    100                         150      if ( $node->{type} eq 'Bookmark lookup' ) {
562            1                                 12         return $node->{children}->[1]->{table};
563                                                      }
564           31    100                         133      if ( $node->{type} eq 'IMPOSSIBLE' ) {
565            1                                  4         return '<none>';
566                                                      }
567           30    100                         234      if ( $node->{children} ) {
568           37                                251         return join(',',
569           37                                138            grep { $_ }
570           26                                100            map  { $self->recursive_table_name($_) }
571           26                                 79                 @{$node->{children}});
572                                                      }
573                                                   }
574                                                   
575                                                   # $num is the number of nodes to the left of this node in a depth-first
576                                                   # traversal.  It lets me figure out which value goes in key_len.
577                                                   my $bal; # Workaround for issue 90 (Variable "$bal" will not stay shared).
578                                                   sub recurse_index_merge {
579            6                    6            30      my ( $self, $row, $spec, $num ) = @_;
580            6                                 62      my ($type, $args) = $spec =~ m/(intersect|union|sort_union)\((.*)\)$/;
581                                                   
582            6                                 19      my @children;
583                                                   
584                                                      # See 'man perlre' and search for 'matches a parenthesized group'.
585            6                                 30      $bal = qr/
586                                                         \(
587                                                         (?:
588                                                            (?> [^()]+ )    # Non-parens without backtracking
589                                                            |
590                                                            (??{ $bal })     # Group with matching parens
591                                                         )*
592                                                         \)
593                                                      /x;
594                                                   
595                                                      # Extract a thing, followed by balanced parentheses.
596            6                                147      foreach my $child ( $args =~ m/(\w+$bal)/g ) {
597            2                                 16         my ( $subtree, $num ) = $self->recurse_index_merge($row, $child, $num);
598            2                                  8         push @children, $subtree;
599                                                      }
600                                                   
601            6    100                          31      if ( !@children ) { # Recursion base case; $args is an index list
602            5                                 26         foreach my $idx ( split(/,/, $args) ) {
603           11                                 47            my $index_scan = $self->index_access($row, 'Index range scan', $idx);
604           11                                 88            $index_scan->{key_len} = ($row->{key_len} =~ m/(\d+)/g)[$num++];
605           11                                 49            push @children, $index_scan;
606                                                         }
607                                                      }
608                                                   
609                                                      return (
610                                                         {
611            6                                 53            type     => 'Index merge',
612                                                            method   => $type,
613                                                            rows     => $row->{rows},
614                                                            children => \@children,
615                                                         },
616                                                         $num
617                                                      );
618                                                   
619                                                   }
620                                                   
621                                                   sub table {
622           70                   70           289      my ( $self, $row ) = @_;
623   ***     70    100     66                 1284      my $node = {
624                                                         type          => ($row->{table} && $row->{table} =~ m/^(derived|union)\(/)
625                                                                          ? uc $1
626                                                                          : 'Table',
627                                                         table         => $row->{table},
628                                                         possible_keys => $row->{possible_keys},
629                                                         partitions    => $row->{partitions},
630                                                      };
631           70    100                         370      if ( $row->{children} ) {
632           28                                125         $node->{children} = $row->{children};
633                                                      }
634           70                                479      return $node;
635                                                   }
636                                                   
637                                                   sub bookmark_lookup {
638           90                   90           406      my ( $self, $node, $row ) = @_;
639   ***     90    100     66                 1541      if ( $row->{Extra} =~ m/Using index/
      ***                   66                        
                           100                        
640                                                            || ( $self->{clustered} && $row->{key} && $row->{key} eq 'PRIMARY' ))
641                                                      {
642           66                                268         return $node;
643                                                      }
644                                                      return {
645           24                                132         type     => 'Bookmark lookup',
646                                                         children => [ $node, $self->table($row) ],
647                                                      };
648                                                   }
649                                                   
650                                                   sub filesort {
651            5                    5            25      my ( $self, $node ) = @_;
652                                                      return {
653            5                                 35         type     => 'Filesort',
654                                                         children => [$node],
655                                                      };
656                                                   }
657                                                   
658                                                   sub temporary {
659            3                    3            19      my ( $self, $node, $table_name, $is_scan ) = @_;
660            3                                 30      $node = {
661                                                         type          => 'TEMPORARY',
662                                                         table         => "temporary($table_name)",
663                                                         possible_keys => undef,
664                                                         partitions    => undef,
665                                                         children      => [$node],
666                                                      };
667            3    100                          16      if ( $is_scan ) {
668            1                                  7         $node = {
669                                                            type     => 'Table scan',
670                                                            rows     => undef,
671                                                            children => [ $node ],
672                                                         };
673                                                      }
674            3                                 16      return $node;
675                                                   }
676                                                   
677                                                   sub index_access {
678           97                   97           464      my ( $self, $row, $type, $key ) = @_;
679   ***     97            66                 1713      my $node = {
680                                                         type          => $type,
681                                                         key           => $row->{table} . '->' . ( $key || $row->{key} ),
682                                                         possible_keys => $row->{possible_keys},
683                                                         partitions    => $row->{partitions},
684                                                         key_len       => $row->{key_len},
685                                                         'ref'         => $row->{ref},
686                                                         rows          => $row->{rows},
687                                                      };
688           97    100                         460      if ( $row->{Extra} =~ m/Full scan on NULL key/ ) {
689            2                                  8         $node->{warning} = 'Full scan on NULL key';
690                                                      }
691           97    100                         438      if ( $row->{Extra} =~ m/Using index for group-by/ ) {
692            1                                  5         $node->{type} = 'Loose index scan';
693                                                      }
694                                                      # See index_merge_bookmark_lookup note above.
695           97    100                        1103      if ( $row->{type} ne 'index_merge' ) {
696           86                                447         $node = $self->bookmark_lookup($node, $row);
697                                                      }
698           97                                381      return $node;
699                                                   }
700                                                   
701                                                   # ###########################################################################
702                                                   # OptionParser package 5266
703                                                   # ###########################################################################
704                                                   package OptionParser;
705                                                   
706            4                    4            59   use strict;
               4                                 13   
               4                                 34   
707            4                    4            28   use warnings FATAL => 'all';
               4                                 12   
               4                                 31   
708                                                   
709            4                    4            51   use Getopt::Long;
               4                                 13   
               4                                 31   
710            4                    4            35   use List::Util qw(max);
               4                                 10   
               4                                 24   
711            4                    4            27   use English qw(-no_match_vars);
               4                                 30   
               4                                 34   
712                                                   
713   ***      4            50      4            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 12   
               4                                 75   
714                                                   
715                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
716                                                   
717                                                   my %attributes = (
718                                                      'type'       => 1,
719                                                      'short form' => 1,
720                                                      'group'      => 1,
721                                                      'default'    => 1,
722                                                      'cumulative' => 1,
723                                                      'negatable'  => 1,
724                                                   );
725                                                   
726                                                   sub new {
727            2                    2            20      my ( $class, %args ) = @_;
728            2                                 11      foreach my $arg ( qw(description) ) {
729   ***      2     50                          14         die "I need a $arg argument" unless $args{$arg};
730                                                      }
731            2                                 30      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
732   ***      2            33                   10      $program_name ||= $PROGRAM_NAME;
733   ***      2            33                   22      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
734                                                   
735   ***      2     50     50                   83      my $self = {
      ***                   50                        
736                                                         description    => $args{description},
737                                                         prompt         => $args{prompt} || '<options>',
738                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
739                                                         dp             => $args{dp}     || undef,
740                                                         program_name   => $program_name,
741                                                         opts           => {},
742                                                         got_opts       => 0,
743                                                         short_opts     => {},
744                                                         defaults       => {},
745                                                         groups         => {},
746                                                         allowed_groups => {},
747                                                         errors         => [],
748                                                         rules          => [],  # desc of rules for --help
749                                                         mutex          => [],  # rule: opts are mutually exclusive
750                                                         atleast1       => [],  # rule: at least one opt is required
751                                                         disables       => {},  # rule: opt disables other opts 
752                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
753                                                         default_files  => [
754                                                            "/etc/maatkit/maatkit.conf",
755                                                            "/etc/maatkit/$program_name.conf",
756                                                            "$home/.maatkit.conf",
757                                                            "$home/.$program_name.conf",
758                                                         ],
759                                                      };
760            2                                 21      return bless $self, $class;
761                                                   }
762                                                   
763                                                   sub get_specs {
764            2                    2             8      my ( $self, $file ) = @_;
765            2                                 11      my @specs = $self->_pod_to_specs($file);
766            2                                 41      $self->_parse_specs(@specs);
767            2                                  9      return;
768                                                   }
769                                                   
770                                                   sub get_defaults_files {
771            2                    2             7      my ( $self ) = @_;
772            2                                  6      return @{$self->{default_files}};
               2                                 22   
773                                                   }
774                                                   
775                                                   sub _pod_to_specs {
776            2                    2             9      my ( $self, $file ) = @_;
777   ***      2            50                   10      $file ||= __FILE__;
778   ***      2     50                          87      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
779                                                   
780            2                                 29      my %types = (
781                                                         string => 's', # standard Getopt type
782                                                         'int'  => 'i', # standard Getopt type
783                                                         float  => 'f', # standard Getopt type
784                                                         Hash   => 'H', # hash, formed from a comma-separated list
785                                                         hash   => 'h', # hash as above, but only if a value is given
786                                                         Array  => 'A', # array, similar to Hash
787                                                         array  => 'a', # array, similar to hash
788                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
789                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
790                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
791                                                      );
792            2                                  7      my @specs = ();
793            2                                  7      my @rules = ();
794            2                                  5      my $para;
795                                                   
796            2                                 14      local $INPUT_RECORD_SEPARATOR = '';
797            2                                 49      while ( $para = <$fh> ) {
798          752    100                        4799         next unless $para =~ m/^=head1 OPTIONS/;
799            2                                  9         last;
800                                                      }
801                                                   
802            2                                 18      while ( $para = <$fh> ) {
803   ***      2     50                          12         last if $para =~ m/^=over/;
804   ***      0                                  0         chomp $para;
805   ***      0                                  0         $para =~ s/\s+/ /g;
806   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
807   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
808   ***      0                                  0         push @rules, $para;
809                                                      }
810                                                   
811   ***      2     50                           9      die 'POD has no OPTIONS section' unless $para;
812                                                   
813            2                                  6      do {
814           36    100                         265         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
815           34                                 89            chomp $para;
816           34                                 72            MKDEBUG && _d($para);
817           34                                 85            my %attribs;
818                                                   
819           34                                134            $para = <$fh>; # read next paragraph, possibly attributes
820                                                   
821           34    100                         134            if ( $para =~ m/: / ) { # attributes
822           24                                117               $para =~ s/\s+\Z//g;
823           44                                198               %attribs = map {
824           24                                112                     my ( $attrib, $val) = split(/: /, $_);
825   ***     44     50                         182                     die "Unrecognized attribute for --$option: $attrib"
826                                                                        unless $attributes{$attrib};
827           44                                213                     ($attrib, $val);
828                                                                  } split(/; /, $para);
829           24    100                         111               if ( $attribs{'short form'} ) {
830           16                                 72                  $attribs{'short form'} =~ s/-//;
831                                                               }
832           24                                103               $para = <$fh>; # read next paragraph, probably short help desc
833                                                            }
834                                                            else {
835           10                                 24               MKDEBUG && _d('Option has no attributes');
836                                                            }
837                                                   
838           34                                288            $para =~ s/\s+\Z//g;
839           34                                298            $para =~ s/\s+/ /g;
840           34                                173            $para =~ s/$POD_link_re/$1/go;
841                                                   
842           34                                135            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
843           34                                 75            MKDEBUG && _d('Short help:', $para);
844                                                   
845   ***     34     50                         134            die "No description after option spec $option" if $para =~ m/^=item/;
846                                                   
847   ***     34     50                         149            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
848   ***      0                                  0               $option = $base_option;
849   ***      0                                  0               $attribs{'negatable'} = 1;
850                                                            }
851                                                   
852           34    100                         559            push @specs, {
      ***            50                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
853                                                               spec  => $option
854                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
855                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
856                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
857                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
858                                                               desc  => $para
859                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
860                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
861                                                            };
862                                                         }
863           36                                203         while ( $para = <$fh> ) {
864   ***     42     50                         144            last unless $para;
865                                                   
866                                                   
867           42    100                         159            if ( $para =~ m/^=head1/ ) {
868            2                                  7               $para = undef; # Can't 'last' out of a do {} block.
869            2                                 10               last;
870                                                            }
871           40    100                         247            last if $para =~ m/^=item --/;
872                                                         }
873                                                      } while ( $para );
874                                                   
875   ***      2     50                          10      die 'No valid specs in POD OPTIONS' unless @specs;
876                                                   
877            2                                 45      close $fh;
878            2                                  9      return @specs, @rules;
879                                                   }
880                                                   
881                                                   sub _parse_specs {
882            2                    2            14      my ( $self, @specs ) = @_;
883            2                                  6      my %disables; # special rule that requires deferred checking
884                                                   
885            2                                 10      foreach my $opt ( @specs ) {
886   ***     34     50                         125         if ( ref $opt ) { # It's an option spec, not a rule.
887                                                            MKDEBUG && _d('Parsing opt spec:',
888           34                                 73               map { ($_, '=>', $opt->{$_}) } keys %$opt);
889                                                   
890           34                                223            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
891   ***     34     50                         136            if ( !$long ) {
892   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
893                                                            }
894           34                                158            $opt->{long} = $long;
895                                                   
896   ***     34     50                         157            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
897           34                                136            $self->{opts}->{$long} = $opt;
898                                                   
899   ***     34     50                         127            if ( length $long == 1 ) {
900   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
901   ***      0                                  0               $self->{short_opts}->{$long} = $long;
902                                                            }
903                                                   
904           34    100                         110            if ( $short ) {
905   ***     16     50                          73               die "Duplicate short option -$short"
906                                                                  if exists $self->{short_opts}->{$short};
907           16                                 64               $self->{short_opts}->{$short} = $long;
908           16                                 53               $opt->{short} = $short;
909                                                            }
910                                                            else {
911           18                                 58               $opt->{short} = undef;
912                                                            }
913                                                   
914   ***     34     50                         182            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
915   ***     34     50                         163            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
916   ***     34     50                         179            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
917                                                   
918   ***     34            50                  134            $opt->{group} ||= 'default';
919           34                                157            $self->{groups}->{ $opt->{group} }->{$long} = 1;
920                                                   
921           34                                108            $opt->{value} = undef;
922           34                                105            $opt->{got}   = 0;
923                                                   
924           34                                164            my ( $type ) = $opt->{spec} =~ m/=(.)/;
925           34                                119            $opt->{type} = $type;
926           34                                 73            MKDEBUG && _d($long, 'type:', $type);
927                                                   
928   ***     34     50     66                  267            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
929   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
930                                                                  . "was given when this OptionParser object was created";
931                                                            }
932                                                   
933           34    100    100                  221            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
934                                                   
935           34    100                         189            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
936   ***      4     50                          22               $self->{defaults}->{$long} = defined $def ? $def : 1;
937            4                                  9               MKDEBUG && _d($long, 'default:', $def);
938                                                            }
939                                                   
940           34    100                         129            if ( $long eq 'config' ) {
941            2                                 12               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
942                                                            }
943                                                   
944   ***     34     50                         162            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
945   ***      0                                  0               $disables{$long} = $dis;
946   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
947                                                            }
948                                                   
949           34                                154            $self->{opts}->{$long} = $opt;
950                                                         }
951                                                         else { # It's an option rule, not a spec.
952   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
953   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
954   ***      0                                  0            my @participants = $self->_get_participants($opt);
955   ***      0                                  0            my $rule_ok = 0;
956                                                   
957   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
958   ***      0                                  0               $rule_ok = 1;
959   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
960   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
961                                                            }
962   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
963   ***      0                                  0               $rule_ok = 1;
964   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
965   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
966                                                            }
967   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
968   ***      0                                  0               $rule_ok = 1;
969   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
970   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
971                                                            }
972   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
973   ***      0                                  0               $rule_ok = 1;
974   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
975   ***      0                                  0               my @groups = split(',', $groups);
976   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
977   ***      0                                  0                  s/\s+//;
978   ***      0                                  0                  $_ => 1;
979                                                               } @groups;
980                                                            }
981                                                   
982   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
983                                                         }
984                                                      }
985                                                   
986            2                                 14      foreach my $long ( keys %disables ) {
987   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
988   ***      0                                  0         $self->{disables}->{$long} = \@participants;
989   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
990                                                      }
991                                                   
992            2                                 12      return; 
993                                                   }
994                                                   
995                                                   sub _get_participants {
996   ***      0                    0             0      my ( $self, $str ) = @_;
997   ***      0                                  0      my @participants;
998   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
999   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
1000                                                           unless exists $self->{opts}->{$long};
1001  ***      0                                  0         push @participants, $long;
1002                                                     }
1003  ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
1004  ***      0                                  0      return @participants;
1005                                                  }
1006                                                  
1007                                                  sub opts {
1008  ***      0                    0             0      my ( $self ) = @_;
1009  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1010  ***      0                                  0      return %opts;
1011                                                  }
1012                                                  
1013                                                  sub short_opts {
1014  ***      0                    0             0      my ( $self ) = @_;
1015  ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
1016  ***      0                                  0      return %short_opts;
1017                                                  }
1018                                                  
1019                                                  sub set_defaults {
1020  ***      0                    0             0      my ( $self, %defaults ) = @_;
1021  ***      0                                  0      $self->{defaults} = {};
1022  ***      0                                  0      foreach my $long ( keys %defaults ) {
1023  ***      0      0                           0         die "Cannot set default for nonexistent option $long"
1024                                                           unless exists $self->{opts}->{$long};
1025  ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
1026  ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
1027                                                     }
1028  ***      0                                  0      return;
1029                                                  }
1030                                                  
1031                                                  sub get_defaults {
1032  ***      0                    0             0      my ( $self ) = @_;
1033  ***      0                                  0      return $self->{defaults};
1034                                                  }
1035                                                  
1036                                                  sub get_groups {
1037  ***      0                    0             0      my ( $self ) = @_;
1038  ***      0                                  0      return $self->{groups};
1039                                                  }
1040                                                  
1041                                                  sub _set_option {
1042           1                    1             5      my ( $self, $opt, $val ) = @_;
1043  ***      1      0                           3      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
1044                                                              : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
1045                                                              : die "Getopt::Long gave a nonexistent option: $opt";
1046                                                  
1047           1                                  3      $opt = $self->{opts}->{$long};
1048  ***      1     50                           7      if ( $opt->{is_cumulative} ) {
1049  ***      0                                  0         $opt->{value}++;
1050                                                     }
1051                                                     else {
1052           1                                  5         $opt->{value} = $val;
1053                                                     }
1054           1                                  4      $opt->{got} = 1;
1055           1                                  5      MKDEBUG && _d('Got option', $long, '=', $val);
1056                                                  }
1057                                                  
1058                                                  sub get_opts {
1059           2                    2             8      my ( $self ) = @_; 
1060                                                  
1061           2                                  6      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 18   
1062          34                                132         $self->{opts}->{$long}->{got} = 0;
1063  ***     34     50                         260         $self->{opts}->{$long}->{value}
                    100                               
1064                                                           = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
1065                                                           : $self->{opts}->{$long}->{is_cumulative} ? 0
1066                                                           : undef;
1067                                                     }
1068           2                                 11      $self->{got_opts} = 0;
1069                                                  
1070           2                                  9      $self->{errors} = [];
1071                                                  
1072  ***      2     50     33                   48      if ( @ARGV && $ARGV[0] eq "--config" ) {
1073  ***      0                                  0         shift @ARGV;
1074  ***      0                                  0         $self->_set_option('config', shift @ARGV);
1075                                                     }
1076  ***      2     50                          14      if ( $self->has('config') ) {
1077           2                                  8         my @extra_args;
1078           2                                 14         foreach my $filename ( split(',', $self->get('config')) ) {
1079           8                                 26            eval {
1080           8                                 38               push @extra_args, $self->_read_config_file($filename);
1081                                                           };
1082  ***      8     50                          42            if ( $EVAL_ERROR ) {
1083  ***      8     50                          35               if ( $self->got('config') ) {
1084  ***      0                                  0                  die $EVAL_ERROR;
1085                                                              }
1086                                                              elsif ( MKDEBUG ) {
1087                                                                 _d($EVAL_ERROR);
1088                                                              }
1089                                                           }
1090                                                        }
1091           2                                 10         unshift @ARGV, @extra_args;
1092                                                     }
1093                                                  
1094           2                                 14      Getopt::Long::Configure('no_ignore_case', 'bundling');
1095                                                     GetOptions(
1096          32                    1           277         map    { $_->{spec} => sub { $self->_set_option(@_); } }
               1                                  7   
              34                                137   
1097           2                                 13         grep   { $_->{long} ne 'config' } # --config is handled specially above.
1098  ***      2     50                           8         values %{$self->{opts}}
1099                                                     ) or $self->save_error('Error parsing options');
1100                                                  
1101  ***      2     50     33                   81      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
1102  ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
1103                                                           $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1104                                                              or die "Cannot print: $OS_ERROR";
1105  ***      0                                  0         exit 0;
1106                                                     }
1107                                                  
1108  ***      2     50     33                   21      if ( @ARGV && $self->{strict} ) {
1109  ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
1110                                                     }
1111                                                  
1112           2                                  6      foreach my $mutex ( @{$self->{mutex}} ) {
               2                                 13   
1113  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
1114  ***      0      0                           0         if ( @set > 1 ) {
1115  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1116  ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
1117                                                                   . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
1118                                                                   . ' are mutually exclusive.';
1119  ***      0                                  0            $self->save_error($err);
1120                                                        }
1121                                                     }
1122                                                  
1123           2                                  6      foreach my $required ( @{$self->{atleast1}} ) {
               2                                  9   
1124  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
1125  ***      0      0                           0         if ( @set == 0 ) {
1126  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1127  ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
1128                                                                   .' or --'.$self->{opts}->{$required->[-1]}->{long};
1129  ***      0                                  0            $self->save_error("Specify at least one of $err");
1130                                                        }
1131                                                     }
1132                                                  
1133           2                                  6      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 18   
1134          34                                128         my $opt = $self->{opts}->{$long};
1135          34    100                         182         if ( $opt->{got} ) {
      ***            50                               
1136  ***      1     50                           6            if ( exists $self->{disables}->{$long} ) {
1137  ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
1138  ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
1139  ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
1140                                                                 'because', $long,'disables them');
1141                                                           }
1142                                                  
1143  ***      1     50                           6            if ( exists $self->{allowed_groups}->{$long} ) {
1144                                                  
1145  ***      0                                  0               my @restricted_groups = grep {
1146  ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
1147  ***      0                                  0               } keys %{$self->{groups}};
1148                                                  
1149  ***      0                                  0               my @restricted_opts;
1150  ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
1151  ***      0                                  0                  RESTRICTED_OPT:
1152  ***      0                                  0                  foreach my $restricted_opt (
1153                                                                    keys %{$self->{groups}->{$restricted_group}} )
1154                                                                 {
1155  ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
1156  ***      0      0                           0                     push @restricted_opts, $restricted_opt
1157                                                                       if $self->{opts}->{$restricted_opt}->{got};
1158                                                                 }
1159                                                              }
1160                                                  
1161  ***      0      0                           0               if ( @restricted_opts ) {
1162  ***      0                                  0                  my $err;
1163  ***      0      0                           0                  if ( @restricted_opts == 1 ) {
1164  ***      0                                  0                     $err = "--$restricted_opts[0]";
1165                                                                 }
1166                                                                 else {
1167  ***      0                                  0                     $err = join(', ',
1168  ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
1169  ***      0                                  0                               grep { $_ } 
1170                                                                              @restricted_opts[0..scalar(@restricted_opts) - 2]
1171                                                                           )
1172                                                                         . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1173                                                                 }
1174  ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
1175                                                              }
1176                                                           }
1177                                                  
1178                                                        }
1179                                                        elsif ( $opt->{is_required} ) { 
1180  ***      0                                  0            $self->save_error("Required option --$long must be specified");
1181                                                        }
1182                                                  
1183          34                                124         $self->_validate_type($opt);
1184                                                     }
1185                                                  
1186           2                                 11      $self->{got_opts} = 1;
1187           2                                  7      return;
1188                                                  }
1189                                                  
1190                                                  sub _validate_type {
1191          34                   34           113      my ( $self, $opt ) = @_;
1192  ***     34    100     66                  305      return unless $opt && $opt->{type};
1193          24                                 75      my $val = $opt->{value};
1194                                                  
1195  ***     24     50     66                  579      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
1196  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1197  ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1198  ***      0      0                           0         if ( !$suffix ) {
1199  ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1200  ***      0             0                    0            $suffix = $s || 's';
1201  ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1202                                                              $opt->{long}, '(value:', $val, ')');
1203                                                        }
1204  ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
1205  ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
1206                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1207                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1208                                                                :                  $num * 86400;   # Days
1209  ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
1210  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1211                                                        }
1212                                                        else {
1213  ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
1214                                                        }
1215                                                     }
1216                                                     elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
1217  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1218  ***      0                                  0         my $prev = {};
1219  ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
1220  ***      0      0                           0         if ( $from_key ) {
1221  ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1222  ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
1223                                                        }
1224  ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
1225  ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
1226                                                     }
1227                                                     elsif ( $val && $opt->{type} eq 'z' ) {  # type size
1228  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1229  ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1230  ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1231  ***      0      0                           0         if ( defined $num ) {
1232  ***      0      0                           0            if ( $factor ) {
1233  ***      0                                  0               $num *= $factor_for{$factor};
1234  ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
1235                                                                 'to num', $num, '* factor', $factor);
1236                                                           }
1237  ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
1238                                                        }
1239                                                        else {
1240  ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
1241                                                        }
1242                                                     }
1243                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1244  ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
1245                                                     }
1246                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1247  ***      2            50                   40         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
1248                                                     }
1249                                                     else {
1250          22                                 51         MKDEBUG && _d('Nothing to validate for option',
1251                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1252                                                     }
1253                                                  
1254          24                                 80      return;
1255                                                  }
1256                                                  
1257                                                  sub get {
1258           8                    8            38      my ( $self, $opt ) = @_;
1259  ***      8     50                          42      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1260  ***      8     50     33                   86      die "Option $opt does not exist"
1261                                                        unless $long && exists $self->{opts}->{$long};
1262           8                                 76      return $self->{opts}->{$long}->{value};
1263                                                  }
1264                                                  
1265                                                  sub got {
1266          10                   10            47      my ( $self, $opt ) = @_;
1267  ***     10     50                          44      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1268  ***     10     50     33                   98      die "Option $opt does not exist"
1269                                                        unless $long && exists $self->{opts}->{$long};
1270          10                                 63      return $self->{opts}->{$long}->{got};
1271                                                  }
1272                                                  
1273                                                  sub has {
1274           2                    2            10      my ( $self, $opt ) = @_;
1275  ***      2     50                          12      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1276  ***      2     50                          19      return defined $long ? exists $self->{opts}->{$long} : 0;
1277                                                  }
1278                                                  
1279                                                  sub set {
1280  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1281  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1282  ***      0      0      0                    0      die "Option $opt does not exist"
1283                                                        unless $long && exists $self->{opts}->{$long};
1284  ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
1285  ***      0                                  0      return;
1286                                                  }
1287                                                  
1288                                                  sub save_error {
1289  ***      0                    0             0      my ( $self, $error ) = @_;
1290  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1291                                                  }
1292                                                  
1293                                                  sub errors {
1294  ***      0                    0             0      my ( $self ) = @_;
1295  ***      0                                  0      return $self->{errors};
1296                                                  }
1297                                                  
1298                                                  sub prompt {
1299  ***      0                    0             0      my ( $self ) = @_;
1300  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1301                                                  }
1302                                                  
1303                                                  sub descr {
1304  ***      0                    0             0      my ( $self ) = @_;
1305  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1306                                                                . "  For more details, please use the --help option, "
1307                                                                . "or try 'perldoc $PROGRAM_NAME' "
1308                                                                . "for complete documentation.";
1309  ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
1310  ***      0                                  0      $descr =~ s/ +$//mg;
1311  ***      0                                  0      return $descr;
1312                                                  }
1313                                                  
1314                                                  sub usage_or_errors {
1315           2                    2             8      my ( $self ) = @_;
1316  ***      2     50                          12      if ( $self->{opts}->{help}->{got} ) {
      ***      2     50                          12   
1317  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1318  ***      0                                  0         exit 0;
1319                                                     }
1320                                                     elsif ( scalar @{$self->{errors}} ) {
1321  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1322  ***      0                                  0         exit 0;
1323                                                     }
1324           2                                  6      return;
1325                                                  }
1326                                                  
1327                                                  sub print_errors {
1328  ***      0                    0             0      my ( $self ) = @_;
1329  ***      0                                  0      my $usage = $self->prompt() . "\n";
1330  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1331  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1332                                                                . "\n";
1333                                                     }
1334  ***      0                                  0      return $usage . "\n" . $self->descr();
1335                                                  }
1336                                                  
1337                                                  sub print_usage {
1338  ***      0                    0             0      my ( $self ) = @_;
1339  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1340  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1341                                                  
1342  ***      0      0                           0      my $maxl = max(
1343  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1344                                                        @opts);
1345                                                  
1346  ***      0      0                           0      my $maxs = max(0,
1347  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1348  ***      0                                  0         values %{$self->{short_opts}});
1349                                                  
1350  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1351  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1352  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1353                                                  
1354  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1355                                                  
1356  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1357                                                  
1358  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1359  ***      0                                  0      push @groups, 'default';
1360                                                  
1361  ***      0                                  0      foreach my $group ( reverse @groups ) {
1362  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1363  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1364  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1365                                                           grep { $_->{group} eq $group }
1366                                                           @opts )
1367                                                        {
1368  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1369  ***      0                                  0            my $short = $opt->{short};
1370  ***      0                                  0            my $desc  = $opt->{desc};
1371  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1372  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1373  ***      0             0                    0               $s    ||= 's';
1374  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1375  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1376                                                                     . "d=days; if no suffix, $s is used.";
1377                                                           }
1378  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1379  ***      0                                  0            $desc =~ s/ +$//mg;
1380  ***      0      0                           0            if ( $short ) {
1381  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1382                                                           }
1383                                                           else {
1384  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1385                                                           }
1386                                                        }
1387                                                     }
1388                                                  
1389  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1390  ***      0                                  0         $usage .= "\nRules:\n\n";
1391  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1392                                                     }
1393  ***      0      0                           0      if ( $self->{dp} ) {
1394  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1395                                                     }
1396  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1397  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1398  ***      0                                  0         my $val   = $opt->{value};
1399  ***      0             0                    0         my $type  = $opt->{type} || '';
1400  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1401  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1402                                                                  : !defined $val             ? '(No value)'
1403                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1404                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1405                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1406                                                                  :                             $val;
1407  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1408                                                     }
1409  ***      0                                  0      return $usage;
1410                                                  }
1411                                                  
1412                                                  sub prompt_noecho {
1413  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1414  ***      0                                  0      my ( $prompt ) = @_;
1415  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1416  ***      0      0                           0      print $prompt
1417                                                        or die "Cannot print: $OS_ERROR";
1418  ***      0                                  0      my $response;
1419  ***      0                                  0      eval {
1420  ***      0                                  0         require Term::ReadKey;
1421  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1422  ***      0                                  0         chomp($response = <STDIN>);
1423  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1424  ***      0      0                           0         print "\n"
1425                                                           or die "Cannot print: $OS_ERROR";
1426                                                     };
1427  ***      0      0                           0      if ( $EVAL_ERROR ) {
1428  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1429                                                     }
1430  ***      0                                  0      return $response;
1431                                                  }
1432                                                  
1433                                                  if ( MKDEBUG ) {
1434                                                     print '# ', $^X, ' ', $], "\n";
1435                                                     my $uname = `uname -a`;
1436                                                     if ( $uname ) {
1437                                                        $uname =~ s/\s+/ /g;
1438                                                        print "# $uname\n";
1439                                                     }
1440                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1441                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1442                                                        ($main::SVN_REV || ''), __LINE__);
1443                                                     print('# Arguments: ',
1444                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1445                                                  }
1446                                                  
1447                                                  sub _read_config_file {
1448           8                    8            32      my ( $self, $filename ) = @_;
1449  ***      8     50                          24      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1450  ***      0                                  0      my @args;
1451  ***      0                                  0      my $prefix = '--';
1452  ***      0                                  0      my $parse  = 1;
1453                                                  
1454                                                     LINE:
1455  ***      0                                  0      while ( my $line = <$fh> ) {
1456  ***      0                                  0         chomp $line;
1457  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1458  ***      0                                  0         $line =~ s/\s+#.*$//g;
1459  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1460  ***      0      0                           0         if ( $line eq '--' ) {
1461  ***      0                                  0            $prefix = '';
1462  ***      0                                  0            $parse  = 0;
1463  ***      0                                  0            next LINE;
1464                                                        }
1465  ***      0      0      0                    0         if ( $parse
      ***             0                               
1466                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1467                                                        ) {
1468  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1469                                                        }
1470                                                        elsif ( $line =~ m/./ ) {
1471  ***      0                                  0            push @args, $line;
1472                                                        }
1473                                                        else {
1474  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1475                                                        }
1476                                                     }
1477  ***      0                                  0      close $fh;
1478  ***      0                                  0      return @args;
1479                                                  }
1480                                                  
1481                                                  sub read_para_after {
1482  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1483  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1484  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1485  ***      0                                  0      my $para;
1486  ***      0                                  0      while ( $para = <$fh> ) {
1487  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1488  ***      0                                  0         last;
1489                                                     }
1490  ***      0                                  0      while ( $para = <$fh> ) {
1491  ***      0      0                           0         next unless $para =~ m/$regex/;
1492  ***      0                                  0         last;
1493                                                     }
1494  ***      0                                  0      $para = <$fh>;
1495  ***      0                                  0      chomp($para);
1496  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1497  ***      0                                  0      return $para;
1498                                                  }
1499                                                  
1500                                                  sub clone {
1501  ***      0                    0             0      my ( $self ) = @_;
1502                                                  
1503  ***      0                                  0      my %clone = map {
1504  ***      0                                  0         my $hashref  = $self->{$_};
1505  ***      0                                  0         my $val_copy = {};
1506  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1507  ***      0                                  0            my $ref = ref $hashref->{$key};
1508  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1509  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1510  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1511                                                                             : $hashref->{$key};
1512                                                        }
1513  ***      0                                  0         $_ => $val_copy;
1514                                                     } qw(opts short_opts defaults);
1515                                                  
1516  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1517  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1518                                                     }
1519                                                  
1520  ***      0                                  0      return bless \%clone;     
1521                                                  }
1522                                                  
1523                                                  sub _d {
1524  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1525  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1526  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1527                                                          @_;
1528  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1529                                                  }
1530                                                  
1531                                                  1;
1532                                                  
1533                                                  # ###########################################################################
1534                                                  # End OptionParser package
1535                                                  # ###########################################################################
1536                                                  
1537                                                  # ###########################################################################
1538                                                  # DSNParser package 5266
1539                                                  # ###########################################################################
1540                                                  package DSNParser;
1541                                                  
1542           4                    4            56   use strict;
               4                                 13   
               4                                 41   
1543           4                    4            26   use warnings FATAL => 'all';
               4                                 11   
               4                                 32   
1544           4                    4            33   use English qw(-no_match_vars);
               4                                 21   
               4                                 31   
1545           4                    4            37   use Data::Dumper;
               4                                 13   
               4                                 29   
1546                                                  $Data::Dumper::Indent    = 0;
1547                                                  $Data::Dumper::Quotekeys = 0;
1548                                                  
1549                                                  eval {
1550                                                     require DBI;
1551                                                  };
1552                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1553                                                  
1554  ***      4            50      4            29   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 11   
               4                                 72   
1555                                                  
1556                                                  sub new {
1557           2                    2            10      my ( $class, @opts ) = @_;
1558           2                                 65      my $self = {
1559                                                        opts => {
1560                                                           A => {
1561                                                              desc => 'Default character set',
1562                                                              dsn  => 'charset',
1563                                                              copy => 1,
1564                                                           },
1565                                                           D => {
1566                                                              desc => 'Database to use',
1567                                                              dsn  => 'database',
1568                                                              copy => 1,
1569                                                           },
1570                                                           F => {
1571                                                              desc => 'Only read default options from the given file',
1572                                                              dsn  => 'mysql_read_default_file',
1573                                                              copy => 1,
1574                                                           },
1575                                                           h => {
1576                                                              desc => 'Connect to host',
1577                                                              dsn  => 'host',
1578                                                              copy => 1,
1579                                                           },
1580                                                           p => {
1581                                                              desc => 'Password to use when connecting',
1582                                                              dsn  => 'password',
1583                                                              copy => 1,
1584                                                           },
1585                                                           P => {
1586                                                              desc => 'Port number to use for connection',
1587                                                              dsn  => 'port',
1588                                                              copy => 1,
1589                                                           },
1590                                                           S => {
1591                                                              desc => 'Socket file to use for connection',
1592                                                              dsn  => 'mysql_socket',
1593                                                              copy => 1,
1594                                                           },
1595                                                           u => {
1596                                                              desc => 'User for login if not current user',
1597                                                              dsn  => 'user',
1598                                                              copy => 1,
1599                                                           },
1600                                                        },
1601                                                     };
1602           2                                 13      foreach my $opt ( @opts ) {
1603  ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
1604  ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1605                                                     }
1606           2                                 22      return bless $self, $class;
1607                                                  }
1608                                                  
1609                                                  sub prop {
1610  ***      0                    0             0      my ( $self, $prop, $value ) = @_;
1611  ***      0      0                           0      if ( @_ > 2 ) {
1612  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1613  ***      0                                  0         $self->{$prop} = $value;
1614                                                     }
1615  ***      0                                  0      return $self->{$prop};
1616                                                  }
1617                                                  
1618                                                  sub parse {
1619  ***      0                    0             0      my ( $self, $dsn, $prev, $defaults ) = @_;
1620  ***      0      0                           0      if ( !$dsn ) {
1621  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1622  ***      0                                  0         return;
1623                                                     }
1624  ***      0                                  0      MKDEBUG && _d('Parsing', $dsn);
1625  ***      0             0                    0      $prev     ||= {};
1626  ***      0             0                    0      $defaults ||= {};
1627  ***      0                                  0      my %given_props;
1628  ***      0                                  0      my %final_props;
1629  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1630                                                  
1631  ***      0                                  0      foreach my $dsn_part ( split(/,/, $dsn) ) {
1632  ***      0      0                           0         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1633  ***      0                                  0            $given_props{$prop_key} = $prop_val;
1634                                                        }
1635                                                        else {
1636  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1637  ***      0                                  0            $given_props{h} = $dsn_part;
1638                                                        }
1639                                                     }
1640                                                  
1641  ***      0                                  0      foreach my $key ( keys %opts ) {
1642  ***      0                                  0         MKDEBUG && _d('Finding value for', $key);
1643  ***      0                                  0         $final_props{$key} = $given_props{$key};
1644  ***      0      0      0                    0         if (   !defined $final_props{$key}
      ***                    0                        
1645                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1646                                                        {
1647  ***      0                                  0            $final_props{$key} = $prev->{$key};
1648  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1649                                                        }
1650  ***      0      0                           0         if ( !defined $final_props{$key} ) {
1651  ***      0                                  0            $final_props{$key} = $defaults->{$key};
1652  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1653                                                        }
1654                                                     }
1655                                                  
1656  ***      0                                  0      foreach my $key ( keys %given_props ) {
1657  ***      0      0                           0         die "Unrecognized DSN part '$key' in '$dsn'\n"
1658                                                           unless exists $opts{$key};
1659                                                     }
1660  ***      0      0                           0      if ( (my $required = $self->prop('required')) ) {
1661  ***      0                                  0         foreach my $key ( keys %$required ) {
1662  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1663                                                        }
1664                                                     }
1665                                                  
1666  ***      0                                  0      return \%final_props;
1667                                                  }
1668                                                  
1669                                                  sub parse_options {
1670  ***      0                    0             0      my ( $self, $o ) = @_;
1671  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1672  ***      0                                  0      my $dsn_string
1673                                                        = join(',',
1674  ***      0      0                           0             map  { "$_=".$o->get($_); }
1675  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1676  ***      0                                  0             keys %{$self->{opts}}
1677                                                          );
1678  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1679  ***      0                                  0      return $self->parse($dsn_string);
1680                                                  }
1681                                                  
1682                                                  sub as_string {
1683  ***      0                    0             0      my ( $self, $dsn ) = @_;
1684  ***      0      0                           0      return $dsn unless ref $dsn;
1685  ***      0      0                           0      return join(',',
1686  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1687  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1688                                                        sort keys %$dsn );
1689                                                  }
1690                                                  
1691                                                  sub usage {
1692  ***      0                    0             0      my ( $self ) = @_;
1693  ***      0                                  0      my $usage
1694                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1695                                                        . "  KEY  COPY  MEANING\n"
1696                                                        . "  ===  ====  =============================================\n";
1697  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1698  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1699  ***      0      0      0                    0         $usage .= "  $key    "
1700                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1701                                                               .  ($opts{$key}->{desc} || '[No description]')
1702                                                               . "\n";
1703                                                     }
1704  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1705  ***      0                                  0      return $usage;
1706                                                  }
1707                                                  
1708                                                  sub get_cxn_params {
1709  ***      0                    0             0      my ( $self, $info ) = @_;
1710  ***      0                                  0      my $dsn;
1711  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1712  ***      0             0                    0      my $driver = $self->prop('dbidriver') || '';
1713  ***      0      0                           0      if ( $driver eq 'Pg' ) {
1714  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1715  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1716  ***      0             0                    0                        grep { defined $info->{$_} }
1717                                                                       qw(h P));
1718                                                     }
1719                                                     else {
1720  ***      0                                  0         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1721  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1722  ***      0             0                    0                        grep { defined $info->{$_} }
1723                                                                       qw(F h P S A))
1724                                                           . ';mysql_read_default_group=client';
1725                                                     }
1726  ***      0                                  0      MKDEBUG && _d($dsn);
1727  ***      0                                  0      return ($dsn, $info->{u}, $info->{p});
1728                                                  }
1729                                                  
1730                                                  sub fill_in_dsn {
1731  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1732  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1733  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1734  ***      0                                  0      $user =~ s/@.*//;
1735  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1736  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1737  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1738  ***      0             0                    0      $dsn->{u} ||= $user;
1739  ***      0             0                    0      $dsn->{D} ||= $db;
1740                                                  }
1741                                                  
1742                                                  sub get_dbh {
1743  ***      0                    0             0      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1744  ***      0             0                    0      $opts ||= {};
1745  ***      0      0                           0      my $defaults = {
1746                                                        AutoCommit         => 0,
1747                                                        RaiseError         => 1,
1748                                                        PrintError         => 0,
1749                                                        ShowErrorStatement => 1,
1750                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1751                                                     };
1752  ***      0                                  0      @{$defaults}{ keys %$opts } = values %$opts;
      ***      0                                  0   
1753                                                  
1754  ***      0      0                           0      if ( !$have_dbi ) {
1755  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1756                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1757                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1758                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1759                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1760                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1761                                                  
1762                                                     }
1763                                                  
1764  ***      0                                  0      my $dbh;
1765  ***      0                                  0      my $tries = 2;
1766  ***      0             0                    0      while ( !$dbh && $tries-- ) {
1767                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1768  ***      0                                  0            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1769                                                  
1770  ***      0                                  0         eval {
1771  ***      0                                  0            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1772                                                  
1773  ***      0      0                           0            if ( $cxn_string =~ m/mysql/i ) {
1774  ***      0                                  0               my $sql;
1775                                                  
1776  ***      0                                  0               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1777                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1778  ***      0                                  0               MKDEBUG && _d($dbh, ':', $sql);
1779  ***      0                                  0               $dbh->do($sql);
1780                                                  
1781  ***      0      0                           0               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1782  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1783  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1784  ***      0                                  0                  $dbh->do($sql);
1785  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1786  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1787  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1788                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1789                                                                 }
1790                                                                 else {
1791  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1792                                                                 }
1793                                                              }
1794                                                  
1795  ***      0      0                           0               if ( $self->prop('set-vars') ) {
1796  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1797  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1798  ***      0                                  0                  $dbh->do($sql);
1799                                                              }
1800                                                           }
1801                                                        };
1802  ***      0      0      0                    0         if ( !$dbh && $EVAL_ERROR ) {
1803  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1804  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1805  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1806  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1807                                                           }
1808                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1809  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1810                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1811                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1812                                                                 . "DBD::mysql is not installed, try:\n"
1813                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1814                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1815                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1816                                                           }
1817  ***      0      0                           0            if ( !$tries ) {
1818  ***      0                                  0               die $EVAL_ERROR;
1819                                                           }
1820                                                        }
1821                                                     }
1822                                                  
1823  ***      0                                  0      MKDEBUG && _d('DBH info: ',
1824                                                        $dbh,
1825                                                        Dumper($dbh->selectrow_hashref(
1826                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1827                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1828                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1829                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1830                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1831                                                        '$DBI::VERSION:',        $DBI::VERSION,
1832                                                     );
1833                                                  
1834  ***      0                                  0      return $dbh;
1835                                                  }
1836                                                  
1837                                                  sub get_hostname {
1838  ***      0                    0             0      my ( $self, $dbh ) = @_;
1839  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1840  ***      0                                  0         return $host;
1841                                                     }
1842  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1843                                                        'SELECT /*!50038 @@hostname, */ 1');
1844  ***      0                                  0      return $hostname;
1845                                                  }
1846                                                  
1847                                                  sub disconnect {
1848  ***      0                    0             0      my ( $self, $dbh ) = @_;
1849  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1850  ***      0                                  0      $dbh->disconnect;
1851                                                  }
1852                                                  
1853                                                  sub print_active_handles {
1854  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1855  ***      0             0                    0      $level ||= 0;
1856  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1857                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1858                                                        or die "Cannot print: $OS_ERROR";
1859  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1860  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1861                                                     }
1862                                                  }
1863                                                  
1864                                                  sub copy {
1865  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1866  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1867  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1868  ***      0                                  0      my %new_dsn = map {
1869  ***      0                                  0         my $key = $_;
1870  ***      0                                  0         my $val;
1871  ***      0      0                           0         if ( $args{overwrite} ) {
1872  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1873                                                        }
1874                                                        else {
1875  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1876                                                        }
1877  ***      0                                  0         $key => $val;
1878  ***      0                                  0      } keys %{$self->{opts}};
1879  ***      0                                  0      return \%new_dsn;
1880                                                  }
1881                                                  
1882                                                  sub _d {
1883  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1884  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1885  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1886                                                          @_;
1887  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1888                                                  }
1889                                                  
1890                                                  1;
1891                                                  
1892                                                  # ###########################################################################
1893                                                  # End DSNParser package
1894                                                  # ###########################################################################
1895                                                  
1896                                                  # ###########################################################################
1897                                                  # Daemon package 5266
1898                                                  # ###########################################################################
1899                                                  
1900                                                  package Daemon;
1901                                                  
1902           4                    4            53   use strict;
               4                                 12   
               4                                 35   
1903           4                    4            25   use warnings FATAL => 'all';
               4                                 12   
               4                                 40   
1904                                                  
1905           4                    4            27   use POSIX qw(setsid);
               4                                  9   
               4                                 40   
1906           4                    4            26   use English qw(-no_match_vars);
               4                                 11   
               4                                 29   
1907                                                  
1908  ***      4            50      4           289   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 16   
               4                                122   
1909                                                  
1910                                                  sub new {
1911  ***      0                    0             0      my ( $class, %args ) = @_;
1912  ***      0                                  0      foreach my $arg ( qw(o) ) {
1913  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1914                                                     }
1915  ***      0                                  0      my $o = $args{o};
1916  ***      0      0                           0      my $self = {
      ***             0                               
1917                                                        o        => $o,
1918                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1919                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1920                                                     };
1921                                                  
1922  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1923                                                  
1924  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1925  ***      0                                  0      return bless $self, $class;
1926                                                  }
1927                                                  
1928                                                  sub daemonize {
1929  ***      0                    0             0      my ( $self ) = @_;
1930                                                  
1931  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1932  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1933  ***      0      0                           0      if ( $pid ) {
1934  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1935  ***      0                                  0         exit;
1936                                                     }
1937                                                  
1938  ***      0                                  0      $self->{child} = 1;
1939                                                  
1940  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1941  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1942                                                  
1943  ***      0                                  0      $self->_make_PID_file();
1944                                                  
1945  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
1946                                                  
1947  ***      0      0                           0      if ( -t STDIN ) {
1948  ***      0                                  0         close STDIN;
1949  ***      0      0                           0         open  STDIN, '/dev/null'
1950                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1951                                                     }
1952                                                  
1953  ***      0      0                           0      if ( $self->{log_file} ) {
1954  ***      0                                  0         close STDOUT;
1955  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1956                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1957                                                  
1958  ***      0                                  0         close STDERR;
1959  ***      0      0                           0         open  STDERR, ">&STDOUT"
1960                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1961                                                     }
1962                                                     else {
1963  ***      0      0                           0         if ( -t STDOUT ) {
1964  ***      0                                  0            close STDOUT;
1965  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
1966                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1967                                                        }
1968  ***      0      0                           0         if ( -t STDERR ) {
1969  ***      0                                  0            close STDERR;
1970  ***      0      0                           0            open  STDERR, '>', '/dev/null'
1971                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1972                                                        }
1973                                                     }
1974                                                  
1975  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1976  ***      0                                  0      return;
1977                                                  }
1978                                                  
1979                                                  sub check_PID_file {
1980  ***      0                    0             0      my ( $self, $file ) = @_;
1981  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1982  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1983  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1984  ***      0                                  0         my $pid;
1985  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1986  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1987  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1988  ***      0      0                           0         if ( $pid ) {
1989  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1990  ***      0      0                           0            if ( $pid_is_alive ) {
1991  ***      0                                  0               die "The PID file $PID_file already exists "
1992                                                                 . " and the PID that it contains, $pid, is running";
1993                                                           }
1994                                                           else {
1995  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1996                                                                 . "contains, $pid, is not running";
1997                                                           }
1998                                                        }
1999                                                        else {
2000  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
2001                                                              . "contain a PID";
2002                                                        }
2003                                                     }
2004                                                     else {
2005  ***      0                                  0         MKDEBUG && _d('No PID file');
2006                                                     }
2007  ***      0                                  0      return;
2008                                                  }
2009                                                  
2010                                                  sub make_PID_file {
2011  ***      0                    0             0      my ( $self ) = @_;
2012  ***      0      0                           0      if ( exists $self->{child} ) {
2013  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
2014                                                     }
2015  ***      0                                  0      $self->_make_PID_file();
2016  ***      0                                  0      $self->{rm_PID_file} = 1;
2017  ***      0                                  0      return;
2018                                                  }
2019                                                  
2020                                                  sub _make_PID_file {
2021  ***      0                    0             0      my ( $self ) = @_;
2022                                                  
2023  ***      0                                  0      my $PID_file = $self->{PID_file};
2024  ***      0      0                           0      if ( !$PID_file ) {
2025  ***      0                                  0         MKDEBUG && _d('No PID file to create');
2026  ***      0                                  0         return;
2027                                                     }
2028                                                  
2029  ***      0                                  0      $self->check_PID_file();
2030                                                  
2031  ***      0      0                           0      open my $PID_FH, '>', $PID_file
2032                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
2033  ***      0      0                           0      print $PID_FH $PID
2034                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
2035  ***      0      0                           0      close $PID_FH
2036                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
2037                                                  
2038  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
2039  ***      0                                  0      return;
2040                                                  }
2041                                                  
2042                                                  sub _remove_PID_file {
2043  ***      0                    0             0      my ( $self ) = @_;
2044  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
2045  ***      0      0                           0         unlink $self->{PID_file}
2046                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
2047  ***      0                                  0         MKDEBUG && _d('Removed PID file');
2048                                                     }
2049                                                     else {
2050  ***      0                                  0         MKDEBUG && _d('No PID to remove');
2051                                                     }
2052  ***      0                                  0      return;
2053                                                  }
2054                                                  
2055                                                  sub DESTROY {
2056  ***      0                    0             0      my ( $self ) = @_;
2057  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
2058  ***      0                                  0      return;
2059                                                  }
2060                                                  
2061                                                  sub _d {
2062  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2063  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2064  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2065                                                          @_;
2066  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2067                                                  }
2068                                                  
2069                                                  1;
2070                                                  
2071                                                  # ###########################################################################
2072                                                  # End Daemon package
2073                                                  # ###########################################################################
2074                                                  
2075                                                  # ###########################################################################
2076                                                  # This is a combination of modules and programs in one -- a runnable module.
2077                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2078                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2079                                                  #
2080                                                  # Check at the end of this package for the call to main() which actually runs
2081                                                  # the program.
2082                                                  # ###########################################################################
2083                                                  package mk_visual_explain;
2084                                                  
2085           4                    4            56   use English qw(-no_match_vars);
               4                                 14   
               4                                 33   
2086           4                    4            40   use Getopt::Long;
               4                                 10   
               4                                 33   
2087           4                    4            27   use Data::Dumper;
               4                                 10   
               4                                 25   
2088                                                  $Data::Dumper::Indent    = 1;
2089                                                  $Data::Dumper::Quotekeys = 0;
2090                                                  
2091  ***      4            50      4            30   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               4                                 10   
               4                                 76   
2092                                                  
2093                                                  sub main {
2094           2                    2            12      @ARGV = @_;  # set global ARGV for this package
2095                                                  
2096                                                     # #######################################################################
2097                                                     # Get configuration information and parse command line options.
2098                                                     # #######################################################################
2099           2                                 23      my $dp = new DSNParser();
2100           2                                 21      my $o  = new OptionParser(
2101                                                        strict       => 0,
2102                                                        prompt       => '<options> [FILE]...',
2103                                                        description  => q{transforms EXPLAIN output into a tree } 
2104                                                                      . q{representation of the query plan.  If FILE is }
2105                                                                      . q{given, input is read from the file(s).  With no }
2106                                                                      . q{FILE, or when FILE is -, read standard input.},
2107                                                     );
2108           2                                 10      $o->get_specs();
2109           2                                 14      $o->get_opts();
2110           2                                 12      $o->usage_or_errors();
2111                                                  
2112                                                     # ########################################################################
2113                                                     # If --pid, check it first since we'll die if it already exits.
2114                                                     # ########################################################################
2115           2                                  5      my $daemon;
2116  ***      2     50                          11      if ( $o->get('pid') ) {
2117                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
2118                                                        # in the the scope of main() because when it's destroyed it automatically
2119                                                        # removes the PID file.
2120  ***      0                                  0         $daemon = new Daemon(o=>$o);
2121  ***      0                                  0         $daemon->make_PID_file();
2122                                                     }
2123                                                  
2124                                                     # #######################################################################
2125                                                     # Get ready to do the main work.
2126                                                     # #######################################################################
2127                                                     # Magically read STDIN or files in @ARGV
2128           2                                  6      my $text = do { local $INPUT_RECORD_SEPARATOR = undef; <>; };
               2                                 15   
               2                                163   
2129           2                                  5      my $rows;
2130                                                  
2131  ***      2     50                          13      if ( $o->got('connect') ) { # Connect to the database.
2132  ***      0                                  0         $dp->prop('set-vars', $o->get('set-vars'));
2133                                                  
2134  ***      0      0      0                    0         if ( $o->got('ask-pass') && !$o->got('password') ) {
2135  ***      0                                  0            $o->set('password', OptionParser::prompt_noecho("Enter password: "));
2136                                                        }
2137                                                  
2138  ***      0                                  0         my $dsn = $dp->parse_options($o);
2139  ***      0                                  0         my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1 } );
2140                                                  
2141  ***      0                                  0         $text =~ s{^.*?select}{EXPLAIN /*!50115 PARTITIONS*/ SELECT}is;
2142  ***      0                                  0         $rows =  $dbh->selectall_arrayref($text, { Slice => {} } );
2143  ***      0                                  0         $dbh->disconnect();
2144                                                     }
2145                                                     else {
2146           2                                 24         $rows = ExplainParser->new->parse($text);
2147                                                     }
2148                                                  
2149                                                     # #######################################################################
2150                                                     # Do the main work.
2151                                                     # #######################################################################
2152           2                                 20      my $et   = ExplainTree->new();
2153           2                                 14      my $tree = $et->process($rows, { clustered => $o->get('clustered-pk') });
2154  ***      2     50                          12      if ( $tree ) {
2155           2    100                          11         print $o->get('format') eq 'dump' ? Dumper($tree)
2156                                                           : $et->pretty_print($tree);
2157                                                     }
2158                                                  
2159           2                                 81      return 0;
2160                                                  }
2161                                                  
2162                                                  # ############################################################################
2163                                                  # Run the program.
2164                                                  # ############################################################################
2165                                                  if ( !caller ) { exit main(@ARGV); }
2166                                                  
2167                                                  1; # Because this is a module as well as a script.
2168                                                  
2169                                                  # ############################################################################
2170                                                  # Documentation.
2171                                                  # ############################################################################
2172                                                  
2173                                                  =pod
2174                                                  
2175                                                  =head1 NAME
2176                                                  
2177                                                  mk-visual-explain - Format EXPLAIN output as a tree.
2178                                                  
2179                                                  =head1 SYNOPSIS
2180                                                  
2181                                                   mk-visual-explain <file_containing_explain_output>
2182                                                   mk-visual-explain -c <file_containing_query>
2183                                                   mysql -e "explain select * from mysql.user" | mk-visual-explain
2184                                                  
2185                                                  =head1 RISKS
2186                                                  
2187                                                  The following section is included to inform users about the potential risks,
2188                                                  whether known or unknown, of using this tool.  The two main categories of risks
2189                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2190                                                  tools) and those created by bugs.
2191                                                  
2192                                                  mk-visual-explain is read-only and very low-risk.
2193                                                  
2194                                                  At the time of this release, we know of no bugs that could cause serious harm to
2195                                                  users.
2196                                                  
2197                                                  The authoritative source for updated information is always the online issue
2198                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2199                                                  see a list of such issues at the following URL:
2200                                                  L<http://www.maatkit.org/bugs/mk-visual-explain>.
2201                                                  
2202                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2203                                                  
2204                                                  =head1 DESCRIPTION
2205                                                  
2206                                                  mk-visual-explain reverse-engineers MySQL's EXPLAIN output into a query
2207                                                  execution plan, which it then formats as a left-deep tree -- the same way the
2208                                                  plan is represented inside MySQL.  It is possible to do this by hand, or to read
2209                                                  EXPLAIN's output directly, but it requires patience and expertise.  Many people
2210                                                  find a tree representation more understandable.
2211                                                  
2212                                                  You can pipe input into mk-visual-explain or specify a filename at the
2213                                                  command line, including the magical '-' filename, which will read from standard
2214                                                  input.  It can do two things with the input: parse it for something that looks
2215                                                  like EXPLAIN output, or connect to a MySQL instance and run EXPLAIN on the
2216                                                  input.
2217                                                  
2218                                                  When parsing its input, mk-visual-explain understands three formats: tabular
2219                                                  like that shown in the mysql command-line client, vertical like that created by
2220                                                  using the \G line terminator in the mysql command-line client, and tab
2221                                                  separated.  It ignores any lines it doesn't know how to parse.
2222                                                  
2223                                                  When executing the input, mk-visual-explain replaces everything in the input
2224                                                  up to the first SELECT keyword with 'EXPLAIN SELECT,' and then executes the
2225                                                  result.  You must specify L<"--connect"> to execute the input as a query.
2226                                                  
2227                                                  Either way, it builds a tree from the result set and prints it to standard
2228                                                  output.  For the following query,
2229                                                  
2230                                                   select * from sakila.film_actor join sakila.film using(film_id);
2231                                                  
2232                                                  mk-visual-explain generates this query plan:
2233                                                  
2234                                                   JOIN
2235                                                   +- Bookmark lookup
2236                                                   |  +- Table
2237                                                   |  |  table          film_actor
2238                                                   |  |  possible_keys  idx_fk_film_id
2239                                                   |  +- Index lookup
2240                                                   |     key            film_actor->idx_fk_film_id
2241                                                   |     possible_keys  idx_fk_film_id
2242                                                   |     key_len        2
2243                                                   |     ref            sakila.film.film_id
2244                                                   |     rows           2
2245                                                   +- Table scan
2246                                                      rows           952
2247                                                      +- Table
2248                                                         table          film
2249                                                         possible_keys  PRIMARY
2250                                                  
2251                                                  The query plan is left-deep, depth-first search, and the tree's root is the
2252                                                  output node -- the last step in the execution plan.  In other words, read it
2253                                                  like this:
2254                                                  
2255                                                  =over
2256                                                  
2257                                                  =item 1
2258                                                  
2259                                                  Table scan the 'film' table, which accesses an estimated 952 rows.
2260                                                  
2261                                                  =item 2
2262                                                  
2263                                                  For each row, find matching rows by doing an index lookup into the
2264                                                  film_actor->idx_fk_film_id index with the value from sakila.film.film_id, then a
2265                                                  bookmark lookup into the film_actor table.
2266                                                  
2267                                                  =back
2268                                                  
2269                                                  For more information on how to read EXPLAIN output, please see
2270                                                  L<http://dev.mysql.com/doc/en/explain.html>, and this talk titled "Query
2271                                                  Optimizer Internals and What's New in the MySQL 5.2 Optimizer," from Timour
2272                                                  Katchaounov, one of the MySQL developers:
2273                                                  L<http://maatkit.org/presentations/katchaounov_timour.pdf>.
2274                                                  
2275                                                  =head1 MODULES
2276                                                  
2277                                                  This program is actually a runnable module, not just an ordinary Perl script.
2278                                                  In fact, there are two modules embedded in it.  This makes unit testing easy,
2279                                                  but it also makes it easy for you to use the parsing and tree-building
2280                                                  functionality if you want.
2281                                                  
2282                                                  The ExplainParser package accepts a string and parses whatever it thinks looks
2283                                                  like EXPLAIN output from it.  The synopsis is as follows:
2284                                                  
2285                                                   require "mk-visual-explain";
2286                                                   my $p    = ExplainParser->new();
2287                                                   my $rows = $p->parse("some text");
2288                                                   # $rows is an arrayref of hashrefs.
2289                                                  
2290                                                  The ExplainTree package accepts a set of rows and turns it into a tree.  For
2291                                                  convenience, you can also have it delegate to ExplainParser and parse text for
2292                                                  you.  Here's the synopsis:
2293                                                  
2294                                                   require "mk-visual-explain";
2295                                                   my $e      = ExplainTree->new();
2296                                                   my $tree   = $e->parse("some text", \%options);
2297                                                   my $output = $e->pretty_print($tree);
2298                                                   print $tree;
2299                                                  
2300                                                  =head1 ALGORITHM
2301                                                  
2302                                                  This section explains the algorithm that converts EXPLAIN into a tree.  You may
2303                                                  be interested in reading this if you want to understand EXPLAIN more fully, or
2304                                                  trying to figure out how this works, but otherwise this section will probably
2305                                                  not make your life richer.
2306                                                  
2307                                                  The tree can be built by examining the id, select_type, and table columns of
2308                                                  each row.  Here's what I know about them:
2309                                                  
2310                                                  The id column is the sequential number of the select.  This does not indicate
2311                                                  nesting; it just comes from counting SELECT from the left of the SQL statement.
2312                                                  It's like capturing parentheses in a regular expression.  A UNION RESULT row
2313                                                  doesn't have an id, because it isn't a SELECT.  The source code actually refers
2314                                                  to UNIONs as a fake_lex, as I recall.
2315                                                  
2316                                                  If two adjacent rows have the same id value, they are joined with the standard
2317                                                  single-sweep multi-join method.
2318                                                  
2319                                                  The select_type column tells a) that a new sub-scope has opened b) what kind
2320                                                  of relationship the row has to the previous row c) what kind of operation the
2321                                                  row represents.
2322                                                  
2323                                                  =over
2324                                                  
2325                                                  =item *
2326                                                  
2327                                                  SIMPLE means there are no subqueries or unions in the whole query.
2328                                                  
2329                                                  =item *
2330                                                  
2331                                                  PRIMARY means there are, but this is the outermost SELECT.
2332                                                  
2333                                                  =item  *
2334                                                  
2335                                                  [DEPENDENT] UNION means this result is UNIONed with the previous result (not
2336                                                  row; a result might encompass more than one row).
2337                                                  
2338                                                  =item *
2339                                                  
2340                                                  UNION RESULT terminates a set of UNIONed results.
2341                                                  
2342                                                  =item *
2343                                                  
2344                                                  [DEPENDENT|UNCACHEABLE] SUBQUERY means a new sub-scope is opening.  This is the
2345                                                  kind of subquery that happens in a WHERE clause, SELECT list or whatnot; it does
2346                                                  not return a so-called "derived table."
2347                                                  
2348                                                  =item *
2349                                                  
2350                                                  DERIVED is a subquery in the FROM clause.
2351                                                  
2352                                                  =back
2353                                                  
2354                                                  Tables that are JOINed all have the same select_type.  For example, if you JOIN
2355                                                  three tables inside a dependent subquery, they'll all say the same thing:
2356                                                  DEPENDENT SUBQUERY.
2357                                                  
2358                                                  The table column usually specifies the table name or alias, but may also say
2359                                                  <derivedN> or <unionN,N...N>.  If it says <derivedN>, the row represents an
2360                                                  access to the temporary table that holds the result of the subquery whose id is
2361                                                  N.  If it says <unionN,..N> it's the same thing, but it refers to the results it
2362                                                  UNIONs together.
2363                                                  
2364                                                  Finally, order matters.  If a row's id is less than the one before it, I think
2365                                                  that means it is dependent on something other than the one before it.  For
2366                                                  example,
2367                                                  
2368                                                   explain select
2369                                                      (select 1 from sakila.film),
2370                                                      (select 2 from sakila.film_actor),
2371                                                      (select 3 from sakila.actor);
2372                                                  
2373                                                   | id | select_type | table      |
2374                                                   +----+-------------+------------+
2375                                                   |  1 | PRIMARY     | NULL       |
2376                                                   |  4 | SUBQUERY    | actor      |
2377                                                   |  3 | SUBQUERY    | film_actor |
2378                                                   |  2 | SUBQUERY    | film       |
2379                                                  
2380                                                  If the results were in order 2-3-4, I think that would mean 3 is a subquery of
2381                                                  2, 4 is a subquery of 3.  As it is, this means 4 is a subquery of the neares
2382                                                  previous recent row with a smaller id, which is 1.  Likewise for 3 and 2.
2383                                                  
2384                                                  This structure is hard to programatically build into a tree for the same reason
2385                                                  it's hard to understand by inspection: there are both forward and backward
2386                                                  references.  <derivedN> is a forward reference to selectN, while <unionM,N> is a
2387                                                  backward reference to selectM and selectN.  That makes recursion and other
2388                                                  tree-building algorithms hard to get right (NOTE: after implementation, I now
2389                                                  see how it would be possible to deal with both forward and backward references,
2390                                                  but I have no motivation to change something that works).  Consider the
2391                                                  following:
2392                                                  
2393                                                   select * from (
2394                                                      select 1 from sakila.actor as actor_1
2395                                                      union
2396                                                      select 1 from sakila.actor as actor_2
2397                                                   ) as der_1
2398                                                   union
2399                                                   select * from (
2400                                                      select 1 from sakila.actor as actor_3
2401                                                      union all
2402                                                      select 1 from sakila.actor as actor_4
2403                                                   ) as der_2;
2404                                                  
2405                                                   | id   | select_type  | table      |
2406                                                   +------+--------------+------------+
2407                                                   |  1   | PRIMARY      | <derived2> |
2408                                                   |  2   | DERIVED      | actor_1    |
2409                                                   |  3   | UNION        | actor_2    |
2410                                                   | NULL | UNION RESULT | <union2,3> |
2411                                                   |  4   | UNION        | <derived5> |
2412                                                   |  5   | DERIVED      | actor_3    |
2413                                                   |  6   | UNION        | actor_4    |
2414                                                   | NULL | UNION RESULT | <union5,6> |
2415                                                   | NULL | UNION RESULT | <union1,4> |
2416                                                  
2417                                                  This would be a lot easier to work with if it looked like this (I've
2418                                                  bracketed the id on rows I moved):
2419                                                  
2420                                                   | id   | select_type  | table      |
2421                                                   +------+--------------+------------+
2422                                                   | [1]  | UNION RESULT | <union1,4> |
2423                                                   |  1   | PRIMARY      | <derived2> |
2424                                                   | [2]  | UNION RESULT | <union2,3> |
2425                                                   |  2   | DERIVED      | actor_1    |
2426                                                   |  3   | UNION        | actor_2    |
2427                                                   |  4   | UNION        | <derived5> |
2428                                                   | [5]  | UNION RESULT | <union5,6> |
2429                                                   |  5   | DERIVED      | actor_3    |
2430                                                   |  6   | UNION        | actor_4    |
2431                                                  
2432                                                  In fact, why not re-number all the ids, so the PRIMARY row becomes 2, and so on?
2433                                                  That would make it even easier to read.  Unfortunately that would also have the
2434                                                  effect of destroying the meaning of the id column, which I think is important to
2435                                                  preserve in the final tree.  Also, though it makes it easier to read, it doesn't
2436                                                  make it easier to manipulate programmatically; so it's fine to leave them
2437                                                  numbered as they are.
2438                                                  
2439                                                  The goal of re-ordering is to make it easier to figure out which rows are
2440                                                  children of which rows in the execution plan.  Given the reordered list and some
2441                                                  row whose table is <union...> or <derived>, it is easy to find the beginning of
2442                                                  the slice of rows that should be child nodes in the tree: you just look for the
2443                                                  first row whose ID is the same as the first number in the table.
2444                                                  
2445                                                  The next question is how to find the last row that should be a child node of a
2446                                                  UNION or DERIVED.   I'll start with DERIVED, because the solution makes UNION
2447                                                  easy.
2448                                                  
2449                                                  Consider how MySQL numbers the SELECTs sequentially according to their position
2450                                                  in the SQL, left-to-right.  Since a DERIVED table encloses everything within it
2451                                                  in a scope, which becomes a temporary table, there are only two things to think
2452                                                  about: its child subqueries and unions (if any), and its next siblings in the
2453                                                  scope that encloses it.  Its children will all have an id greater than it does,
2454                                                  by definition, so any later rows with a smaller id terminate the scope.
2455                                                  
2456                                                  Here's an example.  The middle derived table here has a subquery and a UNION to
2457                                                  make it a little more complex for the example.
2458                                                  
2459                                                   explain select 1
2460                                                   from (
2461                                                      select film_id from sakila.film limit 1
2462                                                   ) as der_1
2463                                                   join (
2464                                                      select film_id, actor_id, (select count(*) from sakila.rental) as r
2465                                                      from sakila.film_actor limit 1
2466                                                      union all
2467                                                      select 1, 1, 1 from sakila.film_actor as dummy
2468                                                   ) as der_2 using (film_id)
2469                                                   join (
2470                                                      select actor_id from sakila.actor limit 1
2471                                                   ) as der_3 using (actor_id);
2472                                                  
2473                                                  Here's the output of EXPLAIN:
2474                                                  
2475                                                   | id   | select_type  | table      |
2476                                                   |  1   | PRIMARY      | <derived2> |
2477                                                   |  1   | PRIMARY      | <derived6> |
2478                                                   |  1   | PRIMARY      | <derived3> |
2479                                                   |  6   | DERIVED      | actor      |
2480                                                   |  3   | DERIVED      | film_actor |
2481                                                   |  4   | SUBQUERY     | rental     |
2482                                                   |  5   | UNION        | dummy      |
2483                                                   | NULL | UNION RESULT | <union3,5> |
2484                                                   |  2   | DERIVED      | film       |
2485                                                  
2486                                                  The siblings all have id 1, and the middle one I care about is derived3.
2487                                                  (Notice MySQL doesn't execute them in the order I defined them, which is fine).
2488                                                  Now notice that MySQL prints out the rows in the opposite order I defined the
2489                                                  subqueries: 6, 3, 2.  It always seems to do this, and there might be other
2490                                                  methods of finding the scope boundaries including looking for the lower boundary
2491                                                  of the next largest sibling, but this is a good enough heuristic.  I am forced
2492                                                  to rely on it for non-DERIVED subqueries, so I rely on it here too.  Therefore,
2493                                                  I decide that everything greater than or equal to 3 belongs to the DERIVED
2494                                                  scope.
2495                                                  
2496                                                  The rule for UNION is simple: they consume the entire enclosing scope, and to
2497                                                  find the component parts of each one, you find each part's beginning as referred
2498                                                  to in the <unionN,...> definition, and its end is either just before the next
2499                                                  one, or if it's the last part, the end is the end of the scope.
2500                                                  
2501                                                  This is only simple because UNION consumes the entire scope, which is either the
2502                                                  entire statement, or the scope of a DERIVED table.  This is because a UNION
2503                                                  cannot be a sibling of another UNION or a table, DERIVED or not.  (Try writing
2504                                                  such a statement if you don't see it intuitively).  Therefore, you can just find
2505                                                  the enclosing scope's boundaries, and the rest is easy.  Notice in the example
2506                                                  above, the UNION is over <union3,5>, which includes the row with id 4 -- it
2507                                                  includes every row between 3 and 5.
2508                                                  
2509                                                  Finally, there are non-derived subqueries to deal with as well.  In this case I
2510                                                  can't look at siblings to find the end of the scope as I did for DERIVED.  I
2511                                                  have to trust that MySQL executes depth-first.  Here's an example:
2512                                                  
2513                                                   explain
2514                                                   select actor_id,
2515                                                   (
2516                                                      select count(film_id)
2517                                                      + (select count(*) from sakila.film)
2518                                                      from sakila.film join sakila.film_actor using(film_id)
2519                                                      where exists(
2520                                                         select * from sakila.actor
2521                                                         where sakila.actor.actor_id = sakila.film_actor.actor_id
2522                                                      )
2523                                                   )
2524                                                   from sakila.actor;
2525                                                  
2526                                                   | id | select_type        | table      |
2527                                                   |  1 | PRIMARY            | actor      |
2528                                                   |  2 | SUBQUERY           | film       |
2529                                                   |  2 | SUBQUERY           | film_actor |
2530                                                   |  4 | DEPENDENT SUBQUERY | actor      |
2531                                                   |  3 | SUBQUERY           | film       |
2532                                                  
2533                                                  In order, the tree should be built like this:
2534                                                  
2535                                                  =over
2536                                                  
2537                                                  =item *
2538                                                  
2539                                                  See row 1.
2540                                                  
2541                                                  =item *
2542                                                  
2543                                                  See row 2.  It's a higher id than 1, so it's a subquery, along with every other
2544                                                  row whose id is greater than 2.
2545                                                  
2546                                                  =item *
2547                                                  
2548                                                  Inside this scope, see 2 and 2 and JOIN them.  See 4.  It's a higher id than 2,
2549                                                  so it's again a subquery; recurse.  After that, see 3, which is also higher;
2550                                                  recurse.
2551                                                  
2552                                                  =back
2553                                                  
2554                                                  But the only reason the nested subquery didn't include select 3 is because
2555                                                  select 4 came first.  In other words, if EXPLAIN looked like this,
2556                                                  
2557                                                   | id | select_type        | table      |
2558                                                   |  1 | PRIMARY            | actor      |
2559                                                   |  2 | SUBQUERY           | film       |
2560                                                   |  2 | SUBQUERY           | film_actor |
2561                                                   |  3 | SUBQUERY           | film       |
2562                                                   |  4 | DEPENDENT SUBQUERY | actor      |
2563                                                  
2564                                                  I would be forced to assume upon seeing select 3 that select 4 is a subquery
2565                                                  of it, rather than just being the next sibling in the enclosing scope.  If this
2566                                                  is ever wrong, then the algorithm is wrong, and I don't see what could be done
2567                                                  about it.
2568                                                  
2569                                                  UNION is a little more complicated than just "the entire scope is a UNION,"
2570                                                  because the UNION might itself be inside an enclosing scope that's only
2571                                                  indicated by the first item inside the UNION.  There are only three kinds of
2572                                                  enclosing scopes: UNION, DERIVED, and SUBQUERY.  A UNION can't enclose a UNION,
2573                                                  and a DERIVED has its own "scope markers," but a SUBQUERY can wholly enclose a
2574                                                  UNION, like this strange example on the empty table t1:
2575                                                  
2576                                                   explain select * from t1 where not exists(
2577                                                      (select t11.i from t1 t11) union (select t12.i from t1 t12));
2578                                                  
2579                                                   |   id | select_type  | table      | Extra                          |
2580                                                   +------+--------------+------------+--------------------------------+
2581                                                   |    1 | PRIMARY      | t1         | const row not found            |
2582                                                   |    2 | SUBQUERY     | NULL       | No tables used                 |
2583                                                   |    3 | SUBQUERY     | NULL       | no matching row in const table |
2584                                                   |    4 | UNION        | t12        | const row not found            |
2585                                                   | NULL | UNION RESULT | <union2,4> |                                |
2586                                                  
2587                                                  The UNION's backward references might make it look like the UNION encloses the
2588                                                  subquery, but studying the query makes it clear this isn't the case.  So when a
2589                                                  UNION's first row says SUBQUERY, it is this special case.
2590                                                  
2591                                                  By the way, I don't fully understand this query plan; there are 4 numbered
2592                                                  SELECT in the plan, but only 3 in the query.  The parens around the UNIONs are
2593                                                  meaningful.  Removing them will make the EXPLAIN different.  Please tell me how
2594                                                  and why this works if you know.
2595                                                  
2596                                                  Armed with this knowledge, it's possible to use recursion to turn the
2597                                                  parent-child relationship between all the rows into a tree representing the
2598                                                  execution plan.
2599                                                  
2600                                                  MySQL prints the rows in execution order, even the forward and backward
2601                                                  references.  At any given scope, the rows are processed as a left-deep tree.
2602                                                  MySQL does not do "bushy" execution plans.  It begins with a table, finds a
2603                                                  matching row in the next table, and continues till the last table, when it emits
2604                                                  a row.  When it runs out, it backtracks till it can find the next row and
2605                                                  repeats.  There are subtleties of course, but this is the basic plan.  This is
2606                                                  why MySQL transforms all RIGHT OUTER JOINs into LEFT OUTER JOINs and cannot do
2607                                                  FULL OUTER JOIN.
2608                                                  
2609                                                  This means in any given scope, say
2610                                                  
2611                                                   | id   | select_type  | table      |
2612                                                   |  1   | SIMPLE       | tbl1       |
2613                                                   |  1   | SIMPLE       | tbl2       |
2614                                                   |  1   | SIMPLE       | tbl3       |
2615                                                  
2616                                                  The execution plan looks like a depth-first traversal of this tree:
2617                                                  
2618                                                         JOIN
2619                                                        /    \
2620                                                      JOIN  tbl3
2621                                                     /    \
2622                                                   tbl1   tbl2
2623                                                  
2624                                                  The JOIN might not be a JOIN.  It might be a subquery, for example.  This comes
2625                                                  from the type column of EXPLAIN.  The documentation says this is a "join type,"
2626                                                  but I think "access type" is more accurate, because it's "how MySQL accesses
2627                                                  rows."
2628                                                  
2629                                                  mk-visual-explain decorates the tree significantly more than just turning
2630                                                  rows into nodes.  Each node may get a series of transformations that turn it
2631                                                  into a subtree of more than one node.  For example, an index scan not marked
2632                                                  with 'Using index' must do a bookmark lookup into the table rows; that is a
2633                                                  three-node subtree.  However, after the above node-ordering and scoping stuff,
2634                                                  the rest of the process is pretty simple.
2635                                                  
2636                                                  =head1 OPTIONS
2637                                                  
2638                                                  =over
2639                                                  
2640                                                  =item --ask-pass
2641                                                  
2642                                                  Prompt for a password when connecting to MySQL.
2643                                                  
2644                                                  =item --charset
2645                                                  
2646                                                  short form: -A; type: string
2647                                                  
2648                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2649                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
2650                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
2651                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
2652                                                  connecting to MySQL.
2653                                                  
2654                                                  =item --clustered-pk
2655                                                  
2656                                                  Assume that PRIMARY KEY index accesses don't need to do a bookmark lookup to
2657                                                  retrieve rows.  This is the case for InnoDB.
2658                                                  
2659                                                  =item --config
2660                                                  
2661                                                  type: Array
2662                                                  
2663                                                  Read this comma-separated list of config files; if specified, this must be the
2664                                                  first option on the command line.
2665                                                  
2666                                                  =item --connect
2667                                                  
2668                                                  Treat input as a query, and obtain EXPLAIN output by connecting to a MySQL
2669                                                  instance and running EXPLAIN on the query.  When this option is given,
2670                                                  mk-visual-explain uses the other connection-specific options such as
2671                                                  L<"--user"> to connect to the MySQL instance.  If you have a .my.cnf file,
2672                                                  it will read it, so you may not need to specify any connection-specific
2673                                                  options.
2674                                                  
2675                                                  =item --database
2676                                                  
2677                                                  short form: -D; type: string
2678                                                  
2679                                                  Connect to this database.
2680                                                  
2681                                                  =item --defaults-file
2682                                                  
2683                                                  short form: -F; type: string
2684                                                  
2685                                                  Only read mysql options from the given file.  You must give an absolute
2686                                                  pathname.
2687                                                  
2688                                                  =item --format
2689                                                  
2690                                                  type: string; default: tree
2691                                                  
2692                                                  Set output format.
2693                                                  
2694                                                  The default is a terse pretty-printed tree. The valid values are:
2695                                                  
2696                                                   value  meaning
2697                                                   =====  =======
2698                                                   tree   Pretty-printed terse tree.
2699                                                   dump   Data::Dumper output (see L<Data::Dumper> for more).
2700                                                  
2701                                                  =item --help
2702                                                  
2703                                                  Show help and exit.
2704                                                  
2705                                                  =item --host
2706                                                  
2707                                                  short form: -h; type: string
2708                                                  
2709                                                  Connect to host.
2710                                                  
2711                                                  =item --password
2712                                                  
2713                                                  short form: -p; type: string
2714                                                  
2715                                                  Password to use when connecting.
2716                                                  
2717                                                  =item --pid
2718                                                  
2719                                                  type: string
2720                                                  
2721                                                  Create the given PID file.  The file contains the process ID of the script.
2722                                                  The PID file is removed when the script exits.  Before starting, the script
2723                                                  checks if the PID file already exists.  If it does not, then the script creates
2724                                                  and writes its own PID to it.  If it does, then the script checks the following:
2725                                                  if the file contains a PID and a process is running with that PID, then
2726                                                  the script dies; or, if there is no process running with that PID, then the
2727                                                  script overwrites the file with its own PID and starts; else, if the file
2728                                                  contains no PID, then the script dies.
2729                                                  
2730                                                  =item --port
2731                                                  
2732                                                  short form: -P; type: int
2733                                                  
2734                                                  Port number to use for connection.
2735                                                  
2736                                                  =item --set-vars
2737                                                  
2738                                                  type: string; default: wait_timeout=10000
2739                                                  
2740                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
2741                                                  string will be appended to SET and executed.
2742                                                  
2743                                                  =item --socket
2744                                                  
2745                                                  short form: -S; type: string
2746                                                  
2747                                                  Socket file to use for connection.
2748                                                  
2749                                                  =item --user
2750                                                  
2751                                                  short form: -u; type: string
2752                                                  
2753                                                  User for login if not current user.
2754                                                  
2755                                                  =item --version
2756                                                  
2757                                                  Show version and exit.
2758                                                  
2759                                                  =back
2760                                                  
2761                                                  =head1 DOWNLOADING
2762                                                  
2763                                                  You can download Maatkit from Google Code at
2764                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2765                                                  easily with a command like the following:
2766                                                  
2767                                                     wget http://www.maatkit.org/get/toolname
2768                                                     or
2769                                                     wget http://www.maatkit.org/trunk/toolname
2770                                                  
2771                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2772                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2773                                                  needed.  The first URL gets the latest released version of the tool, and the
2774                                                  second gets the latest trunk code from Subversion.
2775                                                  
2776                                                  =head1 ENVIRONMENT
2777                                                  
2778                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2779                                                  the Maatkit tools:
2780                                                  
2781                                                     MKDEBUG=1 mk-....
2782                                                  
2783                                                  =head1 SYSTEM REQUIREMENTS
2784                                                  
2785                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2786                                                  installed in any reasonably new version of Perl.
2787                                                  
2788                                                  =head1 BUGS
2789                                                  
2790                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-visual-explain>.
2791                                                  
2792                                                  Please use Google Code Issues and Groups to report bugs or request support:
2793                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2794                                                  discuss Maatkit.
2795                                                  
2796                                                  Please include the complete command-line used to reproduce the problem you are
2797                                                  seeing, the version of all MySQL servers involved, the complete output of the
2798                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2799                                                  running with the C<MKDEBUG=1> environment variable.
2800                                                  
2801                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2802                                                  
2803                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
2804                                                  Feedback and improvements are welcome.
2805                                                  
2806                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2807                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2808                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2809                                                  
2810                                                  This program is free software; you can redistribute it and/or modify it under
2811                                                  the terms of the GNU General Public License as published by the Free Software
2812                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2813                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2814                                                  licenses.
2815                                                  
2816                                                  You should have received a copy of the GNU General Public License along with
2817                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2818                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2819                                                  
2820                                                  =head1 SEE ALSO
2821                                                  
2822                                                  See also L<mk-query-profiler>.
2823                                                  
2824                                                  =head1 AUTHOR
2825                                                  
2826                                                  Baron "Xaprb" Schwartz
2827                                                  
2828                                                  =head1 ABOUT MAATKIT
2829                                                  
2830                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2831                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2832                                                  code contributors.  Both are employed by Percona.  Financial support for
2833                                                  Maatkit development is primarily provided by Percona and its clients. 
2834                                                  
2835                                                  =head1 VERSION
2836                                                  
2837                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
2838                                                  
2839                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
46           100     54    158   unless @cols
55           100     10     17   unless @cols
75           100     54     14   if ($text =~ /^\+---/m) { }
             100     10      4   elsif ($text =~ /^id\tselect_type\t/m) { }
             100      3      1   elsif ($text =~ /\*\*\* 1. row/) { }
88           100     67      1   if ($line_re)
93           100    178     64   if ($row) { }
95           100    608   1174   if (not $$row{$key} or $$row{$key} eq 'NULL')
127          100      3     64   if ($options and ref $options eq 'HASH') { }
146          100      1     62   unless ref $rows eq 'ARRAY' and @$rows
160          100      1    169   if $$row{'table'} and $$row{'table'} =~ /\./
163          100     12    157   if (not defined $$row{'id'})
164   ***     50     12      0   if ($$row{'table'} and my($id) = $$row{'table'} =~ /^<union(\d+)/) { }
182          100     12    123   if ($last_id != $$row{'id'} and $union_for{$$row{'id'}})
198   ***     50      0    120   if (not @rows)
203          100     12    108   if ($rows[0]{'select_type'} eq 'UNION RESULT')
208          100      2     10   if ($rows[0]{'select_type'} =~ /SUBQUERY/)
213          100     12     12   $i < $#ids ? :
217          100      2     22   unless $self->recursive_table_name($_)
221          100      2     10   if ($enclosing_scope)
231          100    205     17   if $$_{'table'}
273          100      2    106   if ($$first{'Extra'} =~ /Using temporary; Using filesort/) { }
             100      1    105   elsif ($$first{'Extra'} =~ /Using filesort/ and $$first{'type'} =~ /^(?:system|const)$/) { }
286   ***     50      1      0   if ($first_non_const)
297          100     27     19   if ($$row{'id'} == $scope) { }
321          100      2    106   if ($is_temp_filesort)
342          100      6      2   !($$row{'select_type'} =~ /^(?:PRIMARY|SIMPLE)$/) ? :
      ***     50      1      0   $$row{'Extra'} =~ /optimized away/ ? :
             100      4      1   $$row{'Extra'} =~ /(?:$no_matching_row)/i ? :
             100      8      5   $$row{'Extra'} =~ /No tables/ ? :
             100    136     13   $sub ? :
356          100      8    141   if ($warn)
363          100     29    120   if ($$row{'Extra'} =~ /Using where/)
370          100      1    148   if ($$row{'Extra'} =~ /Using join buffer/)
377          100      2    147   if ($$row{'Extra'} =~ /Distinct|Not exists/)
384          100      3    146   if ($$row{'Extra'} =~ /Range checked for each record \(\w+ map: ([^\)]+)\)/)
404          100      3    146   if ($$row{'Extra'} =~ /Using filesort/)
408          100      1    148   if ($$row{'Extra'} =~ /Using temporary/)
424          100     52     44   if ($$row{'id'} and $$row{'id'} == $id)
429   ***      0      0      0   unless $$_{'id'}
436          100      6      2   $prefix ? :
440          100      4      4   if ($$node{'children'})
443          100      2      6   @kids > 1 ? :
446          100     15     57   if (defined $$node{$thing})
455          100      4      4   if ($last_child)
554          100     13     66   if ($$node{'table'})
557          100     34     32   if ($$node{'key'})
561          100      1     31   if ($$node{'type'} eq 'Bookmark lookup')
564          100      1     30   if ($$node{'type'} eq 'IMPOSSIBLE')
567          100     26      4   if ($$node{'children'})
601          100      5      1   if (not @children)
623          100     28     42   $$row{'table'} && $$row{'table'} =~ /^(derived|union)\(/ ? :
631          100     28     42   if ($$row{'children'})
639          100     66     24   if ($$row{'Extra'} =~ /Using index/ or $$self{'clustered'} and $$row{'key'} and $$row{'key'} eq 'PRIMARY')
667          100      1      2   if ($is_scan)
688          100      2     95   if ($$row{'Extra'} =~ /Full scan on NULL key/)
691          100      1     96   if ($$row{'Extra'} =~ /Using index for group-by/)
695          100     86     11   if ($$row{'type'} ne 'index_merge')
729   ***     50      0      2   unless $args{$arg}
735   ***     50      2      0   exists $args{'strict'} ? :
778   ***     50      0      2   unless open my $fh, '<', $file
798          100    750      2   unless $para =~ /^=head1 OPTIONS/
803   ***     50      2      0   if $para =~ /^=over/
811   ***     50      0      2   unless $para
814          100     34      2   if (my($option) = $para =~ /^=item --(.*)/)
821          100     24     10   if ($para =~ /: /) { }
825   ***     50      0     44   unless $attributes{$attrib}
829          100     16      8   if ($attribs{'short form'})
845   ***     50      0     34   if $para =~ /^=item/
847   ***     50      0     34   if (my($base_option) = $option =~ /^\[no\](.*)/)
852          100     16     18   $attribs{'short form'} ? :
      ***     50      0     34   $attribs{'negatable'} ? :
      ***     50      0     34   $attribs{'cumulative'} ? :
             100     24     10   $attribs{'type'} ? :
             100      4     30   $attribs{'default'} ? :
      ***     50      0     34   $attribs{'group'} ? :
864   ***     50      0     42   unless $para
867          100      2     40   if ($para =~ /^=head1/)
871          100     34      6   if $para =~ /^=item --/
875   ***     50      0      2   unless @specs
886   ***     50     34      0   if (ref $opt) { }
891   ***     50      0     34   if (not $long)
896   ***     50      0     34   if exists $$self{'opts'}{$long}
899   ***     50      0     34   if (length $long == 1)
904          100     16     18   if ($short) { }
905   ***     50      0     16   if exists $$self{'short_opts'}{$short}
914   ***     50      0     34   $$opt{'spec'} =~ /!/ ? :
915   ***     50      0     34   $$opt{'spec'} =~ /\+/ ? :
916   ***     50      0     34   $$opt{'desc'} =~ /required/ ? :
928   ***     50      0     34   if ($type and $type eq 'd' and not $$self{'dp'})
933          100      2     32   if $type and $type =~ /[HhAadzm]/
935          100      4     30   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
936   ***     50      4      0   defined $def ? :
940          100      2     32   if ($long eq 'config')
944   ***     50      0     34   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
957   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
962   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
967   ***      0      0      0   if ($opt =~ /default to/)
972   ***      0      0      0   if ($opt =~ /restricted to option groups/)
982   ***      0      0      0   unless $rule_ok
999   ***      0      0      0   unless exists $$self{'opts'}{$long}
1023  ***      0      0      0   unless exists $$self{'opts'}{$long}
1043  ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50      1      0   exists $$self{'opts'}{$opt} ? :
1048  ***     50      0      1   if ($$opt{'is_cumulative'}) { }
1063  ***     50      0     28   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100      6     28   exists $$self{'defaults'}{$long} ? :
1072  ***     50      0      2   if (@ARGV and $ARGV[0] eq '--config')
1076  ***     50      2      0   if ($self->has('config'))
1082  ***     50      8      0   if ($EVAL_ERROR)
1083  ***     50      0      8   $self->got('config') ? :
1098  ***     50      0      2   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
1101  ***     50      0      2   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
1102  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1108  ***     50      0      2   if (@ARGV and $$self{'strict'})
1114  ***      0      0      0   if (@set > 1)
1125  ***      0      0      0   if (@set == 0)
1135         100      1     33   if ($$opt{'got'}) { }
      ***     50      0     33   elsif ($$opt{'is_required'}) { }
1136  ***     50      0      1   if (exists $$self{'disables'}{$long})
1143  ***     50      0      1   if (exists $$self{'allowed_groups'}{$long})
1155  ***      0      0      0   if $restricted_opt eq $long
1156  ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
1161  ***      0      0      0   if (@restricted_opts)
1163  ***      0      0      0   if (@restricted_opts == 1) { }
1192         100     10     24   unless $opt and $$opt{'type'}
1195  ***     50      0     24   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0     24   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     24   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0     24   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      2     22   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1198  ***      0      0      0   if (not $suffix)
1204  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1205  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1220  ***      0      0      0   if ($from_key)
1231  ***      0      0      0   if (defined $num) { }
1232  ***      0      0      0   if ($factor)
1259  ***     50      0      8   length $opt == 1 ? :
1260  ***     50      0      8   unless $long and exists $$self{'opts'}{$long}
1267  ***     50      0     10   length $opt == 1 ? :
1268  ***     50      0     10   unless $long and exists $$self{'opts'}{$long}
1275  ***     50      0      2   length $opt == 1 ? :
1276  ***     50      2      0   defined $long ? :
1281  ***      0      0      0   length $opt == 1 ? :
1282  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1316  ***     50      0      2   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      2   elsif (scalar @{$$self{'errors'};}) { }
1317  ***      0      0      0   unless print $self->print_usage
1321  ***      0      0      0   unless print $self->print_errors
1330  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1339  ***      0      0      0   unless $$self{'got_opts'}
1342  ***      0      0      0   $$_{'is_negatable'} ? :
1346  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1362  ***      0      0      0   $group eq 'default' ? :
1368  ***      0      0      0   $$opt{'is_negatable'} ? :
1371  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1380  ***      0      0      0   if ($short) { }
1389  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1393  ***      0      0      0   if ($$self{'dp'})
1401  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1413  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1416  ***      0      0      0   unless print $prompt
1424  ***      0      0      0   unless print "\n"
1427  ***      0      0      0   if ($EVAL_ERROR)
1449  ***     50      8      0   unless open my $fh, '<', $filename
1457  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1460  ***      0      0      0   if ($line eq '--')
1465  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1483  ***      0      0      0   unless open my $fh, '<', $file
1487  ***      0      0      0   unless $para =~ /^=pod$/m
1491  ***      0      0      0   unless $para =~ /$regex/
1496  ***      0      0      0   unless close $fh
1510  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1525  ***      0      0      0   defined $_ ? :
1611  ***      0      0      0   if (@_ > 2)
1620  ***      0      0      0   if (not $dsn)
1632  ***      0      0      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1644  ***      0      0      0   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1650  ***      0      0      0   if (not defined $final_props{$key})
1657  ***      0      0      0   unless exists $opts{$key}
1660  ***      0      0      0   if (my $required = $self->prop('required'))
1662  ***      0      0      0   unless $final_props{$key}
1671  ***      0      0      0   unless ref $o eq 'OptionParser'
1674  ***      0      0      0   if $o->has($_)
1684  ***      0      0      0   unless ref $dsn
1685  ***      0      0      0   $_ eq 'p' ? :
1686  ***      0      0      0   if defined $$dsn{$_}
1699  ***      0      0      0   $opts{$key}{'copy'} ? :
1713  ***      0      0      0   if ($driver eq 'Pg') { }
1745  ***      0      0      0   $cxn_string =~ /charset=utf8/ ? :
1754  ***      0      0      0   if (not $have_dbi)
1773  ***      0      0      0   if ($cxn_string =~ /mysql/i)
1781  ***      0      0      0   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1786  ***      0      0      0   if ($charset eq 'utf8') { }
1787  ***      0      0      0   unless binmode STDOUT, ':utf8'
1791  ***      0      0      0   unless binmode STDOUT
1795  ***      0      0      0   if ($self->prop('set-vars'))
1802  ***      0      0      0   if (not $dbh and $EVAL_ERROR)
1804  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1817  ***      0      0      0   if (not $tries)
1839  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1856  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1866  ***      0      0      0   unless $dsn_1
1867  ***      0      0      0   unless $dsn_2
1871  ***      0      0      0   if ($args{'overwrite'}) { }
1872  ***      0      0      0   defined $$dsn_1{$key} ? :
1875  ***      0      0      0   defined $$dsn_2{$key} ? :
1884  ***      0      0      0   defined $_ ? :
1913  ***      0      0      0   unless $args{$arg}
1916  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1932  ***      0      0      0   unless defined(my $pid = fork)
1933  ***      0      0      0   if ($pid)
1940  ***      0      0      0   unless POSIX::setsid()
1941  ***      0      0      0   unless chdir '/'
1947  ***      0      0      0   if (-t STDIN)
1949  ***      0      0      0   unless open STDIN, '/dev/null'
1953  ***      0      0      0   if ($$self{'log_file'}) { }
1955  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1959  ***      0      0      0   unless open STDERR, '>&STDOUT'
1963  ***      0      0      0   if (-t STDOUT)
1965  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1968  ***      0      0      0   if (-t STDERR)
1970  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1981  ***      0      0      0   $self ? :
1983  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1986  ***      0      0      0   if $EVAL_ERROR
1988  ***      0      0      0   if ($pid) { }
1990  ***      0      0      0   if ($pid_is_alive) { }
2012  ***      0      0      0   if (exists $$self{'child'})
2024  ***      0      0      0   if (not $PID_file)
2031  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
2033  ***      0      0      0   unless print $PID_FH $PID
2035  ***      0      0      0   unless close $PID_FH
2044  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
2045  ***      0      0      0   unless unlink $$self{'PID_file'}
2057  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
2063  ***      0      0      0   defined $_ ? :
2116  ***     50      0      2   if ($o->get('pid'))
2131  ***     50      0      2   if ($o->got('connect')) { }
2134  ***      0      0      0   if ($o->got('ask-pass') and not $o->got('password'))
2154  ***     50      2      0   if ($tree)
2155         100      1      1   $o->get('format') eq 'dump' ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
127   ***     66     64      0      3   $options and ref $options eq 'HASH'
146   ***     66      0      1     62   ref $rows eq 'ARRAY' and @$rows
160          100     33    136      1   $$row{'table'} and $$row{'table'} =~ /\./
164   ***     33      0      0     12   $$row{'table'} and my($id) = $$row{'table'} =~ /^<union(\d+)/
182          100     27     96     12   $last_id != $$row{'id'} and $union_for{$$row{'id'}}
237          100     12      4     32   $end < @rows and $rows[$end]{'id'} >= $der_id
273          100    103      2      1   $$first{'Extra'} =~ /Using filesort/ and $$first{'type'} =~ /^(?:system|const)$/
308          100     18      1     26   $end < @rows and $rows[$end]{'id'} >= $$row{'id'}
424   ***     66      0     44     52   $$row{'id'} and $$row{'id'} == $id
623   ***     66      0     42     28   $$row{'table'} && $$row{'table'} =~ /^(derived|union)\(/
639   ***     66     24      0      1   $$self{'clustered'} and $$row{'key'}
      ***     66     24      0      1   $$self{'clustered'} and $$row{'key'} and $$row{'key'} eq 'PRIMARY'
928   ***     66     10     24      0   $type and $type eq 'd'
      ***     33     34      0      0   $type and $type eq 'd' and not $$self{'dp'}
933          100     10     22      2   $type and $type =~ /[HhAadzm]/
1072  ***     33      0      2      0   @ARGV and $ARGV[0] eq '--config'
1101  ***     33      0      2      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
1108  ***     33      0      2      0   @ARGV and $$self{'strict'}
1192  ***     66      0     10     24   $opt and $$opt{'type'}
1195  ***     66     18      6      0   $val and $$opt{'type'} eq 'm'
      ***     66     18      6      0   $val and $$opt{'type'} eq 'd'
      ***     66     18      6      0   $val and $$opt{'type'} eq 'z'
      ***     66     18      6      0   defined $val and $$opt{'type'} eq 'h'
      ***     66     18      4      0   defined $val and $$opt{'type'} eq 'a'
1260  ***     33      0      0      8   $long and exists $$self{'opts'}{$long}
1268  ***     33      0      0     10   $long and exists $$self{'opts'}{$long}
1282  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1371  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1465  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1644  ***      0      0      0      0   not defined $final_props{$key} and defined $$prev{$key}
      ***      0      0      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1766  ***      0      0      0      0   not $dbh and $tries--
1802  ***      0      0      0      0   not $dbh and $EVAL_ERROR
1983  ***      0      0      0      0   $PID_file and -f $PID_file
2044  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2134  ***      0      0      0      0   $o->got('ask-pass') and not $o->got('password')

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
153          100    127     43   $$row{'Extra'} ||= ''
245          100     15      1   $self->recursive_table_name($kids) || '<none>'
435          100      6      2   $prefix ||= ''
713   ***     50      0      4   $ENV{'MKDEBUG'} || 0
733   ***     50      2      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
735   ***     50      2      0   $args{'prompt'} || '<options>'
      ***     50      0      2   $args{'dp'} || undef
777   ***     50      0      2   $file ||= '/home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain'
918   ***     50     34      0   $$opt{'group'} ||= 'default'
1200  ***      0      0      0   $s || 's'
1209  ***      0      0      0   $prefix || ''
1237  ***      0      0      0   $pre || ''
1244  ***      0      0      0   $val || ''
1247  ***     50      2      0   $val || ''
1305  ***      0      0      0   $$self{'description'} || ''
1373  ***      0      0      0   $s ||= 's'
1399  ***      0      0      0   $$opt{'type'} || ''
1554  ***     50      0      4   $ENV{'MKDEBUG'} || 0
1625  ***      0      0      0   $prev ||= {}
1626  ***      0      0      0   $defaults ||= {}
1699  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1712  ***      0      0      0   $self->prop('dbidriver') || ''
1716  ***      0      0      0   $$info{'D'} || ''
1722  ***      0      0      0   $$info{'D'} || ''
1744  ***      0      0      0   $opts ||= {}
1839  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1855  ***      0      0      0   $level ||= 0
1856  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1908  ***     50      0      4   $ENV{'MKDEBUG'} || 0
2091  ***     50      0      4   $ENV{'MKDEBUG'} || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
95           100     59    549   1174   not $$row{$key} or $$row{$key} eq 'NULL'
639          100     65      1     24   $$row{'Extra'} =~ /Using index/ or $$self{'clustered'} and $$row{'key'} and $$row{'key'} eq 'PRIMARY'
679   ***     66     11     86      0   $key || $$row{'key'}
732   ***     33      2      0      0   $program_name ||= $PROGRAM_NAME
733   ***     33      2      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33      2      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
1195  ***     33      0      0     24   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      2      0     22   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1735  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1736  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1737  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1738  ***      0      0      0      0   $$dsn{'u'} ||= $user
1739  ***      0      0      0      0   $$dsn{'D'} ||= $db
2057  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}


Covered Subroutines
-------------------

Subroutine           Count Location                                                         
-------------------- ----- -----------------------------------------------------------------
ALL                     38 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:467 
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:115 
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:116 
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1542
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1543
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1544
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1545
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1554
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1902
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1903
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1905
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1906
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1908
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:2085
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:2086
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:2087
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:2091
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:22  
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:23  
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:35  
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:36  
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:706 
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:707 
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:709 
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:710 
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:711 
BEGIN                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:713 
__ANON__                 1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1096
_parse_specs             2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:882 
_pod_to_specs            2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:776 
_read_config_file        8 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1448
_set_option              1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1042
_validate_type          34 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1191
bookmark_lookup         90 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:638 
build_query_plan       120 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:196 
const                    7 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:506 
eq_ref                  10 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:491 
filesort                 5 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:651 
fulltext                 1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:476 
get                      8 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1258
get_defaults_files       2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:771 
get_opts                 2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1059
get_specs                2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:764 
got                     10 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1266
has                      2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1274
index                   45 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:486 
index_access            97 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:678 
index_merge              4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:535 
index_of                52 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:421 
index_subquery           1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:525 
load_options            67 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:126 
main                     2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:2094
new                      4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:119 
new                      2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1557
new                     64 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:39  
new                      2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:727 
parse                   61 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:136 
parse                   68 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:67  
parse_tab_sep           27 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:52  
parse_tabular          212 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:43  
parse_vertical           3 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:61  
pretty_print             8 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:434 
process                 63 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:144 
range                    3 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:481 
recurse_index_merge      6 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:579 
recursive_table_name    79 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:553 
ref                     17 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:496 
ref_or_null              1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:501 
system                   8 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:511 
table                   70 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:622 
temporary                3 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:659 
transform              149 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:330 
unique_subquery          1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:520 
usage_or_errors          2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1315

Uncovered Subroutines
---------------------

Subroutine           Count Location                                                         
-------------------- ----- -----------------------------------------------------------------
DESTROY                  0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:2056
_d                       0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1524
_d                       0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1883
_d                       0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:2062
_get_participants        0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:996 
_make_PID_file           0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:2021
_remove_PID_file         0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:2043
as_string                0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1683
check_PID_file           0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1980
clone                    0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1501
copy                     0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1865
daemonize                0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1929
descr                    0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1304
disconnect               0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1848
errors                   0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1294
fill_in_dsn              0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1731
get_cxn_params           0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1709
get_dbh                  0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1743
get_defaults             0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1032
get_groups               0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1037
get_hostname             0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1838
make_PID_file            0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:2011
new                      0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1911
opts                     0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1008
parse                    0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1619
parse_options            0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1670
print_active_handles     0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1854
print_errors             0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1328
print_usage              0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1338
prompt                   0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1299
prompt_noecho            0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1413
prop                     0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1610
read_para_after          0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1482
save_error               0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1289
set                      0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1280
set_defaults             0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1020
short_opts               0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1014
usage                    0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1692


mk-visual-explain.t

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     BEGIN {
4     ***      1     50     33      1            37      die "The MAATKIT_TRUNK environment variable is not set.  See http://code.google.com/p/maatkit/wiki/Testing"
5                                                           unless $ENV{MAATKIT_TRUNK} && -d $ENV{MAATKIT_TRUNK};
6              1                                  8      unshift @INC, "$ENV{MAATKIT_TRUNK}/common";
7                                                     };
8                                                     
9              1                    1            13   use strict;
               1                                  2   
               1                                  7   
10             1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  7   
11             1                    1            14   use English qw(-no_match_vars);
               1                                  3   
               1                                  9   
12             1                    1            12   use Test::More tests => 3;
               1                                  3   
               1                                 13   
13                                                    
14             1                    1            16   use MaatkitTest;
               1                                  3   
               1                                 15   
15             1                                 16   require "$trunk/mk-visual-explain/mk-visual-explain";
16                                                    
17                                                    sub run {
18             2                    2             9      my $output = '';
19    ***      1     50             1           404      open OUTPUT, '>', \$output
               1                                  3   
               1                                  8   
               2                                 28   
20                                                          or die 'Cannot open output to variable';
21             2                                 35      select OUTPUT;
22             2                                 15      mk_visual_explain::main(@_);
23             2                                113      select STDOUT;
24             2                                 17      close $output;
25             2                                 32      return $output;
26                                                    }
27                                                    
28             1                                  8   like(
29                                                       run("$trunk/mk-visual-explain/t/samples/simple_union.sql"),
30                                                       qr/\+\- UNION/,
31                                                       'Read optional input file (issue 394)',
32                                                    );
33                                                    
34             1                                 17   like(
35                                                       run("$trunk/mk-visual-explain/t/samples/simple_union.sql", qw(--format dump)),
36                                                       qr/\$VAR1 = {/,
37                                                       '--format dump (issue 393)'
38                                                    );
39                                                    
40                                                    # #########################################################################
41                                                    # Issue 391: Add --pid option to all scripts
42                                                    # #########################################################################
43             1                              44212   `touch /tmp/mk-script.pid`;
44             1                             266783   my $output = `$trunk/mk-visual-explain/mk-visual-explain $trunk/mk-visual-explain/t/samples/simple_union.sql --format dump --pid /tmp/mk-script.pid 2>&1`;
45             1                                 58   like(
46                                                       $output,
47                                                       qr{PID file /tmp/mk-script.pid already exists},
48                                                       'Dies if PID file already exists (issue 391)'
49                                                    );
50             1                              60963   `rm -rf /tmp/mk-script.pid`;
51                                                    
52                                                    # #############################################################################
53                                                    # Done.
54                                                    # #############################################################################
55             1                                 10   exit;


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
4     ***     50      0      1   unless $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}
19    ***     50      0      2   unless open OUTPUT, '>', \$output


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
4     ***     33      0      0      1   $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}


Covered Subroutines
-------------------

Subroutine Count Location              
---------- ----- ----------------------
BEGIN          1 mk-visual-explain.t:10
BEGIN          1 mk-visual-explain.t:11
BEGIN          1 mk-visual-explain.t:12
BEGIN          1 mk-visual-explain.t:14
BEGIN          1 mk-visual-explain.t:19
BEGIN          1 mk-visual-explain.t:4 
BEGIN          1 mk-visual-explain.t:9 
run            2 mk-visual-explain.t:18


