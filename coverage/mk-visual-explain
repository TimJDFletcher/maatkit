---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...explain/mk-visual-explain   41.8   32.7   28.0   54.0    n/a  100.0   38.6
Total                          41.8   32.7   28.0   54.0    n/a  100.0   38.6
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          mk-visual-explain.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat Jun 13 20:36:16 2009
Finish:       Sat Jun 13 20:36:17 2009

/home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     # This is mk-visual-explain, a program to transform MySQL's EXPLAIN output
3                                                     # into a query execution plan formatted as a tree.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22             1                    1             8   use strict;
               1                                  2   
               1                                  9   
23             1                    1           105   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 3867 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # Converts text (e.g. saved output) to a "recordset" -- an array of hashrefs
31                                                    # -- just like EXPLAIN does for selectall_arrayref({}).
32                                                    # ###########################################################################
33                                                    package ExplainParser;
34                                                    
35             1                    1             6   use strict;
               1                                  2   
               1                                  4   
36             1                    1             5   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
37                                                    
38                                                    sub new {
39             2                    2            26      bless {}, shift;
40                                                    }
41                                                    
42                                                    sub parse_tabular {
43             8                    8            55      my ( $text, @cols ) = @_;
44             8                                 23      my %row;
45             8                                155      my @vals = $text =~ m/\| +([^\|]*?)(?= +\|)/msg;
46             8    100                          46      return (undef, \@vals) unless @cols;
47             6                                 53      @row{@cols} = @vals;
48             6                                 34      return (\%row, undef);
49                                                    }
50                                                    
51                                                    sub parse_tab_sep {
52    ***      0                    0             0      my ( $text, @cols ) = @_;
53    ***      0                                  0      my %row;
54    ***      0                                  0      my @vals = split(/\t/, $text);
55    ***      0      0                           0      return (undef, \@vals) unless @cols;
56    ***      0                                  0      @row{@cols} = @vals;
57    ***      0                                  0      return (\%row, undef);
58                                                    }
59                                                    
60                                                    sub parse_vertical {
61    ***      0                    0             0      my ( $text, @cols ) = @_;
62    ***      0                                  0      my %row = $text =~ m/^ *(\w+): ([^\n]*) *$/msg;
63    ***      0                                  0      return (\%row, undef);
64                                                    }
65                                                    
66                                                    sub parse {
67             2                    2            10      my ($self, $text) = @_;
68             2                                  7      my $started = 0;
69             2                                  5      my $lines   = 0;
70             2                                  7      my @cols    = ();
71             2                                  5      my @result  = ();
72                                                    
73                                                       # Detect which kind of input it is
74             2                                  6      my ( $line_re, $vals_sub );
75    ***      2     50                          11      if ( $text =~ m/^\+---/m ) { # standard "tabular" output
      ***             0                               
      ***             0                               
76             2                                 16         $line_re  = qr/^(\| .*)[\r\n]+/m;
77             2                                  8         $vals_sub = \&parse_tabular;
78                                                       }
79                                                       elsif ( $text =~ m/^id\tselect_type\t/m ) { # tab-separated
80    ***      0                                  0         $line_re  = qr/^(.*?\t.*)[\r\n]+/m;
81    ***      0                                  0         $vals_sub = \&parse_tab_sep;
82                                                       }
83                                                       elsif ( $text =~ m/\*\*\* 1. row/ ) { # "vertical" output
84    ***      0                                  0         $line_re  = qr/^( *.*?^ *Extra:[^\n]*$)/ms;
85    ***      0                                  0         $vals_sub = \&parse_vertical;
86                                                       }
87                                                    
88    ***      2     50                           8      if ( $line_re ) {
89                                                          # Pull it apart into lines and parse them.
90                                                          LINE:
91             2                                 24         foreach my $line ( $text =~ m/$line_re/g ) {
92             8                                 34            my ($row, $cols) = $vals_sub->($line, @cols);
93             8    100                          28            if ( $row ) {
94             6                                 36               foreach my $key ( keys %$row ) {
95            60    100    100                  472                  if ( !$row->{$key} || $row->{$key} eq 'NULL' ) {
96            22                                 73                     $row->{$key} = undef;
97                                                                   }
98                                                                }
99             6                                 27               push @result, $row;
100                                                            }
101                                                            else {
102            2                                 22               @cols = @$cols;
103                                                            }
104                                                         }
105                                                      }
106                                                   
107            2                                 23      return \@result;
108                                                   }
109                                                   
110                                                   # ###########################################################################
111                                                   # Converts output of EXPLAIN into a human-readable tree.
112                                                   # ###########################################################################
113                                                   package ExplainTree;
114                                                   
115            1                    1             8   use List::Util qw(max);
               1                                  2   
               1                                 17   
116            1                    1             7   use Data::Dumper;
               1                                  3   
               1                                  8   
117                                                   
118                                                   sub new {
119            2                    2             9      my ( $class, $options ) = @_;
120            2                                 22      my $self = bless {}, $class;
121            2                                  9      $self->load_options($options);
122            2                                  8      return $self;
123                                                   }
124                                                   
125                                                   sub load_options {
126            4                    4            13      my ( $self, $options ) = @_;
127   ***      4    100     66                   30      if ( $options && ref $options eq 'HASH' ) {
128            2                                  9         @{$self}{keys %$options} = values %$options;
               2                                  8   
129                                                      }
130                                                      else {
131            2                                  7         delete @{$self}{keys %$self};
               2                                  7   
132                                                      }
133                                                   }
134                                                   
135                                                   sub parse {
136   ***      0                    0             0      my ( $self, $text, $options ) = @_;
137   ***      0                                  0      return $self->process(ExplainParser->new->parse($text), $options);
138                                                   }
139                                                   
140                                                   # The main method that turns a result set into a tree.  Accepts an arrayref of
141                                                   # hashrefs which correspond to the rows in EXPLAIN.  See the ALGORITHM in the
142                                                   # documentation for a small novel about this process.
143                                                   sub process {
144            2                    2             9      my ( $self, $rows, $options ) = @_;
145            2                                  8      $self->load_options($options);
146   ***      2     50     33                   19      return unless ref $rows eq 'ARRAY' && @$rows;
147                                                   
148                                                      # Pre-process and sanity check the rows.
149            2                                  8      my @rows = @$rows;
150            2                                 13      foreach my $i ( 0 .. $#rows ) {
151            6                                 21         my $row = $rows[$i];
152            6                                 21         $row->{rowid} = $i;
153            6           100                   24         $row->{Extra} ||= '';
154                                                   
155                                                         # The source code says if there are too many tables unioned together, the
156                                                         # table column will get truncated, like "<union1,2,3,4...>".  If this
157                                                         # happens, I've got to bail out.  I'm not going to check all the source
158                                                         # code for all versions, but in 5.0 it looks like I can get this to happen
159                                                         # around table 20.
160   ***      6     50     33                   53         die "UNION has too many tables: $row->{table}"
161                                                            if $row->{table} && $row->{table} =~ m/\./;
162                                                   
163            6    100                          30         if ( !defined $row->{id} ) {
164   ***      2     50     33                   48            if ( $row->{table} && (my ($id) = $row->{table} =~ m/^<union(\d+)/) ) {
165            2                                 10               $row->{id} = $id;
166                                                            }
167                                                            else {
168   ***      0                                  0               die "Unexpected NULL in id column, please report as a bug";
169                                                            }
170                                                         }
171                                                      }
172                                                   
173                                                      # Re-order the rows so all references are forward.
174            2                                 12      my %union_for
175            6                                 25         = map  { $_->{id} => $_ }
176            2                                  8           grep { $_->{select_type} eq 'UNION RESULT' }
177                                                           @rows;
178                                                   
179            2                                  7      my $last_id = 0;
180            2                                  5      my @reordered;
181            2                                  7      foreach my $row ( grep { $_->{select_type} ne 'UNION RESULT' } @rows ) {
               6                                 27   
182   ***      4    100     66                   41         if ( $last_id != $row->{id} && $union_for{$row->{id}} ) {
183            2                                  8            push @reordered, $union_for{$row->{id}};
184                                                         }
185            4                                 12         push @reordered, $row;
186            4                                 14         $last_id = $row->{id};
187                                                      }
188                                                   
189                                                      # Process the rows recursively.
190            2                                  9      my $tree = $self->build_query_plan(@reordered);
191                                                   
192            2                                 10      return $tree;
193                                                   }
194                                                   
195                                                   sub build_query_plan {
196            6                    6            25      my ( $self, @rows ) = @_;
197                                                   
198   ***      6     50                          23      if ( !@rows ) {
199   ***      0                                  0         die "I got no rows";
200                                                      }
201                                                   
202                                                      # Is it a UNION RESULT?  Split it up into sub-scopes and recurse.
203            6    100                          29      if ( $rows[0]->{select_type} eq 'UNION RESULT' ) {
204            2                                  6         my $row = shift @rows;
205            2                                  6         my @kids;
206            2                                 14         my @ids   = $row->{table} =~ m/(\d+)/g;
207            2                                  6         my $enclosing_scope;
208   ***      2     50                          11         if ( $rows[0]->{select_type} =~ m/SUBQUERY/ ) {
209   ***      0                                  0            $enclosing_scope = $rows[0];
210                                                         }
211            2                                 10         foreach my $i ( 0 .. $#ids ) {
212            4                                 24            my $start = $self->index_of($ids[$i], @rows);
213            4    100                          26            my $end   = $i < $#ids ? $self->index_of($ids[$i + 1], @rows) : @rows;
214            4                                 33            push @kids, $self->build_query_plan(splice(@rows, $start, $end - $start));
215                                                         }
216            2                                  9         $row->{children} = [ @kids ];
217   ***      4     50                          17         $row->{table}    = "union("
218            2                                  8            . join(',', map { $self->recursive_table_name($_) || '<none>' } @kids)
219                                                            . ")";
220            2                                  8         my $tree = $self->transform($row);
221   ***      2     50                          12         if ( $enclosing_scope ) {
222   ***      0                                  0            my $node = $self->transform($enclosing_scope);
223   ***      0                                  0            $node->{children} = [ $tree ];
224   ***      0                                  0            $tree = $node;
225                                                         }
226            2                                 13         return $tree;
227                                                      }
228                                                   
229                                                      # Are there DERIVED tables?  If so, find its children and pull them out of the
230                                                      # list under it.
231   ***      4     50                          14      while ( my ($der) = grep { $_->{table} && $_->{table} =~ m/^<derived\d+>$/ } @rows ) {
               4                                 53   
232                                                   
233                                                         # Figure out the start and end of the derived scope.
234   ***      0                                  0         my ($der_id) = $der->{table} =~ m/^<derived(\d+)>$/;
235   ***      0                                  0         my $start    = $self->index_of($der_id, @rows);
236   ***      0                                  0         my $end      = $start;
237   ***      0             0                    0         while ( $end < @rows && $rows[$end]->{id} >= $der_id ) {
238   ***      0                                  0            $end++;
239                                                         }
240                                                   
241                                                         # Get the rows that belong to this scope and recurse.
242   ***      0                                  0         my @enclosed_scope = splice(@rows, $start, $end - $start);
243   ***      0                                  0         my $kids           = $self->build_query_plan(@enclosed_scope);
244   ***      0                                  0         $der->{children}   = [$kids];
245   ***      0             0                    0         $der->{table}      = "derived(" . ($self->recursive_table_name($kids) || '<none>') . ")";
246                                                      }
247                                                   
248                                                      # Handle the "normal case."  For each node, if the id is the same as the last
249                                                      # one, JOIN and continue.  If the id is greater, it's a subquery, so should
250                                                      # be recursed.
251                                                   
252                                                      # But, filesort/temporary have to be handled specially, because they appear
253                                                      # in the first row, even if they are done later.  Here are the cases,
254                                                      # according to http://s.petrunia.net/blog/?p=24:
255                                                   
256                                                      # ... MySQL has three ways to run a join and produce ordered output:
257                                                      # Method                               EXPLAIN output
258                                                      # ##################################   ####################################
259                                                      # Use index-based access method that   no mention of filesort
260                                                      # produces ordered output
261                                                      # ----------------------------------   ------------------------------------
262                                                      # Use filesort() on 1st non-constant   "Using filesort" in the first row
263                                                      # table
264                                                      # ----------------------------------   ------------------------------------
265                                                      # Put join result into a temporary     "Using temporary; Using filesort" in
266                                                      # table and use filesort() on it       the first row
267                                                      # ----------------------------------   ------------------------------------
268                                                   
269            4                                 20      my $first = shift(@rows);
270                                                   
271                                                      # This is "case three" above.
272            4                                  9      my $is_temp_filesort;
273   ***      4     50     33                   28      if ( $first->{Extra} =~ m/Using temporary; Using filesort/ ) {
      ***            50                               
274                                                         # The entire join is being placed into a temporary table and filesorted,
275                                                         # so I'll make a note of that and apply it afterwards.  In the meantime I
276                                                         # must remove mention of it from the node so the node doesn't get extra
277                                                         # transformations in transform().
278   ***      0                                  0         $is_temp_filesort = 1;
279   ***      0                                  0         $first->{Extra} =~ s/Using temporary; Using filesort(?:; )?//;
280                                                      }
281                                                   
282                                                      # This is "case two" above.  Must find first non-constant table and move
283                                                      # the filesort() there.
284                                                      elsif ( $first->{Extra} =~ m/Using filesort/ && $first->{type} =~ m/^(?:system|const)$/ ) {
285   ***      0                                  0         my ( $first_non_const ) = grep { $_->{type} !~ m/^(?:system|const)$/ } @rows;
      ***      0                                  0   
286   ***      0      0                           0         if ( $first_non_const ) {
287   ***      0                                  0            $first->{Extra} =~ s/Using filesort(?:; )?//;
288   ***      0                                  0            $first_non_const->{Extra} .= '; Using filesort';
289                                                         }
290                                                      }
291                                                   
292            4                                 13      my $scope = $first->{id};
293            4                                 16      my $tree  = $self->transform($first);
294            4                                 10      my $i     = 0;
295            4                                 18      while ( $i < @rows ) {
296   ***      0                                  0         my $row = $rows[$i];
297   ***      0      0                           0         if ( $row->{id} == $scope ) {
298   ***      0                                  0            $tree = {
299                                                               type     => 'JOIN',
300                                                               children => [ $tree, $self->transform($row) ],
301                                                            };
302   ***      0                                  0            $i++;
303                                                         }
304                                                         else {
305                                                            # It's another kind of "join".  Find the enclosing scope boundaries and
306                                                            # recurse.  The scope starts at $i.
307   ***      0                                  0            my $end = $i;
308   ***      0             0                    0            while ( $end < @rows && $rows[$end]->{id} >= $row->{id} ) {
309   ***      0                                  0               $end++;
310                                                            }
311   ***      0                                  0            my @enclosed_scope = splice(@rows, $i, $end - $i);
312   ***      0                                  0            $tree = {
313                                                               type     => $row->{select_type},
314                                                               children => [ $tree, $self->build_query_plan(@enclosed_scope) ],
315                                                            };
316                                                            # Don't increment the pointer because I just removed rows from @rows.
317                                                            # $i++
318                                                         }
319                                                      }
320                                                   
321   ***      4     50                          15      if ( $is_temp_filesort ) {
322   ***      0                                  0         $tree = $self->filesort(
323                                                            $self->temporary($tree, $self->recursive_table_name($tree)));
324                                                      }
325                                                   
326            4                                 18      return $tree;
327                                                   }
328                                                   
329                                                   # TODO: "Using index condition" see http://bugs.mysql.com/bug.php?id=30659
330                                                   sub transform {
331            6                    6            22      my ( $self, $row ) = @_;
332                                                   
333            6                                 18      my $sub = $row->{type};
334                                                   
335                                                      # ##################################################################
336                                                      # Dispatch to a class method to generate the tree.
337                                                      # ##################################################################
338            6                                 26      my $no_matching_row = join('|',
339                                                         "Impossible (?:WHERE|HAVING)(?: noticed after reading const tables)?",
340                                                         'No matching.*row',
341                                                         '(?:unique|const) row not found',
342                                                      );
343   ***      6      0                          31      my $node
      ***             0                               
      ***             0                               
      ***             0                               
      ***            50                               
344                                                         = $sub
345                                                            ? $self->$sub($row)
346                                                         : $row->{Extra} =~ m/No tables/
347                                                            ? { type => ( $row->{select_type} !~ m/^(?:PRIMARY|SIMPLE)$/
348                                                                        ? $row->{select_type}
349                                                                        : 'DUAL') }
350                                                         : $row->{Extra} =~ m/(?:$no_matching_row)/i
351                                                            ? { type => 'IMPOSSIBLE' }
352                                                         : $row->{Extra} =~ m/optimized away/
353                                                            ? { type => 'CONSTANT' }
354                                                         : die "Can't handle " . Dumper($row);
355                                                   
356            6                                 82      my ($warn) = $row->{Extra} =~ m/($no_matching_row)/;
357   ***      6     50                          22      if ( $warn ) {
358   ***      0                                  0         $node->{warning} = $warn;
359                                                      }
360                                                   
361                                                      # ##################################################################
362                                                      # Apply other tree transformations.
363                                                      # ##################################################################
364   ***      6     50                          26      if ( $row->{Extra} =~ m/Using where/ ) {
365   ***      0                                  0         $node = {
366                                                            type     => 'Filter with WHERE',
367                                                            children => [$node],
368                                                         };
369                                                      }
370                                                   
371   ***      6     50                          22      if ( $row->{Extra} =~ m/Using join buffer/ ) {
372   ***      0                                  0         $node = {
373                                                            type     => 'Join buffer',
374                                                            children => [$node],
375                                                         };
376                                                      }
377                                                   
378   ***      6     50                          33      if ( $row->{Extra} =~ m/Distinct|Not exists/ ) {
379   ***      0                                  0         $node = {
380                                                            type     => 'Distinct/Not-Exists',
381                                                            children => [$node],
382                                                         };
383                                                      }
384                                                   
385   ***      6     50                          24      if ( $row->{Extra} =~ m/Range checked for each record \(\w+ map: ([^\)]+)\)/ ) {
386                                                         # (index map: N) is a bitmap of which indexes are used.  For example:
387                                                         #  0x5  base 16 (or base 10)
388                                                         # 0101  base 2
389                                                         # 4321  position of bits
390                                                         #  3 1  indexes used
391   ***      0                                  0         my $bitmap = eval "int($1)";                    # Hex to decimal if it begins with '0x'
392   ***      0                                  0         $bitmap    = unpack("B32", pack("N", $bitmap)); # Convert into binary string of 1/0
393   ***      0                                  0         $bitmap    =~ s/^0+//;                          # Remove leading zeros
394   ***      0                                  0         $bitmap    = reverse $bitmap;                   # Iterate from left-to-right
395   ***      0                                  0         my $possible_keys = join(',',
396   ***      0                                  0            grep { substr($bitmap, $_ - 1, 1) }
397                                                           ( 1 .. length($bitmap) ));
398   ***      0                                  0         $node = {
399                                                            type          => 'Re-evaluate indexes each row',
400                                                            possible_keys => $possible_keys,
401                                                            children      => [$node],
402                                                         };
403                                                      }
404                                                   
405   ***      6     50                          23      if ( $row->{Extra} =~ m/Using filesort/ ) {
406   ***      0                                  0         $node = $self->filesort($node);
407                                                      }
408                                                   
409   ***      6     50                          24      if ( $row->{Extra} =~ m/Using temporary/ ) {
410   ***      0                                  0         $node = $self->temporary($node, $row->{table}, 1);
411                                                      }
412                                                   
413                                                      # Add some data that will help me keep track of nodes as I manipulate
414                                                      # them later
415            6                                 25      $node->{id}    = $row->{id};
416            6                                 24      $node->{rowid} = $row->{rowid};
417                                                   
418            6                                 21      return $node;
419                                                   }
420                                                   
421                                                   sub index_of {
422            6                    6            26      my ( $self, $id, @rows ) = @_;
423            6                                 17      my $i = 0;
424            6                                 17      foreach my $row ( @rows ) {
425   ***      8    100     66                   80         if ( $row->{id} && $row->{id} == $id ) {
426            6                                 23            return $i;
427                                                         }
428            2                                  6         $i++;
429                                                      }
430   ***      0      0                           0      die "Can't find row $id in "
431   ***      0                                  0         . join(',', map { $_->{id} || '' } @rows);
432                                                   }
433                                                   
434                                                   sub pretty_print {
435            4                    4            17      my ( $self, $node, $prefix ) = @_;
436            4           100                   16      $prefix ||= '';
437            4    100                          20      my $branch = $prefix ? substr($prefix, 0, length($prefix) -3) . '+- ' : '';
438            4                                 16      my $output = $branch . $node->{type} . "\n";
439                                                   
440            4                                  8      my @kids;
441            4    100                          37      if ( $node->{children} ) {
442            2                                  6         @kids   = reverse @{$node->{children}};
               2                                 10   
443                                                      }
444            4    100                          17      my $suffix = (@kids > 1) ? '|  ' : '   ';
445                                                   
446            4                                 16      foreach my $thing ( qw(table key partitions possible_keys method key_len ref rows warning) ) {
447           36    100                         167         if ( defined $node->{$thing} ) {
448            7                                 42            $output .= $prefix . sprintf('%-14s %s', $thing, $node->{$thing}) . "\n";
449                                                         }
450                                                      }
451                                                   
452            4                                 13      my $last_child = pop @kids;
453            4                                 13      foreach my $child ( @kids ) {
454            1                                 11         $output .= $self->pretty_print($child, $prefix . $suffix);
455                                                      }
456            4    100                          15      if ( $last_child ) {
457            2                                 19         $output .= $self->pretty_print($last_child, $prefix . '   ');
458                                                      }
459            4                                 27      return $output;
460                                                   }
461                                                   
462                                                   #############################################################################
463                                                   # Each method in this section corresponds to a value you will find in the 'type'
464                                                   # column in EXPLAIN.
465                                                   #############################################################################
466                                                   
467                                                   sub ALL {
468            2                    2             8      my ( $self, $row ) = @_;
469                                                      return {
470            2                                 12         type     => 'Table scan',
471                                                         rows     => $row->{rows},
472                                                         children => [$self->table($row)],
473                                                      };
474                                                   }
475                                                   
476                                                   sub fulltext {
477   ***      0                    0             0      my ( $self, $row ) = @_;
478   ***      0                                  0      return $self->index_access($row, 'Fulltext scan');
479                                                   }
480                                                   
481                                                   sub range {
482   ***      0                    0             0      my ( $self, $row ) = @_;
483   ***      0                                  0      return $self->index_access($row, 'Index range scan');
484                                                   }
485                                                   
486                                                   sub index {
487            4                    4            13      my ( $self, $row ) = @_;
488            4                                 17      return $self->index_access($row, 'Index scan');
489                                                   }
490                                                   
491                                                   sub eq_ref {
492   ***      0                    0             0      my ( $self, $row ) = @_;
493   ***      0                                  0      return $self->index_access($row, 'Unique index lookup');
494                                                   }
495                                                   
496                                                   sub ref {
497   ***      0                    0             0      my ( $self, $row ) = @_;
498   ***      0                                  0      return $self->index_access($row, 'Index lookup');
499                                                   }
500                                                   
501                                                   sub ref_or_null {
502   ***      0                    0             0      my ( $self, $row ) = @_;
503   ***      0                                  0      return $self->index_access($row, 'Index lookup with extra null lookup');
504                                                   }
505                                                   
506                                                   sub const {
507   ***      0                    0             0      my ( $self, $row ) = @_;
508   ***      0                                  0      return $self->index_access($row, 'Constant index lookup');
509                                                   }
510                                                   
511                                                   sub system {
512   ***      0                    0             0      my ( $self, $row ) = @_;
513                                                      return {
514   ***      0                                  0         type => 'Constant table access',
515                                                         rows     => $row->{rows},
516                                                         children => [$self->table($row)],
517                                                      };
518                                                   }
519                                                   
520                                                   sub unique_subquery {
521   ***      0                    0             0      my ( $self, $row ) = @_;
522   ***      0                                  0      return $self->index_access($row, 'Unique subquery');
523                                                   }
524                                                   
525                                                   sub index_subquery {
526   ***      0                    0             0      my ( $self, $row ) = @_;
527   ***      0                                  0      return $self->index_access($row, 'Index subquery');
528                                                   }
529                                                   
530                                                   # From the manual: "The Index Merge method is used to retrieve rows with
531                                                   # several range scans and to merge their results into one."  Therefore each
532                                                   # index access should be shown as an index range scan.  The unions and
533                                                   # intersections can be recursive, as in
534                                                   # union(intersect(key1,key2),intersect(key3,key4))
535                                                   sub index_merge {
536   ***      0                    0             0      my ( $self, $row ) = @_;
537   ***      0                                  0      my ( $merge_spec )
538                                                         = $row->{Extra} =~ m/Using ((?:intersect|union|sort_union)\(.*?\))(?=;|$)/;
539   ***      0                                  0      my ($merge, $num) = $self->recurse_index_merge($row, $merge_spec, 0);
540                                                   
541                                                      # index_merge_bookmark_lookup note:
542                                                      # From the manual, "If the used indexes don't cover all columns used in the
543                                                      # query, full rows are retrieved only when the range conditions for all
544                                                      # used keys are satisfied."  So a bookmark lookup shouldn't be shown for
545                                                      # all indexes; it should be shown from the merge results.
546   ***      0                                  0      return $self->bookmark_lookup($merge, $row);
547                                                   }
548                                                   
549                                                   # ###########################################################################
550                                                   # Helper subroutines.
551                                                   # ###########################################################################
552                                                   
553                                                   sub recursive_table_name {
554            4                    4            15      my ( $self, $node ) = @_;
555   ***      4     50                          24      if ( $node->{table} ) {
556   ***      0                                  0         return $node->{table};
557                                                      }
558   ***      4     50                          17      if ( $node->{key} ) {
559            4                                 25         my ( $table ) = $node->{key} =~ m/(.*?)->/;
560            4                                 26         return $table;
561                                                      }
562   ***      0      0                           0      if ( $node->{type} eq 'Bookmark lookup' ) {
563   ***      0                                  0         return $node->{children}->[1]->{table};
564                                                      }
565   ***      0      0                           0      if ( $node->{type} eq 'IMPOSSIBLE' ) {
566   ***      0                                  0         return '<none>';
567                                                      }
568   ***      0      0                           0      if ( $node->{children} ) {
569   ***      0                                  0         return join(',',
570   ***      0                                  0            grep { $_ }
571   ***      0                                  0            map  { $self->recursive_table_name($_) }
572   ***      0                                  0                 @{$node->{children}});
573                                                      }
574                                                   }
575                                                   
576                                                   # $num is the number of nodes to the left of this node in a depth-first
577                                                   # traversal.  It lets me figure out which value goes in key_len.
578                                                   my $bal; # Workaround for issue 90 (Variable "$bal" will not stay shared).
579                                                   sub recurse_index_merge {
580   ***      0                    0             0      my ( $self, $row, $spec, $num ) = @_;
581   ***      0                                  0      my ($type, $args) = $spec =~ m/(intersect|union|sort_union)\((.*)\)$/;
582                                                   
583   ***      0                                  0      my @children;
584                                                   
585                                                      # See 'man perlre' and search for 'matches a parenthesized group'.
586   ***      0                                  0      $bal = qr/
587                                                         \(
588                                                         (?:
589                                                            (?> [^()]+ )    # Non-parens without backtracking
590                                                            |
591                                                            (??{ $bal })     # Group with matching parens
592                                                         )*
593                                                         \)
594                                                      /x;
595                                                   
596                                                      # Extract a thing, followed by balanced parentheses.
597   ***      0                                  0      foreach my $child ( $args =~ m/(\w+$bal)/g ) {
598   ***      0                                  0         my ( $subtree, $num ) = $self->recurse_index_merge($row, $child, $num);
599   ***      0                                  0         push @children, $subtree;
600                                                      }
601                                                   
602   ***      0      0                           0      if ( !@children ) { # Recursion base case; $args is an index list
603   ***      0                                  0         foreach my $idx ( split(/,/, $args) ) {
604   ***      0                                  0            my $index_scan = $self->index_access($row, 'Index range scan', $idx);
605   ***      0                                  0            $index_scan->{key_len} = ($row->{key_len} =~ m/(\d+)/g)[$num++];
606   ***      0                                  0            push @children, $index_scan;
607                                                         }
608                                                      }
609                                                   
610                                                      return (
611                                                         {
612   ***      0                                  0            type     => 'Index merge',
613                                                            method   => $type,
614                                                            rows     => $row->{rows},
615                                                            children => \@children,
616                                                         },
617                                                         $num
618                                                      );
619                                                   
620                                                   }
621                                                   
622                                                   sub table {
623            2                    2             7      my ( $self, $row ) = @_;
624   ***      2     50     33                   42      my $node = {
625                                                         type          => ($row->{table} && $row->{table} =~ m/^(derived|union)\(/)
626                                                                          ? uc $1
627                                                                          : 'Table',
628                                                         table         => $row->{table},
629                                                         possible_keys => $row->{possible_keys},
630                                                         partitions    => $row->{partitions},
631                                                      };
632   ***      2     50                          10      if ( $row->{children} ) {
633            2                                  8         $node->{children} = $row->{children};
634                                                      }
635            2                                 11      return $node;
636                                                   }
637                                                   
638                                                   sub bookmark_lookup {
639            4                    4            15      my ( $self, $node, $row ) = @_;
640   ***      4     50      0                   25      if ( $row->{Extra} =~ m/Using index/
      ***                    0                        
      ***                   33                        
641                                                            || ( $self->{clustered} && $row->{key} && $row->{key} eq 'PRIMARY' ))
642                                                      {
643            4                                 15         return $node;
644                                                      }
645                                                      return {
646   ***      0                                  0         type     => 'Bookmark lookup',
647                                                         children => [ $node, $self->table($row) ],
648                                                      };
649                                                   }
650                                                   
651                                                   sub filesort {
652   ***      0                    0             0      my ( $self, $node ) = @_;
653                                                      return {
654   ***      0                                  0         type     => 'Filesort',
655                                                         children => [$node],
656                                                      };
657                                                   }
658                                                   
659                                                   sub temporary {
660   ***      0                    0             0      my ( $self, $node, $table_name, $is_scan ) = @_;
661   ***      0                                  0      $node = {
662                                                         type          => 'TEMPORARY',
663                                                         table         => "temporary($table_name)",
664                                                         possible_keys => undef,
665                                                         partitions    => undef,
666                                                         children      => [$node],
667                                                      };
668   ***      0      0                           0      if ( $is_scan ) {
669   ***      0                                  0         $node = {
670                                                            type     => 'Table scan',
671                                                            rows     => undef,
672                                                            children => [ $node ],
673                                                         };
674                                                      }
675   ***      0                                  0      return $node;
676                                                   }
677                                                   
678                                                   sub index_access {
679            4                    4            18      my ( $self, $row, $type, $key ) = @_;
680   ***      4            33                   69      my $node = {
681                                                         type          => $type,
682                                                         key           => $row->{table} . '->' . ( $key || $row->{key} ),
683                                                         possible_keys => $row->{possible_keys},
684                                                         partitions    => $row->{partitions},
685                                                         key_len       => $row->{key_len},
686                                                         'ref'         => $row->{ref},
687                                                         rows          => $row->{rows},
688                                                      };
689   ***      4     50                          17      if ( $row->{Extra} =~ m/Full scan on NULL key/ ) {
690   ***      0                                  0         $node->{warning} = 'Full scan on NULL key';
691                                                      }
692   ***      4     50                          14      if ( $row->{Extra} =~ m/Using index for group-by/ ) {
693   ***      0                                  0         $node->{type} = 'Loose index scan';
694                                                      }
695                                                      # See index_merge_bookmark_lookup note above.
696   ***      4     50                          19      if ( $row->{type} ne 'index_merge' ) {
697            4                                 17         $node = $self->bookmark_lookup($node, $row);
698                                                      }
699            4                                 15      return $node;
700                                                   }
701                                                   
702                                                   # ###########################################################################
703                                                   # OptionParser package 3695
704                                                   # ###########################################################################
705                                                   package OptionParser;
706                                                   
707            1                    1             8   use strict;
               1                                  2   
               1                                  6   
708            1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
709                                                   
710            1                    1            12   use Getopt::Long;
               1                                  3   
               1                                  7   
711            1                    1             7   use List::Util qw(max);
               1                                  2   
               1                                  6   
712            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  9   
713                                                   
714            1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  9   
715                                                   
716                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
717                                                   
718                                                   sub new {
719            2                    2            18      my ( $class, %args ) = @_;
720            2                                  9      foreach my $arg ( qw(description) ) {
721   ***      2     50                          13         die "I need a $arg argument" unless $args{$arg};
722                                                      }
723            2                                 18      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
724   ***      2            50                   12      $program_name ||= $PROGRAM_NAME;
725                                                   
726   ***      2     50     50                   83      my $self = {
      ***                   50                        
727                                                         description    => $args{description},
728                                                         prompt         => $args{prompt} || '<options>',
729                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
730                                                         dp             => $args{dp}     || undef,
731                                                         program_name   => $program_name,
732                                                         opts           => {},
733                                                         got_opts       => 0,
734                                                         short_opts     => {},
735                                                         defaults       => {},
736                                                         groups         => {},
737                                                         allowed_groups => {},
738                                                         errors         => [],
739                                                         rules          => [],  # desc of rules for --help
740                                                         mutex          => [],  # rule: opts are mutually exclusive
741                                                         atleast1       => [],  # rule: at least one opt is required
742                                                         disables       => {},  # rule: opt disables other opts 
743                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
744                                                         default_files  => [
745                                                            "/etc/maatkit/maatkit.conf",
746                                                            "/etc/maatkit/$program_name.conf",
747                                                            "$ENV{HOME}/.maatkit.conf",
748                                                            "$ENV{HOME}/.$program_name.conf",
749                                                         ],
750                                                      };
751            2                                 19      return bless $self, $class;
752                                                   }
753                                                   
754                                                   sub get_specs {
755            2                    2             9      my ( $self, $file ) = @_;
756            2                                  9      my @specs = $self->_pod_to_specs($file);
757            2                                 35      $self->_parse_specs(@specs);
758            2                                  7      return;
759                                                   }
760                                                   
761                                                   sub get_defaults_files {
762            2                    2             8      my ( $self ) = @_;
763            2                                  6      return @{$self->{default_files}};
               2                                 19   
764                                                   }
765                                                   
766                                                   sub _pod_to_specs {
767            2                    2             8      my ( $self, $file ) = @_;
768   ***      2            50                   10      $file ||= __FILE__;
769   ***      2     50                          57      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
770                                                   
771            2                                 27      my %types = (
772                                                         string => 's', # standard Getopt type
773                                                         'int'  => 'i', # standard Getopt type
774                                                         float  => 'f', # standard Getopt type
775                                                         Hash   => 'H', # hash, formed from a comma-separated list
776                                                         hash   => 'h', # hash as above, but only if a value is given
777                                                         Array  => 'A', # array, similar to Hash
778                                                         array  => 'a', # array, similar to hash
779                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
780                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
781                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
782                                                      );
783            2                                  6      my @specs = ();
784            2                                  6      my @rules = ();
785            2                                  5      my $para;
786                                                   
787            2                                 11      local $INPUT_RECORD_SEPARATOR = '';
788            2                                 43      while ( $para = <$fh> ) {
789          528    100                        3337         next unless $para =~ m/^=head1 OPTIONS/;
790            2                                  8         last;
791                                                      }
792                                                   
793            2                                 11      while ( $para = <$fh> ) {
794   ***      2     50                          10         last if $para =~ m/^=over/;
795   ***      0                                  0         chomp $para;
796   ***      0                                  0         $para =~ s/\s+/ /g;
797   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
798   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
799   ***      0                                  0         push @rules, $para;
800                                                      }
801                                                   
802   ***      2     50                           8      die 'POD has no OPTIONS section' unless $para;
803                                                   
804            2                                  6      do {
805           34    100                         215         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
806           32                                 85            chomp $para;
807           32                                 63            MKDEBUG && _d($para);
808           32                                 74            my %attribs;
809                                                   
810           32                                114            $para = <$fh>; # read next paragraph, possibly attributes
811                                                   
812           32    100                         117            if ( $para =~ m/: / ) { # attributes
813           22                                102               $para =~ s/\s+\Z//g;
814           22                                 99               %attribs = map { split(/: /, $_) } split(/; /, $para);
              42                                198   
815           22    100                         119               if ( $attribs{'short form'} ) {
816           16                                 69                  $attribs{'short form'} =~ s/-//;
817                                                               }
818           22                                 88               $para = <$fh>; # read next paragraph, probably short help desc
819                                                            }
820                                                            else {
821           10                                 25               MKDEBUG && _d('Option has no attributes');
822                                                            }
823                                                   
824           32                                227            $para =~ s/\s+\Z//g;
825           32                                217            $para =~ s/\s+/ /g;
826           32                                148            $para =~ s/$POD_link_re/$1/go;
827                                                   
828           32                                120            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
829           32                                 69            MKDEBUG && _d('Short help:', $para);
830                                                   
831   ***     32     50                         125            die "No description after option spec $option" if $para =~ m/^=item/;
832                                                   
833   ***     32     50                         134            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
834   ***      0                                  0               $option = $base_option;
835   ***      0                                  0               $attribs{'negatable'} = 1;
836                                                            }
837                                                   
838           32    100                         504            push @specs, {
      ***            50                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
839                                                               spec  => $option
840                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
841                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
842                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
843                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
844                                                               desc  => $para
845                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
846                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
847                                                            };
848                                                         }
849           34                                200         while ( $para = <$fh> ) {
850   ***     40     50                         135            last unless $para;
851                                                   
852                                                   
853           40    100                         146            if ( $para =~ m/^=head1/ ) {
854            2                                  7               $para = undef; # Can't 'last' out of a do {} block.
855            2                                 11               last;
856                                                            }
857           38    100                         228            last if $para =~ m/^=item --/;
858                                                         }
859                                                      } while ( $para );
860                                                   
861   ***      2     50                          16      die 'No valid specs in POD OPTIONS' unless @specs;
862                                                   
863            2                                 34      close $fh;
864            2                                  8      return @specs, @rules;
865                                                   }
866                                                   
867                                                   sub _parse_specs {
868            2                    2            12      my ( $self, @specs ) = @_;
869            2                                  7      my %disables; # special rule that requires deferred checking
870                                                   
871            2                                  9      foreach my $opt ( @specs ) {
872   ***     32     50                         113         if ( ref $opt ) { # It's an option spec, not a rule.
873                                                            MKDEBUG && _d('Parsing opt spec:',
874           32                                 67               map { ($_, '=>', $opt->{$_}) } keys %$opt);
875                                                   
876           32                                228            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
877   ***     32     50                         122            if ( !$long ) {
878   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
879                                                            }
880           32                                109            $opt->{long} = $long;
881                                                   
882   ***     32     50                         134            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
883           32                                143            $self->{opts}->{$long} = $opt;
884                                                   
885   ***     32     50                         119            if ( length $long == 1 ) {
886   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
887   ***      0                                  0               $self->{short_opts}->{$long} = $long;
888                                                            }
889                                                   
890           32    100                         101            if ( $short ) {
891   ***     16     50                          67               die "Duplicate short option -$short"
892                                                                  if exists $self->{short_opts}->{$short};
893           16                                 65               $self->{short_opts}->{$short} = $long;
894           16                                 55               $opt->{short} = $short;
895                                                            }
896                                                            else {
897           16                                 52               $opt->{short} = undef;
898                                                            }
899                                                   
900   ***     32     50                         155            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
901   ***     32     50                         141            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
902   ***     32     50                         163            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
903                                                   
904   ***     32            50                  125            $opt->{group} ||= 'default';
905           32                                138            $self->{groups}->{ $opt->{group} }->{$long} = 1;
906                                                   
907           32                                104            $opt->{value} = undef;
908           32                                 92            $opt->{got}   = 0;
909                                                   
910           32                                158            my ( $type ) = $opt->{spec} =~ m/=(.)/;
911           32                                112            $opt->{type} = $type;
912           32                                 66            MKDEBUG && _d($long, 'type:', $type);
913                                                   
914   ***     32     50     66                  248            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
915   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
916                                                                  . "was given when this OptionParser object was created";
917                                                            }
918                                                   
919           32    100    100                  205            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
920                                                   
921           32    100                         170            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
922   ***      4     50                          17               if ( $opt->{is_negatable} ) {
923   ***      0      0                           0                  $def = $def eq 'yes' ? 1
      ***             0                               
924                                                                       : $def eq 'no'  ? 0
925                                                                       : $def;
926                                                               }
927   ***      4     50                          22               $self->{defaults}->{$long} = defined $def ? $def : 1;
928            4                                  9               MKDEBUG && _d($long, 'default:', $def);
929                                                            }
930                                                   
931           32    100                         122            if ( $long eq 'config' ) {
932            2                                 11               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
933                                                            }
934                                                   
935   ***     32     50                         151            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
936   ***      0                                  0               $disables{$long} = $dis;
937   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
938                                                            }
939                                                   
940           32                                142            $self->{opts}->{$long} = $opt;
941                                                         }
942                                                         else { # It's an option rule, not a spec.
943   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
944   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
945   ***      0                                  0            my @participants = $self->_get_participants($opt);
946   ***      0                                  0            my $rule_ok = 0;
947                                                   
948   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
949   ***      0                                  0               $rule_ok = 1;
950   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
951   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
952                                                            }
953   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
954   ***      0                                  0               $rule_ok = 1;
955   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
956   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
957                                                            }
958   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
959   ***      0                                  0               $rule_ok = 1;
960   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
961   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
962                                                            }
963   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
964   ***      0                                  0               $rule_ok = 1;
965   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
966   ***      0                                  0               my @groups = split(',', $groups);
967   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
968   ***      0                                  0                  s/\s+//;
969   ***      0                                  0                  $_ => 1;
970                                                               } @groups;
971                                                            }
972                                                   
973   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
974                                                         }
975                                                      }
976                                                   
977            2                                 11      foreach my $long ( keys %disables ) {
978   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
979   ***      0                                  0         $self->{disables}->{$long} = \@participants;
980   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
981                                                      }
982                                                   
983            2                                  9      return; 
984                                                   }
985                                                   
986                                                   sub _get_participants {
987   ***      0                    0             0      my ( $self, $str ) = @_;
988   ***      0                                  0      my @participants;
989   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
990   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
991                                                            unless exists $self->{opts}->{$long};
992   ***      0                                  0         push @participants, $long;
993                                                      }
994   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
995   ***      0                                  0      return @participants;
996                                                   }
997                                                   
998                                                   sub opts {
999   ***      0                    0             0      my ( $self ) = @_;
1000  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1001  ***      0                                  0      return %opts;
1002                                                  }
1003                                                  
1004                                                  sub opt_values {
1005  ***      0                    0             0      my ( $self ) = @_;
1006  ***      0      0                           0      my %opts = map {
1007  ***      0                                  0         my $opt = $self->{opts}->{$_}->{short} ? $self->{opts}->{$_}->{short}
1008                                                                : $_;
1009  ***      0                                  0         $opt => $self->{opts}->{$_}->{value}
1010  ***      0                                  0      } keys %{$self->{opts}};
1011  ***      0                                  0      return %opts;
1012                                                  }
1013                                                  
1014                                                  sub short_opts {
1015  ***      0                    0             0      my ( $self ) = @_;
1016  ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
1017  ***      0                                  0      return %short_opts;
1018                                                  }
1019                                                  
1020                                                  sub set_defaults {
1021  ***      0                    0             0      my ( $self, %defaults ) = @_;
1022  ***      0                                  0      $self->{defaults} = {};
1023  ***      0                                  0      foreach my $long ( keys %defaults ) {
1024  ***      0      0                           0         die "Cannot set default for nonexistent option $long"
1025                                                           unless exists $self->{opts}->{$long};
1026  ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
1027  ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
1028                                                     }
1029  ***      0                                  0      return;
1030                                                  }
1031                                                  
1032                                                  sub get_defaults {
1033  ***      0                    0             0      my ( $self ) = @_;
1034  ***      0                                  0      return $self->{defaults};
1035                                                  }
1036                                                  
1037                                                  sub get_groups {
1038  ***      0                    0             0      my ( $self ) = @_;
1039  ***      0                                  0      return $self->{groups};
1040                                                  }
1041                                                  
1042                                                  sub _set_option {
1043           1                    1             5      my ( $self, $opt, $val ) = @_;
1044  ***      1      0                           2      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
1045                                                              : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
1046                                                              : die "Getopt::Long gave a nonexistent option: $opt";
1047                                                  
1048           1                                  2      $opt = $self->{opts}->{$long};
1049  ***      1     50                          21      if ( $opt->{is_cumulative} ) {
1050  ***      0                                  0         $opt->{value}++;
1051                                                     }
1052                                                     else {
1053           1                                  4         $opt->{value} = $val;
1054                                                     }
1055           1                                  3      $opt->{got} = 1;
1056           1                                  4      MKDEBUG && _d('Got option', $long, '=', $val);
1057                                                  }
1058                                                  
1059                                                  sub get_opts {
1060           2                    2             8      my ( $self ) = @_; 
1061                                                  
1062           2                                  6      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 15   
1063          32                                116         $self->{opts}->{$long}->{got} = 0;
1064  ***     32     50                         243         $self->{opts}->{$long}->{value}
                    100                               
1065                                                           = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
1066                                                           : $self->{opts}->{$long}->{is_cumulative} ? 0
1067                                                           : undef;
1068                                                     }
1069           2                                 10      $self->{got_opts} = 0;
1070                                                  
1071           2                                  8      $self->{errors} = [];
1072                                                  
1073  ***      2     50     33                   25      if ( @ARGV && $ARGV[0] eq "--config" ) {
1074  ***      0                                  0         shift @ARGV;
1075  ***      0                                  0         $self->_set_option('config', shift @ARGV);
1076                                                     }
1077  ***      2     50                           9      if ( $self->has('config') ) {
1078           2                                  5         my @extra_args;
1079           2                                 13         foreach my $filename ( split(',', $self->get('config')) ) {
1080           8                                 20            eval {
1081           8                                 36               push @ARGV, $self->_read_config_file($filename);
1082                                                           };
1083  ***      8     50                          39            if ( $EVAL_ERROR ) {
1084  ***      8     50                          31               if ( $self->got('config') ) {
1085  ***      0                                  0                  die $EVAL_ERROR;
1086                                                              }
1087                                                              elsif ( MKDEBUG ) {
1088                                                                 _d($EVAL_ERROR);
1089                                                              }
1090                                                           }
1091                                                        }
1092           2                                 10         unshift @ARGV, @extra_args;
1093                                                     }
1094                                                  
1095           2                                 14      Getopt::Long::Configure('no_ignore_case', 'bundling');
1096                                                     GetOptions(
1097          30                    1           198         map    { $_->{spec} => sub { $self->_set_option(@_); } }
               1                                  5   
              32                                115   
1098           2                                 10         grep   { $_->{long} ne 'config' } # --config is handled specially above.
1099  ***      2     50                           8         values %{$self->{opts}}
1100                                                     ) or $self->save_error('Error parsing options');
1101                                                  
1102  ***      2     50     33                   61      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
1103  ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
1104                                                           $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1105                                                              or die "Cannot print: $OS_ERROR";
1106  ***      0                                  0         exit 0;
1107                                                     }
1108                                                  
1109  ***      2     50     33                   18      if ( @ARGV && $self->{strict} ) {
1110  ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
1111                                                     }
1112                                                  
1113           2                                  6      foreach my $mutex ( @{$self->{mutex}} ) {
               2                                 10   
1114  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
1115  ***      0      0                           0         if ( @set > 1 ) {
1116  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1117  ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
1118                                                                   . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
1119                                                                   . ' are mutually exclusive.';
1120  ***      0                                  0            $self->save_error($err);
1121                                                        }
1122                                                     }
1123                                                  
1124           2                                  6      foreach my $required ( @{$self->{atleast1}} ) {
               2                                  9   
1125  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
1126  ***      0      0                           0         if ( @set == 0 ) {
1127  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1128  ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
1129                                                                   .' or --'.$self->{opts}->{$required->[-1]}->{long};
1130  ***      0                                  0            $self->save_error("Specify at least one of $err");
1131                                                        }
1132                                                     }
1133                                                  
1134           2                                  5      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 13   
1135          32                                114         my $opt = $self->{opts}->{$long};
1136          32    100                         161         if ( $opt->{got} ) {
      ***            50                               
1137  ***      1     50                           5            if ( exists $self->{disables}->{$long} ) {
1138  ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
1139  ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
1140  ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
1141                                                                 'because', $long,'disables them');
1142                                                           }
1143                                                  
1144  ***      1     50                           5            if ( exists $self->{allowed_groups}->{$long} ) {
1145                                                  
1146  ***      0                                  0               my @restricted_groups = grep {
1147  ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
1148  ***      0                                  0               } keys %{$self->{groups}};
1149                                                  
1150  ***      0                                  0               my @restricted_opts;
1151  ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
1152  ***      0                                  0                  RESTRICTED_OPT:
1153  ***      0                                  0                  foreach my $restricted_opt (
1154                                                                    keys %{$self->{groups}->{$restricted_group}} )
1155                                                                 {
1156  ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
1157  ***      0      0                           0                     push @restricted_opts, $restricted_opt
1158                                                                       if $self->{opts}->{$restricted_opt}->{got};
1159                                                                 }
1160                                                              }
1161                                                  
1162  ***      0      0                           0               if ( @restricted_opts ) {
1163  ***      0                                  0                  my $err;
1164  ***      0      0                           0                  if ( @restricted_opts == 1 ) {
1165  ***      0                                  0                     $err = "--$restricted_opts[0]";
1166                                                                 }
1167                                                                 else {
1168  ***      0                                  0                     $err = join(', ',
1169  ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
1170  ***      0                                  0                               grep { $_ } 
1171                                                                              @restricted_opts[0..scalar(@restricted_opts) - 2]
1172                                                                           )
1173                                                                         . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1174                                                                 }
1175  ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
1176                                                              }
1177                                                           }
1178                                                  
1179                                                        }
1180                                                        elsif ( $opt->{is_required} ) { 
1181  ***      0                                  0            $self->save_error("Required option --$long must be specified");
1182                                                        }
1183                                                  
1184          32                                116         $self->_validate_type($opt);
1185                                                     }
1186                                                  
1187           2                                 10      $self->{got_opts} = 1;
1188           2                                  6      return;
1189                                                  }
1190                                                  
1191                                                  sub _validate_type {
1192          32                   32           108      my ( $self, $opt ) = @_;
1193  ***     32    100     66                  265      return unless $opt && $opt->{type};
1194          22                                 66      my $val = $opt->{value};
1195                                                  
1196  ***     22     50     66                  524      if ( $val && $opt->{type} eq 'm' ) {
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
1197  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1198  ***      0                                  0         my ( $num, $suffix ) = $val =~ m/(\d+)([a-z])?$/;
1199  ***      0      0                           0         if ( !$suffix ) {
1200  ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1201  ***      0             0                    0            $suffix = $s || 's';
1202  ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1203                                                              $opt->{long}, '(value:', $val, ')');
1204                                                        }
1205  ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
1206  ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
1207                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1208                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1209                                                                :                  $num * 86400;   # Days
1210  ***      0                                  0            $opt->{value} = $val;
1211  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1212                                                        }
1213                                                        else {
1214  ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
1215                                                        }
1216                                                     }
1217                                                     elsif ( $val && $opt->{type} eq 'd' ) {
1218  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1219  ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
1220  ***      0                                  0         my $default = {};
1221  ***      0      0                           0         if ( $from_key ) {
1222  ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1223  ***      0                                  0            $default = $self->{dp}->parse(
1224                                                              $self->{dp}->as_string($self->{opts}->{$from_key}->{value}) );
1225                                                        }
1226  ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $default);
1227                                                     }
1228                                                     elsif ( $val && $opt->{type} eq 'z' ) {
1229  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1230  ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1231  ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1232  ***      0      0                           0         if ( defined $num ) {
1233  ***      0      0                           0            if ( $factor ) {
1234  ***      0                                  0               $num *= $factor_for{$factor};
1235  ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
1236                                                                 'to num', $num, '* factor', $factor);
1237                                                           }
1238  ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
1239                                                        }
1240                                                        else {
1241  ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
1242                                                        }
1243                                                     }
1244                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1245  ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
1246                                                     }
1247                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1248  ***      2            50                   23         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
1249                                                     }
1250                                                     else {
1251          20                                 47         MKDEBUG && _d('Nothing to validate for option',
1252                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1253                                                     }
1254                                                  
1255          22                                 70      return;
1256                                                  }
1257                                                  
1258                                                  sub get {
1259           6                    6            30      my ( $self, $opt ) = @_;
1260  ***      6     50                          26      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1261  ***      6     50     33                   56      die "Option $opt does not exist"
1262                                                        unless $long && exists $self->{opts}->{$long};
1263           6                                 53      return $self->{opts}->{$long}->{value};
1264                                                  }
1265                                                  
1266                                                  sub got {
1267          10                   10            40      my ( $self, $opt ) = @_;
1268  ***     10     50                          44      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1269  ***     10     50     33                   87      die "Option $opt does not exist"
1270                                                        unless $long && exists $self->{opts}->{$long};
1271          10                                 60      return $self->{opts}->{$long}->{got};
1272                                                  }
1273                                                  
1274                                                  sub has {
1275           2                    2            11      my ( $self, $opt ) = @_;
1276  ***      2     50                          10      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1277  ***      2     50                          20      return defined $long ? exists $self->{opts}->{$long} : 0;
1278                                                  }
1279                                                  
1280                                                  sub set {
1281  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1282  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1283  ***      0      0      0                    0      die "Option $opt does not exist"
1284                                                        unless $long && exists $self->{opts}->{$long};
1285  ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
1286  ***      0                                  0      return;
1287                                                  }
1288                                                  
1289                                                  sub save_error {
1290  ***      0                    0             0      my ( $self, $error ) = @_;
1291  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1292                                                  }
1293                                                  
1294                                                  sub errors {
1295  ***      0                    0             0      my ( $self ) = @_;
1296  ***      0                                  0      return $self->{errors};
1297                                                  }
1298                                                  
1299                                                  sub prompt {
1300  ***      0                    0             0      my ( $self ) = @_;
1301  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1302                                                  }
1303                                                  
1304                                                  sub descr {
1305  ***      0                    0             0      my ( $self ) = @_;
1306  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1307                                                                . "  For more details, please use the --help option, "
1308                                                                . "or try 'perldoc $PROGRAM_NAME' "
1309                                                                . "for complete documentation.";
1310  ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
1311  ***      0                                  0      $descr =~ s/ +$//mg;
1312  ***      0                                  0      return $descr;
1313                                                  }
1314                                                  
1315                                                  sub usage_or_errors {
1316           2                    2             8      my ( $self ) = @_;
1317  ***      2     50                          11      if ( $self->{opts}->{help}->{got} ) {
      ***      2     50                          14   
1318  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1319  ***      0                                  0         exit 0;
1320                                                     }
1321                                                     elsif ( scalar @{$self->{errors}} ) {
1322  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1323  ***      0                                  0         exit 0;
1324                                                     }
1325           2                                  5      return;
1326                                                  }
1327                                                  
1328                                                  sub print_errors {
1329  ***      0                    0             0      my ( $self ) = @_;
1330  ***      0                                  0      my $usage = $self->prompt() . "\n";
1331  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1332  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1333                                                                . "\n";
1334                                                     }
1335  ***      0                                  0      return $usage . "\n" . $self->descr();
1336                                                  }
1337                                                  
1338                                                  sub print_usage {
1339  ***      0                    0             0      my ( $self ) = @_;
1340  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1341  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1342                                                  
1343  ***      0      0                           0      my $maxl = max(
1344  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1345                                                        @opts);
1346                                                  
1347  ***      0      0                           0      my $maxs = max(0,
1348  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1349  ***      0                                  0         values %{$self->{short_opts}});
1350                                                  
1351  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1352  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1353  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1354                                                  
1355  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1356                                                  
1357  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1358                                                  
1359  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1360  ***      0                                  0      push @groups, 'default';
1361                                                  
1362  ***      0                                  0      foreach my $group ( reverse @groups ) {
1363  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1364  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1365  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1366                                                           grep { $_->{group} eq $group }
1367                                                           @opts )
1368                                                        {
1369  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1370  ***      0                                  0            my $short = $opt->{short};
1371  ***      0                                  0            my $desc  = $opt->{desc};
1372  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1373  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1374  ***      0             0                    0               $s    ||= 's';
1375  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1376  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1377                                                                     . "d=days; if no suffix, $s is used.";
1378                                                           }
1379  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1380  ***      0                                  0            $desc =~ s/ +$//mg;
1381  ***      0      0                           0            if ( $short ) {
1382  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1383                                                           }
1384                                                           else {
1385  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1386                                                           }
1387                                                        }
1388                                                     }
1389                                                  
1390  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1391  ***      0                                  0         $usage .= "\nRules:\n\n";
1392  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1393                                                     }
1394  ***      0      0                           0      if ( $self->{dp} ) {
1395  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1396                                                     }
1397  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1398  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1399  ***      0                                  0         my $val   = $opt->{value};
1400  ***      0             0                    0         my $type  = $opt->{type} || '';
1401  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1402  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1403                                                                  : !defined $val             ? '(No value)'
1404                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1405                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1406                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1407                                                                  :                             $val;
1408  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1409                                                     }
1410  ***      0                                  0      return $usage;
1411                                                  }
1412                                                  
1413                                                  sub prompt_noecho {
1414  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1415  ***      0                                  0      my ( $prompt ) = @_;
1416  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1417  ***      0      0                           0      print $prompt
1418                                                        or die "Cannot print: $OS_ERROR";
1419  ***      0                                  0      my $response;
1420  ***      0                                  0      eval {
1421  ***      0                                  0         require Term::ReadKey;
1422  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1423  ***      0                                  0         chomp($response = <STDIN>);
1424  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1425  ***      0      0                           0         print "\n"
1426                                                           or die "Cannot print: $OS_ERROR";
1427                                                     };
1428  ***      0      0                           0      if ( $EVAL_ERROR ) {
1429  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1430                                                     }
1431  ***      0                                  0      return $response;
1432                                                  }
1433                                                  
1434                                                  if ( MKDEBUG ) {
1435                                                     print '# ', $^X, ' ', $], "\n";
1436                                                     my $uname = `uname -a`;
1437                                                     if ( $uname ) {
1438                                                        $uname =~ s/\s+/ /g;
1439                                                        print "# $uname\n";
1440                                                     }
1441                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1442                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1443                                                        ($main::SVN_REV || ''), __LINE__);
1444                                                     print('# Arguments: ',
1445                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1446                                                  }
1447                                                  
1448                                                  sub _read_config_file {
1449           8                    8            32      my ( $self, $filename ) = @_;
1450  ***      8     50                          22      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1451  ***      0                                  0      my @args;
1452  ***      0                                  0      my $prefix = '--';
1453  ***      0                                  0      my $parse  = 1;
1454                                                  
1455                                                     LINE:
1456  ***      0                                  0      while ( my $line = <$fh> ) {
1457  ***      0                                  0         chomp $line;
1458  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1459  ***      0                                  0         $line =~ s/\s+#.*$//g;
1460  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1461  ***      0      0                           0         if ( $line eq '--' ) {
1462  ***      0                                  0            $prefix = '';
1463  ***      0                                  0            $parse  = 0;
1464  ***      0                                  0            next LINE;
1465                                                        }
1466  ***      0      0      0                    0         if ( $parse
      ***             0                               
1467                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1468                                                        ) {
1469  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1470                                                        }
1471                                                        elsif ( $line =~ m/./ ) {
1472  ***      0                                  0            push @args, $line;
1473                                                        }
1474                                                        else {
1475  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1476                                                        }
1477                                                     }
1478  ***      0                                  0      close $fh;
1479  ***      0                                  0      return @args;
1480                                                  }
1481                                                  
1482                                                  sub read_para_after {
1483  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1484  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1485  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1486  ***      0                                  0      my $para;
1487  ***      0                                  0      while ( $para = <$fh> ) {
1488  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1489  ***      0                                  0         last;
1490                                                     }
1491  ***      0                                  0      while ( $para = <$fh> ) {
1492  ***      0      0                           0         next unless $para =~ m/$regex/;
1493  ***      0                                  0         last;
1494                                                     }
1495  ***      0                                  0      $para = <$fh>;
1496  ***      0                                  0      chomp($para);
1497  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1498  ***      0                                  0      return $para;
1499                                                  }
1500                                                  
1501                                                  sub clone {
1502  ***      0                    0             0      my ( $self ) = @_;
1503                                                  
1504  ***      0                                  0      my %clone = map {
1505  ***      0                                  0         my $hashref  = $self->{$_};
1506  ***      0                                  0         my $val_copy = {};
1507  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1508  ***      0                                  0            my $ref = ref $hashref->{$key};
1509  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1510  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1511  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1512                                                                             : $hashref->{$key};
1513                                                        }
1514  ***      0                                  0         $_ => $val_copy;
1515                                                     } qw(opts short_opts defaults);
1516                                                  
1517  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1518  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1519                                                     }
1520                                                  
1521  ***      0                                  0      return bless \%clone;     
1522                                                  }
1523                                                  
1524                                                  sub _d {
1525  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1526  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1527  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1528                                                          @_;
1529  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1530                                                  }
1531                                                  
1532                                                  1;
1533                                                  
1534                                                  # ###########################################################################
1535                                                  # End OptionParser package
1536                                                  # ###########################################################################
1537                                                  
1538                                                  # ###########################################################################
1539                                                  # DSNParser package 3421
1540                                                  # ###########################################################################
1541           1                    1            15   use strict;
               1                                  3   
               1                                 11   
1542           1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
1543                                                  
1544                                                  package DSNParser;
1545                                                  
1546           1                    1            15   use DBI;
               1                                  4   
               1                                 11   
1547           1                    1             7   use Data::Dumper;
               1                                  3   
               1                                  7   
1548                                                  $Data::Dumper::Indent    = 0;
1549                                                  $Data::Dumper::Quotekeys = 0;
1550           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
1551                                                  
1552           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                 10   
1553                                                  
1554                                                  sub new {
1555           2                    2            11      my ( $class, @opts ) = @_;
1556           2                                 69      my $self = {
1557                                                        opts => {
1558                                                           A => {
1559                                                              desc => 'Default character set',
1560                                                              dsn  => 'charset',
1561                                                              copy => 1,
1562                                                           },
1563                                                           D => {
1564                                                              desc => 'Database to use',
1565                                                              dsn  => 'database',
1566                                                              copy => 1,
1567                                                           },
1568                                                           F => {
1569                                                              desc => 'Only read default options from the given file',
1570                                                              dsn  => 'mysql_read_default_file',
1571                                                              copy => 1,
1572                                                           },
1573                                                           h => {
1574                                                              desc => 'Connect to host',
1575                                                              dsn  => 'host',
1576                                                              copy => 1,
1577                                                           },
1578                                                           p => {
1579                                                              desc => 'Password to use when connecting',
1580                                                              dsn  => 'password',
1581                                                              copy => 1,
1582                                                           },
1583                                                           P => {
1584                                                              desc => 'Port number to use for connection',
1585                                                              dsn  => 'port',
1586                                                              copy => 1,
1587                                                           },
1588                                                           S => {
1589                                                              desc => 'Socket file to use for connection',
1590                                                              dsn  => 'mysql_socket',
1591                                                              copy => 1,
1592                                                           },
1593                                                           u => {
1594                                                              desc => 'User for login if not current user',
1595                                                              dsn  => 'user',
1596                                                              copy => 1,
1597                                                           },
1598                                                        },
1599                                                     };
1600           2                                 11      foreach my $opt ( @opts ) {
1601  ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
1602  ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1603                                                     }
1604           2                                 18      return bless $self, $class;
1605                                                  }
1606                                                  
1607                                                  sub prop {
1608  ***      0                    0             0      my ( $self, $prop, $value ) = @_;
1609  ***      0      0                           0      if ( @_ > 2 ) {
1610  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1611  ***      0                                  0         $self->{$prop} = $value;
1612                                                     }
1613  ***      0                                  0      return $self->{$prop};
1614                                                  }
1615                                                  
1616                                                  sub parse {
1617  ***      0                    0             0      my ( $self, $dsn, $prev, $defaults ) = @_;
1618  ***      0      0                           0      if ( !$dsn ) {
1619  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1620  ***      0                                  0         return;
1621                                                     }
1622  ***      0                                  0      MKDEBUG && _d('Parsing', $dsn);
1623  ***      0             0                    0      $prev     ||= {};
1624  ***      0             0                    0      $defaults ||= {};
1625  ***      0                                  0      my %given_props;
1626  ***      0                                  0      my %final_props;
1627  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1628  ***      0                                  0      my $prop_autokey = $self->prop('autokey');
1629                                                  
1630  ***      0                                  0      foreach my $dsn_part ( split(/,/, $dsn) ) {
1631  ***      0      0                           0         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
      ***             0                               
1632  ***      0                                  0            $given_props{$prop_key} = $prop_val;
1633                                                        }
1634                                                        elsif ( $prop_autokey ) {
1635  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as',
1636                                                              $prop_autokey, '=', $dsn_part);
1637  ***      0                                  0            $given_props{$prop_autokey} = $dsn_part;
1638                                                        }
1639                                                        else {
1640  ***      0                                  0            MKDEBUG && _d('Bad DSN part:', $dsn_part);
1641                                                        }
1642                                                     }
1643                                                  
1644  ***      0                                  0      foreach my $key ( keys %opts ) {
1645  ***      0                                  0         MKDEBUG && _d('Finding value for', $key);
1646  ***      0                                  0         $final_props{$key} = $given_props{$key};
1647  ***      0      0      0                    0         if (   !defined $final_props{$key}
      ***                    0                        
1648                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1649                                                        {
1650  ***      0                                  0            $final_props{$key} = $prev->{$key};
1651  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1652                                                        }
1653  ***      0      0                           0         if ( !defined $final_props{$key} ) {
1654  ***      0                                  0            $final_props{$key} = $defaults->{$key};
1655  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1656                                                        }
1657                                                     }
1658                                                  
1659  ***      0                                  0      foreach my $key ( keys %given_props ) {
1660  ***      0      0                           0         die "Unrecognized DSN part '$key' in '$dsn'\n"
1661                                                           unless exists $opts{$key};
1662                                                     }
1663  ***      0      0                           0      if ( (my $required = $self->prop('required')) ) {
1664  ***      0                                  0         foreach my $key ( keys %$required ) {
1665  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1666                                                        }
1667                                                     }
1668                                                  
1669  ***      0                                  0      return \%final_props;
1670                                                  }
1671                                                  
1672                                                  sub parse_options {
1673  ***      0                    0             0      my ( $self, $o ) = @_;
1674  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1675  ***      0                                  0      my $dsn_string
1676                                                        = join(',',
1677  ***      0      0                           0             map  { "$_=".$o->get($_); }
1678  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1679  ***      0                                  0             keys %{$self->{opts}}
1680                                                          );
1681  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1682  ***      0                                  0      return $self->parse($dsn_string);
1683                                                  }
1684                                                  
1685                                                  sub as_string {
1686  ***      0                    0             0      my ( $self, $dsn ) = @_;
1687  ***      0      0                           0      return $dsn unless ref $dsn;
1688  ***      0      0                           0      return join(',',
1689  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1690  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1691                                                        sort keys %$dsn );
1692                                                  }
1693                                                  
1694                                                  sub usage {
1695  ***      0                    0             0      my ( $self ) = @_;
1696  ***      0                                  0      my $usage
1697                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n"
1698                                                        . "  KEY  COPY  MEANING\n"
1699                                                        . "  ===  ====  =============================================\n";
1700  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1701  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1702  ***      0      0      0                    0         $usage .= "  $key    "
1703                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1704                                                               .  ($opts{$key}->{desc} || '[No description]')
1705                                                               . "\n";
1706                                                     }
1707  ***      0      0                           0      if ( (my $key = $self->prop('autokey')) ) {
1708  ***      0                                  0         $usage .= "  If the DSN is a bareword, the word is treated as the '$key' key.\n";
1709                                                     }
1710  ***      0                                  0      return $usage;
1711                                                  }
1712                                                  
1713                                                  sub get_cxn_params {
1714  ***      0                    0             0      my ( $self, $info ) = @_;
1715  ***      0                                  0      my $dsn;
1716  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1717  ***      0             0                    0      my $driver = $self->prop('dbidriver') || '';
1718  ***      0      0                           0      if ( $driver eq 'Pg' ) {
1719  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1720  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1721  ***      0             0                    0                        grep { defined $info->{$_} }
1722                                                                       qw(h P));
1723                                                     }
1724                                                     else {
1725  ***      0                                  0         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1726  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1727  ***      0             0                    0                        grep { defined $info->{$_} }
1728                                                                       qw(F h P S A))
1729                                                           . ';mysql_read_default_group=client';
1730                                                     }
1731  ***      0                                  0      MKDEBUG && _d($dsn);
1732  ***      0                                  0      return ($dsn, $info->{u}, $info->{p});
1733                                                  }
1734                                                  
1735                                                  sub fill_in_dsn {
1736  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1737  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1738  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1739  ***      0                                  0      $user =~ s/@.*//;
1740  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1741  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1742  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1743  ***      0             0                    0      $dsn->{u} ||= $user;
1744  ***      0             0                    0      $dsn->{D} ||= $db;
1745                                                  }
1746                                                  
1747                                                  sub get_dbh {
1748  ***      0                    0             0      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1749  ***      0             0                    0      $opts ||= {};
1750  ***      0      0                           0      my $defaults = {
1751                                                        AutoCommit        => 0,
1752                                                        RaiseError        => 1,
1753                                                        PrintError        => 0,
1754                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1755                                                     };
1756  ***      0                                  0      @{$defaults}{ keys %$opts } = values %$opts;
      ***      0                                  0   
1757                                                  
1758  ***      0                                  0      my $dbh;
1759  ***      0                                  0      my $tries = 2;
1760  ***      0             0                    0      while ( !$dbh && $tries-- ) {
1761                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1762  ***      0                                  0            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1763                                                  
1764  ***      0                                  0         eval {
1765  ***      0                                  0            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1766                                                  
1767  ***      0      0                           0            if ( $cxn_string =~ m/mysql/i ) {
1768  ***      0                                  0               my $sql;
1769                                                  
1770  ***      0                                  0               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1771                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1772  ***      0                                  0               MKDEBUG && _d($dbh, ':', $sql);
1773  ***      0                                  0               $dbh->do($sql);
1774                                                  
1775  ***      0      0                           0               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1776  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1777  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1778  ***      0                                  0                  $dbh->do($sql);
1779  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1780  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1781  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1782                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1783                                                                 }
1784                                                                 else {
1785  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1786                                                                 }
1787                                                              }
1788                                                  
1789  ***      0      0                           0               if ( $self->prop('setvars') ) {
1790  ***      0                                  0                  $sql = "SET " . $self->prop('setvars');
1791  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1792  ***      0                                  0                  $dbh->do($sql);
1793                                                              }
1794                                                           }
1795                                                        };
1796  ***      0      0      0                    0         if ( !$dbh && $EVAL_ERROR ) {
1797  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1798  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
1799  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1800  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1801                                                           }
1802  ***      0      0                           0            if ( !$tries ) {
1803  ***      0                                  0               die $EVAL_ERROR;
1804                                                           }
1805                                                        }
1806                                                     }
1807                                                  
1808  ***      0                                  0      MKDEBUG && _d('DBH info: ',
1809                                                        $dbh,
1810                                                        Dumper($dbh->selectrow_hashref(
1811                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1812                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1813                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1814                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1815                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1816                                                        '$DBI::VERSION:',        $DBI::VERSION,
1817                                                     );
1818                                                  
1819  ***      0                                  0      return $dbh;
1820                                                  }
1821                                                  
1822                                                  sub get_hostname {
1823  ***      0                    0             0      my ( $self, $dbh ) = @_;
1824  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1825  ***      0                                  0         return $host;
1826                                                     }
1827  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1828                                                        'SELECT /*!50038 @@hostname, */ 1');
1829  ***      0                                  0      return $hostname;
1830                                                  }
1831                                                  
1832                                                  sub disconnect {
1833  ***      0                    0             0      my ( $self, $dbh ) = @_;
1834  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1835  ***      0                                  0      $dbh->disconnect;
1836                                                  }
1837                                                  
1838                                                  sub print_active_handles {
1839  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1840  ***      0             0                    0      $level ||= 0;
1841  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1842                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1843                                                        or die "Cannot print: $OS_ERROR";
1844  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1845  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1846                                                     }
1847                                                  }
1848                                                  
1849                                                  sub _d {
1850  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1851  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1852  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1853                                                          @_;
1854  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1855                                                  }
1856                                                  
1857                                                  1;
1858                                                  
1859                                                  # ###########################################################################
1860                                                  # End DSNParser package
1861                                                  # ###########################################################################
1862                                                  
1863                                                  # ###########################################################################
1864                                                  # This is a combination of modules and programs in one -- a runnable module.
1865                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1866                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1867                                                  #
1868                                                  # Check at the end of this package for the call to main() which actually runs
1869                                                  # the program.
1870                                                  # ###########################################################################
1871                                                  package mk_visual_explain;
1872                                                  
1873           1                    1             8   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
1874           1                    1             7   use Getopt::Long;
               1                                  3   
               1                                  8   
1875           1                    1             6   use Data::Dumper;
               1                                  2   
               1                                  9   
1876                                                  $Data::Dumper::Indent    = 1;
1877                                                  $Data::Dumper::Quotekeys = 0;
1878                                                  
1879           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
1880                                                  
1881                                                  sub main {
1882           2                    2            65      @ARGV = @_;  # set global ARGV for this package
1883                                                  
1884                                                     # #######################################################################
1885                                                     # Get configuration information and parse command line options.
1886                                                     # #######################################################################
1887           2                                 17      my $dp = new DSNParser();
1888           2                                 18      my $o  = new OptionParser(
1889                                                        strict       => 0,
1890                                                        prompt       => '<options> [FILE]...',
1891                                                        description  => q{transforms EXPLAIN output into a tree } 
1892                                                                      . q{representation of the query plan.  If FILE is }
1893                                                                      . q{given, input is read from the file(s).  With no }
1894                                                                      . q{FILE, or when FILE is -, read standard input.},
1895                                                     );
1896           2                                  9      $o->get_specs();
1897           2                                 12      $o->get_opts();
1898           2                                  9      $o->usage_or_errors();
1899                                                  
1900                                                     # #######################################################################
1901                                                     # Get ready to do the main work.
1902                                                     # #######################################################################
1903                                                     # Magically read STDIN or files in @ARGV
1904           2                                  5      my $text = do { local $INPUT_RECORD_SEPARATOR = undef; <>; };
               2                                 12   
               2                                 96   
1905           2                                  6      my $rows;
1906                                                  
1907  ***      2     50                           8      if ( $o->got('connect') ) { # Connect to the database.
1908  ***      0                                  0         $dp->prop('setvars', $o->get('set-vars'));
1909                                                  
1910  ***      0      0      0                    0         if ( $o->got('ask-pass') && !$o->got('password') ) {
1911  ***      0                                  0            $o->set('password', OptionParser::prompt_noecho("Enter password: "));
1912                                                        }
1913                                                  
1914  ***      0                                  0         my $dbh = $dp->get_dbh(
1915                                                           $dp->get_cxn_params({$o->opt_values()}), { AutoCommit => 1 } );
1916                                                  
1917  ***      0                                  0         $text =~ s{^.*?select}{EXPLAIN /*!50115 PARTITIONS*/ SELECT}is;
1918  ***      0                                  0         $rows =  $dbh->selectall_arrayref($text, { Slice => {} } );
1919  ***      0                                  0         $dbh->disconnect();
1920                                                     }
1921                                                     else {
1922           2                                 17         $rows = ExplainParser->new->parse($text);
1923                                                     }
1924                                                  
1925                                                     # #######################################################################
1926                                                     # Do the main work.
1927                                                     # #######################################################################
1928           2                                 17      my $et   = ExplainTree->new();
1929           2                                  9      my $tree = $et->process($rows, { clustered => $o->get('clustered-pk') });
1930  ***      2     50                          10      if ( $tree ) {
1931           2    100                           8         print $o->get('format') eq 'dump' ? Dumper($tree)
1932                                                           : $et->pretty_print($tree);
1933                                                     }
1934                                                  
1935           2                                 62      return 0;
1936                                                  }
1937                                                  
1938                                                  # ############################################################################
1939                                                  # Run the program.
1940                                                  # ############################################################################
1941                                                  if ( !caller ) { exit main(@ARGV); }
1942                                                  
1943                                                  1; # Because this is a module as well as a script.
1944                                                  
1945                                                  # ############################################################################
1946                                                  # Documentation.
1947                                                  # ############################################################################
1948                                                  
1949                                                  =pod
1950                                                  
1951                                                  =head1 NAME
1952                                                  
1953                                                  mk-visual-explain - Format EXPLAIN output as a tree.
1954                                                  
1955                                                  =head1 SYNOPSIS
1956                                                  
1957                                                   mk-visual-explain <file_containing_explain_output>
1958                                                   mk-visual-explain -c <file_containing_query>
1959                                                   mysql -e "explain select * from mysql.user" | mk-visual-explain
1960                                                  
1961                                                  =head1 DESCRIPTION
1962                                                  
1963                                                  mk-visual-explain reverse-engineers MySQL's EXPLAIN output into a query
1964                                                  execution plan, which it then formats as a left-deep tree -- the same way the
1965                                                  plan is represented inside MySQL.  It is possible to do this by hand, or to read
1966                                                  EXPLAIN's output directly, but it requires patience and expertise.  Many people
1967                                                  find a tree representation more understandable.
1968                                                  
1969                                                  You can pipe input into mk-visual-explain or specify a filename at the
1970                                                  command line, including the magical '-' filename, which will read from standard
1971                                                  input.  It can do two things with the input: parse it for something that looks
1972                                                  like EXPLAIN output, or connect to a MySQL instance and run EXPLAIN on the
1973                                                  input.
1974                                                  
1975                                                  When parsing its input, mk-visual-explain understands three formats: tabular
1976                                                  like that shown in the mysql command-line client, vertical like that created by
1977                                                  using the \G line terminator in the mysql command-line client, and tab
1978                                                  separated.  It ignores any lines it doesn't know how to parse.
1979                                                  
1980                                                  When executing the input, mk-visual-explain replaces everything in the input
1981                                                  up to the first SELECT keyword with 'EXPLAIN SELECT,' and then executes the
1982                                                  result.  You must specify L<"--connect"> to execute the input as a query.
1983                                                  
1984                                                  Either way, it builds a tree from the result set and prints it to standard
1985                                                  output.  For the following query,
1986                                                  
1987                                                   select * from sakila.film_actor join sakila.film using(film_id);
1988                                                  
1989                                                  mk-visual-explain generates this query plan:
1990                                                  
1991                                                   JOIN
1992                                                   +- Bookmark lookup
1993                                                   |  +- Table
1994                                                   |  |  table          film_actor
1995                                                   |  |  possible_keys  idx_fk_film_id
1996                                                   |  +- Index lookup
1997                                                   |     key            film_actor->idx_fk_film_id
1998                                                   |     possible_keys  idx_fk_film_id
1999                                                   |     key_len        2
2000                                                   |     ref            sakila.film.film_id
2001                                                   |     rows           2
2002                                                   +- Table scan
2003                                                      rows           952
2004                                                      +- Table
2005                                                         table          film
2006                                                         possible_keys  PRIMARY
2007                                                  
2008                                                  The query plan is left-deep, depth-first search, and the tree's root is the
2009                                                  output node -- the last step in the execution plan.  In other words, read it
2010                                                  like this:
2011                                                  
2012                                                  =over
2013                                                  
2014                                                  =item 1
2015                                                  
2016                                                  Table scan the 'film' table, which accesses an estimated 952 rows.
2017                                                  
2018                                                  =item 2
2019                                                  
2020                                                  For each row, find matching rows by doing an index lookup into the
2021                                                  film_actor->idx_fk_film_id index with the value from sakila.film.film_id, then a
2022                                                  bookmark lookup into the film_actor table.
2023                                                  
2024                                                  =back
2025                                                  
2026                                                  For more information on how to read EXPLAIN output, please see
2027                                                  L<http://dev.mysql.com/doc/en/explain.html>, and this talk titled "Query
2028                                                  Optimizer Internals and What's New in the MySQL 5.2 Optimizer," from Timour
2029                                                  Katchaounov, one of the MySQL developers:
2030                                                  L<http://conferences.oreillynet.com/presentations/mysql07/katchaounov_timour.pdf>.
2031                                                  
2032                                                  =head1 DOWNLOADING
2033                                                  
2034                                                  You can download Maatkit from Google Code at
2035                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2036                                                  easily with a command like the following:
2037                                                  
2038                                                     wget http://www.maatkit.org/get/toolname
2039                                                     or
2040                                                     wget http://www.maatkit.org/trunk/toolname
2041                                                  
2042                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2043                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2044                                                  needed.  The first URL gets the latest released version of the tool, and the
2045                                                  second gets the latest trunk code from Subversion.
2046                                                  
2047                                                  =head1 OPTIONS
2048                                                  
2049                                                  =over
2050                                                  
2051                                                  =item --ask-pass
2052                                                  
2053                                                  Prompt for a password when connecting to MySQL.
2054                                                  
2055                                                  =item --charset
2056                                                  
2057                                                  short form: -A; type: string
2058                                                  
2059                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2060                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
2061                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
2062                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
2063                                                  connecting to MySQL.
2064                                                  
2065                                                  =item --clustered-pk
2066                                                  
2067                                                  Assume that PRIMARY KEY index accesses don't need to do a bookmark lookup to
2068                                                  retrieve rows.  This is the case for InnoDB.
2069                                                  
2070                                                  =item --config
2071                                                  
2072                                                  type: Array
2073                                                  
2074                                                  Read this comma-separated list of config files; if specified, this must be the
2075                                                  first option on the command line.
2076                                                  
2077                                                  =item --connect
2078                                                  
2079                                                  Treat input as a query, and obtain EXPLAIN output by connecting to a MySQL
2080                                                  instance and running EXPLAIN on the query.  When this option is given,
2081                                                  mk-visual-explain uses the other connection-specific options such as
2082                                                  L<"--user"> to connect to the MySQL instance.  If you have a .my.cnf file,
2083                                                  it will read it, so you may not need to specify any connection-specific
2084                                                  options.
2085                                                  
2086                                                  =item --database
2087                                                  
2088                                                  short form: -D; type: string
2089                                                  
2090                                                  Connect to this database.
2091                                                  
2092                                                  =item --defaults-file
2093                                                  
2094                                                  short form: -F; type: string
2095                                                  
2096                                                  Only read mysql options from the given file.  You must give an absolute
2097                                                  pathname.
2098                                                  
2099                                                  =item --format
2100                                                  
2101                                                  type: string; default: tree
2102                                                  
2103                                                  Set output format.
2104                                                  
2105                                                  The default is a terse pretty-printed tree. The valid values are:
2106                                                  
2107                                                   value  meaning
2108                                                   =====  =======
2109                                                   tree   Pretty-printed terse tree.
2110                                                   dump   Data::Dumper output (see L<Data::Dumper> for more).
2111                                                  
2112                                                  =item --help
2113                                                  
2114                                                  Show help and exit.
2115                                                  
2116                                                  =item --host
2117                                                  
2118                                                  short form: -h; type: string
2119                                                  
2120                                                  Connect to host.
2121                                                  
2122                                                  =item --password
2123                                                  
2124                                                  short form: -p; type: string
2125                                                  
2126                                                  Password to use when connecting.
2127                                                  
2128                                                  =item --port
2129                                                  
2130                                                  short form: -P; type: int
2131                                                  
2132                                                  Port number to use for connection.
2133                                                  
2134                                                  =item --set-vars
2135                                                  
2136                                                  type: string; default: wait_timeout=10000
2137                                                  
2138                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
2139                                                  string will be appended to SET and executed.
2140                                                  
2141                                                  =item --socket
2142                                                  
2143                                                  short form: -S; type: string
2144                                                  
2145                                                  Socket file to use for connection.
2146                                                  
2147                                                  =item --user
2148                                                  
2149                                                  short form: -u; type: string
2150                                                  
2151                                                  User for login if not current user.
2152                                                  
2153                                                  =item --version
2154                                                  
2155                                                  Show version and exit.
2156                                                  
2157                                                  =back
2158                                                  
2159                                                  =head1 MODULES
2160                                                  
2161                                                  This program is actually a runnable module, not just an ordinary Perl script.
2162                                                  In fact, there are two modules embedded in it.  This makes unit testing easy,
2163                                                  but it also makes it easy for you to use the parsing and tree-building
2164                                                  functionality if you want.
2165                                                  
2166                                                  The ExplainParser package accepts a string and parses whatever it thinks looks
2167                                                  like EXPLAIN output from it.  The synopsis is as follows:
2168                                                  
2169                                                   require "mk-visual-explain";
2170                                                   my $p    = ExplainParser->new();
2171                                                   my $rows = $p->parse("some text");
2172                                                   # $rows is an arrayref of hashrefs.
2173                                                  
2174                                                  The ExplainTree package accepts a set of rows and turns it into a tree.  For
2175                                                  convenience, you can also have it delegate to ExplainParser and parse text for
2176                                                  you.  Here's the synopsis:
2177                                                  
2178                                                   require "mk-visual-explain";
2179                                                   my $e      = ExplainTree->new();
2180                                                   my $tree   = $e->parse("some text", \%options);
2181                                                   my $output = $e->pretty_print($tree);
2182                                                   print $tree;
2183                                                  
2184                                                  =head1 ALGORITHM
2185                                                  
2186                                                  This section explains the algorithm that converts EXPLAIN into a tree.  You may
2187                                                  be interested in reading this if you want to understand EXPLAIN more fully, or
2188                                                  trying to figure out how this works, but otherwise this section will probably
2189                                                  not make your life richer.
2190                                                  
2191                                                  The tree can be built by examining the id, select_type, and table columns of
2192                                                  each row.  Here's what I know about them:
2193                                                  
2194                                                  The id column is the sequential number of the select.  This does not indicate
2195                                                  nesting; it just comes from counting SELECT from the left of the SQL statement.
2196                                                  It's like capturing parentheses in a regular expression.  A UNION RESULT row
2197                                                  doesn't have an id, because it isn't a SELECT.  The source code actually refers
2198                                                  to UNIONs as a fake_lex, as I recall.
2199                                                  
2200                                                  If two adjacent rows have the same id value, they are joined with the standard
2201                                                  single-sweep multi-join method.
2202                                                  
2203                                                  The select_type column tells a) that a new sub-scope has opened b) what kind
2204                                                  of relationship the row has to the previous row c) what kind of operation the
2205                                                  row represents.
2206                                                  
2207                                                  =over
2208                                                  
2209                                                  =item *
2210                                                  
2211                                                  SIMPLE means there are no subqueries or unions in the whole query.
2212                                                  
2213                                                  =item *
2214                                                  
2215                                                  PRIMARY means there are, but this is the outermost SELECT.
2216                                                  
2217                                                  =item  *
2218                                                  
2219                                                  [DEPENDENT] UNION means this result is UNIONed with the previous result (not
2220                                                  row; a result might encompass more than one row).
2221                                                  
2222                                                  =item *
2223                                                  
2224                                                  UNION RESULT terminates a set of UNIONed results.
2225                                                  
2226                                                  =item *
2227                                                  
2228                                                  [DEPENDENT|UNCACHEABLE] SUBQUERY means a new sub-scope is opening.  This is the
2229                                                  kind of subquery that happens in a WHERE clause, SELECT list or whatnot; it does
2230                                                  not return a so-called "derived table."
2231                                                  
2232                                                  =item *
2233                                                  
2234                                                  DERIVED is a subquery in the FROM clause.
2235                                                  
2236                                                  =back
2237                                                  
2238                                                  Tables that are JOINed all have the same select_type.  For example, if you JOIN
2239                                                  three tables inside a dependent subquery, they'll all say the same thing:
2240                                                  DEPENDENT SUBQUERY.
2241                                                  
2242                                                  The table column usually specifies the table name or alias, but may also say
2243                                                  <derivedN> or <unionN,N...N>.  If it says <derivedN>, the row represents an
2244                                                  access to the temporary table that holds the result of the subquery whose id is
2245                                                  N.  If it says <unionN,..N> it's the same thing, but it refers to the results it
2246                                                  UNIONs together.
2247                                                  
2248                                                  Finally, order matters.  If a row's id is less than the one before it, I think
2249                                                  that means it is dependent on something other than the one before it.  For
2250                                                  example,
2251                                                  
2252                                                   explain select
2253                                                      (select 1 from sakila.film),
2254                                                      (select 2 from sakila.film_actor),
2255                                                      (select 3 from sakila.actor);
2256                                                  
2257                                                   | id | select_type | table      |
2258                                                   +----+-------------+------------+
2259                                                   |  1 | PRIMARY     | NULL       |
2260                                                   |  4 | SUBQUERY    | actor      |
2261                                                   |  3 | SUBQUERY    | film_actor |
2262                                                   |  2 | SUBQUERY    | film       |
2263                                                  
2264                                                  If the results were in order 2-3-4, I think that would mean 3 is a subquery of
2265                                                  2, 4 is a subquery of 3.  As it is, this means 4 is a subquery of the neares
2266                                                  previous recent row with a smaller id, which is 1.  Likewise for 3 and 2.
2267                                                  
2268                                                  This structure is hard to programatically build into a tree for the same reason
2269                                                  it's hard to understand by inspection: there are both forward and backward
2270                                                  references.  <derivedN> is a forward reference to selectN, while <unionM,N> is a
2271                                                  backward reference to selectM and selectN.  That makes recursion and other
2272                                                  tree-building algorithms hard to get right (NOTE: after implementation, I now
2273                                                  see how it would be possible to deal with both forward and backward references,
2274                                                  but I have no motivation to change something that works).  Consider the
2275                                                  following:
2276                                                  
2277                                                   select * from (
2278                                                      select 1 from sakila.actor as actor_1
2279                                                      union
2280                                                      select 1 from sakila.actor as actor_2
2281                                                   ) as der_1
2282                                                   union
2283                                                   select * from (
2284                                                      select 1 from sakila.actor as actor_3
2285                                                      union all
2286                                                      select 1 from sakila.actor as actor_4
2287                                                   ) as der_2;
2288                                                  
2289                                                   | id   | select_type  | table      |
2290                                                   +------+--------------+------------+
2291                                                   |  1   | PRIMARY      | <derived2> |
2292                                                   |  2   | DERIVED      | actor_1    |
2293                                                   |  3   | UNION        | actor_2    |
2294                                                   | NULL | UNION RESULT | <union2,3> |
2295                                                   |  4   | UNION        | <derived5> |
2296                                                   |  5   | DERIVED      | actor_3    |
2297                                                   |  6   | UNION        | actor_4    |
2298                                                   | NULL | UNION RESULT | <union5,6> |
2299                                                   | NULL | UNION RESULT | <union1,4> |
2300                                                  
2301                                                  This would be a lot easier to work with if it looked like this (I've
2302                                                  bracketed the id on rows I moved):
2303                                                  
2304                                                   | id   | select_type  | table      |
2305                                                   +------+--------------+------------+
2306                                                   | [1]  | UNION RESULT | <union1,4> |
2307                                                   |  1   | PRIMARY      | <derived2> |
2308                                                   | [2]  | UNION RESULT | <union2,3> |
2309                                                   |  2   | DERIVED      | actor_1    |
2310                                                   |  3   | UNION        | actor_2    |
2311                                                   |  4   | UNION        | <derived5> |
2312                                                   | [5]  | UNION RESULT | <union5,6> |
2313                                                   |  5   | DERIVED      | actor_3    |
2314                                                   |  6   | UNION        | actor_4    |
2315                                                  
2316                                                  In fact, why not re-number all the ids, so the PRIMARY row becomes 2, and so on?
2317                                                  That would make it even easier to read.  Unfortunately that would also have the
2318                                                  effect of destroying the meaning of the id column, which I think is important to
2319                                                  preserve in the final tree.  Also, though it makes it easier to read, it doesn't
2320                                                  make it easier to manipulate programmatically; so it's fine to leave them
2321                                                  numbered as they are.
2322                                                  
2323                                                  The goal of re-ordering is to make it easier to figure out which rows are
2324                                                  children of which rows in the execution plan.  Given the reordered list and some
2325                                                  row whose table is <union...> or <derived>, it is easy to find the beginning of
2326                                                  the slice of rows that should be child nodes in the tree: you just look for the
2327                                                  first row whose ID is the same as the first number in the table.
2328                                                  
2329                                                  The next question is how to find the last row that should be a child node of a
2330                                                  UNION or DERIVED.   I'll start with DERIVED, because the solution makes UNION
2331                                                  easy.
2332                                                  
2333                                                  Consider how MySQL numbers the SELECTs sequentially according to their position
2334                                                  in the SQL, left-to-right.  Since a DERIVED table encloses everything within it
2335                                                  in a scope, which becomes a temporary table, there are only two things to think
2336                                                  about: its child subqueries and unions (if any), and its next siblings in the
2337                                                  scope that encloses it.  Its children will all have an id greater than it does,
2338                                                  by definition, so any later rows with a smaller id terminate the scope.
2339                                                  
2340                                                  Here's an example.  The middle derived table here has a subquery and a UNION to
2341                                                  make it a little more complex for the example.
2342                                                  
2343                                                   explain select 1
2344                                                   from (
2345                                                      select film_id from sakila.film limit 1
2346                                                   ) as der_1
2347                                                   join (
2348                                                      select film_id, actor_id, (select count(*) from sakila.rental) as r
2349                                                      from sakila.film_actor limit 1
2350                                                      union all
2351                                                      select 1, 1, 1 from sakila.film_actor as dummy
2352                                                   ) as der_2 using (film_id)
2353                                                   join (
2354                                                      select actor_id from sakila.actor limit 1
2355                                                   ) as der_3 using (actor_id);
2356                                                  
2357                                                  Here's the output of EXPLAIN:
2358                                                  
2359                                                   | id   | select_type  | table      |
2360                                                   |  1   | PRIMARY      | <derived2> |
2361                                                   |  1   | PRIMARY      | <derived6> |
2362                                                   |  1   | PRIMARY      | <derived3> |
2363                                                   |  6   | DERIVED      | actor      |
2364                                                   |  3   | DERIVED      | film_actor |
2365                                                   |  4   | SUBQUERY     | rental     |
2366                                                   |  5   | UNION        | dummy      |
2367                                                   | NULL | UNION RESULT | <union3,5> |
2368                                                   |  2   | DERIVED      | film       |
2369                                                  
2370                                                  The siblings all have id 1, and the middle one I care about is derived3.
2371                                                  (Notice MySQL doesn't execute them in the order I defined them, which is fine).
2372                                                  Now notice that MySQL prints out the rows in the opposite order I defined the
2373                                                  subqueries: 6, 3, 2.  It always seems to do this, and there might be other
2374                                                  methods of finding the scope boundaries including looking for the lower boundary
2375                                                  of the next largest sibling, but this is a good enough heuristic.  I am forced
2376                                                  to rely on it for non-DERIVED subqueries, so I rely on it here too.  Therefore,
2377                                                  I decide that everything greater than or equal to 3 belongs to the DERIVED
2378                                                  scope.
2379                                                  
2380                                                  The rule for UNION is simple: they consume the entire enclosing scope, and to
2381                                                  find the component parts of each one, you find each part's beginning as referred
2382                                                  to in the <unionN,...> definition, and its end is either just before the next
2383                                                  one, or if it's the last part, the end is the end of the scope.
2384                                                  
2385                                                  This is only simple because UNION consumes the entire scope, which is either the
2386                                                  entire statement, or the scope of a DERIVED table.  This is because a UNION
2387                                                  cannot be a sibling of another UNION or a table, DERIVED or not.  (Try writing
2388                                                  such a statement if you don't see it intuitively).  Therefore, you can just find
2389                                                  the enclosing scope's boundaries, and the rest is easy.  Notice in the example
2390                                                  above, the UNION is over <union3,5>, which includes the row with id 4 -- it
2391                                                  includes every row between 3 and 5.
2392                                                  
2393                                                  Finally, there are non-derived subqueries to deal with as well.  In this case I
2394                                                  can't look at siblings to find the end of the scope as I did for DERIVED.  I
2395                                                  have to trust that MySQL executes depth-first.  Here's an example:
2396                                                  
2397                                                   explain
2398                                                   select actor_id,
2399                                                   (
2400                                                      select count(film_id)
2401                                                      + (select count(*) from sakila.film)
2402                                                      from sakila.film join sakila.film_actor using(film_id)
2403                                                      where exists(
2404                                                         select * from sakila.actor
2405                                                         where sakila.actor.actor_id = sakila.film_actor.actor_id
2406                                                      )
2407                                                   )
2408                                                   from sakila.actor;
2409                                                  
2410                                                   | id | select_type        | table      |
2411                                                   |  1 | PRIMARY            | actor      |
2412                                                   |  2 | SUBQUERY           | film       |
2413                                                   |  2 | SUBQUERY           | film_actor |
2414                                                   |  4 | DEPENDENT SUBQUERY | actor      |
2415                                                   |  3 | SUBQUERY           | film       |
2416                                                  
2417                                                  In order, the tree should be built like this:
2418                                                  
2419                                                  =over
2420                                                  
2421                                                  =item *
2422                                                  
2423                                                  See row 1.
2424                                                  
2425                                                  =item *
2426                                                  
2427                                                  See row 2.  It's a higher id than 1, so it's a subquery, along with every other
2428                                                  row whose id is greater than 2.
2429                                                  
2430                                                  =item *
2431                                                  
2432                                                  Inside this scope, see 2 and 2 and JOIN them.  See 4.  It's a higher id than 2,
2433                                                  so it's again a subquery; recurse.  After that, see 3, which is also higher;
2434                                                  recurse.
2435                                                  
2436                                                  =back
2437                                                  
2438                                                  But the only reason the nested subquery didn't include select 3 is because
2439                                                  select 4 came first.  In other words, if EXPLAIN looked like this,
2440                                                  
2441                                                   | id | select_type        | table      |
2442                                                   |  1 | PRIMARY            | actor      |
2443                                                   |  2 | SUBQUERY           | film       |
2444                                                   |  2 | SUBQUERY           | film_actor |
2445                                                   |  3 | SUBQUERY           | film       |
2446                                                   |  4 | DEPENDENT SUBQUERY | actor      |
2447                                                  
2448                                                  I would be forced to assume upon seeing select 3 that select 4 is a subquery
2449                                                  of it, rather than just being the next sibling in the enclosing scope.  If this
2450                                                  is ever wrong, then the algorithm is wrong, and I don't see what could be done
2451                                                  about it.
2452                                                  
2453                                                  UNION is a little more complicated than just "the entire scope is a UNION,"
2454                                                  because the UNION might itself be inside an enclosing scope that's only
2455                                                  indicated by the first item inside the UNION.  There are only three kinds of
2456                                                  enclosing scopes: UNION, DERIVED, and SUBQUERY.  A UNION can't enclose a UNION,
2457                                                  and a DERIVED has its own "scope markers," but a SUBQUERY can wholly enclose a
2458                                                  UNION, like this strange example on the empty table t1:
2459                                                  
2460                                                   explain select * from t1 where not exists(
2461                                                      (select t11.i from t1 t11) union (select t12.i from t1 t12));
2462                                                  
2463                                                   |   id | select_type  | table      | Extra                          |
2464                                                   +------+--------------+------------+--------------------------------+
2465                                                   |    1 | PRIMARY      | t1         | const row not found            |
2466                                                   |    2 | SUBQUERY     | NULL       | No tables used                 |
2467                                                   |    3 | SUBQUERY     | NULL       | no matching row in const table |
2468                                                   |    4 | UNION        | t12        | const row not found            |
2469                                                   | NULL | UNION RESULT | <union2,4> |                                |
2470                                                  
2471                                                  The UNION's backward references might make it look like the UNION encloses the
2472                                                  subquery, but studying the query makes it clear this isn't the case.  So when a
2473                                                  UNION's first row says SUBQUERY, it is this special case.
2474                                                  
2475                                                  By the way, I don't fully understand this query plan; there are 4 numbered
2476                                                  SELECT in the plan, but only 3 in the query.  The parens around the UNIONs are
2477                                                  meaningful.  Removing them will make the EXPLAIN different.  Please tell me how
2478                                                  and why this works if you know.
2479                                                  
2480                                                  Armed with this knowledge, it's possible to use recursion to turn the
2481                                                  parent-child relationship between all the rows into a tree representing the
2482                                                  execution plan.
2483                                                  
2484                                                  MySQL prints the rows in execution order, even the forward and backward
2485                                                  references.  At any given scope, the rows are processed as a left-deep tree.
2486                                                  MySQL does not do "bushy" execution plans.  It begins with a table, finds a
2487                                                  matching row in the next table, and continues till the last table, when it emits
2488                                                  a row.  When it runs out, it backtracks till it can find the next row and
2489                                                  repeats.  There are subtleties of course, but this is the basic plan.  This is
2490                                                  why MySQL transforms all RIGHT OUTER JOINs into LEFT OUTER JOINs and cannot do
2491                                                  FULL OUTER JOIN.
2492                                                  
2493                                                  This means in any given scope, say
2494                                                  
2495                                                   | id   | select_type  | table      |
2496                                                   |  1   | SIMPLE       | tbl1       |
2497                                                   |  1   | SIMPLE       | tbl2       |
2498                                                   |  1   | SIMPLE       | tbl3       |
2499                                                  
2500                                                  The execution plan looks like a depth-first traversal of this tree:
2501                                                  
2502                                                         JOIN
2503                                                        /    \
2504                                                      JOIN  tbl3
2505                                                     /    \
2506                                                   tbl1   tbl2
2507                                                  
2508                                                  The JOIN might not be a JOIN.  It might be a subquery, for example.  This comes
2509                                                  from the type column of EXPLAIN.  The documentation says this is a "join type,"
2510                                                  but I think "access type" is more accurate, because it's "how MySQL accesses
2511                                                  rows."
2512                                                  
2513                                                  mk-visual-explain decorates the tree significantly more than just turning
2514                                                  rows into nodes.  Each node may get a series of transformations that turn it
2515                                                  into a subtree of more than one node.  For example, an index scan not marked
2516                                                  with 'Using index' must do a bookmark lookup into the table rows; that is a
2517                                                  three-node subtree.  However, after the above node-ordering and scoping stuff,
2518                                                  the rest of the process is pretty simple.
2519                                                  
2520                                                  =head1 SEE ALSO
2521                                                  
2522                                                  See also L<mk-query-profiler>.
2523                                                  
2524                                                  =head1 ENVIRONMENT
2525                                                  
2526                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2527                                                  the Maatkit tools:
2528                                                  
2529                                                     MKDEBUG=1 mk-....
2530                                                  
2531                                                  =head1 BUGS
2532                                                  
2533                                                  Please use Google Code Issues and Groups to report bugs or request support:
2534                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2535                                                  discuss Maatkit.
2536                                                  
2537                                                  Please include the complete command-line used to reproduce the problem you are
2538                                                  seeing, the version of all MySQL servers involved, the complete output of the
2539                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2540                                                  running with the C<MKDEBUG=1> environment variable.
2541                                                  
2542                                                  =head1 SYSTEM REQUIREMENTS
2543                                                  
2544                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2545                                                  installed in any reasonably new version of Perl.
2546                                                  
2547                                                  =head1 AUTHOR
2548                                                  
2549                                                  Baron "Xaprb" Schwartz.
2550                                                  
2551                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2552                                                  
2553                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
2554                                                  Feedback and improvements are welcome.
2555                                                  
2556                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2557                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2558                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2559                                                  
2560                                                  This program is free software; you can redistribute it and/or modify it under
2561                                                  the terms of the GNU General Public License as published by the Free Software
2562                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2563                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2564                                                  licenses.
2565                                                  
2566                                                  You should have received a copy of the GNU General Public License along with
2567                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2568                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2569                                                  
2570                                                  =head1 VERSION
2571                                                  
2572                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 3867 $.
2573                                                  
2574                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
46           100      2      6   unless @cols
55    ***      0      0      0   unless @cols
75    ***     50      2      0   if ($text =~ /^\+---/m) { }
      ***      0      0      0   elsif ($text =~ /^id\tselect_type\t/m) { }
      ***      0      0      0   elsif ($text =~ /\*\*\* 1. row/) { }
88    ***     50      2      0   if ($line_re)
93           100      6      2   if ($row) { }
95           100     22     38   if (not $$row{$key} or $$row{$key} eq 'NULL')
127          100      2      2   if ($options and ref $options eq 'HASH') { }
146   ***     50      0      2   unless ref $rows eq 'ARRAY' and @$rows
160   ***     50      0      6   if $$row{'table'} and $$row{'table'} =~ /\./
163          100      2      4   if (not defined $$row{'id'})
164   ***     50      2      0   if ($$row{'table'} and my($id) = $$row{'table'} =~ /^<union(\d+)/) { }
182          100      2      2   if ($last_id != $$row{'id'} and $union_for{$$row{'id'}})
198   ***     50      0      6   if (not @rows)
203          100      2      4   if ($rows[0]{'select_type'} eq 'UNION RESULT')
208   ***     50      0      2   if ($rows[0]{'select_type'} =~ /SUBQUERY/)
213          100      2      2   $i < $#ids ? :
217   ***     50      0      4   unless $self->recursive_table_name($_)
221   ***     50      0      2   if ($enclosing_scope)
231   ***     50      4      0   if $$_{'table'}
273   ***     50      0      4   if ($$first{'Extra'} =~ /Using temporary; Using filesort/) { }
      ***     50      0      4   elsif ($$first{'Extra'} =~ /Using filesort/ and $$first{'type'} =~ /^(?:system|const)$/) { }
286   ***      0      0      0   if ($first_non_const)
297   ***      0      0      0   if ($$row{'id'} == $scope) { }
321   ***     50      0      4   if ($is_temp_filesort)
343   ***      0      0      0   !($$row{'select_type'} =~ /^(?:PRIMARY|SIMPLE)$/) ? :
      ***      0      0      0   $$row{'Extra'} =~ /optimized away/ ? :
      ***      0      0      0   $$row{'Extra'} =~ /(?:$no_matching_row)/i ? :
      ***      0      0      0   $$row{'Extra'} =~ /No tables/ ? :
      ***     50      6      0   $sub ? :
357   ***     50      0      6   if ($warn)
364   ***     50      0      6   if ($$row{'Extra'} =~ /Using where/)
371   ***     50      0      6   if ($$row{'Extra'} =~ /Using join buffer/)
378   ***     50      0      6   if ($$row{'Extra'} =~ /Distinct|Not exists/)
385   ***     50      0      6   if ($$row{'Extra'} =~ /Range checked for each record \(\w+ map: ([^\)]+)\)/)
405   ***     50      0      6   if ($$row{'Extra'} =~ /Using filesort/)
409   ***     50      0      6   if ($$row{'Extra'} =~ /Using temporary/)
425          100      6      2   if ($$row{'id'} and $$row{'id'} == $id)
430   ***      0      0      0   unless $$_{'id'}
437          100      3      1   $prefix ? :
441          100      2      2   if ($$node{'children'})
444          100      1      3   @kids > 1 ? :
447          100      7     29   if (defined $$node{$thing})
456          100      2      2   if ($last_child)
555   ***     50      0      4   if ($$node{'table'})
558   ***     50      4      0   if ($$node{'key'})
562   ***      0      0      0   if ($$node{'type'} eq 'Bookmark lookup')
565   ***      0      0      0   if ($$node{'type'} eq 'IMPOSSIBLE')
568   ***      0      0      0   if ($$node{'children'})
602   ***      0      0      0   if (not @children)
624   ***     50      2      0   $$row{'table'} && $$row{'table'} =~ /^(derived|union)\(/ ? :
632   ***     50      2      0   if ($$row{'children'})
640   ***     50      4      0   if ($$row{'Extra'} =~ /Using index/ or $$self{'clustered'} and $$row{'key'} and $$row{'key'} eq 'PRIMARY')
668   ***      0      0      0   if ($is_scan)
689   ***     50      0      4   if ($$row{'Extra'} =~ /Full scan on NULL key/)
692   ***     50      0      4   if ($$row{'Extra'} =~ /Using index for group-by/)
696   ***     50      4      0   if ($$row{'type'} ne 'index_merge')
721   ***     50      0      2   unless $args{$arg}
726   ***     50      2      0   exists $args{'strict'} ? :
769   ***     50      0      2   unless open my $fh, '<', $file
789          100    526      2   unless $para =~ /^=head1 OPTIONS/
794   ***     50      2      0   if $para =~ /^=over/
802   ***     50      0      2   unless $para
805          100     32      2   if (my($option) = $para =~ /^=item --(.*)/)
812          100     22     10   if ($para =~ /: /) { }
815          100     16      6   if ($attribs{'short form'})
831   ***     50      0     32   if $para =~ /^=item/
833   ***     50      0     32   if (my($base_option) = $option =~ /^\[no\](.*)/)
838          100     16     16   $attribs{'short form'} ? :
      ***     50      0     32   $attribs{'negatable'} ? :
      ***     50      0     32   $attribs{'cumulative'} ? :
             100     22     10   $attribs{'type'} ? :
             100      4     28   $attribs{'default'} ? :
      ***     50      0     32   $attribs{'group'} ? :
850   ***     50      0     40   unless $para
853          100      2     38   if ($para =~ /^=head1/)
857          100     32      6   if $para =~ /^=item --/
861   ***     50      0      2   unless @specs
872   ***     50     32      0   if (ref $opt) { }
877   ***     50      0     32   if (not $long)
882   ***     50      0     32   if exists $$self{'opts'}{$long}
885   ***     50      0     32   if (length $long == 1)
890          100     16     16   if ($short) { }
891   ***     50      0     16   if exists $$self{'short_opts'}{$short}
900   ***     50      0     32   $$opt{'spec'} =~ /!/ ? :
901   ***     50      0     32   $$opt{'spec'} =~ /\+/ ? :
902   ***     50      0     32   $$opt{'desc'} =~ /required/ ? :
914   ***     50      0     32   if ($type and $type eq 'd' and not $$self{'dp'})
919          100      2     30   if $type and $type =~ /[HhAadzm]/
921          100      4     28   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
922   ***     50      0      4   if ($$opt{'is_negatable'})
923   ***      0      0      0   $def eq 'no' ? :
      ***      0      0      0   $def eq 'yes' ? :
927   ***     50      4      0   defined $def ? :
931          100      2     30   if ($long eq 'config')
935   ***     50      0     32   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
948   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
953   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
958   ***      0      0      0   if ($opt =~ /default to/)
963   ***      0      0      0   if ($opt =~ /restricted to option groups/)
973   ***      0      0      0   unless $rule_ok
990   ***      0      0      0   unless exists $$self{'opts'}{$long}
1006  ***      0      0      0   $$self{'opts'}{$_}{'short'} ? :
1024  ***      0      0      0   unless exists $$self{'opts'}{$long}
1044  ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50      1      0   exists $$self{'opts'}{$opt} ? :
1049  ***     50      0      1   if ($$opt{'is_cumulative'}) { }
1064  ***     50      0     26   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100      6     26   exists $$self{'defaults'}{$long} ? :
1073  ***     50      0      2   if (@ARGV and $ARGV[0] eq '--config')
1077  ***     50      2      0   if ($self->has('config'))
1083  ***     50      8      0   if ($EVAL_ERROR)
1084  ***     50      0      8   $self->got('config') ? :
1099  ***     50      0      2   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
1102  ***     50      0      2   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
1103  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1109  ***     50      0      2   if (@ARGV and $$self{'strict'})
1115  ***      0      0      0   if (@set > 1)
1126  ***      0      0      0   if (@set == 0)
1136         100      1     31   if ($$opt{'got'}) { }
      ***     50      0     31   elsif ($$opt{'is_required'}) { }
1137  ***     50      0      1   if (exists $$self{'disables'}{$long})
1144  ***     50      0      1   if (exists $$self{'allowed_groups'}{$long})
1156  ***      0      0      0   if $restricted_opt eq $long
1157  ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
1162  ***      0      0      0   if (@restricted_opts)
1164  ***      0      0      0   if (@restricted_opts == 1) { }
1193         100     10     22   unless $opt and $$opt{'type'}
1196  ***     50      0     22   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0     22   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     22   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0     22   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      2     20   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1199  ***      0      0      0   if (not $suffix)
1205  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1206  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1221  ***      0      0      0   if ($from_key)
1232  ***      0      0      0   if (defined $num) { }
1233  ***      0      0      0   if ($factor)
1260  ***     50      0      6   length $opt == 1 ? :
1261  ***     50      0      6   unless $long and exists $$self{'opts'}{$long}
1268  ***     50      0     10   length $opt == 1 ? :
1269  ***     50      0     10   unless $long and exists $$self{'opts'}{$long}
1276  ***     50      0      2   length $opt == 1 ? :
1277  ***     50      2      0   defined $long ? :
1282  ***      0      0      0   length $opt == 1 ? :
1283  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1317  ***     50      0      2   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      2   elsif (scalar @{$$self{'errors'};}) { }
1318  ***      0      0      0   unless print $self->print_usage
1322  ***      0      0      0   unless print $self->print_errors
1331  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1340  ***      0      0      0   unless $$self{'got_opts'}
1343  ***      0      0      0   $$_{'is_negatable'} ? :
1347  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1363  ***      0      0      0   $group eq 'default' ? :
1369  ***      0      0      0   $$opt{'is_negatable'} ? :
1372  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1381  ***      0      0      0   if ($short) { }
1390  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1394  ***      0      0      0   if ($$self{'dp'})
1402  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1414  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1417  ***      0      0      0   unless print $prompt
1425  ***      0      0      0   unless print "\n"
1428  ***      0      0      0   if ($EVAL_ERROR)
1450  ***     50      8      0   unless open my $fh, '<', $filename
1458  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1461  ***      0      0      0   if ($line eq '--')
1466  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1484  ***      0      0      0   unless open my $fh, '<', $file
1488  ***      0      0      0   unless $para =~ /^=pod$/m
1492  ***      0      0      0   unless $para =~ /$regex/
1497  ***      0      0      0   unless close $fh
1511  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1526  ***      0      0      0   defined $_ ? :
1609  ***      0      0      0   if (@_ > 2)
1618  ***      0      0      0   if (not $dsn)
1631  ***      0      0      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
      ***      0      0      0   elsif ($prop_autokey) { }
1647  ***      0      0      0   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1653  ***      0      0      0   if (not defined $final_props{$key})
1660  ***      0      0      0   unless exists $opts{$key}
1663  ***      0      0      0   if (my $required = $self->prop('required'))
1665  ***      0      0      0   unless $final_props{$key}
1674  ***      0      0      0   unless ref $o eq 'OptionParser'
1677  ***      0      0      0   if $o->has($_)
1687  ***      0      0      0   unless ref $dsn
1688  ***      0      0      0   $_ eq 'p' ? :
1689  ***      0      0      0   if defined $$dsn{$_}
1702  ***      0      0      0   $opts{$key}{'copy'} ? :
1707  ***      0      0      0   if (my $key = $self->prop('autokey'))
1718  ***      0      0      0   if ($driver eq 'Pg') { }
1750  ***      0      0      0   $cxn_string =~ /charset=utf8/ ? :
1767  ***      0      0      0   if ($cxn_string =~ /mysql/i)
1775  ***      0      0      0   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1780  ***      0      0      0   if ($charset eq 'utf8') { }
1781  ***      0      0      0   unless binmode STDOUT, ':utf8'
1785  ***      0      0      0   unless binmode STDOUT
1789  ***      0      0      0   if ($self->prop('setvars'))
1796  ***      0      0      0   if (not $dbh and $EVAL_ERROR)
1798  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/)
1802  ***      0      0      0   if (not $tries)
1824  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1841  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1851  ***      0      0      0   defined $_ ? :
1907  ***     50      0      2   if ($o->got('connect')) { }
1910  ***      0      0      0   if ($o->got('ask-pass') and not $o->got('password'))
1930  ***     50      2      0   if ($tree)
1931         100      1      1   $o->get('format') eq 'dump' ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
127   ***     66      2      0      2   $options and ref $options eq 'HASH'
146   ***     33      0      0      2   ref $rows eq 'ARRAY' and @$rows
160   ***     33      0      6      0   $$row{'table'} and $$row{'table'} =~ /\./
164   ***     33      0      0      2   $$row{'table'} and my($id) = $$row{'table'} =~ /^<union(\d+)/
182   ***     66      0      2      2   $last_id != $$row{'id'} and $union_for{$$row{'id'}}
237   ***      0      0      0      0   $end < @rows and $rows[$end]{'id'} >= $der_id
273   ***     33      4      0      0   $$first{'Extra'} =~ /Using filesort/ and $$first{'type'} =~ /^(?:system|const)$/
308   ***      0      0      0      0   $end < @rows and $rows[$end]{'id'} >= $$row{'id'}
425   ***     66      0      2      6   $$row{'id'} and $$row{'id'} == $id
624   ***     33      0      0      2   $$row{'table'} && $$row{'table'} =~ /^(derived|union)\(/
640   ***      0      0      0      0   $$self{'clustered'} and $$row{'key'}
      ***      0      0      0      0   $$self{'clustered'} and $$row{'key'} and $$row{'key'} eq 'PRIMARY'
914   ***     66     10     22      0   $type and $type eq 'd'
      ***     33     32      0      0   $type and $type eq 'd' and not $$self{'dp'}
919          100     10     20      2   $type and $type =~ /[HhAadzm]/
1073  ***     33      0      2      0   @ARGV and $ARGV[0] eq '--config'
1102  ***     33      0      2      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
1109  ***     33      0      2      0   @ARGV and $$self{'strict'}
1193  ***     66      0     10     22   $opt and $$opt{'type'}
1196  ***     66     16      6      0   $val and $$opt{'type'} eq 'm'
      ***     66     16      6      0   $val and $$opt{'type'} eq 'd'
      ***     66     16      6      0   $val and $$opt{'type'} eq 'z'
      ***     66     16      6      0   defined $val and $$opt{'type'} eq 'h'
      ***     66     16      4      0   defined $val and $$opt{'type'} eq 'a'
1261  ***     33      0      0      6   $long and exists $$self{'opts'}{$long}
1269  ***     33      0      0     10   $long and exists $$self{'opts'}{$long}
1283  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1372  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1466  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1647  ***      0      0      0      0   not defined $final_props{$key} and defined $$prev{$key}
      ***      0      0      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1760  ***      0      0      0      0   not $dbh and $tries--
1796  ***      0      0      0      0   not $dbh and $EVAL_ERROR
1910  ***      0      0      0      0   $o->got('ask-pass') and not $o->got('password')

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
153          100      4      2   $$row{'Extra'} ||= ''
245   ***      0      0      0   $self->recursive_table_name($kids) || '<none>'
436          100      3      1   $prefix ||= ''
724   ***     50      2      0   $program_name ||= $PROGRAM_NAME
726   ***     50      2      0   $args{'prompt'} || '<options>'
      ***     50      0      2   $args{'dp'} || undef
768   ***     50      0      2   $file ||= '../mk-visual-explain'
904   ***     50     32      0   $$opt{'group'} ||= 'default'
1201  ***      0      0      0   $s || 's'
1238  ***      0      0      0   $pre || ''
1245  ***      0      0      0   $val || ''
1248  ***     50      2      0   $val || ''
1306  ***      0      0      0   $$self{'description'} || ''
1374  ***      0      0      0   $s ||= 's'
1400  ***      0      0      0   $$opt{'type'} || ''
1623  ***      0      0      0   $prev ||= {}
1624  ***      0      0      0   $defaults ||= {}
1702  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1717  ***      0      0      0   $self->prop('dbidriver') || ''
1721  ***      0      0      0   $$info{'D'} || ''
1727  ***      0      0      0   $$info{'D'} || ''
1749  ***      0      0      0   $opts ||= {}
1824  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1840  ***      0      0      0   $level ||= 0
1841  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
95           100      4     18     38   not $$row{$key} or $$row{$key} eq 'NULL'
640   ***     33      4      0      0   $$row{'Extra'} =~ /Using index/ or $$self{'clustered'} and $$row{'key'} and $$row{'key'} eq 'PRIMARY'
680   ***     33      0      4      0   $key || $$row{'key'}
1196  ***     33      0      0     22   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      2      0     20   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1740  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1741  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1742  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1743  ***      0      0      0      0   $$dsn{'u'} ||= $user
1744  ***      0      0      0      0   $$dsn{'D'} ||= $db


Covered Subroutines
-------------------

Subroutine           Count Location                                                         
-------------------- ----- -----------------------------------------------------------------
ALL                      2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:468 
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:115 
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:116 
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1541
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1542
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1546
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1547
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1550
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1552
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1873
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1874
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1875
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1879
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:22  
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:23  
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:35  
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:36  
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:707 
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:708 
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:710 
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:711 
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:712 
BEGIN                    1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:714 
__ANON__                 1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1097
_parse_specs             2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:868 
_pod_to_specs            2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:767 
_read_config_file        8 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1449
_set_option              1 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1043
_validate_type          32 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1192
bookmark_lookup          4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:639 
build_query_plan         6 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:196 
get                      6 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1259
get_defaults_files       2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:762 
get_opts                 2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1060
get_specs                2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:755 
got                     10 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1267
has                      2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1275
index                    4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:487 
index_access             4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:679 
index_of                 6 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:422 
load_options             4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:126 
main                     2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1882
new                      2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:119 
new                      2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1555
new                      2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:39  
new                      2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:719 
parse                    2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:67  
parse_tabular            8 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:43  
pretty_print             4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:435 
process                  2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:144 
recursive_table_name     4 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:554 
table                    2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:623 
transform                6 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:331 
usage_or_errors          2 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1316

Uncovered Subroutines
---------------------

Subroutine           Count Location                                                         
-------------------- ----- -----------------------------------------------------------------
_d                       0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1525
_d                       0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1850
_get_participants        0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:987 
as_string                0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1686
clone                    0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1502
const                    0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:507 
descr                    0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1305
disconnect               0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1833
eq_ref                   0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:492 
errors                   0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1295
filesort                 0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:652 
fill_in_dsn              0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1736
fulltext                 0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:477 
get_cxn_params           0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1714
get_dbh                  0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1748
get_defaults             0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1033
get_groups               0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1038
get_hostname             0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1823
index_merge              0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:536 
index_subquery           0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:526 
opt_values               0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1005
opts                     0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:999 
parse                    0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:136 
parse                    0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1617
parse_options            0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1673
parse_tab_sep            0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:52  
parse_vertical           0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:61  
print_active_handles     0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1839
print_errors             0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1329
print_usage              0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1339
prompt                   0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1300
prompt_noecho            0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1414
prop                     0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1608
range                    0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:482 
read_para_after          0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1483
recurse_index_merge      0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:580 
ref                      0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:497 
ref_or_null              0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:502 
save_error               0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1290
set                      0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1281
set_defaults             0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1021
short_opts               0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1015
system                   0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:512 
temporary                0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:660 
unique_subquery          0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:521 
usage                    0 /home/daniel/dev/maatkit/mk-visual-explain/mk-visual-explain:1695


