---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...lave-delay/mk-slave-delay   15.7    2.9    6.8   35.6    n/a  100.0   12.1
Total                          15.7    2.9    6.8   35.6    n/a  100.0   12.1
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:31:01 2010
Finish:       Thu Jan 28 22:31:01 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:31:02 2010
Finish:       Thu Jan 28 22:31:14 2010

Run:          ./102_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:31:17 2010
Finish:       Thu Jan 28 22:31:28 2010

/home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-slave-delay, a program that makes a MySQL slave lag its master.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Sergey Zhuravlev and Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22             2                    2            16   use strict;
               2                                  5   
               2                                 19   
23             2                    2            12   use warnings FATAL => 'all';
               2                                  5   
               2                                 16   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # OptionParser package 5266
31                                                    # ###########################################################################
32                                                    package OptionParser;
33                                                    
34             2                    2            14   use strict;
               2                                  5   
               2                                 11   
35             2                    2            13   use warnings FATAL => 'all';
               2                                  5   
               2                                 10   
36                                                    
37             2                    2            19   use Getopt::Long;
               2                                  8   
               2                                 14   
38             2                    2            15   use List::Util qw(max);
               2                                  6   
               2                                 23   
39             2                    2            13   use English qw(-no_match_vars);
               2                                  6   
               2                                 14   
40                                                    
41    ***      2            50      2            19   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  7   
               2                                 41   
42                                                    
43                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
44                                                    
45                                                    my %attributes = (
46                                                       'type'       => 1,
47                                                       'short form' => 1,
48                                                       'group'      => 1,
49                                                       'default'    => 1,
50                                                       'cumulative' => 1,
51                                                       'negatable'  => 1,
52                                                    );
53                                                    
54                                                    sub new {
55    ***      0                    0             0      my ( $class, %args ) = @_;
56    ***      0                                  0      foreach my $arg ( qw(description) ) {
57    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
58                                                       }
59    ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
60    ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
61    ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
62                                                    
63    ***      0      0      0                    0      my $self = {
      ***                    0                        
64                                                          description    => $args{description},
65                                                          prompt         => $args{prompt} || '<options>',
66                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
67                                                          dp             => $args{dp}     || undef,
68                                                          program_name   => $program_name,
69                                                          opts           => {},
70                                                          got_opts       => 0,
71                                                          short_opts     => {},
72                                                          defaults       => {},
73                                                          groups         => {},
74                                                          allowed_groups => {},
75                                                          errors         => [],
76                                                          rules          => [],  # desc of rules for --help
77                                                          mutex          => [],  # rule: opts are mutually exclusive
78                                                          atleast1       => [],  # rule: at least one opt is required
79                                                          disables       => {},  # rule: opt disables other opts 
80                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
81                                                          default_files  => [
82                                                             "/etc/maatkit/maatkit.conf",
83                                                             "/etc/maatkit/$program_name.conf",
84                                                             "$home/.maatkit.conf",
85                                                             "$home/.$program_name.conf",
86                                                          ],
87                                                       };
88    ***      0                                  0      return bless $self, $class;
89                                                    }
90                                                    
91                                                    sub get_specs {
92    ***      0                    0             0      my ( $self, $file ) = @_;
93    ***      0                                  0      my @specs = $self->_pod_to_specs($file);
94    ***      0                                  0      $self->_parse_specs(@specs);
95    ***      0                                  0      return;
96                                                    }
97                                                    
98                                                    sub get_defaults_files {
99    ***      0                    0             0      my ( $self ) = @_;
100   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
101                                                   }
102                                                   
103                                                   sub _pod_to_specs {
104   ***      0                    0             0      my ( $self, $file ) = @_;
105   ***      0             0                    0      $file ||= __FILE__;
106   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
107                                                   
108   ***      0                                  0      my %types = (
109                                                         string => 's', # standard Getopt type
110                                                         'int'  => 'i', # standard Getopt type
111                                                         float  => 'f', # standard Getopt type
112                                                         Hash   => 'H', # hash, formed from a comma-separated list
113                                                         hash   => 'h', # hash as above, but only if a value is given
114                                                         Array  => 'A', # array, similar to Hash
115                                                         array  => 'a', # array, similar to hash
116                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
117                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
118                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
119                                                      );
120   ***      0                                  0      my @specs = ();
121   ***      0                                  0      my @rules = ();
122   ***      0                                  0      my $para;
123                                                   
124   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
125   ***      0                                  0      while ( $para = <$fh> ) {
126   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
127   ***      0                                  0         last;
128                                                      }
129                                                   
130   ***      0                                  0      while ( $para = <$fh> ) {
131   ***      0      0                           0         last if $para =~ m/^=over/;
132   ***      0                                  0         chomp $para;
133   ***      0                                  0         $para =~ s/\s+/ /g;
134   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
135   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
136   ***      0                                  0         push @rules, $para;
137                                                      }
138                                                   
139   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
140                                                   
141   ***      0                                  0      do {
142   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
143   ***      0                                  0            chomp $para;
144   ***      0                                  0            MKDEBUG && _d($para);
145   ***      0                                  0            my %attribs;
146                                                   
147   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
148                                                   
149   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
150   ***      0                                  0               $para =~ s/\s+\Z//g;
151   ***      0                                  0               %attribs = map {
152   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
153   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
154                                                                        unless $attributes{$attrib};
155   ***      0                                  0                     ($attrib, $val);
156                                                                  } split(/; /, $para);
157   ***      0      0                           0               if ( $attribs{'short form'} ) {
158   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
159                                                               }
160   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
161                                                            }
162                                                            else {
163   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
164                                                            }
165                                                   
166   ***      0                                  0            $para =~ s/\s+\Z//g;
167   ***      0                                  0            $para =~ s/\s+/ /g;
168   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
169                                                   
170   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
171   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
172                                                   
173   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
174                                                   
175   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
176   ***      0                                  0               $option = $base_option;
177   ***      0                                  0               $attribs{'negatable'} = 1;
178                                                            }
179                                                   
180   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
181                                                               spec  => $option
182                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
183                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
184                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
185                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
186                                                               desc  => $para
187                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
188                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
189                                                            };
190                                                         }
191   ***      0                                  0         while ( $para = <$fh> ) {
192   ***      0      0                           0            last unless $para;
193                                                   
194                                                   
195   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
196   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
197   ***      0                                  0               last;
198                                                            }
199   ***      0      0                           0            last if $para =~ m/^=item --/;
200                                                         }
201                                                      } while ( $para );
202                                                   
203   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
204                                                   
205   ***      0                                  0      close $fh;
206   ***      0                                  0      return @specs, @rules;
207                                                   }
208                                                   
209                                                   sub _parse_specs {
210   ***      0                    0             0      my ( $self, @specs ) = @_;
211   ***      0                                  0      my %disables; # special rule that requires deferred checking
212                                                   
213   ***      0                                  0      foreach my $opt ( @specs ) {
214   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
215                                                            MKDEBUG && _d('Parsing opt spec:',
216   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
217                                                   
218   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
219   ***      0      0                           0            if ( !$long ) {
220   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
221                                                            }
222   ***      0                                  0            $opt->{long} = $long;
223                                                   
224   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
225   ***      0                                  0            $self->{opts}->{$long} = $opt;
226                                                   
227   ***      0      0                           0            if ( length $long == 1 ) {
228   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
229   ***      0                                  0               $self->{short_opts}->{$long} = $long;
230                                                            }
231                                                   
232   ***      0      0                           0            if ( $short ) {
233   ***      0      0                           0               die "Duplicate short option -$short"
234                                                                  if exists $self->{short_opts}->{$short};
235   ***      0                                  0               $self->{short_opts}->{$short} = $long;
236   ***      0                                  0               $opt->{short} = $short;
237                                                            }
238                                                            else {
239   ***      0                                  0               $opt->{short} = undef;
240                                                            }
241                                                   
242   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
243   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
244   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
245                                                   
246   ***      0             0                    0            $opt->{group} ||= 'default';
247   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
248                                                   
249   ***      0                                  0            $opt->{value} = undef;
250   ***      0                                  0            $opt->{got}   = 0;
251                                                   
252   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
253   ***      0                                  0            $opt->{type} = $type;
254   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
255                                                   
256   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
257   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
258                                                                  . "was given when this OptionParser object was created";
259                                                            }
260                                                   
261   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
262                                                   
263   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
264   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
265   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
266                                                            }
267                                                   
268   ***      0      0                           0            if ( $long eq 'config' ) {
269   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
270                                                            }
271                                                   
272   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
273   ***      0                                  0               $disables{$long} = $dis;
274   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
275                                                            }
276                                                   
277   ***      0                                  0            $self->{opts}->{$long} = $opt;
278                                                         }
279                                                         else { # It's an option rule, not a spec.
280   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
281   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
282   ***      0                                  0            my @participants = $self->_get_participants($opt);
283   ***      0                                  0            my $rule_ok = 0;
284                                                   
285   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
286   ***      0                                  0               $rule_ok = 1;
287   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
288   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
289                                                            }
290   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
291   ***      0                                  0               $rule_ok = 1;
292   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
293   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
294                                                            }
295   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
296   ***      0                                  0               $rule_ok = 1;
297   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
298   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
299                                                            }
300   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
301   ***      0                                  0               $rule_ok = 1;
302   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
303   ***      0                                  0               my @groups = split(',', $groups);
304   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
305   ***      0                                  0                  s/\s+//;
306   ***      0                                  0                  $_ => 1;
307                                                               } @groups;
308                                                            }
309                                                   
310   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
311                                                         }
312                                                      }
313                                                   
314   ***      0                                  0      foreach my $long ( keys %disables ) {
315   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
316   ***      0                                  0         $self->{disables}->{$long} = \@participants;
317   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
318                                                      }
319                                                   
320   ***      0                                  0      return; 
321                                                   }
322                                                   
323                                                   sub _get_participants {
324   ***      0                    0             0      my ( $self, $str ) = @_;
325   ***      0                                  0      my @participants;
326   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
327   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
328                                                            unless exists $self->{opts}->{$long};
329   ***      0                                  0         push @participants, $long;
330                                                      }
331   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
332   ***      0                                  0      return @participants;
333                                                   }
334                                                   
335                                                   sub opts {
336   ***      0                    0             0      my ( $self ) = @_;
337   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
338   ***      0                                  0      return %opts;
339                                                   }
340                                                   
341                                                   sub short_opts {
342   ***      0                    0             0      my ( $self ) = @_;
343   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
344   ***      0                                  0      return %short_opts;
345                                                   }
346                                                   
347                                                   sub set_defaults {
348   ***      0                    0             0      my ( $self, %defaults ) = @_;
349   ***      0                                  0      $self->{defaults} = {};
350   ***      0                                  0      foreach my $long ( keys %defaults ) {
351   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
352                                                            unless exists $self->{opts}->{$long};
353   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
354   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
355                                                      }
356   ***      0                                  0      return;
357                                                   }
358                                                   
359                                                   sub get_defaults {
360   ***      0                    0             0      my ( $self ) = @_;
361   ***      0                                  0      return $self->{defaults};
362                                                   }
363                                                   
364                                                   sub get_groups {
365   ***      0                    0             0      my ( $self ) = @_;
366   ***      0                                  0      return $self->{groups};
367                                                   }
368                                                   
369                                                   sub _set_option {
370   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
371   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
372                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
373                                                               : die "Getopt::Long gave a nonexistent option: $opt";
374                                                   
375   ***      0                                  0      $opt = $self->{opts}->{$long};
376   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
377   ***      0                                  0         $opt->{value}++;
378                                                      }
379                                                      else {
380   ***      0                                  0         $opt->{value} = $val;
381                                                      }
382   ***      0                                  0      $opt->{got} = 1;
383   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
384                                                   }
385                                                   
386                                                   sub get_opts {
387   ***      0                    0             0      my ( $self ) = @_; 
388                                                   
389   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
390   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
391   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
392                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
393                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
394                                                            : undef;
395                                                      }
396   ***      0                                  0      $self->{got_opts} = 0;
397                                                   
398   ***      0                                  0      $self->{errors} = [];
399                                                   
400   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
401   ***      0                                  0         shift @ARGV;
402   ***      0                                  0         $self->_set_option('config', shift @ARGV);
403                                                      }
404   ***      0      0                           0      if ( $self->has('config') ) {
405   ***      0                                  0         my @extra_args;
406   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
407   ***      0                                  0            eval {
408   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
409                                                            };
410   ***      0      0                           0            if ( $EVAL_ERROR ) {
411   ***      0      0                           0               if ( $self->got('config') ) {
412   ***      0                                  0                  die $EVAL_ERROR;
413                                                               }
414                                                               elsif ( MKDEBUG ) {
415                                                                  _d($EVAL_ERROR);
416                                                               }
417                                                            }
418                                                         }
419   ***      0                                  0         unshift @ARGV, @extra_args;
420                                                      }
421                                                   
422   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
423                                                      GetOptions(
424   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
425   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
426   ***      0      0                           0         values %{$self->{opts}}
427                                                      ) or $self->save_error('Error parsing options');
428                                                   
429   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
430   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
431                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
432                                                               or die "Cannot print: $OS_ERROR";
433   ***      0                                  0         exit 0;
434                                                      }
435                                                   
436   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
437   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
438                                                      }
439                                                   
440   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
441   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
442   ***      0      0                           0         if ( @set > 1 ) {
443   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
444   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
445                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
446                                                                    . ' are mutually exclusive.';
447   ***      0                                  0            $self->save_error($err);
448                                                         }
449                                                      }
450                                                   
451   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
452   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
453   ***      0      0                           0         if ( @set == 0 ) {
454   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
455   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
456                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
457   ***      0                                  0            $self->save_error("Specify at least one of $err");
458                                                         }
459                                                      }
460                                                   
461   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
462   ***      0                                  0         my $opt = $self->{opts}->{$long};
463   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
464   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
465   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
466   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
467   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
468                                                                  'because', $long,'disables them');
469                                                            }
470                                                   
471   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
472                                                   
473   ***      0                                  0               my @restricted_groups = grep {
474   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
475   ***      0                                  0               } keys %{$self->{groups}};
476                                                   
477   ***      0                                  0               my @restricted_opts;
478   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
479   ***      0                                  0                  RESTRICTED_OPT:
480   ***      0                                  0                  foreach my $restricted_opt (
481                                                                     keys %{$self->{groups}->{$restricted_group}} )
482                                                                  {
483   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
484   ***      0      0                           0                     push @restricted_opts, $restricted_opt
485                                                                        if $self->{opts}->{$restricted_opt}->{got};
486                                                                  }
487                                                               }
488                                                   
489   ***      0      0                           0               if ( @restricted_opts ) {
490   ***      0                                  0                  my $err;
491   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
492   ***      0                                  0                     $err = "--$restricted_opts[0]";
493                                                                  }
494                                                                  else {
495   ***      0                                  0                     $err = join(', ',
496   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
497   ***      0                                  0                               grep { $_ } 
498                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
499                                                                            )
500                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
501                                                                  }
502   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
503                                                               }
504                                                            }
505                                                   
506                                                         }
507                                                         elsif ( $opt->{is_required} ) { 
508   ***      0                                  0            $self->save_error("Required option --$long must be specified");
509                                                         }
510                                                   
511   ***      0                                  0         $self->_validate_type($opt);
512                                                      }
513                                                   
514   ***      0                                  0      $self->{got_opts} = 1;
515   ***      0                                  0      return;
516                                                   }
517                                                   
518                                                   sub _validate_type {
519   ***      0                    0             0      my ( $self, $opt ) = @_;
520   ***      0      0      0                    0      return unless $opt && $opt->{type};
521   ***      0                                  0      my $val = $opt->{value};
522                                                   
523   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
524   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
525   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
526   ***      0      0                           0         if ( !$suffix ) {
527   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
528   ***      0             0                    0            $suffix = $s || 's';
529   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
530                                                               $opt->{long}, '(value:', $val, ')');
531                                                         }
532   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
533   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
534                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
535                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
536                                                                 :                  $num * 86400;   # Days
537   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
538   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
539                                                         }
540                                                         else {
541   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
542                                                         }
543                                                      }
544                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
545   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
546   ***      0                                  0         my $prev = {};
547   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
548   ***      0      0                           0         if ( $from_key ) {
549   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
550   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
551                                                         }
552   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
553   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
554                                                      }
555                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
556   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
557   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
558   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
559   ***      0      0                           0         if ( defined $num ) {
560   ***      0      0                           0            if ( $factor ) {
561   ***      0                                  0               $num *= $factor_for{$factor};
562   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
563                                                                  'to num', $num, '* factor', $factor);
564                                                            }
565   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
566                                                         }
567                                                         else {
568   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
569                                                         }
570                                                      }
571                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
572   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
573                                                      }
574                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
575   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
576                                                      }
577                                                      else {
578   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
579                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
580                                                      }
581                                                   
582   ***      0                                  0      return;
583                                                   }
584                                                   
585                                                   sub get {
586   ***      0                    0             0      my ( $self, $opt ) = @_;
587   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
588   ***      0      0      0                    0      die "Option $opt does not exist"
589                                                         unless $long && exists $self->{opts}->{$long};
590   ***      0                                  0      return $self->{opts}->{$long}->{value};
591                                                   }
592                                                   
593                                                   sub got {
594   ***      0                    0             0      my ( $self, $opt ) = @_;
595   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
596   ***      0      0      0                    0      die "Option $opt does not exist"
597                                                         unless $long && exists $self->{opts}->{$long};
598   ***      0                                  0      return $self->{opts}->{$long}->{got};
599                                                   }
600                                                   
601                                                   sub has {
602   ***      0                    0             0      my ( $self, $opt ) = @_;
603   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
604   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
605                                                   }
606                                                   
607                                                   sub set {
608   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
609   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
610   ***      0      0      0                    0      die "Option $opt does not exist"
611                                                         unless $long && exists $self->{opts}->{$long};
612   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
613   ***      0                                  0      return;
614                                                   }
615                                                   
616                                                   sub save_error {
617   ***      0                    0             0      my ( $self, $error ) = @_;
618   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
619                                                   }
620                                                   
621                                                   sub errors {
622   ***      0                    0             0      my ( $self ) = @_;
623   ***      0                                  0      return $self->{errors};
624                                                   }
625                                                   
626                                                   sub prompt {
627   ***      0                    0             0      my ( $self ) = @_;
628   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
629                                                   }
630                                                   
631                                                   sub descr {
632   ***      0                    0             0      my ( $self ) = @_;
633   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
634                                                                 . "  For more details, please use the --help option, "
635                                                                 . "or try 'perldoc $PROGRAM_NAME' "
636                                                                 . "for complete documentation.";
637   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
638   ***      0                                  0      $descr =~ s/ +$//mg;
639   ***      0                                  0      return $descr;
640                                                   }
641                                                   
642                                                   sub usage_or_errors {
643   ***      0                    0             0      my ( $self ) = @_;
644   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
645   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
646   ***      0                                  0         exit 0;
647                                                      }
648                                                      elsif ( scalar @{$self->{errors}} ) {
649   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
650   ***      0                                  0         exit 0;
651                                                      }
652   ***      0                                  0      return;
653                                                   }
654                                                   
655                                                   sub print_errors {
656   ***      0                    0             0      my ( $self ) = @_;
657   ***      0                                  0      my $usage = $self->prompt() . "\n";
658   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
659   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
660                                                                 . "\n";
661                                                      }
662   ***      0                                  0      return $usage . "\n" . $self->descr();
663                                                   }
664                                                   
665                                                   sub print_usage {
666   ***      0                    0             0      my ( $self ) = @_;
667   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
668   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
669                                                   
670   ***      0      0                           0      my $maxl = max(
671   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
672                                                         @opts);
673                                                   
674   ***      0      0                           0      my $maxs = max(0,
675   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
676   ***      0                                  0         values %{$self->{short_opts}});
677                                                   
678   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
679   ***      0                                  0      my $rcol = 80 - $lcol - 6;
680   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
681                                                   
682   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
683                                                   
684   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
685                                                   
686   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
687   ***      0                                  0      push @groups, 'default';
688                                                   
689   ***      0                                  0      foreach my $group ( reverse @groups ) {
690   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
691   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
692   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
693                                                            grep { $_->{group} eq $group }
694                                                            @opts )
695                                                         {
696   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
697   ***      0                                  0            my $short = $opt->{short};
698   ***      0                                  0            my $desc  = $opt->{desc};
699   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
700   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
701   ***      0             0                    0               $s    ||= 's';
702   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
703   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
704                                                                      . "d=days; if no suffix, $s is used.";
705                                                            }
706   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
707   ***      0                                  0            $desc =~ s/ +$//mg;
708   ***      0      0                           0            if ( $short ) {
709   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
710                                                            }
711                                                            else {
712   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
713                                                            }
714                                                         }
715                                                      }
716                                                   
717   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
718   ***      0                                  0         $usage .= "\nRules:\n\n";
719   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
720                                                      }
721   ***      0      0                           0      if ( $self->{dp} ) {
722   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
723                                                      }
724   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
725   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
726   ***      0                                  0         my $val   = $opt->{value};
727   ***      0             0                    0         my $type  = $opt->{type} || '';
728   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
729   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
730                                                                   : !defined $val             ? '(No value)'
731                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
732                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
733                                                                   : $type =~ m/A|a/           ? join(',', @$val)
734                                                                   :                             $val;
735   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
736                                                      }
737   ***      0                                  0      return $usage;
738                                                   }
739                                                   
740                                                   sub prompt_noecho {
741   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
742   ***      0                                  0      my ( $prompt ) = @_;
743   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
744   ***      0      0                           0      print $prompt
745                                                         or die "Cannot print: $OS_ERROR";
746   ***      0                                  0      my $response;
747   ***      0                                  0      eval {
748   ***      0                                  0         require Term::ReadKey;
749   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
750   ***      0                                  0         chomp($response = <STDIN>);
751   ***      0                                  0         Term::ReadKey::ReadMode('normal');
752   ***      0      0                           0         print "\n"
753                                                            or die "Cannot print: $OS_ERROR";
754                                                      };
755   ***      0      0                           0      if ( $EVAL_ERROR ) {
756   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
757                                                      }
758   ***      0                                  0      return $response;
759                                                   }
760                                                   
761                                                   if ( MKDEBUG ) {
762                                                      print '# ', $^X, ' ', $], "\n";
763                                                      my $uname = `uname -a`;
764                                                      if ( $uname ) {
765                                                         $uname =~ s/\s+/ /g;
766                                                         print "# $uname\n";
767                                                      }
768                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
769                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
770                                                         ($main::SVN_REV || ''), __LINE__);
771                                                      print('# Arguments: ',
772                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
773                                                   }
774                                                   
775                                                   sub _read_config_file {
776   ***      0                    0             0      my ( $self, $filename ) = @_;
777   ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
778   ***      0                                  0      my @args;
779   ***      0                                  0      my $prefix = '--';
780   ***      0                                  0      my $parse  = 1;
781                                                   
782                                                      LINE:
783   ***      0                                  0      while ( my $line = <$fh> ) {
784   ***      0                                  0         chomp $line;
785   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
786   ***      0                                  0         $line =~ s/\s+#.*$//g;
787   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
788   ***      0      0                           0         if ( $line eq '--' ) {
789   ***      0                                  0            $prefix = '';
790   ***      0                                  0            $parse  = 0;
791   ***      0                                  0            next LINE;
792                                                         }
793   ***      0      0      0                    0         if ( $parse
      ***             0                               
794                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
795                                                         ) {
796   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
797                                                         }
798                                                         elsif ( $line =~ m/./ ) {
799   ***      0                                  0            push @args, $line;
800                                                         }
801                                                         else {
802   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
803                                                         }
804                                                      }
805   ***      0                                  0      close $fh;
806   ***      0                                  0      return @args;
807                                                   }
808                                                   
809                                                   sub read_para_after {
810   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
811   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
812   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
813   ***      0                                  0      my $para;
814   ***      0                                  0      while ( $para = <$fh> ) {
815   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
816   ***      0                                  0         last;
817                                                      }
818   ***      0                                  0      while ( $para = <$fh> ) {
819   ***      0      0                           0         next unless $para =~ m/$regex/;
820   ***      0                                  0         last;
821                                                      }
822   ***      0                                  0      $para = <$fh>;
823   ***      0                                  0      chomp($para);
824   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
825   ***      0                                  0      return $para;
826                                                   }
827                                                   
828                                                   sub clone {
829   ***      0                    0             0      my ( $self ) = @_;
830                                                   
831   ***      0                                  0      my %clone = map {
832   ***      0                                  0         my $hashref  = $self->{$_};
833   ***      0                                  0         my $val_copy = {};
834   ***      0                                  0         foreach my $key ( keys %$hashref ) {
835   ***      0                                  0            my $ref = ref $hashref->{$key};
836   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
837   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
838   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
839                                                                              : $hashref->{$key};
840                                                         }
841   ***      0                                  0         $_ => $val_copy;
842                                                      } qw(opts short_opts defaults);
843                                                   
844   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
845   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
846                                                      }
847                                                   
848   ***      0                                  0      return bless \%clone;     
849                                                   }
850                                                   
851                                                   sub _d {
852   ***      0                    0             0      my ($package, undef, $line) = caller 0;
853   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
854   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
855                                                           @_;
856   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
857                                                   }
858                                                   
859                                                   1;
860                                                   
861                                                   # ###########################################################################
862                                                   # End OptionParser package
863                                                   # ###########################################################################
864                                                   
865                                                   # ###########################################################################
866                                                   # VersionParser package 5266
867                                                   # ###########################################################################
868                                                   package VersionParser;
869                                                   
870            2                    2            30   use strict;
               2                                  6   
               2                                 19   
871            2                    2            16   use warnings FATAL => 'all';
               2                                  7   
               2                                 16   
872                                                   
873            2                    2            18   use English qw(-no_match_vars);
               2                                  6   
               2                                 13   
874                                                   
875   ***      2            50      2            16   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  5   
               2                                 57   
876                                                   
877                                                   sub new {
878   ***      0                    0             0      my ( $class ) = @_;
879   ***      0                                  0      bless {}, $class;
880                                                   }
881                                                   
882                                                   sub parse {
883   ***      0                    0             0      my ( $self, $str ) = @_;
884   ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
885   ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
886   ***      0                                  0      return $result;
887                                                   }
888                                                   
889                                                   sub version_ge {
890   ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
891   ***      0      0                           0      if ( !$self->{$dbh} ) {
892   ***      0                                  0         $self->{$dbh} = $self->parse(
893                                                            $dbh->selectrow_array('SELECT VERSION()'));
894                                                      }
895   ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
896   ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
897   ***      0                                  0      return $result;
898                                                   }
899                                                   
900                                                   sub _d {
901   ***      0                    0             0      my ($package, undef, $line) = caller 0;
902   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
903   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
904                                                           @_;
905   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
906                                                   }
907                                                   
908                                                   1;
909                                                   
910                                                   # ###########################################################################
911                                                   # End VersionParser package
912                                                   # ###########################################################################
913                                                   
914                                                   # ###########################################################################
915                                                   # DSNParser package 5266
916                                                   # ###########################################################################
917                                                   package DSNParser;
918                                                   
919            2                    2            15   use strict;
               2                                  7   
               2                                 16   
920            2                    2            12   use warnings FATAL => 'all';
               2                                  9   
               2                                 12   
921            2                    2            12   use English qw(-no_match_vars);
               2                                  5   
               2                                 16   
922            2                    2            22   use Data::Dumper;
               2                                  4   
               2                                 27   
923                                                   $Data::Dumper::Indent    = 0;
924                                                   $Data::Dumper::Quotekeys = 0;
925                                                   
926                                                   eval {
927                                                      require DBI;
928                                                   };
929                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
930                                                   
931   ***      2            50      2            16   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  4   
               2                                 35   
932                                                   
933                                                   sub new {
934            2                    2            13      my ( $class, @opts ) = @_;
935            2                                188      my $self = {
936                                                         opts => {
937                                                            A => {
938                                                               desc => 'Default character set',
939                                                               dsn  => 'charset',
940                                                               copy => 1,
941                                                            },
942                                                            D => {
943                                                               desc => 'Database to use',
944                                                               dsn  => 'database',
945                                                               copy => 1,
946                                                            },
947                                                            F => {
948                                                               desc => 'Only read default options from the given file',
949                                                               dsn  => 'mysql_read_default_file',
950                                                               copy => 1,
951                                                            },
952                                                            h => {
953                                                               desc => 'Connect to host',
954                                                               dsn  => 'host',
955                                                               copy => 1,
956                                                            },
957                                                            p => {
958                                                               desc => 'Password to use when connecting',
959                                                               dsn  => 'password',
960                                                               copy => 1,
961                                                            },
962                                                            P => {
963                                                               desc => 'Port number to use for connection',
964                                                               dsn  => 'port',
965                                                               copy => 1,
966                                                            },
967                                                            S => {
968                                                               desc => 'Socket file to use for connection',
969                                                               dsn  => 'mysql_socket',
970                                                               copy => 1,
971                                                            },
972                                                            u => {
973                                                               desc => 'User for login if not current user',
974                                                               dsn  => 'user',
975                                                               copy => 1,
976                                                            },
977                                                         },
978                                                      };
979            2                                 10      foreach my $opt ( @opts ) {
980   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
981   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
982                                                      }
983            2                                 29      return bless $self, $class;
984                                                   }
985                                                   
986                                                   sub prop {
987           12                   12            60      my ( $self, $prop, $value ) = @_;
988   ***     12     50                          59      if ( @_ > 2 ) {
989   ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
990   ***      0                                  0         $self->{$prop} = $value;
991                                                      }
992           12                                 95      return $self->{$prop};
993                                                   }
994                                                   
995                                                   sub parse {
996            4                    4           197      my ( $self, $dsn, $prev, $defaults ) = @_;
997   ***      4     50                          22      if ( !$dsn ) {
998   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
999   ***      0                                  0         return;
1000                                                     }
1001           4                                 11      MKDEBUG && _d('Parsing', $dsn);
1002  ***      4            50                   22      $prev     ||= {};
1003  ***      4            50                   21      $defaults ||= {};
1004           4                                 11      my %given_props;
1005           4                                 12      my %final_props;
1006           4                                 14      my %opts = %{$self->{opts}};
               4                                 51   
1007                                                  
1008           4                                 39      foreach my $dsn_part ( split(/,/, $dsn) ) {
1009  ***     16     50                         141         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1010          16                                 72            $given_props{$prop_key} = $prop_val;
1011                                                        }
1012                                                        else {
1013  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1014  ***      0                                  0            $given_props{h} = $dsn_part;
1015                                                        }
1016                                                     }
1017                                                  
1018           4                                 23      foreach my $key ( keys %opts ) {
1019          32                                 96         MKDEBUG && _d('Finding value for', $key);
1020          32                                107         $final_props{$key} = $given_props{$key};
1021  ***     32     50     66                  264         if (   !defined $final_props{$key}
      ***                   33                        
1022                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1023                                                        {
1024  ***      0                                  0            $final_props{$key} = $prev->{$key};
1025  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1026                                                        }
1027          32    100                         135         if ( !defined $final_props{$key} ) {
1028          16                                 53            $final_props{$key} = $defaults->{$key};
1029          16                                 43            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1030                                                        }
1031                                                     }
1032                                                  
1033           4                                 24      foreach my $key ( keys %given_props ) {
1034  ***     16     50                          70         die "Unrecognized DSN part '$key' in '$dsn'\n"
1035                                                           unless exists $opts{$key};
1036                                                     }
1037  ***      4     50                          22      if ( (my $required = $self->prop('required')) ) {
1038  ***      0                                  0         foreach my $key ( keys %$required ) {
1039  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1040                                                        }
1041                                                     }
1042                                                  
1043           4                                 32      return \%final_props;
1044                                                  }
1045                                                  
1046                                                  sub parse_options {
1047  ***      0                    0             0      my ( $self, $o ) = @_;
1048  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1049  ***      0                                  0      my $dsn_string
1050                                                        = join(',',
1051  ***      0      0                           0             map  { "$_=".$o->get($_); }
1052  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1053  ***      0                                  0             keys %{$self->{opts}}
1054                                                          );
1055  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1056  ***      0                                  0      return $self->parse($dsn_string);
1057                                                  }
1058                                                  
1059                                                  sub as_string {
1060  ***      0                    0             0      my ( $self, $dsn ) = @_;
1061  ***      0      0                           0      return $dsn unless ref $dsn;
1062  ***      0      0                           0      return join(',',
1063  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1064  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1065                                                        sort keys %$dsn );
1066                                                  }
1067                                                  
1068                                                  sub usage {
1069  ***      0                    0             0      my ( $self ) = @_;
1070  ***      0                                  0      my $usage
1071                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1072                                                        . "  KEY  COPY  MEANING\n"
1073                                                        . "  ===  ====  =============================================\n";
1074  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1075  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1076  ***      0      0      0                    0         $usage .= "  $key    "
1077                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1078                                                               .  ($opts{$key}->{desc} || '[No description]')
1079                                                               . "\n";
1080                                                     }
1081  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1082  ***      0                                  0      return $usage;
1083                                                  }
1084                                                  
1085                                                  sub get_cxn_params {
1086           4                    4            55      my ( $self, $info ) = @_;
1087           4                                 13      my $dsn;
1088           4                                 12      my %opts = %{$self->{opts}};
               4                                 34   
1089  ***      4            50                   21      my $driver = $self->prop('dbidriver') || '';
1090  ***      4     50                          22      if ( $driver eq 'Pg' ) {
1091  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1092  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1093  ***      0             0                    0                        grep { defined $info->{$_} }
1094                                                                       qw(h P));
1095                                                     }
1096                                                     else {
1097           8                                 60         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1098          20                                 76            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1099  ***      4            50                   52                        grep { defined $info->{$_} }
1100                                                                       qw(F h P S A))
1101                                                           . ';mysql_read_default_group=client';
1102                                                     }
1103           4                                 12      MKDEBUG && _d($dsn);
1104           4                                 35      return ($dsn, $info->{u}, $info->{p});
1105                                                  }
1106                                                  
1107                                                  sub fill_in_dsn {
1108  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1109  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1110  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1111  ***      0                                  0      $user =~ s/@.*//;
1112  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1113  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1114  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1115  ***      0             0                    0      $dsn->{u} ||= $user;
1116  ***      0             0                    0      $dsn->{D} ||= $db;
1117                                                  }
1118                                                  
1119                                                  sub get_dbh {
1120           4                    4            25      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1121  ***      4            50                   20      $opts ||= {};
1122  ***      4     50                          43      my $defaults = {
1123                                                        AutoCommit         => 0,
1124                                                        RaiseError         => 1,
1125                                                        PrintError         => 0,
1126                                                        ShowErrorStatement => 1,
1127                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1128                                                     };
1129           4                                 21      @{$defaults}{ keys %$opts } = values %$opts;
               4                                 17   
1130                                                  
1131  ***      4     50                          19      if ( !$have_dbi ) {
1132  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1133                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1134                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1135                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1136                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1137                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1138                                                  
1139                                                     }
1140                                                  
1141           4                                 11      my $dbh;
1142           4                                 11      my $tries = 2;
1143  ***      4            66                   44      while ( !$dbh && $tries-- ) {
1144                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1145           4                                 10            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1146                                                  
1147           4                                 10         eval {
1148           4                                 32            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1149                                                  
1150  ***      4     50                          58            if ( $cxn_string =~ m/mysql/i ) {
1151           4                                 16               my $sql;
1152                                                  
1153           4                                 17               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1154                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1155           4                                  8               MKDEBUG && _d($dbh, ':', $sql);
1156           4                                429               $dbh->do($sql);
1157                                                  
1158  ***      4     50                          41               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1159  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1160  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1161  ***      0                                  0                  $dbh->do($sql);
1162  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1163  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1164  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1165                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1166                                                                 }
1167                                                                 else {
1168  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1169                                                                 }
1170                                                              }
1171                                                  
1172  ***      4     50                          31               if ( $self->prop('set-vars') ) {
1173  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1174  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1175  ***      0                                  0                  $dbh->do($sql);
1176                                                              }
1177                                                           }
1178                                                        };
1179  ***      4     50     33                   48         if ( !$dbh && $EVAL_ERROR ) {
1180  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1181  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1182  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1183  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1184                                                           }
1185                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1186  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1187                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1188                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1189                                                                 . "DBD::mysql is not installed, try:\n"
1190                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1191                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1192                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1193                                                           }
1194  ***      0      0                           0            if ( !$tries ) {
1195  ***      0                                  0               die $EVAL_ERROR;
1196                                                           }
1197                                                        }
1198                                                     }
1199                                                  
1200           4                                 13      MKDEBUG && _d('DBH info: ',
1201                                                        $dbh,
1202                                                        Dumper($dbh->selectrow_hashref(
1203                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1204                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1205                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1206                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1207                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1208                                                        '$DBI::VERSION:',        $DBI::VERSION,
1209                                                     );
1210                                                  
1211           4                                 30      return $dbh;
1212                                                  }
1213                                                  
1214                                                  sub get_hostname {
1215  ***      0                    0                    my ( $self, $dbh ) = @_;
1216  ***      0      0      0                           if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1217  ***      0                                            return $host;
1218                                                     }
1219  ***      0                                         my ( $hostname, $one ) = $dbh->selectrow_array(
1220                                                        'SELECT /*!50038 @@hostname, */ 1');
1221  ***      0                                         return $hostname;
1222                                                  }
1223                                                  
1224                                                  sub disconnect {
1225  ***      0                    0                    my ( $self, $dbh ) = @_;
1226  ***      0                                         MKDEBUG && $self->print_active_handles($dbh);
1227  ***      0                                         $dbh->disconnect;
1228                                                  }
1229                                                  
1230                                                  sub print_active_handles {
1231  ***      0                    0                    my ( $self, $thing, $level ) = @_;
1232  ***      0             0                           $level ||= 0;
1233  ***      0      0      0                           printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1234                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1235                                                        or die "Cannot print: $OS_ERROR";
1236  ***      0                                         foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                      
      ***      0                                      
1237  ***      0                                            $self->print_active_handles( $handle, $level + 1 );
1238                                                     }
1239                                                  }
1240                                                  
1241                                                  sub copy {
1242  ***      0                    0                    my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1243  ***      0      0                                  die 'I need a dsn_1 argument' unless $dsn_1;
1244  ***      0      0                                  die 'I need a dsn_2 argument' unless $dsn_2;
1245  ***      0                                         my %new_dsn = map {
1246  ***      0                                            my $key = $_;
1247  ***      0                                            my $val;
1248  ***      0      0                                     if ( $args{overwrite} ) {
1249  ***      0      0                                        $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1250                                                        }
1251                                                        else {
1252  ***      0      0                                        $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1253                                                        }
1254  ***      0                                            $key => $val;
1255  ***      0                                         } keys %{$self->{opts}};
1256  ***      0                                         return \%new_dsn;
1257                                                  }
1258                                                  
1259                                                  sub _d {
1260  ***      0                    0                    my ($package, undef, $line) = caller 0;
1261  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1262  ***      0                                              map { defined $_ ? $_ : 'undef' }
1263                                                          @_;
1264  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1265                                                  }
1266                                                  
1267                                                  1;
1268                                                  
1269                                                  # ###########################################################################
1270                                                  # End DSNParser package
1271                                                  # ###########################################################################
1272                                                  
1273                                                  # ###########################################################################
1274                                                  # Daemon package 5266
1275                                                  # ###########################################################################
1276                                                  
1277                                                  package Daemon;
1278                                                  
1279           2                    2            27   use strict;
               2                                  6   
               2                                 23   
1280           2                    2            13   use warnings FATAL => 'all';
               2                                 10   
               2                                 15   
1281                                                  
1282           2                    2            14   use POSIX qw(setsid);
               2                                  6   
               2                                 14   
1283           2                    2            34   use English qw(-no_match_vars);
               2                                  5   
               2                                 14   
1284                                                  
1285  ***      2            50      2            22   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  6   
               2                                 37   
1286                                                  
1287                                                  sub new {
1288  ***      0                    0                    my ( $class, %args ) = @_;
1289  ***      0                                         foreach my $arg ( qw(o) ) {
1290  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1291                                                     }
1292  ***      0                                         my $o = $args{o};
1293  ***      0      0                                  my $self = {
      ***             0                               
1294                                                        o        => $o,
1295                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1296                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1297                                                     };
1298                                                  
1299  ***      0                                         check_PID_file(undef, $self->{PID_file});
1300                                                  
1301  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1302  ***      0                                         return bless $self, $class;
1303                                                  }
1304                                                  
1305                                                  sub daemonize {
1306  ***      0                    0                    my ( $self ) = @_;
1307                                                  
1308  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
1309  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1310  ***      0      0                                  if ( $pid ) {
1311  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
1312  ***      0                                            exit;
1313                                                     }
1314                                                  
1315  ***      0                                         $self->{child} = 1;
1316                                                  
1317  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1318  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1319                                                  
1320  ***      0                                         $self->_make_PID_file();
1321                                                  
1322  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
1323                                                  
1324  ***      0      0                                  if ( -t STDIN ) {
1325  ***      0                                            close STDIN;
1326  ***      0      0                                     open  STDIN, '/dev/null'
1327                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1328                                                     }
1329                                                  
1330  ***      0      0                                  if ( $self->{log_file} ) {
1331  ***      0                                            close STDOUT;
1332  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
1333                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1334                                                  
1335  ***      0                                            close STDERR;
1336  ***      0      0                                     open  STDERR, ">&STDOUT"
1337                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1338                                                     }
1339                                                     else {
1340  ***      0      0                                     if ( -t STDOUT ) {
1341  ***      0                                               close STDOUT;
1342  ***      0      0                                        open  STDOUT, '>', '/dev/null'
1343                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1344                                                        }
1345  ***      0      0                                     if ( -t STDERR ) {
1346  ***      0                                               close STDERR;
1347  ***      0      0                                        open  STDERR, '>', '/dev/null'
1348                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1349                                                        }
1350                                                     }
1351                                                  
1352  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
1353  ***      0                                         return;
1354                                                  }
1355                                                  
1356                                                  sub check_PID_file {
1357  ***      0                    0                    my ( $self, $file ) = @_;
1358  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
1359  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
1360  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
1361  ***      0                                            my $pid;
1362  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
1363  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1364  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
1365  ***      0      0                                     if ( $pid ) {
1366  ***      0                                               my $pid_is_alive = kill 0, $pid;
1367  ***      0      0                                        if ( $pid_is_alive ) {
1368  ***      0                                                  die "The PID file $PID_file already exists "
1369                                                                 . " and the PID that it contains, $pid, is running";
1370                                                           }
1371                                                           else {
1372  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
1373                                                                 . "contains, $pid, is not running";
1374                                                           }
1375                                                        }
1376                                                        else {
1377  ***      0                                               die "The PID file $PID_file already exists but it does not "
1378                                                              . "contain a PID";
1379                                                        }
1380                                                     }
1381                                                     else {
1382  ***      0                                            MKDEBUG && _d('No PID file');
1383                                                     }
1384  ***      0                                         return;
1385                                                  }
1386                                                  
1387                                                  sub make_PID_file {
1388  ***      0                    0                    my ( $self ) = @_;
1389  ***      0      0                                  if ( exists $self->{child} ) {
1390  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
1391                                                     }
1392  ***      0                                         $self->_make_PID_file();
1393  ***      0                                         $self->{rm_PID_file} = 1;
1394  ***      0                                         return;
1395                                                  }
1396                                                  
1397                                                  sub _make_PID_file {
1398  ***      0                    0                    my ( $self ) = @_;
1399                                                  
1400  ***      0                                         my $PID_file = $self->{PID_file};
1401  ***      0      0                                  if ( !$PID_file ) {
1402  ***      0                                            MKDEBUG && _d('No PID file to create');
1403  ***      0                                            return;
1404                                                     }
1405                                                  
1406  ***      0                                         $self->check_PID_file();
1407                                                  
1408  ***      0      0                                  open my $PID_FH, '>', $PID_file
1409                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1410  ***      0      0                                  print $PID_FH $PID
1411                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1412  ***      0      0                                  close $PID_FH
1413                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1414                                                  
1415  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
1416  ***      0                                         return;
1417                                                  }
1418                                                  
1419                                                  sub _remove_PID_file {
1420  ***      0                    0                    my ( $self ) = @_;
1421  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
1422  ***      0      0                                     unlink $self->{PID_file}
1423                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1424  ***      0                                            MKDEBUG && _d('Removed PID file');
1425                                                     }
1426                                                     else {
1427  ***      0                                            MKDEBUG && _d('No PID to remove');
1428                                                     }
1429  ***      0                                         return;
1430                                                  }
1431                                                  
1432                                                  sub DESTROY {
1433  ***      0                    0                    my ( $self ) = @_;
1434  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1435  ***      0                                         return;
1436                                                  }
1437                                                  
1438                                                  sub _d {
1439  ***      0                    0                    my ($package, undef, $line) = caller 0;
1440  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1441  ***      0                                              map { defined $_ ? $_ : 'undef' }
1442                                                          @_;
1443  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1444                                                  }
1445                                                  
1446                                                  1;
1447                                                  
1448                                                  # ###########################################################################
1449                                                  # End Daemon package
1450                                                  # ###########################################################################
1451                                                  
1452                                                  # ###########################################################################
1453                                                  # Transformers package 5266
1454                                                  # ###########################################################################
1455                                                  
1456                                                  package Transformers;
1457                                                  
1458           2                    2            17   use strict;
               2                                  6   
               2                                 17   
1459           2                    2            14   use warnings FATAL => 'all';
               2                                  5   
               2                                 15   
1460           2                    2            13   use English qw(-no_match_vars);
               2                                  5   
               2                                 18   
1461           2                    2            29   use Time::Local qw(timegm timelocal);
               2                                  6   
               2                                 29   
1462           2                    2            16   use Digest::MD5 qw(md5_hex);
               2                                  5   
               2                                 15   
1463                                                  
1464  ***      2            50      2            14   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  4   
               2                                 28   
1465                                                  
1466                                                  require Exporter;
1467                                                  our @ISA         = qw(Exporter);
1468                                                  our %EXPORT_TAGS = ();
1469                                                  our @EXPORT      = ();
1470                                                  our @EXPORT_OK   = qw(
1471                                                     micro_t
1472                                                     percentage_of
1473                                                     secs_to_time
1474                                                     shorten
1475                                                     ts
1476                                                     parse_timestamp
1477                                                     unix_timestamp
1478                                                     any_unix_timestamp
1479                                                     make_checksum
1480                                                  );
1481                                                  
1482                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1483                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
1484                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1485                                                  
1486                                                  sub micro_t {
1487  ***      0                    0                    my ( $t, %args ) = @_;
1488  ***      0      0                                  my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1489  ***      0      0                                  my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1490  ***      0                                         my $f;
1491                                                  
1492  ***      0      0                                  $t = 0 if $t < 0;
1493                                                  
1494  ***      0      0                                  $t = sprintf('%.17f', $t) if $t =~ /e/;
1495                                                  
1496  ***      0                                         $t =~ s/\.(\d{1,6})\d*/\.$1/;
1497                                                  
1498  ***      0      0      0                           if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1499  ***      0                                            $f = ($t * 1000000) . 'us';
1500                                                     }
1501                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1502  ***      0                                            $f = sprintf("%.${p_ms}f", $t * 1000);
1503  ***      0                                            $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1504                                                     }
1505                                                     elsif ($t >= 1) {
1506  ***      0                                            $f = sprintf("%.${p_s}f", $t);
1507  ***      0                                            $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1508                                                     }
1509                                                     else {
1510  ***      0                                            $f = 0;  # $t should = 0 at this point
1511                                                     }
1512                                                  
1513  ***      0                                         return $f;
1514                                                  }
1515                                                  
1516                                                  sub percentage_of {
1517  ***      0                    0                    my ( $is, $of, %args ) = @_;
1518  ***      0             0                           my $p   = $args{p} || 0; # float precision
1519  ***      0      0                                  my $fmt = $p ? "%.${p}f" : "%d";
1520  ***      0             0                           return sprintf $fmt, ($is * 100) / ($of ||= 1);
1521                                                  }
1522                                                  
1523                                                  sub secs_to_time {
1524  ***      0                    0                    my ( $secs, $fmt ) = @_;
1525  ***      0             0                           $secs ||= 0;
1526  ***      0      0                                  return '00:00' unless $secs;
1527                                                  
1528  ***      0      0      0                           $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1529                                                            : $secs >= 3_600  ? 'h'
1530                                                            :                   'm';
1531                                                  
1532                                                     return
1533  ***      0      0                                     $fmt eq 'd' ? sprintf(
      ***             0                               
1534                                                           "%d+%02d:%02d:%02d",
1535                                                           int($secs / 86_400),
1536                                                           int(($secs % 86_400) / 3_600),
1537                                                           int(($secs % 3_600) / 60),
1538                                                           $secs % 60)
1539                                                        : $fmt eq 'h' ? sprintf(
1540                                                           "%02d:%02d:%02d",
1541                                                           int(($secs % 86_400) / 3_600),
1542                                                           int(($secs % 3_600) / 60),
1543                                                           $secs % 60)
1544                                                        : sprintf(
1545                                                           "%02d:%02d",
1546                                                           int(($secs % 3_600) / 60),
1547                                                           $secs % 60);
1548                                                  }
1549                                                  
1550                                                  sub shorten {
1551  ***      0                    0                    my ( $num, %args ) = @_;
1552  ***      0      0                                  my $p = defined $args{p} ? $args{p} : 2;     # float precision
1553  ***      0      0                                  my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1554  ***      0                                         my $n = 0;
1555  ***      0                                         my @units = ('', qw(k M G T P E Z Y));
1556  ***      0             0                           while ( $num >= $d && $n < @units - 1 ) {
1557  ***      0                                            $num /= $d;
1558  ***      0                                            ++$n;
1559                                                     }
1560  ***      0      0      0                           return sprintf(
1561                                                        $num =~ m/\./ || $n
1562                                                           ? "%.${p}f%s"
1563                                                           : '%d',
1564                                                        $num, $units[$n]);
1565                                                  }
1566                                                  
1567                                                  sub ts {
1568  ***      0                    0                    my ( $time, $gmt ) = @_;
1569  ***      0      0                                  my ( $sec, $min, $hour, $mday, $mon, $year )
1570                                                        = $gmt ? gmtime($time) : localtime($time);
1571  ***      0                                         $mon  += 1;
1572  ***      0                                         $year += 1900;
1573  ***      0                                         my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1574                                                        $year, $mon, $mday, $hour, $min, $sec);
1575  ***      0      0                                  if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
1576  ***      0                                            $us = sprintf("%.6f", $us);
1577  ***      0                                            $us =~ s/^0\././;
1578  ***      0                                            $val .= $us;
1579                                                     }
1580  ***      0                                         return $val;
1581                                                  }
1582                                                  
1583                                                  sub parse_timestamp {
1584  ***      0                    0                    my ( $val ) = @_;
1585  ***      0      0                                  if ( my($y, $m, $d, $h, $i, $s, $f)
1586                                                           = $val =~ m/^$mysql_ts$/ )
1587                                                     {
1588  ***      0      0                                     return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1589                                                                       . (defined $f ? '%02.6f' : '%02d'),
1590                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1591                                                     }
1592  ***      0                                         return $val;
1593                                                  }
1594                                                  
1595                                                  sub unix_timestamp {
1596  ***      0                    0                    my ( $val, $gmt ) = @_;
1597  ***      0      0                                  if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
1598  ***      0      0                                     $val = $gmt
1599                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
1600                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
1601  ***      0      0                                     if ( defined $us ) {
1602  ***      0                                               $us = sprintf('%.6f', $us);
1603  ***      0                                               $us =~ s/^0\././;
1604  ***      0                                               $val .= $us;
1605                                                        }
1606                                                     }
1607  ***      0                                         return $val;
1608                                                  }
1609                                                  
1610                                                  sub any_unix_timestamp {
1611  ***      0                    0                    my ( $val, $callback ) = @_;
1612                                                  
1613  ***      0      0                                  if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
1614  ***      0      0                                     $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1615                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1616                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1617                                                           : $suffix eq 'd' ? $n * 86400    # Days
1618                                                           :                  $n;           # default: Seconds
1619  ***      0                                            MKDEBUG && _d('ts is now - N[shmd]:', $n);
1620  ***      0                                            return time - $n;
1621                                                     }
1622                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
1623  ***      0                                            MKDEBUG && _d('ts is MySQL slow log timestamp');
1624  ***      0      0                                     $val .= ' 00:00:00' unless $hms;
1625  ***      0                                            return unix_timestamp(parse_timestamp($val));
1626                                                     }
1627                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
1628  ***      0                                            MKDEBUG && _d('ts is properly formatted timestamp');
1629  ***      0      0                                     $val .= ' 00:00:00' unless $hms;
1630  ***      0                                            return unix_timestamp($val);
1631                                                     }
1632                                                     else {
1633  ***      0                                            MKDEBUG && _d('ts is MySQL expression');
1634  ***      0      0      0                              return $callback->($val) if $callback && ref $callback eq 'CODE';
1635                                                     }
1636                                                  
1637  ***      0                                         MKDEBUG && _d('Unknown ts type:', $val);
1638  ***      0                                         return;
1639                                                  }
1640                                                  
1641                                                  sub make_checksum {
1642  ***      0                    0                    my ( $val ) = @_;
1643  ***      0                                         my $checksum = uc substr(md5_hex($val), -16);
1644  ***      0                                         MKDEBUG && _d($checksum, 'checksum for', $val);
1645  ***      0                                         return $checksum;
1646                                                  }
1647                                                  
1648                                                  sub _d {
1649  ***      0                    0                    my ($package, undef, $line) = caller 0;
1650  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1651  ***      0                                              map { defined $_ ? $_ : 'undef' }
1652                                                          @_;
1653  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1654                                                  }
1655                                                  
1656                                                  1;
1657                                                  
1658                                                  # ###########################################################################
1659                                                  # End Transformers package
1660                                                  # ###########################################################################
1661                                                  
1662                                                  # ###########################################################################
1663                                                  # This is a combination of modules and programs in one -- a runnable module.
1664                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1665                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1666                                                  #
1667                                                  # Check at the end of this package for the call to main() which actually runs
1668                                                  # the program.
1669                                                  # ###########################################################################
1670                                                  package mk_slave_delay;
1671                                                  
1672           2                    2            23   use English qw(-no_match_vars);
               2                                  6   
               2                                 19   
1673           2                    2            17   use List::Util qw(max);
               2                                  5   
               2                                 15   
1674           2                    2            27   use sigtrap qw(handler finish untrapped normal-signals);
               2                                  7   
               2                                 20   
1675                                                  
1676                                                  Transformers->import(qw(ts));
1677                                                  
1678  ***      2            50      2            16   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  4   
               2                                 31   
1679                                                  
1680                                                  my $now;
1681                                                  my $o;
1682                                                  my $oktorun = 1;
1683                                                  
1684                                                  sub main {
1685  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
1686                                                  
1687  ***      0                                         my $dp = new DSNParser();
1688  ***      0                                         my $vp = new VersionParser();
1689  ***      0                                         $o     = new OptionParser(
1690                                                        strict      => 0,
1691                                                        prompt      => '[OPTION]... SLAVE-HOST [MASTER-HOST]',
1692                                                        description => 'starts and stops a slave server as needed '
1693                                                                     . 'to make it lag behind the master.  The SLAVE-HOST '
1694                                                                     . 'and MASTER-HOST use DSN syntax, and values are copied '
1695                                                                     . 'from the SLAVE-HOST to the MASTER-HOST if omitted.',
1696                                                        dp          => $dp,
1697                                                     );
1698  ***      0                                         $o->get_specs();
1699  ***      0                                         $o->get_opts();
1700                                                  
1701  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
1702                                                  
1703  ***      0                                         my $dsn_defaults = $dp->parse_options($o);
1704  ***      0      0                                  my $slave_dsn  = @ARGV ? $dp->parse(shift @ARGV, $dsn_defaults)
1705                                                                            : $dsn_defaults;
1706  ***      0      0                                  my $master_dsn = $dp->parse(shift @ARGV, $slave_dsn, $dsn_defaults) if @ARGV;
1707                                                  
1708  ***      0      0                                  if ( !$o->got('help') ) {
1709  ***      0      0                                     if ( !$slave_dsn ) {
1710  ***      0                                               $o->save_error("Missing or invalid slave host");
1711                                                        }
1712                                                     }
1713                                                  
1714  ***      0                                         $o->set('interval', max($o->get('interval'), 1));
1715  ***      0      0                                  if ( $o->get('run-time') ) {
1716  ***      0                                            $o->set('run-time', max($o->get('run-time'), 1));
1717                                                     }
1718                                                  
1719  ***      0                                         $o->usage_or_errors();
1720                                                  
1721                                                     # #######################################################################
1722                                                     # Ready to work now.
1723                                                     # #######################################################################
1724  ***      0                                         my ( $TS, $FILE, $POS ) = ( 0, 1, 2 );
1725  ***      0                                         my @positions;
1726  ***      0                                         my $next_start = 0;
1727  ***      0                                         $now    = time();
1728  ***      0             0                           my $end = $now + ( $o->get('run-time') || 0 );    # When we should exit
1729                                                  
1730                                                     # Connect before daemonizing, in case --ask-pass is needed.
1731  ***      0                                         my ( $slave, $master );
1732  ***      0                                         $slave     = get_dbh($dp, $slave_dsn);
1733  ***      0                                         my $status = $slave->selectrow_hashref("SHOW SLAVE STATUS");
1734  ***      0      0      0                           if ( !$status || ! %$status ) {
1735  ***      0                                            die "No SLAVE STATUS found.\n";
1736                                                     }
1737                                                  
1738  ***      0      0      0                           if ( $master_dsn ) {
      ***             0                               
1739  ***      0                                            MKDEBUG && _d('Connecting to master via DSN from cmd-line');
1740  ***      0                                            $master = get_dbh($dp, $master_dsn);
1741                                                     }
1742                                                     elsif ( $o->get('use-master')
1743                                                             || $status->{slave_io_state} =~ m/free enough relay log/ )
1744                                                     {
1745                                                        # Try to connect to the slave's master just by looking at its
1746                                                        # SLAVE STATUS.
1747  ***      0                                            MKDEBUG && _d('The I/O thread is waiting, connecting to master');
1748  ***      0                                            my $spec = "h=$status->{master_host},P=$status->{master_port}";
1749  ***      0                                            $master  = get_dbh($dp, $dp->parse($spec, $slave_dsn));
1750                                                     }
1751                                                  
1752                                                     # Daemonize only after (potentially) asking for passwords for --ask-pass.
1753  ***      0                                         my $daemon;
1754  ***      0      0                                  if ( $o->get('daemonize') ) {
      ***             0                               
1755  ***      0                                            $daemon = new Daemon(o=>$o);
1756  ***      0                                            $daemon->daemonize();
1757  ***      0                                            MKDEBUG && _d('I am a daemon now');
1758                                                     }
1759                                                     elsif ( $o->get('pid') ) {
1760                                                        # We're not daemoninzing, it just handles PID stuff.
1761  ***      0                                            $daemon = new Daemon(o=>$o);
1762  ***      0                                            $daemon->make_PID_file();
1763                                                     }
1764                                                  
1765                                                     # If the I/O thread isn't running when the program starts,
1766                                                     # it never knows what to do.  So start it.
1767  ***      0                                         $slave->do('START SLAVE IO_THREAD');
1768                                                  
1769  ***      0             0                           while (                              # Quit if:
      ***                    0                        
1770                                                        (!$o->get('run-time') || $now < $end) # time is exceeded
1771                                                        && $oktorun                       # or instructed to quit
1772                                                     ) {
1773                                                  
1774  ***      0                                            $now = time();
1775                                                  
1776  ***      0                                            $status = $slave->selectrow_hashref("SHOW SLAVE STATUS");
1777  ***      0      0      0                              if ( !$status || ! %$status ) {
1778  ***      0                                               die "No SLAVE STATUS found.\n";
1779                                                        }
1780                                                  
1781  ***      0      0      0                              if ( !$master && $status->{slave_io_state} =~ m/free enough relay log/ ) {
1782  ***      0                                               MKDEBUG && _d("The I/O thread is stuck, connecting to master");
1783                                                           # If we're daemonized and --ask-pass is given, there's no way
1784                                                           # to ask for a password.
1785  ***      0      0      0                                 if ( $o->get('daemonize') && $o->get('ask-pass') ) {
1786  ***      0                                                  die "Cannot ask for password while daemonized";
1787                                                           }
1788  ***      0                                               my $spec = "h=$status->{master_host},P=$status->{master_port}";
1789  ***      0                                               $master  = get_dbh($dp, $dp->parse($spec, $slave_dsn));
1790                                                        }
1791                                                  
1792  ***      0      0                                     if ( defined $status->{seconds_behind_master} ) {
1793  ***      0                                               info("slave running $status->{seconds_behind_master} seconds behind");
1794                                                        }
1795                                                  
1796                                                        # Get binlog position.
1797  ***      0      0                                     if ( $master ) {
1798  ***      0                                               MKDEBUG && _d('Getting binlog pos from master');
1799  ***      0                                               my $res = $master->selectrow_hashref("SHOW MASTER STATUS");
1800  ***      0      0      0                                 die "Binary logging is disabled on the MASTER-HOST.\n"
      ***                    0                        
1801                                                              unless $res && %$res && $res->{file};
1802  ***      0                                               my $pos = $positions[-1];
1803  ***      0      0      0                                 if ( !@positions || $pos->[$FILE] ne $res->{file}
      ***                    0                        
1804                                                              || $pos->[$POS] != $res->{position} )
1805                                                           {
1806  ***      0                                                  push @positions,
1807                                                                 [ $now, $res->{file}, $res->{position} ];
1808                                                           }
1809                                                        }
1810                                                        else {
1811  ***      0                                               MKDEBUG && _d('Getting binlog pos from slave');
1812                                                           # Use the position on master at which the I/O thread is reading.
1813                                                           # If the I/O thread is not far behind, which it usually is not,
1814                                                           # this is basically the same as the master's File/Position, but
1815                                                           # it's more efficient -- one fewer connections to keep open.
1816  ***      0                                               my $pos = $positions[-1];
1817  ***      0      0      0                                 if ( !@positions
      ***                    0                        
1818                                                              || $pos->[$FILE] ne $status->{master_log_file}
1819                                                              || $pos->[$POS] != $status->{read_master_log_pos} )
1820                                                           {
1821  ***      0                                                  push @positions,
1822                                                                 [ $now, $status->{master_log_file},
1823                                                                   $status->{read_master_log_pos} ];
1824                                                           }
1825                                                        }
1826                                                  
1827  ***      0      0      0                              if ( ( $status->{slave_sql_running} || '' ) eq 'No' ) {
      ***             0      0                        
1828  ***      0                                               MKDEBUG && _d('Slave not running');
1829                                                           # Find the most recent binlog position that's older than
1830                                                           # the delay amount.
1831  ***      0                                               my $pos;
1832  ***      0                                               my $i = 0;
1833  ***      0             0                                 while ( $i < @positions
1834                                                                   && $positions[$i]->[$TS] <= $now - $o->get('delay') ) {
1835  ***      0                                                  $pos = $i;
1836  ***      0                                                  $i++;
1837                                                           }
1838                                                  
1839  ***      0      0                                        if ( $pos ) {
1840  ***      0                                                  my $position = $positions[$pos];
1841  ***      0                                                  MKDEBUG && _d('Chosen position:', ts($position->[$TS]),
1842                                                                    $position->[$FILE], '/', $position->[$POS]);
1843                                                           }
1844                                                           else {
1845  ***      0                                                  MKDEBUG && _d('No position found');
1846                                                           }
1847                                                  
1848                                                           # Make the slave server delay if possible; otherwise sleep and check
1849                                                           # again.
1850  ***      0      0      0                                 if ( $now >= $next_start && defined $pos ) {
1851  ***      0                                                  my $position = $positions[$pos];
1852  ***      0      0      0                                    if ( $position->[$FILE] ne $status->{relay_master_log_file}
1853                                                                 || $position->[$POS] != $status->{exec_master_log_pos} )
1854                                                              {
1855  ***      0                                                     $slave->do(
1856                                                                    "START SLAVE SQL_THREAD UNTIL /*$position->[$TS]*/ "
1857                                                                       . "MASTER_LOG_FILE = '$position->[$FILE]', "
1858                                                                       . "MASTER_LOG_POS = $position->[$POS]"
1859                                                                 );
1860                                                  
1861  ***      0                                                     info("START SLAVE until master "
1862                                                                    . ts($position->[$TS])
1863                                                                    . " $position->[$FILE]/$position->[$POS]");
1864                                                              }
1865                                                              else {
1866  ***      0                                                     info("no new binlog events");
1867                                                              }
1868                                                  
1869                                                              # Throw away positions we're going to replicate past.
1870  ***      0                                                  @positions = @positions[$pos + 1 .. $#positions];
1871                                                           }
1872                                                           else {
1873  ***      0                                                  my $position = $positions[-1];
1874  ***      0                                                  info("slave stopped at master position "
1875                                                                 . "$position->[$FILE]/$position->[$POS]");
1876                                                           }
1877                                                        }
1878                                                        elsif ( ($status->{seconds_behind_master} || 0) < $o->get('delay') ) {
1879  ***      0                                               my $position = $positions[-1];
1880  ***      0             0                                 my $behind = $status->{seconds_behind_master} || 0;
1881  ***      0                                               $next_start = $now + $o->get('delay') - $behind;
1882  ***      0                                               info("STOP SLAVE until "
1883                                                              . ts($next_start)
1884                                                              . " at master position $position->[$FILE]/$position->[$POS]");
1885  ***      0                                               $slave->do("STOP SLAVE SQL_THREAD");
1886                                                        }
1887                                                        else {
1888  ***      0                                               my $position = $positions[-1];
1889  ***      0             0                                 my $behind = $status->{seconds_behind_master} || 0;
1890  ***      0                                               info("slave running $behind seconds behind at"
1891                                                              . " master position $position->[$FILE]/$position->[$POS]");
1892                                                        }
1893                                                  
1894  ***      0                                            sleep($o->get('interval'));
1895                                                     }
1896                                                  
1897  ***      0      0      0                           if ( $slave && $o->get('continue') ) {
1898  ***      0                                            info("Setting slave to run normally");
1899  ***      0                                            $slave->do("START SLAVE SQL_THREAD");
1900                                                     }
1901                                                  
1902  ***      0                                         return 0;
1903                                                  }
1904                                                  
1905                                                  # ############################################################################
1906                                                  # Subroutines
1907                                                  # ############################################################################
1908                                                  
1909                                                  sub info {
1910  ***      0                    0                    my ( $message ) = @_;
1911  ***      0      0                                  $o->get('quiet') ? MKDEBUG && _d('info: now:', $now, 'message:', $message)
1912                                                                      : print ts($now), " ", $message, "\n";
1913                                                  }
1914                                                  
1915                                                  # Catches signals so mk-slave-delay can exit gracefully.
1916                                                  sub finish {
1917  ***      0                    0                    my ($signal) = @_;
1918  ***      0                                         print STDERR "Exiting on SIG$signal.\n";
1919  ***      0                                         $oktorun = 0;
1920                                                  }
1921                                                  
1922                                                  sub get_dbh {
1923  ***      0                    0                    my ( $dp, $info, $db ) = @_;
1924                                                  
1925  ***      0      0                                  if ( $o->get('ask-pass') ) {
1926  ***      0                                            $info->{p} = OptionParser::prompt_noecho("Enter password for $info->{h}: ");
1927                                                     }
1928                                                  
1929  ***      0                                         my $dbh = $dp->get_dbh(
1930                                                        $dp->get_cxn_params($info), {AutoCommit => 1});
1931  ***      0                                         $dbh->{FetchHashKeyName} = 'NAME_lc'; # Lowercases all column names
1932  ***      0                                         $dbh->{InactiveDestroy}  = 1;         # Don't disconnect on fork
1933  ***      0                                         return $dbh;
1934                                                  }
1935                                                  
1936                                                  sub _d {
1937  ***      0                    0                    my ($package, undef, $line) = caller 0;
1938  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1939  ***      0                                              map { defined $_ ? $_ : 'undef' }
1940                                                          @_;
1941  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1942                                                  }
1943                                                  
1944                                                  # ############################################################################
1945                                                  # Run the program.
1946                                                  # ############################################################################
1947                                                  if ( !caller ) { exit main(@ARGV); }
1948                                                  
1949                                                  1; # Because this is a module as well as a script.
1950                                                  
1951                                                  # ############################################################################
1952                                                  # Documentation.
1953                                                  # ############################################################################
1954                                                  
1955                                                  =pod
1956                                                  
1957                                                  =head1 NAME
1958                                                  
1959                                                  mk-slave-delay - Make a MySQL slave server lag behind its master.
1960                                                  
1961                                                  =head1 SYNOPSIS
1962                                                  
1963                                                  To hold slavehost one minute behind its master for ten minutes:
1964                                                  
1965                                                     mk-slave-delay --delay 1m --interval 15s --run-time 10m slavehost
1966                                                  
1967                                                  =head1 RISKS
1968                                                  
1969                                                  The following section is included to inform users about the potential risks,
1970                                                  whether known or unknown, of using this tool.  The two main categories of risks
1971                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
1972                                                  tools) and those created by bugs.
1973                                                  
1974                                                  mk-slave-delay is generally very low-risk.  It simply starts and stops the
1975                                                  replication SQL thread.  This might cause monitoring systems to think the slave
1976                                                  is having trouble.
1977                                                  
1978                                                  At the time of this release, we know of no bugs that could cause serious harm to
1979                                                  users.
1980                                                  
1981                                                  The authoritative source for updated information is always the online issue
1982                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
1983                                                  see a list of such issues at the following URL:
1984                                                  L<http://www.maatkit.org/bugs/mk-slave-delay>.
1985                                                  
1986                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
1987                                                  
1988                                                  =head1 DESCRIPTION
1989                                                  
1990                                                  C<mk-slave-delay> watches a slave and starts and stops its replication SQL
1991                                                  thread as necessary to hold it at least as far behind the master as you
1992                                                  request.  In practice, it will typically cause the slave to lag between
1993                                                  L<"--delay"> and L<"--delay">+L<"--interval"> behind the master.
1994                                                  
1995                                                  It bases the delay on binlog positions in the slave's relay logs by default,
1996                                                  so there is no need to connect to the master.  This works well if the IO
1997                                                  thread doesn't lag the master much, which is typical in most replication
1998                                                  setups; the IO thread lag is usually milliseconds on a fast network.  If your
1999                                                  IO thread's lag is too large for your purposes, C<mk-slave-delay> can also
2000                                                  connect to the master for information about binlog positions.
2001                                                  
2002                                                  If the slave's I/O thread reports that it is waiting for the SQL thread to
2003                                                  free some relay log space, C<mk-slave-delay> will automatically connect to the
2004                                                  master to find binary log positions.  If L<"--ask-pass"> and L<"--daemonize">
2005                                                  are given, it is possible that this could cause it to ask for a password while
2006                                                  daemonized.  In this case, it exits.  Therefore, if you think your slave might
2007                                                  encounter this condition, you should be sure to either specify
2008                                                  L<"--use-master"> explicitly when daemonizing, or don't specify L<"--ask-pass">.
2009                                                  
2010                                                  The SLAVE-HOST and optional MASTER-HOST are both DSNs.  A DSN is a special
2011                                                  syntax that can be either just a hostname (like C<server.domain.com> or
2012                                                  C<1.2.3.4>), or a C<key=value,key=value> string.  Keys are a single letter:
2013                                                  
2014                                                     KEY MEANING
2015                                                     === =======
2016                                                     h   Connect to host
2017                                                     P   Port number to use for connection
2018                                                     S   Socket file to use for connection
2019                                                     u   User for login if not current user
2020                                                     p   Password to use when connecting
2021                                                     F   Only read default options from the given file
2022                                                  
2023                                                  Missing MASTER-HOST values are filled in with values from SLAVE-HOST, so you
2024                                                  don't need to specify them in both places.  C<mk-slave-delay> reads all normal
2025                                                  MySQL option files, such as ~/.my.cnf, so you may not need to specify username,
2026                                                  password and other common options at all.
2027                                                  
2028                                                  C<mk-slave-delay> tries to exit gracefully by trapping signals such as Ctrl-C.
2029                                                  You cannot bypass L<"--[no]continue"> with a trappable signal.
2030                                                  
2031                                                  =head1 OUTPUT
2032                                                  
2033                                                  If you specify L<"--quiet">, there is no output.  Otherwise, the normal output
2034                                                  is a status message consisting of a timestamp and information about what
2035                                                  C<mk-slave-delay> is doing: starting the slave, stopping the slave, or just
2036                                                  observing.
2037                                                  
2038                                                  =head1 OPTIONS
2039                                                  
2040                                                  =over
2041                                                  
2042                                                  =item --ask-pass
2043                                                  
2044                                                  Prompt for a password when connecting to MySQL.
2045                                                  
2046                                                  =item --charset
2047                                                  
2048                                                  short form: -A; type: string
2049                                                  
2050                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2051                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
2052                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
2053                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
2054                                                  connecting to MySQL.
2055                                                  
2056                                                  =item --config
2057                                                  
2058                                                  type: Array
2059                                                  
2060                                                  Read this comma-separated list of config files; if specified, this must be the
2061                                                  first option on the command line.
2062                                                  
2063                                                  =item --[no]continue
2064                                                  
2065                                                  default: yes
2066                                                  
2067                                                  Continue replication normally on exit.  After exiting, restart the slave's SQL
2068                                                  thread with no UNTIL condition, so it will run as usual and catch up to the
2069                                                  master.  This is enabled by default and works even if you terminate
2070                                                  C<mk-slave-delay> with Control-C.
2071                                                  
2072                                                  =item --daemonize
2073                                                  
2074                                                  Fork to the background and detach from the shell.  POSIX
2075                                                  operating systems only.
2076                                                  
2077                                                  =item --defaults-file
2078                                                  
2079                                                  short form: -F; type: string
2080                                                  
2081                                                  Only read mysql options from the given file.  You must give an absolute
2082                                                  pathname.
2083                                                  
2084                                                  =item --delay
2085                                                  
2086                                                  type: time; default: 1h
2087                                                  
2088                                                  How far the slave should lag its master.
2089                                                  
2090                                                  =item --help
2091                                                  
2092                                                  Show help and exit.
2093                                                  
2094                                                  =item --host
2095                                                  
2096                                                  short form: -h; type: string
2097                                                  
2098                                                  Connect to host.
2099                                                  
2100                                                  =item --interval
2101                                                  
2102                                                  type: time; default: 1m
2103                                                  
2104                                                  How frequently C<mk-slave-delay> should check whether the slave needs to be
2105                                                  started or stopped.
2106                                                  
2107                                                  =item --log
2108                                                  
2109                                                  type: string
2110                                                  
2111                                                  Print all output to this file when daemonized.
2112                                                  
2113                                                  =item --password
2114                                                  
2115                                                  short form: -p; type: string
2116                                                  
2117                                                  Password to use when connecting.
2118                                                  
2119                                                  =item --pid
2120                                                  
2121                                                  type: string
2122                                                  
2123                                                  Create the given PID file when daemonized.  The file contains the process
2124                                                  ID of the daemonized instance.  The PID file is removed when the
2125                                                  daemonized instance exits.  The program checks for the existence of the
2126                                                  PID file when starting; if it exists and the process with the matching PID
2127                                                  exists, the program exits.
2128                                                  
2129                                                  =item --port
2130                                                  
2131                                                  short form: -P; type: int
2132                                                  
2133                                                  Port number to use for connection.
2134                                                  
2135                                                  =item --quiet
2136                                                  
2137                                                  short form: -q
2138                                                  
2139                                                  Don't print informational messages about operation.  See L<OUTPUT> for details.
2140                                                  
2141                                                  =item --run-time
2142                                                  
2143                                                  type: time
2144                                                  
2145                                                  How long C<mk-slave-delay> should run before exiting.  The default is to run
2146                                                  forever.
2147                                                  
2148                                                  =item --set-vars
2149                                                  
2150                                                  type: string; default: wait_timeout=10000
2151                                                  
2152                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2153                                                  will be appended to SET and executed.
2154                                                  
2155                                                  =item --socket
2156                                                  
2157                                                  short form: -S; type: string
2158                                                  
2159                                                  Socket file to use for connection.
2160                                                  
2161                                                  =item --use-master
2162                                                  
2163                                                  Get binlog positions from master, not slave.  Don't trust the binlog positions
2164                                                  in the slave's relay log.  Connect to the master and get binlog positions
2165                                                  instead.  If you specify this option without giving a MASTER-HOST on the command
2166                                                  line, C<mk-slave-delay> examines the slave's SHOW SLAVE STATUS to determine the
2167                                                  hostname and port for connecting to the master.
2168                                                  
2169                                                  C<mk-slave-delay> uses only the MASTER_HOST and MASTER_PORT values from SHOW
2170                                                  SLAVE STATUS for the master connection.  It does not use the MASTER_USER
2171                                                  value.  If you want to specify a different username for the master than the
2172                                                  one you use to connect to the slave, you should specify the MASTER-HOST option
2173                                                  explicitly on the command line.
2174                                                  
2175                                                  =item --user
2176                                                  
2177                                                  short form: -u; type: string
2178                                                  
2179                                                  User for login if not current user.
2180                                                  
2181                                                  =item --version
2182                                                  
2183                                                  Show version and exit.
2184                                                  
2185                                                  =back
2186                                                  
2187                                                  =head1 DOWNLOADING
2188                                                  
2189                                                  You can download Maatkit from Google Code at
2190                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2191                                                  easily with a command like the following:
2192                                                  
2193                                                     wget http://www.maatkit.org/get/toolname
2194                                                     or
2195                                                     wget http://www.maatkit.org/trunk/toolname
2196                                                  
2197                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2198                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2199                                                  needed.  The first URL gets the latest released version of the tool, and the
2200                                                  second gets the latest trunk code from Subversion.
2201                                                  
2202                                                  =head1 ENVIRONMENT
2203                                                  
2204                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2205                                                  the Maatkit tools:
2206                                                  
2207                                                     MKDEBUG=1 mk-....
2208                                                  
2209                                                  =head1 SYSTEM REQUIREMENTS
2210                                                  
2211                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2212                                                  installed in any reasonably new version of Perl.
2213                                                  
2214                                                  =head1 BUGS
2215                                                  
2216                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-slave-delay>.
2217                                                  
2218                                                  Please use Google Code Issues and Groups to report bugs or request support:
2219                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2220                                                  discuss Maatkit.
2221                                                  
2222                                                  Please include the complete command-line used to reproduce the problem you are
2223                                                  seeing, the version of all MySQL servers involved, the complete output of the
2224                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2225                                                  running with the C<MKDEBUG=1> environment variable.
2226                                                  
2227                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2228                                                  
2229                                                  This program is copyright 2007-@CURRENTYEAR@ Sergey Zhuravlev and Baron Schwartz.
2230                                                  Feedback and improvements are welcome.
2231                                                  
2232                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2233                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2234                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2235                                                  
2236                                                  This program is free software; you can redistribute it and/or modify it under
2237                                                  the terms of the GNU General Public License as published by the Free Software
2238                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2239                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2240                                                  licenses.
2241                                                  
2242                                                  You should have received a copy of the GNU General Public License along with
2243                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2244                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2245                                                  
2246                                                  =head1 AUTHOR
2247                                                  
2248                                                  Sergey Zhuravlev, Baron Schwartz
2249                                                  
2250                                                  =head1 ABOUT MAATKIT
2251                                                  
2252                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2253                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2254                                                  code contributors.  Both are employed by Percona.  Financial support for
2255                                                  Maatkit development is primarily provided by Percona and its clients. 
2256                                                  
2257                                                  =head1 VERSION
2258                                                  
2259                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
2260                                                  
2261                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
57    ***      0      0      0   unless $args{$arg}
63    ***      0      0      0   exists $args{'strict'} ? :
106   ***      0      0      0   unless open my $fh, '<', $file
126   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
131   ***      0      0      0   if $para =~ /^=over/
139   ***      0      0      0   unless $para
142   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
149   ***      0      0      0   if ($para =~ /: /) { }
153   ***      0      0      0   unless $attributes{$attrib}
157   ***      0      0      0   if ($attribs{'short form'})
173   ***      0      0      0   if $para =~ /^=item/
175   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
180   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
192   ***      0      0      0   unless $para
195   ***      0      0      0   if ($para =~ /^=head1/)
199   ***      0      0      0   if $para =~ /^=item --/
203   ***      0      0      0   unless @specs
214   ***      0      0      0   if (ref $opt) { }
219   ***      0      0      0   if (not $long)
224   ***      0      0      0   if exists $$self{'opts'}{$long}
227   ***      0      0      0   if (length $long == 1)
232   ***      0      0      0   if ($short) { }
233   ***      0      0      0   if exists $$self{'short_opts'}{$short}
242   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
243   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
244   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
256   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
261   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
263   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
264   ***      0      0      0   defined $def ? :
268   ***      0      0      0   if ($long eq 'config')
272   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
285   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
290   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
295   ***      0      0      0   if ($opt =~ /default to/)
300   ***      0      0      0   if ($opt =~ /restricted to option groups/)
310   ***      0      0      0   unless $rule_ok
327   ***      0      0      0   unless exists $$self{'opts'}{$long}
351   ***      0      0      0   unless exists $$self{'opts'}{$long}
371   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
376   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
391   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
400   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
404   ***      0      0      0   if ($self->has('config'))
410   ***      0      0      0   if ($EVAL_ERROR)
411   ***      0      0      0   $self->got('config') ? :
426   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
429   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
430   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
436   ***      0      0      0   if (@ARGV and $$self{'strict'})
442   ***      0      0      0   if (@set > 1)
453   ***      0      0      0   if (@set == 0)
463   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
464   ***      0      0      0   if (exists $$self{'disables'}{$long})
471   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
483   ***      0      0      0   if $restricted_opt eq $long
484   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
489   ***      0      0      0   if (@restricted_opts)
491   ***      0      0      0   if (@restricted_opts == 1) { }
520   ***      0      0      0   unless $opt and $$opt{'type'}
523   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
526   ***      0      0      0   if (not $suffix)
532   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
533   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
548   ***      0      0      0   if ($from_key)
559   ***      0      0      0   if (defined $num) { }
560   ***      0      0      0   if ($factor)
587   ***      0      0      0   length $opt == 1 ? :
588   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
595   ***      0      0      0   length $opt == 1 ? :
596   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
603   ***      0      0      0   length $opt == 1 ? :
604   ***      0      0      0   defined $long ? :
609   ***      0      0      0   length $opt == 1 ? :
610   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
644   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
645   ***      0      0      0   unless print $self->print_usage
649   ***      0      0      0   unless print $self->print_errors
658   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
667   ***      0      0      0   unless $$self{'got_opts'}
670   ***      0      0      0   $$_{'is_negatable'} ? :
674   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
690   ***      0      0      0   $group eq 'default' ? :
696   ***      0      0      0   $$opt{'is_negatable'} ? :
699   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
708   ***      0      0      0   if ($short) { }
717   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
721   ***      0      0      0   if ($$self{'dp'})
729   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
741   ***      0      0      0   if ref $_[0] eq 'OptionParser'
744   ***      0      0      0   unless print $prompt
752   ***      0      0      0   unless print "\n"
755   ***      0      0      0   if ($EVAL_ERROR)
777   ***      0      0      0   unless open my $fh, '<', $filename
785   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
788   ***      0      0      0   if ($line eq '--')
793   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
811   ***      0      0      0   unless open my $fh, '<', $file
815   ***      0      0      0   unless $para =~ /^=pod$/m
819   ***      0      0      0   unless $para =~ /$regex/
824   ***      0      0      0   unless close $fh
838   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
853   ***      0      0      0   defined $_ ? :
891   ***      0      0      0   if (not $$self{$dbh})
895   ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
902   ***      0      0      0   defined $_ ? :
988   ***     50      0     12   if (@_ > 2)
997   ***     50      0      4   if (not $dsn)
1009  ***     50     16      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1021  ***     50      0     32   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1027         100     16     16   if (not defined $final_props{$key})
1034  ***     50      0     16   unless exists $opts{$key}
1037  ***     50      0      4   if (my $required = $self->prop('required'))
1039  ***      0      0      0   unless $final_props{$key}
1048  ***      0      0      0   unless ref $o eq 'OptionParser'
1051  ***      0      0      0   if $o->has($_)
1061  ***      0      0      0   unless ref $dsn
1062  ***      0      0      0   $_ eq 'p' ? :
1063  ***      0      0      0   if defined $$dsn{$_}
1076  ***      0      0      0   $opts{$key}{'copy'} ? :
1090  ***     50      0      4   if ($driver eq 'Pg') { }
1122  ***     50      0      4   $cxn_string =~ /charset=utf8/ ? :
1131  ***     50      0      4   if (not $have_dbi)
1150  ***     50      4      0   if ($cxn_string =~ /mysql/i)
1158  ***     50      0      4   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1163  ***      0      0      0   if ($charset eq 'utf8') { }
1164  ***      0      0      0   unless binmode STDOUT, ':utf8'
1168  ***      0      0      0   unless binmode STDOUT
1172  ***     50      0      4   if ($self->prop('set-vars'))
1179  ***     50      0      4   if (not $dbh and $EVAL_ERROR)
1181  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1194  ***      0      0      0   if (not $tries)
1216  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1233  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1243  ***      0      0      0   unless $dsn_1
1244  ***      0      0      0   unless $dsn_2
1248  ***      0      0      0   if ($args{'overwrite'}) { }
1249  ***      0      0      0   defined $$dsn_1{$key} ? :
1252  ***      0      0      0   defined $$dsn_2{$key} ? :
1261  ***      0      0      0   defined $_ ? :
1290  ***      0      0      0   unless $args{$arg}
1293  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1309  ***      0      0      0   unless defined(my $pid = fork)
1310  ***      0      0      0   if ($pid)
1317  ***      0      0      0   unless POSIX::setsid()
1318  ***      0      0      0   unless chdir '/'
1324  ***      0      0      0   if (-t STDIN)
1326  ***      0      0      0   unless open STDIN, '/dev/null'
1330  ***      0      0      0   if ($$self{'log_file'}) { }
1332  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1336  ***      0      0      0   unless open STDERR, '>&STDOUT'
1340  ***      0      0      0   if (-t STDOUT)
1342  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1345  ***      0      0      0   if (-t STDERR)
1347  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1358  ***      0      0      0   $self ? :
1360  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1363  ***      0      0      0   if $EVAL_ERROR
1365  ***      0      0      0   if ($pid) { }
1367  ***      0      0      0   if ($pid_is_alive) { }
1389  ***      0      0      0   if (exists $$self{'child'})
1401  ***      0      0      0   if (not $PID_file)
1408  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1410  ***      0      0      0   unless print $PID_FH $PID
1412  ***      0      0      0   unless close $PID_FH
1421  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1422  ***      0      0      0   unless unlink $$self{'PID_file'}
1434  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1440  ***      0      0      0   defined $_ ? :
1488  ***      0      0      0   defined $args{'p_ms'} ? :
1489  ***      0      0      0   defined $args{'p_s'} ? :
1492  ***      0      0      0   if $t < 0
1494  ***      0      0      0   if $t =~ /e/
1498  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1519  ***      0      0      0   $p ? :
1526  ***      0      0      0   unless $secs
1528  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1533  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1552  ***      0      0      0   defined $args{'p'} ? :
1553  ***      0      0      0   defined $args{'d'} ? :
1560  ***      0      0      0   $num =~ /\./ || $n ? :
1569  ***      0      0      0   $gmt ? :
1575  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
1585  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1588  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
1597  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
1598  ***      0      0      0   $gmt ? :
1601  ***      0      0      0   if (defined $us)
1613  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
1614  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1624  ***      0      0      0   unless $hms
1629  ***      0      0      0   unless $hms
1634  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1650  ***      0      0      0   defined $_ ? :
1704  ***      0      0      0   @ARGV ? :
1706  ***      0      0      0   if @ARGV
1708  ***      0      0      0   if (not $o->got('help'))
1709  ***      0      0      0   if (not $slave_dsn)
1715  ***      0      0      0   if ($o->get('run-time'))
1734  ***      0      0      0   if (not $status or not %$status)
1738  ***      0      0      0   if ($master_dsn) { }
      ***      0      0      0   elsif ($o->get('use-master') or $$status{'slave_io_state'} =~ /free enough relay log/) { }
1754  ***      0      0      0   if ($o->get('daemonize')) { }
      ***      0      0      0   elsif ($o->get('pid')) { }
1777  ***      0      0      0   if (not $status or not %$status)
1781  ***      0      0      0   if (not $master and $$status{'slave_io_state'} =~ /free enough relay log/)
1785  ***      0      0      0   if ($o->get('daemonize') and $o->get('ask-pass'))
1792  ***      0      0      0   if (defined $$status{'seconds_behind_master'})
1797  ***      0      0      0   if ($master) { }
1800  ***      0      0      0   unless $res and %$res and $$res{'file'}
1803  ***      0      0      0   if (not @positions or $$pos[$FILE] ne $$res{'file'} or $$pos[$POS] != $$res{'position'})
1817  ***      0      0      0   if (not @positions or $$pos[$FILE] ne $$status{'master_log_file'} or $$pos[$POS] != $$status{'read_master_log_pos'})
1827  ***      0      0      0   if (($$status{'slave_sql_running'} || '') eq 'No') { }
      ***      0      0      0   elsif (($$status{'seconds_behind_master'} || 0) < $o->get('delay')) { }
1839  ***      0      0      0   if ($pos) { }
1850  ***      0      0      0   if ($now >= $next_start and defined $pos) { }
1852  ***      0      0      0   if ($$position[$FILE] ne $$status{'relay_master_log_file'} or $$position[$POS] != $$status{'exec_master_log_pos'}) { }
1897  ***      0      0      0   if ($slave and $o->get('continue'))
1911  ***      0      0      0   $o->get('quiet') ? :
1925  ***      0      0      0   if ($o->get('ask-pass'))
1938  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
256   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
261   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
400   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
429   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
436   ***      0      0      0      0   @ARGV and $$self{'strict'}
520   ***      0      0      0      0   $opt and $$opt{'type'}
523   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
588   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
596   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
610   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
699   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
793   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1021  ***     66     16     16      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     32      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1143  ***     66      4      0      4   not $dbh and $tries--
1179  ***     33      4      0      0   not $dbh and $EVAL_ERROR
1360  ***      0      0      0      0   $PID_file and -f $PID_file
1421  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1498  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1556  ***      0      0      0      0   $num >= $d and $n < @units - 1
1634  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
1769  ***      0      0      0      0   !$o->get('run-time') || $now < $end and $oktorun
1781  ***      0      0      0      0   not $master and $$status{'slave_io_state'} =~ /free enough relay log/
1785  ***      0      0      0      0   $o->get('daemonize') and $o->get('ask-pass')
1800  ***      0      0      0      0   $res and %$res
      ***      0      0      0      0   $res and %$res and $$res{'file'}
1833  ***      0      0      0      0   $i < @positions and $positions[$i][$TS] <= $now - $o->get('delay')
1850  ***      0      0      0      0   $now >= $next_start and defined $pos
1897  ***      0      0      0      0   $slave and $o->get('continue')

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
41    ***     50      0      2   $ENV{'MKDEBUG'} || 0
61    ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
63    ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
105   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay'
246   ***      0      0      0   $$opt{'group'} ||= 'default'
528   ***      0      0      0   $s || 's'
537   ***      0      0      0   $prefix || ''
565   ***      0      0      0   $pre || ''
572   ***      0      0      0   $val || ''
575   ***      0      0      0   $val || ''
633   ***      0      0      0   $$self{'description'} || ''
701   ***      0      0      0   $s ||= 's'
727   ***      0      0      0   $$opt{'type'} || ''
875   ***     50      0      2   $ENV{'MKDEBUG'} || 0
931   ***     50      0      2   $ENV{'MKDEBUG'} || 0
1002  ***     50      0      4   $prev ||= {}
1003  ***     50      0      4   $defaults ||= {}
1076  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1089  ***     50      0      4   $self->prop('dbidriver') || ''
1093  ***      0      0      0   $$info{'D'} || ''
1099  ***     50      0      4   $$info{'D'} || ''
1121  ***     50      4      0   $opts ||= {}
1216  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1232  ***      0      0      0   $level ||= 0
1233  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1285  ***     50      0      2   $ENV{'MKDEBUG'} || 0
1464  ***     50      0      2   $ENV{'MKDEBUG'} || 0
1518  ***      0      0      0   $args{'p'} || 0
1520  ***      0      0      0   $of ||= 1
1525  ***      0      0      0   $secs ||= 0
1678  ***     50      0      2   $ENV{'MKDEBUG'} || 0
1728  ***      0      0      0   $o->get('run-time') || 0
1827  ***      0      0      0   $$status{'slave_sql_running'} || ''
      ***      0      0      0   $$status{'seconds_behind_master'} || 0
1880  ***      0      0      0   $$status{'seconds_behind_master'} || 0
1889  ***      0      0      0   $$status{'seconds_behind_master'} || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
60    ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
61    ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
523   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1112  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1113  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1114  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1115  ***      0      0      0      0   $$dsn{'u'} ||= $user
1116  ***      0      0      0      0   $$dsn{'D'} ||= $db
1434  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1528  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1560  ***      0      0      0      0   $num =~ /\./ || $n
1734  ***      0      0      0      0   not $status or not %$status
1738  ***      0      0      0      0   $o->get('use-master') or $$status{'slave_io_state'} =~ /free enough relay log/
1769  ***      0      0      0      0   !$o->get('run-time') || $now < $end
1777  ***      0      0      0      0   not $status or not %$status
1803  ***      0      0      0      0   not @positions or $$pos[$FILE] ne $$res{'file'}
      ***      0      0      0      0   not @positions or $$pos[$FILE] ne $$res{'file'} or $$pos[$POS] != $$res{'position'}
1817  ***      0      0      0      0   not @positions or $$pos[$FILE] ne $$status{'master_log_file'}
      ***      0      0      0      0   not @positions or $$pos[$FILE] ne $$status{'master_log_file'} or $$pos[$POS] != $$status{'read_master_log_pos'}
1852  ***      0      0      0      0   $$position[$FILE] ne $$status{'relay_master_log_file'} or $$position[$POS] != $$status{'exec_master_log_pos'}


Covered Subroutines
-------------------

Subroutine           Count Location                                                   
-------------------- ----- -----------------------------------------------------------
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1279
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1280
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1282
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1283
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1285
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1458
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1459
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1460
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1461
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1462
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1464
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1672
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1673
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1674
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1678
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:22  
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:23  
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:34  
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:35  
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:37  
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:38  
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:39  
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:41  
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:870 
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:871 
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:873 
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:875 
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:919 
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:920 
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:921 
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:922 
BEGIN                    2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:931 
get_cxn_params           4 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1086
get_dbh                  4 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1120
new                      2 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:934 
parse                    4 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:996 
prop                    12 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:987 

Uncovered Subroutines
---------------------

Subroutine           Count Location                                                   
-------------------- ----- -----------------------------------------------------------
DESTROY                  0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1433
__ANON__                 0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:424 
_d                       0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1260
_d                       0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1439
_d                       0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1649
_d                       0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1937
_d                       0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:852 
_d                       0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:901 
_get_participants        0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:324 
_make_PID_file           0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1398
_parse_specs             0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:210 
_pod_to_specs            0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:104 
_read_config_file        0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:776 
_remove_PID_file         0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1420
_set_option              0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:370 
_validate_type           0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:519 
any_unix_timestamp       0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1611
as_string                0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1060
check_PID_file           0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1357
clone                    0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:829 
copy                     0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1242
daemonize                0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1306
descr                    0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:632 
disconnect               0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1225
errors                   0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:622 
fill_in_dsn              0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1108
finish                   0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1917
get                      0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:586 
get_dbh                  0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1923
get_defaults             0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:360 
get_defaults_files       0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:99  
get_groups               0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:365 
get_hostname             0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1215
get_opts                 0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:387 
get_specs                0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:92  
got                      0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:594 
has                      0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:602 
info                     0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1910
main                     0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1685
make_PID_file            0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1388
make_checksum            0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1642
micro_t                  0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1487
new                      0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1288
new                      0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:55  
new                      0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:878 
opts                     0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:336 
parse                    0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:883 
parse_options            0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1047
parse_timestamp          0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1584
percentage_of            0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1517
print_active_handles     0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1231
print_errors             0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:656 
print_usage              0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:666 
prompt                   0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:627 
prompt_noecho            0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:741 
read_para_after          0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:810 
save_error               0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:617 
secs_to_time             0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1524
set                      0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:608 
set_defaults             0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:348 
short_opts               0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:342 
shorten                  0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1551
ts                       0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1568
unix_timestamp           0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1596
usage                    0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:1069
usage_or_errors          0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:643 
version_ge               0 /home/daniel/dev/maatkit/mk-slave-delay/mk-slave-delay:890 


