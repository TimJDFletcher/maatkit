---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...store/mk-parallel-restore   12.5    1.9    5.3   35.9    n/a  100.0    9.9
Total                          12.5    1.9    5.3   35.9    n/a  100.0    9.9
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:34 2010
Finish:       Thu Jan 28 22:27:34 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:36 2010
Finish:       Thu Jan 28 22:27:37 2010

Run:          ./102_biggest_first.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:40 2010
Finish:       Thu Jan 28 22:27:41 2010

Run:          ./103_progress.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:44 2010
Finish:       Thu Jan 28 22:27:44 2010

Run:          ./104_resume.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:47 2010
Finish:       Thu Jan 28 22:27:49 2010

Run:          ./105_daemon.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:51 2010
Finish:       Thu Jan 28 22:27:52 2010

Run:          ./106_fast_index.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:54 2010
Finish:       Thu Jan 28 22:27:56 2010

Run:          ./107_switches.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:27:59 2010
Finish:       Thu Jan 28 22:28:00 2010

Run:          ./108_pure_restore.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:02 2010
Finish:       Thu Jan 28 22:28:03 2010

Run:          ./109_threads.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:06 2010
Finish:       Thu Jan 28 22:28:06 2010

Run:          ./110_dsn_d_part.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:09 2010
Finish:       Thu Jan 28 22:28:10 2010

Run:          ./111_restore_only_to_empty_dbs.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:12 2010
Finish:       Thu Jan 28 22:28:13 2010

Run:          ./112_create_databases.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:16 2010
Finish:       Thu Jan 28 22:28:17 2010

Run:          ./113_restore_innodb_tables.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:20 2010
Finish:       Thu Jan 28 22:28:21 2010

Run:          ./201_issue_506.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:24 2010
Finish:       Thu Jan 28 22:28:26 2010

Run:          ./202_issue_221.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:29 2010
Finish:       Thu Jan 28 22:28:29 2010

Run:          ./203_issue_406.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:32 2010
Finish:       Thu Jan 28 22:28:33 2010

Run:          ./204_issue_624.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:36 2010
Finish:       Thu Jan 28 22:28:36 2010

Run:          ./205_issue_625.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:39 2010
Finish:       Thu Jan 28 22:28:39 2010

Run:          ./207_issue_703.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:42 2010
Finish:       Thu Jan 28 22:28:43 2010

Run:          ./208_issue_726.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:45 2010
Finish:       Thu Jan 28 22:28:46 2010

Run:          ./209_issue_57.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:28:49 2010
Finish:       Thu Jan 28 22:28:56 2010

/home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is a program to load files into MySQL in parallel.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22            21                   21           123   use strict;
              21                                 54   
              21                                143   
23            21                   21           133   use warnings FATAL => 'all';
              21                                 59   
              21                                147   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # OptionParser package 5266
31                                                    # ###########################################################################
32                                                    package OptionParser;
33                                                    
34            21                   21           145   use strict;
              21                                 61   
              21                                103   
35            21                   21           129   use warnings FATAL => 'all';
              21                                 55   
              21                                 98   
36                                                    
37            21                   21           197   use Getopt::Long;
              21                                 76   
              21                                147   
38            21                   21           156   use List::Util qw(max);
              21                                 61   
              21                                238   
39            21                   21           135   use English qw(-no_match_vars);
              21                                 57   
              21                                143   
40                                                    
41    ***     21            50     21           155   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 97   
              21                                350   
42                                                    
43                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
44                                                    
45                                                    my %attributes = (
46                                                       'type'       => 1,
47                                                       'short form' => 1,
48                                                       'group'      => 1,
49                                                       'default'    => 1,
50                                                       'cumulative' => 1,
51                                                       'negatable'  => 1,
52                                                    );
53                                                    
54                                                    sub new {
55    ***      0                    0             0      my ( $class, %args ) = @_;
56    ***      0                                  0      foreach my $arg ( qw(description) ) {
57    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
58                                                       }
59    ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
60    ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
61    ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
62                                                    
63    ***      0      0      0                    0      my $self = {
      ***                    0                        
64                                                          description    => $args{description},
65                                                          prompt         => $args{prompt} || '<options>',
66                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
67                                                          dp             => $args{dp}     || undef,
68                                                          program_name   => $program_name,
69                                                          opts           => {},
70                                                          got_opts       => 0,
71                                                          short_opts     => {},
72                                                          defaults       => {},
73                                                          groups         => {},
74                                                          allowed_groups => {},
75                                                          errors         => [],
76                                                          rules          => [],  # desc of rules for --help
77                                                          mutex          => [],  # rule: opts are mutually exclusive
78                                                          atleast1       => [],  # rule: at least one opt is required
79                                                          disables       => {},  # rule: opt disables other opts 
80                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
81                                                          default_files  => [
82                                                             "/etc/maatkit/maatkit.conf",
83                                                             "/etc/maatkit/$program_name.conf",
84                                                             "$home/.maatkit.conf",
85                                                             "$home/.$program_name.conf",
86                                                          ],
87                                                       };
88    ***      0                                  0      return bless $self, $class;
89                                                    }
90                                                    
91                                                    sub get_specs {
92    ***      0                    0             0      my ( $self, $file ) = @_;
93    ***      0                                  0      my @specs = $self->_pod_to_specs($file);
94    ***      0                                  0      $self->_parse_specs(@specs);
95    ***      0                                  0      return;
96                                                    }
97                                                    
98                                                    sub get_defaults_files {
99    ***      0                    0             0      my ( $self ) = @_;
100   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
101                                                   }
102                                                   
103                                                   sub _pod_to_specs {
104   ***      0                    0             0      my ( $self, $file ) = @_;
105   ***      0             0                    0      $file ||= __FILE__;
106   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
107                                                   
108   ***      0                                  0      my %types = (
109                                                         string => 's', # standard Getopt type
110                                                         'int'  => 'i', # standard Getopt type
111                                                         float  => 'f', # standard Getopt type
112                                                         Hash   => 'H', # hash, formed from a comma-separated list
113                                                         hash   => 'h', # hash as above, but only if a value is given
114                                                         Array  => 'A', # array, similar to Hash
115                                                         array  => 'a', # array, similar to hash
116                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
117                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
118                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
119                                                      );
120   ***      0                                  0      my @specs = ();
121   ***      0                                  0      my @rules = ();
122   ***      0                                  0      my $para;
123                                                   
124   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
125   ***      0                                  0      while ( $para = <$fh> ) {
126   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
127   ***      0                                  0         last;
128                                                      }
129                                                   
130   ***      0                                  0      while ( $para = <$fh> ) {
131   ***      0      0                           0         last if $para =~ m/^=over/;
132   ***      0                                  0         chomp $para;
133   ***      0                                  0         $para =~ s/\s+/ /g;
134   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
135   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
136   ***      0                                  0         push @rules, $para;
137                                                      }
138                                                   
139   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
140                                                   
141   ***      0                                  0      do {
142   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
143   ***      0                                  0            chomp $para;
144   ***      0                                  0            MKDEBUG && _d($para);
145   ***      0                                  0            my %attribs;
146                                                   
147   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
148                                                   
149   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
150   ***      0                                  0               $para =~ s/\s+\Z//g;
151   ***      0                                  0               %attribs = map {
152   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
153   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
154                                                                        unless $attributes{$attrib};
155   ***      0                                  0                     ($attrib, $val);
156                                                                  } split(/; /, $para);
157   ***      0      0                           0               if ( $attribs{'short form'} ) {
158   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
159                                                               }
160   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
161                                                            }
162                                                            else {
163   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
164                                                            }
165                                                   
166   ***      0                                  0            $para =~ s/\s+\Z//g;
167   ***      0                                  0            $para =~ s/\s+/ /g;
168   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
169                                                   
170   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
171   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
172                                                   
173   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
174                                                   
175   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
176   ***      0                                  0               $option = $base_option;
177   ***      0                                  0               $attribs{'negatable'} = 1;
178                                                            }
179                                                   
180   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
181                                                               spec  => $option
182                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
183                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
184                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
185                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
186                                                               desc  => $para
187                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
188                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
189                                                            };
190                                                         }
191   ***      0                                  0         while ( $para = <$fh> ) {
192   ***      0      0                           0            last unless $para;
193                                                   
194                                                   
195   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
196   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
197   ***      0                                  0               last;
198                                                            }
199   ***      0      0                           0            last if $para =~ m/^=item --/;
200                                                         }
201                                                      } while ( $para );
202                                                   
203   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
204                                                   
205   ***      0                                  0      close $fh;
206   ***      0                                  0      return @specs, @rules;
207                                                   }
208                                                   
209                                                   sub _parse_specs {
210   ***      0                    0             0      my ( $self, @specs ) = @_;
211   ***      0                                  0      my %disables; # special rule that requires deferred checking
212                                                   
213   ***      0                                  0      foreach my $opt ( @specs ) {
214   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
215                                                            MKDEBUG && _d('Parsing opt spec:',
216   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
217                                                   
218   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
219   ***      0      0                           0            if ( !$long ) {
220   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
221                                                            }
222   ***      0                                  0            $opt->{long} = $long;
223                                                   
224   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
225   ***      0                                  0            $self->{opts}->{$long} = $opt;
226                                                   
227   ***      0      0                           0            if ( length $long == 1 ) {
228   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
229   ***      0                                  0               $self->{short_opts}->{$long} = $long;
230                                                            }
231                                                   
232   ***      0      0                           0            if ( $short ) {
233   ***      0      0                           0               die "Duplicate short option -$short"
234                                                                  if exists $self->{short_opts}->{$short};
235   ***      0                                  0               $self->{short_opts}->{$short} = $long;
236   ***      0                                  0               $opt->{short} = $short;
237                                                            }
238                                                            else {
239   ***      0                                  0               $opt->{short} = undef;
240                                                            }
241                                                   
242   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
243   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
244   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
245                                                   
246   ***      0             0                    0            $opt->{group} ||= 'default';
247   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
248                                                   
249   ***      0                                  0            $opt->{value} = undef;
250   ***      0                                  0            $opt->{got}   = 0;
251                                                   
252   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
253   ***      0                                  0            $opt->{type} = $type;
254   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
255                                                   
256   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
257   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
258                                                                  . "was given when this OptionParser object was created";
259                                                            }
260                                                   
261   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
262                                                   
263   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
264   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
265   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
266                                                            }
267                                                   
268   ***      0      0                           0            if ( $long eq 'config' ) {
269   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
270                                                            }
271                                                   
272   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
273   ***      0                                  0               $disables{$long} = $dis;
274   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
275                                                            }
276                                                   
277   ***      0                                  0            $self->{opts}->{$long} = $opt;
278                                                         }
279                                                         else { # It's an option rule, not a spec.
280   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
281   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
282   ***      0                                  0            my @participants = $self->_get_participants($opt);
283   ***      0                                  0            my $rule_ok = 0;
284                                                   
285   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
286   ***      0                                  0               $rule_ok = 1;
287   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
288   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
289                                                            }
290   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
291   ***      0                                  0               $rule_ok = 1;
292   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
293   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
294                                                            }
295   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
296   ***      0                                  0               $rule_ok = 1;
297   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
298   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
299                                                            }
300   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
301   ***      0                                  0               $rule_ok = 1;
302   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
303   ***      0                                  0               my @groups = split(',', $groups);
304   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
305   ***      0                                  0                  s/\s+//;
306   ***      0                                  0                  $_ => 1;
307                                                               } @groups;
308                                                            }
309                                                   
310   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
311                                                         }
312                                                      }
313                                                   
314   ***      0                                  0      foreach my $long ( keys %disables ) {
315   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
316   ***      0                                  0         $self->{disables}->{$long} = \@participants;
317   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
318                                                      }
319                                                   
320   ***      0                                  0      return; 
321                                                   }
322                                                   
323                                                   sub _get_participants {
324   ***      0                    0             0      my ( $self, $str ) = @_;
325   ***      0                                  0      my @participants;
326   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
327   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
328                                                            unless exists $self->{opts}->{$long};
329   ***      0                                  0         push @participants, $long;
330                                                      }
331   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
332   ***      0                                  0      return @participants;
333                                                   }
334                                                   
335                                                   sub opts {
336   ***      0                    0             0      my ( $self ) = @_;
337   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
338   ***      0                                  0      return %opts;
339                                                   }
340                                                   
341                                                   sub short_opts {
342   ***      0                    0             0      my ( $self ) = @_;
343   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
344   ***      0                                  0      return %short_opts;
345                                                   }
346                                                   
347                                                   sub set_defaults {
348   ***      0                    0             0      my ( $self, %defaults ) = @_;
349   ***      0                                  0      $self->{defaults} = {};
350   ***      0                                  0      foreach my $long ( keys %defaults ) {
351   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
352                                                            unless exists $self->{opts}->{$long};
353   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
354   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
355                                                      }
356   ***      0                                  0      return;
357                                                   }
358                                                   
359                                                   sub get_defaults {
360   ***      0                    0             0      my ( $self ) = @_;
361   ***      0                                  0      return $self->{defaults};
362                                                   }
363                                                   
364                                                   sub get_groups {
365   ***      0                    0             0      my ( $self ) = @_;
366   ***      0                                  0      return $self->{groups};
367                                                   }
368                                                   
369                                                   sub _set_option {
370   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
371   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
372                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
373                                                               : die "Getopt::Long gave a nonexistent option: $opt";
374                                                   
375   ***      0                                  0      $opt = $self->{opts}->{$long};
376   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
377   ***      0                                  0         $opt->{value}++;
378                                                      }
379                                                      else {
380   ***      0                                  0         $opt->{value} = $val;
381                                                      }
382   ***      0                                  0      $opt->{got} = 1;
383   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
384                                                   }
385                                                   
386                                                   sub get_opts {
387   ***      0                    0             0      my ( $self ) = @_; 
388                                                   
389   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
390   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
391   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
392                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
393                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
394                                                            : undef;
395                                                      }
396   ***      0                                  0      $self->{got_opts} = 0;
397                                                   
398   ***      0                                  0      $self->{errors} = [];
399                                                   
400   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
401   ***      0                                  0         shift @ARGV;
402   ***      0                                  0         $self->_set_option('config', shift @ARGV);
403                                                      }
404   ***      0      0                           0      if ( $self->has('config') ) {
405   ***      0                                  0         my @extra_args;
406   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
407   ***      0                                  0            eval {
408   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
409                                                            };
410   ***      0      0                           0            if ( $EVAL_ERROR ) {
411   ***      0      0                           0               if ( $self->got('config') ) {
412   ***      0                                  0                  die $EVAL_ERROR;
413                                                               }
414                                                               elsif ( MKDEBUG ) {
415                                                                  _d($EVAL_ERROR);
416                                                               }
417                                                            }
418                                                         }
419   ***      0                                  0         unshift @ARGV, @extra_args;
420                                                      }
421                                                   
422   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
423                                                      GetOptions(
424   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
425   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
426   ***      0      0                           0         values %{$self->{opts}}
427                                                      ) or $self->save_error('Error parsing options');
428                                                   
429   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
430   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
431                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
432                                                               or die "Cannot print: $OS_ERROR";
433   ***      0                                  0         exit 0;
434                                                      }
435                                                   
436   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
437   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
438                                                      }
439                                                   
440   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
441   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
442   ***      0      0                           0         if ( @set > 1 ) {
443   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
444   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
445                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
446                                                                    . ' are mutually exclusive.';
447   ***      0                                  0            $self->save_error($err);
448                                                         }
449                                                      }
450                                                   
451   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
452   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
453   ***      0      0                           0         if ( @set == 0 ) {
454   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
455   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
456                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
457   ***      0                                  0            $self->save_error("Specify at least one of $err");
458                                                         }
459                                                      }
460                                                   
461   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
462   ***      0                                  0         my $opt = $self->{opts}->{$long};
463   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
464   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
465   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
466   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
467   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
468                                                                  'because', $long,'disables them');
469                                                            }
470                                                   
471   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
472                                                   
473   ***      0                                  0               my @restricted_groups = grep {
474   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
475   ***      0                                  0               } keys %{$self->{groups}};
476                                                   
477   ***      0                                  0               my @restricted_opts;
478   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
479   ***      0                                  0                  RESTRICTED_OPT:
480   ***      0                                  0                  foreach my $restricted_opt (
481                                                                     keys %{$self->{groups}->{$restricted_group}} )
482                                                                  {
483   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
484   ***      0      0                           0                     push @restricted_opts, $restricted_opt
485                                                                        if $self->{opts}->{$restricted_opt}->{got};
486                                                                  }
487                                                               }
488                                                   
489   ***      0      0                           0               if ( @restricted_opts ) {
490   ***      0                                  0                  my $err;
491   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
492   ***      0                                  0                     $err = "--$restricted_opts[0]";
493                                                                  }
494                                                                  else {
495   ***      0                                  0                     $err = join(', ',
496   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
497   ***      0                                  0                               grep { $_ } 
498                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
499                                                                            )
500                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
501                                                                  }
502   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
503                                                               }
504                                                            }
505                                                   
506                                                         }
507                                                         elsif ( $opt->{is_required} ) { 
508   ***      0                                  0            $self->save_error("Required option --$long must be specified");
509                                                         }
510                                                   
511   ***      0                                  0         $self->_validate_type($opt);
512                                                      }
513                                                   
514   ***      0                                  0      $self->{got_opts} = 1;
515   ***      0                                  0      return;
516                                                   }
517                                                   
518                                                   sub _validate_type {
519   ***      0                    0             0      my ( $self, $opt ) = @_;
520   ***      0      0      0                    0      return unless $opt && $opt->{type};
521   ***      0                                  0      my $val = $opt->{value};
522                                                   
523   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
524   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
525   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
526   ***      0      0                           0         if ( !$suffix ) {
527   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
528   ***      0             0                    0            $suffix = $s || 's';
529   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
530                                                               $opt->{long}, '(value:', $val, ')');
531                                                         }
532   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
533   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
534                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
535                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
536                                                                 :                  $num * 86400;   # Days
537   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
538   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
539                                                         }
540                                                         else {
541   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
542                                                         }
543                                                      }
544                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
545   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
546   ***      0                                  0         my $prev = {};
547   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
548   ***      0      0                           0         if ( $from_key ) {
549   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
550   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
551                                                         }
552   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
553   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
554                                                      }
555                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
556   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
557   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
558   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
559   ***      0      0                           0         if ( defined $num ) {
560   ***      0      0                           0            if ( $factor ) {
561   ***      0                                  0               $num *= $factor_for{$factor};
562   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
563                                                                  'to num', $num, '* factor', $factor);
564                                                            }
565   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
566                                                         }
567                                                         else {
568   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
569                                                         }
570                                                      }
571                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
572   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
573                                                      }
574                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
575   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
576                                                      }
577                                                      else {
578   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
579                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
580                                                      }
581                                                   
582   ***      0                                  0      return;
583                                                   }
584                                                   
585                                                   sub get {
586   ***      0                    0             0      my ( $self, $opt ) = @_;
587   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
588   ***      0      0      0                    0      die "Option $opt does not exist"
589                                                         unless $long && exists $self->{opts}->{$long};
590   ***      0                                  0      return $self->{opts}->{$long}->{value};
591                                                   }
592                                                   
593                                                   sub got {
594   ***      0                    0             0      my ( $self, $opt ) = @_;
595   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
596   ***      0      0      0                    0      die "Option $opt does not exist"
597                                                         unless $long && exists $self->{opts}->{$long};
598   ***      0                                  0      return $self->{opts}->{$long}->{got};
599                                                   }
600                                                   
601                                                   sub has {
602   ***      0                    0             0      my ( $self, $opt ) = @_;
603   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
604   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
605                                                   }
606                                                   
607                                                   sub set {
608   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
609   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
610   ***      0      0      0                    0      die "Option $opt does not exist"
611                                                         unless $long && exists $self->{opts}->{$long};
612   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
613   ***      0                                  0      return;
614                                                   }
615                                                   
616                                                   sub save_error {
617   ***      0                    0             0      my ( $self, $error ) = @_;
618   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
619                                                   }
620                                                   
621                                                   sub errors {
622   ***      0                    0             0      my ( $self ) = @_;
623   ***      0                                  0      return $self->{errors};
624                                                   }
625                                                   
626                                                   sub prompt {
627   ***      0                    0             0      my ( $self ) = @_;
628   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
629                                                   }
630                                                   
631                                                   sub descr {
632   ***      0                    0             0      my ( $self ) = @_;
633   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
634                                                                 . "  For more details, please use the --help option, "
635                                                                 . "or try 'perldoc $PROGRAM_NAME' "
636                                                                 . "for complete documentation.";
637   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
638   ***      0                                  0      $descr =~ s/ +$//mg;
639   ***      0                                  0      return $descr;
640                                                   }
641                                                   
642                                                   sub usage_or_errors {
643   ***      0                    0             0      my ( $self ) = @_;
644   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
645   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
646   ***      0                                  0         exit 0;
647                                                      }
648                                                      elsif ( scalar @{$self->{errors}} ) {
649   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
650   ***      0                                  0         exit 0;
651                                                      }
652   ***      0                                  0      return;
653                                                   }
654                                                   
655                                                   sub print_errors {
656   ***      0                    0             0      my ( $self ) = @_;
657   ***      0                                  0      my $usage = $self->prompt() . "\n";
658   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
659   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
660                                                                 . "\n";
661                                                      }
662   ***      0                                  0      return $usage . "\n" . $self->descr();
663                                                   }
664                                                   
665                                                   sub print_usage {
666   ***      0                    0             0      my ( $self ) = @_;
667   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
668   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
669                                                   
670   ***      0      0                           0      my $maxl = max(
671   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
672                                                         @opts);
673                                                   
674   ***      0      0                           0      my $maxs = max(0,
675   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
676   ***      0                                  0         values %{$self->{short_opts}});
677                                                   
678   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
679   ***      0                                  0      my $rcol = 80 - $lcol - 6;
680   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
681                                                   
682   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
683                                                   
684   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
685                                                   
686   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
687   ***      0                                  0      push @groups, 'default';
688                                                   
689   ***      0                                  0      foreach my $group ( reverse @groups ) {
690   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
691   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
692   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
693                                                            grep { $_->{group} eq $group }
694                                                            @opts )
695                                                         {
696   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
697   ***      0                                  0            my $short = $opt->{short};
698   ***      0                                  0            my $desc  = $opt->{desc};
699   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
700   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
701   ***      0             0                    0               $s    ||= 's';
702   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
703   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
704                                                                      . "d=days; if no suffix, $s is used.";
705                                                            }
706   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
707   ***      0                                  0            $desc =~ s/ +$//mg;
708   ***      0      0                           0            if ( $short ) {
709   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
710                                                            }
711                                                            else {
712   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
713                                                            }
714                                                         }
715                                                      }
716                                                   
717   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
718   ***      0                                  0         $usage .= "\nRules:\n\n";
719   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
720                                                      }
721   ***      0      0                           0      if ( $self->{dp} ) {
722   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
723                                                      }
724   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
725   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
726   ***      0                                  0         my $val   = $opt->{value};
727   ***      0             0                    0         my $type  = $opt->{type} || '';
728   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
729   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
730                                                                   : !defined $val             ? '(No value)'
731                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
732                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
733                                                                   : $type =~ m/A|a/           ? join(',', @$val)
734                                                                   :                             $val;
735   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
736                                                      }
737   ***      0                                  0      return $usage;
738                                                   }
739                                                   
740                                                   sub prompt_noecho {
741   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
742   ***      0                                  0      my ( $prompt ) = @_;
743   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
744   ***      0      0                           0      print $prompt
745                                                         or die "Cannot print: $OS_ERROR";
746   ***      0                                  0      my $response;
747   ***      0                                  0      eval {
748   ***      0                                  0         require Term::ReadKey;
749   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
750   ***      0                                  0         chomp($response = <STDIN>);
751   ***      0                                  0         Term::ReadKey::ReadMode('normal');
752   ***      0      0                           0         print "\n"
753                                                            or die "Cannot print: $OS_ERROR";
754                                                      };
755   ***      0      0                           0      if ( $EVAL_ERROR ) {
756   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
757                                                      }
758   ***      0                                  0      return $response;
759                                                   }
760                                                   
761                                                   if ( MKDEBUG ) {
762                                                      print '# ', $^X, ' ', $], "\n";
763                                                      my $uname = `uname -a`;
764                                                      if ( $uname ) {
765                                                         $uname =~ s/\s+/ /g;
766                                                         print "# $uname\n";
767                                                      }
768                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
769                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
770                                                         ($main::SVN_REV || ''), __LINE__);
771                                                      print('# Arguments: ',
772                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
773                                                   }
774                                                   
775                                                   sub _read_config_file {
776   ***      0                    0             0      my ( $self, $filename ) = @_;
777   ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
778   ***      0                                  0      my @args;
779   ***      0                                  0      my $prefix = '--';
780   ***      0                                  0      my $parse  = 1;
781                                                   
782                                                      LINE:
783   ***      0                                  0      while ( my $line = <$fh> ) {
784   ***      0                                  0         chomp $line;
785   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
786   ***      0                                  0         $line =~ s/\s+#.*$//g;
787   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
788   ***      0      0                           0         if ( $line eq '--' ) {
789   ***      0                                  0            $prefix = '';
790   ***      0                                  0            $parse  = 0;
791   ***      0                                  0            next LINE;
792                                                         }
793   ***      0      0      0                    0         if ( $parse
      ***             0                               
794                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
795                                                         ) {
796   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
797                                                         }
798                                                         elsif ( $line =~ m/./ ) {
799   ***      0                                  0            push @args, $line;
800                                                         }
801                                                         else {
802   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
803                                                         }
804                                                      }
805   ***      0                                  0      close $fh;
806   ***      0                                  0      return @args;
807                                                   }
808                                                   
809                                                   sub read_para_after {
810   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
811   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
812   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
813   ***      0                                  0      my $para;
814   ***      0                                  0      while ( $para = <$fh> ) {
815   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
816   ***      0                                  0         last;
817                                                      }
818   ***      0                                  0      while ( $para = <$fh> ) {
819   ***      0      0                           0         next unless $para =~ m/$regex/;
820   ***      0                                  0         last;
821                                                      }
822   ***      0                                  0      $para = <$fh>;
823   ***      0                                  0      chomp($para);
824   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
825   ***      0                                  0      return $para;
826                                                   }
827                                                   
828                                                   sub clone {
829   ***      0                    0             0      my ( $self ) = @_;
830                                                   
831   ***      0                                  0      my %clone = map {
832   ***      0                                  0         my $hashref  = $self->{$_};
833   ***      0                                  0         my $val_copy = {};
834   ***      0                                  0         foreach my $key ( keys %$hashref ) {
835   ***      0                                  0            my $ref = ref $hashref->{$key};
836   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
837   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
838   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
839                                                                              : $hashref->{$key};
840                                                         }
841   ***      0                                  0         $_ => $val_copy;
842                                                      } qw(opts short_opts defaults);
843                                                   
844   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
845   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
846                                                      }
847                                                   
848   ***      0                                  0      return bless \%clone;     
849                                                   }
850                                                   
851                                                   sub _d {
852   ***      0                    0             0      my ($package, undef, $line) = caller 0;
853   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
854   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
855                                                           @_;
856   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
857                                                   }
858                                                   
859                                                   1;
860                                                   
861                                                   # ###########################################################################
862                                                   # End OptionParser package
863                                                   # ###########################################################################
864                                                   
865                                                   # ###########################################################################
866                                                   # Quoter package 5266
867                                                   # ###########################################################################
868           21                   21           237   use strict;
              21                                 61   
              21                                184   
869           21                   21           150   use warnings FATAL => 'all';
              21                                 59   
              21                                170   
870                                                   
871                                                   package Quoter;
872                                                   
873           21                   21           140   use English qw(-no_match_vars);
              21                                 60   
              21                                146   
874                                                   
875   ***     21            50     21           152   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 55   
              21                                433   
876                                                   
877                                                   sub new {
878   ***      0                    0             0      my ( $class ) = @_;
879   ***      0                                  0      bless {}, $class;
880                                                   }
881                                                   
882                                                   sub quote {
883   ***      0                    0             0      my ( $self, @vals ) = @_;
884   ***      0                                  0      foreach my $val ( @vals ) {
885   ***      0                                  0         $val =~ s/`/``/g;
886                                                      }
887   ***      0                                  0      return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                  0   
888                                                   }
889                                                   
890                                                   sub quote_val {
891   ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
892                                                   
893   ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
894   ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
895                                                   
896   ***      0      0                           0      if ( !defined $is_numeric ) {
897   ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
898                                                      }
899                                                   
900   ***      0      0                           0      return $val if $is_numeric;
901                                                   
902   ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
903   ***      0                                  0      return "'$val'";
904                                                   }
905                                                   
906                                                   sub split_unquote {
907   ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
908   ***      0                                  0      $db_tbl =~ s/`//g;
909   ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
910   ***      0      0                           0      if ( !$tbl ) {
911   ***      0                                  0         $tbl = $db;
912   ***      0                                  0         $db  = $default_db;
913                                                      }
914   ***      0                                  0      return ($db, $tbl);
915                                                   }
916                                                   
917                                                   sub literal_like {
918   ***      0                    0             0      my ( $self, $like ) = @_;
919   ***      0      0                           0      return unless $like;
920   ***      0                                  0      $like =~ s/([%_])/\\$1/g;
921   ***      0                                  0      return "'$like'";
922                                                   }
923                                                   
924                                                   1;
925                                                   
926                                                   # ###########################################################################
927                                                   # End Quoter package
928                                                   # ###########################################################################
929                                                   
930                                                   # ###########################################################################
931                                                   # DSNParser package 5266
932                                                   # ###########################################################################
933                                                   package DSNParser;
934                                                   
935           21                   21           158   use strict;
              21                                 65   
              21                                146   
936           21                   21           130   use warnings FATAL => 'all';
              21                                 55   
              21                                113   
937           21                   21           126   use English qw(-no_match_vars);
              21                                 58   
              21                                110   
938           21                   21           152   use Data::Dumper;
              21                                 53   
              21                                191   
939                                                   $Data::Dumper::Indent    = 0;
940                                                   $Data::Dumper::Quotekeys = 0;
941                                                   
942                                                   eval {
943                                                      require DBI;
944                                                   };
945                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
946                                                   
947   ***     21            50     21           145   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 67   
              21                                287   
948                                                   
949                                                   sub new {
950           15                   15            76      my ( $class, @opts ) = @_;
951           15                               1239      my $self = {
952                                                         opts => {
953                                                            A => {
954                                                               desc => 'Default character set',
955                                                               dsn  => 'charset',
956                                                               copy => 1,
957                                                            },
958                                                            D => {
959                                                               desc => 'Database to use',
960                                                               dsn  => 'database',
961                                                               copy => 1,
962                                                            },
963                                                            F => {
964                                                               desc => 'Only read default options from the given file',
965                                                               dsn  => 'mysql_read_default_file',
966                                                               copy => 1,
967                                                            },
968                                                            h => {
969                                                               desc => 'Connect to host',
970                                                               dsn  => 'host',
971                                                               copy => 1,
972                                                            },
973                                                            p => {
974                                                               desc => 'Password to use when connecting',
975                                                               dsn  => 'password',
976                                                               copy => 1,
977                                                            },
978                                                            P => {
979                                                               desc => 'Port number to use for connection',
980                                                               dsn  => 'port',
981                                                               copy => 1,
982                                                            },
983                                                            S => {
984                                                               desc => 'Socket file to use for connection',
985                                                               dsn  => 'mysql_socket',
986                                                               copy => 1,
987                                                            },
988                                                            u => {
989                                                               desc => 'User for login if not current user',
990                                                               dsn  => 'user',
991                                                               copy => 1,
992                                                            },
993                                                         },
994                                                      };
995           15                                 77      foreach my $opt ( @opts ) {
996   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
997   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
998                                                      }
999           15                                203      return bless $self, $class;
1000                                                  }
1001                                                  
1002                                                  sub prop {
1003          57                   57           268      my ( $self, $prop, $value ) = @_;
1004  ***     57     50                         294      if ( @_ > 2 ) {
1005  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1006  ***      0                                  0         $self->{$prop} = $value;
1007                                                     }
1008          57                                436      return $self->{$prop};
1009                                                  }
1010                                                  
1011                                                  sub parse {
1012          19                   19           817      my ( $self, $dsn, $prev, $defaults ) = @_;
1013  ***     19     50                         101      if ( !$dsn ) {
1014  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1015  ***      0                                  0         return;
1016                                                     }
1017          19                                 45      MKDEBUG && _d('Parsing', $dsn);
1018  ***     19            50                   93      $prev     ||= {};
1019  ***     19            50                   91      $defaults ||= {};
1020          19                                 54      my %given_props;
1021          19                                 53      my %final_props;
1022          19                                 58      my %opts = %{$self->{opts}};
              19                                183   
1023                                                  
1024          19                                172      foreach my $dsn_part ( split(/,/, $dsn) ) {
1025  ***     76     50                         657         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1026          76                                405            $given_props{$prop_key} = $prop_val;
1027                                                        }
1028                                                        else {
1029  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1030  ***      0                                  0            $given_props{h} = $dsn_part;
1031                                                        }
1032                                                     }
1033                                                  
1034          19                                107      foreach my $key ( keys %opts ) {
1035         152                                322         MKDEBUG && _d('Finding value for', $key);
1036         152                                514         $final_props{$key} = $given_props{$key};
1037  ***    152     50     66                 1209         if (   !defined $final_props{$key}
      ***                   33                        
1038                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1039                                                        {
1040  ***      0                                  0            $final_props{$key} = $prev->{$key};
1041  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1042                                                        }
1043         152    100                         663         if ( !defined $final_props{$key} ) {
1044          76                                242            $final_props{$key} = $defaults->{$key};
1045          76                                216            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1046                                                        }
1047                                                     }
1048                                                  
1049          19                                102      foreach my $key ( keys %given_props ) {
1050  ***     76     50                         347         die "Unrecognized DSN part '$key' in '$dsn'\n"
1051                                                           unless exists $opts{$key};
1052                                                     }
1053  ***     19     50                          99      if ( (my $required = $self->prop('required')) ) {
1054  ***      0                                  0         foreach my $key ( keys %$required ) {
1055  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1056                                                        }
1057                                                     }
1058                                                  
1059          19                                136      return \%final_props;
1060                                                  }
1061                                                  
1062                                                  sub parse_options {
1063  ***      0                    0             0      my ( $self, $o ) = @_;
1064  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1065  ***      0                                  0      my $dsn_string
1066                                                        = join(',',
1067  ***      0      0                           0             map  { "$_=".$o->get($_); }
1068  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1069  ***      0                                  0             keys %{$self->{opts}}
1070                                                          );
1071  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1072  ***      0                                  0      return $self->parse($dsn_string);
1073                                                  }
1074                                                  
1075                                                  sub as_string {
1076  ***      0                    0             0      my ( $self, $dsn ) = @_;
1077  ***      0      0                           0      return $dsn unless ref $dsn;
1078  ***      0      0                           0      return join(',',
1079  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1080  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1081                                                        sort keys %$dsn );
1082                                                  }
1083                                                  
1084                                                  sub usage {
1085  ***      0                    0             0      my ( $self ) = @_;
1086  ***      0                                  0      my $usage
1087                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1088                                                        . "  KEY  COPY  MEANING\n"
1089                                                        . "  ===  ====  =============================================\n";
1090  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1091  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1092  ***      0      0      0                    0         $usage .= "  $key    "
1093                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1094                                                               .  ($opts{$key}->{desc} || '[No description]')
1095                                                               . "\n";
1096                                                     }
1097  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1098  ***      0                                  0      return $usage;
1099                                                  }
1100                                                  
1101                                                  sub get_cxn_params {
1102          19                   19           262      my ( $self, $info ) = @_;
1103          19                                 55      my $dsn;
1104          19                                 55      my %opts = %{$self->{opts}};
              19                                176   
1105  ***     19            50                  102      my $driver = $self->prop('dbidriver') || '';
1106  ***     19     50                          95      if ( $driver eq 'Pg' ) {
1107  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1108  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1109  ***      0             0                    0                        grep { defined $info->{$_} }
1110                                                                       qw(h P));
1111                                                     }
1112                                                     else {
1113          38                                278         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1114          95                                366            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1115  ***     19            50                  231                        grep { defined $info->{$_} }
1116                                                                       qw(F h P S A))
1117                                                           . ';mysql_read_default_group=client';
1118                                                     }
1119          19                                 62      MKDEBUG && _d($dsn);
1120          19                                181      return ($dsn, $info->{u}, $info->{p});
1121                                                  }
1122                                                  
1123                                                  sub fill_in_dsn {
1124  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1125  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1126  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1127  ***      0                                  0      $user =~ s/@.*//;
1128  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1129  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1130  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1131  ***      0             0                    0      $dsn->{u} ||= $user;
1132  ***      0             0                    0      $dsn->{D} ||= $db;
1133                                                  }
1134                                                  
1135                                                  sub get_dbh {
1136          19                   19           117      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1137  ***     19            50                   95      $opts ||= {};
1138  ***     19     50                         191      my $defaults = {
1139                                                        AutoCommit         => 0,
1140                                                        RaiseError         => 1,
1141                                                        PrintError         => 0,
1142                                                        ShowErrorStatement => 1,
1143                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1144                                                     };
1145          19                                100      @{$defaults}{ keys %$opts } = values %$opts;
              19                                 82   
1146                                                  
1147  ***     19     50                          87      if ( !$have_dbi ) {
1148  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1149                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1150                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1151                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1152                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1153                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1154                                                  
1155                                                     }
1156                                                  
1157          19                                 63      my $dbh;
1158          19                                 60      my $tries = 2;
1159  ***     19            66                  242      while ( !$dbh && $tries-- ) {
1160                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1161          19                                 52            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1162                                                  
1163          19                                 54         eval {
1164          19                                128            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1165                                                  
1166  ***     19     50                         232            if ( $cxn_string =~ m/mysql/i ) {
1167          19                                 62               my $sql;
1168                                                  
1169          19                                 79               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1170                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1171          19                                 46               MKDEBUG && _d($dbh, ':', $sql);
1172          19                               2402               $dbh->do($sql);
1173                                                  
1174  ***     19     50                         163               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1175  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1176  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1177  ***      0                                  0                  $dbh->do($sql);
1178  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1179  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1180  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1181                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1182                                                                 }
1183                                                                 else {
1184  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1185                                                                 }
1186                                                              }
1187                                                  
1188  ***     19     50                         128               if ( $self->prop('set-vars') ) {
1189  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1190  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1191  ***      0                                  0                  $dbh->do($sql);
1192                                                              }
1193                                                           }
1194                                                        };
1195  ***     19     50     33                  204         if ( !$dbh && $EVAL_ERROR ) {
1196  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1197  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1198  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1199  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1200                                                           }
1201                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1202  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1203                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1204                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1205                                                                 . "DBD::mysql is not installed, try:\n"
1206                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1207                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1208                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1209                                                           }
1210  ***      0      0                           0            if ( !$tries ) {
1211  ***      0                                  0               die $EVAL_ERROR;
1212                                                           }
1213                                                        }
1214                                                     }
1215                                                  
1216          19                                 47      MKDEBUG && _d('DBH info: ',
1217                                                        $dbh,
1218                                                        Dumper($dbh->selectrow_hashref(
1219                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1220                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1221                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1222                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1223                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1224                                                        '$DBI::VERSION:',        $DBI::VERSION,
1225                                                     );
1226                                                  
1227          19                                129      return $dbh;
1228                                                  }
1229                                                  
1230                                                  sub get_hostname {
1231  ***      0                    0                    my ( $self, $dbh ) = @_;
1232  ***      0      0      0                           if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1233  ***      0                                            return $host;
1234                                                     }
1235  ***      0                                         my ( $hostname, $one ) = $dbh->selectrow_array(
1236                                                        'SELECT /*!50038 @@hostname, */ 1');
1237  ***      0                                         return $hostname;
1238                                                  }
1239                                                  
1240                                                  sub disconnect {
1241  ***      0                    0                    my ( $self, $dbh ) = @_;
1242  ***      0                                         MKDEBUG && $self->print_active_handles($dbh);
1243  ***      0                                         $dbh->disconnect;
1244                                                  }
1245                                                  
1246                                                  sub print_active_handles {
1247  ***      0                    0                    my ( $self, $thing, $level ) = @_;
1248  ***      0             0                           $level ||= 0;
1249  ***      0      0      0                           printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1250                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1251                                                        or die "Cannot print: $OS_ERROR";
1252  ***      0                                         foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                      
      ***      0                                      
1253  ***      0                                            $self->print_active_handles( $handle, $level + 1 );
1254                                                     }
1255                                                  }
1256                                                  
1257                                                  sub copy {
1258  ***      0                    0                    my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1259  ***      0      0                                  die 'I need a dsn_1 argument' unless $dsn_1;
1260  ***      0      0                                  die 'I need a dsn_2 argument' unless $dsn_2;
1261  ***      0                                         my %new_dsn = map {
1262  ***      0                                            my $key = $_;
1263  ***      0                                            my $val;
1264  ***      0      0                                     if ( $args{overwrite} ) {
1265  ***      0      0                                        $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1266                                                        }
1267                                                        else {
1268  ***      0      0                                        $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1269                                                        }
1270  ***      0                                            $key => $val;
1271  ***      0                                         } keys %{$self->{opts}};
1272  ***      0                                         return \%new_dsn;
1273                                                  }
1274                                                  
1275                                                  sub _d {
1276  ***      0                    0                    my ($package, undef, $line) = caller 0;
1277  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1278  ***      0                                              map { defined $_ ? $_ : 'undef' }
1279                                                          @_;
1280  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1281                                                  }
1282                                                  
1283                                                  1;
1284                                                  
1285                                                  # ###########################################################################
1286                                                  # End DSNParser package
1287                                                  # ###########################################################################
1288                                                  
1289                                                  # ###########################################################################
1290                                                  # Transformers package 5266
1291                                                  # ###########################################################################
1292                                                  
1293                                                  package Transformers;
1294                                                  
1295          21                   21           176   use strict;
              21                                 69   
              21                                130   
1296          21                   21           146   use warnings FATAL => 'all';
              21                                 54   
              21                                133   
1297          21                   21           129   use English qw(-no_match_vars);
              21                                 62   
              21                                356   
1298          21                   21           281   use Time::Local qw(timegm timelocal);
              21                                 63   
              21                                229   
1299          21                   21           144   use Digest::MD5 qw(md5_hex);
              21                                 48   
              21                                146   
1300                                                  
1301  ***     21            50     21           129   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 49   
              21                                267   
1302                                                  
1303                                                  require Exporter;
1304                                                  our @ISA         = qw(Exporter);
1305                                                  our %EXPORT_TAGS = ();
1306                                                  our @EXPORT      = ();
1307                                                  our @EXPORT_OK   = qw(
1308                                                     micro_t
1309                                                     percentage_of
1310                                                     secs_to_time
1311                                                     shorten
1312                                                     ts
1313                                                     parse_timestamp
1314                                                     unix_timestamp
1315                                                     any_unix_timestamp
1316                                                     make_checksum
1317                                                  );
1318                                                  
1319                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1320                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
1321                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1322                                                  
1323                                                  sub micro_t {
1324  ***      0                    0                    my ( $t, %args ) = @_;
1325  ***      0      0                                  my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1326  ***      0      0                                  my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1327  ***      0                                         my $f;
1328                                                  
1329  ***      0      0                                  $t = 0 if $t < 0;
1330                                                  
1331  ***      0      0                                  $t = sprintf('%.17f', $t) if $t =~ /e/;
1332                                                  
1333  ***      0                                         $t =~ s/\.(\d{1,6})\d*/\.$1/;
1334                                                  
1335  ***      0      0      0                           if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1336  ***      0                                            $f = ($t * 1000000) . 'us';
1337                                                     }
1338                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1339  ***      0                                            $f = sprintf("%.${p_ms}f", $t * 1000);
1340  ***      0                                            $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1341                                                     }
1342                                                     elsif ($t >= 1) {
1343  ***      0                                            $f = sprintf("%.${p_s}f", $t);
1344  ***      0                                            $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1345                                                     }
1346                                                     else {
1347  ***      0                                            $f = 0;  # $t should = 0 at this point
1348                                                     }
1349                                                  
1350  ***      0                                         return $f;
1351                                                  }
1352                                                  
1353                                                  sub percentage_of {
1354  ***      0                    0                    my ( $is, $of, %args ) = @_;
1355  ***      0             0                           my $p   = $args{p} || 0; # float precision
1356  ***      0      0                                  my $fmt = $p ? "%.${p}f" : "%d";
1357  ***      0             0                           return sprintf $fmt, ($is * 100) / ($of ||= 1);
1358                                                  }
1359                                                  
1360                                                  sub secs_to_time {
1361  ***      0                    0                    my ( $secs, $fmt ) = @_;
1362  ***      0             0                           $secs ||= 0;
1363  ***      0      0                                  return '00:00' unless $secs;
1364                                                  
1365  ***      0      0      0                           $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1366                                                            : $secs >= 3_600  ? 'h'
1367                                                            :                   'm';
1368                                                  
1369                                                     return
1370  ***      0      0                                     $fmt eq 'd' ? sprintf(
      ***             0                               
1371                                                           "%d+%02d:%02d:%02d",
1372                                                           int($secs / 86_400),
1373                                                           int(($secs % 86_400) / 3_600),
1374                                                           int(($secs % 3_600) / 60),
1375                                                           $secs % 60)
1376                                                        : $fmt eq 'h' ? sprintf(
1377                                                           "%02d:%02d:%02d",
1378                                                           int(($secs % 86_400) / 3_600),
1379                                                           int(($secs % 3_600) / 60),
1380                                                           $secs % 60)
1381                                                        : sprintf(
1382                                                           "%02d:%02d",
1383                                                           int(($secs % 3_600) / 60),
1384                                                           $secs % 60);
1385                                                  }
1386                                                  
1387                                                  sub shorten {
1388  ***      0                    0                    my ( $num, %args ) = @_;
1389  ***      0      0                                  my $p = defined $args{p} ? $args{p} : 2;     # float precision
1390  ***      0      0                                  my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1391  ***      0                                         my $n = 0;
1392  ***      0                                         my @units = ('', qw(k M G T P E Z Y));
1393  ***      0             0                           while ( $num >= $d && $n < @units - 1 ) {
1394  ***      0                                            $num /= $d;
1395  ***      0                                            ++$n;
1396                                                     }
1397  ***      0      0      0                           return sprintf(
1398                                                        $num =~ m/\./ || $n
1399                                                           ? "%.${p}f%s"
1400                                                           : '%d',
1401                                                        $num, $units[$n]);
1402                                                  }
1403                                                  
1404                                                  sub ts {
1405  ***      0                    0                    my ( $time, $gmt ) = @_;
1406  ***      0      0                                  my ( $sec, $min, $hour, $mday, $mon, $year )
1407                                                        = $gmt ? gmtime($time) : localtime($time);
1408  ***      0                                         $mon  += 1;
1409  ***      0                                         $year += 1900;
1410  ***      0                                         my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1411                                                        $year, $mon, $mday, $hour, $min, $sec);
1412  ***      0      0                                  if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
1413  ***      0                                            $us = sprintf("%.6f", $us);
1414  ***      0                                            $us =~ s/^0\././;
1415  ***      0                                            $val .= $us;
1416                                                     }
1417  ***      0                                         return $val;
1418                                                  }
1419                                                  
1420                                                  sub parse_timestamp {
1421  ***      0                    0                    my ( $val ) = @_;
1422  ***      0      0                                  if ( my($y, $m, $d, $h, $i, $s, $f)
1423                                                           = $val =~ m/^$mysql_ts$/ )
1424                                                     {
1425  ***      0      0                                     return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1426                                                                       . (defined $f ? '%02.6f' : '%02d'),
1427                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1428                                                     }
1429  ***      0                                         return $val;
1430                                                  }
1431                                                  
1432                                                  sub unix_timestamp {
1433  ***      0                    0                    my ( $val, $gmt ) = @_;
1434  ***      0      0                                  if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
1435  ***      0      0                                     $val = $gmt
1436                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
1437                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
1438  ***      0      0                                     if ( defined $us ) {
1439  ***      0                                               $us = sprintf('%.6f', $us);
1440  ***      0                                               $us =~ s/^0\././;
1441  ***      0                                               $val .= $us;
1442                                                        }
1443                                                     }
1444  ***      0                                         return $val;
1445                                                  }
1446                                                  
1447                                                  sub any_unix_timestamp {
1448  ***      0                    0                    my ( $val, $callback ) = @_;
1449                                                  
1450  ***      0      0                                  if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
1451  ***      0      0                                     $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1452                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1453                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1454                                                           : $suffix eq 'd' ? $n * 86400    # Days
1455                                                           :                  $n;           # default: Seconds
1456  ***      0                                            MKDEBUG && _d('ts is now - N[shmd]:', $n);
1457  ***      0                                            return time - $n;
1458                                                     }
1459                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
1460  ***      0                                            MKDEBUG && _d('ts is MySQL slow log timestamp');
1461  ***      0      0                                     $val .= ' 00:00:00' unless $hms;
1462  ***      0                                            return unix_timestamp(parse_timestamp($val));
1463                                                     }
1464                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
1465  ***      0                                            MKDEBUG && _d('ts is properly formatted timestamp');
1466  ***      0      0                                     $val .= ' 00:00:00' unless $hms;
1467  ***      0                                            return unix_timestamp($val);
1468                                                     }
1469                                                     else {
1470  ***      0                                            MKDEBUG && _d('ts is MySQL expression');
1471  ***      0      0      0                              return $callback->($val) if $callback && ref $callback eq 'CODE';
1472                                                     }
1473                                                  
1474  ***      0                                         MKDEBUG && _d('Unknown ts type:', $val);
1475  ***      0                                         return;
1476                                                  }
1477                                                  
1478                                                  sub make_checksum {
1479  ***      0                    0                    my ( $val ) = @_;
1480  ***      0                                         my $checksum = uc substr(md5_hex($val), -16);
1481  ***      0                                         MKDEBUG && _d($checksum, 'checksum for', $val);
1482  ***      0                                         return $checksum;
1483                                                  }
1484                                                  
1485                                                  sub _d {
1486  ***      0                    0                    my ($package, undef, $line) = caller 0;
1487  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1488  ***      0                                              map { defined $_ ? $_ : 'undef' }
1489                                                          @_;
1490  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1491                                                  }
1492                                                  
1493                                                  1;
1494                                                  
1495                                                  # ###########################################################################
1496                                                  # End Transformers package
1497                                                  # ###########################################################################
1498                                                  
1499                                                  # ###########################################################################
1500                                                  # MaatkitCommon package 5266
1501                                                  # ###########################################################################
1502                                                  package MaatkitCommon;
1503                                                  
1504                                                  
1505          21                   21           160   use strict;
              21                                 60   
              21                                138   
1506          21                   21           130   use warnings FATAL => 'all';
              21                                 48   
              21                                139   
1507                                                  
1508          21                   21           124   use English qw(-no_match_vars);
              21                                 56   
              21                                136   
1509                                                  
1510                                                  require Exporter;
1511                                                  our @ISA         = qw(Exporter);
1512                                                  our %EXPORT_TAGS = ();
1513                                                  our @EXPORT      = qw();
1514                                                  our @EXPORT_OK   = qw(
1515                                                     _d
1516                                                     get_number_of_cpus
1517                                                  );
1518                                                  
1519  ***     21            50     21           143   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 53   
              21                                288   
1520                                                  
1521                                                  sub _d {
1522  ***      0                    0                    my ($package, undef, $line) = caller 0;
1523  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1524  ***      0                                              map { defined $_ ? $_ : 'undef' }
1525                                                          @_;
1526  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1527                                                  }
1528                                                  
1529                                                  sub get_number_of_cpus {
1530  ***      0                    0                    my ( $sys_info ) = @_;
1531  ***      0                                         my $n_cpus; 
1532                                                  
1533  ***      0                                         my $cpuinfo;
1534  ***      0      0      0                           if ( $sys_info || (open $cpuinfo, "<", "/proc/cpuinfo") ) {
1535  ***      0                                            local $INPUT_RECORD_SEPARATOR = undef;
1536  ***      0             0                              my $contents = $sys_info || <$cpuinfo>;
1537  ***      0                                            MKDEBUG && _d('sys info:', $contents);
1538  ***      0      0                                     close $cpuinfo if $cpuinfo;
1539  ***      0                                            $n_cpus = scalar( map { $_ } $contents =~ m/(processor)/g );
      ***      0                                      
1540  ***      0                                            MKDEBUG && _d('Got', $n_cpus, 'cpus from /proc/cpuinfo');
1541  ***      0      0                                     return $n_cpus if $n_cpus;
1542                                                     }
1543                                                  
1544                                                  
1545  ***      0      0      0                           if ( $sys_info || ($OSNAME =~ m/freebsd/i) || ($OSNAME =~ m/darwin/i) ) { 
      ***                    0                        
1546  ***      0             0                              my $contents = $sys_info || `sysctl hw.ncpu`;
1547  ***      0                                            MKDEBUG && _d('sys info:', $contents);
1548  ***      0      0                                     ($n_cpus) = $contents =~ m/(\d)/ if $contents;
1549  ***      0                                            MKDEBUG && _d('Got', $n_cpus, 'cpus from sysctl hw.ncpu');
1550  ***      0      0                                     return $n_cpus if $n_cpus;
1551                                                     } 
1552                                                  
1553  ***      0             0                           $n_cpus ||= $ENV{NUMBER_OF_PROCESSORS};
1554                                                  
1555  ***      0             0                           return $n_cpus || 1; # There has to be at least 1 CPU.
1556                                                  }
1557                                                  
1558                                                  1;
1559                                                  
1560                                                  # ###########################################################################
1561                                                  # End MaatkitCommon package
1562                                                  # ###########################################################################
1563                                                  
1564                                                  # ###########################################################################
1565                                                  # Daemon package 5266
1566                                                  # ###########################################################################
1567                                                  
1568                                                  package Daemon;
1569                                                  
1570          21                   21           154   use strict;
              21                                 58   
              21                                110   
1571          21                   21           129   use warnings FATAL => 'all';
              21                                 57   
              21                                123   
1572                                                  
1573          21                   21           133   use POSIX qw(setsid);
              21                                 47   
              21                                154   
1574          21                   21           126   use English qw(-no_match_vars);
              21                                 63   
              21                                110   
1575                                                  
1576  ***     21            50     21           149   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 55   
              21                                273   
1577                                                  
1578                                                  sub new {
1579  ***      0                    0                    my ( $class, %args ) = @_;
1580  ***      0                                         foreach my $arg ( qw(o) ) {
1581  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1582                                                     }
1583  ***      0                                         my $o = $args{o};
1584  ***      0      0                                  my $self = {
      ***             0                               
1585                                                        o        => $o,
1586                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1587                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1588                                                     };
1589                                                  
1590  ***      0                                         check_PID_file(undef, $self->{PID_file});
1591                                                  
1592  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1593  ***      0                                         return bless $self, $class;
1594                                                  }
1595                                                  
1596                                                  sub daemonize {
1597  ***      0                    0                    my ( $self ) = @_;
1598                                                  
1599  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
1600  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1601  ***      0      0                                  if ( $pid ) {
1602  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
1603  ***      0                                            exit;
1604                                                     }
1605                                                  
1606  ***      0                                         $self->{child} = 1;
1607                                                  
1608  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1609  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1610                                                  
1611  ***      0                                         $self->_make_PID_file();
1612                                                  
1613  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
1614                                                  
1615  ***      0      0                                  if ( -t STDIN ) {
1616  ***      0                                            close STDIN;
1617  ***      0      0                                     open  STDIN, '/dev/null'
1618                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1619                                                     }
1620                                                  
1621  ***      0      0                                  if ( $self->{log_file} ) {
1622  ***      0                                            close STDOUT;
1623  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
1624                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1625                                                  
1626  ***      0                                            close STDERR;
1627  ***      0      0                                     open  STDERR, ">&STDOUT"
1628                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1629                                                     }
1630                                                     else {
1631  ***      0      0                                     if ( -t STDOUT ) {
1632  ***      0                                               close STDOUT;
1633  ***      0      0                                        open  STDOUT, '>', '/dev/null'
1634                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1635                                                        }
1636  ***      0      0                                     if ( -t STDERR ) {
1637  ***      0                                               close STDERR;
1638  ***      0      0                                        open  STDERR, '>', '/dev/null'
1639                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1640                                                        }
1641                                                     }
1642                                                  
1643  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
1644  ***      0                                         return;
1645                                                  }
1646                                                  
1647                                                  sub check_PID_file {
1648  ***      0                    0                    my ( $self, $file ) = @_;
1649  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
1650  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
1651  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
1652  ***      0                                            my $pid;
1653  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
1654  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1655  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
1656  ***      0      0                                     if ( $pid ) {
1657  ***      0                                               my $pid_is_alive = kill 0, $pid;
1658  ***      0      0                                        if ( $pid_is_alive ) {
1659  ***      0                                                  die "The PID file $PID_file already exists "
1660                                                                 . " and the PID that it contains, $pid, is running";
1661                                                           }
1662                                                           else {
1663  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
1664                                                                 . "contains, $pid, is not running";
1665                                                           }
1666                                                        }
1667                                                        else {
1668  ***      0                                               die "The PID file $PID_file already exists but it does not "
1669                                                              . "contain a PID";
1670                                                        }
1671                                                     }
1672                                                     else {
1673  ***      0                                            MKDEBUG && _d('No PID file');
1674                                                     }
1675  ***      0                                         return;
1676                                                  }
1677                                                  
1678                                                  sub make_PID_file {
1679  ***      0                    0                    my ( $self ) = @_;
1680  ***      0      0                                  if ( exists $self->{child} ) {
1681  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
1682                                                     }
1683  ***      0                                         $self->_make_PID_file();
1684  ***      0                                         $self->{rm_PID_file} = 1;
1685  ***      0                                         return;
1686                                                  }
1687                                                  
1688                                                  sub _make_PID_file {
1689  ***      0                    0                    my ( $self ) = @_;
1690                                                  
1691  ***      0                                         my $PID_file = $self->{PID_file};
1692  ***      0      0                                  if ( !$PID_file ) {
1693  ***      0                                            MKDEBUG && _d('No PID file to create');
1694  ***      0                                            return;
1695                                                     }
1696                                                  
1697  ***      0                                         $self->check_PID_file();
1698                                                  
1699  ***      0      0                                  open my $PID_FH, '>', $PID_file
1700                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1701  ***      0      0                                  print $PID_FH $PID
1702                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1703  ***      0      0                                  close $PID_FH
1704                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1705                                                  
1706  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
1707  ***      0                                         return;
1708                                                  }
1709                                                  
1710                                                  sub _remove_PID_file {
1711  ***      0                    0                    my ( $self ) = @_;
1712  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
1713  ***      0      0                                     unlink $self->{PID_file}
1714                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1715  ***      0                                            MKDEBUG && _d('Removed PID file');
1716                                                     }
1717                                                     else {
1718  ***      0                                            MKDEBUG && _d('No PID to remove');
1719                                                     }
1720  ***      0                                         return;
1721                                                  }
1722                                                  
1723                                                  sub DESTROY {
1724  ***      0                    0                    my ( $self ) = @_;
1725  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1726  ***      0                                         return;
1727                                                  }
1728                                                  
1729                                                  sub _d {
1730  ***      0                    0                    my ($package, undef, $line) = caller 0;
1731  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1732  ***      0                                              map { defined $_ ? $_ : 'undef' }
1733                                                          @_;
1734  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1735                                                  }
1736                                                  
1737                                                  1;
1738                                                  
1739                                                  # ###########################################################################
1740                                                  # End Daemon package
1741                                                  # ###########################################################################
1742                                                  
1743                                                  # ###########################################################################
1744                                                  # TableParser package 5266
1745                                                  # ###########################################################################
1746                                                  package TableParser;
1747                                                  
1748          21                   21           154   use strict;
              21                                 52   
              21                                115   
1749          21                   21           129   use warnings FATAL => 'all';
              21                                 52   
              21                                110   
1750          21                   21           149   use English qw(-no_match_vars);
              21                                 55   
              21                                119   
1751          21                   21           146   use Data::Dumper;
              21                                 51   
              21                                165   
1752                                                  $Data::Dumper::Indent    = 1;
1753                                                  $Data::Dumper::Sortkeys  = 1;
1754                                                  $Data::Dumper::Quotekeys = 0;
1755                                                  
1756  ***     21            50     21           133   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 53   
              21                                276   
1757                                                  
1758                                                  
1759                                                  sub new {
1760  ***      0                    0                    my ( $class, %args ) = @_;
1761  ***      0                                         my @required_args = qw(Quoter);
1762  ***      0                                         foreach my $arg ( @required_args ) {
1763  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1764                                                     }
1765  ***      0                                         my $self = { %args };
1766  ***      0                                         return bless $self, $class;
1767                                                  }
1768                                                  
1769                                                  
1770                                                  sub parse {
1771  ***      0                    0                    my ( $self, $ddl, $opts ) = @_;
1772  ***      0      0                                  return unless $ddl;
1773  ***      0      0                                  if ( ref $ddl eq 'ARRAY' ) {
1774  ***      0      0                                     if ( lc $ddl->[0] eq 'table' ) {
1775  ***      0                                               $ddl = $ddl->[1];
1776                                                        }
1777                                                        else {
1778                                                           return {
1779  ***      0                                                  engine => 'VIEW',
1780                                                           };
1781                                                        }
1782                                                     }
1783                                                  
1784  ***      0      0                                  if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
1785  ***      0                                            die "Cannot parse table definition; is ANSI quoting "
1786                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
1787                                                     }
1788                                                  
1789  ***      0                                         my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
1790  ***      0      0                                  (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
1791                                                  
1792  ***      0                                         $ddl =~ s/(`[^`]+`)/\L$1/g;
1793                                                  
1794  ***      0                                         my $engine = $self->get_engine($ddl);
1795                                                  
1796  ***      0                                         my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
1797  ***      0                                         my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                      
1798  ***      0                                         MKDEBUG && _d('Columns:', join(', ', @cols));
1799                                                  
1800  ***      0                                         my %def_for;
1801  ***      0                                         @def_for{@cols} = @defs;
1802                                                  
1803  ***      0                                         my (@nums, @null);
1804  ***      0                                         my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
1805  ***      0                                         foreach my $col ( @cols ) {
1806  ***      0                                            my $def = $def_for{$col};
1807  ***      0                                            my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
1808  ***      0      0                                     die "Can't determine column type for $def" unless $type;
1809  ***      0                                            $type_for{$col} = $type;
1810  ***      0      0                                     if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
1811  ***      0                                               push @nums, $col;
1812  ***      0                                               $is_numeric{$col} = 1;
1813                                                        }
1814  ***      0      0                                     if ( $def !~ m/NOT NULL/ ) {
1815  ***      0                                               push @null, $col;
1816  ***      0                                               $is_nullable{$col} = 1;
1817                                                        }
1818  ***      0      0                                     $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
1819                                                     }
1820                                                  
1821  ***      0                                         my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
1822                                                  
1823                                                     return {
1824  ***      0                                            name           => $name,
1825                                                        cols           => \@cols,
1826  ***      0                                            col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
1827  ***      0                                            is_col         => { map { $_ => 1 } @cols },
1828                                                        null_cols      => \@null,
1829                                                        is_nullable    => \%is_nullable,
1830                                                        is_autoinc     => \%is_autoinc,
1831                                                        clustered_key  => $clustered_key,
1832                                                        keys           => $keys,
1833                                                        defs           => \%def_for,
1834                                                        numeric_cols   => \@nums,
1835                                                        is_numeric     => \%is_numeric,
1836                                                        engine         => $engine,
1837                                                        type_for       => \%type_for,
1838                                                     };
1839                                                  }
1840                                                  
1841                                                  sub sort_indexes {
1842  ***      0                    0                    my ( $self, $tbl ) = @_;
1843                                                  
1844                                                     my @indexes
1845  ***      0                                            = sort {
1846  ***      0                                               (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
1847                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
1848                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
1849  ***      0      0      0                                 || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                        
1850                                                        }
1851                                                        grep {
1852  ***      0                                               $tbl->{keys}->{$_}->{type} eq 'BTREE'
1853                                                        }
1854  ***      0                                            sort keys %{$tbl->{keys}};
1855                                                  
1856  ***      0                                         MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
1857  ***      0                                         return @indexes;
1858                                                  }
1859                                                  
1860                                                  sub find_best_index {
1861  ***      0                    0                    my ( $self, $tbl, $index ) = @_;
1862  ***      0                                         my $best;
1863  ***      0      0                                  if ( $index ) {
1864  ***      0                                            ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                      
      ***      0                                      
1865                                                     }
1866  ***      0      0                                  if ( !$best ) {
1867  ***      0      0                                     if ( $index ) {
1868  ***      0                                               die "Index '$index' does not exist in table";
1869                                                        }
1870                                                        else {
1871  ***      0                                               ($best) = $self->sort_indexes($tbl);
1872                                                        }
1873                                                     }
1874  ***      0                                         MKDEBUG && _d('Best index found is', $best);
1875  ***      0                                         return $best;
1876                                                  }
1877                                                  
1878                                                  sub find_possible_keys {
1879  ***      0                    0                    my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
1880  ***      0      0                                  return () unless $where;
1881  ***      0                                         my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
1882                                                        . ' WHERE ' . $where;
1883  ***      0                                         MKDEBUG && _d($sql);
1884  ***      0                                         my $expl = $dbh->selectrow_hashref($sql);
1885  ***      0                                         $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                      
1886  ***      0      0                                  if ( $expl->{possible_keys} ) {
1887  ***      0                                            MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
1888  ***      0                                            my @candidates = split(',', $expl->{possible_keys});
1889  ***      0                                            my %possible   = map { $_ => 1 } @candidates;
      ***      0                                      
1890  ***      0      0                                     if ( $expl->{key} ) {
1891  ***      0                                               MKDEBUG && _d('MySQL chose', $expl->{key});
1892  ***      0                                               unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                      
1893  ***      0                                               MKDEBUG && _d('Before deduping:', join(', ', @candidates));
1894  ***      0                                               my %seen;
1895  ***      0                                               @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                      
1896                                                        }
1897  ***      0                                            MKDEBUG && _d('Final list:', join(', ', @candidates));
1898  ***      0                                            return @candidates;
1899                                                     }
1900                                                     else {
1901  ***      0                                            MKDEBUG && _d('No keys in possible_keys');
1902  ***      0                                            return ();
1903                                                     }
1904                                                  }
1905                                                  
1906                                                  sub check_table {
1907  ***      0                    0                    my ( $self, %args ) = @_;
1908  ***      0                                         my @required_args = qw(dbh db tbl);
1909  ***      0                                         foreach my $arg ( @required_args ) {
1910  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1911                                                     }
1912  ***      0                                         my ($dbh, $db, $tbl) = @args{@required_args};
1913  ***      0                                         my $q      = $self->{Quoter};
1914  ***      0                                         my $db_tbl = $q->quote($db, $tbl);
1915  ***      0                                         MKDEBUG && _d('Checking', $db_tbl);
1916                                                  
1917  ***      0                                         my $sql = "SHOW TABLES FROM " . $q->quote($db)
1918                                                             . ' LIKE ' . $q->literal_like($tbl);
1919  ***      0                                         MKDEBUG && _d($sql);
1920  ***      0                                         my $row;
1921  ***      0                                         eval {
1922  ***      0                                            $row = $dbh->selectrow_arrayref($sql);
1923                                                     };
1924  ***      0      0                                  if ( $EVAL_ERROR ) {
1925  ***      0                                            MKDEBUG && _d($EVAL_ERROR);
1926  ***      0                                            return 0;
1927                                                     }
1928  ***      0      0      0                           if ( !$row->[0] || $row->[0] ne $tbl ) {
1929  ***      0                                            MKDEBUG && _d('Table does not exist');
1930  ***      0                                            return 0;
1931                                                     }
1932                                                  
1933  ***      0                                         MKDEBUG && _d('Table exists; no privs to check');
1934  ***      0      0                                  return 1 unless $args{all_privs};
1935                                                  
1936  ***      0                                         $sql = "SHOW FULL COLUMNS FROM $db_tbl";
1937  ***      0                                         MKDEBUG && _d($sql);
1938  ***      0                                         eval {
1939  ***      0                                            $row = $dbh->selectrow_hashref($sql);
1940                                                     };
1941  ***      0      0                                  if ( $EVAL_ERROR ) {
1942  ***      0                                            MKDEBUG && _d($EVAL_ERROR);
1943  ***      0                                            return 0;
1944                                                     }
1945  ***      0      0                                  if ( !scalar keys %$row ) {
1946  ***      0                                            MKDEBUG && _d('Table has no columns:', Dumper($row));
1947  ***      0                                            return 0;
1948                                                     }
1949  ***      0             0                           my $privs = $row->{privileges} || $row->{Privileges};
1950                                                  
1951  ***      0                                         $sql = "DELETE FROM $db_tbl LIMIT 0";
1952  ***      0                                         MKDEBUG && _d($sql);
1953  ***      0                                         eval {
1954  ***      0                                            $dbh->do($sql);
1955                                                     };
1956  ***      0      0                                  my $can_delete = $EVAL_ERROR ? 0 : 1;
1957                                                  
1958  ***      0                                         MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
1959                                                        ($can_delete ? 'delete' : ''));
1960                                                  
1961  ***      0      0      0                           if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
1962                                                            && $can_delete) ) {
1963  ***      0                                            MKDEBUG && _d('User does not have all privs');
1964  ***      0                                            return 0;
1965                                                     }
1966                                                  
1967  ***      0                                         MKDEBUG && _d('User has all privs');
1968  ***      0                                         return 1;
1969                                                  }
1970                                                  
1971                                                  sub get_engine {
1972  ***      0                    0                    my ( $self, $ddl, $opts ) = @_;
1973  ***      0                                         my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
1974  ***      0                                         MKDEBUG && _d('Storage engine:', $engine);
1975  ***      0             0                           return $engine || undef;
1976                                                  }
1977                                                  
1978                                                  sub get_keys {
1979  ***      0                    0                    my ( $self, $ddl, $opts, $is_nullable ) = @_;
1980  ***      0                                         my $engine        = $self->get_engine($ddl);
1981  ***      0                                         my $keys          = {};
1982  ***      0                                         my $clustered_key = undef;
1983                                                  
1984                                                     KEY:
1985  ***      0                                         foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
1986                                                  
1987  ***      0      0                                     next KEY if $key =~ m/FOREIGN/;
1988                                                  
1989  ***      0                                            my $key_ddl = $key;
1990  ***      0                                            MKDEBUG && _d('Parsed key:', $key_ddl);
1991                                                  
1992  ***      0      0                                     if ( $engine !~ m/MEMORY|HEAP/ ) {
1993  ***      0                                               $key =~ s/USING HASH/USING BTREE/;
1994                                                        }
1995                                                  
1996  ***      0                                            my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
1997  ***      0                                            my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
1998  ***      0             0                              $type = $type || $special || 'BTREE';
      ***                    0                        
1999  ***      0      0      0                              if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
2000                                                           && $engine =~ m/HEAP|MEMORY/i )
2001                                                        {
2002  ***      0                                               $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
2003                                                        }
2004                                                  
2005  ***      0                                            my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
2006  ***      0      0                                     my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
2007  ***      0                                            my @cols;
2008  ***      0                                            my @col_prefixes;
2009  ***      0                                            foreach my $col_def ( split(',', $cols) ) {
2010  ***      0                                               my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
2011  ***      0                                               push @cols, $name;
2012  ***      0                                               push @col_prefixes, $prefix;
2013                                                        }
2014  ***      0                                            $name =~ s/`//g;
2015                                                  
2016  ***      0                                            MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
2017                                                  
2018  ***      0                                            $keys->{$name} = {
2019                                                           name         => $name,
2020                                                           type         => $type,
2021                                                           colnames     => $cols,
2022                                                           cols         => \@cols,
2023                                                           col_prefixes => \@col_prefixes,
2024                                                           is_unique    => $unique,
2025  ***      0                                               is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
2026  ***      0                                               is_col       => { map { $_ => 1 } @cols },
2027                                                           ddl          => $key_ddl,
2028                                                        };
2029                                                  
2030  ***      0      0      0                              if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
2031  ***      0                                               my $this_key = $keys->{$name};
2032  ***      0      0      0                                 if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
2033  ***      0                                                  $clustered_key = 'PRIMARY';
2034                                                           }
2035                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
2036  ***      0                                                  $clustered_key = $this_key->{name};
2037                                                           }
2038  ***      0                                               MKDEBUG && $clustered_key && _d('This key is the clustered key');
2039                                                        }
2040                                                     }
2041                                                  
2042  ***      0                                         return $keys, $clustered_key;
2043                                                  }
2044                                                  
2045                                                  sub get_fks {
2046  ***      0                    0                    my ( $self, $ddl, $opts ) = @_;
2047  ***      0                                         my $fks = {};
2048                                                  
2049  ***      0                                         foreach my $fk (
2050                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
2051                                                     {
2052  ***      0                                            my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
2053  ***      0                                            my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
2054  ***      0                                            my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
2055                                                  
2056  ***      0      0      0                              if ( $parent !~ m/\./ && $opts->{database} ) {
2057  ***      0                                               $parent = "`$opts->{database}`.$parent";
2058                                                        }
2059                                                  
2060  ***      0                                            $fks->{$name} = {
2061                                                           name           => $name,
2062                                                           colnames       => $cols,
2063  ***      0                                               cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                      
2064                                                           parent_tbl     => $parent,
2065                                                           parent_colnames=> $parent_cols,
2066  ***      0                                               parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                      
2067                                                           ddl            => $fk,
2068                                                        };
2069                                                     }
2070                                                  
2071  ***      0                                         return $fks;
2072                                                  }
2073                                                  
2074                                                  sub remove_auto_increment {
2075  ***      0                    0                    my ( $self, $ddl ) = @_;
2076  ***      0                                         $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
2077  ***      0                                         return $ddl;
2078                                                  }
2079                                                  
2080                                                  sub remove_secondary_indexes {
2081  ***      0                    0                    my ( $self, $ddl ) = @_;
2082  ***      0                                         my $sec_indexes_ddl;
2083  ***      0                                         my $tbl_struct = $self->parse($ddl);
2084                                                  
2085  ***      0      0      0                           if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
2086  ***      0                                            my $clustered_key = $tbl_struct->{clustered_key};
2087  ***      0             0                              $clustered_key  ||= '';
2088                                                  
2089  ***      0                                            my @sec_indexes   = map {
2090  ***      0                                               my $key_def = $_->{ddl};
2091  ***      0                                               $key_def =~ s/([\(\)])/\\$1/g;
2092  ***      0                                               $ddl =~ s/\s+$key_def//;
2093  ***      0                                               "ADD $_->{ddl}";
2094                                                        }
2095  ***      0                                            grep { $_->{name} ne $clustered_key }
2096  ***      0                                            values %{$tbl_struct->{keys}};
2097  ***      0                                            MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
2098                                                  
2099  ***      0      0                                     if ( @sec_indexes ) {
2100  ***      0                                               $sec_indexes_ddl = join(' ', @sec_indexes);
2101  ***      0                                               $sec_indexes_ddl =~ s/,$//;
2102                                                        }
2103                                                  
2104  ***      0                                            $ddl =~ s/,(\n\) )/$1/s;
2105                                                     }
2106                                                     else {
2107  ***      0                                            MKDEBUG && _d('Not removing secondary indexes from',
2108                                                           $tbl_struct->{engine}, 'table');
2109                                                     }
2110                                                  
2111  ***      0                                         return $ddl, $sec_indexes_ddl, $tbl_struct;
2112                                                  }
2113                                                  
2114                                                  sub _d {
2115  ***      0                    0                    my ($package, undef, $line) = caller 0;
2116  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2117  ***      0                                              map { defined $_ ? $_ : 'undef' }
2118                                                          @_;
2119  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2120                                                  }
2121                                                  
2122                                                  1;
2123                                                  
2124                                                  # ###########################################################################
2125                                                  # End TableParser package
2126                                                  # ###########################################################################
2127                                                  
2128                                                  # ###########################################################################
2129                                                  # This is a combination of modules and programs in one -- a runnable module.
2130                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2131                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2132                                                  #
2133                                                  # Check at the end of this package for the call to main() which actually runs
2134                                                  # the program.
2135                                                  # ###########################################################################
2136                                                  package mk_parallel_restore;
2137                                                  
2138          21                   21           188   use English qw(-no_match_vars);
              21                                 68   
              21                                188   
2139          21                   21           160   use File::Basename qw(dirname);
              21                                 51   
              21                                295   
2140          21                   21           151   use File::Find;
              21                                 51   
              21                                198   
2141          21                   21           137   use File::Spec;
              21                                 48   
              21                                197   
2142          21                   21           256   use File::Temp;
              21                                 64   
              21                                289   
2143          21                   21           170   use List::Util qw(max sum);
              21                                 53   
              21                                122   
2144          21                   21           130   use POSIX;
              21                                 55   
              21                                133   
2145          21                   21           198   use Time::HiRes qw(time);
              21                                 57   
              21                                166   
2146          21                   21           140   use Data::Dumper;
              21                                 57   
              21                                129   
2147                                                  $Data::Dumper::Indent    = 1;
2148                                                  $Data::Dumper::Sortkeys  = 1;
2149                                                  $Data::Dumper::Quotekeys = 0;
2150                                                  
2151  ***     21            50     21           139   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              21                                 49   
              21                                365   
2152                                                  
2153                                                  Transformers->import(qw(shorten secs_to_time ts));
2154                                                  
2155                                                  # Global variables.
2156                                                  my $last_bytes_done = 0;
2157                                                  
2158                                                  sub main {
2159  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
2160                                                  
2161                                                     # ########################################################################
2162                                                     # Get configuration information.
2163                                                     # ########################################################################
2164  ***      0                                         my $dp = new DSNParser();
2165  ***      0                                         my $o  = new OptionParser(
2166                                                        strict      => 0,
2167                                                        prompt      => '[OPTION]... PATH [PATH]...',
2168                                                        description => 'loads files into MySQL in parallel.',
2169                                                     );
2170  ***      0                                         $o->get_specs();
2171  ***      0                                         $o->get_opts();
2172                                                  
2173  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
2174                                                  
2175  ***      0      0                                  $o->set('threads', max(2, MaatkitCommon::get_number_of_cpus()))
2176                                                        unless $o->got('threads');
2177                                                  
2178                                                     # ########################################################################
2179                                                     # Process options.
2180                                                     # ########################################################################
2181  ***      0                                         $o->set('base-dir', File::Spec->rel2abs($o->get('base-dir')));
2182                                                  
2183  ***      0      0                                  if ( $o->get('quiet') ) {
2184  ***      0                                            $o->set('verbose', 0);
2185                                                     }
2186                                                  
2187  ***      0      0                                  if ( $o->get('csv') ) {
2188  ***      0                                            $o->set('tab', 1);
2189                                                     }
2190                                                  
2191  ***      0      0                                  if ( $o->get('tab') ) {
2192  ***      0      0                                     $o->set('commit', 1)             unless $o->get('commit');
2193  ***      0      0                                     $o->set('disable-keys', 1)       unless $o->got('disable-keys');
2194  ***      0      0                                     $o->set('no-auto-value-on-0', 1) unless $o->got('no-auto-value-on-0');
2195  ***      0      0                                     $o->set('bin-log', 0)            unless $o->got('bin-log');
2196  ***      0      0                                     $o->set('unique-checks', 0)      unless $o->got('unique-checks');
2197  ***      0      0                                     $o->set('foreign-key-checks', 0) unless $o->got('foreign-key-checks');
2198                                                     }
2199                                                  
2200  ***      0      0                                  if ( !@ARGV ) {
2201  ***      0                                            $o->save_error("You did not specify any files to restore");
2202                                                     }
2203                                                  
2204  ***      0                                         foreach my $opt ( qw(bulk-insert-buffer-size local ignore replace) ) {
2205  ***      0      0      0                              if ( $o->got($opt) && !$o->get('tab') ) {
2206  ***      0                                               $o->save_error("Option --$opt is ineffective without --tab or --csv");
2207                                                        }
2208                                                     }
2209                                                  
2210  ***      0      0                                  if ( $o->get('fifo') ) {
2211  ***      0      0                                     if ( !$o->got('umask') ) {
2212  ***      0                                               $o->set('umask', 0);
2213                                                        }
2214                                                     }
2215                                                  
2216  ***      0      0                                  if ( $o->get('umask') ) {
2217  ***      0                                            umask oct($o->get('umask'));
2218                                                     }
2219                                                  
2220                                                     # See issue 31.
2221  ***      0      0                                  my $biggest_first = $o->got('biggest-first') ? $o->get('biggest-first')
      ***             0                               
2222                                                                       : @ARGV > 1                ? 0
2223                                                                       : $o->get('biggest-first'); # default from POD
2224  ***      0                                         $o->set('biggest-first', $biggest_first);
2225                                                  
2226  ***      0                                         $o->usage_or_errors();
2227                                                  
2228                                                     # ########################################################################
2229                                                     # If --pid, check it first since we'll die if it already exits.
2230                                                     # ########################################################################
2231  ***      0                                         my $daemon;
2232  ***      0      0                                  if ( $o->get('pid') ) {
2233                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
2234                                                        # in the the scope of main() because when it's destroyed it automatically
2235                                                        # removes the PID file.
2236  ***      0                                            $daemon = new Daemon(o=>$o);
2237  ***      0                                            $daemon->make_PID_file();
2238                                                     }
2239                                                     
2240                                                  
2241                                                     # ########################################################################
2242                                                     # Make common modules.
2243                                                     # ########################################################################
2244  ***      0                                         my $q  = new Quoter();
2245  ***      0                                         my $tp = new TableParser(Quoter => $q);
2246  ***      0                                         my %common_modules = (
2247                                                        o  => $o,
2248                                                        dp => $dp,
2249                                                        q  => $q,
2250                                                        tp => $tp,
2251                                                     );
2252                                                  
2253                                                     # ########################################################################
2254                                                     # Connect.
2255                                                     # ########################################################################
2256  ***      0      0                                  if ( $o->get('ask-pass') ) {
2257  ***      0                                            $o->set('password', OptionParser::prompt_noecho("Enter password: "));
2258                                                     }
2259  ***      0                                         my $dbh = get_cxn(o=>$o, dp=>$dp);
2260  ***      0                                         $dbh->{InactiveDestroy}  = 1;         # Don't die on fork().
2261  ***      0                                         $dbh->{FetchHashKeyName} = 'NAME_lc'; # Lowercases all column names for fetchrow_hashref()
2262                                                  
2263                                                     # Turn off binary logging on the main dbh else some things
2264                                                     # like --create-databases will replicate.
2265  ***      0      0                                  _do($dbh, $o->get('dry-run'), 'SET SQL_LOG_BIN=0') unless $o->get('bin-log');
2266                                                  
2267                                                     # ########################################################################
2268                                                     # Discover files to be restored.
2269                                                     # ########################################################################
2270  ***      0                                         my @tables_to_do;
2271  ***      0                                         my @view_files;
2272  ***      0                                         my %files_for_table;
2273  ***      0                                         my %size_for_table;
2274  ***      0                                         my %size_for_file;
2275  ***      0                                         my %chunks_for_table;
2276  ***      0                                         my %stats;
2277  ***      0                                         my $known_filetypes = 'sql|txt|csv';
2278  ***      0                                         my $bytes = 0; # For progress measurements
2279                                                  
2280                                                     {
2281                                                     # These vars aren't needed outside this local scope.
2282  ***      0                                         my $databases       = $o->get('databases');
      ***      0                                      
2283  ***      0                                         my $databases_regex = $o->get('databases-regex');
2284  ***      0                                         my $tables          = $o->get('tables');
2285  ***      0                                         my $tables_regex    = $o->get('tables-regex');
2286  ***      0                                         my %has_tables;
2287                                                  
2288                                                     # Find directories and files and save them.
2289                                                     File::Find::find(
2290                                                        {  no_chdir => 1,
2291                                                           wanted   => sub {
2292  ***      0                    0                             my ( $dir, $filename ) = ($File::Find::dir, $File::Find::name);
2293  ***      0      0      0                                    if ( -f $filename && $filename !~ m/00_master/ ) {
      ***             0      0                        
2294  ***      0                                                     my ($vol, $dirs, $file) = File::Spec->splitpath( $filename );
2295  ***      0      0                                              if ( $file =~ m/\.(?:$known_filetypes)(?:\.\d+)?(?:\.gz)?$/ ) {
2296  ***      0                                                        my @dirs       = grep { $_ } File::Spec->splitdir($dir);
      ***      0                                      
2297  ***      0                                                        my $db         = $dirs[-1];
2298  ***      0             0                                          my $restore_db = $o->get('database') || $dirs[-1];
2299  ***      0                                                        my ($tbl)      = $file =~ m/^(?:\d\d_)?([^.]+)/;
2300                                                  
2301  ***      0      0      0                                          if ( ( !$databases || exists($databases->{$db}) )
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
2302                                                                       && ( !$databases_regex || $db =~ m/$databases_regex/ )
2303                                                                       && ( !exists $o->get('ignore-databases')->{$db} )
2304                                                                       && ( !exists $o->get('ignore-tables')->{$tbl} )
2305                                                                       && ( !exists $o->get('ignore-tables')->{"$db.$tbl"} )
2306                                                                       && ( !$tables || exists($tables->{$tbl}) )
2307                                                                       && ( !$tables_regex || $tbl =~ m/$tables_regex/ ) )
2308                                                                    {
2309  ***      0      0      0                                             if ( filetype($file) !~ m/sql/ && !$o->get('tab') ) {
2310  ***      0                                                              die "$filename isn't a SQL file and you didn't tell me "
2311                                                                             . "to load tab-delimited files.  Maybe you should "
2312                                                                             . "specify the --tab option.\n";
2313                                                                       }
2314                                                  
2315  ***      0      0                                                    if ( $o->get('only-empty-databases') ) {
2316  ***      0      0      0                                                if ( defined $has_tables{$restore_db}
2317                                                                               && $has_tables{$restore_db} ) {
2318  ***      0                                                                 info($o, 1, "Skipping file $filename because "
2319                                                                                . "database $restore_db is not empty");
2320  ***      0                                                                 return;
2321                                                                          }
2322                                                  
2323  ***      0                                                              my $tbls;
2324  ***      0                                                              eval {
2325  ***      0                                                                 my $sql = "SHOW TABLES FROM ".$q->quote($restore_db);
2326  ***      0                                                                 MKDEBUG && _d($sql);
2327  ***      0                                                                 $tbls = $dbh->selectall_arrayref($sql);
2328                                                                          };
2329  ***      0      0                                                       if ( $EVAL_ERROR ) {
2330                                                                             # An error may indicate that the db doesn't exist.
2331  ***      0                                                                 MKDEBUG && _d($EVAL_ERROR);
2332  ***      0                                                                 $has_tables{$restore_db} = 0;
2333                                                                          }
2334                                                                          else {
2335  ***      0                                                                 $has_tables{$restore_db} = scalar @$tbls;
2336  ***      0                                                                 MKDEBUG && _d($restore_db, 'has',
2337                                                                                $has_tables{$restore_db}, 'tables');
2338  ***      0      0                                                          if ( $has_tables{$restore_db} ) {
2339  ***      0                                                                    info($o, 1, "Skipping file $filename because "
2340                                                                                   . "database $restore_db is not empty");
2341  ***      0                                                                    return;
2342                                                                             }
2343                                                                          }
2344                                                                       }
2345                                                  
2346  ***      0                                                           $stats{files}++;
2347  ***      0                                                           push @{$files_for_table{$restore_db}->{$tbl}}, $filename;
      ***      0                                      
2348  ***      0                                                           my $size = -s $filename; # For progress measurements
2349  ***      0                                                           $bytes += $size;
2350  ***      0                                                           $size_for_table{$restore_db}->{$tbl} += $size;
2351  ***      0                                                           $size_for_file{$filename} = $size;
2352  ***      0                                                           push @tables_to_do, { # This pushes a dupe, filtered later.
2353                                                                          D => $restore_db,
2354                                                                          N => $tbl,
2355                                                                       };
2356                                                                    }
2357                                                                    else {
2358  ***      0                                                           MKDEBUG && _d($db, $tbl, "doesn't pass filters");
2359                                                                    }
2360                                                  
2361                                                                    # Check if a chunks file for this table exits. This file
2362                                                                    # is used for resuming interrupted restores.
2363  ***      0                                                        my $chunks_file = $dirs . $tbl . '.chunks';
2364  ***      0      0      0                                          if ( !exists $chunks_for_table{$restore_db}->{$tbl}
2365                                                                         && -f $chunks_file ) {
2366  ***      0      0                                                    open my $CHUNKS_FILE, "< $chunks_file"
2367                                                                          or die "Cannot open $file: $OS_ERROR";
2368  ***      0                                                           my $chunks = do { local $/ = undef; <$CHUNKS_FILE> };
      ***      0                                      
      ***      0                                      
2369  ***      0      0                                                    close $CHUNKS_FILE
2370                                                                          or die "Cannot close $file: $OS_ERROR";
2371  ***      0                                                           push @{ $chunks_for_table{$restore_db}->{$tbl} },
      ***      0                                      
2372                                                                          split(/\n/, $chunks);
2373                                                                    }
2374                                                                 }
2375                                                              }
2376                                                              elsif ( !-d $filename && $filename !~ m/00_master_data.sql/ ) {
2377  ***      0                                                     info($o, 1, "Skipping file $filename");
2378                                                              }
2379                                                           },
2380                                                        },
2381  ***      0                                            map { File::Spec->rel2abs($_) } @ARGV
      ***      0                                      
2382                                                     );
2383                                                     }
2384                                                  
2385                                                     # ########################################################################
2386                                                     # Canonicalize table list in the order they were discovered, filtering out
2387                                                     # tables that should not be done.
2388                                                     # ########################################################################
2389                                                     {
2390  ***      0                                            my %seen;
      ***      0                                      
2391  ***      0                                            @tables_to_do = grep { !$seen{$_->{D}}->{$_->{N}}++ } @tables_to_do;
      ***      0                                      
2392  ***      0                                            $stats{tables} = scalar(@tables_to_do);
2393                                                  
2394  ***      0      0                                     if ( $o->get('create-databases') ) {
2395  ***      0                                               my %dbs;
2396  ***      0                                               map { $dbs{ $_->{D} }++ } @tables_to_do;
      ***      0                                      
2397  ***      0                                               foreach my $db ( keys %dbs ) {
2398  ***      0                                                  _do($dbh, $o->get('dry-run'),
2399                                                                 "CREATE DATABASE IF NOT EXISTS " . $q->quote($db));
2400                                                           }
2401                                                        }
2402                                                     }
2403                                                  
2404                                                     # #########################################################################
2405                                                     # Design the format for printing out.
2406                                                     # #########################################################################
2407  ***      0                                         my ( $maxdb, $maxtbl);
2408  ***      0                                         $maxdb  = max(8, map { length($_->{D}) } @tables_to_do);
      ***      0                                      
2409  ***      0                                         $maxtbl = max(5, map { length($_->{N}) } @tables_to_do);
      ***      0                                      
2410  ***      0                                         my $format = "%-${maxdb}s %-${maxtbl}s %5s %5s %6s %7s";
2411  ***      0                                         info($o, 2, sprintf($format, qw(DATABASE TABLE FILES TIME STATUS THREADS)));
2412                                                  
2413                                                     # This signal handler will do nothing but wake up the sleeping parent process
2414                                                     # and record the exit status and time of the child that exited (as a side
2415                                                     # effect of not discarding the signal).  Due to Solaris's signal handling and
2416                                                     # File::Find's use of forking, this must go after File::Find.  See
2417                                                     # bug #1887102.
2418  ***      0                                         my %exited_children;
2419                                                     $SIG{CHLD} = sub {
2420  ***      0                    0                       my $kid;
2421  ***      0                                            while (($kid = waitpid(-1, POSIX::WNOHANG)) > 0) {
2422                                                           # Must right-shift to get the actual exit status of the child.
2423  ***      0                                               $exited_children{$kid}->{exit_status} = $CHILD_ERROR >> 8;
2424  ***      0                                               $exited_children{$kid}->{exit_time}   = time();
2425                                                        }
2426  ***      0                                         };
2427                                                  
2428                                                     # Save the table sizes to make testing more reliable.
2429  ***      0                                         foreach my $tbl ( @tables_to_do ) {
2430  ***      0                                            $tbl->{Z} = $size_for_table{ $tbl->{D} }->{ $tbl->{N} };
2431                                                     }
2432                                                  
2433  ***      0      0                                  if ( $o->get('biggest-first') ) {
2434  ***      0                                            @tables_to_do = sort { $b->{Z} <=> $a->{Z} } @tables_to_do;
      ***      0                                      
2435                                                     }
2436                                                  
2437                                                     # #########################################################################
2438                                                     # Assign the work to child processes.  Initially just start --threads
2439                                                     # number of children.  Each child that exits will trigger a new one to
2440                                                     # start after that.
2441                                                     # #########################################################################
2442  ***      0                                         my $start = time();
2443  ***      0                                         my $done  = 0; # For progress measurements. 
2444                                                  
2445  ***      0                                         my %kids;
2446  ***      0             0                           while ( @tables_to_do || %kids ) {
2447                                                  
2448                                                        # Wait for the MySQL server to become responsive.
2449  ***      0                                            my $tries = 0;
2450  ***      0             0                              while ( !$dbh->ping && $tries++ < $o->get('wait') ) {
2451  ***      0                                               sleep(1);
2452  ***      0                                               eval {
2453  ***      0                                                  $dbh = get_cxn(%common_modules);
2454                                                           };
2455  ***      0      0                                        if ( $EVAL_ERROR ) {
2456  ***      0                                                  info($o, 0, 'Waiting: ' . scalar(localtime) . ' '
2457                                                                 . mysql_error_msg($EVAL_ERROR));
2458                                                           }
2459                                                        }
2460  ***      0      0                                     if ( $tries >= $o->get('wait') ) {
2461  ***      0                                               die "Too many retries, exiting.\n";
2462                                                        }
2463                                                  
2464                                                        # Start a new child process.
2465  ***      0             0                              while ( @tables_to_do && $o->get('threads') > keys %kids ) {
2466  ***      0                                               my $todo = shift @tables_to_do;
2467  ***      0                                               $todo->{time} = time;
2468  ***      0                                               my $pid = fork();
2469  ***      0      0                                        die "Can't fork: $OS_ERROR" unless defined $pid;
2470  ***      0      0                                        if ( $pid ) {              # I'm the parent
2471  ***      0                                                  $kids{$pid} = $todo;
2472                                                           }
2473                                                           else {                     # I'm the child
2474  ***      0                                                  $SIG{CHLD} = 'DEFAULT'; # See bug #1886444
2475  ***      0                                                  MKDEBUG && _d("PID", $PID, "got", Dumper($todo));
2476  ***      0                                                  my $exit_status = 0;
2477  ***      0             0                                    $exit_status = do_table(
2478                                                                 file_types  => $known_filetypes,
2479                                                                 db          => $todo->{D},
2480                                                                 tbl         => $todo->{N},
2481                                                                 files       => $files_for_table{$todo->{D}}->{$todo->{N}},
2482                                                                 file_size   => \%size_for_file,
2483                                                                 tbl_chunks  => \%chunks_for_table,
2484                                                                 %common_modules,
2485                                                              ) || $exit_status;
2486  ***      0                                                  exit($exit_status);
2487                                                           }
2488                                                        }
2489                                                  
2490                                                        # Possibly wait for child.
2491  ***      0                                            my $reaped = 0;
2492  ***      0                                            foreach my $kid ( keys %exited_children ) {
2493  ***      0                                               my $status = $exited_children{$kid};
2494  ***      0                                               my $todo   = $kids{$kid};
2495  ***      0                                               my $stat   = $status->{exit_status};
2496  ***      0                                               my $time   = $status->{exit_time} - $todo->{time};
2497  ***      0                                               info($o, 2, sprintf($format, @{$todo}{qw(D N)},
      ***      0                                      
2498  ***      0                                                  scalar(@{$files_for_table{$todo->{D}}->{$todo->{N}}}),
2499                                                              sprintf('%.2f', $time), $stat, scalar(keys %kids)));
2500  ***      0      0                                        $stats{ $stat ? 'failure' : 'success' }++;
2501  ***      0                                               $stats{time} += $time;
2502  ***      0                                               delete $kids{$kid};
2503  ***      0                                               delete $exited_children{$kid};
2504  ***      0                                               $reaped = 1;
2505  ***      0                                               $done += $todo->{Z};
2506                                                           # Reap progress report. See sub bytes_done_from_processlist() below.
2507  ***      0      0                                        print_progress_report($o, $done, $dbh, $bytes, $start)
2508                                                              if $o->get('progress');
2509                                                        }
2510                                                  
2511  ***      0      0                                     if ( !$reaped ) {
2512                                                           # Don't busy-wait.  But don't wait forever either, as a child may exit
2513                                                           # and signal while we're not sleeping, so if we sleep forever we may
2514                                                           # not get the signal.
2515  ***      0                                               sleep(1);
2516                                                           # Sleep progress report. See sub bytes_done_from_processlist() below.
2517  ***      0      0                                        print_progress_report($o, $done, $dbh, $bytes, $start)
2518                                                              if $o->get('progress');
2519                                                        }
2520                                                     }
2521                                                  
2522                                                     # Print final progress report which will show 100% done.
2523                                                     # undef for the dbh param prevents checking the proclist
2524                                                     # because all children are supposed to be done at this point.
2525  ***      0      0                                  print_progress_report($o, $done, undef, $bytes, $start)
2526                                                        if $o->get('progress');
2527                                                  
2528  ***      0                                         $stats{wallclock} = time() - $start;
2529                                                  
2530  ***      0      0                                  info($o, 1, sprintf(
2531                                                        '%5d tables, %5d files, %5d successes, %2d failures, '
2532                                                        . '%6.2f wall-clock time, %6.2f load time',
2533                                                           map {
2534  ***      0                                                  $stats{$_} || 0
2535                                                           } qw(tables files success failure wallclock time)
2536                                                        ));
2537                                                  
2538                                                     # Exit status is 1 if there were any failures.
2539  ***      0      0                                  return ($stats{failure} ? 1 : 0);
2540                                                  }
2541                                                  
2542                                                  # ############################################################################
2543                                                  # Subroutines
2544                                                  # ############################################################################
2545                                                  
2546                                                  sub makefifo {
2547  ***      0                    0                    my ( $o ) = @_;
2548  ***      0                                         my $filename = File::Spec->catfile($o->get('base-dir'), "mpr_fifo_$PID");
2549  ***      0      0                                  if ( !-p $filename ) {
2550  ***      0      0                                     if ( -e $filename ) {
2551  ***      0                                               die "Cannot make fifo: $filename exists";
2552                                                        }
2553  ***      0      0                                     if ( $o->get('dry-run') ) {
2554  ***      0                                               print "mkfifo $filename\n";
2555                                                        }
2556                                                        else {
2557  ***      0      0                                        POSIX::mkfifo($filename, 0777)
2558                                                              or die "Cannot make fifo $filename: $OS_ERROR";
2559                                                        }
2560                                                     }
2561  ***      0                                         return $filename;
2562                                                  }
2563                                                  
2564                                                  sub mysql_error_msg {
2565  ***      0                    0                    my ( $text ) = @_;
2566  ***      0                                         $text =~ s/^.*?failed: (.*?) at \S+ line (\d+).*$/$1 at line $2/s;
2567  ***      0                                         return $text;
2568                                                  }
2569                                                  
2570                                                  # Prints a message.
2571                                                  sub info {
2572  ***      0                    0                    my ( $o, $level, $msg ) = @_;
2573  ***      0      0                                  if ( $level <= $o->get('verbose') ) {
2574  ***      0                                            print $msg, "\n";
2575                                                     }
2576                                                  }
2577                                                  
2578                                                  # Actually restores a table.
2579                                                  sub do_table {
2580  ***      0                    0                    my ( %args ) = @_;
2581  ***      0                                         foreach my $arg ( qw(file_types db tbl files o dp file_size tp) ) {
2582  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2583                                                     }
2584  ***      0                                         my $file_types = $args{file_types};
2585  ***      0                                         my $db         = $args{db};
2586  ***      0                                         my $tbl        = $args{tbl};
2587  ***      0                                         my @files      = @{$args{files}};
      ***      0                                      
2588  ***      0                                         my $o          = $args{o};
2589  ***      0                                         my $file_size  = $args{file_size};
2590                                                  
2591  ***      0                                         my $dry_run      = $o->get('dry-run');
2592  ***      0                                         my $exit_status  = 0;
2593  ***      0                                         my $bytes_done   = 0;
2594  ***      0                                         my $dbh          = get_cxn(%args);
2595  ***      0                                         my ($fifo, $load_from);
2596                                                  
2597                                                     # Sort files.  If it's a --tab, this will result in the following load
2598                                                     # order:
2599                                                     # * sql     (drop and create table)
2600                                                     # * txt/csv (load data into table)
2601  ***      0                                         @files = sort {
2602  ***      0                                            my $a_type = filetype($a);
2603  ***      0                                            my $b_type = filetype($b);
2604  ***      0      0                                     (index($file_types, $a_type) <=> index($file_types, $b_type))
2605                                                           || ($a cmp $b);
2606                                                     } @files;
2607                                                  
2608  ***      0      0                                  if ( $o->get('resume') ) {
2609  ***      0                                            $bytes_done = skip_finished_chunks(
2610                                                           \@files,
2611                                                           dbh => $dbh,
2612                                                           %args,
2613                                                        );
2614                                                     }
2615                                                  
2616                                                     # Newer versions of mk-parallel-dump make the first file, called
2617                                                     # 00_TBL.sql, contain only CREATE TABLE.  Then table data begins
2618                                                     # with the second file.  Older versions of mk-parallel-dump put
2619                                                     # CREATE TABLE with the first chunk of table data in the first file.
2620                                                     # skip_finished_chunks() handles both versions and removes whatever
2621                                                     # file has CREATE TABLE if necessary.  So if there's a first file
2622                                                     # and it's from a new version dump, then we need to execute it to
2623                                                     # create the table.  Else, skip_finished_chunks() determined that
2624                                                     # the table already exists.
2625  ***      0      0      0                           my $create_table = $files[0] && $files[0] =~ m/00_$tbl\.sql$/ ? shift @files                                                                  : undef;
2626  ***      0                                         MKDEBUG && _d('CREATE TABLE', $tbl, 'in', $create_table);
2627  ***      0                                         my $table_ddl;
2628  ***      0                                         my $indexes_ddl;
2629  ***      0                                         my $engine = '';
2630  ***      0      0      0                           if ( $create_table && $o->get('create-tables') ) {
2631  ***      0                                            MKDEBUG && _d('Creating table');
2632  ***      0      0                                     open my $fh, '<', $create_table
2633                                                           or die "Cannot open $create_table: $OS_ERROR";
2634  ***      0                                            $table_ddl = do { local $/ = undef; <$fh> };
      ***      0                                      
      ***      0                                      
2635  ***      0      0                                     close $fh or warn "Cannot close $create_table: $OS_ERROR";
2636                                                  
2637                                                        # Don't let engine be undef.
2638  ***      0             0                              $engine = $args{tp}->get_engine($table_ddl) || '';
2639                                                  
2640  ***      0      0                                     if ( $o->get('fast-index') ) {
2641  ***      0                                               ($table_ddl, $indexes_ddl)
2642                                                              = $args{tp}->remove_secondary_indexes($table_ddl);
2643                                                        }
2644                                                  
2645  ***      0                                            my @sql;
2646  ***      0                                            push @sql, "USE `$db`";
2647  ***      0      0                                     push @sql, 'SET SQL_LOG_BIN=0' unless $o->get('bin-log');
2648  ***      0      0                                     push @sql, 'SET FOREIGN_KEY_CHECKS=0' unless $o->get('foreign-key-checks');
2649  ***      0      0                                     push @sql, "DROP TABLE IF EXISTS `$db`.`$tbl`" if $o->get('drop-tables');
2650  ***      0                                            push @sql, $table_ddl;
2651  ***      0                                            _do($dbh, $dry_run, @sql);
2652  ***      0                                            $bytes_done += $file_size->{$create_table};
2653                                                     }
2654                                                  
2655  ***      0      0                                  _do($dbh, $dry_run, "LOCK TABLES `$db`.`$tbl` WRITE")
2656                                                        if $o->get('lock-tables');
2657  ***      0      0                                  _do($dbh, $dry_run, "TRUNCATE TABLE `$db`.`$tbl`")
2658                                                        if $o->get('truncate');
2659                                                  
2660  ***      0                                         foreach my $file ( @files ) {
2661                                                  
2662                                                        # skip_finished_chunks() undefs files which are already restored
2663  ***      0      0                                     next unless $file;
2664                                                  
2665                                                        # Make sure dbh is connected (it should be).
2666  ***      0             0                              $dbh ||= get_cxn(%args);
2667                                                  
2668                                                        # If restoring a new, "pure" dump, then $engine will already be set.
2669                                                        # Else, we're restoring an old dump in which the table won't be created
2670                                                        # until after the first file.  That means SHOW CREATE will fail on the
2671                                                        # first file, work on the second file, and then we can get the engine.
2672  ***      0      0                                     if ( !$engine ) {
2673  ***      0                                               MKDEBUG && _d('Getting table ddl and engine');
2674  ***      0      0                                        if ( !$dry_run ) {
2675  ***      0                                                  eval {
2676  ***      0                                                     $table_ddl = $dbh->selectall_arrayref("SHOW CREATE TABLE `$db`.`$tbl`")->[0]->[1];
2677                                                              };
2678  ***      0                                                  MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2679                                                           }
2680  ***      0             0                                 $engine = $args{tp}->get_engine($table_ddl || '') || '';
      ***                    0                        
2681                                                        }
2682                                                  
2683                                                        # Set options.
2684  ***      0                                            my @sql;
2685  ***      0                                            push @sql, "USE `$db`"; # For binary logging.
2686                                                  
2687  ***      0      0      0                              push @sql, "/*!40000 ALTER TABLE `$db`.`$tbl` DISABLE KEYS */"
2688                                                           if $o->get('disable-keys') && $engine eq 'MyISAM';
2689                                                  
2690  ***      0      0                                     push @sql, '/*!40101 SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO" */'
2691                                                           if $o->get('no-auto-value-on-0');
2692                                                  
2693  ***      0      0                                     push @sql, 'SET UNIQUE_CHECKS=0'
2694                                                           unless $o->get('unique-checks');
2695                                                  
2696  ***      0      0                                     push @sql, 'SET FOREIGN_KEY_CHECKS=0'
2697                                                           unless $o->get('foreign-key-checks');
2698                                                  
2699  ***      0      0                                     push @sql, 'SET SQL_LOG_BIN=0'
2700                                                           unless $o->get('bin-log');
2701                                                  
2702  ***      0      0                                     if ( my $bibs = $o->get('bulk-insert-buffer-size') ) {
2703  ***      0                                               push @sql, "SET SESSION bulk_insert_buffer_size=$bibs";
2704                                                        }
2705  ***      0                                            _do($dbh, $dry_run, @sql);
2706                                                  
2707                                                        # Restore the data.
2708  ***      0      0                                     if ( filetype($file) eq 'sql' ) {
2709  ***      0                                               $exit_status |= do_sql_file(
2710                                                              dbh  => $dbh,
2711                                                              file => $file,
2712                                                              %args,
2713                                                           );
2714                                                        }
2715                                                        else {
2716  ***      0      0                                        if ( $file =~ m/\.gz$/ ) {
2717  ***      0      0                                           if ( $o->get('fifo') ) {
2718  ***      0             0                                       $fifo ||= makefifo($o);
2719  ***      0                                                     $exit_status
2720                                                                    |= system_call($o, qq{gunzip --stdout '$file' > '$fifo' &});
2721  ***      0                                                     $load_from = $fifo;
2722                                                              }
2723                                                              else {
2724  ***      0                                                     $exit_status |= system_call($o, qq{gunzip '$file'});
2725  ***      0                                                     ( $load_from = $file ) =~ s/\.gz$//;
2726                                                              }
2727                                                           }
2728                                                           else {
2729  ***      0                                                  $load_from = $file;
2730                                                           }
2731                                                  
2732  ***      0                                               my $sql;
2733  ***      0                                               my $charset = $o->get('charset');
2734  ***      0      0                                        my $LOCAL   = $o->get('local') ? ' LOCAL' : '';
2735  ***      0      0                                        my $OPT     = $o->get('ignore')  ? 'IGNORE'
      ***             0                               
2736                                                                       : $o->get('replace') ? 'REPLACE'
2737                                                                       : '';
2738  ***      0      0                                        if ( $o->get('csv') ) {
      ***             0                               
2739  ***      0                                                  $sql  = qq{LOAD DATA$LOCAL INFILE /*done:$bytes_done $db\.$tbl*/ ? }
2740                                                                    . qq{$OPT INTO TABLE `$db`.`$tbl` }
2741                                                                    . qq{/*!50038 CHARACTER SET $charset */ }
2742                                                                    . qq{FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\\"' }
2743                                                                    . qq{LINES TERMINATED BY '\\n'};
2744                                                           }
2745                                                           elsif ( $o->get('tab') ) {
2746  ***      0                                                  $sql  = qq{LOAD DATA$LOCAL INFILE /*done:$bytes_done $db\.$tbl*/ ? }
2747                                                                    . qq{$OPT INTO TABLE `$db`.`$tbl` }
2748                                                                    . qq{/*!50038 CHARACTER SET $charset */};
2749                                                           }
2750                                                  
2751  ***      0      0                                        if ( $sql ) {
2752  ***      0      0                                           if ( $dry_run ) {
2753  ***      0                                                     print $sql, "\n";
2754                                                              }
2755                                                              else {
2756  ***      0                                                     eval {
2757  ***      0                                                        $dbh->do($sql, {}, $load_from); 
2758                                                                 };
2759  ***      0      0                                              if ( $EVAL_ERROR ) {
2760  ***      0                                                        die mysql_error_msg($EVAL_ERROR)." while restoring $db.$tbl";
2761                                                                 }
2762  ***      0                                                     $bytes_done += $file_size->{$file};
2763                                                              }
2764                                                           }
2765                                                           else {
2766  ***      0      0                                           unlink $fifo if $fifo;
2767  ***      0                                                  die "I don't understand how to load file $file\n";
2768                                                           }
2769                                                        } # .txt tab file
2770                                                  
2771  ***      0      0                                     $dbh->commit() if $o->get('commit');
2772                                                  
2773                                                     } # each file
2774                                                  
2775  ***      0      0                                  if ( $dbh ) {
2776  ***      0                                            my @sql;
2777  ***      0      0      0                              push @sql, "/*!40000 ALTER TABLE `$db`.`$tbl` ENABLE KEYS */"
2778                                                           if $o->get('disable-keys') && $engine eq 'MyISAM';
2779  ***      0      0                                     push @sql, 'UNLOCK TABLES'
2780                                                           if $o->get('lock-tables');
2781                                                  
2782                                                        # Do InnoDB fast index creation.
2783  ***      0      0      0                              if ( $o->get('fast-index') && $indexes_ddl ) {
2784  ***      0                                               push @sql, "ALTER TABLE `$db`.`$tbl` $indexes_ddl";
2785                                                        }
2786                                                  
2787  ***      0                                            _do($dbh, $dry_run, @sql);
2788                                                     }
2789                                                  
2790  ***      0      0      0                           unlink $fifo if $fifo && !$dry_run;
2791  ***      0      0                                  $dbh->disconnect() if $dbh;
2792                                                  
2793  ***      0                                         return $exit_status;
2794                                                  }
2795                                                  
2796                                                  # Execute sql statements in file through dbh->do() so that we can
2797                                                  # control things like SQL_LOG_BIN. Otherwise, we may replicate
2798                                                  # DROP TABLE statments.
2799                                                  # Returns 0 on success, 1 on failure (this is to mimic the exit
2800                                                  # status of older code).
2801                                                  sub do_sql_file {
2802  ***      0                    0                    my ( %args ) = @_;
2803  ***      0                                         foreach my $arg ( qw(o dbh file) ) {
2804  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2805                                                     }
2806  ***      0                                         my $o           = $args{o};
2807  ***      0                                         my $dbh         = $args{dbh};
2808  ***      0                                         my $file        = $args{file};
2809  ***      0                                         my $decompress  = $o->get('decompress');
2810  ***      0                                         my $exit_status = 0;
2811                                                  
2812  ***      0                                         MKDEBUG && _d('Restoring', $file);
2813                                                  
2814  ***      0                                         my $fh;
2815  ***      0      0                                  if ( $file =~ m/\.gz/ ) {
2816  ***      0      0                                     if ( !open $fh, '-|', "$decompress $file" ) {
2817  ***      0                                               warn "Cannot $decompress $file: $OS_ERROR";
2818  ***      0                                               return 1;
2819                                                        }
2820                                                     }
2821                                                     else {
2822  ***      0      0                                     if ( !open $fh, '<', "$args{file}" ) {
2823  ***      0                                               warn "Cannot open $file: $OS_ERROR";
2824  ***      0                                               return 1;
2825                                                        }
2826                                                     }
2827                                                  
2828  ***      0                                         local $INPUT_RECORD_SEPARATOR = ";\n";
2829  ***      0                                         while ( my $sql = <$fh> ) {
2830  ***      0      0                                     next if $sql =~ m/^$/;  # issue 625
2831  ***      0      0                                     if ( $o->get('dry-run') ) {
2832  ***      0                                               print $sql;
2833                                                        }
2834                                                        else {
2835  ***      0                                               eval {
2836  ***      0                                                  $dbh->do($sql);
2837                                                           };
2838  ***      0      0                                        if ( $EVAL_ERROR ) {
2839  ***      0                                                  warn mysql_error_msg($EVAL_ERROR) . " while restoring $file";
2840  ***      0                                                  $exit_status |= 1;
2841                                                           }
2842                                                        } 
2843                                                     }
2844                                                  
2845  ***      0                                         close $fh;
2846  ***      0                                         return $exit_status;
2847                                                  }
2848                                                  
2849                                                  # Undef files in $files_ref for which the rows in the corresponding
2850                                                  # chunk have already been restored.
2851                                                  # Returns the number of bytes "done" (already restored) in order to
2852                                                  # keep --progress accurate.
2853                                                  sub skip_finished_chunks {
2854  ***      0                    0                    my ( $files, %args ) = @_;
2855  ***      0                                         foreach my $arg ( qw(dbh db tbl tbl_chunks file_size o dp q tp) ) {
2856  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2857                                                     }
2858  ***      0                                         my $db        = $args{db};
2859  ***      0                                         my $tbl       = $args{tbl};
2860  ***      0                                         my $file_size = $args{file_size};
2861  ***      0                                         my $o         = $args{o};
2862  ***      0                                         my $chunks    = $args{tbl_chunks}->{$db}->{$tbl};
2863  ***      0                                         my $q         = $args{q};
2864  ***      0                                         my $dbh       = $args{dbh};
2865  ***      0                                         my $tp        = $args{tp};
2866                                                  
2867  ***      0                                         my $db_tbl = $q->quote($db, $tbl);
2868                                                  
2869  ***      0                                         MKDEBUG && _d("Checking if restore of", $db_tbl, "can be resumed");
2870                                                  
2871  ***      0      0                                  if ( !defined $chunks ) {
2872  ***      0                                            MKDEBUG && _d('Cannot resume restore: no chunks file');
2873  ***      0                                            return 0;
2874                                                     }
2875                                                  
2876  ***      0      0                                  if ( $chunks->[0] eq '1=1' ) {
2877  ***      0                                            MKDEBUG && _d('Cannot resume restore: only 1 chunk (1=1)');
2878  ***      0                                            return 0;
2879                                                     }
2880                                                  
2881  ***      0                                         $dbh->do("USE `$db`");
2882                                                  
2883  ***      0                                         my $first_missing_chunk = 0;
2884                                                     # First check that the table exists (issue 221).
2885                                                     # If not, then we resume from chunk 0 which will contain
2886                                                     # the create table def.
2887  ***      0      0                                  if ( $tp->check_table(dbh=>$dbh, db=>$db, tbl=>$tbl) ) {
2888                                                        # Table exists, so figure out the first missing chunk.
2889  ***      0                                            foreach my $chunk ( @$chunks ) {
2890  ***      0                                               my $select_chunk   = "SELECT 1 FROM $db_tbl WHERE ( $chunk ) LIMIT 1";
2891  ***      0                                               my $chunk_restored = $dbh->selectall_arrayref($select_chunk);
2892  ***      0      0                                        last if scalar @$chunk_restored == 0;
2893  ***      0                                               $first_missing_chunk++;
2894                                                        }
2895                                                     }
2896                                                     elsif ( MKDEBUG ) {
2897                                                        _d("Restoring from chunk 0 because table", $db_tbl, "does not exist");
2898                                                     }
2899                                                  
2900  ***      0                                         my $bytes_done = 0;
2901  ***      0      0                                  if ( $first_missing_chunk ) {
2902  ***      0      0                                     $first_missing_chunk -= 1 unless $o->get('atomic-resume');
2903                                                  
2904  ***      0      0                                     if ( defined $chunks->[$first_missing_chunk] ) {
2905                                                           # We need to DELETE the first missing chunk otherwise we may try to
2906                                                           # INSERT dupliate values.
2907  ***      0                                               my @sql;
2908  ***      0      0                                        push @sql, 'SET FOREIGN_KEY_CHECKS=0'
2909                                                              unless $o->get('foreign-key-checks');
2910  ***      0      0                                        push @sql, 'SET SQL_LOG_BIN=0'
2911                                                              unless $o->get('bin-log');
2912  ***      0                                               push @sql, "DELETE FROM $db_tbl WHERE $chunks->[$first_missing_chunk]";
2913  ***      0                                               _do($dbh, $o->get('dry-run'), @sql);
2914                                                        }
2915                                                  
2916  ***      0                                            my $first_file = 0;
2917  ***      0                                            my $last_file  = $first_missing_chunk - 1;
2918  ***      0      0                                     if ( $files->[0] =~ m/00_$tbl\.sql$/ ) {
2919  ***      0                                               $first_file  = 1;
2920  ***      0                                               $last_file  += 1;
2921  ***      0                                               $files->[0]  = undef;
2922                                                        }
2923  ***      0                                            MKDEBUG && _d('First chunk file', $first_file, $files->[$first_file]);
2924  ***      0                                            foreach my $file ( @$files[$first_file..$last_file] ) {
2925  ***      0                                               $bytes_done += $file_size->{$file};
2926  ***      0                                               $file = undef;
2927                                                        }
2928                                                     }
2929                                                  
2930  ***      0                                         MKDEBUG && _d('Resuming restore of', $db_tbl, 'from chunk',
2931                                                        $first_missing_chunk, 'with', $bytes_done, 'bytes already done;',
2932                                                        scalar @$chunks, 'chunks; first missing chunk:',
2933                                                        $chunks->[$first_missing_chunk]);
2934                                                  
2935  ***      0                                         return $bytes_done;
2936                                                  }
2937                                                  
2938                                                  # The following 2 subs allow us a much finer gradient of progress reporting.
2939                                                  # However, a little magick has to be wielded to insure smooth operation.
2940                                                  # Above, in the main loop there is a "reap" and a "sleep" progress report.
2941                                                  # For both, the recorded bytes done + bytes repoted via the processlist are
2942                                                  # reported. For the reap report, this is not problematic except that it
2943                                                  # doesn't happen often enough. On really big tables, we would go a long
2944                                                  # time without a reap report. Therefore, we must also do sleep reports which
2945                                                  # are printed about once every second. These give us the gradient of
2946                                                  # reporting that we want. However, sleep reports cause another problem.
2947                                                  # Occasionally, they'll report less bytes done than the previous report
2948                                                  # because the bytes done seen via the proclist increase and decrease.
2949                                                  # Mostly, they increase, but occasionally a sleep report will catch a
2950                                                  # bunch of new children who haven't done anything yet so their bytes
2951                                                  # done compared to all the children that just finished is much less.
2952                                                  # This is why we return -1 in the sub below and don't print a report.
2953                                                  sub bytes_done_from_processlist {
2954  ***      0                    0                    my ( $dbh ) = @_;
2955  ***      0                                         my $bytes_done = 0;
2956                                                  
2957  ***      0                                         my $proclist = $dbh->selectall_arrayref('SHOW PROCESSLIST');
2958  ***      0                                         foreach my $proc ( @$proclist ) {
2959  ***      0             0                              my $info = $proc->[7] || '';
2960  ***      0                                            my ( $done ) = $info =~ /LOAD DATA.+\/\*done:(\d+)\b/;
2961  ***      0             0                              $done ||= 0;
2962  ***      0                                            $bytes_done += $done;
2963                                                     }
2964                                                  
2965  ***      0      0                                  return -1 if ($bytes_done <= $last_bytes_done);
2966  ***      0                                         $last_bytes_done = $bytes_done;
2967                                                  
2968  ***      0                                         return $bytes_done;
2969                                                  }
2970                                                  
2971                                                  sub print_progress_report {
2972  ***      0                    0                    my ( $o, $done, $dbh, $bytes, $start ) = @_;
2973                                                  
2974  ***      0      0                                  my $done_from_proclist
2975                                                        =  defined $dbh ? bytes_done_from_processlist($dbh) : 0;
2976  ***      0      0                                  return if $done_from_proclist < 0;
2977                                                  
2978  ***      0                                         my $done_and_doing = $done + $done_from_proclist;
2979  ***      0                                         my $pct            = $done_and_doing / $bytes;
2980  ***      0                                         my $now            = time();
2981  ***      0                                         my $remaining      = ($now - $start) / $pct;
2982                                                  
2983  ***      0                                         info($o, 1, sprintf("done: %s/%s %6.2f%% %s remain (%s)",
2984                                                          shorten($done_and_doing), shorten($bytes), $pct * 100,
2985                                                          secs_to_time($remaining), ts($now + $remaining)));
2986                                                  
2987  ***      0                                         return;
2988                                                  }
2989                                                  
2990                                                  sub filetype {
2991  ***      0                    0                    my ( $filename ) = @_;
2992  ***      0                                         my ( $type ) = $filename =~ m/\.(sql|txt|csv)(?:\.\d+)?(?:\.gz)?$/;
2993  ***      0             0                           return $type || '';
2994                                                  }
2995                                                  
2996                                                  sub get_cxn {
2997  ***      0                    0                    my ( %args ) = @_;
2998  ***      0                                         foreach my $arg ( qw(o dp) ) {
2999  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
3000                                                     }
3001  ***      0                                         my $o  = $args{o};
3002  ***      0                                         my $dp = $args{dp};
3003                                                  
3004                                                     # DSNParser will interpret D has the default database for the connection,
3005                                                     # but in this script D means the database into which all files are loaded.
3006                                                     # Therefore, we must get the opt values and manually remove D.
3007  ***      0                                         my $dsn   = $dp->parse_options($o);
3008  ***      0                                         $dsn->{D} = undef;
3009  ***      0                                         my $dbh   = $dp->get_dbh($dp->get_cxn_params($dsn));
3010                                                  
3011  ***      0      0                                  if ( my $charset = $o->get('charset') ) {
3012  ***      0                                            $dbh->do("/*!40101 SET character_set_database=$charset */");
3013                                                     }
3014                                                  
3015  ***      0                                         return $dbh;
3016                                                  }
3017                                                  
3018                                                  sub system_call {
3019  ***      0                    0                    my ( $o, @cmd ) = @_;
3020  ***      0                                         my $exit_status = 0;
3021  ***      0      0                                  if ( $o->get('dry-run') ) {
3022  ***      0                                            print join(' ', @cmd), "\n";
3023                                                     }
3024                                                     else {
3025  ***      0                                            $exit_status = system(join(' ', @cmd));
3026                                                        # Must right-shift to get the actual exit status of the command.
3027                                                        # Otherwise the upstream exit() call that's about to happen will get a
3028                                                        # larger value than it likes, and will just report zero to waitpid().
3029  ***      0                                            $exit_status = $exit_status >> 8;
3030                                                     }
3031  ***      0                                         return $exit_status;
3032                                                  }
3033                                                  
3034                                                  # Executes $dbh->do() for each statement, unless $dry_run in which case
3035                                                  # the statements are just printed.  This could be accomplished by subclassing
3036                                                  # DBI, but this is the quick and easy solution.
3037                                                  sub _do {
3038  ***      0                    0                    my ( $dbh, $dry_run, @statements ) = @_;
3039  ***      0                                         eval {
3040  ***      0                                            foreach my $sql ( @statements ) {
3041  ***      0      0                                        next unless $sql;
3042  ***      0                                               MKDEBUG && _d($sql);
3043  ***      0      0                                        if ( $dry_run ) {
3044  ***      0                                                  print "$sql\n"
3045                                                           }
3046                                                           else {
3047  ***      0                                                  $dbh->do($sql);
3048                                                           }
3049                                                        }
3050                                                     };
3051  ***      0      0                                  warn $EVAL_ERROR if $EVAL_ERROR;
3052  ***      0                                         return;
3053                                                  }
3054                                                  
3055                                                  sub _d {
3056  ***      0                    0                    my ($package, undef, $line) = caller 0;
3057  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3058  ***      0                                              map { defined $_ ? $_ : 'undef' }
3059                                                          @_;
3060  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3061                                                  }
3062                                                  
3063                                                  # ############################################################################
3064                                                  # Run the program.
3065                                                  # ############################################################################
3066                                                  if ( !caller ) { exit main(@ARGV); }
3067                                                  
3068                                                  1; # Because this is a module as well as a script.
3069                                                  
3070                                                  # ############################################################################
3071                                                  # Documentation.
3072                                                  # ############################################################################
3073                                                  
3074                                                  =pod
3075                                                  
3076                                                  =head1 NAME
3077                                                  
3078                                                  mk-parallel-restore - Load files into MySQL in parallel.
3079                                                  
3080                                                  =head1 SYNOPSIS
3081                                                  
3082                                                    mk-parallel-restore /path/to/files
3083                                                    mk-parallel-restore --tab /path/to/files
3084                                                  
3085                                                  =head1 RISKS
3086                                                  
3087                                                  The following section is included to inform users about the potential risks,
3088                                                  whether known or unknown, of using this tool.  The two main categories of risks
3089                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
3090                                                  tools) and those created by bugs.
3091                                                  
3092                                                  mk-parallel-restore is not a backup program!  It is only for fast data imports,
3093                                                  for purposes such as loading test data into a system quickly.  Do not use
3094                                                  mk-parallel-restore for backups.  mk-parallel-restore inserts data unless you
3095                                                  use the L<"--dry-run"> option.
3096                                                  
3097                                                  At the time of this release, we know of no bugs that could cause serious harm to
3098                                                  users.
3099                                                  
3100                                                  The authoritative source for updated information is always the online issue
3101                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
3102                                                  see a list of such issues at the following URL:
3103                                                  L<http://www.maatkit.org/bugs/mk-parallel-restore>.
3104                                                  
3105                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
3106                                                  
3107                                                  =head1 DESCRIPTION
3108                                                  
3109                                                  mk-parallel-restore is a way to load SQL or delimited-file dumps into MySQL
3110                                                  in parallel at high speed.  It is especially designed for restoring files
3111                                                  dumped by L<mk-parallel-dump>.  It automatically
3112                                                  detects whether a file contains SQL or delimited data from the filename
3113                                                  extension, and either shells out to C<mysql> or executes C<LOAD DATA INFILE>
3114                                                  with the file.  On UNIX-like systems, it will even make a FIFO to decompress
3115                                                  gzipped files for C<LOAD DATA INFILE>.
3116                                                  
3117                                                  By default it discovers all files in the directory you specify on the command
3118                                                  line.  It uses the file's parent directory as the database name and the file's
3119                                                  name (up to the first dot) as the table name.  It can deal with files named
3120                                                  like the following:
3121                                                  
3122                                                    dir/tbl.sql
3123                                                    dir/tbl.txt
3124                                                    dir/tbl.csv
3125                                                  
3126                                                  It is also happy with files that look like this, where C<EXT> is one of the
3127                                                  extensions just listed.
3128                                                  
3129                                                    dir/tbl.EXT.000
3130                                                    dir/tbl.EXT.000.gz
3131                                                  
3132                                                  By default, it loads C<SQL> files first, if they exist, then loads C<CSV> or
3133                                                  C<TXT> files next, in order of the numbers in the filename extension as just
3134                                                  shown.  This makes it easy for you to reload a table's definition followed by
3135                                                  its data, in case you dumped them into separate files (as happens with
3136                                                  C<mysqldump>'s C<--tab> option).  See L<mk-parallel-dump> for details on how
3137                                                  data is dumped.
3138                                                  
3139                                                  Exit status is 0 if everything went well, 1 if any files failed, and any
3140                                                  other value indicates an internal error.
3141                                                  
3142                                                  =head1 OUTPUT
3143                                                  
3144                                                  Output depends on verbosity.  When L<"--dry-run"> is given, output includes
3145                                                  commands that would be executed.
3146                                                  
3147                                                  When L<"--verbose"> is 0, there is normally no output unless there's an error.
3148                                                  
3149                                                  When L<"--verbose"> is 1, there is one line of output for the entire job,
3150                                                  showing how many tables were processed, how many files were loaded with what
3151                                                  status, how much time elapsed, and how much time the parallel load jobs added
3152                                                  up to.  If any files were skipped, the filenames are printed to the output.
3153                                                  
3154                                                  When L<"--verbose"> is 2, there's one line of output per table, showing extra
3155                                                  data such as how many threads were running when each table finished loading:
3156                                                  
3157                                                    DATABASE TABLE            FILES  TIME STATUS THREADS
3158                                                    sakila   language             2  0.07      0       2
3159                                                    sakila   film_actor           2  0.07      0       2
3160                                                    sakila   actor                2  0.06      0       2
3161                                                    sakila   payment              2  0.07      0       2
3162                                                    sakila   transport_backup     2  0.05      0       2
3163                                                    sakila   country              2  0.08      0       2
3164                                                    sakila   film                 2  0.05      0       2
3165                                                    sakila   rental               2  0.07      0       2
3166                                                  
3167                                                  =head1 SPEED OF PARALLEL LOADING
3168                                                  
3169                                                  User-contributed benchmarks are welcome.  See
3170                                                  L<http://www.paragon-cs.com/wordpress/?p=52> for one user's experiences.
3171                                                  
3172                                                  =head1 OPTIONS
3173                                                  
3174                                                  =over
3175                                                  
3176                                                  =item --ask-pass
3177                                                  
3178                                                  Prompt for a password when connecting to MySQL.
3179                                                  
3180                                                  =item --[no]atomic-resume
3181                                                  
3182                                                  default: yes
3183                                                  
3184                                                  Treat chunks as atomic when resuming restore.
3185                                                  
3186                                                  By default C<mk-parallel-restore> resumes restoration from the first chunk that
3187                                                  is missing all its rows.  For dumps of transactionally-safe tables (InnoDB),
3188                                                  it cannot happen that a chunk is only partially restored.  Therefore, restoring 
3189                                                  from the first missing chunk is safe.
3190                                                  
3191                                                  However, for dumps of non-transactionally safe tables, it is possible that a
3192                                                  chunk can be only partially restored.  In such cases, the chunk will wrongly
3193                                                  appear to be fully restored.  Therefore, you must specify C<--no-atomic-resume>
3194                                                  so that the partially restored chunk is fully restored.
3195                                                  
3196                                                  =item --base-dir
3197                                                  
3198                                                  type: string
3199                                                  
3200                                                  Directory where FIFO files will be created.
3201                                                  
3202                                                  =item --[no]biggest-first
3203                                                  
3204                                                  default: yes
3205                                                  
3206                                                  Restore the biggest tables first for highest concurrency.
3207                                                  
3208                                                  =item --[no]bin-log
3209                                                  
3210                                                  default: yes
3211                                                  
3212                                                  Enable binary logging (C<SET SQL_LOG_BIN=1>).
3213                                                  
3214                                                  Restore operations are replicated by default (SQL_LOG_BIN=1) except for
3215                                                  L<"--tab"> restores which are not replicated by default (SQL_LOG_BIN=0).
3216                                                  This prevents large loads from being logged to the server's binary log.
3217                                                  
3218                                                  The value given on the command line overrides the defaults.  Therefore,
3219                                                  specifying C<--bin-log> with L<"--tab"> will allow the L<"--tab"> restore
3220                                                  to replicate.
3221                                                  
3222                                                  =item --bulk-insert-buffer-size
3223                                                  
3224                                                  type: int
3225                                                  
3226                                                  Set bulk_insert_buffer_size before each C<LOAD DATA INFILE>.
3227                                                  
3228                                                  Has no effect without L<"--tab">.
3229                                                  
3230                                                  =item --charset
3231                                                  
3232                                                  short form: -A; type: string; default: BINARY
3233                                                  
3234                                                  Sets the connection, database, and C<LOAD DATA INFILE> character set.
3235                                                  
3236                                                  The default is C<BINARY>, which is the safest value to use for C<LOAD DATA
3237                                                  INFILE>.  Has no effect without L<"--tab">.
3238                                                  
3239                                                  =item --[no]commit
3240                                                  
3241                                                  default: yes
3242                                                  
3243                                                  Commit after each file.
3244                                                  
3245                                                  =item --config
3246                                                  
3247                                                  type: Array
3248                                                  
3249                                                  Read this comma-separated list of config files; if specified, this must be the
3250                                                  first option on the command line.
3251                                                  
3252                                                  =item --create-databases
3253                                                  
3254                                                  Create databases if they don't exist.
3255                                                  
3256                                                  =item --[no]create-tables
3257                                                  
3258                                                  default: yes
3259                                                  
3260                                                  Create tables.
3261                                                  
3262                                                  See also L<"--[no]drop-tables">.
3263                                                  
3264                                                  =item --csv
3265                                                  
3266                                                  Files are in CSV format (implies L<"--tab">).
3267                                                  
3268                                                  Changes L<"--tab"> options so the following C<LOAD DATA INFILE> statement is used:
3269                                                  
3270                                                     LOAD DATA INFILE <filename> INTO TABLE <table>
3271                                                     FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"'
3272                                                     LINES TERMINATED BY '\n';
3273                                                  
3274                                                  =item --database
3275                                                  
3276                                                  short form: -D; type: string
3277                                                  
3278                                                  Load all files into this database.
3279                                                  
3280                                                  Overrides the database which is normally specified by the directory in which the
3281                                                  files live.  Does I<not> specify a default database for the connection.
3282                                                  
3283                                                  =item --databases
3284                                                  
3285                                                  short form: -d; type: hash
3286                                                  
3287                                                  Restore only this comma-separated list of databases.
3288                                                  
3289                                                  =item --databases-regex
3290                                                  
3291                                                  type: string
3292                                                  
3293                                                  Restore only databases whose names match this regex.
3294                                                  
3295                                                  =item --decompress
3296                                                  
3297                                                  type: string; default: gzip -d -c
3298                                                  
3299                                                  Command used to decompress and print .gz files to STDOUT (like zcat).
3300                                                  
3301                                                  =item --defaults-file
3302                                                  
3303                                                  short form: -F; type: string
3304                                                  
3305                                                  Only read mysql options from the given file.  You must give an absolute
3306                                                  pathname.
3307                                                  
3308                                                  =item --[no]disable-keys
3309                                                  
3310                                                  default: yes
3311                                                  
3312                                                  Execute C<ALTER TABLE DISABLE KEYS> before each MyISAM table.
3313                                                  
3314                                                  This option only works with MyISAM tables.
3315                                                  
3316                                                  =item --[no]drop-tables
3317                                                  
3318                                                  default: yes
3319                                                  
3320                                                  Execute C<DROP TABLE IF EXISTS> before creating each table.
3321                                                  
3322                                                  =item --dry-run
3323                                                  
3324                                                  Print commands instead of executing them.
3325                                                  
3326                                                  =item --fast-index
3327                                                  
3328                                                  Do InnoDB plugin fast index creation by restoring secondary indexes after data.
3329                                                  
3330                                                  This option only works with InnoDB tables and the InnoDB plugin.
3331                                                  
3332                                                  =item --[no]fifo
3333                                                  
3334                                                  default: yes
3335                                                  
3336                                                  Stream files into a FIFO for L<"--tab">.
3337                                                  
3338                                                  Load compressed tab-separated files by piping them into a FIFO and using the
3339                                                  FIFO with C<LOAD DATA INFILE>, instead of by decompressing the files on disk.
3340                                                  Sets L<"--umask"> to 0.
3341                                                  
3342                                                  =item --[no]foreign-key-checks
3343                                                  
3344                                                  default: yes
3345                                                  
3346                                                  Set C<FOREIGN_KEY_CHECKS=1> before C<LOAD DATA INFILE>.
3347                                                  
3348                                                  =item --help
3349                                                  
3350                                                  Show help and exit.
3351                                                  
3352                                                  =item --host
3353                                                  
3354                                                  short form: -h; type: string
3355                                                  
3356                                                  Connect to host.
3357                                                  
3358                                                  =item --ignore
3359                                                  
3360                                                  Adds the C<IGNORE> modifier to C<LOAD DATA INFILE>.
3361                                                  
3362                                                  =item --ignore-databases
3363                                                  
3364                                                  type: Hash
3365                                                  
3366                                                  Ignore this comma-separated list of databases.
3367                                                  
3368                                                  =item --ignore-tables
3369                                                  
3370                                                  type: Hash
3371                                                  
3372                                                  Ignore this comma-separated list of table names.
3373                                                  
3374                                                  Table names may be qualified with the database name.
3375                                                  
3376                                                  =item --local
3377                                                  
3378                                                  Uses the C<LOCAL> option to C<LOAD DATA INFILE>.
3379                                                  
3380                                                  If you enable this option, the files are read locally by the client library, not
3381                                                  by the server.
3382                                                  
3383                                                  =item --[no]lock-tables
3384                                                  
3385                                                  Lock tables before C<LOAD DATA INFILE>.
3386                                                  
3387                                                  =item --[no]no-auto-value-on-0
3388                                                  
3389                                                  default: yes
3390                                                  
3391                                                  Set SQL C<NO_AUTO_VALUE_ON_ZERO>.
3392                                                  
3393                                                  =item --only-empty-databases
3394                                                  
3395                                                  Restore only to empty databases.
3396                                                  
3397                                                  By default mk-parallel-restore will restore tables into a database so long
3398                                                  as it exists (or is created by L<"--create-databases">).  This option is
3399                                                  a safety feature that prevents any tables from being restored into a database
3400                                                  that already has tables even if those tables are the same ones being restored.
3401                                                  If you specify this option, every database must have zero tables.
3402                                                  
3403                                                  This implicitly disables L<"--[no]resume">.  L<"--create-databases"> will work
3404                                                  if the database doesn't already exist and it creates it.
3405                                                  
3406                                                  The databases are checked after all filters (L<"--databases">, etc.)
3407                                                  
3408                                                  =item --password
3409                                                  
3410                                                  short form: -p; type: string
3411                                                  
3412                                                  Password to use when connecting.
3413                                                  
3414                                                  =item --pid
3415                                                  
3416                                                  type: string
3417                                                  
3418                                                  Create the given PID file.  The file contains the process ID of the script.
3419                                                  The PID file is removed when the script exits.  Before starting, the script
3420                                                  checks if the PID file already exists.  If it does not, then the script creates
3421                                                  and writes its own PID to it.  If it does, then the script checks the following:
3422                                                  if the file contains a PID and a process is running with that PID, then
3423                                                  the script dies; or, if there is no process running with that PID, then the
3424                                                  script overwrites the file with its own PID and starts; else, if the file
3425                                                  contains no PID, then the script dies.
3426                                                  
3427                                                  =item --port
3428                                                  
3429                                                  short form: -P; type: int
3430                                                  
3431                                                  Port number to use for connection.
3432                                                  
3433                                                  =item --progress
3434                                                  
3435                                                  Display progress messages.
3436                                                  
3437                                                  Progress is displayed each time a table finishes loading.  Progress is
3438                                                  calculated by measuring the size of each file to be loaded, and assuming all
3439                                                  bytes are created equal.  The output is the completed and total size, the
3440                                                  percent completed, estimated time remaining, and estimated completion time.
3441                                                  
3442                                                  =item --quiet
3443                                                  
3444                                                  short form: -q
3445                                                  
3446                                                  Sets L<"--verbose"> to 0.
3447                                                  
3448                                                  =item --replace
3449                                                  
3450                                                  Adds the C<REPLACE> modifier to C<LOAD DATA INFILE>.
3451                                                  
3452                                                  =item --[no]resume
3453                                                  
3454                                                  default: yes
3455                                                  
3456                                                  Resume the restore from a previously incomplete restore.
3457                                                  
3458                                                  By default, C<mk-parallel-restore> checks each table's chunks for existing
3459                                                  rows and restores only from the point where a previous restore stopped.
3460                                                  Specify L<--no-resume> to disable restore resumption and fully restores every
3461                                                  table.
3462                                                  
3463                                                  Restore resumption does not work with tab-separated files or dumps that were
3464                                                  not chunked.
3465                                                  
3466                                                  =item --set-vars
3467                                                  
3468                                                  type: string; default: wait_timeout=10000
3469                                                  
3470                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
3471                                                  string will be appended to SET and executed.
3472                                                  
3473                                                  =item --socket
3474                                                  
3475                                                  short form: -S; type: string
3476                                                  
3477                                                  Socket file to use for connection.
3478                                                  
3479                                                  =item --tab
3480                                                  
3481                                                  Load tab-separated files with C<LOAD DATA INFILE>.
3482                                                  
3483                                                  This is similar to what C<mysqlimport> does, but more flexible.
3484                                                  
3485                                                  The following options are enabled unless they are specifically disabled
3486                                                  on the command line:
3487                                                  
3488                                                     L<"--commit">
3489                                                     L<"--[no]disable-keys">
3490                                                     L<"--[no]no-auto-value-on-0">
3491                                                  
3492                                                  And the following options are disabled (C<--no-bin-log>, etc.) unless they
3493                                                  are specifically enabled on the command line:
3494                                                  
3495                                                     L<"--[no]bin-log">
3496                                                     L<"--[no]unique-checks">
3497                                                     L<"--[no]foreign-key-checks">
3498                                                  
3499                                                  =item --tables
3500                                                  
3501                                                  short form: -t; type: hash
3502                                                  
3503                                                  Restore only this comma-separated list of table names.
3504                                                  
3505                                                  Table names may be qualified with the database name.
3506                                                  
3507                                                  =item --tables-regex
3508                                                  
3509                                                  type: string
3510                                                  
3511                                                  Restore only tables whose names match this regex.
3512                                                  
3513                                                  =item --threads
3514                                                  
3515                                                  type: int; default: 2
3516                                                  
3517                                                  Specifies the number of parallel processes to run.
3518                                                  
3519                                                  The default is 2 (this is mk-parallel-restore after all -- 1 is not parallel).
3520                                                  On GNU/Linux machines, the default is the number of times 'processor' appears in
3521                                                  F</proc/cpuinfo>.  On Windows, the default is read from the environment.  In any
3522                                                  case, the default is at least 2, even when there's only a single processor.
3523                                                  
3524                                                  =item --truncate
3525                                                  
3526                                                  Run C<TRUNCATE TABLE> before C<LOAD DATA INFILE>.
3527                                                  
3528                                                  This will delete all rows from a table before loading the first tab-delimited
3529                                                  file into it.
3530                                                  
3531                                                  =item --umask
3532                                                  
3533                                                  type: string
3534                                                  
3535                                                  Set the program's C<umask> to this octal value.
3536                                                  
3537                                                  This is useful when you want created files (such as FIFO files) to be readable
3538                                                  or writable by other users (for example, the MySQL server itself).
3539                                                  
3540                                                  =item --[no]unique-checks
3541                                                  
3542                                                  default: yes
3543                                                  
3544                                                  Set C<UNIQUE_CHECKS=1> before C<LOAD DATA INFILE>.
3545                                                  
3546                                                  =item --user
3547                                                  
3548                                                  short form: -u; type: string
3549                                                  
3550                                                  User for login if not current user.
3551                                                  
3552                                                  =item --verbose
3553                                                  
3554                                                  short form: -v; cumulative: yes; default: 1
3555                                                  
3556                                                  Verbosity; can specify multiple times.
3557                                                  
3558                                                  Repeatedly specifying it increments the verbosity.  Default is 1 if not
3559                                                  specified.  See L<"OUTPUT">.
3560                                                  
3561                                                  =item --version
3562                                                  
3563                                                  Show version and exit.
3564                                                  
3565                                                  =item --wait
3566                                                  
3567                                                  short form: -w; type: time; default: 5m
3568                                                  
3569                                                  Wait limit when server is down.
3570                                                  
3571                                                  If the MySQL server crashes during loading, waits until the server comes back
3572                                                  and then continues with the rest of the files.  C<mk-parallel-restore> will
3573                                                  check the server every second until this time is exhausted, at which point it
3574                                                  will give up and exit.
3575                                                  
3576                                                  =back
3577                                                  
3578                                                  =head1 DOWNLOADING
3579                                                  
3580                                                  You can download Maatkit from Google Code at
3581                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
3582                                                  easily with a command like the following:
3583                                                  
3584                                                     wget http://www.maatkit.org/get/toolname
3585                                                     or
3586                                                     wget http://www.maatkit.org/trunk/toolname
3587                                                  
3588                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
3589                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
3590                                                  needed.  The first URL gets the latest released version of the tool, and the
3591                                                  second gets the latest trunk code from Subversion.
3592                                                  
3593                                                  =head1 ENVIRONMENT
3594                                                  
3595                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
3596                                                  the Maatkit tools:
3597                                                  
3598                                                     MKDEBUG=1 mk-....
3599                                                  
3600                                                  =head1 SYSTEM REQUIREMENTS
3601                                                  
3602                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
3603                                                  installed in any reasonably new version of Perl.
3604                                                  
3605                                                  =head1 BUGS
3606                                                  
3607                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-parallel-restore>.
3608                                                  
3609                                                  Please use Google Code Issues and Groups to report bugs or request support:
3610                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
3611                                                  discuss Maatkit.
3612                                                  
3613                                                  Please include the complete command-line used to reproduce the problem you are
3614                                                  seeing, the version of all MySQL servers involved, the complete output of the
3615                                                  tool when run with L<"--version">, and if possible, debugging output produced by
3616                                                  running with the C<MKDEBUG=1> environment variable.
3617                                                  
3618                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
3619                                                  
3620                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
3621                                                  Feedback and improvements are welcome.
3622                                                  
3623                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
3624                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
3625                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
3626                                                  
3627                                                  This program is free software; you can redistribute it and/or modify it under
3628                                                  the terms of the GNU General Public License as published by the Free Software
3629                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
3630                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
3631                                                  licenses.
3632                                                  
3633                                                  You should have received a copy of the GNU General Public License along with
3634                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
3635                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
3636                                                  
3637                                                  =head1 SEE ALSO
3638                                                  
3639                                                  See also L<mk-parallel-dump>.
3640                                                  
3641                                                  =head1 AUTHOR
3642                                                  
3643                                                  Baron Schwartz
3644                                                  
3645                                                  =head1 ABOUT MAATKIT
3646                                                  
3647                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
3648                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
3649                                                  code contributors.  Both are employed by Percona.  Financial support for
3650                                                  Maatkit development is primarily provided by Percona and its clients. 
3651                                                  
3652                                                  =head1 VERSION
3653                                                  
3654                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
3655                                                  
3656                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
57    ***      0      0      0   unless $args{$arg}
63    ***      0      0      0   exists $args{'strict'} ? :
106   ***      0      0      0   unless open my $fh, '<', $file
126   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
131   ***      0      0      0   if $para =~ /^=over/
139   ***      0      0      0   unless $para
142   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
149   ***      0      0      0   if ($para =~ /: /) { }
153   ***      0      0      0   unless $attributes{$attrib}
157   ***      0      0      0   if ($attribs{'short form'})
173   ***      0      0      0   if $para =~ /^=item/
175   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
180   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
192   ***      0      0      0   unless $para
195   ***      0      0      0   if ($para =~ /^=head1/)
199   ***      0      0      0   if $para =~ /^=item --/
203   ***      0      0      0   unless @specs
214   ***      0      0      0   if (ref $opt) { }
219   ***      0      0      0   if (not $long)
224   ***      0      0      0   if exists $$self{'opts'}{$long}
227   ***      0      0      0   if (length $long == 1)
232   ***      0      0      0   if ($short) { }
233   ***      0      0      0   if exists $$self{'short_opts'}{$short}
242   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
243   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
244   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
256   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
261   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
263   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
264   ***      0      0      0   defined $def ? :
268   ***      0      0      0   if ($long eq 'config')
272   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
285   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
290   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
295   ***      0      0      0   if ($opt =~ /default to/)
300   ***      0      0      0   if ($opt =~ /restricted to option groups/)
310   ***      0      0      0   unless $rule_ok
327   ***      0      0      0   unless exists $$self{'opts'}{$long}
351   ***      0      0      0   unless exists $$self{'opts'}{$long}
371   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
376   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
391   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
400   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
404   ***      0      0      0   if ($self->has('config'))
410   ***      0      0      0   if ($EVAL_ERROR)
411   ***      0      0      0   $self->got('config') ? :
426   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
429   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
430   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
436   ***      0      0      0   if (@ARGV and $$self{'strict'})
442   ***      0      0      0   if (@set > 1)
453   ***      0      0      0   if (@set == 0)
463   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
464   ***      0      0      0   if (exists $$self{'disables'}{$long})
471   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
483   ***      0      0      0   if $restricted_opt eq $long
484   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
489   ***      0      0      0   if (@restricted_opts)
491   ***      0      0      0   if (@restricted_opts == 1) { }
520   ***      0      0      0   unless $opt and $$opt{'type'}
523   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
526   ***      0      0      0   if (not $suffix)
532   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
533   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
548   ***      0      0      0   if ($from_key)
559   ***      0      0      0   if (defined $num) { }
560   ***      0      0      0   if ($factor)
587   ***      0      0      0   length $opt == 1 ? :
588   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
595   ***      0      0      0   length $opt == 1 ? :
596   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
603   ***      0      0      0   length $opt == 1 ? :
604   ***      0      0      0   defined $long ? :
609   ***      0      0      0   length $opt == 1 ? :
610   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
644   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
645   ***      0      0      0   unless print $self->print_usage
649   ***      0      0      0   unless print $self->print_errors
658   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
667   ***      0      0      0   unless $$self{'got_opts'}
670   ***      0      0      0   $$_{'is_negatable'} ? :
674   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
690   ***      0      0      0   $group eq 'default' ? :
696   ***      0      0      0   $$opt{'is_negatable'} ? :
699   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
708   ***      0      0      0   if ($short) { }
717   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
721   ***      0      0      0   if ($$self{'dp'})
729   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
741   ***      0      0      0   if ref $_[0] eq 'OptionParser'
744   ***      0      0      0   unless print $prompt
752   ***      0      0      0   unless print "\n"
755   ***      0      0      0   if ($EVAL_ERROR)
777   ***      0      0      0   unless open my $fh, '<', $filename
785   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
788   ***      0      0      0   if ($line eq '--')
793   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
811   ***      0      0      0   unless open my $fh, '<', $file
815   ***      0      0      0   unless $para =~ /^=pod$/m
819   ***      0      0      0   unless $para =~ /$regex/
824   ***      0      0      0   unless close $fh
838   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
853   ***      0      0      0   defined $_ ? :
893   ***      0      0      0   unless defined $val
894   ***      0      0      0   if $val eq ''
896   ***      0      0      0   if (not defined $is_numeric)
897   ***      0      0      0   $val =~ /^0|\D/ ? :
900   ***      0      0      0   if $is_numeric
910   ***      0      0      0   if (not $tbl)
919   ***      0      0      0   unless $like
1004  ***     50      0     57   if (@_ > 2)
1013  ***     50      0     19   if (not $dsn)
1025  ***     50     76      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1037  ***     50      0    152   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1043         100     76     76   if (not defined $final_props{$key})
1050  ***     50      0     76   unless exists $opts{$key}
1053  ***     50      0     19   if (my $required = $self->prop('required'))
1055  ***      0      0      0   unless $final_props{$key}
1064  ***      0      0      0   unless ref $o eq 'OptionParser'
1067  ***      0      0      0   if $o->has($_)
1077  ***      0      0      0   unless ref $dsn
1078  ***      0      0      0   $_ eq 'p' ? :
1079  ***      0      0      0   if defined $$dsn{$_}
1092  ***      0      0      0   $opts{$key}{'copy'} ? :
1106  ***     50      0     19   if ($driver eq 'Pg') { }
1138  ***     50      0     19   $cxn_string =~ /charset=utf8/ ? :
1147  ***     50      0     19   if (not $have_dbi)
1166  ***     50     19      0   if ($cxn_string =~ /mysql/i)
1174  ***     50      0     19   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1179  ***      0      0      0   if ($charset eq 'utf8') { }
1180  ***      0      0      0   unless binmode STDOUT, ':utf8'
1184  ***      0      0      0   unless binmode STDOUT
1188  ***     50      0     19   if ($self->prop('set-vars'))
1195  ***     50      0     19   if (not $dbh and $EVAL_ERROR)
1197  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1210  ***      0      0      0   if (not $tries)
1232  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1249  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1259  ***      0      0      0   unless $dsn_1
1260  ***      0      0      0   unless $dsn_2
1264  ***      0      0      0   if ($args{'overwrite'}) { }
1265  ***      0      0      0   defined $$dsn_1{$key} ? :
1268  ***      0      0      0   defined $$dsn_2{$key} ? :
1277  ***      0      0      0   defined $_ ? :
1325  ***      0      0      0   defined $args{'p_ms'} ? :
1326  ***      0      0      0   defined $args{'p_s'} ? :
1329  ***      0      0      0   if $t < 0
1331  ***      0      0      0   if $t =~ /e/
1335  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1356  ***      0      0      0   $p ? :
1363  ***      0      0      0   unless $secs
1365  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1370  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1389  ***      0      0      0   defined $args{'p'} ? :
1390  ***      0      0      0   defined $args{'d'} ? :
1397  ***      0      0      0   $num =~ /\./ || $n ? :
1406  ***      0      0      0   $gmt ? :
1412  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
1422  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1425  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
1434  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
1435  ***      0      0      0   $gmt ? :
1438  ***      0      0      0   if (defined $us)
1450  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
1451  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1461  ***      0      0      0   unless $hms
1466  ***      0      0      0   unless $hms
1471  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1487  ***      0      0      0   defined $_ ? :
1523  ***      0      0      0   defined $_ ? :
1534  ***      0      0      0   if ($sys_info or open $cpuinfo, '<', '/proc/cpuinfo')
1538  ***      0      0      0   if $cpuinfo
1541  ***      0      0      0   if $n_cpus
1545  ***      0      0      0   if ($sys_info or $OSNAME =~ /freebsd/i or $OSNAME =~ /darwin/i)
1548  ***      0      0      0   if $contents
1550  ***      0      0      0   if $n_cpus
1581  ***      0      0      0   unless $args{$arg}
1584  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1600  ***      0      0      0   unless defined(my $pid = fork)
1601  ***      0      0      0   if ($pid)
1608  ***      0      0      0   unless POSIX::setsid()
1609  ***      0      0      0   unless chdir '/'
1615  ***      0      0      0   if (-t STDIN)
1617  ***      0      0      0   unless open STDIN, '/dev/null'
1621  ***      0      0      0   if ($$self{'log_file'}) { }
1623  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1627  ***      0      0      0   unless open STDERR, '>&STDOUT'
1631  ***      0      0      0   if (-t STDOUT)
1633  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1636  ***      0      0      0   if (-t STDERR)
1638  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1649  ***      0      0      0   $self ? :
1651  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1654  ***      0      0      0   if $EVAL_ERROR
1656  ***      0      0      0   if ($pid) { }
1658  ***      0      0      0   if ($pid_is_alive) { }
1680  ***      0      0      0   if (exists $$self{'child'})
1692  ***      0      0      0   if (not $PID_file)
1699  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1701  ***      0      0      0   unless print $PID_FH $PID
1703  ***      0      0      0   unless close $PID_FH
1712  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1713  ***      0      0      0   unless unlink $$self{'PID_file'}
1725  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1731  ***      0      0      0   defined $_ ? :
1763  ***      0      0      0   unless $args{$arg}
1772  ***      0      0      0   unless $ddl
1773  ***      0      0      0   if (ref $ddl eq 'ARRAY')
1774  ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
1784  ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
1790  ***      0      0      0   if $name
1808  ***      0      0      0   unless $type
1810  ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
1814  ***      0      0      0   if (not $def =~ /NOT NULL/)
1818  ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
1849  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1863  ***      0      0      0   if ($index)
1866  ***      0      0      0   if (not $best)
1867  ***      0      0      0   if ($index) { }
1880  ***      0      0      0   unless $where
1886  ***      0      0      0   if ($$expl{'possible_keys'}) { }
1890  ***      0      0      0   if ($$expl{'key'})
1910  ***      0      0      0   unless $args{$arg}
1924  ***      0      0      0   if ($EVAL_ERROR)
1928  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
1934  ***      0      0      0   unless $args{'all_privs'}
1941  ***      0      0      0   if ($EVAL_ERROR)
1945  ***      0      0      0   if (not scalar keys %$row)
1956  ***      0      0      0   $EVAL_ERROR ? :
1961  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
1987  ***      0      0      0   if $key =~ /FOREIGN/
1992  ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
1999  ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
2006  ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
2030  ***      0      0      0   if ($engine =~ /InnoDB/i and not $clustered_key)
2032  ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
2056  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
2085  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
2099  ***      0      0      0   if (@sec_indexes)
2116  ***      0      0      0   defined $_ ? :
2175  ***      0      0      0   unless $o->got('threads')
2183  ***      0      0      0   if ($o->get('quiet'))
2187  ***      0      0      0   if ($o->get('csv'))
2191  ***      0      0      0   if ($o->get('tab'))
2192  ***      0      0      0   unless $o->get('commit')
2193  ***      0      0      0   unless $o->got('disable-keys')
2194  ***      0      0      0   unless $o->got('no-auto-value-on-0')
2195  ***      0      0      0   unless $o->got('bin-log')
2196  ***      0      0      0   unless $o->got('unique-checks')
2197  ***      0      0      0   unless $o->got('foreign-key-checks')
2200  ***      0      0      0   if (not @ARGV)
2205  ***      0      0      0   if ($o->got($opt) and not $o->get('tab'))
2210  ***      0      0      0   if ($o->get('fifo'))
2211  ***      0      0      0   if (not $o->got('umask'))
2216  ***      0      0      0   if ($o->get('umask'))
2221  ***      0      0      0   @ARGV > 1 ? :
      ***      0      0      0   $o->got('biggest-first') ? :
2232  ***      0      0      0   if ($o->get('pid'))
2256  ***      0      0      0   if ($o->get('ask-pass'))
2265  ***      0      0      0   unless $o->get('bin-log')
2293  ***      0      0      0   if (-f $filename and not $filename =~ /00_master/) { }
      ***      0      0      0   elsif (not -d $filename and not $filename =~ /00_master_data.sql/) { }
2295  ***      0      0      0   if ($file =~ /\.(?:$known_filetypes)(?:\.\d+)?(?:\.gz)?$/)
2301  ***      0      0      0   if (!$databases || exists $$databases{$db} and !$databases_regex || $db =~ /$databases_regex/ and not exists $o->get('ignore-databases')->{$db} and not exists $o->get('ignore-tables')->{$tbl} and not exists $o->get('ignore-tables')->{"$db.$tbl"} and !$tables || exists $$tables{$tbl} and !$tables_regex || $tbl =~ /$tables_regex/) { }
2309  ***      0      0      0   if (not filetype($file) =~ /sql/ and not $o->get('tab'))
2315  ***      0      0      0   if ($o->get('only-empty-databases'))
2316  ***      0      0      0   if (defined $has_tables{$restore_db} and $has_tables{$restore_db})
2329  ***      0      0      0   if ($EVAL_ERROR) { }
2338  ***      0      0      0   if ($has_tables{$restore_db})
2364  ***      0      0      0   if (not exists $chunks_for_table{$restore_db}{$tbl} and -f $chunks_file)
2366  ***      0      0      0   unless open my $CHUNKS_FILE, "< $chunks_file"
2369  ***      0      0      0   unless close $CHUNKS_FILE
2394  ***      0      0      0   if ($o->get('create-databases'))
2433  ***      0      0      0   if ($o->get('biggest-first'))
2455  ***      0      0      0   if ($EVAL_ERROR)
2460  ***      0      0      0   if ($tries >= $o->get('wait'))
2469  ***      0      0      0   unless defined $pid
2470  ***      0      0      0   if ($pid) { }
2500  ***      0      0      0   $stat ? :
2507  ***      0      0      0   if $o->get('progress')
2511  ***      0      0      0   if (not $reaped)
2517  ***      0      0      0   if $o->get('progress')
2525  ***      0      0      0   if $o->get('progress')
2530  ***      0      0      0   unless $stats{$_}
2539  ***      0      0      0   $stats{'failure'} ? :
2549  ***      0      0      0   if (not -p $filename)
2550  ***      0      0      0   if (-e $filename)
2553  ***      0      0      0   if ($o->get('dry-run')) { }
2557  ***      0      0      0   unless POSIX::mkfifo($filename, 511)
2573  ***      0      0      0   if ($level <= $o->get('verbose'))
2582  ***      0      0      0   unless $args{$arg}
2604  ***      0      0      0   unless index($file_types, $a_type) <=> index($file_types, $b_type)
2608  ***      0      0      0   if ($o->get('resume'))
2625  ***      0      0      0   $files[0] && $files[0] =~ /00_$tbl\.sql$/ ? :
2630  ***      0      0      0   if ($create_table and $o->get('create-tables'))
2632  ***      0      0      0   unless open my $fh, '<', $create_table
2635  ***      0      0      0   unless close $fh
2640  ***      0      0      0   if ($o->get('fast-index'))
2647  ***      0      0      0   unless $o->get('bin-log')
2648  ***      0      0      0   unless $o->get('foreign-key-checks')
2649  ***      0      0      0   if $o->get('drop-tables')
2655  ***      0      0      0   if $o->get('lock-tables')
2657  ***      0      0      0   if $o->get('truncate')
2663  ***      0      0      0   unless $file
2672  ***      0      0      0   if (not $engine)
2674  ***      0      0      0   if (not $dry_run)
2687  ***      0      0      0   if $o->get('disable-keys') and $engine eq 'MyISAM'
2690  ***      0      0      0   if $o->get('no-auto-value-on-0')
2693  ***      0      0      0   unless $o->get('unique-checks')
2696  ***      0      0      0   unless $o->get('foreign-key-checks')
2699  ***      0      0      0   unless $o->get('bin-log')
2702  ***      0      0      0   if (my $bibs = $o->get('bulk-insert-buffer-size'))
2708  ***      0      0      0   if (filetype($file) eq 'sql') { }
2716  ***      0      0      0   if ($file =~ /\.gz$/) { }
2717  ***      0      0      0   if ($o->get('fifo')) { }
2734  ***      0      0      0   $o->get('local') ? :
2735  ***      0      0      0   $o->get('replace') ? :
      ***      0      0      0   $o->get('ignore') ? :
2738  ***      0      0      0   if ($o->get('csv')) { }
      ***      0      0      0   elsif ($o->get('tab')) { }
2751  ***      0      0      0   if ($sql) { }
2752  ***      0      0      0   if ($dry_run) { }
2759  ***      0      0      0   if ($EVAL_ERROR)
2766  ***      0      0      0   if $fifo
2771  ***      0      0      0   if $o->get('commit')
2775  ***      0      0      0   if ($dbh)
2777  ***      0      0      0   if $o->get('disable-keys') and $engine eq 'MyISAM'
2779  ***      0      0      0   if $o->get('lock-tables')
2783  ***      0      0      0   if ($o->get('fast-index') and $indexes_ddl)
2790  ***      0      0      0   if $fifo and not $dry_run
2791  ***      0      0      0   if $dbh
2804  ***      0      0      0   unless $args{$arg}
2815  ***      0      0      0   if ($file =~ /\.gz/) { }
2816  ***      0      0      0   if (not open $fh, '-|', "$decompress $file")
2822  ***      0      0      0   if (not open $fh, '<', "$args{'file'}")
2830  ***      0      0      0   if $sql =~ /^$/
2831  ***      0      0      0   if ($o->get('dry-run')) { }
2838  ***      0      0      0   if ($EVAL_ERROR)
2856  ***      0      0      0   unless $args{$arg}
2871  ***      0      0      0   if (not defined $chunks)
2876  ***      0      0      0   if ($$chunks[0] eq '1=1')
2887  ***      0      0      0   $tp->check_table('dbh', $dbh, 'db', $db, 'tbl', $tbl) ? :
2892  ***      0      0      0   if scalar @$chunk_restored == 0
2901  ***      0      0      0   if ($first_missing_chunk)
2902  ***      0      0      0   unless $o->get('atomic-resume')
2904  ***      0      0      0   if (defined $$chunks[$first_missing_chunk])
2908  ***      0      0      0   unless $o->get('foreign-key-checks')
2910  ***      0      0      0   unless $o->get('bin-log')
2918  ***      0      0      0   if ($$files[0] =~ /00_$tbl\.sql$/)
2965  ***      0      0      0   if $bytes_done <= $last_bytes_done
2974  ***      0      0      0   defined $dbh ? :
2976  ***      0      0      0   if $done_from_proclist < 0
2999  ***      0      0      0   unless $args{$arg}
3011  ***      0      0      0   if (my $charset = $o->get('charset'))
3021  ***      0      0      0   if ($o->get('dry-run')) { }
3041  ***      0      0      0   unless $sql
3043  ***      0      0      0   if ($dry_run) { }
3051  ***      0      0      0   if $EVAL_ERROR
3057  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
256   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
261   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
400   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
429   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
436   ***      0      0      0      0   @ARGV and $$self{'strict'}
520   ***      0      0      0      0   $opt and $$opt{'type'}
523   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
588   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
596   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
610   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
699   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
793   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1037  ***     66     76     76      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33    152      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1159  ***     66     19      0     19   not $dbh and $tries--
1195  ***     33     19      0      0   not $dbh and $EVAL_ERROR
1335  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1393  ***      0      0      0      0   $num >= $d and $n < @units - 1
1471  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
1651  ***      0      0      0      0   $PID_file and -f $PID_file
1712  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1961  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
1999  ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
2030  ***      0      0      0      0   $engine =~ /InnoDB/i and not $clustered_key
2032  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
2056  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
2205  ***      0      0      0      0   $o->got($opt) and not $o->get('tab')
2293  ***      0      0      0      0   -f $filename and not $filename =~ /00_master/
      ***      0      0      0      0   not -d $filename and not $filename =~ /00_master_data.sql/
2301  ***      0      0      0      0   !$databases || exists $$databases{$db} and !$databases_regex || $db =~ /$databases_regex/
      ***      0      0      0      0   !$databases || exists $$databases{$db} and !$databases_regex || $db =~ /$databases_regex/ and not exists $o->get('ignore-databases')->{$db}
      ***      0      0      0      0   !$databases || exists $$databases{$db} and !$databases_regex || $db =~ /$databases_regex/ and not exists $o->get('ignore-databases')->{$db} and not exists $o->get('ignore-tables')->{$tbl}
      ***      0      0      0      0   !$databases || exists $$databases{$db} and !$databases_regex || $db =~ /$databases_regex/ and not exists $o->get('ignore-databases')->{$db} and not exists $o->get('ignore-tables')->{$tbl} and not exists $o->get('ignore-tables')->{"$db.$tbl"}
      ***      0      0      0      0   !$databases || exists $$databases{$db} and !$databases_regex || $db =~ /$databases_regex/ and not exists $o->get('ignore-databases')->{$db} and not exists $o->get('ignore-tables')->{$tbl} and not exists $o->get('ignore-tables')->{"$db.$tbl"} and !$tables || exists $$tables{$tbl}
      ***      0      0      0      0   !$databases || exists $$databases{$db} and !$databases_regex || $db =~ /$databases_regex/ and not exists $o->get('ignore-databases')->{$db} and not exists $o->get('ignore-tables')->{$tbl} and not exists $o->get('ignore-tables')->{"$db.$tbl"} and !$tables || exists $$tables{$tbl} and !$tables_regex || $tbl =~ /$tables_regex/
2309  ***      0      0      0      0   not filetype($file) =~ /sql/ and not $o->get('tab')
2316  ***      0      0      0      0   defined $has_tables{$restore_db} and $has_tables{$restore_db}
2364  ***      0      0      0      0   not exists $chunks_for_table{$restore_db}{$tbl} and -f $chunks_file
2450  ***      0      0      0      0   not $dbh->ping and $tries++ < $o->get('wait')
2465  ***      0      0      0      0   @tables_to_do and $o->get('threads') > keys %kids
2625  ***      0      0      0      0   $files[0] && $files[0] =~ /00_$tbl\.sql$/
2630  ***      0      0      0      0   $create_table and $o->get('create-tables')
2687  ***      0      0      0      0   $o->get('disable-keys') and $engine eq 'MyISAM'
2777  ***      0      0      0      0   $o->get('disable-keys') and $engine eq 'MyISAM'
2783  ***      0      0      0      0   $o->get('fast-index') and $indexes_ddl
2790  ***      0      0      0      0   $fifo and not $dry_run

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
41    ***     50      0     21   $ENV{'MKDEBUG'} || 0
61    ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
63    ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
105   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore'
246   ***      0      0      0   $$opt{'group'} ||= 'default'
528   ***      0      0      0   $s || 's'
537   ***      0      0      0   $prefix || ''
565   ***      0      0      0   $pre || ''
572   ***      0      0      0   $val || ''
575   ***      0      0      0   $val || ''
633   ***      0      0      0   $$self{'description'} || ''
701   ***      0      0      0   $s ||= 's'
727   ***      0      0      0   $$opt{'type'} || ''
875   ***     50      0     21   $ENV{'MKDEBUG'} || 0
947   ***     50      0     21   $ENV{'MKDEBUG'} || 0
1018  ***     50      0     19   $prev ||= {}
1019  ***     50      0     19   $defaults ||= {}
1092  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1105  ***     50      0     19   $self->prop('dbidriver') || ''
1109  ***      0      0      0   $$info{'D'} || ''
1115  ***     50      0     19   $$info{'D'} || ''
1137  ***     50     19      0   $opts ||= {}
1232  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1248  ***      0      0      0   $level ||= 0
1249  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1301  ***     50      0     21   $ENV{'MKDEBUG'} || 0
1355  ***      0      0      0   $args{'p'} || 0
1357  ***      0      0      0   $of ||= 1
1362  ***      0      0      0   $secs ||= 0
1519  ***     50      0     21   $ENV{'MKDEBUG'} || 0
1555  ***      0      0      0   $n_cpus || 1
1576  ***     50      0     21   $ENV{'MKDEBUG'} || 0
1756  ***     50      0     21   $ENV{'MKDEBUG'} || 0
1975  ***      0      0      0   $engine || undef
1998  ***      0      0      0   $type || $special || 'BTREE'
2085  ***      0      0      0   $$tbl_struct{'engine'} || ''
2087  ***      0      0      0   $clustered_key ||= ''
2151  ***     50      0     21   $ENV{'MKDEBUG'} || 0
2638  ***      0      0      0   $args{'tp'}->get_engine($table_ddl) || ''
2680  ***      0      0      0   $table_ddl || ''
      ***      0      0      0   $args{'tp'}->get_engine($table_ddl || '') || ''
2959  ***      0      0      0   $$proc[7] || ''
2961  ***      0      0      0   $done ||= 0
2993  ***      0      0      0   $type || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
60    ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
61    ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
523   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1128  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1129  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1130  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1131  ***      0      0      0      0   $$dsn{'u'} ||= $user
1132  ***      0      0      0      0   $$dsn{'D'} ||= $db
1365  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1397  ***      0      0      0      0   $num =~ /\./ || $n
1534  ***      0      0      0      0   $sys_info or open $cpuinfo, '<', '/proc/cpuinfo'
1536  ***      0      0      0      0   $sys_info || <$cpuinfo>
1545  ***      0      0      0      0   $sys_info or $OSNAME =~ /freebsd/i
      ***      0      0      0      0   $sys_info or $OSNAME =~ /freebsd/i or $OSNAME =~ /darwin/i
1546  ***      0      0      0      0   $sys_info || `sysctl hw.ncpu`
1553  ***      0      0      0      0   $n_cpus ||= $ENV{'NUMBER_OF_PROCESSORS'}
1725  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1849  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1928  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
1949  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
1998  ***      0      0      0      0   $type || $special
2298  ***      0      0      0      0   $o->get('database') || $dirs[-1]
2301  ***      0      0      0      0   !$databases || exists $$databases{$db}
      ***      0      0      0      0   !$databases_regex || $db =~ /$databases_regex/
      ***      0      0      0      0   !$tables || exists $$tables{$tbl}
      ***      0      0      0      0   !$tables_regex || $tbl =~ /$tables_regex/
2446  ***      0      0      0      0   @tables_to_do or %kids
2477  ***      0      0      0      0   do_table('file_types', $known_filetypes, 'db', $$todo{'D'}, 'tbl', $$todo{'N'}, 'files', $files_for_table{$$todo{'D'}}{$$todo{'N'}}, 'file_size', \%size_for_file, 'tbl_chunks', \%chunks_for_table, %common_modules) || $exit_status
2666  ***      0      0      0      0   $dbh ||= get_cxn(%args)
2718  ***      0      0      0      0   $fifo ||= makefifo($o)


Covered Subroutines
-------------------

Subroutine                  Count Location                                                             
--------------------------- ----- ---------------------------------------------------------------------
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1295
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1296
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1297
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1298
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1299
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1301
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1505
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1506
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1508
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1519
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1570
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1571
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1573
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1574
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1576
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1748
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1749
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1750
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1751
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1756
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2138
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2139
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2140
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2141
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2142
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2143
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2144
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2145
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2146
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2151
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:22  
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:23  
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:34  
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:35  
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:37  
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:38  
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:39  
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:41  
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:868 
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:869 
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:873 
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:875 
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:935 
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:936 
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:937 
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:938 
BEGIN                          21 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:947 
get_cxn_params                 19 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1102
get_dbh                        19 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1136
new                            15 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:950 
parse                          19 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1012
prop                           57 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1003

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                                             
--------------------------- ----- ---------------------------------------------------------------------
DESTROY                         0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1724
__ANON__                        0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2292
__ANON__                        0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2420
__ANON__                        0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:424 
_d                              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1276
_d                              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1486
_d                              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1522
_d                              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1730
_d                              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2115
_d                              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:3056
_d                              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:852 
_do                             0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:3038
_get_participants               0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:324 
_make_PID_file                  0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1689
_parse_specs                    0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:210 
_pod_to_specs                   0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:104 
_read_config_file               0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:776 
_remove_PID_file                0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1711
_set_option                     0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:370 
_validate_type                  0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:519 
any_unix_timestamp              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1448
as_string                       0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1076
bytes_done_from_processlist     0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2954
check_PID_file                  0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1648
check_table                     0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1907
clone                           0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:829 
copy                            0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1258
daemonize                       0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1597
descr                           0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:632 
disconnect                      0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1241
do_sql_file                     0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2802
do_table                        0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2580
errors                          0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:622 
filetype                        0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2991
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1124
find_best_index                 0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1861
find_possible_keys              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1879
get                             0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:586 
get_cxn                         0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2997
get_defaults                    0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:360 
get_defaults_files              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:99  
get_engine                      0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1972
get_fks                         0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2046
get_groups                      0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:365 
get_hostname                    0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1231
get_keys                        0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1979
get_number_of_cpus              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1530
get_opts                        0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:387 
get_specs                       0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:92  
got                             0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:594 
has                             0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:602 
info                            0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2572
literal_like                    0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:918 
main                            0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2159
make_PID_file                   0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1679
make_checksum                   0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1479
makefifo                        0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2547
micro_t                         0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1324
mysql_error_msg                 0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2565
new                             0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1579
new                             0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1760
new                             0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:55  
new                             0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:878 
opts                            0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:336 
parse                           0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1771
parse_options                   0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1063
parse_timestamp                 0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1421
percentage_of                   0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1354
print_active_handles            0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1247
print_errors                    0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:656 
print_progress_report           0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2972
print_usage                     0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:666 
prompt                          0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:627 
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:741 
quote                           0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:883 
quote_val                       0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:891 
read_para_after                 0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:810 
remove_auto_increment           0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2075
remove_secondary_indexes        0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2081
save_error                      0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:617 
secs_to_time                    0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1361
set                             0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:608 
set_defaults                    0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:348 
short_opts                      0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:342 
shorten                         0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1388
skip_finished_chunks            0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:2854
sort_indexes                    0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1842
split_unquote                   0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:907 
system_call                     0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:3019
ts                              0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1405
unix_timestamp                  0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1433
usage                           0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:1085
usage_or_errors                 0 /home/daniel/dev/maatkit/mk-parallel-restore/mk-parallel-restore:643 


