---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...hecksum/mk-table-checksum    9.2    1.4    3.4   29.6    n/a  100.0    7.4
Total                           9.2    1.4    3.4   29.6    n/a  100.0    7.4
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:40:23 2010
Finish:       Thu Jan 28 22:40:23 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:40:25 2010
Finish:       Thu Jan 28 22:40:27 2010

Run:          ./102_since.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:40:30 2010
Finish:       Thu Jan 28 22:40:33 2010

Run:          ./103_schema.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:40:37 2010
Finish:       Thu Jan 28 22:40:44 2010

Run:          ./104_resume.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:40:48 2010
Finish:       Thu Jan 28 22:40:51 2010

Run:          ./105_chunk_size.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:40:54 2010
Finish:       Thu Jan 28 22:40:55 2010

Run:          ./106_float_precision.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:40:59 2010
Finish:       Thu Jan 28 22:41:00 2010

Run:          ./107_probability.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:04 2010
Finish:       Thu Jan 28 22:41:05 2010

Run:          ./108_arg_table.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:08 2010
Finish:       Thu Jan 28 22:41:10 2010

Run:          ./109_offset_modulo.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:14 2010
Finish:       Thu Jan 28 22:41:14 2010

Run:          ./110_force_index.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:18 2010
Finish:       Thu Jan 28 22:41:18 2010

Run:          ./111_create_replicate_table.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:22 2010
Finish:       Thu Jan 28 22:41:23 2010

Run:          ./112_ignore_columns.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:27 2010
Finish:       Thu Jan 28 22:41:27 2010

Run:          ./113_checksum.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:31 2010
Finish:       Thu Jan 28 22:41:32 2010

Run:          ./114_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:36 2010
Finish:       Thu Jan 28 22:41:36 2010

Run:          ./115_replicate.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:39 2010
Finish:       Thu Jan 28 22:41:40 2010

Run:          ./116_fnv_64.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:44 2010
Finish:       Thu Jan 28 22:41:45 2010

Run:          ./201_issue_35.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:49 2010
Finish:       Thu Jan 28 22:41:50 2010

Run:          ./202_issue_21.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:53 2010
Finish:       Thu Jan 28 22:41:56 2010

Run:          ./203_issue_69.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:41:59 2010
Finish:       Thu Jan 28 22:42:01 2010

Run:          ./204_issue_81.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:42:05 2010
Finish:       Thu Jan 28 22:42:06 2010

Run:          ./205_issue_47.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:42:09 2010
Finish:       Thu Jan 28 22:42:10 2010

Run:          ./206_issue_122.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:42:13 2010
Finish:       Thu Jan 28 22:42:14 2010

Run:          ./207_issue_51.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:42:17 2010
Finish:       Thu Jan 28 22:42:18 2010

Run:          ./mk-checksum-filter.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:42:22 2010
Finish:       Thu Jan 28 22:42:22 2010

/home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program checksums MySQL tables efficiently on one or more servers.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22            23                   23           128   use strict;
              23                                 55   
              23                                167   
23            23                   23           152   use warnings FATAL => 'all';
              23                                 57   
              23                                157   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5565 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # TableParser package 5266
31                                                    # ###########################################################################
32                                                    package TableParser;
33                                                    
34            23                   23           158   use strict;
              23                                 55   
              23                                103   
35            23                   23           140   use warnings FATAL => 'all';
              23                                 58   
              23                                125   
36            23                   23           145   use English qw(-no_match_vars);
              23                                 53   
              23                                158   
37            23                   23           156   use Data::Dumper;
              23                                 59   
              23                                179   
38                                                    $Data::Dumper::Indent    = 1;
39                                                    $Data::Dumper::Sortkeys  = 1;
40                                                    $Data::Dumper::Quotekeys = 0;
41                                                    
42    ***     23            50     23           160   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                 64   
              23                                336   
43                                                    
44                                                    
45                                                    sub new {
46    ***      0                    0             0      my ( $class, %args ) = @_;
47    ***      0                                  0      my @required_args = qw(Quoter);
48    ***      0                                  0      foreach my $arg ( @required_args ) {
49    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
50                                                       }
51    ***      0                                  0      my $self = { %args };
52    ***      0                                  0      return bless $self, $class;
53                                                    }
54                                                    
55                                                    
56                                                    sub parse {
57    ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
58    ***      0      0                           0      return unless $ddl;
59    ***      0      0                           0      if ( ref $ddl eq 'ARRAY' ) {
60    ***      0      0                           0         if ( lc $ddl->[0] eq 'table' ) {
61    ***      0                                  0            $ddl = $ddl->[1];
62                                                          }
63                                                          else {
64                                                             return {
65    ***      0                                  0               engine => 'VIEW',
66                                                             };
67                                                          }
68                                                       }
69                                                    
70    ***      0      0                           0      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
71    ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
72                                                             . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
73                                                       }
74                                                    
75    ***      0                                  0      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
76    ***      0      0                           0      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
77                                                    
78    ***      0                                  0      $ddl =~ s/(`[^`]+`)/\L$1/g;
79                                                    
80    ***      0                                  0      my $engine = $self->get_engine($ddl);
81                                                    
82    ***      0                                  0      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
83    ***      0                                  0      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                  0   
84    ***      0                                  0      MKDEBUG && _d('Columns:', join(', ', @cols));
85                                                    
86    ***      0                                  0      my %def_for;
87    ***      0                                  0      @def_for{@cols} = @defs;
88                                                    
89    ***      0                                  0      my (@nums, @null);
90    ***      0                                  0      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
91    ***      0                                  0      foreach my $col ( @cols ) {
92    ***      0                                  0         my $def = $def_for{$col};
93    ***      0                                  0         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
94    ***      0      0                           0         die "Can't determine column type for $def" unless $type;
95    ***      0                                  0         $type_for{$col} = $type;
96    ***      0      0                           0         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
97    ***      0                                  0            push @nums, $col;
98    ***      0                                  0            $is_numeric{$col} = 1;
99                                                          }
100   ***      0      0                           0         if ( $def !~ m/NOT NULL/ ) {
101   ***      0                                  0            push @null, $col;
102   ***      0                                  0            $is_nullable{$col} = 1;
103                                                         }
104   ***      0      0                           0         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
105                                                      }
106                                                   
107   ***      0                                  0      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
108                                                   
109                                                      return {
110   ***      0                                  0         name           => $name,
111                                                         cols           => \@cols,
112   ***      0                                  0         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
113   ***      0                                  0         is_col         => { map { $_ => 1 } @cols },
114                                                         null_cols      => \@null,
115                                                         is_nullable    => \%is_nullable,
116                                                         is_autoinc     => \%is_autoinc,
117                                                         clustered_key  => $clustered_key,
118                                                         keys           => $keys,
119                                                         defs           => \%def_for,
120                                                         numeric_cols   => \@nums,
121                                                         is_numeric     => \%is_numeric,
122                                                         engine         => $engine,
123                                                         type_for       => \%type_for,
124                                                      };
125                                                   }
126                                                   
127                                                   sub sort_indexes {
128   ***      0                    0             0      my ( $self, $tbl ) = @_;
129                                                   
130                                                      my @indexes
131   ***      0                                  0         = sort {
132   ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
133                                                            || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
134                                                            || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
135   ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
136                                                         }
137                                                         grep {
138   ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
139                                                         }
140   ***      0                                  0         sort keys %{$tbl->{keys}};
141                                                   
142   ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
143   ***      0                                  0      return @indexes;
144                                                   }
145                                                   
146                                                   sub find_best_index {
147   ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
148   ***      0                                  0      my $best;
149   ***      0      0                           0      if ( $index ) {
150   ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
151                                                      }
152   ***      0      0                           0      if ( !$best ) {
153   ***      0      0                           0         if ( $index ) {
154   ***      0                                  0            die "Index '$index' does not exist in table";
155                                                         }
156                                                         else {
157   ***      0                                  0            ($best) = $self->sort_indexes($tbl);
158                                                         }
159                                                      }
160   ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
161   ***      0                                  0      return $best;
162                                                   }
163                                                   
164                                                   sub find_possible_keys {
165   ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
166   ***      0      0                           0      return () unless $where;
167   ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
168                                                         . ' WHERE ' . $where;
169   ***      0                                  0      MKDEBUG && _d($sql);
170   ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
171   ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
172   ***      0      0                           0      if ( $expl->{possible_keys} ) {
173   ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
174   ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
175   ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
176   ***      0      0                           0         if ( $expl->{key} ) {
177   ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
178   ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
179   ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
180   ***      0                                  0            my %seen;
181   ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
182                                                         }
183   ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
184   ***      0                                  0         return @candidates;
185                                                      }
186                                                      else {
187   ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
188   ***      0                                  0         return ();
189                                                      }
190                                                   }
191                                                   
192                                                   sub check_table {
193   ***      0                    0             0      my ( $self, %args ) = @_;
194   ***      0                                  0      my @required_args = qw(dbh db tbl);
195   ***      0                                  0      foreach my $arg ( @required_args ) {
196   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
197                                                      }
198   ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
199   ***      0                                  0      my $q      = $self->{Quoter};
200   ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
201   ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
202                                                   
203   ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
204                                                              . ' LIKE ' . $q->literal_like($tbl);
205   ***      0                                  0      MKDEBUG && _d($sql);
206   ***      0                                  0      my $row;
207   ***      0                                  0      eval {
208   ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
209                                                      };
210   ***      0      0                           0      if ( $EVAL_ERROR ) {
211   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
212   ***      0                                  0         return 0;
213                                                      }
214   ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
215   ***      0                                  0         MKDEBUG && _d('Table does not exist');
216   ***      0                                  0         return 0;
217                                                      }
218                                                   
219   ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
220   ***      0      0                           0      return 1 unless $args{all_privs};
221                                                   
222   ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
223   ***      0                                  0      MKDEBUG && _d($sql);
224   ***      0                                  0      eval {
225   ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
226                                                      };
227   ***      0      0                           0      if ( $EVAL_ERROR ) {
228   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
229   ***      0                                  0         return 0;
230                                                      }
231   ***      0      0                           0      if ( !scalar keys %$row ) {
232   ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
233   ***      0                                  0         return 0;
234                                                      }
235   ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
236                                                   
237   ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
238   ***      0                                  0      MKDEBUG && _d($sql);
239   ***      0                                  0      eval {
240   ***      0                                  0         $dbh->do($sql);
241                                                      };
242   ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
243                                                   
244   ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
245                                                         ($can_delete ? 'delete' : ''));
246                                                   
247   ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
248                                                             && $can_delete) ) {
249   ***      0                                  0         MKDEBUG && _d('User does not have all privs');
250   ***      0                                  0         return 0;
251                                                      }
252                                                   
253   ***      0                                  0      MKDEBUG && _d('User has all privs');
254   ***      0                                  0      return 1;
255                                                   }
256                                                   
257                                                   sub get_engine {
258   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
259   ***      0                                  0      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
260   ***      0                                  0      MKDEBUG && _d('Storage engine:', $engine);
261   ***      0             0                    0      return $engine || undef;
262                                                   }
263                                                   
264                                                   sub get_keys {
265   ***      0                    0             0      my ( $self, $ddl, $opts, $is_nullable ) = @_;
266   ***      0                                  0      my $engine        = $self->get_engine($ddl);
267   ***      0                                  0      my $keys          = {};
268   ***      0                                  0      my $clustered_key = undef;
269                                                   
270                                                      KEY:
271   ***      0                                  0      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
272                                                   
273   ***      0      0                           0         next KEY if $key =~ m/FOREIGN/;
274                                                   
275   ***      0                                  0         my $key_ddl = $key;
276   ***      0                                  0         MKDEBUG && _d('Parsed key:', $key_ddl);
277                                                   
278   ***      0      0                           0         if ( $engine !~ m/MEMORY|HEAP/ ) {
279   ***      0                                  0            $key =~ s/USING HASH/USING BTREE/;
280                                                         }
281                                                   
282   ***      0                                  0         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
283   ***      0                                  0         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
284   ***      0             0                    0         $type = $type || $special || 'BTREE';
      ***                    0                        
285   ***      0      0      0                    0         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
286                                                            && $engine =~ m/HEAP|MEMORY/i )
287                                                         {
288   ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
289                                                         }
290                                                   
291   ***      0                                  0         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
292   ***      0      0                           0         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
293   ***      0                                  0         my @cols;
294   ***      0                                  0         my @col_prefixes;
295   ***      0                                  0         foreach my $col_def ( split(',', $cols) ) {
296   ***      0                                  0            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
297   ***      0                                  0            push @cols, $name;
298   ***      0                                  0            push @col_prefixes, $prefix;
299                                                         }
300   ***      0                                  0         $name =~ s/`//g;
301                                                   
302   ***      0                                  0         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
303                                                   
304   ***      0                                  0         $keys->{$name} = {
305                                                            name         => $name,
306                                                            type         => $type,
307                                                            colnames     => $cols,
308                                                            cols         => \@cols,
309                                                            col_prefixes => \@col_prefixes,
310                                                            is_unique    => $unique,
311   ***      0                                  0            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
312   ***      0                                  0            is_col       => { map { $_ => 1 } @cols },
313                                                            ddl          => $key_ddl,
314                                                         };
315                                                   
316   ***      0      0      0                    0         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
317   ***      0                                  0            my $this_key = $keys->{$name};
318   ***      0      0      0                    0            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
319   ***      0                                  0               $clustered_key = 'PRIMARY';
320                                                            }
321                                                            elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
322   ***      0                                  0               $clustered_key = $this_key->{name};
323                                                            }
324   ***      0                                  0            MKDEBUG && $clustered_key && _d('This key is the clustered key');
325                                                         }
326                                                      }
327                                                   
328   ***      0                                  0      return $keys, $clustered_key;
329                                                   }
330                                                   
331                                                   sub get_fks {
332   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
333   ***      0                                  0      my $fks = {};
334                                                   
335   ***      0                                  0      foreach my $fk (
336                                                         $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
337                                                      {
338   ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
339   ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
340   ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
341                                                   
342   ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
343   ***      0                                  0            $parent = "`$opts->{database}`.$parent";
344                                                         }
345                                                   
346   ***      0                                  0         $fks->{$name} = {
347                                                            name           => $name,
348                                                            colnames       => $cols,
349   ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
350                                                            parent_tbl     => $parent,
351                                                            parent_colnames=> $parent_cols,
352   ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
353                                                            ddl            => $fk,
354                                                         };
355                                                      }
356                                                   
357   ***      0                                  0      return $fks;
358                                                   }
359                                                   
360                                                   sub remove_auto_increment {
361   ***      0                    0             0      my ( $self, $ddl ) = @_;
362   ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
363   ***      0                                  0      return $ddl;
364                                                   }
365                                                   
366                                                   sub remove_secondary_indexes {
367   ***      0                    0             0      my ( $self, $ddl ) = @_;
368   ***      0                                  0      my $sec_indexes_ddl;
369   ***      0                                  0      my $tbl_struct = $self->parse($ddl);
370                                                   
371   ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
372   ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
373   ***      0             0                    0         $clustered_key  ||= '';
374                                                   
375   ***      0                                  0         my @sec_indexes   = map {
376   ***      0                                  0            my $key_def = $_->{ddl};
377   ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
378   ***      0                                  0            $ddl =~ s/\s+$key_def//;
379   ***      0                                  0            "ADD $_->{ddl}";
380                                                         }
381   ***      0                                  0         grep { $_->{name} ne $clustered_key }
382   ***      0                                  0         values %{$tbl_struct->{keys}};
383   ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
384                                                   
385   ***      0      0                           0         if ( @sec_indexes ) {
386   ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
387   ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
388                                                         }
389                                                   
390   ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
391                                                      }
392                                                      else {
393   ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
394                                                            $tbl_struct->{engine}, 'table');
395                                                      }
396                                                   
397   ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
398                                                   }
399                                                   
400                                                   sub _d {
401   ***      0                    0             0      my ($package, undef, $line) = caller 0;
402   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
403   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
404                                                           @_;
405   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
406                                                   }
407                                                   
408                                                   1;
409                                                   
410                                                   # ###########################################################################
411                                                   # End TableParser package
412                                                   # ###########################################################################
413                                                   
414                                                   # ###########################################################################
415                                                   # TableChecksum package 5266
416                                                   # ###########################################################################
417                                                   package TableChecksum;
418                                                   
419           23                   23           207   use strict;
              23                                 76   
              23                                143   
420           23                   23           142   use warnings FATAL => 'all';
              23                                 59   
              23                                137   
421           23                   23           150   use English qw(-no_match_vars);
              23                                 62   
              23                                138   
422           23                   23           171   use List::Util qw(max);
              23                                 68   
              23                                271   
423                                                   
424   ***     23            50     23           148   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                 65   
              23                                331   
425                                                   
426                                                   our %ALGOS = (
427                                                      CHECKSUM => { pref => 0, hash => 0 },
428                                                      BIT_XOR  => { pref => 2, hash => 1 },
429                                                      ACCUM    => { pref => 3, hash => 1 },
430                                                   );
431                                                   
432                                                   sub new {
433   ***      0                    0             0      my ( $class, %args ) = @_;
434   ***      0                                  0      foreach my $arg ( qw(Quoter VersionParser) ) {
435   ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
436                                                      }
437   ***      0                                  0      my $self = { %args };
438   ***      0                                  0      return bless $self, $class;
439                                                   }
440                                                   
441                                                   sub crc32 {
442   ***      0                    0             0      my ( $self, $string ) = @_;
443   ***      0                                  0      my $poly = 0xEDB88320;
444   ***      0                                  0      my $crc  = 0xFFFFFFFF;
445   ***      0                                  0      foreach my $char ( split(//, $string) ) {
446   ***      0                                  0         my $comp = ($crc ^ ord($char)) & 0xFF;
447   ***      0                                  0         for ( 1 .. 8 ) {
448   ***      0      0                           0            $comp = $comp & 1 ? $poly ^ ($comp >> 1) : $comp >> 1;
449                                                         }
450   ***      0                                  0         $crc = (($crc >> 8) & 0x00FFFFFF) ^ $comp;
451                                                      }
452   ***      0                                  0      return $crc ^ 0xFFFFFFFF;
453                                                   }
454                                                   
455                                                   sub get_crc_wid {
456   ***      0                    0             0      my ( $self, $dbh, $func ) = @_;
457   ***      0                                  0      my $crc_wid = 16;
458   ***      0      0      0                    0      if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
459   ***      0                                  0         eval {
460   ***      0                                  0            my ($val) = $dbh->selectrow_array("SELECT $func('a')");
461   ***      0                                  0            $crc_wid = max(16, length($val));
462                                                         };
463                                                      }
464   ***      0                                  0      return $crc_wid;
465                                                   }
466                                                   
467                                                   sub get_crc_type {
468   ***      0                    0             0      my ( $self, $dbh, $func ) = @_;
469   ***      0                                  0      my $type   = '';
470   ***      0                                  0      my $length = 0;
471   ***      0                                  0      my $sql    = "SELECT $func('a')";
472   ***      0                                  0      my $sth    = $dbh->prepare($sql);
473   ***      0                                  0      eval {
474   ***      0                                  0         $sth->execute();
475   ***      0                                  0         $type   = $sth->{mysql_type_name}->[0];
476   ***      0                                  0         $length = $sth->{mysql_length}->[0];
477   ***      0                                  0         MKDEBUG && _d($sql, $type, $length);
478   ***      0      0      0                    0         if ( $type eq 'bigint' && $length < 20 ) {
479   ***      0                                  0            $type = 'int';
480                                                         }
481                                                      };
482   ***      0                                  0      $sth->finish;
483   ***      0                                  0      MKDEBUG && _d('crc_type:', $type, 'length:', $length);
484   ***      0                                  0      return ($type, $length);
485                                                   }
486                                                   
487                                                   sub best_algorithm {
488   ***      0                    0             0      my ( $self, %args ) = @_;
489   ***      0                                  0      my ( $alg, $dbh ) = @args{ qw(algorithm dbh) };
490   ***      0                                  0      my $vp = $self->{VersionParser};
491   ***      0                                  0      my @choices = sort { $ALGOS{$a}->{pref} <=> $ALGOS{$b}->{pref} } keys %ALGOS;
      ***      0                                  0   
492   ***      0      0      0                    0      die "Invalid checksum algorithm $alg"
493                                                         if $alg && !$ALGOS{$alg};
494                                                   
495   ***      0      0      0                    0      if (
      ***                    0                        
      ***                    0                        
496                                                         $args{where} || $args{chunk}        # CHECKSUM does whole table
497                                                         || $args{replicate}                 # CHECKSUM can't do INSERT.. SELECT
498                                                         || !$vp->version_ge($dbh, '4.1.1')) # CHECKSUM doesn't exist
499                                                      {
500   ***      0                                  0         MKDEBUG && _d('Cannot use CHECKSUM algorithm');
501   ***      0                                  0         @choices = grep { $_ ne 'CHECKSUM' } @choices;
      ***      0                                  0   
502                                                      }
503                                                   
504   ***      0      0                           0      if ( !$vp->version_ge($dbh, '4.1.1') ) {
505   ***      0                                  0         MKDEBUG && _d('Cannot use BIT_XOR algorithm because MySQL < 4.1.1');
506   ***      0                                  0         @choices = grep { $_ ne 'BIT_XOR' } @choices;
      ***      0                                  0   
507                                                      }
508                                                   
509   ***      0      0      0                    0      if ( $alg && grep { $_ eq $alg } @choices ) {
      ***      0                                  0   
510   ***      0                                  0         MKDEBUG && _d('User requested', $alg, 'algorithm');
511   ***      0                                  0         return $alg;
512                                                      }
513                                                   
514   ***      0      0      0                    0      if ( $args{count} && grep { $_ ne 'CHECKSUM' } @choices ) {
      ***      0                                  0   
515   ***      0                                  0         MKDEBUG && _d('Not using CHECKSUM algorithm because COUNT desired');
516   ***      0                                  0         @choices = grep { $_ ne 'CHECKSUM' } @choices;
      ***      0                                  0   
517                                                      }
518                                                   
519   ***      0                                  0      MKDEBUG && _d('Algorithms, in order:', @choices);
520   ***      0                                  0      return $choices[0];
521                                                   }
522                                                   
523                                                   sub is_hash_algorithm {
524   ***      0                    0             0      my ( $self, $algorithm ) = @_;
525   ***      0             0                    0      return $ALGOS{$algorithm} && $ALGOS{$algorithm}->{hash};
526                                                   }
527                                                   
528                                                   sub choose_hash_func {
529   ***      0                    0             0      my ( $self, %args ) = @_;
530   ***      0                                  0      my @funcs = qw(CRC32 FNV1A_64 FNV_64 MD5 SHA1);
531   ***      0      0                           0      if ( $args{function} ) {
532   ***      0                                  0         unshift @funcs, $args{function};
533                                                      }
534   ***      0                                  0      my ($result, $error);
535   ***      0             0                    0      do {
536   ***      0                                  0         my $func;
537   ***      0                                  0         eval {
538   ***      0                                  0            $func = shift(@funcs);
539   ***      0                                  0            my $sql = "SELECT $func('test-string')";
540   ***      0                                  0            MKDEBUG && _d($sql);
541   ***      0                                  0            $args{dbh}->do($sql);
542   ***      0                                  0            $result = $func;
543                                                         };
544   ***      0      0      0                    0         if ( $EVAL_ERROR && $EVAL_ERROR =~ m/failed: (.*?) at \S+ line/ ) {
545   ***      0                                  0            $error .= qq{$func cannot be used because "$1"\n};
546   ***      0                                  0            MKDEBUG && _d($func, 'cannot be used because', $1);
547                                                         }
548                                                      } while ( @funcs && !$result );
549                                                   
550   ***      0      0                           0      die $error unless $result;
551   ***      0                                  0      MKDEBUG && _d('Chosen hash func:', $result);
552   ***      0                                  0      return $result;
553                                                   }
554                                                   
555                                                   sub optimize_xor {
556   ***      0                    0             0      my ( $self, %args ) = @_;
557   ***      0                                  0      my ($dbh, $func) = @args{qw(dbh function)};
558                                                   
559   ***      0      0                           0      die "$func never needs the BIT_XOR optimization"
560                                                         if $func =~ m/^(?:FNV1A_64|FNV_64|CRC32)$/i;
561                                                   
562   ***      0                                  0      my $opt_slice = 0;
563   ***      0                                  0      my $unsliced  = uc $dbh->selectall_arrayref("SELECT $func('a')")->[0]->[0];
564   ***      0                                  0      my $sliced    = '';
565   ***      0                                  0      my $start     = 1;
566   ***      0      0                           0      my $crc_wid   = length($unsliced) < 16 ? 16 : length($unsliced);
567                                                   
568   ***      0             0                    0      do { # Try different positions till sliced result equals non-sliced.
569   ***      0                                  0         MKDEBUG && _d('Trying slice', $opt_slice);
570   ***      0                                  0         $dbh->do('SET @crc := "", @cnt := 0');
571   ***      0                                  0         my $slices = $self->make_xor_slices(
572                                                            query     => "\@crc := $func('a')",
573                                                            crc_wid   => $crc_wid,
574                                                            opt_slice => $opt_slice,
575                                                         );
576                                                   
577   ***      0                                  0         my $sql = "SELECT CONCAT($slices) AS TEST FROM (SELECT NULL) AS x";
578   ***      0                                  0         $sliced = ($dbh->selectrow_array($sql))[0];
579   ***      0      0                           0         if ( $sliced ne $unsliced ) {
580   ***      0                                  0            MKDEBUG && _d('Slice', $opt_slice, 'does not work');
581   ***      0                                  0            $start += 16;
582   ***      0                                  0            ++$opt_slice;
583                                                         }
584                                                      } while ( $start < $crc_wid && $sliced ne $unsliced );
585                                                   
586   ***      0      0                           0      if ( $sliced eq $unsliced ) {
587   ***      0                                  0         MKDEBUG && _d('Slice', $opt_slice, 'works');
588   ***      0                                  0         return $opt_slice;
589                                                      }
590                                                      else {
591   ***      0                                  0         MKDEBUG && _d('No slice works');
592   ***      0                                  0         return undef;
593                                                      }
594                                                   }
595                                                   
596                                                   sub make_xor_slices {
597   ***      0                    0             0      my ( $self, %args ) = @_;
598   ***      0                                  0      foreach my $arg ( qw(query crc_wid) ) {
599   ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
600                                                      }
601   ***      0                                  0      my ( $query, $crc_wid, $opt_slice ) = @args{qw(query crc_wid opt_slice)};
602                                                   
603   ***      0                                  0      my @slices;
604                                                      for ( my $start = 1; $start <= $crc_wid; $start += 16 ) {
605   ***      0                                  0         my $len = $crc_wid - $start + 1;
606   ***      0      0                           0         if ( $len > 16 ) {
607   ***      0                                  0            $len = 16;
608                                                         }
609   ***      0                                  0         push @slices,
610                                                            "LPAD(CONV(BIT_XOR("
611                                                            . "CAST(CONV(SUBSTRING(\@crc, $start, $len), 16, 10) AS UNSIGNED))"
612                                                            . ", 10, 16), $len, '0')";
613   ***      0                                  0      }
614                                                   
615   ***      0      0      0                    0      if ( defined $opt_slice && $opt_slice < @slices ) {
616   ***      0                                  0         $slices[$opt_slice] =~ s/\@crc/\@crc := $query/;
617                                                      }
618                                                      else {
619   ***      0                                  0         map { s/\@crc/$query/ } @slices;
      ***      0                                  0   
620                                                      }
621                                                   
622   ***      0                                  0      return join(', ', @slices);
623                                                   }
624                                                   
625                                                   sub make_row_checksum {
626   ***      0                    0             0      my ( $self, %args ) = @_;
627   ***      0                                  0      my ( $tbl_struct, $func ) = @args{ qw(tbl_struct function) };
628   ***      0                                  0      my $q = $self->{Quoter};
629                                                   
630   ***      0             0                    0      my $sep = $args{sep} || '#';
631   ***      0                                  0      $sep =~ s/'//g;
632   ***      0             0                    0      $sep ||= '#';
633                                                   
634   ***      0                                  0      my %ignorecols = map { $_ => 1 } @{$args{ignorecols}};
      ***      0                                  0   
      ***      0                                  0   
635                                                   
636   ***      0                                  0      my %cols = map { lc($_) => 1 }
      ***      0                                  0   
637   ***      0                                  0                 grep { !exists $ignorecols{$_} }
638   ***      0      0                           0                 ($args{cols} ? @{$args{cols}} : @{$tbl_struct->{cols}});
      ***      0                                  0   
639   ***      0                                  0      my @cols =
640                                                         map {
641   ***      0                                  0            my $type = $tbl_struct->{type_for}->{$_};
642   ***      0                                  0            my $result = $q->quote($_);
643   ***      0      0      0                    0            if ( $type eq 'timestamp' ) {
      ***             0      0                        
      ***             0                               
644   ***      0                                  0               $result .= ' + 0';
645                                                            }
646                                                            elsif ( $type =~ m/float|double/ && $args{float_precision} ) {
647   ***      0                                  0               $result = "ROUND($result, $args{float_precision})";
648                                                            }
649                                                            elsif ( $type =~ m/varchar/ && $args{trim} ) {
650   ***      0                                  0               $result = "TRIM($result)";
651                                                            }
652   ***      0                                  0            $result;
653                                                         }
654                                                         grep {
655   ***      0                                  0            $cols{$_}
656                                                         }
657   ***      0                                  0         @{$tbl_struct->{cols}};
658                                                   
659   ***      0                                  0      my $query;
660   ***      0      0      0                    0      if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
661   ***      0                                  0         my @nulls = grep { $cols{$_} } @{$tbl_struct->{null_cols}};
      ***      0                                  0   
      ***      0                                  0   
662   ***      0      0                           0         if ( @nulls ) {
663   ***      0                                  0            my $bitmap = "CONCAT("
664   ***      0                                  0               . join(', ', map { 'ISNULL(' . $q->quote($_) . ')' } @nulls)
665                                                               . ")";
666   ***      0                                  0            push @cols, $bitmap;
667                                                         }
668                                                   
669   ***      0      0                           0         $query = @cols > 1
670                                                                ? "$func(CONCAT_WS('$sep', " . join(', ', @cols) . '))'
671                                                                : "$func($cols[0])";
672                                                      }
673                                                      else {
674   ***      0                                  0         my $fnv_func = uc $func;
675   ***      0                                  0         $query = "$fnv_func(" . join(', ', @cols) . ')';
676                                                      }
677                                                   
678   ***      0                                  0      return $query;
679                                                   }
680                                                   
681                                                   sub make_checksum_query {
682   ***      0                    0             0      my ( $self, %args ) = @_;
683   ***      0                                  0      my @required_args = qw(db tbl tbl_struct algorithm crc_wid crc_type);
684   ***      0                                  0      foreach my $arg( @required_args ) {
685   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
686                                                      }
687   ***      0                                  0      my ( $db, $tbl, $tbl_struct, $algorithm,
688                                                           $crc_wid, $crc_type) = @args{@required_args};
689   ***      0                                  0      my $func = $args{function};
690   ***      0                                  0      my $q = $self->{Quoter};
691   ***      0                                  0      my $result;
692                                                   
693   ***      0      0      0                    0      die "Invalid or missing checksum algorithm"
694                                                         unless $algorithm && $ALGOS{$algorithm};
695                                                   
696   ***      0      0                           0      if ( $algorithm eq 'CHECKSUM' ) {
697   ***      0                                  0         return "CHECKSUM TABLE " . $q->quote($db, $tbl);
698                                                      }
699                                                   
700   ***      0                                  0      my $expr = $self->make_row_checksum(%args);
701                                                   
702   ***      0      0                           0      if ( $algorithm eq 'BIT_XOR' ) {
703   ***      0      0                           0         if ( $crc_type =~ m/int$/ ) {
704   ***      0                                  0            $result = "LOWER(CONV(BIT_XOR(CAST($expr AS UNSIGNED)), 10, 16)) AS crc ";
705                                                         }
706                                                         else {
707   ***      0                                  0            my $slices = $self->make_xor_slices( query => $expr, %args );
708   ***      0                                  0            $result = "LOWER(CONCAT($slices)) AS crc ";
709                                                         }
710                                                      }
711                                                      else {
712   ***      0      0                           0         if ( $crc_type =~ m/int$/ ) {
713   ***      0                                  0            $result = "RIGHT(MAX("
714                                                               . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
715                                                               . "CONV(CAST($func(CONCAT(\@crc, $expr)) AS UNSIGNED), 10, 16))"
716                                                               . "), $crc_wid) AS crc ";
717                                                         }
718                                                         else {
719   ***      0                                  0            $result = "RIGHT(MAX("
720                                                               . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
721                                                               . "$func(CONCAT(\@crc, $expr)))"
722                                                               . "), $crc_wid) AS crc ";
723                                                         }
724                                                      }
725   ***      0      0                           0      if ( $args{replicate} ) {
726   ***      0                                  0         $result = "REPLACE /*PROGRESS_COMMENT*/ INTO $args{replicate} "
727                                                            . "(db, tbl, chunk, boundaries, this_cnt, this_crc) "
728                                                            . "SELECT ?, ?, /*CHUNK_NUM*/ ?, COUNT(*) AS cnt, $result";
729                                                      }
730                                                      else {
731   ***      0      0                           0         $result = "SELECT "
732                                                            . ($args{buffer} ? 'SQL_BUFFER_RESULT ' : '')
733                                                            . "/*PROGRESS_COMMENT*//*CHUNK_NUM*/ COUNT(*) AS cnt, $result";
734                                                      }
735   ***      0                                  0      return $result . "FROM /*DB_TBL*//*INDEX_HINT*//*WHERE*/";
736                                                   }
737                                                   
738                                                   sub find_replication_differences {
739   ***      0                    0             0      my ( $self, $dbh, $table ) = @_;
740                                                   
741   ***      0                                  0      (my $sql = <<"   EOF") =~ s/\s+/ /gm;
742                                                         SELECT db, tbl, chunk, boundaries,
743                                                            COALESCE(this_cnt-master_cnt, 0) AS cnt_diff,
744                                                            COALESCE(
745                                                               this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc),
746                                                               0
747                                                            ) AS crc_diff,
748                                                            this_cnt, master_cnt, this_crc, master_crc
749                                                         FROM $table
750                                                         WHERE master_cnt <> this_cnt OR master_crc <> this_crc
751                                                         OR ISNULL(master_crc) <> ISNULL(this_crc)
752                                                      EOF
753                                                   
754   ***      0                                  0      MKDEBUG && _d($sql);
755   ***      0                                  0      my $diffs = $dbh->selectall_arrayref($sql, { Slice => {} });
756   ***      0                                  0      return @$diffs;
757                                                   }
758                                                   
759                                                   sub _d {
760   ***      0                    0             0      my ($package, undef, $line) = caller 0;
761   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
762   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
763                                                           @_;
764   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
765                                                   }
766                                                   
767                                                   1;
768                                                   
769                                                   # ###########################################################################
770                                                   # End TableChecksum package
771                                                   # ###########################################################################
772                                                   
773                                                   # ###########################################################################
774                                                   # OptionParser package 5266
775                                                   # ###########################################################################
776                                                   package OptionParser;
777                                                   
778           23                   23           192   use strict;
              23                                 78   
              23                                156   
779           23                   23           143   use warnings FATAL => 'all';
              23                                 58   
              23                                129   
780                                                   
781           23                   23           268   use Getopt::Long;
              23                                 73   
              23                                249   
782           23                   23           174   use List::Util qw(max);
              23                                 69   
              23                                128   
783           23                   23           149   use English qw(-no_match_vars);
              23                                 57   
              23                                161   
784                                                   
785   ***     23            50     23           164   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                 56   
              23                                350   
786                                                   
787                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
788                                                   
789                                                   my %attributes = (
790                                                      'type'       => 1,
791                                                      'short form' => 1,
792                                                      'group'      => 1,
793                                                      'default'    => 1,
794                                                      'cumulative' => 1,
795                                                      'negatable'  => 1,
796                                                   );
797                                                   
798                                                   sub new {
799   ***      0                    0             0      my ( $class, %args ) = @_;
800   ***      0                                  0      foreach my $arg ( qw(description) ) {
801   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
802                                                      }
803   ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
804   ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
805   ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
806                                                   
807   ***      0      0      0                    0      my $self = {
      ***                    0                        
808                                                         description    => $args{description},
809                                                         prompt         => $args{prompt} || '<options>',
810                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
811                                                         dp             => $args{dp}     || undef,
812                                                         program_name   => $program_name,
813                                                         opts           => {},
814                                                         got_opts       => 0,
815                                                         short_opts     => {},
816                                                         defaults       => {},
817                                                         groups         => {},
818                                                         allowed_groups => {},
819                                                         errors         => [],
820                                                         rules          => [],  # desc of rules for --help
821                                                         mutex          => [],  # rule: opts are mutually exclusive
822                                                         atleast1       => [],  # rule: at least one opt is required
823                                                         disables       => {},  # rule: opt disables other opts 
824                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
825                                                         default_files  => [
826                                                            "/etc/maatkit/maatkit.conf",
827                                                            "/etc/maatkit/$program_name.conf",
828                                                            "$home/.maatkit.conf",
829                                                            "$home/.$program_name.conf",
830                                                         ],
831                                                      };
832   ***      0                                  0      return bless $self, $class;
833                                                   }
834                                                   
835                                                   sub get_specs {
836   ***      0                    0             0      my ( $self, $file ) = @_;
837   ***      0                                  0      my @specs = $self->_pod_to_specs($file);
838   ***      0                                  0      $self->_parse_specs(@specs);
839   ***      0                                  0      return;
840                                                   }
841                                                   
842                                                   sub get_defaults_files {
843   ***      0                    0             0      my ( $self ) = @_;
844   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
845                                                   }
846                                                   
847                                                   sub _pod_to_specs {
848   ***      0                    0             0      my ( $self, $file ) = @_;
849   ***      0             0                    0      $file ||= __FILE__;
850   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
851                                                   
852   ***      0                                  0      my %types = (
853                                                         string => 's', # standard Getopt type
854                                                         'int'  => 'i', # standard Getopt type
855                                                         float  => 'f', # standard Getopt type
856                                                         Hash   => 'H', # hash, formed from a comma-separated list
857                                                         hash   => 'h', # hash as above, but only if a value is given
858                                                         Array  => 'A', # array, similar to Hash
859                                                         array  => 'a', # array, similar to hash
860                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
861                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
862                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
863                                                      );
864   ***      0                                  0      my @specs = ();
865   ***      0                                  0      my @rules = ();
866   ***      0                                  0      my $para;
867                                                   
868   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
869   ***      0                                  0      while ( $para = <$fh> ) {
870   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
871   ***      0                                  0         last;
872                                                      }
873                                                   
874   ***      0                                  0      while ( $para = <$fh> ) {
875   ***      0      0                           0         last if $para =~ m/^=over/;
876   ***      0                                  0         chomp $para;
877   ***      0                                  0         $para =~ s/\s+/ /g;
878   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
879   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
880   ***      0                                  0         push @rules, $para;
881                                                      }
882                                                   
883   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
884                                                   
885   ***      0                                  0      do {
886   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
887   ***      0                                  0            chomp $para;
888   ***      0                                  0            MKDEBUG && _d($para);
889   ***      0                                  0            my %attribs;
890                                                   
891   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
892                                                   
893   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
894   ***      0                                  0               $para =~ s/\s+\Z//g;
895   ***      0                                  0               %attribs = map {
896   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
897   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
898                                                                        unless $attributes{$attrib};
899   ***      0                                  0                     ($attrib, $val);
900                                                                  } split(/; /, $para);
901   ***      0      0                           0               if ( $attribs{'short form'} ) {
902   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
903                                                               }
904   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
905                                                            }
906                                                            else {
907   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
908                                                            }
909                                                   
910   ***      0                                  0            $para =~ s/\s+\Z//g;
911   ***      0                                  0            $para =~ s/\s+/ /g;
912   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
913                                                   
914   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
915   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
916                                                   
917   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
918                                                   
919   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
920   ***      0                                  0               $option = $base_option;
921   ***      0                                  0               $attribs{'negatable'} = 1;
922                                                            }
923                                                   
924   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
925                                                               spec  => $option
926                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
927                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
928                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
929                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
930                                                               desc  => $para
931                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
932                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
933                                                            };
934                                                         }
935   ***      0                                  0         while ( $para = <$fh> ) {
936   ***      0      0                           0            last unless $para;
937                                                   
938                                                   
939   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
940   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
941   ***      0                                  0               last;
942                                                            }
943   ***      0      0                           0            last if $para =~ m/^=item --/;
944                                                         }
945                                                      } while ( $para );
946                                                   
947   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
948                                                   
949   ***      0                                  0      close $fh;
950   ***      0                                  0      return @specs, @rules;
951                                                   }
952                                                   
953                                                   sub _parse_specs {
954   ***      0                    0             0      my ( $self, @specs ) = @_;
955   ***      0                                  0      my %disables; # special rule that requires deferred checking
956                                                   
957   ***      0                                  0      foreach my $opt ( @specs ) {
958   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
959                                                            MKDEBUG && _d('Parsing opt spec:',
960   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
961                                                   
962   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
963   ***      0      0                           0            if ( !$long ) {
964   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
965                                                            }
966   ***      0                                  0            $opt->{long} = $long;
967                                                   
968   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
969   ***      0                                  0            $self->{opts}->{$long} = $opt;
970                                                   
971   ***      0      0                           0            if ( length $long == 1 ) {
972   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
973   ***      0                                  0               $self->{short_opts}->{$long} = $long;
974                                                            }
975                                                   
976   ***      0      0                           0            if ( $short ) {
977   ***      0      0                           0               die "Duplicate short option -$short"
978                                                                  if exists $self->{short_opts}->{$short};
979   ***      0                                  0               $self->{short_opts}->{$short} = $long;
980   ***      0                                  0               $opt->{short} = $short;
981                                                            }
982                                                            else {
983   ***      0                                  0               $opt->{short} = undef;
984                                                            }
985                                                   
986   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
987   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
988   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
989                                                   
990   ***      0             0                    0            $opt->{group} ||= 'default';
991   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
992                                                   
993   ***      0                                  0            $opt->{value} = undef;
994   ***      0                                  0            $opt->{got}   = 0;
995                                                   
996   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
997   ***      0                                  0            $opt->{type} = $type;
998   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
999                                                   
1000  ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
1001  ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
1002                                                                 . "was given when this OptionParser object was created";
1003                                                           }
1004                                                  
1005  ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
1006                                                  
1007  ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
1008  ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
1009  ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
1010                                                           }
1011                                                  
1012  ***      0      0                           0            if ( $long eq 'config' ) {
1013  ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
1014                                                           }
1015                                                  
1016  ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
1017  ***      0                                  0               $disables{$long} = $dis;
1018  ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
1019                                                           }
1020                                                  
1021  ***      0                                  0            $self->{opts}->{$long} = $opt;
1022                                                        }
1023                                                        else { # It's an option rule, not a spec.
1024  ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
1025  ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
1026  ***      0                                  0            my @participants = $self->_get_participants($opt);
1027  ***      0                                  0            my $rule_ok = 0;
1028                                                  
1029  ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
1030  ***      0                                  0               $rule_ok = 1;
1031  ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
1032  ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
1033                                                           }
1034  ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
1035  ***      0                                  0               $rule_ok = 1;
1036  ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
1037  ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
1038                                                           }
1039  ***      0      0                           0            if ( $opt =~ m/default to/ ) {
1040  ***      0                                  0               $rule_ok = 1;
1041  ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
1042  ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
1043                                                           }
1044  ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
1045  ***      0                                  0               $rule_ok = 1;
1046  ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
1047  ***      0                                  0               my @groups = split(',', $groups);
1048  ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
1049  ***      0                                  0                  s/\s+//;
1050  ***      0                                  0                  $_ => 1;
1051                                                              } @groups;
1052                                                           }
1053                                                  
1054  ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
1055                                                        }
1056                                                     }
1057                                                  
1058  ***      0                                  0      foreach my $long ( keys %disables ) {
1059  ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
1060  ***      0                                  0         $self->{disables}->{$long} = \@participants;
1061  ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
1062                                                     }
1063                                                  
1064  ***      0                                  0      return; 
1065                                                  }
1066                                                  
1067                                                  sub _get_participants {
1068  ***      0                    0             0      my ( $self, $str ) = @_;
1069  ***      0                                  0      my @participants;
1070  ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
1071  ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
1072                                                           unless exists $self->{opts}->{$long};
1073  ***      0                                  0         push @participants, $long;
1074                                                     }
1075  ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
1076  ***      0                                  0      return @participants;
1077                                                  }
1078                                                  
1079                                                  sub opts {
1080  ***      0                    0             0      my ( $self ) = @_;
1081  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1082  ***      0                                  0      return %opts;
1083                                                  }
1084                                                  
1085                                                  sub short_opts {
1086  ***      0                    0             0      my ( $self ) = @_;
1087  ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
1088  ***      0                                  0      return %short_opts;
1089                                                  }
1090                                                  
1091                                                  sub set_defaults {
1092  ***      0                    0             0      my ( $self, %defaults ) = @_;
1093  ***      0                                  0      $self->{defaults} = {};
1094  ***      0                                  0      foreach my $long ( keys %defaults ) {
1095  ***      0      0                           0         die "Cannot set default for nonexistent option $long"
1096                                                           unless exists $self->{opts}->{$long};
1097  ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
1098  ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
1099                                                     }
1100  ***      0                                  0      return;
1101                                                  }
1102                                                  
1103                                                  sub get_defaults {
1104  ***      0                    0             0      my ( $self ) = @_;
1105  ***      0                                  0      return $self->{defaults};
1106                                                  }
1107                                                  
1108                                                  sub get_groups {
1109  ***      0                    0             0      my ( $self ) = @_;
1110  ***      0                                  0      return $self->{groups};
1111                                                  }
1112                                                  
1113                                                  sub _set_option {
1114  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1115  ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
1116                                                              : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
1117                                                              : die "Getopt::Long gave a nonexistent option: $opt";
1118                                                  
1119  ***      0                                  0      $opt = $self->{opts}->{$long};
1120  ***      0      0                           0      if ( $opt->{is_cumulative} ) {
1121  ***      0                                  0         $opt->{value}++;
1122                                                     }
1123                                                     else {
1124  ***      0                                  0         $opt->{value} = $val;
1125                                                     }
1126  ***      0                                  0      $opt->{got} = 1;
1127  ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
1128                                                  }
1129                                                  
1130                                                  sub get_opts {
1131  ***      0                    0             0      my ( $self ) = @_; 
1132                                                  
1133  ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
1134  ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
1135  ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
1136                                                           = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
1137                                                           : $self->{opts}->{$long}->{is_cumulative} ? 0
1138                                                           : undef;
1139                                                     }
1140  ***      0                                  0      $self->{got_opts} = 0;
1141                                                  
1142  ***      0                                  0      $self->{errors} = [];
1143                                                  
1144  ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
1145  ***      0                                  0         shift @ARGV;
1146  ***      0                                  0         $self->_set_option('config', shift @ARGV);
1147                                                     }
1148  ***      0      0                           0      if ( $self->has('config') ) {
1149  ***      0                                  0         my @extra_args;
1150  ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
1151  ***      0                                  0            eval {
1152  ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
1153                                                           };
1154  ***      0      0                           0            if ( $EVAL_ERROR ) {
1155  ***      0      0                           0               if ( $self->got('config') ) {
1156  ***      0                                  0                  die $EVAL_ERROR;
1157                                                              }
1158                                                              elsif ( MKDEBUG ) {
1159                                                                 _d($EVAL_ERROR);
1160                                                              }
1161                                                           }
1162                                                        }
1163  ***      0                                  0         unshift @ARGV, @extra_args;
1164                                                     }
1165                                                  
1166  ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
1167                                                     GetOptions(
1168  ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
1169  ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
1170  ***      0      0                           0         values %{$self->{opts}}
1171                                                     ) or $self->save_error('Error parsing options');
1172                                                  
1173  ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
1174  ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
1175                                                           $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1176                                                              or die "Cannot print: $OS_ERROR";
1177  ***      0                                  0         exit 0;
1178                                                     }
1179                                                  
1180  ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
1181  ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
1182                                                     }
1183                                                  
1184  ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
1185  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
1186  ***      0      0                           0         if ( @set > 1 ) {
1187  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1188  ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
1189                                                                   . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
1190                                                                   . ' are mutually exclusive.';
1191  ***      0                                  0            $self->save_error($err);
1192                                                        }
1193                                                     }
1194                                                  
1195  ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
1196  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
1197  ***      0      0                           0         if ( @set == 0 ) {
1198  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1199  ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
1200                                                                   .' or --'.$self->{opts}->{$required->[-1]}->{long};
1201  ***      0                                  0            $self->save_error("Specify at least one of $err");
1202                                                        }
1203                                                     }
1204                                                  
1205  ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
1206  ***      0                                  0         my $opt = $self->{opts}->{$long};
1207  ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
1208  ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
1209  ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
1210  ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
1211  ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
1212                                                                 'because', $long,'disables them');
1213                                                           }
1214                                                  
1215  ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
1216                                                  
1217  ***      0                                  0               my @restricted_groups = grep {
1218  ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
1219  ***      0                                  0               } keys %{$self->{groups}};
1220                                                  
1221  ***      0                                  0               my @restricted_opts;
1222  ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
1223  ***      0                                  0                  RESTRICTED_OPT:
1224  ***      0                                  0                  foreach my $restricted_opt (
1225                                                                    keys %{$self->{groups}->{$restricted_group}} )
1226                                                                 {
1227  ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
1228  ***      0      0                           0                     push @restricted_opts, $restricted_opt
1229                                                                       if $self->{opts}->{$restricted_opt}->{got};
1230                                                                 }
1231                                                              }
1232                                                  
1233  ***      0      0                           0               if ( @restricted_opts ) {
1234  ***      0                                  0                  my $err;
1235  ***      0      0                           0                  if ( @restricted_opts == 1 ) {
1236  ***      0                                  0                     $err = "--$restricted_opts[0]";
1237                                                                 }
1238                                                                 else {
1239  ***      0                                  0                     $err = join(', ',
1240  ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
1241  ***      0                                  0                               grep { $_ } 
1242                                                                              @restricted_opts[0..scalar(@restricted_opts) - 2]
1243                                                                           )
1244                                                                         . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1245                                                                 }
1246  ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
1247                                                              }
1248                                                           }
1249                                                  
1250                                                        }
1251                                                        elsif ( $opt->{is_required} ) { 
1252  ***      0                                  0            $self->save_error("Required option --$long must be specified");
1253                                                        }
1254                                                  
1255  ***      0                                  0         $self->_validate_type($opt);
1256                                                     }
1257                                                  
1258  ***      0                                  0      $self->{got_opts} = 1;
1259  ***      0                                  0      return;
1260                                                  }
1261                                                  
1262                                                  sub _validate_type {
1263  ***      0                    0             0      my ( $self, $opt ) = @_;
1264  ***      0      0      0                    0      return unless $opt && $opt->{type};
1265  ***      0                                  0      my $val = $opt->{value};
1266                                                  
1267  ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
1268  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1269  ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1270  ***      0      0                           0         if ( !$suffix ) {
1271  ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1272  ***      0             0                    0            $suffix = $s || 's';
1273  ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1274                                                              $opt->{long}, '(value:', $val, ')');
1275                                                        }
1276  ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
1277  ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
1278                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1279                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1280                                                                :                  $num * 86400;   # Days
1281  ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
1282  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1283                                                        }
1284                                                        else {
1285  ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
1286                                                        }
1287                                                     }
1288                                                     elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
1289  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1290  ***      0                                  0         my $prev = {};
1291  ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
1292  ***      0      0                           0         if ( $from_key ) {
1293  ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1294  ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
1295                                                        }
1296  ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
1297  ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
1298                                                     }
1299                                                     elsif ( $val && $opt->{type} eq 'z' ) {  # type size
1300  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1301  ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1302  ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1303  ***      0      0                           0         if ( defined $num ) {
1304  ***      0      0                           0            if ( $factor ) {
1305  ***      0                                  0               $num *= $factor_for{$factor};
1306  ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
1307                                                                 'to num', $num, '* factor', $factor);
1308                                                           }
1309  ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
1310                                                        }
1311                                                        else {
1312  ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
1313                                                        }
1314                                                     }
1315                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1316  ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
1317                                                     }
1318                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1319  ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
1320                                                     }
1321                                                     else {
1322  ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
1323                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1324                                                     }
1325                                                  
1326  ***      0                                  0      return;
1327                                                  }
1328                                                  
1329                                                  sub get {
1330  ***      0                    0             0      my ( $self, $opt ) = @_;
1331  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1332  ***      0      0      0                    0      die "Option $opt does not exist"
1333                                                        unless $long && exists $self->{opts}->{$long};
1334  ***      0                                  0      return $self->{opts}->{$long}->{value};
1335                                                  }
1336                                                  
1337                                                  sub got {
1338  ***      0                    0             0      my ( $self, $opt ) = @_;
1339  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1340  ***      0      0      0                    0      die "Option $opt does not exist"
1341                                                        unless $long && exists $self->{opts}->{$long};
1342  ***      0                                  0      return $self->{opts}->{$long}->{got};
1343                                                  }
1344                                                  
1345                                                  sub has {
1346  ***      0                    0             0      my ( $self, $opt ) = @_;
1347  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1348  ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
1349                                                  }
1350                                                  
1351                                                  sub set {
1352  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1353  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1354  ***      0      0      0                    0      die "Option $opt does not exist"
1355                                                        unless $long && exists $self->{opts}->{$long};
1356  ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
1357  ***      0                                  0      return;
1358                                                  }
1359                                                  
1360                                                  sub save_error {
1361  ***      0                    0             0      my ( $self, $error ) = @_;
1362  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1363                                                  }
1364                                                  
1365                                                  sub errors {
1366  ***      0                    0             0      my ( $self ) = @_;
1367  ***      0                                  0      return $self->{errors};
1368                                                  }
1369                                                  
1370                                                  sub prompt {
1371  ***      0                    0             0      my ( $self ) = @_;
1372  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1373                                                  }
1374                                                  
1375                                                  sub descr {
1376  ***      0                    0             0      my ( $self ) = @_;
1377  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1378                                                                . "  For more details, please use the --help option, "
1379                                                                . "or try 'perldoc $PROGRAM_NAME' "
1380                                                                . "for complete documentation.";
1381  ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
1382  ***      0                                  0      $descr =~ s/ +$//mg;
1383  ***      0                                  0      return $descr;
1384                                                  }
1385                                                  
1386                                                  sub usage_or_errors {
1387  ***      0                    0             0      my ( $self ) = @_;
1388  ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
1389  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1390  ***      0                                  0         exit 0;
1391                                                     }
1392                                                     elsif ( scalar @{$self->{errors}} ) {
1393  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1394  ***      0                                  0         exit 0;
1395                                                     }
1396  ***      0                                  0      return;
1397                                                  }
1398                                                  
1399                                                  sub print_errors {
1400  ***      0                    0             0      my ( $self ) = @_;
1401  ***      0                                  0      my $usage = $self->prompt() . "\n";
1402  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1403  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1404                                                                . "\n";
1405                                                     }
1406  ***      0                                  0      return $usage . "\n" . $self->descr();
1407                                                  }
1408                                                  
1409                                                  sub print_usage {
1410  ***      0                    0             0      my ( $self ) = @_;
1411  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1412  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1413                                                  
1414  ***      0      0                           0      my $maxl = max(
1415  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1416                                                        @opts);
1417                                                  
1418  ***      0      0                           0      my $maxs = max(0,
1419  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1420  ***      0                                  0         values %{$self->{short_opts}});
1421                                                  
1422  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1423  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1424  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1425                                                  
1426  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1427                                                  
1428  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1429                                                  
1430  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1431  ***      0                                  0      push @groups, 'default';
1432                                                  
1433  ***      0                                  0      foreach my $group ( reverse @groups ) {
1434  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1435  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1436  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1437                                                           grep { $_->{group} eq $group }
1438                                                           @opts )
1439                                                        {
1440  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1441  ***      0                                  0            my $short = $opt->{short};
1442  ***      0                                  0            my $desc  = $opt->{desc};
1443  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1444  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1445  ***      0             0                    0               $s    ||= 's';
1446  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1447  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1448                                                                     . "d=days; if no suffix, $s is used.";
1449                                                           }
1450  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1451  ***      0                                  0            $desc =~ s/ +$//mg;
1452  ***      0      0                           0            if ( $short ) {
1453  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1454                                                           }
1455                                                           else {
1456  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1457                                                           }
1458                                                        }
1459                                                     }
1460                                                  
1461  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1462  ***      0                                  0         $usage .= "\nRules:\n\n";
1463  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1464                                                     }
1465  ***      0      0                           0      if ( $self->{dp} ) {
1466  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1467                                                     }
1468  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1469  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1470  ***      0                                  0         my $val   = $opt->{value};
1471  ***      0             0                    0         my $type  = $opt->{type} || '';
1472  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1473  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1474                                                                  : !defined $val             ? '(No value)'
1475                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1476                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1477                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1478                                                                  :                             $val;
1479  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1480                                                     }
1481  ***      0                                  0      return $usage;
1482                                                  }
1483                                                  
1484                                                  sub prompt_noecho {
1485  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1486  ***      0                                  0      my ( $prompt ) = @_;
1487  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1488  ***      0      0                           0      print $prompt
1489                                                        or die "Cannot print: $OS_ERROR";
1490  ***      0                                  0      my $response;
1491  ***      0                                  0      eval {
1492  ***      0                                  0         require Term::ReadKey;
1493  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1494  ***      0                                  0         chomp($response = <STDIN>);
1495  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1496  ***      0      0                           0         print "\n"
1497                                                           or die "Cannot print: $OS_ERROR";
1498                                                     };
1499  ***      0      0                           0      if ( $EVAL_ERROR ) {
1500  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1501                                                     }
1502  ***      0                                  0      return $response;
1503                                                  }
1504                                                  
1505                                                  if ( MKDEBUG ) {
1506                                                     print '# ', $^X, ' ', $], "\n";
1507                                                     my $uname = `uname -a`;
1508                                                     if ( $uname ) {
1509                                                        $uname =~ s/\s+/ /g;
1510                                                        print "# $uname\n";
1511                                                     }
1512                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1513                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1514                                                        ($main::SVN_REV || ''), __LINE__);
1515                                                     print('# Arguments: ',
1516                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1517                                                  }
1518                                                  
1519                                                  sub _read_config_file {
1520  ***      0                    0             0      my ( $self, $filename ) = @_;
1521  ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1522  ***      0                                  0      my @args;
1523  ***      0                                  0      my $prefix = '--';
1524  ***      0                                  0      my $parse  = 1;
1525                                                  
1526                                                     LINE:
1527  ***      0                                  0      while ( my $line = <$fh> ) {
1528  ***      0                                  0         chomp $line;
1529  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1530  ***      0                                  0         $line =~ s/\s+#.*$//g;
1531  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1532  ***      0      0                           0         if ( $line eq '--' ) {
1533  ***      0                                  0            $prefix = '';
1534  ***      0                                  0            $parse  = 0;
1535  ***      0                                  0            next LINE;
1536                                                        }
1537  ***      0      0      0                    0         if ( $parse
      ***             0                               
1538                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1539                                                        ) {
1540  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1541                                                        }
1542                                                        elsif ( $line =~ m/./ ) {
1543  ***      0                                  0            push @args, $line;
1544                                                        }
1545                                                        else {
1546  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1547                                                        }
1548                                                     }
1549  ***      0                                  0      close $fh;
1550  ***      0                                  0      return @args;
1551                                                  }
1552                                                  
1553                                                  sub read_para_after {
1554  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1555  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1556  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1557  ***      0                                  0      my $para;
1558  ***      0                                  0      while ( $para = <$fh> ) {
1559  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1560  ***      0                                  0         last;
1561                                                     }
1562  ***      0                                  0      while ( $para = <$fh> ) {
1563  ***      0      0                           0         next unless $para =~ m/$regex/;
1564  ***      0                                  0         last;
1565                                                     }
1566  ***      0                                  0      $para = <$fh>;
1567  ***      0                                  0      chomp($para);
1568  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1569  ***      0                                  0      return $para;
1570                                                  }
1571                                                  
1572                                                  sub clone {
1573  ***      0                    0             0      my ( $self ) = @_;
1574                                                  
1575  ***      0                                  0      my %clone = map {
1576  ***      0                                  0         my $hashref  = $self->{$_};
1577  ***      0                                  0         my $val_copy = {};
1578  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1579  ***      0                                  0            my $ref = ref $hashref->{$key};
1580  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1581  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1582  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1583                                                                             : $hashref->{$key};
1584                                                        }
1585  ***      0                                  0         $_ => $val_copy;
1586                                                     } qw(opts short_opts defaults);
1587                                                  
1588  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1589  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1590                                                     }
1591                                                  
1592  ***      0                                  0      return bless \%clone;     
1593                                                  }
1594                                                  
1595                                                  sub _d {
1596  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1597  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1598  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1599                                                          @_;
1600  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1601                                                  }
1602                                                  
1603                                                  1;
1604                                                  
1605                                                  # ###########################################################################
1606                                                  # End OptionParser package
1607                                                  # ###########################################################################
1608                                                  
1609                                                  # ###########################################################################
1610                                                  # DSNParser package 5266
1611                                                  # ###########################################################################
1612                                                  package DSNParser;
1613                                                  
1614          23                   23           256   use strict;
              23                                 67   
              23                                188   
1615          23                   23           256   use warnings FATAL => 'all';
              23                                 63   
              23                                180   
1616          23                   23           148   use English qw(-no_match_vars);
              23                                 62   
              23                                152   
1617          23                   23           157   use Data::Dumper;
              23                                 59   
              23                                149   
1618                                                  $Data::Dumper::Indent    = 0;
1619                                                  $Data::Dumper::Quotekeys = 0;
1620                                                  
1621                                                  eval {
1622                                                     require DBI;
1623                                                  };
1624                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1625                                                  
1626  ***     23            50     23           162   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                 63   
              23                                354   
1627                                                  
1628                                                  sub new {
1629          22                   22           112      my ( $class, @opts ) = @_;
1630          22                                543      my $self = {
1631                                                        opts => {
1632                                                           A => {
1633                                                              desc => 'Default character set',
1634                                                              dsn  => 'charset',
1635                                                              copy => 1,
1636                                                           },
1637                                                           D => {
1638                                                              desc => 'Database to use',
1639                                                              dsn  => 'database',
1640                                                              copy => 1,
1641                                                           },
1642                                                           F => {
1643                                                              desc => 'Only read default options from the given file',
1644                                                              dsn  => 'mysql_read_default_file',
1645                                                              copy => 1,
1646                                                           },
1647                                                           h => {
1648                                                              desc => 'Connect to host',
1649                                                              dsn  => 'host',
1650                                                              copy => 1,
1651                                                           },
1652                                                           p => {
1653                                                              desc => 'Password to use when connecting',
1654                                                              dsn  => 'password',
1655                                                              copy => 1,
1656                                                           },
1657                                                           P => {
1658                                                              desc => 'Port number to use for connection',
1659                                                              dsn  => 'port',
1660                                                              copy => 1,
1661                                                           },
1662                                                           S => {
1663                                                              desc => 'Socket file to use for connection',
1664                                                              dsn  => 'mysql_socket',
1665                                                              copy => 1,
1666                                                           },
1667                                                           u => {
1668                                                              desc => 'User for login if not current user',
1669                                                              dsn  => 'user',
1670                                                              copy => 1,
1671                                                           },
1672                                                        },
1673                                                     };
1674          22                                115      foreach my $opt ( @opts ) {
1675  ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
1676  ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1677                                                     }
1678          22                                308      return bless $self, $class;
1679                                                  }
1680                                                  
1681                                                  sub prop {
1682          93                   93           445      my ( $self, $prop, $value ) = @_;
1683  ***     93     50                         464      if ( @_ > 2 ) {
1684  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1685  ***      0                                  0         $self->{$prop} = $value;
1686                                                     }
1687          93                                820      return $self->{$prop};
1688                                                  }
1689                                                  
1690                                                  sub parse {
1691          31                   31          1353      my ( $self, $dsn, $prev, $defaults ) = @_;
1692  ***     31     50                         213      if ( !$dsn ) {
1693  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1694  ***      0                                  0         return;
1695                                                     }
1696          31                                131      MKDEBUG && _d('Parsing', $dsn);
1697  ***     31            50                  145      $prev     ||= {};
1698  ***     31            50                  138      $defaults ||= {};
1699          31                               1244      my %given_props;
1700          31                                105      my %final_props;
1701          31                                 94      my %opts = %{$self->{opts}};
              31                                301   
1702                                                  
1703          31                                275      foreach my $dsn_part ( split(/,/, $dsn) ) {
1704  ***    124     50                        1023         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1705         124                                549            $given_props{$prop_key} = $prop_val;
1706                                                        }
1707                                                        else {
1708  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1709  ***      0                                  0            $given_props{h} = $dsn_part;
1710                                                        }
1711                                                     }
1712                                                  
1713          31                                177      foreach my $key ( keys %opts ) {
1714         248                                525         MKDEBUG && _d('Finding value for', $key);
1715         248                                830         $final_props{$key} = $given_props{$key};
1716  ***    248     50     66                 1935         if (   !defined $final_props{$key}
      ***                   33                        
1717                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1718                                                        {
1719  ***      0                                  0            $final_props{$key} = $prev->{$key};
1720  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1721                                                        }
1722         248    100                        1058         if ( !defined $final_props{$key} ) {
1723         124                                401            $final_props{$key} = $defaults->{$key};
1724         124                                335            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1725                                                        }
1726                                                     }
1727                                                  
1728          31                                168      foreach my $key ( keys %given_props ) {
1729  ***    124     50                         557         die "Unrecognized DSN part '$key' in '$dsn'\n"
1730                                                           unless exists $opts{$key};
1731                                                     }
1732  ***     31     50                         168      if ( (my $required = $self->prop('required')) ) {
1733  ***      0                                  0         foreach my $key ( keys %$required ) {
1734  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1735                                                        }
1736                                                     }
1737                                                  
1738          31                                217      return \%final_props;
1739                                                  }
1740                                                  
1741                                                  sub parse_options {
1742  ***      0                    0             0      my ( $self, $o ) = @_;
1743  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1744  ***      0                                  0      my $dsn_string
1745                                                        = join(',',
1746  ***      0      0                           0             map  { "$_=".$o->get($_); }
1747  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1748  ***      0                                  0             keys %{$self->{opts}}
1749                                                          );
1750  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1751  ***      0                                  0      return $self->parse($dsn_string);
1752                                                  }
1753                                                  
1754                                                  sub as_string {
1755  ***      0                    0             0      my ( $self, $dsn ) = @_;
1756  ***      0      0                           0      return $dsn unless ref $dsn;
1757  ***      0      0                           0      return join(',',
1758  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1759  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1760                                                        sort keys %$dsn );
1761                                                  }
1762                                                  
1763                                                  sub usage {
1764  ***      0                    0             0      my ( $self ) = @_;
1765  ***      0                                  0      my $usage
1766                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1767                                                        . "  KEY  COPY  MEANING\n"
1768                                                        . "  ===  ====  =============================================\n";
1769  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1770  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1771  ***      0      0      0                    0         $usage .= "  $key    "
1772                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1773                                                               .  ($opts{$key}->{desc} || '[No description]')
1774                                                               . "\n";
1775                                                     }
1776  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1777  ***      0                                  0      return $usage;
1778                                                  }
1779                                                  
1780                                                  sub get_cxn_params {
1781          31                   31           413      my ( $self, $info ) = @_;
1782          31                                104      my $dsn;
1783          31                                 90      my %opts = %{$self->{opts}};
              31                                247   
1784  ***     31            50                  159      my $driver = $self->prop('dbidriver') || '';
1785  ***     31     50                         156      if ( $driver eq 'Pg' ) {
1786  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1787  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1788  ***      0             0                    0                        grep { defined $info->{$_} }
1789                                                                       qw(h P));
1790                                                     }
1791                                                     else {
1792          62                                439         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1793         155                                581            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1794  ***     31            50                  374                        grep { defined $info->{$_} }
1795                                                                       qw(F h P S A))
1796                                                           . ';mysql_read_default_group=client';
1797                                                     }
1798          31                                 98      MKDEBUG && _d($dsn);
1799          31                                256      return ($dsn, $info->{u}, $info->{p});
1800                                                  }
1801                                                  
1802                                                  sub fill_in_dsn {
1803  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1804  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1805  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1806  ***      0                                  0      $user =~ s/@.*//;
1807  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1808  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1809  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1810  ***      0             0                    0      $dsn->{u} ||= $user;
1811  ***      0             0                    0      $dsn->{D} ||= $db;
1812                                                  }
1813                                                  
1814                                                  sub get_dbh {
1815          31                   31           193      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1816  ***     31            50                  152      $opts ||= {};
1817  ***     31     50                         303      my $defaults = {
1818                                                        AutoCommit         => 0,
1819                                                        RaiseError         => 1,
1820                                                        PrintError         => 0,
1821                                                        ShowErrorStatement => 1,
1822                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1823                                                     };
1824          31                                159      @{$defaults}{ keys %$opts } = values %$opts;
              31                                131   
1825                                                  
1826  ***     31     50                         143      if ( !$have_dbi ) {
1827  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1828                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1829                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1830                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1831                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1832                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1833                                                  
1834                                                     }
1835                                                  
1836          31                                 86      my $dbh;
1837          31                                 96      my $tries = 2;
1838  ***     31            66                  310      while ( !$dbh && $tries-- ) {
1839                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1840          31                                 77            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1841                                                  
1842          31                                 91         eval {
1843          31                                211            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1844                                                  
1845  ***     31     50                         350            if ( $cxn_string =~ m/mysql/i ) {
1846          31                                121               my $sql;
1847                                                  
1848          31                                117               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1849                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1850          31                                 88               MKDEBUG && _d($dbh, ':', $sql);
1851          31                               3955               $dbh->do($sql);
1852                                                  
1853  ***     31     50                         308               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1854  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1855  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1856  ***      0                                  0                  $dbh->do($sql);
1857  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1858  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1859  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1860                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1861                                                                 }
1862                                                                 else {
1863  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1864                                                                 }
1865                                                              }
1866                                                  
1867  ***     31     50                         203               if ( $self->prop('set-vars') ) {
1868  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1869  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1870  ***      0                                  0                  $dbh->do($sql);
1871                                                              }
1872                                                           }
1873                                                        };
1874  ***     31     50     33                  361         if ( !$dbh && $EVAL_ERROR ) {
1875  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1876  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1877  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1878  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1879                                                           }
1880                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1881  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1882                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1883                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1884                                                                 . "DBD::mysql is not installed, try:\n"
1885                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1886                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1887                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1888                                                           }
1889  ***      0      0                           0            if ( !$tries ) {
1890  ***      0                                  0               die $EVAL_ERROR;
1891                                                           }
1892                                                        }
1893                                                     }
1894                                                  
1895          31                                116      MKDEBUG && _d('DBH info: ',
1896                                                        $dbh,
1897                                                        Dumper($dbh->selectrow_hashref(
1898                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1899                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1900                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1901                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1902                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1903                                                        '$DBI::VERSION:',        $DBI::VERSION,
1904                                                     );
1905                                                  
1906          31                                202      return $dbh;
1907                                                  }
1908                                                  
1909                                                  sub get_hostname {
1910  ***      0                    0             0      my ( $self, $dbh ) = @_;
1911  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1912  ***      0                                  0         return $host;
1913                                                     }
1914  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1915                                                        'SELECT /*!50038 @@hostname, */ 1');
1916  ***      0                                  0      return $hostname;
1917                                                  }
1918                                                  
1919                                                  sub disconnect {
1920  ***      0                    0             0      my ( $self, $dbh ) = @_;
1921  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1922  ***      0                                  0      $dbh->disconnect;
1923                                                  }
1924                                                  
1925                                                  sub print_active_handles {
1926  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1927  ***      0             0                    0      $level ||= 0;
1928  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1929                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1930                                                        or die "Cannot print: $OS_ERROR";
1931  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1932  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1933                                                     }
1934                                                  }
1935                                                  
1936                                                  sub copy {
1937  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1938  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1939  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1940  ***      0                                  0      my %new_dsn = map {
1941  ***      0                                  0         my $key = $_;
1942  ***      0                                  0         my $val;
1943  ***      0      0                           0         if ( $args{overwrite} ) {
1944  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1945                                                        }
1946                                                        else {
1947  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1948                                                        }
1949  ***      0                                  0         $key => $val;
1950  ***      0                                  0      } keys %{$self->{opts}};
1951  ***      0                                  0      return \%new_dsn;
1952                                                  }
1953                                                  
1954                                                  sub _d {
1955  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1956  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1957  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1958                                                          @_;
1959  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1960                                                  }
1961                                                  
1962                                                  1;
1963                                                  
1964                                                  # ###########################################################################
1965                                                  # End DSNParser package
1966                                                  # ###########################################################################
1967                                                  
1968                                                  # ###########################################################################
1969                                                  # VersionParser package 5266
1970                                                  # ###########################################################################
1971                                                  package VersionParser;
1972                                                  
1973          23                   23           185   use strict;
              23                                 65   
              23                                140   
1974          23                   23           154   use warnings FATAL => 'all';
              23                                 61   
              23                                140   
1975                                                  
1976          23                   23           140   use English qw(-no_match_vars);
              23                                 72   
              23                                125   
1977                                                  
1978  ***     23            50     23           158   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                317   
              23                                339   
1979                                                  
1980                                                  sub new {
1981           1                    1             4      my ( $class ) = @_;
1982           1                                 13      bless {}, $class;
1983                                                  }
1984                                                  
1985                                                  sub parse {
1986           2                    2           231      my ( $self, $str ) = @_;
1987           2                                 27      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1988           2                                  5      MKDEBUG && _d($str, 'parses to', $result);
1989           2                                 22      return $result;
1990                                                  }
1991                                                  
1992                                                  sub version_ge {
1993           1                    1            10      my ( $self, $dbh, $target ) = @_;
1994  ***      1     50                          10      if ( !$self->{$dbh} ) {
1995           1                                  3         $self->{$dbh} = $self->parse(
1996                                                           $dbh->selectrow_array('SELECT VERSION()'));
1997                                                     }
1998  ***      1     50                          27      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1999           1                                  3      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
2000           1                                  6      return $result;
2001                                                  }
2002                                                  
2003                                                  sub _d {
2004  ***      0                    0                    my ($package, undef, $line) = caller 0;
2005  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2006  ***      0                                              map { defined $_ ? $_ : 'undef' }
2007                                                          @_;
2008  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2009                                                  }
2010                                                  
2011                                                  1;
2012                                                  
2013                                                  # ###########################################################################
2014                                                  # End VersionParser package
2015                                                  # ###########################################################################
2016                                                  
2017                                                  # ###########################################################################
2018                                                  # MySQLDump package 5266
2019                                                  # ###########################################################################
2020                                                  package MySQLDump;
2021                                                  
2022          23                   23           159   use strict;
              23                                 58   
              23                                123   
2023          23                   23           141   use warnings FATAL => 'all';
              23                                 66   
              23                                133   
2024                                                  
2025          23                   23           151   use English qw(-no_match_vars);
              23                                 69   
              23                                357   
2026                                                  
2027  ***     23            50     23           158   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                 61   
              23                               3398   
2028                                                  
2029                                                  ( our $before = <<'EOF') =~ s/^   //gm;
2030                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
2031                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
2032                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
2033                                                     /*!40101 SET NAMES utf8 */;
2034                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
2035                                                     /*!40103 SET TIME_ZONE='+00:00' */;
2036                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
2037                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2038                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2039                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2040                                                  EOF
2041                                                  
2042                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2043                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2044                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2045                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2046                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2047                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2048                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2049                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2050                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2051                                                  EOF
2052                                                  
2053                                                  sub new {
2054  ***      0                    0                    my ( $class, %args ) = @_;
2055  ***      0      0                                  $args{cache} = 1 unless defined $args{cache};
2056  ***      0                                         my $self = bless \%args, $class;
2057  ***      0                                         return $self;
2058                                                  }
2059                                                  
2060                                                  sub dump {
2061  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2062                                                  
2063  ***      0      0                                  if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2064  ***      0                                            my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2065  ***      0      0                                     return unless $ddl;
2066  ***      0      0                                     if ( $ddl->[0] eq 'table' ) {
2067  ***      0                                               return $before
2068                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2069                                                              . $ddl->[1] . ";\n";
2070                                                        }
2071                                                        else {
2072  ***      0                                               return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2073                                                              . '/*!50001 DROP VIEW IF EXISTS '
2074                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2075                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2076                                                        }
2077                                                     }
2078                                                     elsif ( $what eq 'triggers' ) {
2079  ***      0                                            my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2080  ***      0      0      0                              if ( $trgs && @$trgs ) {
2081  ***      0                                               my $result = $before . "\nDELIMITER ;;\n";
2082  ***      0                                               foreach my $trg ( @$trgs ) {
2083  ***      0      0                                           if ( $trg->{sql_mode} ) {
2084  ***      0                                                     $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2085                                                              }
2086  ***      0                                                  $result .= "/*!50003 CREATE */ ";
2087  ***      0      0                                           if ( $trg->{definer} ) {
2088  ***      0                                                     my ( $user, $host )
2089  ***      0                                                        = map { s/'/''/g; "'$_'"; }
      ***      0                                      
2090                                                                      split('@', $trg->{definer}, 2);
2091  ***      0                                                     $result .= "/*!50017 DEFINER=$user\@$host */ ";
2092                                                              }
2093  ***      0                                                  $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2094                                                                 $quoter->quote($trg->{trigger}),
2095  ***      0                                                     @{$trg}{qw(timing event)},
2096                                                                 $quoter->quote($trg->{table}),
2097                                                                 $trg->{statement});
2098                                                           }
2099  ***      0                                               $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2100  ***      0                                               return $result;
2101                                                        }
2102                                                        else {
2103  ***      0                                               return undef;
2104                                                        }
2105                                                     }
2106                                                     elsif ( $what eq 'view' ) {
2107  ***      0                                            my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2108  ***      0                                            return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2109                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2110                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2111                                                     }
2112                                                     else {
2113  ***      0                                            die "You didn't say what to dump.";
2114                                                     }
2115                                                  }
2116                                                  
2117                                                  sub _use_db {
2118  ***      0                    0                    my ( $self, $dbh, $quoter, $new ) = @_;
2119  ***      0      0                                  if ( !$new ) {
2120  ***      0                                            MKDEBUG && _d('No new DB to use');
2121  ***      0                                            return;
2122                                                     }
2123  ***      0                                         my $sql = 'SELECT DATABASE()';
2124  ***      0                                         MKDEBUG && _d($sql);
2125  ***      0                                         my $curr = $dbh->selectrow_array($sql);
2126  ***      0      0      0                           if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
2127  ***      0                                            MKDEBUG && _d('Current and new DB are the same');
2128  ***      0                                            return $curr;
2129                                                     }
2130  ***      0                                         $sql = 'USE ' . $quoter->quote($new);
2131  ***      0                                         MKDEBUG && _d($sql);
2132  ***      0                                         $dbh->do($sql);
2133  ***      0                                         return $curr;
2134                                                  }
2135                                                  
2136                                                  sub get_create_table {
2137  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2138  ***      0      0      0                           if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2139  ***      0                                            my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2140                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2141                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2142                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2143  ***      0                                            MKDEBUG && _d($sql);
2144  ***      0                                            eval { $dbh->do($sql); };
      ***      0                                      
2145  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2146  ***      0                                            my $curr_db = $self->_use_db($dbh, $quoter, $db);
2147  ***      0                                            $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2148  ***      0                                            MKDEBUG && _d($sql);
2149  ***      0                                            my $href;
2150  ***      0                                            eval { $href = $dbh->selectrow_hashref($sql); };
      ***      0                                      
2151  ***      0      0                                     if ( $EVAL_ERROR ) {
2152  ***      0                                               warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2153  ***      0                                               return;
2154                                                        }
2155  ***      0                                            $self->_use_db($dbh, $quoter, $curr_db);
2156  ***      0                                            $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2157                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2158  ***      0                                            MKDEBUG && _d($sql);
2159  ***      0                                            $dbh->do($sql);
2160  ***      0                                            my ($key) = grep { m/create table/i } keys %$href;
      ***      0                                      
2161  ***      0      0                                     if ( $key ) {
2162  ***      0                                               MKDEBUG && _d('This table is a base table');
2163  ***      0                                               $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2164                                                        }
2165                                                        else {
2166  ***      0                                               MKDEBUG && _d('This table is a view');
2167  ***      0                                               ($key) = grep { m/create view/i } keys %$href;
      ***      0                                      
2168  ***      0                                               $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2169                                                        }
2170                                                     }
2171  ***      0                                         return $self->{tables}->{$db}->{$tbl};
2172                                                  }
2173                                                  
2174                                                  sub get_columns {
2175  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2176  ***      0                                         MKDEBUG && _d('Get columns for', $db, $tbl);
2177  ***      0      0      0                           if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2178  ***      0                                            my $curr_db = $self->_use_db($dbh, $quoter, $db);
2179  ***      0                                            my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2180  ***      0                                            MKDEBUG && _d($sql);
2181  ***      0                                            my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2182  ***      0                                            $self->_use_db($dbh, $quoter, $curr_db);
2183  ***      0                                            $self->{columns}->{$db}->{$tbl} = [
2184                                                           map {
2185  ***      0                                                  my %row;
2186  ***      0                                                  @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
2187  ***      0                                                  \%row;
2188                                                           } @$cols
2189                                                        ];
2190                                                     }
2191  ***      0                                         return $self->{columns}->{$db}->{$tbl};
2192                                                  }
2193                                                  
2194                                                  sub get_tmp_table {
2195  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2196  ***      0                                         my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2197  ***      0                                         $result .= join(",\n",
2198  ***      0                                            map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2199  ***      0                                            @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2200  ***      0                                         $result .= "\n)";
2201  ***      0                                         MKDEBUG && _d($result);
2202  ***      0                                         return $result;
2203                                                  }
2204                                                  
2205                                                  sub get_triggers {
2206  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2207  ***      0      0      0                           if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2208  ***      0                                            $self->{triggers}->{$db} = {};
2209  ***      0                                            my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2210                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2211                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2212                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2213  ***      0                                            MKDEBUG && _d($sql);
2214  ***      0                                            eval { $dbh->do($sql); };
      ***      0                                      
2215  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2216  ***      0                                            $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2217  ***      0                                            MKDEBUG && _d($sql);
2218  ***      0                                            my $sth = $dbh->prepare($sql);
2219  ***      0                                            $sth->execute();
2220  ***      0      0                                     if ( $sth->rows ) {
2221  ***      0                                               my $trgs = $sth->fetchall_arrayref({});
2222  ***      0                                               foreach my $trg (@$trgs) {
2223  ***      0                                                  my %trg;
2224  ***      0                                                  @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                      
2225  ***      0                                                  push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                      
2226                                                           }
2227                                                        }
2228  ***      0                                            $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2229                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2230  ***      0                                            MKDEBUG && _d($sql);
2231  ***      0                                            $dbh->do($sql);
2232                                                     }
2233  ***      0      0                                  if ( $tbl ) {
2234  ***      0                                            return $self->{triggers}->{$db}->{$tbl};
2235                                                     }
2236  ***      0                                         return values %{$self->{triggers}->{$db}};
      ***      0                                      
2237                                                  }
2238                                                  
2239                                                  sub get_databases {
2240  ***      0                    0                    my ( $self, $dbh, $quoter, $like ) = @_;
2241  ***      0      0      0                           if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2242  ***      0                                            my $sql = 'SHOW DATABASES';
2243  ***      0                                            my @params;
2244  ***      0      0                                     if ( $like ) {
2245  ***      0                                               $sql .= ' LIKE ?';
2246  ***      0                                               push @params, $like;
2247                                                        }
2248  ***      0                                            my $sth = $dbh->prepare($sql);
2249  ***      0                                            MKDEBUG && _d($sql, @params);
2250  ***      0                                            $sth->execute( @params );
2251  ***      0                                            my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                      
      ***      0                                      
2252  ***      0      0                                     $self->{databases} = \@dbs unless $like;
2253  ***      0                                            return @dbs;
2254                                                     }
2255  ***      0                                         return @{$self->{databases}};
      ***      0                                      
2256                                                  }
2257                                                  
2258                                                  sub get_table_status {
2259  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $like ) = @_;
2260  ***      0      0      0                           if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2261  ***      0                                            my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2262  ***      0                                            my @params;
2263  ***      0      0                                     if ( $like ) {
2264  ***      0                                               $sql .= ' LIKE ?';
2265  ***      0                                               push @params, $like;
2266                                                        }
2267  ***      0                                            MKDEBUG && _d($sql, @params);
2268  ***      0                                            my $sth = $dbh->prepare($sql);
2269  ***      0                                            $sth->execute(@params);
2270  ***      0                                            my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                      
2271  ***      0                                            @tables = map {
2272  ***      0                                               my %tbl; # Make a copy with lowercased keys
2273  ***      0                                               @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
2274  ***      0             0                                 $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2275  ***      0                                               delete $tbl{type};
2276  ***      0                                               \%tbl;
2277                                                        } @tables;
2278  ***      0      0                                     $self->{table_status}->{$db} = \@tables unless $like;
2279  ***      0                                            return @tables;
2280                                                     }
2281  ***      0                                         return @{$self->{table_status}->{$db}};
      ***      0                                      
2282                                                  }
2283                                                  
2284                                                  sub get_table_list {
2285  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $like ) = @_;
2286  ***      0      0      0                           if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2287  ***      0                                            my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2288  ***      0                                            my @params;
2289  ***      0      0                                     if ( $like ) {
2290  ***      0                                               $sql .= ' LIKE ?';
2291  ***      0                                               push @params, $like;
2292                                                        }
2293  ***      0                                            MKDEBUG && _d($sql, @params);
2294  ***      0                                            my $sth = $dbh->prepare($sql);
2295  ***      0                                            $sth->execute(@params);
2296  ***      0                                            my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                      
2297  ***      0      0      0                              @tables = map {
2298  ***      0                                               my %tbl = (
2299                                                              name   => $_->[0],
2300                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2301                                                           );
2302  ***      0                                               \%tbl;
2303                                                        } @tables;
2304  ***      0      0                                     $self->{table_list}->{$db} = \@tables unless $like;
2305  ***      0                                            return @tables;
2306                                                     }
2307  ***      0                                         return @{$self->{table_list}->{$db}};
      ***      0                                      
2308                                                  }
2309                                                  
2310                                                  sub _d {
2311  ***      0                    0                    my ($package, undef, $line) = caller 0;
2312  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2313  ***      0                                              map { defined $_ ? $_ : 'undef' }
2314                                                          @_;
2315  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2316                                                  }
2317                                                  
2318                                                  1;
2319                                                  
2320                                                  # ###########################################################################
2321                                                  # End MySQLDump package
2322                                                  # ###########################################################################
2323                                                  
2324                                                  # ###########################################################################
2325                                                  # TableChunker package 5266
2326                                                  # ###########################################################################
2327          23                   23          1404   use strict;
              23                                535   
              23                                140   
2328          23                   23           136   use warnings FATAL => 'all';
              23                                306   
              23                                148   
2329                                                  
2330                                                  package TableChunker;
2331                                                  
2332          23                   23           137   use English qw(-no_match_vars);
              23                                 57   
              23                                126   
2333          23                   23           149   use POSIX qw(ceil);
              23                                 62   
              23                                156   
2334          23                   23           144   use List::Util qw(min max);
              23                                 53   
              23                                125   
2335          23                   23           138   use Data::Dumper;
              23                                 53   
              23                                118   
2336                                                  $Data::Dumper::Indent    = 1;
2337                                                  $Data::Dumper::Sortkeys  = 1;
2338                                                  $Data::Dumper::Quotekeys = 0;
2339                                                  
2340  ***     23            50     23           149   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                 55   
              23                                327   
2341                                                  
2342                                                  sub new {
2343  ***      0                    0                    my ( $class, %args ) = @_;
2344  ***      0                                         foreach my $arg ( qw(Quoter MySQLDump) ) {
2345  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2346                                                     }
2347  ***      0                                         my $self = { %args };
2348  ***      0                                         return bless $self, $class;
2349                                                  }
2350                                                  
2351                                                  my $EPOCH      = '1970-01-01';
2352                                                  my %int_types  = map { $_ => 1 }
2353                                                     qw(bigint date datetime int mediumint smallint time timestamp tinyint year);
2354                                                  my %real_types = map { $_ => 1 }
2355                                                     qw(decimal double float);
2356                                                  
2357                                                  sub find_chunk_columns {
2358  ***      0                    0                    my ( $self, %args ) = @_;
2359  ***      0                                         foreach my $arg ( qw(tbl_struct) ) {
2360  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2361                                                     }
2362  ***      0                                         my $tbl_struct = $args{tbl_struct};
2363                                                  
2364  ***      0                                         my @possible_indexes;
2365  ***      0                                         foreach my $index ( values %{ $tbl_struct->{keys} } ) {
      ***      0                                      
2366                                                  
2367  ***      0      0                                     next unless $index->{type} eq 'BTREE';
2368                                                  
2369  ***      0             0                              defined $_ && next for @{ $index->{col_prefixes} };
      ***      0                                      
      ***      0                                      
2370                                                  
2371  ***      0      0                                     if ( $args{exact} ) {
2372  ***      0      0      0                                 next unless $index->{is_unique} && @{$index->{cols}} == 1;
      ***      0                                      
2373                                                        }
2374                                                  
2375  ***      0                                            push @possible_indexes, $index;
2376                                                     }
2377                                                     MKDEBUG && _d('Possible chunk indexes in order:',
2378  ***      0                                            join(', ', map { $_->{name} } @possible_indexes));
2379                                                  
2380  ***      0                                         my $can_chunk_exact = 0;
2381  ***      0                                         my @candidate_cols;
2382  ***      0                                         foreach my $index ( @possible_indexes ) { 
2383  ***      0                                            my $col = $index->{cols}->[0];
2384                                                  
2385  ***      0      0      0                              next unless ( $int_types{$tbl_struct->{type_for}->{$col}}
2386                                                                      || $real_types{$tbl_struct->{type_for}->{$col}} );
2387                                                  
2388  ***      0                                            push @candidate_cols, { column => $col, index => $index->{name} };
2389                                                     }
2390                                                  
2391  ***      0      0      0                           $can_chunk_exact = 1 if $args{exact} && scalar @candidate_cols;
2392                                                  
2393  ***      0                                         if ( MKDEBUG ) {
2394                                                        my $chunk_type = $args{exact} ? 'Exact' : 'Inexact';
2395                                                        _d($chunk_type, 'chunkable:',
2396                                                           join(', ', map { "$_->{column} on $_->{index}" } @candidate_cols));
2397                                                     }
2398                                                  
2399  ***      0                                         my @result;
2400  ***      0                                         MKDEBUG && _d('Ordering columns by order in tbl, PK first');
2401  ***      0      0                                  if ( $tbl_struct->{keys}->{PRIMARY} ) {
2402  ***      0                                            my $pk_first_col = $tbl_struct->{keys}->{PRIMARY}->{cols}->[0];
2403  ***      0                                            @result          = grep { $_->{column} eq $pk_first_col } @candidate_cols;
      ***      0                                      
2404  ***      0                                            @candidate_cols  = grep { $_->{column} ne $pk_first_col } @candidate_cols;
      ***      0                                      
2405                                                     }
2406  ***      0                                         my $i = 0;
2407  ***      0                                         my %col_pos = map { $_ => $i++ } @{$tbl_struct->{cols}};
      ***      0                                      
      ***      0                                      
2408  ***      0                                         push @result, sort { $col_pos{$a->{column}} <=> $col_pos{$b->{column}} }
      ***      0                                      
2409                                                                      @candidate_cols;
2410                                                  
2411  ***      0                                         if ( MKDEBUG ) {
2412                                                        _d('Chunkable columns:',
2413                                                           join(', ', map { "$_->{column} on $_->{index}" } @result));
2414                                                        _d('Can chunk exactly:', $can_chunk_exact);
2415                                                     }
2416                                                  
2417  ***      0                                         return ($can_chunk_exact, @result);
2418                                                  }
2419                                                  
2420                                                  sub calculate_chunks {
2421  ***      0                    0                    my ( $self, %args ) = @_;
2422  ***      0                                         foreach my $arg ( qw(dbh tbl_struct chunk_col min max rows_in_range
2423                                                                          chunk_size dbh) ) {
2424  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
2425                                                     }
2426  ***      0                                         MKDEBUG && _d('Calculate chunks for', Dumper(\%args));
2427  ***      0                                         my $dbh = $args{dbh};
2428                                                  
2429  ***      0                                         my @chunks;
2430  ***      0                                         my ($range_func, $start_point, $end_point);
2431  ***      0                                         my $col_type = $args{tbl_struct}->{type_for}->{$args{chunk_col}};
2432  ***      0                                         MKDEBUG && _d('chunk col type:', $col_type);
2433                                                  
2434                                                  
2435  ***      0      0                                  if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
2436  ***      0                                            $start_point = $args{min};
2437  ***      0                                            $end_point   = $args{max};
2438  ***      0                                            $range_func  = 'range_num';
2439                                                     }
2440                                                     elsif ( $col_type eq 'timestamp' ) {
2441  ***      0                                            my $sql = "SELECT UNIX_TIMESTAMP('$args{min}'), UNIX_TIMESTAMP('$args{max}')";
2442  ***      0                                            MKDEBUG && _d($sql);
2443  ***      0                                            ($start_point, $end_point) = $dbh->selectrow_array($sql);
2444  ***      0                                            $range_func  = 'range_timestamp';
2445                                                     }
2446                                                     elsif ( $col_type eq 'date' ) {
2447  ***      0                                            my $sql = "SELECT TO_DAYS('$args{min}'), TO_DAYS('$args{max}')";
2448  ***      0                                            MKDEBUG && _d($sql);
2449  ***      0                                            ($start_point, $end_point) = $dbh->selectrow_array($sql);
2450  ***      0                                            $range_func  = 'range_date';
2451                                                     }
2452                                                     elsif ( $col_type eq 'time' ) {
2453  ***      0                                            my $sql = "SELECT TIME_TO_SEC('$args{min}'), TIME_TO_SEC('$args{max}')";
2454  ***      0                                            MKDEBUG && _d($sql);
2455  ***      0                                            ($start_point, $end_point) = $dbh->selectrow_array($sql);
2456  ***      0                                            $range_func  = 'range_time';
2457                                                     }
2458                                                     elsif ( $col_type eq 'datetime' ) {
2459  ***      0                                            $start_point = $self->timestampdiff($dbh, $args{min});
2460  ***      0                                            $end_point   = $self->timestampdiff($dbh, $args{max});
2461  ***      0                                            $range_func  = 'range_datetime';
2462                                                     }
2463                                                     else {
2464  ***      0                                            die "I don't know how to chunk $col_type\n";
2465                                                     }
2466                                                  
2467  ***      0      0                                  if ( !defined $start_point ) {
2468  ***      0                                            MKDEBUG && _d('Start point is undefined');
2469  ***      0                                            $start_point = 0;
2470                                                     }
2471  ***      0      0      0                           if ( !defined $end_point || $end_point < $start_point ) {
2472  ***      0                                            MKDEBUG && _d('End point is undefined or before start point');
2473  ***      0                                            $end_point = 0;
2474                                                     }
2475  ***      0                                         MKDEBUG && _d('Start and end of chunk range:',$start_point,',', $end_point);
2476                                                  
2477  ***      0                                         my $interval = $args{chunk_size}
2478                                                                  * ($end_point - $start_point)
2479                                                                  / $args{rows_in_range};
2480  ***      0      0                                  if ( $int_types{$col_type} ) {
2481  ***      0                                            $interval = ceil($interval);
2482                                                     }
2483  ***      0             0                           $interval ||= $args{chunk_size};
2484  ***      0      0                                  if ( $args{exact} ) {
2485  ***      0                                            $interval = $args{chunk_size};
2486                                                     }
2487  ***      0                                         MKDEBUG && _d('Chunk interval:', $interval, 'units');
2488                                                  
2489  ***      0                                         my $col = $self->{Quoter}->quote($args{chunk_col});
2490  ***      0      0                                  if ( $start_point < $end_point ) {
2491  ***      0                                            my ( $beg, $end );
2492  ***      0                                            my $iter = 0;
2493                                                        for ( my $i = $start_point; $i < $end_point; $i += $interval ) {
2494  ***      0                                               ( $beg, $end ) = $self->$range_func($dbh, $i, $interval, $end_point);
2495                                                  
2496  ***      0      0                                        if ( $iter++ == 0 ) {
2497  ***      0                                                  push @chunks, "$col < " . $self->quote($end);
2498                                                           }
2499                                                           else {
2500  ***      0                                                  push @chunks, "$col >= " . $self->quote($beg) . " AND $col < " . $self->quote($end);
2501                                                           }
2502  ***      0                                            }
2503                                                  
2504  ***      0                                            my $nullable = $args{tbl_struct}->{is_nullable}->{$args{chunk_col}};
2505  ***      0                                            pop @chunks;
2506  ***      0      0                                     if ( @chunks ) {
2507  ***      0                                               push @chunks, "$col >= " . $self->quote($beg);
2508                                                        }
2509                                                        else {
2510  ***      0      0                                        push @chunks, $nullable ? "$col IS NOT NULL" : '1=1';
2511                                                        }
2512  ***      0      0                                     if ( $nullable ) {
2513  ***      0                                               push @chunks, "$col IS NULL";
2514                                                        }
2515                                                  
2516                                                     }
2517                                                     else {
2518  ***      0                                            MKDEBUG && _d('No chunks; using single chunk 1=1');
2519  ***      0                                            push @chunks, '1=1';
2520                                                     }
2521                                                  
2522  ***      0                                         return @chunks;
2523                                                  }
2524                                                  
2525                                                  sub get_first_chunkable_column {
2526  ***      0                    0                    my ( $self, %args ) = @_;
2527  ***      0                                         foreach my $arg ( qw(tbl_struct) ) {
2528  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2529                                                     }
2530  ***      0                                         my ($exact, @cols) = $self->find_chunk_columns(%args);
2531  ***      0                                         return ( $cols[0]->{column}, $cols[0]->{index} );
2532                                                  }
2533                                                  
2534                                                  sub size_to_rows {
2535  ***      0                    0                    my ( $self, %args ) = @_;
2536  ***      0                                         my @required_args = qw(dbh db tbl chunk_size);
2537  ***      0                                         foreach my $arg ( @required_args ) {
2538  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2539                                                     }
2540  ***      0                                         my ($dbh, $db, $tbl, $chunk_size) = @args{@required_args};
2541  ***      0                                         my $q  = $self->{Quoter};
2542  ***      0                                         my $du = $self->{MySQLDump};
2543                                                  
2544  ***      0                                         my ($n_rows, $avg_row_length);
2545                                                  
2546  ***      0                                         my ( $num, $suffix ) = $chunk_size =~ m/^(\d+)([MGk])?$/;
2547  ***      0      0                                  if ( $suffix ) { # Convert to bytes.
      ***             0                               
2548  ***      0      0                                     $chunk_size = $suffix eq 'k' ? $num * 1_024
      ***             0                               
2549                                                                    : $suffix eq 'M' ? $num * 1_024 * 1_024
2550                                                                    :                  $num * 1_024 * 1_024 * 1_024;
2551                                                     }
2552                                                     elsif ( $num ) {
2553  ***      0                                            $n_rows = $num;
2554                                                     }
2555                                                     else {
2556  ***      0                                            die "Invalid chunk size $chunk_size; must be an integer "
2557                                                           . "with optional suffix kMG";
2558                                                     }
2559                                                  
2560  ***      0      0      0                           if ( $suffix || $args{avg_row_length} ) {
2561  ***      0                                            my ($status) = $du->get_table_status($dbh, $q, $db, $tbl);
2562  ***      0                                            $avg_row_length = $status->{avg_row_length};
2563  ***      0      0                                     if ( !defined $n_rows ) {
2564  ***      0      0                                        $n_rows = $avg_row_length ? ceil($chunk_size / $avg_row_length) : undef;
2565                                                        }
2566                                                     }
2567                                                  
2568  ***      0      0                                  return wantarray ? ($n_rows, $avg_row_length) : $n_rows;
2569                                                  }
2570                                                  
2571                                                  sub get_range_statistics {
2572  ***      0                    0                    my ( $self, %args ) = @_;
2573  ***      0                                         my @required_args = qw(dbh db tbl chunk_col);
2574  ***      0                                         foreach my $arg ( @required_args ) {
2575  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2576                                                     }
2577  ***      0                                         my ($dbh, $db, $tbl, $col) = @args{@required_args};
2578  ***      0                                         my $where = $args{where};
2579  ***      0                                         my $q = $self->{Quoter};
2580  ***      0      0                                  my $sql = "SELECT MIN(" . $q->quote($col) . "), MAX(" . $q->quote($col)
2581                                                        . ") FROM " . $q->quote($db, $tbl)
2582                                                        . ($where ? " WHERE $where" : '');
2583  ***      0                                         MKDEBUG && _d($sql);
2584  ***      0                                         my ( $min, $max );
2585  ***      0                                         eval {
2586  ***      0                                            ( $min, $max ) = $dbh->selectrow_array($sql);
2587                                                     };
2588  ***      0      0                                  if ( $EVAL_ERROR ) {
2589  ***      0                                            chomp $EVAL_ERROR;
2590  ***      0      0                                     if ( $EVAL_ERROR =~ m/in your SQL syntax/ ) {
2591  ***      0                                               die "$EVAL_ERROR (WHERE clause: $where)";
2592                                                        }
2593                                                        else {
2594  ***      0                                               die $EVAL_ERROR;
2595                                                        }
2596                                                     }
2597  ***      0      0                                  $sql = "EXPLAIN SELECT * FROM " . $q->quote($db, $tbl)
2598                                                        . ($where ? " WHERE $where" : '');
2599  ***      0                                         MKDEBUG && _d($sql);
2600  ***      0                                         my $expl = $dbh->selectrow_hashref($sql);
2601                                                     return (
2602  ***      0                                            min           => $min,
2603                                                        max           => $max,
2604                                                        rows_in_range => $expl->{rows},
2605                                                     );
2606                                                  }
2607                                                  
2608                                                  sub quote {
2609  ***      0                    0                    my ( $self, $val ) = @_;
2610  ***      0      0                                  return $val =~ m/\d[:-]/ ? qq{"$val"} : $val;
2611                                                  }
2612                                                  
2613                                                  sub inject_chunks {
2614  ***      0                    0                    my ( $self, %args ) = @_;
2615  ***      0                                         foreach my $arg ( qw(database table chunks chunk_num query) ) {
2616  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
2617                                                     }
2618  ***      0                                         MKDEBUG && _d('Injecting chunk', $args{chunk_num});
2619  ***      0                                         my $query   = $args{query};
2620  ***      0                                         my $comment = sprintf("/*%s.%s:%d/%d*/",
2621                                                        $args{database}, $args{table},
2622  ***      0                                            $args{chunk_num} + 1, scalar @{$args{chunks}});
2623  ***      0                                         $query =~ s!/\*PROGRESS_COMMENT\*/!$comment!;
2624  ***      0                                         my $where = "WHERE (" . $args{chunks}->[$args{chunk_num}] . ')';
2625  ***      0      0      0                           if ( $args{where} && grep { $_ } @{$args{where}} ) {
      ***      0                                      
      ***      0                                      
2626  ***      0                                            $where .= " AND ("
2627  ***      0                                               . join(" AND ", map { "($_)" } grep { $_ } @{$args{where}} )
      ***      0                                      
      ***      0                                      
2628                                                           . ")";
2629                                                     }
2630  ***      0                                         my $db_tbl     = $self->{Quoter}->quote(@args{qw(database table)});
2631  ***      0             0                           my $index_hint = $args{index_hint} || '';
2632                                                  
2633  ***      0                                         MKDEBUG && _d('Parameters:',
2634                                                        Dumper({WHERE => $where, DB_TBL => $db_tbl, INDEX_HINT => $index_hint}));
2635  ***      0                                         $query =~ s!/\*WHERE\*/! $where!;
2636  ***      0                                         $query =~ s!/\*DB_TBL\*/!$db_tbl!;
2637  ***      0                                         $query =~ s!/\*INDEX_HINT\*/! $index_hint!;
2638  ***      0                                         $query =~ s!/\*CHUNK_NUM\*/! $args{chunk_num} AS chunk_num,!;
2639                                                  
2640  ***      0                                         return $query;
2641                                                  }
2642                                                  
2643                                                  sub range_num {
2644  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
2645  ***      0                                         my $end = min($max, $start + $interval);
2646                                                  
2647                                                  
2648  ***      0      0                                  $start = sprintf('%.17f', $start) if $start =~ /e/;
2649  ***      0      0                                  $end   = sprintf('%.17f', $end)   if $end   =~ /e/;
2650                                                  
2651  ***      0                                         $start =~ s/\.(\d{5}).*$/.$1/;
2652  ***      0                                         $end   =~ s/\.(\d{5}).*$/.$1/;
2653                                                  
2654  ***      0      0                                  if ( $end > $start ) {
2655  ***      0                                            return ( $start, $end );
2656                                                     }
2657                                                     else {
2658  ***      0                                            die "Chunk size is too small: $end !> $start\n";
2659                                                     }
2660                                                  }
2661                                                  
2662                                                  sub range_time {
2663  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
2664  ***      0                                         my $sql = "SELECT SEC_TO_TIME($start), SEC_TO_TIME(LEAST($max, $start + $interval))";
2665  ***      0                                         MKDEBUG && _d($sql);
2666  ***      0                                         return $dbh->selectrow_array($sql);
2667                                                  }
2668                                                  
2669                                                  sub range_date {
2670  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
2671  ***      0                                         my $sql = "SELECT FROM_DAYS($start), FROM_DAYS(LEAST($max, $start + $interval))";
2672  ***      0                                         MKDEBUG && _d($sql);
2673  ***      0                                         return $dbh->selectrow_array($sql);
2674                                                  }
2675                                                  
2676                                                  sub range_datetime {
2677  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
2678  ***      0                                         my $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $start SECOND), "
2679                                                         . "DATE_ADD('$EPOCH', INTERVAL LEAST($max, $start + $interval) SECOND)";
2680  ***      0                                         MKDEBUG && _d($sql);
2681  ***      0                                         return $dbh->selectrow_array($sql);
2682                                                  }
2683                                                  
2684                                                  sub range_timestamp {
2685  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
2686  ***      0                                         my $sql = "SELECT FROM_UNIXTIME($start), FROM_UNIXTIME(LEAST($max, $start + $interval))";
2687  ***      0                                         MKDEBUG && _d($sql);
2688  ***      0                                         return $dbh->selectrow_array($sql);
2689                                                  }
2690                                                  
2691                                                  sub timestampdiff {
2692  ***      0                    0                    my ( $self, $dbh, $time ) = @_;
2693  ***      0                                         my $sql = "SELECT (COALESCE(TO_DAYS('$time'), 0) * 86400 + TIME_TO_SEC('$time')) "
2694                                                        . "- TO_DAYS('$EPOCH 00:00:00') * 86400";
2695  ***      0                                         MKDEBUG && _d($sql);
2696  ***      0                                         my ( $diff ) = $dbh->selectrow_array($sql);
2697  ***      0                                         $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $diff SECOND)";
2698  ***      0                                         MKDEBUG && _d($sql);
2699  ***      0                                         my ( $check ) = $dbh->selectrow_array($sql);
2700  ***      0      0                                  die <<"   EOF"
2701                                                     Incorrect datetime math: given $time, calculated $diff but checked to $check.
2702                                                     This is probably because you are using a version of MySQL that overflows on
2703                                                     large interval values to DATE_ADD().  If not, please report this as a bug.
2704                                                     EOF
2705                                                        unless $check eq $time;
2706  ***      0                                         return $diff;
2707                                                  }
2708                                                  
2709                                                  sub _d {
2710  ***      0                    0                    my ($package, undef, $line) = caller 0;
2711  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2712  ***      0                                              map { defined $_ ? $_ : 'undef' }
2713                                                          @_;
2714  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2715                                                  }
2716                                                  
2717                                                  1;
2718                                                  
2719                                                  # ###########################################################################
2720                                                  # End TableChunker package
2721                                                  # ###########################################################################
2722                                                  
2723                                                  # ###########################################################################
2724                                                  # Quoter package 5266
2725                                                  # ###########################################################################
2726          23                   23           209   use strict;
              23                                 57   
              23                                146   
2727          23                   23           140   use warnings FATAL => 'all';
              23                                 54   
              23                                136   
2728                                                  
2729                                                  package Quoter;
2730                                                  
2731          23                   23           145   use English qw(-no_match_vars);
              23                                 68   
              23                                145   
2732                                                  
2733  ***     23            50     23           146   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                 60   
              23                                500   
2734                                                  
2735                                                  sub new {
2736  ***      0                    0                    my ( $class ) = @_;
2737  ***      0                                         bless {}, $class;
2738                                                  }
2739                                                  
2740                                                  sub quote {
2741  ***      0                    0                    my ( $self, @vals ) = @_;
2742  ***      0                                         foreach my $val ( @vals ) {
2743  ***      0                                            $val =~ s/`/``/g;
2744                                                     }
2745  ***      0                                         return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                      
2746                                                  }
2747                                                  
2748                                                  sub quote_val {
2749  ***      0                    0                    my ( $self, $val, $is_numeric ) = @_;
2750                                                  
2751  ***      0      0                                  return 'NULL' unless defined $val;  # undef = NULL
2752  ***      0      0                                  return "''" if $val eq '';          # blank string = ''
2753                                                  
2754  ***      0      0                                  if ( !defined $is_numeric ) {
2755  ***      0      0                                     $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
2756                                                     }
2757                                                  
2758  ***      0      0                                  return $val if $is_numeric;
2759                                                  
2760  ***      0                                         $val =~ s/(['\\])/\\$1/g;
2761  ***      0                                         return "'$val'";
2762                                                  }
2763                                                  
2764                                                  sub split_unquote {
2765  ***      0                    0                    my ( $self, $db_tbl, $default_db ) = @_;
2766  ***      0                                         $db_tbl =~ s/`//g;
2767  ***      0                                         my ( $db, $tbl ) = split(/[.]/, $db_tbl);
2768  ***      0      0                                  if ( !$tbl ) {
2769  ***      0                                            $tbl = $db;
2770  ***      0                                            $db  = $default_db;
2771                                                     }
2772  ***      0                                         return ($db, $tbl);
2773                                                  }
2774                                                  
2775                                                  sub literal_like {
2776  ***      0                    0                    my ( $self, $like ) = @_;
2777  ***      0      0                                  return unless $like;
2778  ***      0                                         $like =~ s/([%_])/\\$1/g;
2779  ***      0                                         return "'$like'";
2780                                                  }
2781                                                  
2782                                                  1;
2783                                                  
2784                                                  # ###########################################################################
2785                                                  # End Quoter package
2786                                                  # ###########################################################################
2787                                                  
2788                                                  # ###########################################################################
2789                                                  # MasterSlave package 5362
2790                                                  # ###########################################################################
2791          23                   23           163   use strict;
              23                                 66   
              23                                127   
2792          23                   23           148   use warnings FATAL => 'all';
              23                                 61   
              23                                111   
2793                                                  
2794                                                  package MasterSlave;
2795                                                  
2796          23                   23           147   use English qw(-no_match_vars);
              23                                 55   
              23                                113   
2797          23                   23           164   use List::Util qw(min max);
              23                                 53   
              23                                139   
2798          23                   23           141   use Data::Dumper;
              23                                 54   
              23                                129   
2799                                                  $Data::Dumper::Quotekeys = 0;
2800                                                  $Data::Dumper::Indent    = 0;
2801                                                  
2802  ***     23            50     23           143   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                 51   
              23                                324   
2803                                                  
2804                                                  sub new {
2805  ***      0                    0                    bless {}, shift;
2806                                                  }
2807                                                  
2808                                                  sub recurse_to_slaves {
2809  ***      0                    0                    my ( $self, $args, $level ) = @_;
2810  ***      0             0                           $level ||= 0;
2811  ***      0                                         my $dp   = $args->{dsn_parser};
2812  ***      0                                         my $dsn  = $args->{dsn};
2813                                                  
2814  ***      0                                         my $dbh;
2815  ***      0                                         eval {
2816  ***      0             0                              $dbh = $args->{dbh} || $dp->get_dbh(
2817                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
2818  ***      0                                            MKDEBUG && _d('Connected to', $dp->as_string($dsn));
2819                                                     };
2820  ***      0      0                                  if ( $EVAL_ERROR ) {
2821  ***      0      0                                     print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
2822                                                           or die "Cannot print: $OS_ERROR";
2823  ***      0                                            return;
2824                                                     }
2825                                                  
2826  ***      0                                         my $sql  = 'SELECT @@SERVER_ID';
2827  ***      0                                         MKDEBUG && _d($sql);
2828  ***      0                                         my ($id) = $dbh->selectrow_array($sql);
2829  ***      0                                         MKDEBUG && _d('Working on server ID', $id);
2830  ***      0                                         my $master_thinks_i_am = $dsn->{server_id};
2831  ***      0      0      0                           if ( !defined $id
      ***                    0                        
      ***                    0                        
2832                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
2833                                                         || $args->{server_ids_seen}->{$id}++
2834                                                     ) {
2835  ***      0                                            MKDEBUG && _d('Server ID seen, or not what master said');
2836  ***      0      0                                     if ( $args->{skip_callback} ) {
2837  ***      0                                               $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
2838                                                        }
2839  ***      0                                            return;
2840                                                     }
2841                                                  
2842  ***      0                                         $args->{callback}->($dsn, $dbh, $level, $args->{parent});
2843                                                  
2844  ***      0      0      0                           if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
2845                                                  
2846  ***      0      0                                     my @slaves =
2847  ***      0                                               grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
2848                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
2849                                                  
2850  ***      0                                            foreach my $slave ( @slaves ) {
2851  ***      0                                               MKDEBUG && _d('Recursing from',
2852                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
2853  ***      0                                               $self->recurse_to_slaves(
2854                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
2855                                                        }
2856                                                     }
2857                                                  }
2858                                                  
2859                                                  sub find_slave_hosts {
2860  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
2861                                                  
2862  ***      0                                         my @methods = qw(processlist hosts);
2863  ***      0      0                                  if ( $method ) {
2864  ***      0                                            @methods = grep { $_ ne $method } @methods;
      ***      0                                      
2865  ***      0                                            unshift @methods, $method;
2866                                                     }
2867                                                     else {
2868  ***      0      0      0                              if ( ($dsn->{P} || 3306) != 3306 ) {
2869  ***      0                                               MKDEBUG && _d('Port number is non-standard; using only hosts method');
2870  ***      0                                               @methods = qw(hosts);
2871                                                        }
2872                                                     }
2873  ***      0                                         MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
2874                                                        'using methods', @methods);
2875                                                  
2876  ***      0                                         my @slaves;
2877                                                     METHOD:
2878  ***      0                                         foreach my $method ( @methods ) {
2879  ***      0                                            my $find_slaves = "_find_slaves_by_$method";
2880  ***      0                                            MKDEBUG && _d('Finding slaves with', $find_slaves);
2881  ***      0                                            @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
2882  ***      0      0                                     last METHOD if @slaves;
2883                                                     }
2884                                                  
2885  ***      0                                         MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
2886  ***      0                                         return @slaves;
2887                                                  }
2888                                                  
2889                                                  sub _find_slaves_by_processlist {
2890  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
2891                                                  
2892  ***      0                                         my @slaves = map  {
2893  ***      0                                            my $slave        = $dsn_parser->parse("h=$_", $dsn);
2894  ***      0                                            $slave->{source} = 'processlist';
2895  ***      0                                            $slave;
2896                                                     }
2897  ***      0                                         grep { $_ }
2898                                                     map  {
2899  ***      0                                            my ( $host ) = $_->{host} =~ m/^([^:]+):/;
2900  ***      0      0                                     if ( $host eq 'localhost' ) {
2901  ***      0                                               $host = '127.0.0.1'; # Replication never uses sockets.
2902                                                        }
2903  ***      0                                            $host;
2904                                                     } $self->get_connected_slaves($dbh);
2905                                                  
2906  ***      0                                         return @slaves;
2907                                                  }
2908                                                  
2909                                                  sub _find_slaves_by_hosts {
2910  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
2911                                                  
2912  ***      0                                         my @slaves;
2913  ***      0                                         my $sql = 'SHOW SLAVE HOSTS';
2914  ***      0                                         MKDEBUG && _d($dbh, $sql);
2915  ***      0                                         @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                      
2916                                                  
2917  ***      0      0                                  if ( @slaves ) {
2918  ***      0                                            MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
2919  ***      0                                            @slaves = map {
2920  ***      0                                               my %hash;
2921  ***      0                                               @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
2922  ***      0      0                                        my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
2923                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
2924                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
2925  ***      0                                               my $dsn           = $dsn_parser->parse($spec, $dsn);
2926  ***      0                                               $dsn->{server_id} = $hash{server_id};
2927  ***      0                                               $dsn->{master_id} = $hash{master_id};
2928  ***      0                                               $dsn->{source}    = 'hosts';
2929  ***      0                                               $dsn;
2930                                                        } @slaves;
2931                                                     }
2932                                                  
2933  ***      0                                         return @slaves;
2934                                                  }
2935                                                  
2936                                                  sub get_connected_slaves {
2937  ***      0                    0                    my ( $self, $dbh ) = @_;
2938                                                  
2939  ***      0                                         my $proc =
2940  ***      0                                            grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
2941  ***      0                                            @{$dbh->selectcol_arrayref('SHOW GRANTS')};
2942  ***      0      0                                  if ( !$proc ) {
2943  ***      0                                            die "You do not have the PROCESS privilege";
2944                                                     }
2945                                                  
2946  ***      0                                         my $sql = 'SHOW PROCESSLIST';
2947  ***      0                                         MKDEBUG && _d($dbh, $sql);
2948  ***      0                                         grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                      
2949                                                     map  { # Lowercase the column names
2950  ***      0                                            my %hash;
2951  ***      0                                            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
2952  ***      0                                            \%hash;
2953                                                     }
2954  ***      0                                         @{$dbh->selectall_arrayref($sql, { Slice => {} })};
2955                                                  }
2956                                                  
2957                                                  sub is_master_of {
2958  ***      0                    0                    my ( $self, $master, $slave ) = @_;
2959  ***      0      0                                  my $master_status = $self->get_master_status($master)
2960                                                        or die "The server specified as a master is not a master";
2961  ***      0      0                                  my $slave_status  = $self->get_slave_status($slave)
2962                                                        or die "The server specified as a slave is not a slave";
2963  ***      0      0                                  my @connected     = $self->get_connected_slaves($master)
2964                                                        or die "The server specified as a master has no connected slaves";
2965  ***      0                                         my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
2966                                                  
2967  ***      0      0                                  if ( $port != $slave_status->{master_port} ) {
2968  ***      0                                            die "The slave is connected to $slave_status->{master_port} "
2969                                                           . "but the master's port is $port";
2970                                                     }
2971                                                  
2972  ***      0      0                                  if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                      
2973  ***      0                                            die "I don't see any slave I/O thread connected with user "
2974                                                           . $slave_status->{master_user};
2975                                                     }
2976                                                  
2977  ***      0      0      0                           if ( ($slave_status->{slave_io_state} || '')
2978                                                        eq 'Waiting for master to send event' )
2979                                                     {
2980  ***      0                                            my ( $master_log_name, $master_log_num )
2981                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
2982  ***      0                                            my ( $slave_log_name, $slave_log_num )
2983                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
2984  ***      0      0      0                              if ( $master_log_name ne $slave_log_name
2985                                                           || abs($master_log_num - $slave_log_num) > 1 )
2986                                                        {
2987  ***      0                                               die "The slave thinks it is reading from "
2988                                                              . "$slave_status->{master_log_file},  but the "
2989                                                              . "master is writing to $master_status->{file}";
2990                                                        }
2991                                                     }
2992  ***      0                                         return 1;
2993                                                  }
2994                                                  
2995                                                  sub get_master_dsn {
2996  ***      0                    0                    my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
2997  ***      0      0                                  my $master = $self->get_slave_status($dbh) or return undef;
2998  ***      0                                         my $spec   = "h=$master->{master_host},P=$master->{master_port}";
2999  ***      0                                         return       $dsn_parser->parse($spec, $dsn);
3000                                                  }
3001                                                  
3002                                                  sub get_slave_status {
3003  ***      0                    0                    my ( $self, $dbh ) = @_;
3004  ***      0      0                                  if ( !$self->{not_a_slave}->{$dbh} ) {
3005  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
3006                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
3007  ***      0                                            MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
3008  ***      0                                            $sth->execute();
3009  ***      0                                            my ($ss) = @{$sth->fetchall_arrayref({})};
      ***      0                                      
3010                                                  
3011  ***      0      0      0                              if ( $ss && %$ss ) {
3012  ***      0                                               $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
      ***      0                                      
3013  ***      0                                               return $ss;
3014                                                        }
3015                                                  
3016  ***      0                                            MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
3017  ***      0                                            $self->{not_a_slave}->{$dbh}++;
3018                                                     }
3019                                                  }
3020                                                  
3021                                                  sub get_master_status {
3022  ***      0                    0                    my ( $self, $dbh ) = @_;
3023  ***      0      0                                  if ( !$self->{not_a_master}->{$dbh} ) {
3024  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
3025                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
3026  ***      0                                            MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
3027  ***      0                                            $sth->execute();
3028  ***      0                                            my ($ms) = @{$sth->fetchall_arrayref({})};
      ***      0                                      
3029                                                  
3030  ***      0      0      0                              if ( $ms && %$ms ) {
3031  ***      0                                               $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
      ***      0                                      
3032  ***      0      0      0                                 if ( $ms->{file} && $ms->{position} ) {
3033  ***      0                                                  return $ms;
3034                                                           }
3035                                                        }
3036                                                  
3037  ***      0                                            MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
3038  ***      0                                            $self->{not_a_master}->{$dbh}++;
3039                                                     }
3040                                                  }
3041                                                  
3042                                                  sub wait_for_master {
3043  ***      0                    0                    my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
3044  ***      0                                         my $result;
3045  ***      0      0                                  $time = 60 unless defined $time;
3046  ***      0                                         MKDEBUG && _d('Waiting for slave to catch up to master timeout ok:',
3047                                                        $timeoutok);
3048  ***      0             0                           $ms ||= $self->get_master_status($master);
3049  ***      0      0                                  if ( $ms ) {
3050  ***      0                                            my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
3051  ***      0                                            MKDEBUG && _d($slave, $query);
3052  ***      0                                            ($result) = $slave->selectrow_array($query);
3053  ***      0      0                                     my $stat = defined $result ? $result : 'NULL';
3054  ***      0                                            MKDEBUG && _d('Result of waiting:', $stat);
3055  ***      0      0      0                              if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                    0                        
3056  ***      0                                               die "MASTER_POS_WAIT returned $stat";
3057                                                        }
3058                                                     }
3059                                                     else {
3060  ***      0                                            MKDEBUG && _d('Not waiting: this server is not a master');
3061                                                     }
3062  ***      0                                         return $result;
3063                                                  }
3064                                                  
3065                                                  sub stop_slave {
3066  ***      0                    0                    my ( $self, $dbh ) = @_;
3067  ***      0             0                           my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
3068                                                           ||= $dbh->prepare('STOP SLAVE');
3069  ***      0                                         MKDEBUG && _d($dbh, $sth->{Statement});
3070  ***      0                                         $sth->execute();
3071                                                  }
3072                                                  
3073                                                  sub start_slave {
3074  ***      0                    0                    my ( $self, $dbh, $pos ) = @_;
3075  ***      0      0                                  if ( $pos ) {
3076  ***      0                                            my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
3077                                                                . "MASTER_LOG_POS=$pos->{position}";
3078  ***      0                                            MKDEBUG && _d($dbh, $sql);
3079  ***      0                                            $dbh->do($sql);
3080                                                     }
3081                                                     else {
3082  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
3083                                                              ||= $dbh->prepare('START SLAVE');
3084  ***      0                                            MKDEBUG && _d($dbh, $sth->{Statement});
3085  ***      0                                            $sth->execute();
3086                                                     }
3087                                                  }
3088                                                  
3089                                                  sub catchup_to_master {
3090  ***      0                    0                    my ( $self, $slave, $master, $time ) = @_;
3091  ***      0                                         $self->stop_slave($master);
3092  ***      0                                         $self->stop_slave($slave);
3093  ***      0                                         my $slave_status  = $self->get_slave_status($slave);
3094  ***      0                                         my $slave_pos     = $self->repl_posn($slave_status);
3095  ***      0                                         my $master_status = $self->get_master_status($master);
3096  ***      0                                         my $master_pos    = $self->repl_posn($master_status);
3097  ***      0                                         MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
3098                                                        'Slave position:', $self->pos_to_string($slave_pos));
3099  ***      0      0                                  if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
3100  ***      0                                            MKDEBUG && _d('Waiting for slave to catch up to master');
3101  ***      0                                            $self->start_slave($slave, $master_pos);
3102  ***      0                                            eval {
3103  ***      0                                               $self->wait_for_master($master, $slave, $time, 0, $master_status);
3104                                                        };
3105  ***      0      0                                     if ( $EVAL_ERROR ) {
3106  ***      0                                               MKDEBUG && _d($EVAL_ERROR);
3107  ***      0      0                                        if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
3108  ***      0                                                  $slave_status = $self->get_slave_status($slave);
3109  ***      0      0                                           if ( !$self->slave_is_running($slave_status) ) {
3110  ***      0                                                     MKDEBUG && _d('Master position:',
3111                                                                    $self->pos_to_string($master_pos),
3112                                                                    'Slave position:', $self->pos_to_string($slave_pos));
3113  ***      0                                                     $slave_pos = $self->repl_posn($slave_status);
3114  ***      0      0                                              if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
3115  ***      0                                                        die "$EVAL_ERROR but slave has not caught up to master";
3116                                                                 }
3117  ***      0                                                     MKDEBUG && _d('Slave is caught up to master and stopped');
3118                                                              }
3119                                                              else {
3120  ***      0                                                     die "$EVAL_ERROR but slave was still running";
3121                                                              }
3122                                                           }
3123                                                           else {
3124  ***      0                                                  die $EVAL_ERROR;
3125                                                           }
3126                                                        }
3127                                                     }
3128                                                  }
3129                                                  
3130                                                  sub catchup_to_same_pos {
3131  ***      0                    0                    my ( $self, $s1_dbh, $s2_dbh ) = @_;
3132  ***      0                                         $self->stop_slave($s1_dbh);
3133  ***      0                                         $self->stop_slave($s2_dbh);
3134  ***      0                                         my $s1_status = $self->get_slave_status($s1_dbh);
3135  ***      0                                         my $s2_status = $self->get_slave_status($s2_dbh);
3136  ***      0                                         my $s1_pos    = $self->repl_posn($s1_status);
3137  ***      0                                         my $s2_pos    = $self->repl_posn($s2_status);
3138  ***      0      0                                  if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
3139  ***      0                                            $self->start_slave($s1_dbh, $s2_pos);
3140                                                     }
3141                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
3142  ***      0                                            $self->start_slave($s2_dbh, $s1_pos);
3143                                                     }
3144                                                  
3145  ***      0                                         $s1_status = $self->get_slave_status($s1_dbh);
3146  ***      0                                         $s2_status = $self->get_slave_status($s2_dbh);
3147  ***      0                                         $s1_pos    = $self->repl_posn($s1_status);
3148  ***      0                                         $s2_pos    = $self->repl_posn($s2_status);
3149                                                  
3150  ***      0      0      0                           if ( $self->slave_is_running($s1_status)
      ***                    0                        
3151                                                       || $self->slave_is_running($s2_status)
3152                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
3153                                                     {
3154  ***      0                                            die "The servers aren't both stopped at the same position";
3155                                                     }
3156                                                  
3157                                                  }
3158                                                  
3159                                                  sub change_master_to {
3160  ***      0                    0                    my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
3161  ***      0                                         $self->stop_slave($dbh);
3162  ***      0                                         MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
3163  ***      0                                         my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
3164                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
3165                                                        . "MASTER_LOG_POS=$master_pos->{position}";
3166  ***      0                                         MKDEBUG && _d($dbh, $sql);
3167  ***      0                                         $dbh->do($sql);
3168                                                  }
3169                                                  
3170                                                  sub make_sibling_of_master {
3171  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
3172                                                  
3173  ***      0      0                                  my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3174                                                        or die "This server is not a slave";
3175  ***      0                                         my $master_dbh  = $dsn_parser->get_dbh(
3176                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
3177  ***      0      0                                  my $gmaster_dsn
3178                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3179                                                        or die "This server's master is not a slave";
3180  ***      0                                         my $gmaster_dbh = $dsn_parser->get_dbh(
3181                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
3182  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
3183  ***      0                                            die "The slave's master's master is the slave: master-master replication";
3184                                                     }
3185                                                  
3186  ***      0                                         $self->stop_slave($master_dbh);
3187  ***      0                                         $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
3188  ***      0                                         $self->stop_slave($slave_dbh);
3189                                                  
3190  ***      0                                         my $master_status = $self->get_master_status($master_dbh);
3191  ***      0                                         my $mslave_status = $self->get_slave_status($master_dbh);
3192  ***      0                                         my $slave_status  = $self->get_slave_status($slave_dbh);
3193  ***      0                                         my $master_pos    = $self->repl_posn($master_status);
3194  ***      0                                         my $slave_pos     = $self->repl_posn($slave_status);
3195                                                  
3196  ***      0      0      0                           if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
3197                                                       && !$self->slave_is_running($slave_status)
3198                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
3199                                                     {
3200  ***      0                                            $self->change_master_to($slave_dbh, $gmaster_dsn,
3201                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
3202                                                     }
3203                                                     else {
3204  ***      0                                            die "The servers aren't both stopped at the same position";
3205                                                     }
3206                                                  
3207  ***      0                                         $mslave_status = $self->get_slave_status($master_dbh);
3208  ***      0                                         $slave_status  = $self->get_slave_status($slave_dbh);
3209  ***      0                                         my $mslave_pos = $self->repl_posn($mslave_status);
3210  ***      0                                         $slave_pos     = $self->repl_posn($slave_status);
3211  ***      0      0      0                           if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
3212                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
3213                                                     {
3214  ***      0                                            die "The servers don't have the same master/position after the change";
3215                                                     }
3216                                                  }
3217                                                  
3218                                                  sub make_slave_of_sibling {
3219  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
3220                                                          $dsn_parser, $timeout) = @_;
3221                                                  
3222  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
3223  ***      0                                            die "You are trying to make the slave a slave of itself";
3224                                                     }
3225                                                  
3226  ***      0      0                                  my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3227                                                        or die "This server is not a slave";
3228  ***      0                                         my $master_dbh1 = $dsn_parser->get_dbh(
3229                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
3230  ***      0      0                                  my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3231                                                        or die "The sibling is not a slave";
3232  ***      0      0                                  if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
3233  ***      0                                            die "This server isn't a sibling of the slave";
3234                                                     }
3235  ***      0      0                                  my $sib_master_stat = $self->get_master_status($sib_dbh)
3236                                                        or die "Binary logging is not enabled on the sibling";
3237  ***      0      0                                  die "The log_slave_updates option is not enabled on the sibling"
3238                                                        unless $self->has_slave_updates($sib_dbh);
3239                                                  
3240  ***      0                                         $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
3241                                                  
3242  ***      0                                         $sib_master_stat = $self->get_master_status($sib_dbh);
3243  ***      0                                         $self->change_master_to($slave_dbh, $sib_dsn,
3244                                                           $self->repl_posn($sib_master_stat));
3245                                                  
3246  ***      0                                         my $slave_status = $self->get_slave_status($slave_dbh);
3247  ***      0                                         my $slave_pos    = $self->repl_posn($slave_status);
3248  ***      0                                         $sib_master_stat = $self->get_master_status($sib_dbh);
3249  ***      0      0      0                           if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
3250                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
3251                                                     {
3252  ***      0                                            die "After changing the slave's master, it isn't a slave of the sibling, "
3253                                                           . "or it has a different replication position than the sibling";
3254                                                     }
3255                                                  }
3256                                                  
3257                                                  sub make_slave_of_uncle {
3258  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
3259                                                          $dsn_parser, $timeout) = @_;
3260                                                  
3261  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
3262  ***      0                                            die "You are trying to make the slave a slave of itself";
3263                                                     }
3264                                                  
3265  ***      0      0                                  my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3266                                                        or die "This server is not a slave";
3267  ***      0                                         my $master_dbh = $dsn_parser->get_dbh(
3268                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
3269  ***      0      0                                  my $gmaster_dsn
3270                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3271                                                        or die "The master is not a slave";
3272  ***      0      0                                  my $unc_master_dsn
3273                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
3274                                                        or die "The uncle is not a slave";
3275  ***      0      0                                  if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
3276  ***      0                                            die "The uncle isn't really the slave's uncle";
3277                                                     }
3278                                                  
3279  ***      0      0                                  my $unc_master_stat = $self->get_master_status($unc_dbh)
3280                                                        or die "Binary logging is not enabled on the uncle";
3281  ***      0      0                                  die "The log_slave_updates option is not enabled on the uncle"
3282                                                        unless $self->has_slave_updates($unc_dbh);
3283                                                  
3284  ***      0                                         $self->catchup_to_same_pos($master_dbh, $unc_dbh);
3285  ***      0                                         $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
3286                                                  
3287  ***      0                                         my $slave_status  = $self->get_slave_status($slave_dbh);
3288  ***      0                                         my $master_status = $self->get_master_status($master_dbh);
3289  ***      0      0                                  if ( $self->pos_cmp(
3290                                                           $self->repl_posn($slave_status),
3291                                                           $self->repl_posn($master_status)) != 0 )
3292                                                     {
3293  ***      0                                            die "The slave is not caught up to its master";
3294                                                     }
3295                                                  
3296  ***      0                                         $unc_master_stat = $self->get_master_status($unc_dbh);
3297  ***      0                                         $self->change_master_to($slave_dbh, $unc_dsn,
3298                                                        $self->repl_posn($unc_master_stat));
3299                                                  
3300                                                  
3301  ***      0                                         $slave_status    = $self->get_slave_status($slave_dbh);
3302  ***      0                                         my $slave_pos    = $self->repl_posn($slave_status);
3303  ***      0      0      0                           if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
3304                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
3305                                                     {
3306  ***      0                                            die "After changing the slave's master, it isn't a slave of the uncle, "
3307                                                           . "or it has a different replication position than the uncle";
3308                                                     }
3309                                                  }
3310                                                  
3311                                                  sub detach_slave {
3312  ***      0                    0                    my ( $self, $dbh ) = @_;
3313  ***      0                                         $self->stop_slave($dbh);
3314  ***      0      0                                  my $stat = $self->get_slave_status($dbh)
3315                                                        or die "This server is not a slave";
3316  ***      0                                         $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
3317  ***      0                                         $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
3318  ***      0                                         return $stat;
3319                                                  }
3320                                                  
3321                                                  sub slave_is_running {
3322  ***      0                    0                    my ( $self, $slave_status ) = @_;
3323  ***      0             0                           return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
3324                                                  }
3325                                                  
3326                                                  sub has_slave_updates {
3327  ***      0                    0                    my ( $self, $dbh ) = @_;
3328  ***      0                                         my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
3329  ***      0                                         MKDEBUG && _d($dbh, $sql);
3330  ***      0                                         my ($name, $value) = $dbh->selectrow_array($sql);
3331  ***      0             0                           return $value && $value =~ m/^(1|ON)$/;
3332                                                  }
3333                                                  
3334                                                  sub repl_posn {
3335  ***      0                    0                    my ( $self, $status ) = @_;
3336  ***      0      0      0                           if ( exists $status->{file} && exists $status->{position} ) {
3337                                                        return {
3338  ***      0                                               file     => $status->{file},
3339                                                           position => $status->{position},
3340                                                        };
3341                                                     }
3342                                                     else {
3343                                                        return {
3344  ***      0                                               file     => $status->{relay_master_log_file},
3345                                                           position => $status->{exec_master_log_pos},
3346                                                        };
3347                                                     }
3348                                                  }
3349                                                  
3350                                                  sub get_slave_lag {
3351  ***      0                    0                    my ( $self, $dbh ) = @_;
3352  ***      0                                         my $stat = $self->get_slave_status($dbh);
3353  ***      0                                         return $stat->{seconds_behind_master};
3354                                                  }
3355                                                  
3356                                                  sub pos_cmp {
3357  ***      0                    0                    my ( $self, $a, $b ) = @_;
3358  ***      0                                         return $self->pos_to_string($a) cmp $self->pos_to_string($b);
3359                                                  }
3360                                                  
3361                                                  sub short_host {
3362  ***      0                    0                    my ( $self, $dsn ) = @_;
3363  ***      0                                         my ($host, $port);
3364  ***      0      0                                  if ( $dsn->{master_host} ) {
3365  ***      0                                            $host = $dsn->{master_host};
3366  ***      0                                            $port = $dsn->{master_port};
3367                                                     }
3368                                                     else {
3369  ***      0                                            $host = $dsn->{h};
3370  ***      0                                            $port = $dsn->{P};
3371                                                     }
3372  ***      0      0      0                           return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
3373                                                  }
3374                                                  
3375                                                  sub pos_to_string {
3376  ***      0                    0                    my ( $self, $pos ) = @_;
3377  ***      0                                         my $fmt  = '%s/%020d';
3378  ***      0                                         return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                      
3379                                                  }
3380                                                  
3381                                                  sub _d {
3382  ***      0                    0                    my ($package, undef, $line) = caller 0;
3383  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3384  ***      0                                              map { defined $_ ? $_ : 'undef' }
3385                                                          @_;
3386  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3387                                                  }
3388                                                  
3389                                                  1;
3390                                                  
3391                                                  # ###########################################################################
3392                                                  # End MasterSlave package
3393                                                  # ###########################################################################
3394                                                  
3395                                                  # ###########################################################################
3396                                                  # Daemon package 5266
3397                                                  # ###########################################################################
3398                                                  
3399                                                  package Daemon;
3400                                                  
3401          23                   23           199   use strict;
              23                                 66   
              23                                154   
3402          23                   23           146   use warnings FATAL => 'all';
              23                                 55   
              23                                151   
3403                                                  
3404          23                   23           140   use POSIX qw(setsid);
              23                                 66   
              23                                152   
3405          23                   23           152   use English qw(-no_match_vars);
              23                                162   
              23                                136   
3406                                                  
3407  ***     23            50     23           150   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                 58   
              23                                348   
3408                                                  
3409                                                  sub new {
3410  ***      0                    0                    my ( $class, %args ) = @_;
3411  ***      0                                         foreach my $arg ( qw(o) ) {
3412  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
3413                                                     }
3414  ***      0                                         my $o = $args{o};
3415  ***      0      0                                  my $self = {
      ***             0                               
3416                                                        o        => $o,
3417                                                        log_file => $o->has('log') ? $o->get('log') : undef,
3418                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
3419                                                     };
3420                                                  
3421  ***      0                                         check_PID_file(undef, $self->{PID_file});
3422                                                  
3423  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
3424  ***      0                                         return bless $self, $class;
3425                                                  }
3426                                                  
3427                                                  sub daemonize {
3428  ***      0                    0                    my ( $self ) = @_;
3429                                                  
3430  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
3431  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
3432  ***      0      0                                  if ( $pid ) {
3433  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
3434  ***      0                                            exit;
3435                                                     }
3436                                                  
3437  ***      0                                         $self->{child} = 1;
3438                                                  
3439  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
3440  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
3441                                                  
3442  ***      0                                         $self->_make_PID_file();
3443                                                  
3444  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
3445                                                  
3446  ***      0      0                                  if ( -t STDIN ) {
3447  ***      0                                            close STDIN;
3448  ***      0      0                                     open  STDIN, '/dev/null'
3449                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
3450                                                     }
3451                                                  
3452  ***      0      0                                  if ( $self->{log_file} ) {
3453  ***      0                                            close STDOUT;
3454  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
3455                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
3456                                                  
3457  ***      0                                            close STDERR;
3458  ***      0      0                                     open  STDERR, ">&STDOUT"
3459                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
3460                                                     }
3461                                                     else {
3462  ***      0      0                                     if ( -t STDOUT ) {
3463  ***      0                                               close STDOUT;
3464  ***      0      0                                        open  STDOUT, '>', '/dev/null'
3465                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
3466                                                        }
3467  ***      0      0                                     if ( -t STDERR ) {
3468  ***      0                                               close STDERR;
3469  ***      0      0                                        open  STDERR, '>', '/dev/null'
3470                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
3471                                                        }
3472                                                     }
3473                                                  
3474  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
3475  ***      0                                         return;
3476                                                  }
3477                                                  
3478                                                  sub check_PID_file {
3479  ***      0                    0                    my ( $self, $file ) = @_;
3480  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
3481  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
3482  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
3483  ***      0                                            my $pid;
3484  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
3485  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
3486  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
3487  ***      0      0                                     if ( $pid ) {
3488  ***      0                                               my $pid_is_alive = kill 0, $pid;
3489  ***      0      0                                        if ( $pid_is_alive ) {
3490  ***      0                                                  die "The PID file $PID_file already exists "
3491                                                                 . " and the PID that it contains, $pid, is running";
3492                                                           }
3493                                                           else {
3494  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
3495                                                                 . "contains, $pid, is not running";
3496                                                           }
3497                                                        }
3498                                                        else {
3499  ***      0                                               die "The PID file $PID_file already exists but it does not "
3500                                                              . "contain a PID";
3501                                                        }
3502                                                     }
3503                                                     else {
3504  ***      0                                            MKDEBUG && _d('No PID file');
3505                                                     }
3506  ***      0                                         return;
3507                                                  }
3508                                                  
3509                                                  sub make_PID_file {
3510  ***      0                    0                    my ( $self ) = @_;
3511  ***      0      0                                  if ( exists $self->{child} ) {
3512  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
3513                                                     }
3514  ***      0                                         $self->_make_PID_file();
3515  ***      0                                         $self->{rm_PID_file} = 1;
3516  ***      0                                         return;
3517                                                  }
3518                                                  
3519                                                  sub _make_PID_file {
3520  ***      0                    0                    my ( $self ) = @_;
3521                                                  
3522  ***      0                                         my $PID_file = $self->{PID_file};
3523  ***      0      0                                  if ( !$PID_file ) {
3524  ***      0                                            MKDEBUG && _d('No PID file to create');
3525  ***      0                                            return;
3526                                                     }
3527                                                  
3528  ***      0                                         $self->check_PID_file();
3529                                                  
3530  ***      0      0                                  open my $PID_FH, '>', $PID_file
3531                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
3532  ***      0      0                                  print $PID_FH $PID
3533                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
3534  ***      0      0                                  close $PID_FH
3535                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
3536                                                  
3537  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
3538  ***      0                                         return;
3539                                                  }
3540                                                  
3541                                                  sub _remove_PID_file {
3542  ***      0                    0                    my ( $self ) = @_;
3543  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
3544  ***      0      0                                     unlink $self->{PID_file}
3545                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
3546  ***      0                                            MKDEBUG && _d('Removed PID file');
3547                                                     }
3548                                                     else {
3549  ***      0                                            MKDEBUG && _d('No PID to remove');
3550                                                     }
3551  ***      0                                         return;
3552                                                  }
3553                                                  
3554                                                  sub DESTROY {
3555  ***      0                    0                    my ( $self ) = @_;
3556  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
3557  ***      0                                         return;
3558                                                  }
3559                                                  
3560                                                  sub _d {
3561  ***      0                    0                    my ($package, undef, $line) = caller 0;
3562  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3563  ***      0                                              map { defined $_ ? $_ : 'undef' }
3564                                                          @_;
3565  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3566                                                  }
3567                                                  
3568                                                  1;
3569                                                  
3570                                                  # ###########################################################################
3571                                                  # End Daemon package
3572                                                  # ###########################################################################
3573                                                  
3574                                                  # ###########################################################################
3575                                                  # SchemaIterator package 5473
3576                                                  # ###########################################################################
3577                                                  package SchemaIterator;
3578                                                  
3579          23                   23           174   use strict;
              23                                 61   
              23                                123   
3580          23                   23           138   use warnings FATAL => 'all';
              23                                 67   
              23                                120   
3581                                                  
3582          23                   23           135   use English qw(-no_match_vars);
              23                                 52   
              23                                115   
3583          23                   23           155   use Data::Dumper;
              23                                 66   
              23                                127   
3584                                                  $Data::Dumper::Indent    = 1;
3585                                                  $Data::Dumper::Sortkeys  = 1;
3586                                                  $Data::Dumper::Quotekeys = 0;
3587                                                  
3588  ***     23            50     23           155   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                 59   
              23                                443   
3589                                                  
3590                                                  sub new {
3591  ***      0                    0                    my ( $class, %args ) = @_;
3592  ***      0                                         foreach my $arg ( qw(Quoter) ) {
3593  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
3594                                                     }
3595  ***      0                                         my $self = {
3596                                                        %args,
3597                                                        filter => undef,
3598                                                        dbs    => [],
3599                                                     };
3600  ***      0                                         return bless $self, $class;
3601                                                  }
3602                                                  
3603                                                  sub make_filter {
3604  ***      0                    0                    my ( $self, $o ) = @_;
3605  ***      0                                         my @lines = (
3606                                                        'sub {',
3607                                                        '   my ( $dbh, $db, $tbl ) = @_;',
3608                                                        '   my $engine = undef;',
3609                                                     );
3610                                                  
3611                                                  
3612  ***      0      0                                  my @permit_dbs = _make_filter('unless', '$db', $o->get('databases'))
3613                                                        if $o->has('databases');
3614  ***      0      0                                  my @reject_dbs = _make_filter('if', '$db', $o->get('ignore-databases'))
3615                                                        if $o->has('ignore-databases');
3616  ***      0                                         my @dbs_regex;
3617  ***      0      0      0                           if ( $o->has('databases-regex') && (my $p = $o->get('databases-regex')) ) {
3618  ***      0                                            push @dbs_regex, "      return 0 unless \$db && (\$db =~ m/$p/o);";
3619                                                     }
3620  ***      0                                         my @reject_dbs_regex;
3621  ***      0      0      0                           if ( $o->has('ignore-databases-regex')
3622                                                          && (my $p = $o->get('ignore-databases-regex')) ) {
3623  ***      0                                            push @reject_dbs_regex, "      return 0 if \$db && (\$db =~ m/$p/o);";
3624                                                     }
3625  ***      0      0      0                           if ( @permit_dbs || @reject_dbs || @dbs_regex || @reject_dbs_regex ) {
      ***                    0                        
      ***                    0                        
3626  ***      0      0                                     push @lines,
      ***             0                               
      ***             0                               
      ***             0                               
3627                                                           '   if ( $db ) {',
3628                                                              (@permit_dbs        ? @permit_dbs       : ()),
3629                                                              (@reject_dbs        ? @reject_dbs       : ()),
3630                                                              (@dbs_regex         ? @dbs_regex        : ()),
3631                                                              (@reject_dbs_regex  ? @reject_dbs_regex : ()),
3632                                                           '   }';
3633                                                     }
3634                                                  
3635  ***      0      0      0                           if ( $o->has('tables') || $o->has('ignore-tables')
      ***                    0                        
3636                                                          || $o->has('ignore-tables-regex') ) {
3637                                                  
3638  ***      0                                            my $have_qtbl       = 0;
3639  ***      0                                            my $have_only_qtbls = 0;
3640  ***      0                                            my %qtbls;
3641                                                  
3642  ***      0                                            my @permit_tbls;
3643  ***      0                                            my @permit_qtbls;
3644  ***      0                                            my %permit_qtbls;
3645  ***      0      0                                     if ( $o->get('tables') ) {
3646  ***      0                                               my %tbls;
3647                                                           map {
3648  ***      0      0                                           if ( $_ =~ m/\./ ) {
      ***      0                                      
3649  ***      0                                                     $permit_qtbls{$_} = 1;
3650                                                              }
3651                                                              else {
3652  ***      0                                                     $tbls{$_} = 1;
3653                                                              }
3654  ***      0                                               } keys %{ $o->get('tables') };
3655  ***      0                                               @permit_tbls  = _make_filter('unless', '$tbl', \%tbls);
3656  ***      0                                               @permit_qtbls = _make_filter('unless', '$qtbl', \%permit_qtbls);
3657                                                  
3658  ***      0      0                                        if ( @permit_qtbls ) {
3659  ***      0                                                  push @lines,
3660                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
3661  ***      0                                                  $have_qtbl = 1;
3662                                                           }
3663                                                        }
3664                                                  
3665  ***      0                                            my @reject_tbls;
3666  ***      0                                            my @reject_qtbls;
3667  ***      0                                            my %reject_qtbls;
3668  ***      0      0                                     if ( $o->get('ignore-tables') ) {
3669  ***      0                                               my %tbls;
3670                                                           map {
3671  ***      0      0                                           if ( $_ =~ m/\./ ) {
      ***      0                                      
3672  ***      0                                                     $reject_qtbls{$_} = 1;
3673                                                              }
3674                                                              else {
3675  ***      0                                                     $tbls{$_} = 1;
3676                                                              }
3677  ***      0                                               } keys %{ $o->get('ignore-tables') };
3678  ***      0                                               @reject_tbls= _make_filter('if', '$tbl', \%tbls);
3679  ***      0                                               @reject_qtbls = _make_filter('if', '$qtbl', \%reject_qtbls);
3680                                                  
3681  ***      0      0      0                                 if ( @reject_qtbls && !$have_qtbl ) {
3682  ***      0                                                  push @lines,
3683                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
3684                                                           }
3685                                                        }
3686                                                  
3687  ***      0      0      0                              if ( keys %permit_qtbls  && !@permit_dbs ) {
3688  ***      0                                               my $dbs = {};
3689  ***      0                                               map {
3690  ***      0                                                  my ($db, undef) = split(/\./, $_);
3691  ***      0                                                  $dbs->{$db} = 1;
3692                                                           } keys %permit_qtbls;
3693  ***      0                                               MKDEBUG && _d('Adding restriction "--databases',
3694                                                                 (join(',', keys %$dbs) . '"'));
3695  ***      0      0                                        if ( keys %$dbs ) {
3696  ***      0                                                  $o->set('databases', $dbs);
3697  ***      0                                                  return $self->make_filter($o);
3698                                                           }
3699                                                        }
3700                                                  
3701  ***      0                                            my @tbls_regex;
3702  ***      0      0      0                              if ( $o->has('tables-regex') && (my $p = $o->get('tables-regex')) ) {
3703  ***      0                                               push @tbls_regex, "      return 0 unless \$tbl && (\$tbl =~ m/$p/o);";
3704                                                        }
3705  ***      0                                            my @reject_tbls_regex;
3706  ***      0      0      0                              if ( $o->has('ignore-tables-regex')
3707                                                             && (my $p = $o->get('ignore-tables-regex')) ) {
3708  ***      0                                               push @reject_tbls_regex,
3709                                                              "      return 0 if \$tbl && (\$tbl =~ m/$p/o);";
3710                                                        }
3711                                                  
3712  ***      0                                            my @get_eng;
3713  ***      0                                            my @permit_engs;
3714  ***      0                                            my @reject_engs;
3715  ***      0      0      0                              if ( ($o->has('engines') && $o->get('engines'))
      ***                    0                        
      ***                    0                        
3716                                                             || ($o->has('ignore-engines') && $o->get('ignore-engines')) ) {
3717  ***      0                                               push @get_eng,
3718                                                              '      my $sql = "SHOW TABLE STATUS "',
3719                                                              '              . ($db ? "FROM `$db`" : "")',
3720                                                              '              . " LIKE \'$tbl\'";',
3721                                                              '      MKDEBUG && _d($sql);',
3722                                                              '      eval {',
3723                                                              '         $engine = $dbh->selectrow_hashref($sql)->{engine};',
3724                                                              '      };',
3725                                                              '      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);',
3726                                                              '      MKDEBUG && _d($tbl, "uses engine", $engine);',
3727                                                              '      $engine = lc $engine if $engine;',
3728                                                           @permit_engs
3729                                                              = _make_filter('unless', '$engine', $o->get('engines'), 1);
3730                                                           @reject_engs
3731  ***      0                                                  = _make_filter('if', '$engine', $o->get('ignore-engines'), 1)
3732                                                        }
3733                                                  
3734  ***      0      0      0                              if ( @permit_tbls || @reject_tbls || @tbls_regex || @reject_tbls_regex
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
3735                                                             || @permit_engs || @reject_engs ) {
3736  ***      0      0                                        push @lines,
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
3737                                                              '   if ( $tbl ) {',
3738                                                                 (@permit_tbls       ? @permit_tbls        : ()),
3739                                                                 (@reject_tbls       ? @reject_tbls        : ()),
3740                                                                 (@tbls_regex        ? @tbls_regex         : ()),
3741                                                                 (@reject_tbls_regex ? @reject_tbls_regex  : ()),
3742                                                                 (@permit_qtbls      ? @permit_qtbls       : ()),
3743                                                                 (@reject_qtbls      ? @reject_qtbls       : ()),
3744                                                                 (@get_eng           ? @get_eng            : ()),
3745                                                                 (@permit_engs       ? @permit_engs        : ()),
3746                                                                 (@reject_engs       ? @reject_engs        : ()),
3747                                                              '   }';
3748                                                        }
3749                                                     }
3750                                                  
3751  ***      0                                         push @lines,
3752                                                        '   MKDEBUG && _d(\'Passes filters:\', $db, $tbl, $engine, $dbh);',
3753                                                        '   return 1;',  '}';
3754                                                  
3755  ***      0                                         my $code = join("\n", @lines);
3756  ***      0                                         MKDEBUG && _d('filter sub:', $code);
3757  ***      0      0                                  my $filter_sub= eval $code
3758                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
3759                                                  
3760  ***      0                                         return $filter_sub;
3761                                                  }
3762                                                  
3763                                                  sub set_filter {
3764  ***      0                    0                    my ( $self, $filter_sub ) = @_;
3765  ***      0                                         $self->{filter} = $filter_sub;
3766  ***      0                                         MKDEBUG && _d('Set filter sub');
3767  ***      0                                         return;
3768                                                  }
3769                                                  
3770                                                  sub get_db_itr {
3771  ***      0                    0                    my ( $self, %args ) = @_;
3772  ***      0                                         my @required_args = qw(dbh);
3773  ***      0                                         foreach my $arg ( @required_args ) {
3774  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
3775                                                     }
3776  ***      0                                         my ($dbh) = @args{@required_args};
3777                                                  
3778  ***      0                                         my $filter = $self->{filter};
3779  ***      0                                         my @dbs;
3780  ***      0                                         eval {
3781  ***      0                                            my $sql = 'SHOW DATABASES';
3782  ***      0                                            MKDEBUG && _d($sql);
3783  ***      0      0                                     @dbs =  grep {
3784  ***      0                                               my $ok = $filter ? $filter->($dbh, $_, undef) : 1;
3785  ***      0      0                                        $ok = 0 if $_ =~ m/information_schema|lost\+found/;
3786  ***      0                                               $ok;
3787  ***      0                                            } @{ $dbh->selectcol_arrayref($sql) };
3788  ***      0                                            MKDEBUG && _d('Found', scalar @dbs, 'databases');
3789                                                     };
3790  ***      0                                         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3791                                                     return sub {
3792  ***      0                    0                       return shift @dbs;
3793  ***      0                                         };
3794                                                  }
3795                                                  
3796                                                  sub get_tbl_itr {
3797  ***      0                    0                    my ( $self, %args ) = @_;
3798  ***      0                                         my @required_args = qw(dbh db);
3799  ***      0                                         foreach my $arg ( @required_args ) {
3800  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
3801                                                     }
3802  ***      0                                         my ($dbh, $db, $views) = @args{@required_args, 'views'};
3803                                                  
3804  ***      0                                         my $filter = $self->{filter};
3805  ***      0                                         my @tbls;
3806  ***      0      0                                  if ( $db ) {
3807  ***      0                                            eval {
3808  ***      0                                               my $sql = 'SHOW /*!50002 FULL*/ TABLES FROM '
3809                                                                   . $self->{Quoter}->quote($db);
3810  ***      0                                               MKDEBUG && _d($sql);
3811  ***      0                                               @tbls = map {
3812  ***      0                                                  $_->[0]
3813                                                           }
3814                                                           grep {
3815  ***      0                                                  my ($tbl, $type) = @$_;
3816  ***      0      0                                           my $ok = $filter ? $filter->($dbh, $db, $tbl) : 1;
3817  ***      0      0                                           if ( !$views ) {
3818  ***      0      0      0                                       $ok = 0 if ($type || '') eq 'VIEW';
3819                                                              }
3820  ***      0                                                  $ok;
3821                                                           }
3822  ***      0                                               @{ $dbh->selectall_arrayref($sql) };
3823  ***      0                                               MKDEBUG && _d('Found', scalar @tbls, 'tables in', $db);
3824                                                        };
3825  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3826                                                     }
3827                                                     else {
3828  ***      0                                            MKDEBUG && _d('No db given so no tables');
3829                                                     }
3830                                                     return sub {
3831  ***      0                    0                       return shift @tbls;
3832  ***      0                                         };
3833                                                  }
3834                                                  
3835                                                  sub _make_filter {
3836  ***      0                    0                    my ( $cond, $var_name, $objs, $lc ) = @_;
3837  ***      0                                         my @lines;
3838  ***      0      0                                  if ( scalar keys %$objs ) {
3839  ***      0      0                                     my $test = join(' || ',
3840  ***      0                                               map { "$var_name eq '" . ($lc ? lc $_ : $_) ."'" } keys %$objs);
3841  ***      0                                            push @lines, "      return 0 $cond $var_name && ($test);",
3842                                                     }
3843  ***      0                                         return @lines;
3844                                                  }
3845                                                  
3846                                                  sub _d {
3847  ***      0                    0                    my ($package, undef, $line) = caller 0;
3848  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3849  ***      0                                              map { defined $_ ? $_ : 'undef' }
3850                                                          @_;
3851  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3852                                                  }
3853                                                  
3854                                                  1;
3855                                                  
3856                                                  # ###########################################################################
3857                                                  # End SchemaIterator package
3858                                                  # ###########################################################################
3859                                                  
3860                                                  # ###########################################################################
3861                                                  # This is a combination of modules and programs in one -- a runnable module.
3862                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
3863                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
3864                                                  #
3865                                                  # Check at the end of this package for the call to main() which actually runs
3866                                                  # the program.
3867                                                  # ###########################################################################
3868                                                  package mk_table_checksum;
3869                                                  
3870          23                   23           175   use English qw(-no_match_vars);
              23                                 64   
              23                                126   
3871          23                   23           170   use List::Util qw(max maxstr);
              23                                 56   
              23                                133   
3872          23                   23           162   use Time::HiRes qw(gettimeofday sleep);
              23                                 55   
              23                                167   
3873          23                   23           160   use Data::Dumper;
              23                                 60   
              23                                112   
3874                                                  $Data::Dumper::Indent    = 0;
3875                                                  $Data::Dumper::Quotekeys = 0;
3876                                                  
3877  ***     23            50     23           146   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              23                                 54   
              23                                319   
3878                                                  
3879                                                  $OUTPUT_AUTOFLUSH = 1;
3880                                                  
3881                                                  # Global variables.
3882                                                  my $exit_status = 0;
3883                                                  my $checksum_table_data;
3884                                                  my ( $fetch_sth, $update_sth, $savesince_sth );
3885                                                  my ( $crc_wid, $md5sum_fmt );
3886                                                  my $already_checksummed;
3887                                                  # %tables_to_checksum has the following structure:
3888                                                  #    database => [
3889                                                  #       { table },
3890                                                  #       ...
3891                                                  #    ],
3892                                                  #    ...
3893                                                  my %tables_to_checksum;
3894                                                  
3895                                                  sub main {
3896  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
3897                                                  
3898                                                     # ########################################################################
3899                                                     # Get configuration information.
3900                                                     # ########################################################################
3901  ***      0                                         my $dp = new DSNParser();
3902                                                  
3903                                                     # Because of --arg-table, $final_o is the OptionParser obj used to get
3904                                                     # most options (see my $final_o below).
3905  ***      0                                         my $o = new OptionParser(
3906                                                        dp          => $dp,
3907                                                        strict      => 0,
3908                                                        prompt      => '[OPTION]... HOST_DSN [HOST_DSN]...',
3909                                                        description => 'checksums MySQL tables efficiently on one or more hosts. '
3910                                                                     . ' Each host is specified as a DSN and missing values are '
3911                                                                     . 'inherited from the first host.  If you specify multiple '
3912                                                                     . 'hosts, the first is assumed to be the master.',
3913                                                     );
3914  ***      0                                         $o->get_specs();
3915  ***      0                                         $o->get_opts();
3916                                                  
3917  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
3918                                                  
3919                                                     # This list contains all the command-line arguments that can be overridden
3920                                                     # by a table that contains arguments for each table to be checksummed.
3921                                                     # The long form of each argument is given.  The values are read from the
3922                                                     # POD by finding the magical token.
3923  ***      0                                         my %overridable_args;
3924                                                     {
3925  ***      0                                            my $para = $o->read_para_after(
      ***      0                                      
3926                                                           __FILE__, qr/MAGIC_overridable_args/);
3927  ***      0                                            foreach my $arg ( $para =~ m/([\w-]+)/g ) {
3928  ***      0      0                                        die "Magical argument $arg mentioned in POD is not a "
3929                                                              . "command-line argument" unless $o->has($arg);
3930  ***      0                                               $overridable_args{$arg} = 1;
3931                                                        }
3932                                                     };
3933                                                  
3934                                                     # Post-process command-line options and arguments.
3935  ***      0      0                                  $o->set('lock', 1)      if $o->get('wait');
3936  ***      0      0                                  $o->set('slave-lag', 1) if $o->get('lock');
3937                                                  
3938  ***      0      0                                  if ( !@ARGV ) {
3939  ***      0                                            $o->save_error("No hosts specified.");
3940                                                     }
3941                                                  
3942  ***      0                                         my @hosts; 
3943  ***      0                                         my $dsn_defaults = $dp->parse_options($o);
3944                                                     {
3945  ***      0                                            foreach my $arg ( unique(@ARGV) ) {
      ***      0                                      
3946  ***      0                                               push @hosts, $dp->parse($arg, $hosts[0], $dsn_defaults);
3947                                                        }
3948                                                     }
3949                                                  
3950  ***      0      0                                  if ( $o->get('explain-hosts') ) {
3951  ***      0                                            foreach my $host ( @hosts ) {
3952  ***      0                                               print "Server $host->{h}:\n   ", $dp->as_string($host), "\n";
3953                                                        }
3954  ***      0                                            return 0;
3955                                                     }
3956                                                  
3957                                                     # Checksumming table data is the normal operation. But if we're only to
3958                                                     # compare schemas, then we can skip a lot of work, like selecting an algo,
3959                                                     # replication stuff, etc.
3960  ***      0      0                                  $checksum_table_data = $o->get('schema') ? 0 : 1;
3961                                                  
3962  ***      0      0                                  if ( $o->get('checksum') ) {
3963  ***      0                                            $o->set('count', 0);
3964                                                     }
3965                                                  
3966  ***      0      0                                  if ( $o->get('explain') ) {
3967  ***      0                                            @hosts = $hosts[0];
3968                                                     }
3969                                                  
3970  ***      0      0                                  if ( !$o->get('help') ) {
3971  ***      0      0      0                              if ( $o->get('replicate-check') && !$o->get('replicate') ) {
3972  ***      0                                               $o->save_error("--replicate-check requires --replicate.");
3973                                                        }
3974  ***      0      0      0                              if ( $o->get('save-since') && !$o->get('arg-table') ) {
      ***             0      0                        
3975  ***      0                                               $o->save_error("--save-since requires --arg-table.");
3976                                                        }
3977                                                        elsif ( $o->get('replicate') && @hosts > 1 ) {
3978  ***      0                                               $o->save_error("You can only specify one host with --replicate.");
3979                                                        }
3980                                                  
3981  ***      0      0      0                              if ( $o->get('resume-replicate') && !$o->get('replicate') ) {
3982  ***      0                                               $o->save_error("--resume-replicate requires --replicate.");
3983                                                        }
3984  ***      0      0      0                              if ( $o->get('resume') && $o->get('replicate') ) {
3985  ***      0                                               $o->save_error('--resume does not work with --replicate.  '
3986                                                              . 'Use --resume-replicate instead.');
3987                                                        }
3988                                                     }
3989                                                  
3990  ***      0                                         $o->usage_or_errors();
3991                                                  
3992                                                     # ########################################################################
3993                                                     # If --pid, check it first since we'll die if it already exits.
3994                                                     # ########################################################################
3995  ***      0                                         my $daemon;
3996  ***      0      0                                  if ( $o->get('pid') ) {
3997                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
3998                                                        # in the the scope of main() because when it's destroyed it automatically
3999                                                        # removes the PID file.
4000  ***      0                                            $daemon = new Daemon(o=>$o);
4001  ***      0                                            $daemon->make_PID_file();
4002                                                     }
4003                                                  
4004                                                     # ########################################################################
4005                                                     # Ready to work now.
4006                                                     # ########################################################################
4007  ***      0                                         my $q  = new Quoter();
4008  ***      0                                         my $vp = new VersionParser();
4009  ***      0                                         my $tp = new TableParser(Quoter => $q);
4010  ***      0                                         my $tc = new TableChecksum(Quoter=> $q, VersionParser => $vp);
4011  ***      0                                         my $ms = new MasterSlave();
4012  ***      0                                         my $du = new MySQLDump(cache => 0);
4013  ***      0                                         my $ch = new TableChunker(Quoter => $q, MySQLDump => $du); 
4014  ***      0                                         my %common_modules = (
4015                                                        ch => $ch,
4016                                                        dp => $dp,
4017                                                        du => $du,
4018                                                        o  => $o,
4019                                                        ms => $ms,
4020                                                        q  => $q,
4021                                                        tc => $tc,
4022                                                        tp => $tp,
4023                                                        vp => $vp,
4024                                                     );
4025                                                  
4026  ***      0                                         my $main_dbh = get_cxn($hosts[0], %common_modules);
4027                                                  
4028  ***      0                                         my $lag_dbh;
4029                                                     {
4030  ***      0      0                                     if ( $o->get('check-slave-lag') ) {
      ***      0                                      
4031  ***      0                                               my $dsn = $dp->parse($o->get('check-slave-lag'), $hosts[0], $dsn_defaults);
4032  ***      0                                               $lag_dbh = get_cxn($dsn, %common_modules);
4033                                                        }
4034                                                     }
4035                                                  
4036                                                     # ########################################################################
4037                                                     # Load --arg-table information.
4038                                                     # ########################################################################
4039  ***      0                                         my %args_for;
4040  ***      0      0                                  if ( my $arg_tbl = $o->get('arg-table') ) {
4041  ***      0                                            my %col_in_argtable;
4042  ***      0                                            my $rows = $main_dbh->selectall_arrayref(
4043                                                           "SELECT * FROM $arg_tbl", { Slice => {} });
4044  ***      0                                            foreach my $row ( @$rows ) {
4045  ***      0      0      0                                 die "Invalid entry in --arg-table: db and tbl must be set"
4046                                                              unless $row->{db} && $row->{tbl};
4047  ***      0                                               $args_for{$row->{db}}->{$row->{tbl}} = {
4048  ***      0      0                                           map  { $_ => $row->{$_} }
4049  ***      0                                                  grep { $overridable_args{$_} && defined $row->{$_} }
4050                                                              keys %$row
4051                                                           };
4052  ***      0      0                                        if ( !%col_in_argtable ) { # do only once
4053  ***      0                                                  foreach my $key ( keys %$row ) {
4054  ***      0      0                                              next if $key =~ m/^(db|tbl|ts)$/;
4055  ***      0      0                                              die "Column $key (from $arg_tbl given by --arg-table) is not "
4056                                                                    . "an overridable argument" unless $overridable_args{$key};
4057  ***      0                                                     $col_in_argtable{$key} = 1;
4058                                                              }
4059                                                           }
4060                                                        }
4061  ***      0      0                                     if ( $col_in_argtable{since} ) {
4062  ***      0                                               $savesince_sth = $main_dbh->prepare(
4063                                                             "UPDATE $arg_tbl SET since=COALESCE(?, NOW()) WHERE db=? AND tbl=?");
4064                                                        }
4065                                                     }
4066                                                  
4067                                                     # ########################################################################
4068                                                     # Check replication slaves if desired.  If only --replicate-check is given,
4069                                                     # then we will exit here.  If --recheck is also given, then we'll continue
4070                                                     # through the entire script but checksum only the inconsistent tables found
4071                                                     # here.
4072                                                     # ########################################################################
4073  ***      0      0                                  if ( $o->get('replicate-check') ) {
4074  ***      0      0                                     my $callback = $o->get('recheck')
4075                                                                     ? \&save_inconsistent_tbls
4076                                                                     : \&print_inconsistent_tbls;
4077                                                        $ms->recurse_to_slaves(
4078                                                           {  dbh        => $main_dbh,
4079                                                              dsn        => $hosts[0],
4080                                                              dsn_parser => $dp,
4081                                                              recurse    => $o->get('replicate-check'),
4082                                                              callback   => sub {
4083  ***      0                    0                                my ( $dsn, $dbh, $level, $parent ) = @_;
4084  ***      0                                                     my @tbls = $tc->find_replication_differences(
4085                                                                    $dbh, $o->get('replicate'));
4086  ***      0      0                                              return unless @tbls;
4087  ***      0                                                     $exit_status = 1;
4088                                                                 # Call the callback that does something useful with
4089                                                                 # the inconsistent tables.
4090                                                                 # o dbh db tbl args_for
4091  ***      0                                                     $callback->(
4092                                                                    dsn      => $dsn,
4093                                                                    dbh      => $dbh,
4094                                                                    level    => $level,
4095                                                                    parent   => $parent,
4096                                                                    tbls     => \@tbls,
4097                                                                    args_for => \%args_for,
4098                                                                    %common_modules
4099                                                                 );
4100                                                              },
4101  ***      0                                                  method => $o->get('recursion-method'),
4102                                                           }
4103                                                        );
4104  ***      0      0                                     return $exit_status unless $o->get('recheck');
4105                                                     }
4106                                                  
4107                                                     # ########################################################################
4108                                                     # Otherwise get ready to checksum table data, unless we have only to check
4109                                                     # schemas in which case we can skip all such work, knowing already that we
4110                                                     # will use CRC32.
4111                                                     # ########################################################################
4112  ***      0      0                                  if ( $checksum_table_data ) {
4113                                                        # Verify that CONCAT_WS is compatible across all servers. On older
4114                                                        # versions of MySQL it skips both empty strings and NULL; on newer
4115                                                        # just NULL.
4116  ***      0      0      0                              if ( $o->get('verify') && @hosts > 1 ) {
4117  ***      0                                               verify_checksum_compat(hosts=>\@hosts, %common_modules);
4118                                                        }
4119                                                  
4120  ***      0                                            ($fetch_sth, $update_sth)
4121                                                           = check_repl_table(dbh=>$main_dbh, %common_modules);
4122                                                     }
4123                                                     else {
4124  ***      0                                            $crc_wid = 16; # Wider than the widest CRC32.
4125                                                     } 
4126                                                  
4127                                                     # ########################################################################
4128                                                     # If resuming a previous run, figure out what the previous run finished.
4129                                                     # ######################################################################## 
4130  ***      0      0      0                           if ( $o->get('replicate') && $o->get('resume-replicate') ) {
      ***             0                               
4131  ***      0                                            $already_checksummed = read_repl_table(
4132                                                           dbh  => $main_dbh,
4133                                                           host => $hosts[0]->{h},
4134                                                           %common_modules,
4135                                                        );
4136                                                     } 
4137                                                     elsif ( $o->get('resume') ) {
4138  ***      0                                            $already_checksummed = parse_resume_file($o->get('resume'));
4139                                                     }
4140                                                  
4141                                                     # ########################################################################
4142                                                     # Iterate through databases and tables and do the checksums.
4143                                                     # ########################################################################
4144                                                  
4145                                                     # Get table info for all hosts, all slaves, unless we're in the special
4146                                                     # "repl-re-check" mode in which case %tables_to_checksum has already the
4147                                                     # inconsistent tables that we need to re-checksum.
4148                                                     get_all_tbls_info(
4149  ***      0      0      0                              dbh      => $main_dbh,
4150                                                        args_for => \%args_for,
4151                                                        %common_modules,
4152                                                     ) unless ($o->get('replicate-check') && $o->get('recheck'));
4153                                                  
4154                                                     # Finally, checksum the tables.
4155  ***      0                                         foreach my $database ( keys %tables_to_checksum ) {
4156  ***      0                                            my $tables = $tables_to_checksum{$database};
4157  ***      0                                            checksum_tables(
4158                                                           dbh     => $main_dbh,
4159                                                           db      => $database,
4160                                                           tbls    => $tables,
4161                                                           hosts   => \@hosts,
4162                                                           lag_dbh => $lag_dbh,
4163                                                           %common_modules
4164                                                        );
4165                                                     }
4166                                                  
4167  ***      0                                         return $exit_status;
4168                                                  }
4169                                                  
4170                                                  # ############################################################################
4171                                                  # Subroutines
4172                                                  # ############################################################################
4173                                                  
4174                                                  sub get_all_tbls_info {
4175  ***      0                    0                    my ( %args ) = @_;
4176  ***      0                                         foreach my $arg ( qw(o dbh q tp du ch args_for) ) {
4177  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4178                                                     }
4179  ***      0                                         my $o      = $args{o};
4180  ***      0                                         my $dbh    = $args{dbh};
4181                                                  
4182  ***      0                                         my $si = new SchemaIterator(
4183                                                        Quoter => $args{q},
4184                                                     );
4185  ***      0                                         $si->set_filter($si->make_filter($o));
4186                                                  
4187  ***      0                                         my $next_db = $si->get_db_itr(dbh => $dbh);
4188  ***      0                                         while ( my $db = $next_db->() ) {
4189  ***      0                                            my $next_tbl = $si->get_tbl_itr(
4190                                                           dbh   => $dbh,
4191                                                           db    => $db,
4192                                                           views => 0,
4193                                                        );
4194  ***      0                                            while ( my $tbl = $next_tbl->() ) {
4195  ***      0                                               MKDEBUG && _d("Examining", $db, '.', $tbl);
4196  ***      0                                               my $final_o = get_final_opts(
4197                                                              %args,
4198                                                              db  => $db,
4199                                                              tbl => $tbl,
4200                                                           );
4201  ***      0                                               save_tbl_to_checksum(
4202                                                              %args,
4203                                                              db      => $db,
4204                                                              tbl     => $tbl,
4205                                                              final_o => $final_o,
4206                                                           );
4207                                                        }
4208                                                     }
4209                                                  
4210  ***      0                                         return;
4211                                                  }
4212                                                  
4213                                                  sub save_tbl_to_checksum {
4214  ***      0                    0                    my ( %args ) = @_;
4215  ***      0                                         foreach my $arg ( qw(q ch du final_o tp dbh db tbl du tp ch vp) ) {
4216  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4217                                                     }
4218  ***      0                                         my $du      = $args{du};
4219  ***      0                                         my $tp      = $args{tp};
4220  ***      0                                         my $ch      = $args{ch};
4221  ***      0                                         my $final_o = $args{final_o};
4222  ***      0                                         my $dbh     = $args{dbh};
4223  ***      0                                         my $db      = $args{db};
4224  ***      0                                         my $tbl     = $args{tbl};
4225  ***      0                                         my $q       = $args{q};
4226  ***      0                                         my $vp      = $args{vp};
4227                                                  
4228                                                     # Skip the table in which checksums are stored.
4229  ***      0      0      0                           return if ($final_o->get('replicate')
4230                                                        && $final_o->get('replicate') eq "$db.$tbl");
4231                                                  
4232  ***      0                                         eval { # Catch errors caused by tables being dropped during work.
4233                                                  
4234                                                        # Parse the table and determine a column that's chunkable.  This is
4235                                                        # used not only for chunking, but also for --since.
4236  ***      0                                            my $create        = $du->get_create_table($dbh, $q, $db, $tbl);
4237  ***      0                                            my $struct        = $tp->parse($create);
4238  ***      0                                            my ( $col, $idx ) = $ch->get_first_chunkable_column(tbl_struct=>$struct);
4239                                                  
4240  ***      0      0                                     $idx = undef if $final_o->get('no-use-index');
4241  ***      0      0                                     if ( $idx ) {
4242  ***      0      0                                        my $hint = $vp->version_ge($dbh, '4.0.9') ? 'FORCE' : 'USE';
4243  ***      0                                               $idx     = "$hint INDEX (" . $q->quote($idx) . ")";
4244                                                        }
4245  ***      0                                            MKDEBUG && _d('Index hint:', $idx);
4246                                                  
4247  ***      0                                            my @chunks = '1=1'; # Default.
4248  ***      0                                            my $maxval = undef;
4249  ***      0      0                                     if ( $args{given_chunks} ) {
4250  ***      0                                               @chunks = @{$args{given_chunks}};
      ***      0                                      
4251                                                        }
4252                                                        else {      
4253  ***      0      0      0                                 if ( $final_o->get('chunk-size') && $col ) {
4254  ***      0                                                  my $rows_per_chunk = $ch->size_to_rows(
4255                                                                 dbh        => $dbh,
4256                                                                 db         => $db,
4257                                                                 tbl        => $tbl,
4258                                                                 chunk_size => $final_o->get('chunk-size'),
4259                                                              );
4260                                                  
4261                                                              # Calculate chunks for this table.
4262  ***      0                                                  my %params = $ch->get_range_statistics(
4263                                                                 dbh       => $dbh,
4264                                                                 db        => $db,
4265                                                                 tbl       => $tbl,
4266                                                                 chunk_col => $col
4267                                                              );
4268  ***      0      0                                           if ( !grep { !defined $params{$_} } qw(min max rows_in_range) ) {
      ***      0                                      
4269  ***      0                                                     @chunks = $ch->calculate_chunks(
4270                                                                    dbh        => $dbh,
4271                                                                    tbl_struct => $struct,
4272                                                                    chunk_col  => $col,
4273                                                                    chunk_size => $rows_per_chunk,
4274                                                                    %params,
4275                                                                 );
4276  ***      0                                                     $maxval = $params{max};
4277                                                              }
4278                                                           }
4279                                                        }
4280                                                  
4281  ***      0                                            push @{ $tables_to_checksum{$db} }, {
      ***      0                                      
4282                                                           struct   => $struct,
4283                                                           create   => $create,
4284                                                           database => $db,
4285                                                           table    => $tbl,
4286                                                           column   => $col,
4287                                                           maxval   => $maxval,
4288                                                           index    => $idx,
4289                                                           chunks   => \@chunks,
4290                                                           final_o  => $final_o,
4291                                                        };
4292                                                     };
4293  ***      0      0                                  if ( $EVAL_ERROR ) {
4294  ***      0                                            print_err($final_o, $EVAL_ERROR, $db, $tbl);
4295                                                     }
4296                                                  
4297  ***      0                                         return;
4298                                                  }
4299                                                  
4300                                                  # Checksum the tables in the given database.
4301                                                  # A separate report for each database and its tables is printed.
4302                                                  sub checksum_tables {
4303  ***      0                    0                    my ( %args ) = @_;
4304  ***      0                                         foreach my $arg ( qw(tc du o q db dbh hosts tbls) ) {
4305  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4306                                                     }
4307  ***      0                                         my $tc    = $args{tc};
4308  ***      0                                         my $du    = $args{du};
4309  ***      0                                         my $o     = $args{o};
4310  ***      0                                         my $db    = $args{db};
4311  ***      0                                         my $dbh   = $args{dbh};
4312  ***      0                                         my $hosts = $args{hosts};
4313  ***      0                                         my $tbls  = $args{tbls};
4314  ***      0                                         my $q     = $args{q};
4315                                                  
4316  ***      0                                         my ($hdr, $explain);
4317                                                  
4318                                                     # NOTE: remember, you can't 'next TABLE' inside the eval{}.
4319                                                     # NOTE: remember to use the final_o embedded within each $table, not $o
4320  ***      0                                         foreach my $table ( @$tbls ) {
4321  ***      0                                            eval {
4322  ***      0                                               my $final_o = $table->{final_o};
4323  ***      0                                               delete $table->{final_o};  # so we can Dumper($table) tersely
4324  ***      0                                               my $do_table = 1;
4325  ***      0                                               MKDEBUG && _d("Doing", $db, '.', $table->{table});
4326  ***      0                                               MKDEBUG && _d("Table:", Dumper($table));
4327                                                  
4328                                                           # Determine the checksum strategy for every table because it
4329                                                           # might change given various --arg-table opts for each table.
4330  ***      0                                               my $strat_ref;
4331  ***      0                                               my ( $strat, $crc_type, $func, $opt_slice );
4332  ***      0      0      0                                 if ( $checksum_table_data && $do_table ) {
4333  ***      0                                                  $strat_ref = determine_checksum_strat(
4334                                                                 dbh => $dbh,
4335                                                                 tc  => $tc,
4336                                                                 o   => $final_o,
4337                                                              );
4338  ***      0                                                  ( $strat, $crc_wid, $crc_type, $func, $opt_slice )
4339                                                                 = @$strat_ref{ qw(strat crc_wid crc_type func opt_slice) };
4340  ***      0                                                  MKDEBUG && _d("Checksum strat:", Dumper($strat_ref));
4341                                                           }
4342                                                           else {
4343                                                              # --schema doesn't use a checksum strategy, but do_tbl()
4344                                                              # requires a start arg.
4345  ***      0                                                  $strat = '--schema';
4346                                                           }
4347  ***      0                                               $md5sum_fmt = "%-${crc_wid}s  %s.%s.%s.%d\n";
4348                                                  
4349                                                           # Design and print header unless we are resuming in which case
4350                                                           # we should have already re-printed the partial output of the
4351                                                           # resume file in parse_resume_file().  This only has to be done
4352                                                           # once and done here because we need $crc_wid which is determined
4353                                                           # by the checksum strat above.
4354  ***      0      0                                        if ( !$hdr ) {
4355  ***      0      0                                           if ( $o->get('tab') ) {
4356  ***      0                                                     $hdr = "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n";
4357  ***      0                                                     $explain = "%s\t%s\t%s\n";
4358                                                              }
4359                                                              else {
4360  ***      0                                                     my $max_tbl  = max(5, map { length($_->{table}) } @$tbls);
      ***      0                                      
4361  ***      0                                                     my $max_db   = max(8, length($db));
4362  ***      0                                                     my $max_host = max(4, map { length($_->{h}) } @$hosts);
      ***      0                                      
4363  ***      0                                                     $hdr         = "%-${max_db}s %-${max_tbl}s %5s "
4364                                                                              . "%-${max_host}s %-6s %10s %${crc_wid}s %4s %4s %4s %4s\n";
4365  ***      0                                                     $explain     = "%-${max_db}s %-${max_tbl}s %s\n";
4366                                                              }
4367  ***      0                                                  my @hdr_args = qw(DATABASE TABLE CHUNK HOST ENGINE
4368                                                                                COUNT CHECKSUM TIME WAIT STAT LAG);
4369  ***      0      0      0                                    unless ( $o->get('quiet')
      ***                    0                        
      ***                    0                        
4370                                                                       || $o->get('explain')
4371                                                                       || $o->get('checksum')
4372                                                                       || $o->get('resume') )
4373                                                              {
4374  ***      0      0                                              printf($hdr, @hdr_args)
4375                                                                    or die "Cannot print: $OS_ERROR";
4376                                                              }
4377                                                           }
4378                                                  
4379                                                           # Clean out the replication table entry for this table.
4380  ***      0      0      0                                 if ( (my $replicate_table = $final_o->get('replicate'))
4381                                                                && !$final_o->get('explain') ) {
4382  ***      0                                                  my $del_sql = "DELETE FROM $replicate_table WHERE db=? AND tbl=?";
4383  ***      0                                                  MKDEBUG && _d($dbh, $del_sql, $db, $table->{table});
4384  ***      0                                                  $dbh->do($del_sql, {}, $db, $table->{table});
4385                                                           }
4386                                                  
4387                                                           # If --since is given, figure out either
4388                                                           # 1) for temporal sinces, if the table has an update time and that
4389                                                           #    time is newer than --since, then checksum the whole table,
4390                                                           #    otherwise skip it; or
4391                                                           # 2) for "numerical" sinces, which column to use: either the
4392                                                           #    specified column (--sincecolumn) or the auto-discovered one,
4393                                                           #    whichever exists in the table, in that order.
4394                                                           # Then, if --savesince is given, save either 1) the current timestamp
4395                                                           # or 2) the resulting WHERE clause.
4396  ***      0      0                                        if ( $final_o->get('since') ) {
4397  ***      0      0                                           if ( is_temporal($final_o->get('since')) ) {
4398  ***      0                                                     MKDEBUG && _d('--since is temporal');
4399  ***      0                                                     my ( $stat )
4400                                                                    = $du->get_table_status($dbh, $q, $db, $table->{table});
4401  ***      0                                                     my $time = $stat->{update_time};
4402  ***      0      0      0                                       if ( $time && $time lt $final_o->get('since') ) {
4403  ***      0                                                        MKDEBUG && _d("Skipping table because --since value",
4404                                                                       $final_o->get('since'), "is newer than", $time);
4405  ***      0                                                        $do_table = 0;
4406  ***      0                                                        $table->{chunks} = [];
4407                                                                 }
4408                                                              }
4409                                                              else {
4410  ***      0                                                     MKDEBUG && _d('--since is numerical');
4411                                                                 # For numerical sinces, choose the column to apply --since to.
4412                                                                 # It may not be the column the user said to use! If the user
4413                                                                 # didn't specify a column that's good to chunk on, we'll use
4414                                                                 # something else instead.
4415                                                  
4416                                                                 # $table->{column} is the first chunkable column returned from
4417                                                                 # the call to get_first_chunkable_column() in
4418                                                                 # save_tbl_to_checksum().
4419  ***      0      0                                              my ( $sincecol ) =
4420  ***      0                                                        grep { $_ && $table->{struct}->{is_col}->{$_} }
4421                                                                       ( $table->{column}, $final_o->get('since-column') );
4422                                                  
4423  ***      0      0                                              if ( $sincecol ) {
4424  ***      0                                                        MKDEBUG && _d('Column for numerical --since:',
4425                                                                       $db, '.', $table->{table}, '.', $sincecol);
4426                                                                    # This ends up being an additional WHERE clause.
4427  ***      0                                                        $table->{since} = $q->quote($sincecol)
4428                                                                       . '>=' .  $q->quote_val($final_o->get('since'));
4429                                                                 }
4430                                                                 else {
4431  ***      0                                                        MKDEBUG && _d('No column for numerical --since for',
4432                                                                       $db, '.', $table->{table});
4433                                                                 }
4434                                                              }
4435                                                           }
4436                                                  
4437                                                           # ##################################################################
4438                                                           # The query is independent of the chunk, so I make it once for every
4439                                                           # one.
4440                                                           # ##################################################################
4441  ***      0                                               my $query;
4442  ***      0      0      0                                 if ( $checksum_table_data && $do_table ) {
4443  ***      0                                                  $query = $tc->make_checksum_query(
4444                                                                 db              => $db,
4445                                                                 tbl             => $table->{table},
4446                                                                 tbl_struct      => $table->{struct},
4447                                                                 algorithm       => $strat,
4448                                                                 function        => $func,
4449                                                                 crc_wid         => $crc_wid,
4450                                                                 crc_type        => $crc_type,
4451                                                                 opt_slice       => $opt_slice,
4452                                                                 cols            => $final_o->get('columns'),
4453                                                                 sep             => $final_o->get('separator'),
4454                                                                 replicate       => $final_o->get('replicate'),
4455                                                                 float_precision => $final_o->get('float-precision'),
4456                                                                 trim            => $final_o->get('trim'),
4457                                                                 ignorecols      => $final_o->get('ignore-columns'),
4458                                                              );
4459                                                           }
4460                                                           else { # --schema
4461  ***      0                                                  $query = undef;
4462                                                           }
4463                                                  
4464  ***      0                                               checksum_chunks(
4465                                                              %args,
4466                                                              tbl     => $table,
4467                                                              query   => $query,
4468                                                              hdr     => $hdr,
4469                                                              explain => $explain,
4470                                                              final_o => $final_o,
4471                                                              strat   => $strat,
4472                                                           );
4473                                                  
4474                                                           # Save the --since value if
4475                                                           #    1) it's temporal and the tbl had changed since --since; or
4476                                                           #    2) it's "numerical" and it had a chunkable or nibble-able
4477                                                           #       column and it wasn't empty
4478                                                           # See issues 121 and 122.
4479  ***      0      0      0                                 if ( $final_o->get('save-since') && $savesince_sth ) {
4480  ***      0      0                                           if ( is_temporal($final_o->get('since')) ) {
      ***             0                               
4481  ***      0                                                     MKDEBUG && _d(
4482                                                                    "Saving temporal --since value: current timestamp for",
4483                                                                    $db, '.', $table->{table});
4484  ***      0                                                     $savesince_sth->execute(undef,
4485                                                                    $db, $table->{table});
4486                                                              }
4487                                                              elsif ( defined $table->{maxval} ) {
4488  ***      0                                                     MKDEBUG && _d("Saving numerical --since value:",
4489                                                                    $table->{maxval}, "for", $db, '.', $table->{table});
4490  ***      0                                                     $savesince_sth->execute($table->{maxval},
4491                                                                    $db, $table->{table});
4492                                                              }
4493                                                              else {
4494  ***      0                                                     MKDEBUG && _d("Cannot save --since value:",
4495                                                                    $table->{maxval}, "for", $db, '.', $table->{table});
4496                                                              }
4497                                                           }
4498                                                        };
4499  ***      0      0                                     if ( $EVAL_ERROR ) {
4500  ***      0                                               print_err($o, $EVAL_ERROR, $db, $table->{table});
4501                                                        }
4502                                                     }
4503                                                  
4504  ***      0                                         return;
4505                                                  }
4506                                                  
4507                                                  sub checksum_chunks {
4508  ***      0                    0                    my ( %args ) = @_;
4509  ***      0                                         foreach my $arg ( qw(dp final_o ms o q db tbl hosts hdr explain) ) {
4510  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4511                                                     }
4512  ***      0                                         my $dp      = $args{dp};
4513  ***      0                                         my $du      = $args{du};
4514  ***      0                                         my $final_o = $args{final_o};
4515  ***      0                                         my $ms      = $args{ms};
4516  ***      0                                         my $o       = $args{o};
4517  ***      0                                         my $q       = $args{q};
4518  ***      0                                         my $db      = $args{db};
4519  ***      0                                         my $dbh     = $args{dbh};
4520  ***      0                                         my @hosts   = @{$args{hosts}};
      ***      0                                      
4521  ***      0                                         my $tbl     = $args{tbl}; 
4522                                                  
4523                                                     # ##################################################################
4524                                                     # This loop may seem suboptimal, because it causes a new child to be
4525                                                     # forked for each table, for each host, for each chunk.  It also
4526                                                     # causes the program to parallelize only within the chunk; that is,
4527                                                     # no two child processes are running on different chunks at a time.
4528                                                     # This is by design. It lets me unlock the table on the master
4529                                                     # between chunks.
4530                                                     # ##################################################################
4531  ***      0                                         my $num_chunks = scalar(@{$tbl->{chunks}});
      ***      0                                      
4532  ***      0                                         MKDEBUG && _d('Checksumming', $num_chunks, 'chunks');
4533                                                     CHUNK:
4534  ***      0                                         foreach my $chunk_num ( 0 .. $num_chunks - 1 ) {
4535                                                  
4536  ***      0      0                                     if ( my $lag_dbh = $args{lag_dbh} ) {
4537  ***      0                                               my $lag = $ms->get_slave_lag($lag_dbh);
4538  ***      0             0                                 while ( !defined $lag || $lag > $final_o->get('max-lag') ) {
4539  ***      0                                                  MKDEBUG && _d('Sleeping: slave lag is', $lag);
4540  ***      0                                                  sleep($o->get('check-interval'));
4541  ***      0                                                  $lag = $ms->get_slave_lag($lag_dbh);
4542                                                           }
4543                                                        }
4544                                                  
4545  ***      0      0      0                              if (    ($num_chunks > 1 || $final_o->get('single-chunk'))
      ***                    0                        
      ***                    0                        
      ***                    0                        
4546                                                             && $checksum_table_data
4547                                                             && defined $final_o->get('probability')
4548                                                             && rand(100) >= $final_o->get('probability') ) {
4549  ***      0                                               MKDEBUG && _d('Skipping chunk because of --probability');
4550  ***      0                                               next CHUNK;
4551                                                        }
4552                                                  
4553  ***      0      0      0                              if (    $num_chunks > 1
      ***                    0                        
      ***                    0                        
4554                                                             && $checksum_table_data
4555                                                             && $final_o->get('modulo')
4556                                                             && ($chunk_num % $final_o->get('modulo') != $final_o->get('offset')))
4557                                                        {
4558  ***      0                                               MKDEBUG && _d('Skipping chunk', $chunk_num, 'because of --modulo');
4559  ***      0                                               next CHUNK;
4560                                                        }
4561                                                  
4562  ***      0                                            my $chunk_start_time = gettimeofday();
4563  ***      0                                            MKDEBUG && _d('Starting chunk', $chunk_num, 'at', $chunk_start_time);
4564                                                  
4565  ***      0      0                                     if ( $final_o->get('replicate') ) {
4566                                                           # We're in --replicate mode.
4567                                                  
4568                                                           # If resuming, check if this db.tbl.chunk.host can be skipped.
4569  ***      0      0                                        if ( $o->get('resume-replicate') ) {
4570  ***      0      0                                           if ( already_checksummed($tbl->{database},
4571                                                                                       $tbl->{table},
4572                                                                                       $chunk_num,
4573                                                                                       $hosts[0]->{h}) ) {
4574  ***      0      0                                              print "# already checksummed:"
4575                                                                    . " $tbl->{database}"
4576                                                                    . " $tbl->{table}"
4577                                                                    . " $chunk_num "
4578                                                                    . $hosts[0]->{h} 
4579                                                                    . "\n"
4580                                                                    unless $o->get('quiet');
4581  ***      0                                                     next CHUNK;
4582                                                              }
4583                                                           }
4584                                                  
4585  ***      0             0                                 $hosts[0]->{dbh} ||= $dbh;
4586                                                  
4587  ***      0                                               do_tbl_replicate(
4588                                                              $chunk_num,
4589                                                              %args,
4590                                                              host => $hosts[0],
4591                                                           );
4592                                                        }
4593                                                        else {
4594                                                           # We're in "normal" mode. Lock table and get position on the master.
4595                                                  
4596  ***      0      0                                        if ( !$final_o->get('explain') ) {
4597  ***      0      0                                           if ( $final_o->get('lock') ) {
4598  ***      0                                                     my $sql = "LOCK TABLES "
4599                                                                         . $q->quote($db, $tbl->{table}) . " READ";
4600  ***      0                                                     MKDEBUG && _d($sql);
4601  ***      0                                                     $dbh->do($sql);
4602                                                              }
4603  ***      0      0                                           if ( $final_o->get('wait') ) {
4604  ***      0                                                     $tbl->{master_status} = $ms->get_master_status($dbh);
4605                                                              }
4606                                                           }
4607                                                  
4608  ***      0                                               my %children;
4609                                                           HOST:
4610  ***      0                                               foreach my $i ( 0 .. $#hosts ) {
4611  ***      0                                                  my $is_master = $i == 0; # First host is assumed to be master.
4612  ***      0                                                  my $host      = $hosts[$i];
4613                                                  
4614                                                              # Open a single connection for each host.  Re-use the
4615                                                              # connection for the master/single host.
4616  ***      0      0                                           if ( $is_master ) {
4617  ***      0                                                     $dbh->{InactiveDestroy} = 1;  # Ensure that this is set.
4618  ***      0             0                                       $host->{dbh} ||= $dbh;
4619                                                              }
4620                                                              else {
4621  ***      0             0                                       $host->{dbh} ||= get_cxn($host, %args);
4622                                                              }
4623                                                  
4624                                                              # If resuming, check if this db.tbl.chunk.host can be skipped.
4625  ***      0      0                                           if ( $final_o->get('resume') ) {
4626  ***      0      0                                              next HOST if already_checksummed($tbl->{database},
4627                                                                                                  $tbl->{table},
4628                                                                                                  $chunk_num,
4629                                                                                                  $host->{h});
4630                                                              }
4631                                                  
4632                                                              # Fork, but only if there's more than one host.
4633  ***      0      0                                           my $pid = @hosts > 1 ? fork() : undef;
4634                                                  
4635  ***      0      0      0                                    if ( @hosts == 1 || (defined($pid) && $pid == 0) ) {
      ***             0      0                        
      ***                    0                        
4636                                                                 # Do the work (I'm a child, or there's only one host)
4637                                                                 
4638  ***      0                                                     eval {
4639  ***      0                                                        do_tbl(
4640                                                                       $chunk_num,
4641                                                                       $is_master,
4642                                                                       %args,
4643                                                                       dbh  => $host->{dbh},
4644                                                                       host => $host,
4645                                                                    );
4646                                                                 };
4647  ***      0      0                                              if ( $EVAL_ERROR ) {
4648  ***      0                                                        print_err($o, $EVAL_ERROR, $db, $tbl->{table},
4649                                                                              $dp->as_string($host));
4650  ***      0      0                                                 exit(1) if @hosts > 1; # exit only if I'm a child
4651                                                                 }
4652                                                                 
4653  ***      0      0                                              exit(0) if @hosts > 1; # exit only if I'm a child
4654                                                              }
4655                                                              elsif ( @hosts > 1 && !defined($pid) ) {
4656  ***      0                                                     die("Unable to fork!");
4657                                                              }
4658                                                              
4659                                                              # I already exited if I'm a child, so I'm the parent.
4660  ***      0      0                                           $children{$host->{h}} = $pid if @hosts > 1;
4661                                                           }
4662                                                  
4663                                                           # Wait for the children to exit.
4664  ***      0                                               foreach my $host ( keys %children ) {
4665  ***      0                                                  my $pid = waitpid($children{$host}, 0);
4666  ***      0                                                  MKDEBUG && _d("Child", $pid, "exited with", $CHILD_ERROR);
4667  ***      0             0                                    $exit_status ||= $CHILD_ERROR >> 8;
4668                                                           }
4669  ***      0      0      0                                 if ( ($final_o->get('lock') && !$final_o->get('explain')) ) {
4670  ***      0                                                  my $sql = "UNLOCK TABLES";
4671  ***      0                                                  MKDEBUG && _d($dbh, $sql);
4672  ***      0                                                  $dbh->do($sql);
4673                                                           }
4674                                                        }
4675                                                  
4676  ***      0                                            my $chunk_stop_time = gettimeofday();
4677  ***      0                                            MKDEBUG && _d('Finished chunk at', $chunk_stop_time);
4678                                                  
4679  ***      0      0      0                              if ( $final_o->get('sleep') && !$final_o->get('explain') ) {
      ***             0      0                        
4680  ***      0                                               MKDEBUG && _d('Sleeping', $final_o->get('sleep'));
4681  ***      0                                               sleep($final_o->get('sleep'));
4682                                                        }
4683                                                        elsif ( $final_o->get('sleep-coef') && !$final_o->get('explain') ) {
4684  ***      0                                               my $sleep_time
4685                                                              = ($chunk_stop_time - $chunk_start_time)
4686                                                              * $final_o->get('sleep-coef');
4687  ***      0                                               MKDEBUG && _d('Sleeping', $sleep_time);
4688  ***      0                                               sleep($sleep_time);
4689                                                        }
4690                                                     } # End foreach CHUNK
4691                                                  
4692  ***      0                                         return;
4693                                                  }
4694                                                  
4695                                                  # Override the command-line arguments with those from --arg-table
4696                                                  # if necessary.  Returns a cloned OptionParser object ($final_o).
4697                                                  # This clone is only a partial OptionParser object.
4698                                                  sub get_final_opts {
4699  ***      0                    0                    my ( %args ) = @_;
4700  ***      0                                         foreach my $arg ( qw(o dbh db tbl args_for) ) {
4701  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4702                                                     }
4703  ***      0                                         my $o        = $args{o};
4704  ***      0                                         my $dbh      = $args{dbh};
4705  ***      0                                         my $db       = $args{db};
4706  ***      0                                         my $tbl      = $args{tbl};
4707  ***      0                                         my $args_for = $args{args_for};
4708                                                  
4709  ***      0                                         my $final_o = $o->clone();
4710  ***      0      0                                  if ( my $override = $args_for->{$db}->{$tbl} ) {
4711  ***      0                                            map { $final_o->set($_, $override->{$_}); } keys %$override;
      ***      0                                      
4712                                                     }
4713                                                  
4714                                                     # --since and --offset are potentially expressions that should be
4715                                                     # evaluated by the DB server. This has to be done after the override
4716                                                     # from the --arg-table table.
4717  ***      0                                         foreach my $opt ( qw(since offset) ) {
4718                                                        # Don't get MySQL to evaluate if it's temporal, as 2008-08-01 --> 1999
4719  ***      0                                            my $val = $final_o->get($opt);
4720  ***      0      0      0                              if ( $val && !is_temporal($val) ) {
4721  ***      0                                               $final_o->set($opt, eval_expr($opt, $val, $dbh));
4722                                                        }
4723                                                     }
4724                                                  
4725  ***      0                                         return $final_o;
4726                                                  }
4727                                                  
4728                                                  sub is_temporal {
4729  ***      0                    0                    my ( $val ) = @_;
4730  ***      0             0                           return $val && $val =~ m/^\d{4}-\d{2}-\d{2}(?:.[0-9:]+)?/;
4731                                                  }
4732                                                  
4733                                                  sub print_inconsistent_tbls {
4734  ***      0                    0                    my ( %args ) = @_;
4735  ***      0                                         foreach my $arg ( qw(o dp dsn tbls) ) {
4736  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4737                                                     }
4738  ***      0                                         my $o      = $args{o};
4739  ***      0                                         my $dp     = $args{dp};
4740  ***      0                                         my $dsn    = $args{dsn};
4741  ***      0                                         my $tbls   = $args{tbls};
4742                                                  
4743  ***      0      0                                  return if $o->get('quiet');
4744                                                  
4745  ***      0                                         my @headers = qw(db tbl chunk cnt_diff crc_diff boundaries);
4746  ***      0                                         print "Differences on " . $dp->as_string($dsn) . "\n";
4747  ***      0                                         my $max_db   = max(5, map { length($_->{db})  } @$tbls);
      ***      0                                      
4748  ***      0                                         my $max_tbl  = max(5, map { length($_->{tbl}) } @$tbls);
      ***      0                                      
4749  ***      0                                         my $fmt      = "%-${max_db}s %-${max_tbl}s %5s %8s %8s %s\n";
4750  ***      0      0                                  printf($fmt, map { uc } @headers) or die "Cannot print: $OS_ERROR";
      ***      0                                      
4751  ***      0                                         foreach my $tbl ( @$tbls ) {
4752  ***      0      0                                     printf($fmt, @{$tbl}{@headers}) or die "Cannot print: $OS_ERROR";
      ***      0                                      
4753                                                     }
4754  ***      0      0                                  print "\n" or die "Cannot print: $OS_ERROR";
4755                                                  
4756  ***      0                                         return;
4757                                                  }
4758                                                  
4759                                                  sub save_inconsistent_tbls {
4760  ***      0                    0                    my ( %args ) = @_;
4761  ***      0                                         foreach my $arg ( qw(dbh tbls) ) {
4762  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4763                                                     }
4764  ***      0                                         my $dbh  = $args{dbh};
4765  ***      0                                         my $tbls = $args{tbls};
4766                                                  
4767  ***      0                                         foreach my $tbl ( @$tbls ) {
4768  ***      0                                            MKDEBUG && _d("Will recheck", $tbl->{db}, '.', $tbl->{tbl},
4769                                                                      "(chunk:", $tbl->{boundaries}, ')');
4770  ***      0                                            my $final_o = get_final_opts(
4771                                                           %args,
4772                                                           db  => $tbl->{db},
4773                                                           tbl => $tbl->{tbl},
4774                                                        );
4775  ***      0                                            my $chunks = [ $tbl->{boundaries} ];
4776  ***      0                                            save_tbl_to_checksum(
4777                                                           %args,
4778                                                           db      => $tbl->{db},
4779                                                           tbl     => $tbl->{tbl},
4780                                                           final_o => $final_o,
4781                                                        );
4782                                                     }
4783  ***      0                                         return;
4784                                                  }
4785                                                  
4786                                                  # The value may be an expression like 'NOW() - INTERVAL 7 DAY'
4787                                                  # and we should evaluate it.
4788                                                  sub eval_expr {
4789  ***      0                    0                    my ( $name, $val, $dbh ) = @_;
4790  ***      0                                         my $result = $val;
4791  ***      0                                         eval {
4792  ***      0                                            ($result) = $dbh->selectrow_array("SELECT $val");
4793  ***      0                                            MKDEBUG && _d("option", $name, "evaluates to:", $result);
4794                                                     };
4795  ***      0      0      0                           if ( $EVAL_ERROR && MKDEBUG ) {
4796  ***      0                                            chomp $EVAL_ERROR;
4797  ***      0                                            _d("Error evaluating option", $name, $EVAL_ERROR);
4798                                                     }
4799  ***      0                                         return $result;
4800                                                  }
4801                                                  
4802                                                  sub determine_checksum_strat {
4803  ***      0                    0                    my ( %args ) = @_;
4804  ***      0                                         foreach my $arg ( qw(o dbh tc) ) {
4805  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4806                                                     }
4807  ***      0                                         my $o   = $args{o};
4808  ***      0                                         my $dbh = $args{dbh};
4809  ***      0                                         my $tc  = $args{tc};
4810                                                  
4811  ***      0                                         my $ret = {  # return vals in easy-to-swallow hash form
4812                                                        strat      => undef,
4813                                                        crc_type   => 'varchar',
4814                                                        crc_wid    => 16,
4815                                                        func       => undef,
4816                                                        opt_slice  => undef,
4817                                                     };
4818                                                  
4819  ***      0             0                           $ret->{strat} = $tc->best_algorithm(
4820                                                        algorithm   => $o->get('algorithm'),
4821                                                        dbh         => $dbh,
4822                                                        where       => $o->get('where') || $o->get('since'),
4823                                                        chunk       => $o->get('chunk-size'),
4824                                                        replicate   => $o->get('replicate'),
4825                                                        count       => $o->get('count'),
4826                                                     );
4827                                                  
4828  ***      0      0      0                           if ( $o->get('algorithm') && $o->get('algorithm') ne $ret->{strat} ) {
4829  ***      0                                            warn "--algorithm=".$o->get('algorithm')." can't be used; "
4830                                                           . "falling back to $ret->{strat}\n";
4831                                                     }
4832                                                  
4833                                                     # If using a cryptographic hash strategy, decide what hash function to use,
4834                                                     # and if using BIT_XOR whether and which slice to place the user variable in.
4835  ***      0      0                                  if ( $tc->is_hash_algorithm( $ret->{strat} ) ) {
4836  ***      0                                            $ret->{func} = $tc->choose_hash_func(
4837                                                           function => $o->get('function'),
4838                                                           dbh      => $dbh,
4839                                                        );
4840  ***      0      0      0                              if ( $o->get('function') && $o->get('function') ne $ret->{func} ) {
4841  ***      0                                               warn "Checksum function ".$o->get('function')." cannot be used; "
4842                                                              . "using $ret->{func}\n";
4843                                                        }
4844  ***      0                                            $ret->{crc_wid}    = $tc->get_crc_wid($dbh, $ret->{func});
4845  ***      0                                            ($ret->{crc_type}) = $tc->get_crc_type($dbh, $ret->{func});
4846                                                  
4847  ***      0      0      0                              if ( $o->get('optimize-xor') && $ret->{strat} eq 'BIT_XOR' ) {
4848  ***      0      0                                        if ( $ret->{crc_type} !~ m/int$/ ) {
4849  ***      0                                                  $ret->{opt_slice}
4850                                                                 = $tc->optimize_xor(dbh => $dbh, function => $ret->{func});
4851  ***      0      0                                           if ( !defined $ret->{opt_slice} ) {
4852  ***      0                                                     warn "Cannot use --optimize-xor, disabling";
4853  ***      0                                                     $o->set('optimize-xor', 0);
4854                                                              }
4855                                                           }
4856                                                           else {
4857                                                              # FNV_64 doesn't need the optimize_xor gizmo.
4858  ***      0                                                  $o->get('optimize-xor', 0);
4859                                                           }
4860                                                        }
4861                                                     }
4862                                                  
4863  ***      0                                         return $ret;
4864                                                  }
4865                                                  
4866                                                  sub verify_checksum_compat {
4867  ***      0                    0                    my ( %args ) = @_;
4868  ***      0                                         foreach my $arg ( qw(o hosts) ) {
4869  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4870                                                     }
4871  ***      0                                         my $o     = $args{o};
4872  ***      0                                         my $hosts = $args{hosts};
4873                                                  
4874  ***      0                                         my @verify_sums;
4875  ***      0                                         foreach my $host ( @$hosts ) {
4876  ***      0                                            my $dbh = get_cxn($host, %args);
4877  ***      0                                            my $sql = "SELECT MD5(CONCAT_WS(',', '1', ''))";
4878  ***      0                                            MKDEBUG && _d($dbh, $sql);
4879  ***      0                                            my $cks = $dbh->selectall_arrayref($sql)->[0]->[0];
4880  ***      0                                            push @verify_sums, {
4881                                                           host => $host->{h},
4882                                                           ver  => $dbh->{mysql_serverinfo},
4883                                                           sum  => $cks,
4884                                                        };
4885                                                     }
4886  ***      0      0                                  if ( unique(map { $_->{sum} } @verify_sums ) > 1 ) {
      ***      0                                      
4887  ***      0                                            my $max = max(map { length($_->{h}) } @$hosts);
      ***      0                                      
4888  ***      0                                            die "Not all servers have compatible versions.  Some return different\n"
4889                                                           . "checksum values for the same query, and cannot be compared.  This\n"
4890                                                           . "behavior changed in MySQL 4.0.14.  Here is info on each host:\n\n"
4891                                                           . join("\n",
4892  ***      0                                                    map { sprintf("%-${max}s %-32s %s", @{$_}{qw(host sum ver)}) }
      ***      0                                      
4893                                                                   { host => 'HOST', sum => 'CHECKSUM', ver => 'VERSION'},
4894                                                                @verify_sums
4895                                                             )
4896                                                           . "\n\nYou can disable this check with --no-verify.\n";
4897                                                     }
4898  ***      0                                         return;
4899                                                  }
4900                                                  
4901                                                  # Check for existence and privileges on the replication table before
4902                                                  # starting, and prepare the statements that will be used to update it.
4903                                                  # Also clean out the checksum table.  And create it if needed.
4904                                                  # Returns fetch and update statement handles.
4905                                                  sub check_repl_table {
4906  ***      0                    0                    my ( %args ) = @_;
4907  ***      0                                         foreach my $arg ( qw(o dbh tp q) ) {
4908  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4909                                                     }
4910  ***      0                                         my $o   = $args{o};
4911  ***      0                                         my $dbh = $args{dbh};
4912  ***      0                                         my $tp  = $args{tp};
4913  ***      0                                         my $q   = $args{q};
4914                                                  
4915  ***      0                                         my $replicate_table = $o->get('replicate');
4916  ***      0      0                                  return unless $replicate_table;
4917                                                  
4918                                                     # Check that the replicate table exists and that we can access it.
4919  ***      0                                         my ($db, $tbl) = $q->split_unquote($replicate_table);
4920  ***      0                                         my $tbl_exists = $tp->check_table(
4921                                                        dbh => $dbh,
4922                                                        db  => $db,
4923                                                        tbl => $tbl,
4924                                                     );
4925                                                  
4926  ***      0      0                                  if ( !$tbl_exists ) {
4927  ***      0      0                                     if ( $o->get('create-replicate-table') ) {
4928  ***      0      0                                        create_repl_table(%args)
4929                                                              or die "--create-replicate-table failed to create "
4930                                                                 . $replicate_table;
4931                                                        }
4932                                                        else {
4933  ***      0                                               die  "--replicate table $replicate_table does not exist; "
4934                                                              . "read the documentation or use --create-replicate-table "
4935                                                              . "to create it.";
4936                                                        }
4937                                                     }
4938                                                     else {
4939  ***      0                                            MKDEBUG && _d('--replicate table', $replicate_table, 'already exists');
4940                                                        # Check it again but this time check the privs.
4941  ***      0                                            my $have_tbl_privs = $tp->check_table(
4942                                                           dbh       => $dbh,
4943                                                           db        => $db,
4944                                                           tbl       => $tbl,
4945                                                           all_privs => 1,
4946                                                        );
4947  ***      0      0                                     die "User does not have all necessary privileges on $replicate_table"
4948                                                           unless $have_tbl_privs;
4949                                                     }
4950                                                  
4951                                                     # Clean out the replicate table globally.
4952  ***      0      0                                  if ( $o->get('empty-replicate-table') ) {
4953  ***      0                                            my $del_sql = "DELETE FROM $replicate_table";
4954  ***      0                                            MKDEBUG && _d($dbh, $del_sql);
4955  ***      0                                            $dbh->do($del_sql);
4956                                                     }
4957                                                  
4958  ***      0                                         my $fetch_sth = $dbh->prepare(
4959                                                        "SELECT this_crc, this_cnt FROM $replicate_table "
4960                                                        . "WHERE db = ? AND tbl = ? AND chunk = ?");
4961  ***      0                                         my $update_sth = $dbh->prepare(
4962                                                        "UPDATE $replicate_table SET master_crc = ?, master_cnt = ? "
4963                                                        . "WHERE db = ? AND tbl = ? AND chunk = ?");
4964                                                  
4965  ***      0                                         return ($fetch_sth, $update_sth);
4966                                                  }
4967                                                  
4968                                                  # Returns 1 on successful creation of the replicate table,
4969                                                  # or 0 on failure.
4970                                                  sub create_repl_table {
4971  ***      0                    0                    my ( %args ) = @_;
4972  ***      0                                         foreach my $arg ( qw(o dbh) ) {
4973  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4974                                                     }
4975  ***      0                                         my $o   = $args{o};
4976  ***      0                                         my $dbh = $args{dbh};
4977                                                  
4978  ***      0                                         my $replicate_table = $o->get('replicate');
4979                                                  
4980  ***      0                                         my $sql = $o->read_para_after(
4981                                                        __FILE__, qr/MAGIC_create_replicate/);
4982  ***      0                                         $sql =~ s/CREATE TABLE checksum/CREATE TABLE $replicate_table/;
4983  ***      0                                         $sql =~ s/;$//;
4984  ***      0                                         MKDEBUG && _d($dbh, $sql);
4985  ***      0                                         eval {
4986  ***      0                                            $dbh->do($sql);
4987                                                     };
4988  ***      0      0                                  if ( $EVAL_ERROR ) {
4989  ***      0                                            MKDEBUG && _d('--create-replicate-table failed:', $EVAL_ERROR);
4990  ***      0                                            return 0;
4991                                                     }
4992                                                  
4993  ***      0                                         return 1;
4994                                                  }
4995                                                  
4996                                                  sub read_repl_table {
4997  ***      0                    0                    my ( %args ) = @_;
4998  ***      0                                         foreach my $arg ( qw(o dbh host) ) {
4999  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5000                                                     }
5001  ***      0                                         my $o    = $args{o};
5002  ***      0                                         my $dbh  = $args{dbh};
5003  ***      0                                         my $host = $args{host};
5004                                                  
5005  ***      0                                         my $replicate_table = $o->get('replicate');
5006  ***      0      0                                  die "Cannot read replicate table because --replicate was not specified"
5007                                                        unless $replicate_table;
5008                                                  
5009                                                     # Read checksums from replicate table.
5010  ***      0                                         my $already_checksummed;
5011  ***      0                                         my $checksums
5012                                                        = $dbh->selectall_arrayref("SELECT db, tbl, chunk FROM $replicate_table");
5013                                                  
5014                                                     # Save each finished checksum.
5015  ***      0                                         foreach my $checksum ( @$checksums ) {
5016  ***      0                                            my ( $db, $tbl, $chunk ) = @$checksum[0..2];
5017  ***      0                                            $already_checksummed->{$db}->{$tbl}->{$chunk}->{$host} = 1;
5018                                                     }
5019                                                  
5020  ***      0                                         return $already_checksummed;
5021                                                  }
5022                                                  
5023                                                  sub parse_resume_file {
5024  ***      0                    0                    my ( $resume_file ) = @_;
5025                                                  
5026  ***      0      0                                  open my $resume_fh, '<', $resume_file
5027                                                        or die "Cannot open resume file $resume_file: $OS_ERROR";
5028                                                  
5029                                                     # The resume file, being the output from a previous run, should
5030                                                     # have the columns DATABASE TABLE CHUNK HOST ... (in that order).
5031                                                     # We only need those first 4 columns. We re-print every line of
5032                                                     # the resume file so the end result will be the whole, finished
5033                                                     # output: what the previous run got done plus what we are about
5034                                                     # to resume and finish.
5035  ***      0                                         my $already_checksummed;
5036  ***      0                                         while ( my $line = <$resume_fh> ) {
5037                                                        # Re-print every line.
5038  ***      0                                            print $line;
5039                                                  
5040                                                        # If the line is a checksum line, parse from it the db, tbl,
5041                                                        # checksum and host.
5042  ***      0      0                                     if ( $line =~ m/^\S+\s+\S+\s+\d+\s+/ ) {
5043  ***      0                                               my ( $db, $tbl, $chunk, $host ) = $line =~ m/(\S+)/g;
5044  ***      0                                               $already_checksummed->{$db}->{$tbl}->{$chunk}->{$host} = 1;
5045                                                        }
5046                                                     }
5047                                                  
5048  ***      0                                         close $resume_fh;
5049  ***      0                                         MKDEBUG && _d("Already checksummed:", Dumper($already_checksummed));
5050                                                  
5051  ***      0                                         return $already_checksummed;
5052                                                  }
5053                                                  
5054                                                  sub already_checksummed {
5055  ***      0                    0                    my ( $d, $t, $c, $h ) = @_; # db, tbl, chunk num, host
5056  ***      0      0                                  if ( exists $already_checksummed->{$d}->{$t}->{$c}->{$h} ) {
5057  ***      0                                            MKDEBUG && _d("Skipping chunk because of --resume:", $d, $t, $c, $h);
5058  ***      0                                            return 1;
5059                                                     }
5060  ***      0                                         return 0;
5061                                                  }
5062                                                  
5063                                                  sub do_tbl_replicate {
5064  ***      0                    0                    my ( $chunk_num, %args ) = @_;
5065  ***      0                                         foreach my $arg ( qw(q host query tbl hdr explain final_o ch) ) {
5066  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5067                                                     }
5068  ***      0                                         my $ch      = $args{ch};
5069  ***      0                                         my $final_o = $args{final_o};
5070  ***      0                                         my $q       = $args{q};
5071  ***      0                                         my $host    = $args{host};
5072  ***      0                                         my $hdr     = $args{hdr};
5073  ***      0                                         my $explain = $args{explain};
5074  ***      0                                         my $tbl     = $args{tbl};
5075                                                  
5076  ***      0                                         MKDEBUG && _d('Replicating chunk', $chunk_num,
5077                                                        'of table', $tbl->{database}, '.', $tbl->{table},
5078                                                        'on', $host->{h}, ':', $host->{P});
5079                                                  
5080  ***      0                                         my $dbh = $host->{dbh};
5081  ***      0                                         $dbh->do("USE " . $q->quote($tbl->{database}));
5082                                                  
5083  ***      0                                         my $cnt = 'NULL';
5084  ***      0                                         my $crc = 'NULL';
5085  ***      0                                         my $beg = time();
5086  ***      0                                         my $sql = $ch->inject_chunks(
5087                                                        query      => $args{query},
5088                                                        database   => $tbl->{database},
5089                                                        table      => $tbl->{table},
5090                                                        chunks     => $tbl->{chunks},
5091                                                        chunk_num  => $chunk_num,
5092                                                        where      => [$final_o->get('where'), $tbl->{since}],
5093                                                        index_hint => $tbl->{index},
5094                                                     );
5095                                                  
5096  ***      0                                         if ( MKDEBUG && $chunk_num == 0 ) {
5097                                                        _d("SQL for inject chunk 0:", $sql);
5098                                                     }
5099                                                  
5100  ***      0                                         my $where = $tbl->{chunks}->[$chunk_num];
5101  ***      0      0                                  if ( $final_o->get('explain') ) {
5102  ***      0      0                                     if ( $chunk_num == 0 ) {
5103  ***      0      0                                        printf($explain, @{$tbl}{qw(database table)}, $sql)
      ***      0                                      
5104                                                              or die "Cannot print: $OS_ERROR";
5105                                                        }
5106  ***      0      0                                     printf($explain, @{$tbl}{qw(database table)}, $where)
      ***      0                                      
5107                                                           or die "Cannot print: $OS_ERROR";
5108  ***      0                                            return;
5109                                                     }
5110                                                  
5111                                                     # Actually run the checksum query
5112  ***      0                                         $dbh->do('SET @crc := "", @cnt := 0 /*!50108 , '
5113                                                            . '@@binlog_format := "STATEMENT"*/');
5114  ***      0                                         $dbh->do($sql, {}, @{$tbl}{qw(database table)}, $where);
      ***      0                                      
5115                                                  
5116                                                     # Catch any warnings thrown....
5117  ***      0                                         $sql = 'SHOW WARNINGS';
5118  ***      0                                         MKDEBUG && _d($sql);
5119  ***      0                                         my $warnings = $dbh->selectall_arrayref($sql, { Slice => {} } );
5120  ***      0                                         foreach my $warning ( @$warnings ) {
5121  ***      0      0                                     if ( $warning->{Message} =~ m/Data truncated for column 'boundaries'/ ) {
5122  ***      0                                               _d("Warning: WHERE clause too large for boundaries column; ",
5123                                                              "mk-table-sync may fail; value:", $where);
5124                                                        }
5125                                                        else {
5126  ***      0                                               die Dumper($warning);
5127                                                        }
5128                                                     }
5129                                                  
5130                                                     # Update the master_crc etc columns
5131  ***      0                                         $fetch_sth->execute(@{$tbl}{qw(database table)}, $chunk_num);
      ***      0                                      
5132  ***      0                                         ( $crc, $cnt ) = $fetch_sth->fetchrow_array();
5133  ***      0                                         $update_sth->execute($crc, $cnt, @{$tbl}{qw(database table)}, $chunk_num);
      ***      0                                      
5134                                                  
5135  ***      0                                         my $end = time();
5136  ***      0             0                           $crc  ||= 'NULL';
5137  ***      0      0      0                           if ( !$final_o->get('quiet') && !$final_o->get('explain') ) {
5138  ***      0      0                                     if ( $final_o->get('checksum') ) {
5139  ***      0                                               printf($md5sum_fmt, $crc, $host->{h},
5140  ***      0      0                                           @{$tbl}{qw(database table)}, $chunk_num)
5141                                                              or die "Cannot print: $OS_ERROR";
5142                                                        }
5143                                                        else {
5144  ***      0                                               printf($hdr,
5145  ***      0      0                                           @{$tbl}{qw(database table)}, $chunk_num,
5146                                                              $host->{h}, $tbl->{struct}->{engine}, $cnt, $crc,
5147                                                              $end - $beg, 'NULL', 'NULL', 'NULL')
5148                                                                 or die "Cannot print: $OS_ERROR";
5149                                                        }
5150                                                     }
5151                                                  
5152  ***      0                                         return;
5153                                                  }
5154                                                  
5155                                                  sub do_tbl {
5156  ***      0                    0                    my ( $chunk_num, $is_master, %args ) = @_;
5157  ***      0                                         foreach my $arg ( qw(du final_o ms q tc dbh host tbl hdr explain strat) ) {
5158  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5159                                                     }
5160  ***      0                                         my $du      = $args{du};
5161  ***      0                                         my $final_o = $args{final_o};
5162  ***      0                                         my $ms      = $args{ms};
5163  ***      0                                         my $tc      = $args{tc};
5164  ***      0                                         my $tp      = $args{tp};
5165  ***      0                                         my $q       = $args{q};
5166  ***      0                                         my $host    = $args{host};
5167  ***      0                                         my $tbl     = $args{tbl};
5168  ***      0                                         my $explain = $args{explain};
5169  ***      0                                         my $hdr     = $args{hdr};
5170  ***      0                                         my $strat   = $args{strat};
5171                                                  
5172  ***      0                                         MKDEBUG && _d('Checksumming chunk', $chunk_num,
5173                                                        'of table', $tbl->{database}, '.', $tbl->{table},
5174                                                        'on', $host->{h}, ':', $host->{P},
5175                                                        'using algorithm', $strat);
5176                                                  
5177  ***      0                                         my $dbh = $host->{dbh};
5178  ***      0                                         $dbh->do("USE " . $q->quote($tbl->{database}));
5179                                                  
5180  ***      0                                         my $cnt = 'NULL';
5181  ***      0                                         my $crc = 'NULL';
5182  ***      0                                         my $sta = 'NULL';
5183  ***      0                                         my $lag = 'NULL';
5184  ***      0                                         my $beg = time();
5185                                                  
5186                                                     # I'm a slave.  Wait to catch up to the master.  Calculate slave lag.
5187  ***      0      0      0                           if ( !$is_master
      ***                    0                        
5188                                                          && $final_o->get('wait')
5189                                                          && !$final_o->get('explain') )
5190                                                     {
5191  ***      0                                            MKDEBUG && _d('Waiting to catch up to master', $args{dbh}->{h},
5192                                                           ':', $args{dbh}->{P});
5193  ***      0                                            $sta = $ms->wait_for_master(
5194                                                           $args{dbh}, $dbh, $final_o->get('wait'), 1, $tbl->{master_status});
5195  ***      0      0                                     $sta = 'NULL' unless defined $sta;
5196                                                     }
5197  ***      0      0      0                           if ( !$is_master
      ***                    0                        
5198                                                          && $final_o->get('slave-lag')
5199                                                          && !$final_o->get('explain') )
5200                                                     {
5201  ***      0                                            my $res = $ms->get_slave_status($dbh);
5202  ***      0      0      0                              $lag = $res && defined $res->{seconds_behind_master}
5203                                                             ? $res->{seconds_behind_master}
5204                                                             : 'NULL';
5205                                                     }
5206                                                  
5207                                                     # Check that table exists on slave.
5208  ***      0                                         my $have_table = 1;
5209  ***      0      0      0                           if ( !$is_master || !$checksum_table_data ) {
5210  ***      0                                            $have_table = $tp->check_table(
5211                                                           dbh => $dbh,
5212                                                           db  => $tbl->{database},
5213                                                           tbl => $tbl->{table},
5214                                                        );
5215  ***      0      0                                     warn "$tbl->{database}.$tbl->{table} does not exist on slave"
      ***             0                               
      ***             0                               
5216                                                           . ($host->{h} ? " $host->{h}" : '')
5217                                                           . ($host->{P} ? ":$host->{P}" : '')
5218                                                           unless $have_table;
5219                                                     }
5220                                                  
5221                                                     # Time the checksum operation and the wait-for-master operation separately.
5222  ***      0                                         my $mid = time();
5223                                                  
5224  ***      0      0                                  if ( $have_table ) {
5225                                                        # Do the checksum operation.
5226  ***      0      0                                     if ( $checksum_table_data ) {
5227  ***      0      0                                        if ( $strat eq 'CHECKSUM' ) {
      ***             0                               
5228  ***      0      0                                           if ( $final_o->get('crc') ) {
5229  ***      0                                                     $crc = do_checksum(%args);
5230                                                              }
5231  ***      0      0                                           if ( $final_o->get('count') ) {
5232  ***      0                                                     $cnt = do_count($chunk_num, %args);
5233                                                              }
5234                                                           }
5235                                                           elsif ( $final_o->get('crc') ) {
5236  ***      0                                                  ( $cnt, $crc ) = do_var_crc($chunk_num, %args);
5237  ***      0             0                                    $crc ||= 'NULL';
5238                                                           }
5239                                                           else {
5240  ***      0                                                  $cnt = do_count($chunk_num, %args);
5241                                                           }
5242                                                        }
5243                                                        else { # Checksum SHOW CREATE TABLE for --schema.
5244  ***      0                                               my $create
5245                                                              = $du->get_create_table($dbh, $q, $tbl->{database}, $tbl->{table});
5246  ***      0                                               $create = $create->[1];
5247  ***      0                                               $create = $tp->remove_auto_increment($create);
5248  ***      0                                               $crc    = $tc->crc32($create);
5249                                                        }
5250                                                     }
5251                                                  
5252  ***      0                                         my $end = time();
5253                                                  
5254  ***      0      0      0                           if ( !$final_o->get('quiet') && !$final_o->get('explain') ) {
5255  ***      0      0                                     if ( $final_o->get('checksum') ) {
5256  ***      0                                               printf($md5sum_fmt, $crc, $host->{h},
5257  ***      0      0                                           @{$tbl}{qw(database table)}, $chunk_num)
5258                                                              or die "Cannot print: $OS_ERROR";
5259                                                        }
5260                                                        else {
5261  ***      0                                               printf($hdr,
5262  ***      0      0                                           @{$tbl}{qw(database table)}, $chunk_num,
5263                                                              $host->{h}, $tbl->{struct}->{engine}, $cnt, $crc,
5264                                                              $end - $mid, $mid - $beg, $sta, $lag)
5265                                                              or die "Cannot print: $OS_ERROR";
5266                                                        }
5267                                                     }
5268                                                  
5269  ***      0                                         return;
5270                                                  }
5271                                                  
5272                                                  sub get_cxn {
5273  ***      0                    0                    my ( $dsn, %args ) = @_;
5274  ***      0                                         foreach my $arg ( qw(o dp) ) {
5275  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5276                                                     }
5277  ***      0                                         my $dp  = $args{dp};
5278  ***      0                                         my $o   = $args{o};
5279                                                  
5280  ***      0      0      0                           if ( $o->get('ask-pass') && !defined $dsn->{p} ) {
5281  ***      0                                            $dsn->{p} = OptionParser::prompt_noecho("Enter password for $dsn->{h}: ");
5282                                                     }
5283                                                  
5284  ***      0      0                                  my $ac  = $o->get('lock') ? 0 : 1;
5285  ***      0                                         my $dbh = $dp->get_dbh(
5286                                                        $dp->get_cxn_params($dsn), { AutoCommit => $ac });
5287  ***      0                                         $dbh->{InactiveDestroy} = 1; # Prevent destroying on fork.
5288  ***      0                                         return $dbh;
5289                                                  }
5290                                                  
5291                                                  sub do_var_crc {
5292  ***      0                    0                    my ( $chunk_num, %args ) = @_;
5293  ***      0                                         foreach my $arg ( qw(ch dbh query tbl explain final_o) ) {
5294  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5295                                                     }
5296  ***      0                                         my $final_o = $args{final_o};
5297  ***      0                                         my $ch      = $args{ch};
5298  ***      0                                         my $tbl     = $args{tbl};
5299  ***      0                                         my $explain = $args{explain};
5300  ***      0                                         my $dbh     = $args{dbh};
5301                                                  
5302  ***      0                                         MKDEBUG && _d("do_var_crc for", $tbl->{table});
5303                                                  
5304  ***      0                                         my $sql = $ch->inject_chunks(
5305                                                        query      => $args{query},
5306                                                        database   => $tbl->{database},
5307                                                        table      => $tbl->{table},
5308                                                        chunks     => $tbl->{chunks},
5309                                                        chunk_num  => $chunk_num,
5310                                                        where      => [$final_o->get('where'), $tbl->{since}],
5311                                                        index_hint => $tbl->{index},
5312                                                     );
5313                                                  
5314  ***      0                                         if ( MKDEBUG && $chunk_num == 0 ) {
5315                                                        _d("SQL for chunk 0:", $sql);
5316                                                     }
5317                                                  
5318  ***      0      0                                  if ( $final_o->get('explain') ) {
5319  ***      0      0                                     if ( $chunk_num == 0 ) {
5320  ***      0      0                                        printf($explain, @{$tbl}{qw(database table)}, $sql)
      ***      0                                      
5321                                                              or die "Cannot print: $OS_ERROR";
5322                                                        }
5323  ***      0      0                                     printf($explain, @{$tbl}{qw(database table)},$tbl->{chunks}->[$chunk_num])
      ***      0                                      
5324                                                           or die "Cannot print: $OS_ERROR";
5325  ***      0                                            return;
5326                                                     }
5327                                                  
5328  ***      0                                         $dbh->do('set @crc := "", @cnt := 0');
5329  ***      0                                         my $res = $dbh->selectall_arrayref($sql, { Slice => {} })->[0];
5330  ***      0                                         return ($res->{cnt}, $res->{crc});
5331                                                  }
5332                                                  
5333                                                  sub do_checksum {
5334  ***      0                    0                    my ( %args ) = @_;
5335  ***      0                                         foreach my $arg ( qw(dbh query tbl explain final_o) ) {
5336  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5337                                                     }
5338  ***      0                                         my $dbh     = $args{dbh};
5339  ***      0                                         my $final_o = $args{final_o};
5340  ***      0                                         my $tbl     = $args{tbl};
5341  ***      0                                         my $query   = $args{query};
5342  ***      0                                         my $explain = $args{explain};
5343                                                  
5344  ***      0                                         MKDEBUG && _d("do_checksum for", $tbl->{table});
5345                                                  
5346  ***      0      0                                  if ( $final_o->get('explain') ) {
5347  ***      0      0                                     printf($explain, @{$tbl}{qw(database table)}, $query)
      ***      0                                      
5348                                                           or die "Cannot print: $OS_ERROR";
5349                                                     }
5350                                                     else {
5351  ***      0                                            my $res = $dbh->selectrow_hashref($query);
5352  ***      0      0                                     if ( $res ) {
5353  ***      0                                               my ($key) = grep { m/checksum/i } keys %$res;
      ***      0                                      
5354  ***      0      0                                        return defined $res->{$key} ? $res->{$key} : 'NULL';
5355                                                        }
5356                                                     }
5357                                                  
5358  ***      0                                         return;
5359                                                  }
5360                                                  
5361                                                  sub do_count {
5362  ***      0                    0                    my ( $chunk_num, %args ) = @_;
5363  ***      0                                         foreach my $arg ( qw(q dbh tbl explain final_o) ) {
5364  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5365                                                     }
5366  ***      0                                         my $final_o = $args{final_o};
5367  ***      0                                         my $tbl     = $args{tbl};
5368  ***      0                                         my $explain = $args{explain};
5369  ***      0                                         my $dbh     = $args{dbh};
5370  ***      0                                         my $q       = $args{q};
5371                                                  
5372  ***      0                                         MKDEBUG && _d("do_count for", $tbl->{table});
5373                                                  
5374  ***      0                                         my $sql = "SELECT COUNT(*) FROM "
5375  ***      0                                            . $q->quote(@{$tbl}{qw(database table)});
5376  ***      0      0      0                           if ( $final_o->get('where') || $final_o->get('since') ) {
5377  ***      0                                            my $where_since = ($final_o->get('where'), $final_o->get('since'));
5378  ***      0                                            $sql .= " WHERE ("
5379  ***      0                                                  . join(" AND ", map { "($_)" } grep { $_ } @$where_since )
      ***      0                                      
5380                                                              . ")";
5381                                                     }
5382  ***      0      0                                  if ( $final_o->get('explain') ) {
5383  ***      0      0                                     printf($explain, @{$tbl}{qw(database table)}, $sql)
      ***      0                                      
5384                                                           or die "Cannot print: $OS_ERROR";
5385                                                     }
5386                                                     else {
5387  ***      0                                            return $dbh->selectall_arrayref($sql)->[0]->[0];
5388                                                     }
5389                                                  
5390  ***      0                                         return;
5391                                                  }
5392                                                  
5393                                                  sub unique {
5394  ***      0                    0                    my %seen;
5395  ***      0                                         grep { !$seen{$_}++ } @_;
      ***      0                                      
5396                                                  }
5397                                                  
5398                                                  # Tries to extract the MySQL error message and print it
5399                                                  sub print_err {
5400  ***      0                    0                    my ( $o, $msg, $db, $tbl, $host ) = @_;
5401  ***      0      0      0                           return if !defined $msg
      ***                    0                        
5402                                                        # Honor --quiet in the (common?) event of dropped tables or deadlocks
5403                                                        or ($o->get('quiet')
5404                                                           && $EVAL_ERROR =~ m/: Table .*? doesn't exist|Deadlock found/);
5405  ***      0                                         $msg =~ s/^.*?failed: (.*?) at \S+ line (\d+).*$/$1 at line $2/s;
5406  ***      0                                         $msg =~ s/\s+/ /g;
5407  ***      0      0      0                           if ( $db && $tbl ) {
5408  ***      0                                            $msg .= " while doing $db.$tbl";
5409                                                     }
5410  ***      0      0                                  if ( $host ) {
5411  ***      0                                            $msg .= " on $host";
5412                                                     }
5413  ***      0                                         print STDERR $msg, "\n";
5414                                                  }
5415                                                  
5416                                                  sub _d {
5417  ***      0                    0                    my ($package, undef, $line) = caller 0;
5418  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
5419  ***      0                                              map { defined $_ ? $_ : 'undef' }
5420                                                          @_;
5421  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5422                                                  }
5423                                                  
5424                                                  # ############################################################################
5425                                                  # Run the program.
5426                                                  # ############################################################################
5427                                                  if ( !caller ) { exit main(@ARGV); }
5428                                                  
5429                                                  1; # Because this is a module as well as a script.
5430                                                  
5431                                                  # ############################################################################
5432                                                  # Documentation
5433                                                  # ############################################################################
5434                                                  =pod
5435                                                  
5436                                                  =head1 NAME
5437                                                  
5438                                                  mk-table-checksum - Perform an online replication consistency check, or
5439                                                  checksum MySQL tables efficiently on one or many servers.
5440                                                  
5441                                                  =head1 SYNOPSIS
5442                                                  
5443                                                  STOP! Are you checksumming a slave(s) against its master?  Then be sure to learn
5444                                                  what L<"--replicate"> does.  It is probably the option you want to use.
5445                                                  
5446                                                     mk-table-checksum --replicate=mydb.checksum master-host
5447                                                     ... time passses, replication catches up ...
5448                                                     mk-table-checksum --replicate=mydb.checksum --replicate-check 2 master-host
5449                                                  
5450                                                  Or,
5451                                                  
5452                                                     mk-table-checksum h=host1,u=user,p=password h=host2 ...
5453                                                  
5454                                                  Or,
5455                                                  
5456                                                     mk-table-checksum host1 host2 ... hostN | mk-checksum-filter
5457                                                  
5458                                                  See L<"SPECIFYING HOSTS"> for more on the syntax of the host arguments.
5459                                                  
5460                                                  =head1 RISKS
5461                                                  
5462                                                  The following section is included to inform users about the potential risks,
5463                                                  whether known or unknown, of using this tool.  The two main categories of risks
5464                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
5465                                                  tools) and those created by bugs.
5466                                                  
5467                                                  mk-table-checksum executes queries that cause the MySQL server to checksum its
5468                                                  data.  This can cause significant server load.  It is read-only unless you use
5469                                                  the L<"--replicate"> option, in which case it inserts a small amount of data
5470                                                  into the specified table.
5471                                                  
5472                                                  At the time of this release, we know of no bugs that could cause serious harm to
5473                                                  users.  There are miscellaneous bugs that might be annoying.
5474                                                  
5475                                                  The authoritative source for updated information is always the online issue
5476                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
5477                                                  see a list of such issues at the following URL:
5478                                                  L<http://www.maatkit.org/bugs/mk-table-checksum>.
5479                                                  
5480                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
5481                                                  
5482                                                  =head1 DESCRIPTION
5483                                                  
5484                                                  mk-table-checksum generates table checksums for MySQL tables, typically
5485                                                  useful for verifying your slaves are in sync with the master.  The checksums
5486                                                  are generated by a query on the server, and there is very little network
5487                                                  traffic as a result.
5488                                                  
5489                                                  Checksums typically take about twice as long as COUNT(*) on very large InnoDB
5490                                                  tables in my tests.  For smaller tables, COUNT(*) is a good bit faster than
5491                                                  the checksums.  See L<"--algorithm"> for more details on performance.
5492                                                  
5493                                                  If you specify more than one server, mk-table-checksum assumes the first
5494                                                  server is the master and others are slaves.  Checksums are parallelized for
5495                                                  speed, forking off a child process for each table.  Duplicate server names are
5496                                                  ignored, but if you want to checksum a server against itself you can use two
5497                                                  different forms of the hostname (for example, "localhost 127.0.0.1", or
5498                                                  "h=localhost,P=3306 h=localhost,P=3307").
5499                                                  
5500                                                  If you want to compare the tables in one database to those in another database
5501                                                  on the same server, just checksum both databases:
5502                                                  
5503                                                     mk-table-checksum --databases db1,db2
5504                                                  
5505                                                  You can then use L<mk-checksum-filter> to compare the results in both databases
5506                                                  easily.
5507                                                  
5508                                                  mk-table-checksum examines table structure only on the first host specified,
5509                                                  so if anything differs on the others, it won't notice.  It ignores views.
5510                                                  
5511                                                  The checksums work on MySQL version 3.23.58 through 6.0-alpha.  They will not
5512                                                  necessarily produce the same values on all versions.  Differences in
5513                                                  formatting and/or space-padding between 4.1 and 5.0, for example, will cause
5514                                                  the checksums to be different.
5515                                                  
5516                                                  =head1 SPECIFYING HOSTS
5517                                                  
5518                                                  mk-table-checksum connects to a theoretically unlimited number of MySQL
5519                                                  servers.  You specify a list of one or more host definitions on the command
5520                                                  line, such as "host1 host2".  Each host definition can be just a hostname, or it
5521                                                  can be a complex string that specifies connection options as well.  You can
5522                                                  specify connection options two ways:
5523                                                  
5524                                                  =over
5525                                                  
5526                                                  =item *
5527                                                  
5528                                                  Format a host definition in a key=value,key=value form.  If an argument on the
5529                                                  command line contains the letter '=', mk-table-checksum will parse it into
5530                                                  its component parts.  Examine the L<"--help"> output for details on the allowed
5531                                                  keys.
5532                                                  
5533                                                  Specifying a list of simple host definitions "host1 host2" is equivalent to the
5534                                                  more complicated "h=host1 h=host2" format.
5535                                                  
5536                                                  =item *
5537                                                  
5538                                                  With the command-line options such as L<"--user"> and L<"--password">.  These
5539                                                  options, if given, apply globally to all host definitions.
5540                                                  
5541                                                  =back
5542                                                  
5543                                                  In addition to specifying connection options this way, mk-table-checksum
5544                                                  allows shortcuts.  Any options specified for the first host definition on the
5545                                                  command line fill in missing values in subsequent ones.  Any options that are
5546                                                  still missing after this are filled in from the command-line options if
5547                                                  possible.
5548                                                  
5549                                                  In other words, the places you specify connection options have precedence:
5550                                                  highest precedence is the option specified directly in the host definition, next
5551                                                  is the option specified in the first host definition, and lowest is the
5552                                                  command-line option.
5553                                                  
5554                                                  You can mix simple and complex host definitions and/or command-line arguments.
5555                                                  For example, if all your servers except one of your slaves uses a non-standard
5556                                                  port number:
5557                                                  
5558                                                     mk-table-checksum --port 4500 master h=slave1,P=3306 slave2 slave3
5559                                                  
5560                                                  If you are confused about how mk-table-checksum will connect to your servers,
5561                                                  give the L<"--explain-hosts"> option and it will tell you.
5562                                                  
5563                                                  =head1 HOW FAST IS IT?
5564                                                  
5565                                                  Speed and efficiency are important, because the typical use case is checksumming
5566                                                  large amounts of data.
5567                                                  
5568                                                  C<mk-table-checksum> is designed to do very little work itself, and generates
5569                                                  very little network traffic aside from inspecting table structures with C<SHOW
5570                                                  CREATE TABLE>.  The results of checksum queries are typically 40-character or
5571                                                  shorter strings.
5572                                                  
5573                                                  The MySQL server does the bulk of the work, in the form of the checksum queries.
5574                                                  The following benchmarks show the checksum query times for various checksum
5575                                                  algorithms.  The first two results are simply running C<COUNT(col8)> and
5576                                                  C<CHECKSUM TABLE> on the table.  C<CHECKSUM TABLE> is just C<CRC32> under the
5577                                                  hood, but it's implemented inside the storage engine layer instead of at the
5578                                                  MySQL layer.
5579                                                  
5580                                                   ALGORITHM       HASH FUNCTION  EXTRA           TIME
5581                                                   ==============  =============  ==============  =====
5582                                                   COUNT(col8)                                    2.3
5583                                                   CHECKSUM TABLE                                 5.3
5584                                                   BIT_XOR         FNV_64                         12.7
5585                                                   ACCUM           FNV_64                         42.4
5586                                                   BIT_XOR         MD5            --optimize-xor  80.0
5587                                                   ACCUM           MD5                            87.4
5588                                                   BIT_XOR         SHA1           --optimize-xor  90.1
5589                                                   ACCUM           SHA1                           101.3
5590                                                   BIT_XOR         MD5                            172.0
5591                                                   BIT_XOR         SHA1                           197.3
5592                                                  
5593                                                  The tests are entirely CPU-bound.  The sample data is an InnoDB table with the
5594                                                  following structure:
5595                                                  
5596                                                   CREATE TABLE test (
5597                                                     col1 int NOT NULL,
5598                                                     col2 date NOT NULL,
5599                                                     col3 int NOT NULL,
5600                                                     col4 int NOT NULL,
5601                                                     col5 int,
5602                                                     col6 decimal(3,1),
5603                                                     col7 smallint unsigned NOT NULL,
5604                                                     col8 timestamp NOT NULL,
5605                                                     PRIMARY KEY  (col2, col1),
5606                                                     KEY (col7),
5607                                                     KEY (col1)
5608                                                   ) ENGINE=InnoDB
5609                                                  
5610                                                  The table has 4303585 rows, 365969408 bytes of data and 173457408 bytes of
5611                                                  indexes.  The server is a Dell PowerEdge 1800 with dual 32-bit Xeon 2.8GHz
5612                                                  processors and 2GB of RAM.  The tests are fully CPU-bound, and the server is
5613                                                  otherwise idle.  The results are generally consistent to within a tenth of a
5614                                                  second on repeated runs.
5615                                                  
5616                                                  C<CRC32> is the default checksum function to use, and should be enough for most
5617                                                  cases.  If you need stronger guarantees that your data is identical, you should
5618                                                  use one of the other functions.
5619                                                  
5620                                                  =head1 ALGORITHM SELECTION
5621                                                  
5622                                                  The L<"--algorithm"> option allows you to specify which algorithm you would
5623                                                  like to use, but it does not guarantee that mk-table-checksum will use this
5624                                                  algorithm.  mk-table-checksum will ultimately select the best algorithm possible
5625                                                  given various factors such as the MySQL version and other command line options.
5626                                                  
5627                                                  The three basic algorithms in descending order of preference are CHECKSUM,
5628                                                  BIT_XOR and ACCUM.  CHECKSUM cannot be used if any one of these criteria
5629                                                  is true:
5630                                                  
5631                                                    * L<"--where"> is used.
5632                                                    * L<"--since"> is used.
5633                                                    * L<"--chunk-size"> is used.
5634                                                    * L<"--replicate"> is used.
5635                                                    * L<"--count"> is used.
5636                                                    * MySQL version less than 4.1.1.
5637                                                  
5638                                                  The BIT_XOR algorithm also requires MySQL version 4.1.1 or later.
5639                                                  
5640                                                  After checking these criteria, if the requested L<"--algorithm"> remains then it
5641                                                  is used, otherwise the first remaining algorithm with the highest preference
5642                                                  is used.
5643                                                  
5644                                                  =head1 CONSISTENT CHECKSUMS
5645                                                  
5646                                                  If you are using this tool to verify your slaves still have the same data as the
5647                                                  master, which is why I wrote it, you should read this section.
5648                                                  
5649                                                  The best way to do this with replication is to use the L<"--replicate"> option.
5650                                                  When the queries are finished running on the master and its slaves, you can go
5651                                                  to the slaves and issue SQL queries to see if any tables are different from the
5652                                                  master.  Try the following:
5653                                                  
5654                                                    SELECT db, tbl, chunk, this_cnt-master_cnt AS cnt_diff,
5655                                                       this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc)
5656                                                          AS crc_diff
5657                                                    FROM checksum
5658                                                    WHERE master_cnt <> this_cnt OR master_crc <> this_crc
5659                                                       OR ISNULL(master_crc) <> ISNULL(this_crc);
5660                                                  
5661                                                  The L<"--replicate-check"> option can do this query for you.  If you can't use
5662                                                  this method, try the following:
5663                                                  
5664                                                  =over
5665                                                  
5666                                                  =item *
5667                                                  
5668                                                  If your servers are not being written to, you can just run the tool with no
5669                                                  further ado:
5670                                                  
5671                                                    mk-table-checksum server1 server2 ... serverN
5672                                                  
5673                                                  =item *
5674                                                  
5675                                                  If the servers are being written to, you need some way to make sure they are
5676                                                  consistent at the moment you run the checksums.  For situations other than
5677                                                  master-slave replication, you will have to figure this out yourself.  You may be
5678                                                  able to use the L<"--where"> option with a date or time column to only checksum
5679                                                  data that's not recent.
5680                                                  
5681                                                  =item *
5682                                                  
5683                                                  If you are checksumming a master and slaves, you can do a fast parallel
5684                                                  checksum and assume the slaves are caught up to the master.  In practice, this
5685                                                  tends to work well except for tables which are constantly updated.  You can
5686                                                  use the L<"--slave-lag"> option to see how far behind each slave was when it
5687                                                  checksummed a given table.  This can help you decide whether to investigate
5688                                                  further.
5689                                                  
5690                                                  =item *
5691                                                  
5692                                                  The next most disruptive technique is to lock the table on the master, then take
5693                                                  checksums.  This should prevent changes from propagating to the slaves.  You can
5694                                                  just lock on the master (with L<"--lock">), or you can both lock on the master
5695                                                  and wait on the slaves till they reach that point in the master's binlog
5696                                                  (L<"--wait">).  Which is better depends on your workload; only you know that.
5697                                                  
5698                                                  =item *
5699                                                  
5700                                                  If you decide to make the checksums on the slaves wait until they're guaranteed
5701                                                  to be caught up to the master, the algorithm looks like this:
5702                                                  
5703                                                   For each table,
5704                                                     Master: lock table
5705                                                     Master: get pos
5706                                                     In parallel,
5707                                                       Master: checksum
5708                                                       Slave(s): wait for pos, then checksum
5709                                                     End
5710                                                     Master: unlock table
5711                                                   End
5712                                                  
5713                                                  =back
5714                                                  
5715                                                  What I typically do when I'm not using the L<"--replicate"> option is simply run
5716                                                  the tool on all servers with no further options.  This runs fast, parallel,
5717                                                  non-blocking checksums simultaneously.  If there are tables that look different,
5718                                                  I re-run with L<"--wait">=600 on the tables in question.  This makes the tool
5719                                                  lock on the master as explained above.
5720                                                  
5721                                                  =head1 OUTPUT
5722                                                  
5723                                                  Output is to STDOUT, one line per server and table, with header lines for each
5724                                                  database.  I tried to make the output easy to process with awk.  For this reason
5725                                                  columns are always present.  If there's no value, mk-table-checksum prints
5726                                                  'NULL'.
5727                                                  
5728                                                  The default is column-aligned output for human readability, but you can change
5729                                                  it to tab-separated if you want.  Use the L<"--tab"> option for this.
5730                                                  
5731                                                  Output is unsorted, though all lines for one table should be output together.
5732                                                  For speed, all checksums are done in parallel (as much as possible) and may
5733                                                  complete out of the order in which they were started.  You might want to run
5734                                                  them through another script or command-line utility to make sure they are in the
5735                                                  order you want.  If you pipe the output through L<mk-checksum-filter>, you
5736                                                  can sort the output and/or avoid seeing output about tables that have no
5737                                                  differences.
5738                                                  
5739                                                  The columns in the output are as follows.  The database, table, and chunk come
5740                                                  first so you can sort by them easily (they are the "primary key").
5741                                                  
5742                                                  Output from L<"--replicate-check"> and L<"--checksum"> are different.
5743                                                  
5744                                                  =over
5745                                                  
5746                                                  =item DATABASE
5747                                                  
5748                                                  The database the table is in.
5749                                                  
5750                                                  =item TABLE
5751                                                  
5752                                                  The table name.
5753                                                  
5754                                                  =item CHUNK
5755                                                  
5756                                                  The chunk (see L<"--chunk-size">).  Zero if you are not doing chunked checksums.
5757                                                  
5758                                                  =item HOST
5759                                                  
5760                                                  The server's hostname.
5761                                                  
5762                                                  =item ENGINE
5763                                                  
5764                                                  The table's storage engine.
5765                                                  
5766                                                  =item COUNT
5767                                                  
5768                                                  The table's row count, unless you specified to skip it.
5769                                                  
5770                                                  =item CHECKSUM
5771                                                  
5772                                                  The table's checksum, unless you specified to skip it or the table has no rows.
5773                                                  some types of checksums will be 0 if there are no rows; others will print NULL.
5774                                                  
5775                                                  =item TIME
5776                                                  
5777                                                  The time the actual checksum and/or counting took.
5778                                                  
5779                                                  =item WAIT
5780                                                  
5781                                                  How long the checksum blocked before beginning.
5782                                                  
5783                                                  =item STAT
5784                                                  
5785                                                  The return value of MASTER_POS_WAIT().
5786                                                  
5787                                                  =item LAG
5788                                                  
5789                                                  How far the slave lags the master, as reported by SHOW SLAVE STATUS.
5790                                                  
5791                                                  =back
5792                                                  
5793                                                  =head1 EXIT STATUS
5794                                                  
5795                                                  A successful exit status is 0.  If there is an error checksumming any table,
5796                                                  the exit status is 1.
5797                                                  
5798                                                  When running L<"--replicate-check">, if any slave has chunks that differ from
5799                                                  the master, the exit status is 1.
5800                                                  
5801                                                  =head1 QUERIES
5802                                                  
5803                                                  If you are using innotop (see L<http://code.google.com/p/innotop>),
5804                                                  mytop, or another tool to watch currently running MySQL queries, you may see
5805                                                  the checksum queries.  They look similar to this:
5806                                                  
5807                                                    REPLACE /*test.test_tbl:'2'/'5'*/ INTO test.checksum(db, ...
5808                                                  
5809                                                  Since mk-table-checksum's queries run for a long time and tend to be
5810                                                  textually very long, and thus won't fit on one screen of these monitoring
5811                                                  tools, I've been careful to place a comment at the beginning of the query so
5812                                                  you can see what it is and what it's doing.  The comment contains the name of
5813                                                  the table that's being checksummed, the chunk it is currently checksumming,
5814                                                  and how many chunks will be checksummed.  In the case above, it is
5815                                                  checksumming chunk 2 of 5 in table test.test_tbl.
5816                                                  
5817                                                  =head1 OPTIONS
5818                                                  
5819                                                  L<"--schema"> is restricted to option groups Connection, Filter, Output, Help, Config.
5820                                                  
5821                                                  =over
5822                                                  
5823                                                  =item --algorithm
5824                                                  
5825                                                  type: string
5826                                                  
5827                                                  Checksum algorithm (ACCUM|CHECKSUM|BIT_XOR).
5828                                                  
5829                                                  Specifies which checksum algorithm to use.  Valid arguments are CHECKSUM,
5830                                                  BIT_XOR and ACCUM.  The latter two do cryptographic hash checksums.
5831                                                  See also L<"ALGORITHM SELECTION">.
5832                                                  
5833                                                  CHECKSUM is built into MySQL, but has some disadvantages.  BIT_XOR and ACCUM are
5834                                                  implemented by SQL queries.  They use a cryptographic hash of all columns
5835                                                  concatenated together with a separator, followed by a bitmap of each nullable
5836                                                  column that is NULL (necessary because CONCAT_WS() skips NULL columns).
5837                                                  
5838                                                  CHECKSUM is the default.  This method uses MySQL's built-in CHECKSUM TABLE
5839                                                  command, which is a CRC32 behind the scenes.  It cannot be used before MySQL
5840                                                  4.1.1, and various options disable it as well.  It does not simultaneously count
5841                                                  rows; that requires an extra COUNT(*) query.  This is a good option when you are
5842                                                  using MyISAM tables with live checksums enabled; in this case both the COUNT(*)
5843                                                  and CHECKSUM queries will run very quickly.
5844                                                  
5845                                                  The BIT_XOR algorithm is available for MySQL 4.1.1 and newer.  It uses
5846                                                  BIT_XOR(), which is order-independent, to reduce all the rows to a single
5847                                                  checksum.
5848                                                  
5849                                                  ACCUM uses a user variable as an accumulator.  It reduces each row to a single
5850                                                  checksum, which is concatenated with the accumulator and re-checksummed.  This
5851                                                  technique is order-dependent.  If the table has a primary key, it will be used
5852                                                  to order the results for consistency; otherwise it's up to chance.
5853                                                  
5854                                                  The pathological worst case is where identical rows will cancel each other out
5855                                                  in the BIT_XOR.  In this case you will not be able to distinguish a table full
5856                                                  of one value from a table full of another value.  The ACCUM algorithm will
5857                                                  distinguish them.
5858                                                  
5859                                                  However, the ACCUM algorithm is order-dependent, so if you have two tables
5860                                                  with identical data but the rows are out of order, you'll get different
5861                                                  checksums with ACCUM.
5862                                                  
5863                                                  If a given algorithm won't work for some reason, mk-table-checksum falls back to
5864                                                  another.  The least common denominator is ACCUM, which works on MySQL 3.23.2 and
5865                                                  newer.
5866                                                  
5867                                                  =item --arg-table
5868                                                  
5869                                                  type: string
5870                                                  
5871                                                  The database.table with arguments for each table to checksum.
5872                                                  
5873                                                  This table may be named anything you wish.  It must contain at least the
5874                                                  following columns:
5875                                                  
5876                                                    CREATE TABLE checksum_args (
5877                                                       db         char(64)     NOT NULL,
5878                                                       tbl        char(64)     NOT NULL,
5879                                                       -- other columns as desired
5880                                                       PRIMARY KEY (db, tbl)
5881                                                    );
5882                                                  
5883                                                  In addition to the columns shown, it may contain any of the other columns listed
5884                                                  here (Note: this list is used by the code, MAGIC_overridable_args):
5885                                                  
5886                                                    algorithm chunk-size columns count crc function lock modulo no-use-index
5887                                                    offset optimize-xor probability separator save-since single-chunk since
5888                                                    since-column sleep sleep-coef trim wait where
5889                                                  
5890                                                  Each of these columns corresponds to the long form of a command-line option.
5891                                                  Each column should be NULL-able.  Column names with hyphens should be enclosed
5892                                                  in backticks (e.g. `chunk-size`) when the table is created.  The data type does
5893                                                  not matter, but it's suggested you use a sensible data type to prevent garbage
5894                                                  data.
5895                                                  
5896                                                  When C<mk-table-checksum> checksums a table, it will look for a matching entry
5897                                                  in this table.  Any column that has a defined value will override the
5898                                                  corresponding command-line argument for the table being currently processed.
5899                                                  In this way it is possible to specify custom command-line arguments for any
5900                                                  table.
5901                                                  
5902                                                  If you add columns to the table that aren't in the above list of allowable
5903                                                  columns, it's an error.  The exceptions are C<db>, C<tbl>, and C<ts>.  The C<ts>
5904                                                  column can be used as a timestamp for easy visibility into the last time the
5905                                                  C<since> column was updated with L<"--save-since">.
5906                                                  
5907                                                  This table is assumed to be located on the first server given on the
5908                                                  command-line.
5909                                                  
5910                                                  =item --ask-pass
5911                                                  
5912                                                  group: Connection
5913                                                  
5914                                                  Prompt for a password when connecting to MySQL.
5915                                                  
5916                                                  =item --check-interval
5917                                                  
5918                                                  type: time; default: 1s
5919                                                  
5920                                                  How often to check for slave lag if L<"--check-slave-lag"> is given.
5921                                                  
5922                                                  =item --check-slave-lag
5923                                                  
5924                                                  type: string
5925                                                  
5926                                                  Pause checksumming each chunk until the specified DSN's slave lag is less than
5927                                                  L<"--max-lag">.
5928                                                  
5929                                                  =item --checksum
5930                                                  
5931                                                  group: Output
5932                                                  
5933                                                  Print checksums and table names in the style of md5sum (disables
5934                                                  L<"--[no]count">).
5935                                                  
5936                                                  Makes the output behave more like the output of C<md5sum>.  The checksum is
5937                                                  first on the line, followed by the host, database, table, and chunk number,
5938                                                  concatenated with dots.
5939                                                  
5940                                                  =item --chunk-size
5941                                                  
5942                                                  type: string
5943                                                  
5944                                                  Approximate number of rows or size of data to checksum at a time.  Allowable
5945                                                  suffixes are k, M, G. Disallows C<--algorithm CHECKSUM>.
5946                                                  
5947                                                  If you specify a chunk size, mk-table-checksum will try to find an index that
5948                                                  will let it split the table into ranges of approximately L<"--chunk-size">
5949                                                  rows, based on the table's index statistics.  Currently only numeric and date
5950                                                  types can be chunked.
5951                                                  
5952                                                  If the table is chunkable, mk-table-checksum will checksum each range separately
5953                                                  with parameters in the checksum query's WHERE clause.  If mk-table-checksum
5954                                                  cannot find a suitable index, it will do the entire table in one chunk as though
5955                                                  you had not specified L<"--chunk-size"> at all.  Each table is handled
5956                                                  individually, so some tables may be chunked and others not.
5957                                                  
5958                                                  The chunks will be approximately sized, and depending on the distribution of
5959                                                  values in the indexed column, some chunks may be larger than the value you
5960                                                  specify.
5961                                                  
5962                                                  If you specify a suffix (one of k, M or G), the parameter is treated as a data
5963                                                  size rather than a number of rows.  The output of SHOW TABLE STATUS is then used
5964                                                  to estimate the amount of data the table contains, and convert that to a number
5965                                                  of rows.
5966                                                  
5967                                                  =item --columns
5968                                                  
5969                                                  type: array; group: Filter
5970                                                  
5971                                                  Checksum only this comma-separated list of columns.
5972                                                  
5973                                                  =item --config
5974                                                  
5975                                                  type: Array; group: Config
5976                                                  
5977                                                  Read this comma-separated list of config files; if specified, this must be the
5978                                                  first option on the command line.
5979                                                  
5980                                                  =item --[no]count
5981                                                  
5982                                                  Count rows in tables.  This is built into ACCUM and BIT_XOR, but requires an
5983                                                  extra query for CHECKSUM.
5984                                                  
5985                                                  This is disabled by default to avoid an extra COUNT(*) query when
5986                                                  L<"--algorithm"> is CHECKSUM.  If you have only MyISAM tables and live checksums
5987                                                  are enabled, both CHECKSUM and COUNT will be very fast, but otherwise you may
5988                                                  want to use one of the other algorithms.
5989                                                  
5990                                                  =item --[no]crc
5991                                                  
5992                                                  default: yes
5993                                                  
5994                                                  Do a CRC (checksum) of tables.
5995                                                  
5996                                                  Take the checksum of the rows as well as their count.  This is enabled by
5997                                                  default.  If you disable it, you'll just get COUNT(*) queries.
5998                                                  
5999                                                  =item --create-replicate-table
6000                                                  
6001                                                  Create the replicate table given by L<"--replicate"> if it does not exist.
6002                                                  
6003                                                  Normally, if the replicate table given by L<"--replicate"> does not exist,
6004                                                  C<mk-table-checksum> will die. With this option, however, C<mk-table-checksum>
6005                                                  will create the replicate table for you, using the database.table name given to
6006                                                  L<"--replicate">.
6007                                                  
6008                                                  The structure of the replicate table is the same as the suggested table
6009                                                  mentioned in L<"--replicate">. Note that since ENGINE is not specified, the
6010                                                  replicate table will use the server's default storage engine.  If you want to
6011                                                  use a different engine, you need to create the table yourself.
6012                                                  
6013                                                  =item --databases
6014                                                  
6015                                                  short form: -d; type: hash; group: Filter
6016                                                  
6017                                                  Only checksum this comma-separated list of databases.
6018                                                  
6019                                                  =item --defaults-file
6020                                                  
6021                                                  short form: -F; type: string; group: Connection
6022                                                  
6023                                                  Only read mysql options from the given file.  You must give an absolute
6024                                                  pathname.
6025                                                  
6026                                                  =item --empty-replicate-table
6027                                                  
6028                                                  Empty table given by L<"--replicate"> before starting.
6029                                                  
6030                                                  Issues a DELETE against the table given by L<"--replicate"> before beginning
6031                                                  work.  Ignored if L<"--replicate"> is not specified.  This can be useful to
6032                                                  remove entries related to tables that no longer exist, or just to clean out the
6033                                                  results of a previous run.
6034                                                  
6035                                                  =item --engines
6036                                                  
6037                                                  short form: -e; type: hash; group: Filter
6038                                                  
6039                                                  Do only this comma-separated list of storage engines.
6040                                                  
6041                                                  =item --explain
6042                                                  
6043                                                  group: Output
6044                                                  
6045                                                  Show, but do not execute, checksum queries (disables L<"--empty-replicate-table">).
6046                                                  
6047                                                  =item --explain-hosts
6048                                                  
6049                                                  group: Help
6050                                                  
6051                                                  Print connection information and exit.
6052                                                  
6053                                                  Print out a list of hosts to which mk-table-checksum will connect, with all
6054                                                  the various connection options, and exit.  See L<"SPECIFYING HOSTS">.
6055                                                  
6056                                                  =item --float-precision
6057                                                  
6058                                                  type: int
6059                                                  
6060                                                  Precision for C<FLOAT> and C<DOUBLE> column comparisons.
6061                                                  
6062                                                  If you specify this option, FLOAT and DOUBLE columns will be rounded to the
6063                                                  specified number of digits after the decimal point for the checksum.  This can
6064                                                  avoid checksum mismatches due to different floating-point representations of
6065                                                  the same values on different MySQL versions and hardware.
6066                                                  
6067                                                  =item --function
6068                                                  
6069                                                  type: string
6070                                                  
6071                                                  Hash function for checksums (FNV1A_64, MURMUR_HASH, SHA1, MD5, CRC32, etc).
6072                                                  
6073                                                  You can use this option to choose the cryptographic hash function used for
6074                                                  L<"--algorithm">=ACCUM or L<"--algorithm">=BIT_XOR.  The default is to use
6075                                                  C<CRC32>, but C<MD5> and C<SHA1> also work, and you can use your own function,
6076                                                  such as a compiled UDF, if you wish.  Whatever function you specify is run in
6077                                                  SQL, not in Perl, so it must be available to MySQL.
6078                                                  
6079                                                  The C<FNV1A_64> UDF mentioned in the benchmarks is much faster than C<MD5>.  The
6080                                                  C++ source code is distributed with Maatkit.  It is very simple to compile and
6081                                                  install; look at the header in the source code for instructions.  If it is
6082                                                  installed, it is preferred over C<MD5>.  You can also use the MURMUR_HASH
6083                                                  function if you compile and install that as a UDF; the source is also
6084                                                  distributed with Maatkit, and it is faster and has better distribution
6085                                                  than FNV1A_64.
6086                                                  
6087                                                  =item --help
6088                                                  
6089                                                  group: Help
6090                                                  
6091                                                  Show help and exit.
6092                                                  
6093                                                  =item --ignore-columns
6094                                                  
6095                                                  type: array; group: Filter
6096                                                  
6097                                                  Ignore this comma-separated list of columns when calculating the checksum.
6098                                                  
6099                                                  This option only affects the checksum when using the ACCUM or BIT_XOR
6100                                                  L<"--algorithm">.
6101                                                  
6102                                                  =item --ignore-databases
6103                                                  
6104                                                  type: hash; group: Filter
6105                                                  
6106                                                  Ignore this comma-separated list of databases.
6107                                                  
6108                                                  =item --ignore-engines
6109                                                  
6110                                                  type: Hash; default: FEDERATED,MRG_MyISAM; group: Filter
6111                                                  
6112                                                  Ignore this comma-separated list of storage engines.
6113                                                  
6114                                                  =item --ignore-tables
6115                                                  
6116                                                  type: hash; group: Filter
6117                                                  
6118                                                  Ignore this comma-separated list of tables.
6119                                                  
6120                                                  Table names may be qualified with the database name.
6121                                                  
6122                                                  =item --lock
6123                                                  
6124                                                  Lock on master until done on slaves (implies L<"--slave-lag">).
6125                                                  
6126                                                  This option can help you to get a consistent read on a master and many slaves.
6127                                                  If you specify this option, mk-table-checksum will lock the table on the
6128                                                  first server on the command line, which it assumes to be the master.  It will
6129                                                  keep this lock until the checksums complete on the other servers.
6130                                                  
6131                                                  This option isn't very useful by itself, so you probably want to use L<"--wait">
6132                                                  instead.
6133                                                  
6134                                                  Note: if you're checksumming a slave against its master, you should use
6135                                                  L<"--replicate">.  In that case, there's no need for locking, waiting, or any of
6136                                                  that.
6137                                                  
6138                                                  =item --max-lag
6139                                                  
6140                                                  type: time; default: 1s
6141                                                  
6142                                                  Suspend checksumming if the slave given by L<"--check-slave-lag"> lags.
6143                                                  
6144                                                  This option causes mk-table-checksum to look at the slave every time it's about
6145                                                  to checksum a chunk.  If the slave's lag is greater than the option's value, or
6146                                                  if the slave isn't running (so its lag is NULL), mk-table-checksum sleeps for
6147                                                  L<"--check-interval"> seconds and then looks at the lag again.  It repeats until
6148                                                  the slave is caught up, then proceeds to checksum the chunk.
6149                                                  
6150                                                  This option is useful to let you checksum data as fast as the slaves can handle
6151                                                  it, assuming the slave you directed mk-table-checksum to monitor is
6152                                                  representative of all the slaves that may be replicating from this server.  It
6153                                                  should eliminate the need for L<"--sleep"> or L<"--sleep-coef">.
6154                                                  
6155                                                  =item --modulo
6156                                                  
6157                                                  type: int
6158                                                  
6159                                                  Do only every Nth chunk on chunked tables.
6160                                                  
6161                                                  This option lets you checksum only some chunks of the table.  This is a useful
6162                                                  alternative to L<"--probability"> when you want to be sure you get full coverage
6163                                                  in some specified number of runs; for example, you can do only every 7th chunk,
6164                                                  and then use L<"--offset"> to rotate the modulo every day of the week.
6165                                                  
6166                                                  Just like with L<"--probability">, a table that cannot be chunked is done every
6167                                                  time.
6168                                                  
6169                                                  =item --no-use-index
6170                                                  
6171                                                  Do not add USE INDEX hint to SQL statements.
6172                                                  
6173                                                  By default C<mk-table-checksum> adds a C<USE INDEX> hint to each SQL statement
6174                                                  to coerce MySQL into using the index for the column by which a table will be
6175                                                  chunked.  This option causes C<mk-table-checksum> to omit C<USE INDEX> hints.
6176                                                  
6177                                                  =item --offset
6178                                                  
6179                                                  type: string; default: 0
6180                                                  
6181                                                  Modulo offset expression for use with L<"--modulo">.
6182                                                  
6183                                                  The argument may be an SQL expression, such as C<WEEKDAY(NOW())> (which returns
6184                                                  a number from 0 through 6).  The argument is evaluated by MySQL.  The result is
6185                                                  used as follows: if chunk_num % L<"--modulo"> == L<"--offset">, the chunk will
6186                                                  be checksummed.
6187                                                  
6188                                                  =item --[no]optimize-xor
6189                                                  
6190                                                  default: yes
6191                                                  
6192                                                  Optimize BIT_XOR with user variables.
6193                                                  
6194                                                  This option specifies to use user variables to reduce the number of times each
6195                                                  row must be passed through the cryptographic hash function when you are using
6196                                                  the BIT_XOR algorithm.
6197                                                  
6198                                                  With the optimization, the queries look like this in pseudo-code:
6199                                                  
6200                                                    SELECT CONCAT(
6201                                                       BIT_XOR(SLICE_OF(@user_variable)),
6202                                                       BIT_XOR(SLICE_OF(@user_variable)),
6203                                                       ...
6204                                                       BIT_XOR(SLICE_OF(@user_variable := HASH(col1, col2... colN))));
6205                                                  
6206                                                  The exact positioning of user variables and calls to the hash function is
6207                                                  determined dynamically, and will vary between MySQL versions.  Without the
6208                                                  optimization, it looks like this:
6209                                                  
6210                                                    SELECT CONCAT(
6211                                                       BIT_XOR(SLICE_OF(MD5(col1, col2... colN))),
6212                                                       BIT_XOR(SLICE_OF(MD5(col1, col2... colN))),
6213                                                       ...
6214                                                       BIT_XOR(SLICE_OF(MD5(col1, col2... colN))));
6215                                                  
6216                                                  The difference is the number of times all the columns must be mashed together
6217                                                  and fed through the hash function.  If you are checksumming really large
6218                                                  columns, such as BLOB or TEXT columns, this might make a big difference.
6219                                                  
6220                                                  =item --password
6221                                                  
6222                                                  short form: -p; type: string; group: Connection
6223                                                  
6224                                                  Password to use when connecting.
6225                                                  
6226                                                  =item --pid
6227                                                  
6228                                                  type: string
6229                                                  
6230                                                  Create the given PID file.  The file contains the process ID of the script.
6231                                                  The PID file is removed when the script exits.  Before starting, the script
6232                                                  checks if the PID file already exists.  If it does not, then the script creates
6233                                                  and writes its own PID to it.  If it does, then the script checks the following:
6234                                                  if the file contains a PID and a process is running with that PID, then
6235                                                  the script dies; or, if there is no process running with that PID, then the
6236                                                  script overwrites the file with its own PID and starts; else, if the file
6237                                                  contains no PID, then the script dies.
6238                                                  
6239                                                  =item --port
6240                                                  
6241                                                  short form: -P; type: int; group: Connection
6242                                                  
6243                                                  Port number to use for connection.
6244                                                  
6245                                                  =item --probability
6246                                                  
6247                                                  type: int; default: 100
6248                                                  
6249                                                  Checksums will be run with this percent probability.
6250                                                  
6251                                                  This is an integer between 1 and 100.  If 100, every chunk of every table will
6252                                                  certainly be checksummed.  If less than that, there is a chance that some chunks
6253                                                  of some tables will be skipped.  This is useful for routine jobs designed to
6254                                                  randomly sample bits of tables without checksumming the whole server.  By
6255                                                  default, if a table is not chunkable, it will be checksummed every time even
6256                                                  when the probability is less than 100.  You can override this with
6257                                                  L<"--single-chunk">.
6258                                                  
6259                                                  See also L<"--modulo">.
6260                                                  
6261                                                  =item --quiet
6262                                                  
6263                                                  short form: -q; group: Output
6264                                                  
6265                                                  Do not print checksum results.
6266                                                  
6267                                                  =item --recheck
6268                                                  
6269                                                  Re-checksum chunks that L<"--replicate-check"> found to be different.
6270                                                  
6271                                                  =item --recursion-method
6272                                                  
6273                                                  type: string
6274                                                  
6275                                                  Preferred recursion method used to find slaves for L<"--replicate-check">.
6276                                                  
6277                                                  Possible methods are:
6278                                                  
6279                                                    METHOD       USES
6280                                                    ===========  ================
6281                                                    processlist  SHOW PROCESSLIST
6282                                                    hosts        SHOW SLAVE HOSTS
6283                                                  
6284                                                  The processlist method is preferred because SHOW SLAVE HOSTS is not reliable.
6285                                                  However, the hosts method is required if the server uses a non-standard
6286                                                  port (not 3306).  Usually mk-table-checksum does the right thing and finds
6287                                                  the slaves, but you may give a preferred method and it will be used first.
6288                                                  If it doesn't find any slaves, the other methods will be tried.
6289                                                  
6290                                                  =item --replicate
6291                                                  
6292                                                  type: string
6293                                                  
6294                                                  Replicate checksums to slaves (disallows --algorithm CHECKSUM).
6295                                                  
6296                                                  This option enables a completely different checksum strategy for a consistent,
6297                                                  lock-free checksum across a master and its slaves.  This works only with
6298                                                  statement-based replication (mk-table-checksum will switch the binlog format
6299                                                  to STATEMENT for the duration of the session if your server uses row-based
6300                                                  replication).  Instead of running the checksum queries on each server, you run
6301                                                  it only on the master.  You specify a table to insert the results into.  The
6302                                                  query will insert directly into the table, so it will be replicated through the
6303                                                  binlog to the slaves.
6304                                                  
6305                                                  The argument to the option is the table (fully qualified: db.table) in which the
6306                                                  checksums should be stored. The table must have at least these columns: db, tbl,
6307                                                  chunk, boundaries, this_crc, master_crc, this_cnt, master_cnt.  The table may be
6308                                                  named anything you wish.  Here is a suggested table structure, which is
6309                                                  automatically used for L<"--create-replicate-table"> (MAGIC_create_replicate):
6310                                                  
6311                                                    CREATE TABLE checksum (
6312                                                       db         char(64)     NOT NULL,
6313                                                       tbl        char(64)     NOT NULL,
6314                                                       chunk      int          NOT NULL,
6315                                                       boundaries char(100)    NOT NULL,
6316                                                       this_crc   char(40)     NOT NULL,
6317                                                       this_cnt   int          NOT NULL,
6318                                                       master_crc char(40)         NULL,
6319                                                       master_cnt int              NULL,
6320                                                       ts         timestamp    NOT NULL,
6321                                                       PRIMARY KEY (db, tbl, chunk)
6322                                                    );
6323                                                  
6324                                                  Be sure to choose an appropriate storage engine for the checksum table.  If you
6325                                                  are checksumming InnoDB tables, for instance, a deadlock will break replication
6326                                                  if the checksum table is non-transactional, because the transaction will still
6327                                                  be written to the binlog.  It will then replay without a deadlock on the
6328                                                  slave and break replication with "different error on master and slave."  This
6329                                                  is not a problem with mk-table-checksum, it's a problem with MySQL
6330                                                  replication, and you can read more about it in the MySQL manual.
6331                                                  
6332                                                  When the queries are finished replicating, you can run a simple query on each
6333                                                  slave to see which tables have differences from the master.  See L<"CONSISTENT
6334                                                  CHECKSUMS"> for details.  If you find tables that have differences, you can use
6335                                                  the chunk boundaries in a WHERE clause with L<mk-table-sync> to help repair
6336                                                  them more efficiently.  See L<mk-table-sync> for details.
6337                                                  
6338                                                  This option eliminates the need to do complicated locking and unlocking, waiting
6339                                                  for master binlog positions, and so on.  It disables L<"--lock">, L<"--wait">,
6340                                                  and L<"--slave-lag">.
6341                                                  
6342                                                  The checksum queries actually do a REPLACE into this table, so existing rows
6343                                                  need not be removed before running.  However, you may wish to do this anyway to
6344                                                  remove rows related to tables that don't exist anymore.  The
6345                                                  L<"--empty-replicate-table"> option does this for you.
6346                                                  
6347                                                  Since mk-table-checksum uses USE to select the table's database as its
6348                                                  default database before executing the checksum query, the checksum queries
6349                                                  should replicate to slaves even if --binlog-do-db settings on the master filter
6350                                                  out the checksum table's database.  For more information on how --binlog-do-db
6351                                                  works, see L<http://dev.mysql.com/doc/en/binary-log.html>.
6352                                                  
6353                                                  If the slaves have any --replicate-do-X or replicate-ignore-X options, you
6354                                                  should be careful not to checksum any databases or tables that exist on the
6355                                                  master and not the slaves.  Changes to such tables may not normally be executed
6356                                                  on the slaves because of the --replicate-X options, but the checksum queries
6357                                                  change the checksum table, not the tables they checksum.  Therefore these
6358                                                  queries will be executed on the slave, and if the table or database does not
6359                                                  exist, they will cause replication to fail.  For more information on replication
6360                                                  rules, see L<http://dev.mysql.com/doc/en/replication-rules.html>.
6361                                                  
6362                                                  The table specified by L<"--replicate"> will never be checksummed itself.
6363                                                  
6364                                                  =item --replicate-check
6365                                                  
6366                                                  type: int
6367                                                  
6368                                                  Check results in L<"--replicate"> table, to the specified depth.
6369                                                  
6370                                                  Recursively finds differences recorded in the table given by L<"--replicate">.
6371                                                  Recurses to the depth you specify: 0 is no recursion (check only the server
6372                                                  you specify), 1 is check the server and its slaves, 2 is check the slaves of
6373                                                  its slaves, and so on.
6374                                                  
6375                                                  It finds differences by running the query shown in L<"CONSISTENT CHECKSUMS">,
6376                                                  and prints results.  Exits after printing.  This is just a convenient way of
6377                                                  running the query so you don't have to do it manually.
6378                                                  
6379                                                  The output is one informational line per slave host, followed by the results
6380                                                  of the query, if any.  If L<"--quiet"> is specified, there is no output.
6381                                                  
6382                                                  This option makes C<mk-table-checksum> looks for slaves by running C<SHOW
6383                                                  PROCESSLIST>.  If it finds connections that appear to be from slaves, it
6384                                                  derives
6385                                                  connection information for each slave the same default-and-override method
6386                                                  described in L<"SPECIFYING HOSTS">.
6387                                                  
6388                                                  If C<SHOW PROCESSLIST> doesn't return any rows, C<mk-table-checksum> looks at
6389                                                  C<SHOW SLAVE HOSTS> instead.  The host and port, and user and password if
6390                                                  available, from C<SHOW SLAVE HOSTS> are combined into a DSN and used as the
6391                                                  argument.  This requires slaves to be configured with C<report-host>,
6392                                                  C<report-port> and so on.
6393                                                  
6394                                                  This requires the @@SERVER_ID system variable, so it works only on MySQL
6395                                                  3.23.26 or newer.
6396                                                  
6397                                                  If any slave has chunks that differ from the master, mk-table-checksum's
6398                                                  exit status is 1; otherwise it is 0.
6399                                                  
6400                                                  =item --resume
6401                                                  
6402                                                  type: string
6403                                                  
6404                                                  Resume checksum using given output file from a previously interrupted run.
6405                                                  
6406                                                  The given output file should be the literal output from a previous run of
6407                                                  C<mk-table-checksum>.  For example:
6408                                                  
6409                                                     mk-table-checksum host1 host2 -C 100 > checksum_results.txt
6410                                                     mk-table-checksum host1 host2 -C 100 --resume checksum_results.txt
6411                                                  
6412                                                  The command line options given to the first run and the resumed run must
6413                                                  be identical (except, of course, for --resume).  If they are not, the result
6414                                                  will be unpredictible and probably wrong.
6415                                                  
6416                                                  L<"--resume"> does not work with L<"--replicate">; for that, use
6417                                                  L<"--resume-replicate">.
6418                                                  
6419                                                  =item --resume-replicate
6420                                                  
6421                                                  Resume L<"--replicate">.
6422                                                  
6423                                                  This option resumes a previous checksum operation using L<"--replicate">.
6424                                                  It is like L<"--resume"> but does not require an output file.  Instead,
6425                                                  it uses the checksum table given to L<"--replicate"> to determine where to
6426                                                  resume the checksum operation.
6427                                                  
6428                                                  =item --save-since
6429                                                  
6430                                                  When L<"--arg-table"> and L<"--since"> are given, save the current L<"--since">
6431                                                  value into that table's C<since> column after checksumming.  In this way you can
6432                                                  incrementally checksum tables by starting where the last one finished.
6433                                                  
6434                                                  The value to be saved could be the current timestamp, or it could be the maximum
6435                                                  existing value of the column given by L<"--since-column">.  It depends on what
6436                                                  options are in effect.  See the description of L<"--since"> to see how
6437                                                  timestamps are different from ordinary values.
6438                                                  
6439                                                  =item --schema
6440                                                  
6441                                                  Checksum C<SHOW CREATE TABLE> intead of table data.
6442                                                  
6443                                                  =item --separator
6444                                                  
6445                                                  type: string; default: #
6446                                                  
6447                                                  The separator character used for CONCAT_WS().
6448                                                  
6449                                                  This character is used to join the values of columns when checksumming with
6450                                                  L<"--algorithm"> of BIT_XOR or ACCUM.
6451                                                  
6452                                                  =item --set-vars
6453                                                  
6454                                                  type: string; default: wait_timeout=10000; group: Connection
6455                                                  
6456                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
6457                                                  string will be appended to SET and executed.
6458                                                  
6459                                                  =item --since
6460                                                  
6461                                                  type: string
6462                                                  
6463                                                  Checksum only data newer than this value.
6464                                                  
6465                                                  If the table is chunk-able or nibble-able, this value will apply to the first
6466                                                  column of the chunked or nibbled index.
6467                                                  
6468                                                  This is not too different to L<"--where">, but instead of universally applying a
6469                                                  WHERE clause to every table, it selectively finds the right column to use and
6470                                                  applies it only if such a column is found.  See also L<"--since-column">.
6471                                                  
6472                                                  The argument may be an expression, which is evaluated by MySQL.  For example,
6473                                                  you can specify C<CURRENT_DATE - INTERVAL 7 DAY> to get the date of one week
6474                                                  ago.
6475                                                  
6476                                                  A special bit of extra magic: if the value is temporal (looks like a date or
6477                                                  datetime), then the table is checksummed only if the create time (or last
6478                                                  modified time, for tables that report the last modified time, such as MyISAM
6479                                                  tables) is newer than the value.  In this sense it's not applied as a WHERE
6480                                                  clause at all.
6481                                                  
6482                                                  =item --since-column
6483                                                  
6484                                                  type: string
6485                                                  
6486                                                  The column name to be used for L<"--since">.
6487                                                  
6488                                                  The default is for the tool to choose the best one automatically.  If you
6489                                                  specify a value, that will be used if possible; otherwise the best
6490                                                  auto-determined one; otherwise none.  If the column doesn't exist in the table,
6491                                                  it is just ignored.
6492                                                  
6493                                                  =item --single-chunk
6494                                                  
6495                                                  Permit skipping with L<"--probability"> if there is only one chunk.
6496                                                  
6497                                                  Normally, if a table isn't split into many chunks, it will always be
6498                                                  checksummed regardless of L<"--probability">.  This setting lets the
6499                                                  probabilistic behavior apply to tables that aren't divided into chunks.
6500                                                  
6501                                                  =item --slave-lag
6502                                                  
6503                                                  Report how far slaves lag master.
6504                                                  
6505                                                  If this option is enabled, the output will show how many seconds behind the
6506                                                  master each slave is.  This can be useful when you want a fast, parallel,
6507                                                  non-blocking checksum, and you know your slaves might lag the master.  You can
6508                                                  inspect the results and make an educated guess whether any discrepancies on the
6509                                                  slave are due to slave lag instead of corrupt data.
6510                                                  
6511                                                  If you're using L<"--replicate">, slave lag is a non-issue and you don't need to
6512                                                  worry about this.
6513                                                  
6514                                                  =item --sleep
6515                                                  
6516                                                  type: int
6517                                                  
6518                                                  Sleep time between checksums.
6519                                                  
6520                                                  If this option is specified, mk-table-checksum will sleep the specified
6521                                                  number of seconds between checksums.  That is, it will sleep between every
6522                                                  table, and if you specify L<"--chunk-size">, it will also sleep between chunks.
6523                                                  
6524                                                  This is a very crude way to throttle checksumming; see L<"--sleep-coef"> and
6525                                                  L<"--check-slave-lag">.
6526                                                  
6527                                                  =item --sleep-coef
6528                                                  
6529                                                  type: float
6530                                                  
6531                                                  Calculate L<"--sleep"> as a multiple of the last checksum time.
6532                                                  
6533                                                  If this option is specified, mk-table-checksum will sleep the amount of
6534                                                  time elapsed during the previous checksum, multiplied by the specified
6535                                                  coefficient.  This option is ignored if L<"--sleep"> is specified.
6536                                                  
6537                                                  This is a slightly more sophisticated way to throttle checksum speed: sleep a
6538                                                  varying amount of time between chunks, depending on how long the chunks are
6539                                                  taking.  Even better is to use L<"--check-slave-lag"> if you're checksumming
6540                                                  master/slave replication.
6541                                                  
6542                                                  =item --socket
6543                                                  
6544                                                  short form: -S; type: string; group: Connection
6545                                                  
6546                                                  Socket file to use for connection.
6547                                                  
6548                                                  =item --tab
6549                                                  
6550                                                  group: Output
6551                                                  
6552                                                  Print tab-separated output, not column-aligned output.
6553                                                  
6554                                                  =item --tables
6555                                                  
6556                                                  short form: -t; type: hash; group: Filter
6557                                                  
6558                                                  Do only this comma-separated list of tables.
6559                                                  
6560                                                  Table names may be qualified with the database name.
6561                                                  
6562                                                  =item --trim
6563                                                  
6564                                                  Trim C<VARCHAR> columns (helps when comparing 4.1 to >= 5.0).
6565                                                  
6566                                                  This option adds a C<TRIM()> to C<VARCHAR> columns in C<BIT_XOR> and C<ACCUM>
6567                                                  modes.
6568                                                  
6569                                                  This is useful when you don't care about the trailing space differences between
6570                                                  MySQL versions which vary in their handling of trailing spaces. MySQL 5.0 and 
6571                                                  later all retain trailing spaces in C<VARCHAR>, while previous versions would 
6572                                                  remove them.
6573                                                  
6574                                                  =item --user
6575                                                  
6576                                                  short form: -u; type: string; group: Connection
6577                                                  
6578                                                  User for login if not current user.
6579                                                  
6580                                                  =item --[no]verify
6581                                                  
6582                                                  default: yes
6583                                                  
6584                                                  Verify checksum compatibility across servers.
6585                                                  
6586                                                  This option runs a trivial checksum on all servers to ensure they have
6587                                                  compatible CONCAT_WS() and cryptographic hash functions.
6588                                                  
6589                                                  Versions of MySQL before 4.0.14 will skip empty strings and NULLs in
6590                                                  CONCAT_WS, and others will only skip NULLs.  The two kinds of behavior will
6591                                                  produce different results if you have any columns containing the empty string
6592                                                  in your table.  If you know you don't (for instance, all columns are
6593                                                  integers), you can safely disable this check and you will get a reliable
6594                                                  checksum even on servers with different behavior.
6595                                                  
6596                                                  =item --version
6597                                                  
6598                                                  group: Help
6599                                                  
6600                                                  Show version and exit.
6601                                                  
6602                                                  =item --wait
6603                                                  
6604                                                  short form: -w; type: time
6605                                                  
6606                                                  Wait this long for slaves to catch up to their master (implies L<"--lock">
6607                                                  L<"--slave-lag">).
6608                                                  
6609                                                  Note: the best way to verify that a slave is in sync with its master is to use
6610                                                  L<"--replicate"> instead.  The L<"--wait"> option is really only useful if
6611                                                  you're trying to compare masters and slaves without using L<"--replicate">,
6612                                                  which is possible but complex and less efficient in some ways.
6613                                                  
6614                                                  This option helps you get a consistent checksum across a master server and its
6615                                                  slaves.  It combines locking and waiting to accomplish this.  First it locks the
6616                                                  table on the master (the first server on the command line).  Then it finds the
6617                                                  master's binlog position.  Checksums on slaves will be deferred until they reach
6618                                                  the same binlog position.
6619                                                  
6620                                                  The argument to the option is the number of seconds to wait for the slaves to
6621                                                  catch up to the master.  It is actually the argument to MASTER_POS_WAIT().  If
6622                                                  the slaves don't catch up to the master within this time, they will unblock
6623                                                  and go ahead with the checksum.  You can tell whether this happened by
6624                                                  examining the STAT column in the output, which is the return value of
6625                                                  MASTER_POS_WAIT().
6626                                                  
6627                                                  =item --where
6628                                                  
6629                                                  type: string
6630                                                  
6631                                                  Do only rows matching this C<WHERE> clause (disallows L<"--algorithm"> CHECKSUM).
6632                                                  
6633                                                  You can use this option to limit the checksum to only part of the table.  This
6634                                                  is particularly useful if you have append-only tables and don't want to
6635                                                  constantly re-check all rows; you could run a daily job to just check
6636                                                  yesterday's rows, for instance.
6637                                                  
6638                                                  This option is much like the -w option to mysqldump.  Do not specify the WHERE
6639                                                  keyword.  You may need to quote the value.  Here is an example:
6640                                                  
6641                                                    mk-table-checksum --where "foo=bar"
6642                                                  
6643                                                  =back
6644                                                  
6645                                                  =head1 DOWNLOADING
6646                                                  
6647                                                  You can download Maatkit from Google Code at
6648                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
6649                                                  easily with a command like the following:
6650                                                  
6651                                                     wget http://www.maatkit.org/get/toolname
6652                                                     or
6653                                                     wget http://www.maatkit.org/trunk/toolname
6654                                                  
6655                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
6656                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
6657                                                  needed.  The first URL gets the latest released version of the tool, and the
6658                                                  second gets the latest trunk code from Subversion.
6659                                                  
6660                                                  =head1 ENVIRONMENT
6661                                                  
6662                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
6663                                                  the Maatkit tools:
6664                                                  
6665                                                     MKDEBUG=1 mk-....
6666                                                  
6667                                                  =head1 SYSTEM REQUIREMENTS
6668                                                  
6669                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
6670                                                  installed in any reasonably new version of Perl.
6671                                                  
6672                                                  =head1 BUGS
6673                                                  
6674                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-table-checksum>.
6675                                                  
6676                                                  Please use Google Code Issues and Groups to report bugs or request support:
6677                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
6678                                                  discuss Maatkit.
6679                                                  
6680                                                  Please include the complete command-line used to reproduce the problem you are
6681                                                  seeing, the version of all MySQL servers involved, the complete output of the
6682                                                  tool when run with L<"--version">, and if possible, debugging output produced by
6683                                                  running with the C<MKDEBUG=1> environment variable.
6684                                                  
6685                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
6686                                                  
6687                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6688                                                  Feedback and improvements are welcome.
6689                                                  
6690                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
6691                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
6692                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
6693                                                  
6694                                                  This program is free software; you can redistribute it and/or modify it under
6695                                                  the terms of the GNU General Public License as published by the Free Software
6696                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
6697                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
6698                                                  licenses.
6699                                                  
6700                                                  You should have received a copy of the GNU General Public License along with
6701                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
6702                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
6703                                                  
6704                                                  =head1 SEE ALSO
6705                                                  
6706                                                  See also L<mk-checksum-filter> and L<mk-table-sync>.
6707                                                  
6708                                                  =head1 AUTHOR
6709                                                  
6710                                                  Baron "Xaprb" Schwartz
6711                                                  
6712                                                  =head1 ABOUT MAATKIT
6713                                                  
6714                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
6715                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
6716                                                  code contributors.  Both are employed by Percona.  Financial support for
6717                                                  Maatkit development is primarily provided by Percona and its clients. 
6718                                                  
6719                                                  =head1 ACKNOWLEDGEMENTS
6720                                                  
6721                                                  This is an incomplete list.  My apologies for omissions or misspellings.
6722                                                  
6723                                                  Claus Jeppesen,
6724                                                  Francois Saint-Jacques,
6725                                                  Giuseppe Maxia,
6726                                                  Heikki Tuuri,
6727                                                  James Briggs,
6728                                                  Martin Friebe,
6729                                                  Sergey Zhuravlev,
6730                                                  
6731                                                  =head1 VERSION
6732                                                  
6733                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5565 $.
6734                                                  
6735                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
49    ***      0      0      0   unless $args{$arg}
58    ***      0      0      0   unless $ddl
59    ***      0      0      0   if (ref $ddl eq 'ARRAY')
60    ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
70    ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
76    ***      0      0      0   if $name
94    ***      0      0      0   unless $type
96    ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
100   ***      0      0      0   if (not $def =~ /NOT NULL/)
104   ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
135   ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
149   ***      0      0      0   if ($index)
152   ***      0      0      0   if (not $best)
153   ***      0      0      0   if ($index) { }
166   ***      0      0      0   unless $where
172   ***      0      0      0   if ($$expl{'possible_keys'}) { }
176   ***      0      0      0   if ($$expl{'key'})
196   ***      0      0      0   unless $args{$arg}
210   ***      0      0      0   if ($EVAL_ERROR)
214   ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
220   ***      0      0      0   unless $args{'all_privs'}
227   ***      0      0      0   if ($EVAL_ERROR)
231   ***      0      0      0   if (not scalar keys %$row)
242   ***      0      0      0   $EVAL_ERROR ? :
247   ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
273   ***      0      0      0   if $key =~ /FOREIGN/
278   ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
285   ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
292   ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
316   ***      0      0      0   if ($engine =~ /InnoDB/i and not $clustered_key)
318   ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
342   ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
371   ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
385   ***      0      0      0   if (@sec_indexes)
402   ***      0      0      0   defined $_ ? :
435   ***      0      0      0   unless defined $args{$arg}
448   ***      0      0      0   $comp & 1 ? :
458   ***      0      0      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64')
478   ***      0      0      0   if ($type eq 'bigint' and $length < 20)
492   ***      0      0      0   if $alg and not $ALGOS{$alg}
495   ***      0      0      0   if ($args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1'))
504   ***      0      0      0   if (not $vp->version_ge($dbh, '4.1.1'))
509   ***      0      0      0   if ($alg and grep {$_ eq $alg;} @choices)
514   ***      0      0      0   if ($args{'count'} and grep {$_ ne 'CHECKSUM';} @choices)
531   ***      0      0      0   if ($args{'function'})
544   ***      0      0      0   if ($EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/)
550   ***      0      0      0   unless $result
559   ***      0      0      0   if $func =~ /^(?:FNV1A_64|FNV_64|CRC32)$/i
566   ***      0      0      0   length $unsliced < 16 ? :
579   ***      0      0      0   if ($sliced ne $unsliced)
586   ***      0      0      0   if ($sliced eq $unsliced) { }
599   ***      0      0      0   unless defined $args{$arg}
606   ***      0      0      0   if ($len > 16)
615   ***      0      0      0   if (defined $opt_slice and $opt_slice < @slices) { }
638   ***      0      0      0   $args{'cols'} ? :
643   ***      0      0      0   if ($type eq 'timestamp') { }
      ***      0      0      0   elsif ($type =~ /float|double/ and $args{'float_precision'}) { }
      ***      0      0      0   elsif ($type =~ /varchar/ and $args{'trim'}) { }
660   ***      0      0      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64') { }
662   ***      0      0      0   if (@nulls)
669   ***      0      0      0   @cols > 1 ? :
685   ***      0      0      0   unless $args{$arg}
693   ***      0      0      0   unless $algorithm and $ALGOS{$algorithm}
696   ***      0      0      0   if ($algorithm eq 'CHECKSUM')
702   ***      0      0      0   if ($algorithm eq 'BIT_XOR') { }
703   ***      0      0      0   if ($crc_type =~ /int$/) { }
712   ***      0      0      0   if ($crc_type =~ /int$/) { }
725   ***      0      0      0   if ($args{'replicate'}) { }
731   ***      0      0      0   $args{'buffer'} ? :
761   ***      0      0      0   defined $_ ? :
801   ***      0      0      0   unless $args{$arg}
807   ***      0      0      0   exists $args{'strict'} ? :
850   ***      0      0      0   unless open my $fh, '<', $file
870   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
875   ***      0      0      0   if $para =~ /^=over/
883   ***      0      0      0   unless $para
886   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
893   ***      0      0      0   if ($para =~ /: /) { }
897   ***      0      0      0   unless $attributes{$attrib}
901   ***      0      0      0   if ($attribs{'short form'})
917   ***      0      0      0   if $para =~ /^=item/
919   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
924   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
936   ***      0      0      0   unless $para
939   ***      0      0      0   if ($para =~ /^=head1/)
943   ***      0      0      0   if $para =~ /^=item --/
947   ***      0      0      0   unless @specs
958   ***      0      0      0   if (ref $opt) { }
963   ***      0      0      0   if (not $long)
968   ***      0      0      0   if exists $$self{'opts'}{$long}
971   ***      0      0      0   if (length $long == 1)
976   ***      0      0      0   if ($short) { }
977   ***      0      0      0   if exists $$self{'short_opts'}{$short}
986   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
987   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
988   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
1000  ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
1005  ***      0      0      0   if $type and $type =~ /[HhAadzm]/
1007  ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
1008  ***      0      0      0   defined $def ? :
1012  ***      0      0      0   if ($long eq 'config')
1016  ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
1029  ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
1034  ***      0      0      0   if ($opt =~ /at least one|one and only one/)
1039  ***      0      0      0   if ($opt =~ /default to/)
1044  ***      0      0      0   if ($opt =~ /restricted to option groups/)
1054  ***      0      0      0   unless $rule_ok
1071  ***      0      0      0   unless exists $$self{'opts'}{$long}
1095  ***      0      0      0   unless exists $$self{'opts'}{$long}
1115  ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
1120  ***      0      0      0   if ($$opt{'is_cumulative'}) { }
1135  ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
1144  ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
1148  ***      0      0      0   if ($self->has('config'))
1154  ***      0      0      0   if ($EVAL_ERROR)
1155  ***      0      0      0   $self->got('config') ? :
1170  ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
1173  ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
1174  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1180  ***      0      0      0   if (@ARGV and $$self{'strict'})
1186  ***      0      0      0   if (@set > 1)
1197  ***      0      0      0   if (@set == 0)
1207  ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
1208  ***      0      0      0   if (exists $$self{'disables'}{$long})
1215  ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
1227  ***      0      0      0   if $restricted_opt eq $long
1228  ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
1233  ***      0      0      0   if (@restricted_opts)
1235  ***      0      0      0   if (@restricted_opts == 1) { }
1264  ***      0      0      0   unless $opt and $$opt{'type'}
1267  ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1270  ***      0      0      0   if (not $suffix)
1276  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1277  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1292  ***      0      0      0   if ($from_key)
1303  ***      0      0      0   if (defined $num) { }
1304  ***      0      0      0   if ($factor)
1331  ***      0      0      0   length $opt == 1 ? :
1332  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1339  ***      0      0      0   length $opt == 1 ? :
1340  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1347  ***      0      0      0   length $opt == 1 ? :
1348  ***      0      0      0   defined $long ? :
1353  ***      0      0      0   length $opt == 1 ? :
1354  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1388  ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
1389  ***      0      0      0   unless print $self->print_usage
1393  ***      0      0      0   unless print $self->print_errors
1402  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1411  ***      0      0      0   unless $$self{'got_opts'}
1414  ***      0      0      0   $$_{'is_negatable'} ? :
1418  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1434  ***      0      0      0   $group eq 'default' ? :
1440  ***      0      0      0   $$opt{'is_negatable'} ? :
1443  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1452  ***      0      0      0   if ($short) { }
1461  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1465  ***      0      0      0   if ($$self{'dp'})
1473  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1485  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1488  ***      0      0      0   unless print $prompt
1496  ***      0      0      0   unless print "\n"
1499  ***      0      0      0   if ($EVAL_ERROR)
1521  ***      0      0      0   unless open my $fh, '<', $filename
1529  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1532  ***      0      0      0   if ($line eq '--')
1537  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1555  ***      0      0      0   unless open my $fh, '<', $file
1559  ***      0      0      0   unless $para =~ /^=pod$/m
1563  ***      0      0      0   unless $para =~ /$regex/
1568  ***      0      0      0   unless close $fh
1582  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1597  ***      0      0      0   defined $_ ? :
1683  ***     50      0     93   if (@_ > 2)
1692  ***     50      0     31   if (not $dsn)
1704  ***     50    124      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1716  ***     50      0    248   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1722         100    124    124   if (not defined $final_props{$key})
1729  ***     50      0    124   unless exists $opts{$key}
1732  ***     50      0     31   if (my $required = $self->prop('required'))
1734  ***      0      0      0   unless $final_props{$key}
1743  ***      0      0      0   unless ref $o eq 'OptionParser'
1746  ***      0      0      0   if $o->has($_)
1756  ***      0      0      0   unless ref $dsn
1757  ***      0      0      0   $_ eq 'p' ? :
1758  ***      0      0      0   if defined $$dsn{$_}
1771  ***      0      0      0   $opts{$key}{'copy'} ? :
1785  ***     50      0     31   if ($driver eq 'Pg') { }
1817  ***     50      0     31   $cxn_string =~ /charset=utf8/ ? :
1826  ***     50      0     31   if (not $have_dbi)
1845  ***     50     31      0   if ($cxn_string =~ /mysql/i)
1853  ***     50      0     31   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1858  ***      0      0      0   if ($charset eq 'utf8') { }
1859  ***      0      0      0   unless binmode STDOUT, ':utf8'
1863  ***      0      0      0   unless binmode STDOUT
1867  ***     50      0     31   if ($self->prop('set-vars'))
1874  ***     50      0     31   if (not $dbh and $EVAL_ERROR)
1876  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1889  ***      0      0      0   if (not $tries)
1911  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1928  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1938  ***      0      0      0   unless $dsn_1
1939  ***      0      0      0   unless $dsn_2
1943  ***      0      0      0   if ($args{'overwrite'}) { }
1944  ***      0      0      0   defined $$dsn_1{$key} ? :
1947  ***      0      0      0   defined $$dsn_2{$key} ? :
1956  ***      0      0      0   defined $_ ? :
1994  ***     50      1      0   if (not $$self{$dbh})
1998  ***     50      1      0   $$self{$dbh} ge $self->parse($target) ? :
2005  ***      0      0      0   defined $_ ? :
2055  ***      0      0      0   unless defined $args{'cache'}
2063  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2065  ***      0      0      0   unless $ddl
2066  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2080  ***      0      0      0   if ($trgs and @$trgs) { }
2083  ***      0      0      0   if ($$trg{'sql_mode'})
2087  ***      0      0      0   if ($$trg{'definer'})
2119  ***      0      0      0   if (not $new)
2126  ***      0      0      0   if ($curr and $new and $curr eq $new)
2138  ***      0      0      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2151  ***      0      0      0   if ($EVAL_ERROR)
2161  ***      0      0      0   if ($key) { }
2177  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2207  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2220  ***      0      0      0   if ($sth->rows)
2233  ***      0      0      0   if ($tbl)
2241  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2244  ***      0      0      0   if ($like)
2252  ***      0      0      0   unless $like
2260  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2263  ***      0      0      0   if ($like)
2278  ***      0      0      0   unless $like
2286  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2289  ***      0      0      0   if ($like)
2297  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2304  ***      0      0      0   unless $like
2312  ***      0      0      0   defined $_ ? :
2345  ***      0      0      0   unless $args{$arg}
2360  ***      0      0      0   unless $args{$arg}
2367  ***      0      0      0   unless $$index{'type'} eq 'BTREE'
2371  ***      0      0      0   if ($args{'exact'})
2372  ***      0      0      0   unless $$index{'is_unique'} and @{$$index{'cols'};} == 1
2385  ***      0      0      0   unless $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2391  ***      0      0      0   if $args{'exact'} and scalar @candidate_cols
2401  ***      0      0      0   if ($$tbl_struct{'keys'}{'PRIMARY'})
2424  ***      0      0      0   unless defined $args{$arg}
2435  ***      0      0      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type eq 'timestamp') { }
      ***      0      0      0   elsif ($col_type eq 'date') { }
      ***      0      0      0   elsif ($col_type eq 'time') { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
2467  ***      0      0      0   if (not defined $start_point)
2471  ***      0      0      0   if (not defined $end_point or $end_point < $start_point)
2480  ***      0      0      0   if ($int_types{$col_type})
2484  ***      0      0      0   if ($args{'exact'})
2490  ***      0      0      0   if ($start_point < $end_point) { }
2496  ***      0      0      0   if ($iter++ == 0) { }
2506  ***      0      0      0   if (@chunks) { }
2510  ***      0      0      0   $nullable ? :
2512  ***      0      0      0   if ($nullable)
2528  ***      0      0      0   unless $args{$arg}
2538  ***      0      0      0   unless $args{$arg}
2547  ***      0      0      0   if ($suffix) { }
      ***      0      0      0   elsif ($num) { }
2548  ***      0      0      0   $suffix eq 'M' ? :
      ***      0      0      0   $suffix eq 'k' ? :
2560  ***      0      0      0   if ($suffix or $args{'avg_row_length'})
2563  ***      0      0      0   if (not defined $n_rows)
2564  ***      0      0      0   $avg_row_length ? :
2568  ***      0      0      0   wantarray ? :
2575  ***      0      0      0   unless $args{$arg}
2580  ***      0      0      0   $where ? :
2588  ***      0      0      0   if ($EVAL_ERROR)
2590  ***      0      0      0   if ($EVAL_ERROR =~ /in your SQL syntax/) { }
2597  ***      0      0      0   $where ? :
2610  ***      0      0      0   $val =~ /\d[:-]/ ? :
2616  ***      0      0      0   unless defined $args{$arg}
2625  ***      0      0      0   if ($args{'where'} and grep {$_;} @{$args{'where'};})
2648  ***      0      0      0   if $start =~ /e/
2649  ***      0      0      0   if $end =~ /e/
2654  ***      0      0      0   if ($end > $start) { }
2700  ***      0      0      0   unless $check eq $time
2711  ***      0      0      0   defined $_ ? :
2751  ***      0      0      0   unless defined $val
2752  ***      0      0      0   if $val eq ''
2754  ***      0      0      0   if (not defined $is_numeric)
2755  ***      0      0      0   $val =~ /^0|\D/ ? :
2758  ***      0      0      0   if $is_numeric
2768  ***      0      0      0   if (not $tbl)
2777  ***      0      0      0   unless $like
2820  ***      0      0      0   if ($EVAL_ERROR)
2821  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
2831  ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
2836  ***      0      0      0   if ($$args{'skip_callback'})
2844  ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
2846  ***      0      0      0   unless not $$_{'master_id'}
2863  ***      0      0      0   if ($method) { }
2868  ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
2882  ***      0      0      0   if @slaves
2900  ***      0      0      0   if ($host eq 'localhost')
2917  ***      0      0      0   if (@slaves)
2922  ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
2942  ***      0      0      0   if (not $proc)
2959  ***      0      0      0   unless my $master_status = $self->get_master_status($master)
2961  ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
2963  ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
2967  ***      0      0      0   if ($port != $$slave_status{'master_port'})
2972  ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
2977  ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
2984  ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
2997  ***      0      0      0   unless my $master = $self->get_slave_status($dbh)
3004  ***      0      0      0   if (not $$self{'not_a_slave'}{$dbh})
3011  ***      0      0      0   if ($ss and %$ss)
3023  ***      0      0      0   if (not $$self{'not_a_master'}{$dbh})
3030  ***      0      0      0   if ($ms and %$ms)
3032  ***      0      0      0   if ($$ms{'file'} and $$ms{'position'})
3045  ***      0      0      0   unless defined $time
3049  ***      0      0      0   if ($ms) { }
3053  ***      0      0      0   defined $result ? :
3055  ***      0      0      0   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
3075  ***      0      0      0   if ($pos) { }
3099  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
3105  ***      0      0      0   if ($EVAL_ERROR)
3107  ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
3109  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
3114  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
3138  ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
3150  ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
3173  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3177  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3182  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
3196  ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
3211  ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
3222  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
3226  ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3230  ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3232  ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
3235  ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
3237  ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
3249  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
3261  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
3265  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3269  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3272  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
3275  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
3279  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
3281  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
3289  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
3303  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
3314  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
3336  ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
3364  ***      0      0      0   if ($$dsn{'master_host'}) { }
3372  ***      0      0      0   ($port || 3306) == 3306 ? :
3383  ***      0      0      0   defined $_ ? :
3412  ***      0      0      0   unless $args{$arg}
3415  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
3431  ***      0      0      0   unless defined(my $pid = fork)
3432  ***      0      0      0   if ($pid)
3439  ***      0      0      0   unless POSIX::setsid()
3440  ***      0      0      0   unless chdir '/'
3446  ***      0      0      0   if (-t STDIN)
3448  ***      0      0      0   unless open STDIN, '/dev/null'
3452  ***      0      0      0   if ($$self{'log_file'}) { }
3454  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
3458  ***      0      0      0   unless open STDERR, '>&STDOUT'
3462  ***      0      0      0   if (-t STDOUT)
3464  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
3467  ***      0      0      0   if (-t STDERR)
3469  ***      0      0      0   unless open STDERR, '>', '/dev/null'
3480  ***      0      0      0   $self ? :
3482  ***      0      0      0   if ($PID_file and -f $PID_file) { }
3485  ***      0      0      0   if $EVAL_ERROR
3487  ***      0      0      0   if ($pid) { }
3489  ***      0      0      0   if ($pid_is_alive) { }
3511  ***      0      0      0   if (exists $$self{'child'})
3523  ***      0      0      0   if (not $PID_file)
3530  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
3532  ***      0      0      0   unless print $PID_FH $PID
3534  ***      0      0      0   unless close $PID_FH
3543  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
3544  ***      0      0      0   unless unlink $$self{'PID_file'}
3556  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
3562  ***      0      0      0   defined $_ ? :
3593  ***      0      0      0   unless $args{$arg}
3612  ***      0      0      0   if $o->has('databases')
3614  ***      0      0      0   if $o->has('ignore-databases')
3617  ***      0      0      0   if ($o->has('databases-regex') and my $p = $o->get('databases-regex'))
3621  ***      0      0      0   if ($o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex'))
3625  ***      0      0      0   if (@permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex)
3626  ***      0      0      0   @permit_dbs ? :
      ***      0      0      0   @reject_dbs ? :
      ***      0      0      0   @dbs_regex ? :
      ***      0      0      0   @reject_dbs_regex ? :
3635  ***      0      0      0   if ($o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex'))
3645  ***      0      0      0   if ($o->get('tables'))
3648  ***      0      0      0   if ($_ =~ /\./) { }
3658  ***      0      0      0   if (@permit_qtbls)
3668  ***      0      0      0   if ($o->get('ignore-tables'))
3671  ***      0      0      0   if ($_ =~ /\./) { }
3681  ***      0      0      0   if (@reject_qtbls and not $have_qtbl)
3687  ***      0      0      0   if (keys %permit_qtbls and not @permit_dbs)
3695  ***      0      0      0   if (keys %$dbs)
3702  ***      0      0      0   if ($o->has('tables-regex') and my $p = $o->get('tables-regex'))
3706  ***      0      0      0   if ($o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex'))
3715  ***      0      0      0   if ($o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines'))
3734  ***      0      0      0   if (@permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs)
3736  ***      0      0      0   @permit_tbls ? :
      ***      0      0      0   @reject_tbls ? :
      ***      0      0      0   @tbls_regex ? :
      ***      0      0      0   @reject_tbls_regex ? :
      ***      0      0      0   @permit_qtbls ? :
      ***      0      0      0   @reject_qtbls ? :
      ***      0      0      0   @get_eng ? :
      ***      0      0      0   @permit_engs ? :
      ***      0      0      0   @reject_engs ? :
3757  ***      0      0      0   unless my $filter_sub = eval $code
3774  ***      0      0      0   unless $args{$arg}
3783  ***      0      0      0   $filter ? :
3785  ***      0      0      0   if $_ =~ /information_schema|lost\+found/
3800  ***      0      0      0   unless $args{$arg}
3806  ***      0      0      0   if ($db) { }
3816  ***      0      0      0   $filter ? :
3817  ***      0      0      0   if (not $views)
3818  ***      0      0      0   if ($type || '') eq 'VIEW'
3838  ***      0      0      0   if (scalar keys %$objs)
3839  ***      0      0      0   $lc ? :
3848  ***      0      0      0   defined $_ ? :
3928  ***      0      0      0   unless $o->has($arg)
3935  ***      0      0      0   if $o->get('wait')
3936  ***      0      0      0   if $o->get('lock')
3938  ***      0      0      0   if (not @ARGV)
3950  ***      0      0      0   if ($o->get('explain-hosts'))
3960  ***      0      0      0   $o->get('schema') ? :
3962  ***      0      0      0   if ($o->get('checksum'))
3966  ***      0      0      0   if ($o->get('explain'))
3970  ***      0      0      0   if (not $o->get('help'))
3971  ***      0      0      0   if ($o->get('replicate-check') and not $o->get('replicate'))
3974  ***      0      0      0   if ($o->get('save-since') and not $o->get('arg-table')) { }
      ***      0      0      0   elsif ($o->get('replicate') and @hosts > 1) { }
3981  ***      0      0      0   if ($o->get('resume-replicate') and not $o->get('replicate'))
3984  ***      0      0      0   if ($o->get('resume') and $o->get('replicate'))
3996  ***      0      0      0   if ($o->get('pid'))
4030  ***      0      0      0   if ($o->get('check-slave-lag'))
4040  ***      0      0      0   if (my $arg_tbl = $o->get('arg-table'))
4045  ***      0      0      0   unless $$row{'db'} and $$row{'tbl'}
4048  ***      0      0      0   if $overridable_args{$_}
4052  ***      0      0      0   if (not %col_in_argtable)
4054  ***      0      0      0   if $key =~ /^(db|tbl|ts)$/
4055  ***      0      0      0   unless $overridable_args{$key}
4061  ***      0      0      0   if ($col_in_argtable{'since'})
4073  ***      0      0      0   if ($o->get('replicate-check'))
4074  ***      0      0      0   $o->get('recheck') ? :
4086  ***      0      0      0   unless @tbls
4104  ***      0      0      0   unless $o->get('recheck')
4112  ***      0      0      0   if ($checksum_table_data) { }
4116  ***      0      0      0   if ($o->get('verify') and @hosts > 1)
4130  ***      0      0      0   if ($o->get('replicate') and $o->get('resume-replicate')) { }
      ***      0      0      0   elsif ($o->get('resume')) { }
4149  ***      0      0      0   unless $o->get('replicate-check') and $o->get('recheck')
4177  ***      0      0      0   unless $args{$arg}
4216  ***      0      0      0   unless $args{$arg}
4229  ***      0      0      0   if $final_o->get('replicate') and $final_o->get('replicate') eq "$db.$tbl"
4240  ***      0      0      0   if $final_o->get('no-use-index')
4241  ***      0      0      0   if ($idx)
4242  ***      0      0      0   $vp->version_ge($dbh, '4.0.9') ? :
4249  ***      0      0      0   if ($args{'given_chunks'}) { }
4253  ***      0      0      0   if ($final_o->get('chunk-size') and $col)
4268  ***      0      0      0   if (not grep {not defined $params{$_};} 'min', 'max', 'rows_in_range')
4293  ***      0      0      0   if ($EVAL_ERROR)
4305  ***      0      0      0   unless $args{$arg}
4332  ***      0      0      0   if ($checksum_table_data and $do_table) { }
4354  ***      0      0      0   if (not $hdr)
4355  ***      0      0      0   if ($o->get('tab')) { }
4369  ***      0      0      0   unless ($o->get('quiet') or $o->get('explain') or $o->get('checksum') or $o->get('resume'))
4374  ***      0      0      0   unless printf $hdr, @hdr_args
4380  ***      0      0      0   if (my $replicate_table = $final_o->get('replicate') and not $final_o->get('explain'))
4396  ***      0      0      0   if ($final_o->get('since'))
4397  ***      0      0      0   if (is_temporal($final_o->get('since'))) { }
4402  ***      0      0      0   if ($time and $time lt $final_o->get('since'))
4419  ***      0      0      0   if $_
4423  ***      0      0      0   if ($sincecol) { }
4442  ***      0      0      0   if ($checksum_table_data and $do_table) { }
4479  ***      0      0      0   if ($final_o->get('save-since') and $savesince_sth)
4480  ***      0      0      0   if (is_temporal($final_o->get('since'))) { }
      ***      0      0      0   elsif (defined $$table{'maxval'}) { }
4499  ***      0      0      0   if ($EVAL_ERROR)
4510  ***      0      0      0   unless $args{$arg}
4536  ***      0      0      0   if (my $lag_dbh = $args{'lag_dbh'})
4545  ***      0      0      0   if ($num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data and defined $final_o->get('probability') and rand 100 >= $final_o->get('probability'))
4553  ***      0      0      0   if ($num_chunks > 1 and $checksum_table_data and $final_o->get('modulo') and $chunk_num % $final_o->get('modulo') != $final_o->get('offset'))
4565  ***      0      0      0   if ($final_o->get('replicate')) { }
4569  ***      0      0      0   if ($o->get('resume-replicate'))
4570  ***      0      0      0   if (already_checksummed($$tbl{'database'}, $$tbl{'table'}, $chunk_num, $hosts[0]{'h'}))
4574  ***      0      0      0   unless $o->get('quiet')
4596  ***      0      0      0   if (not $final_o->get('explain'))
4597  ***      0      0      0   if ($final_o->get('lock'))
4603  ***      0      0      0   if ($final_o->get('wait'))
4616  ***      0      0      0   if ($is_master) { }
4625  ***      0      0      0   if ($final_o->get('resume'))
4626  ***      0      0      0   if already_checksummed($$tbl{'database'}, $$tbl{'table'}, $chunk_num, $$host{'h'})
4633  ***      0      0      0   @hosts > 1 ? :
4635  ***      0      0      0   if (@hosts == 1 or defined $pid and $pid == 0) { }
      ***      0      0      0   elsif (@hosts > 1 and not defined $pid) { }
4647  ***      0      0      0   if ($EVAL_ERROR)
4650  ***      0      0      0   if @hosts > 1
4653  ***      0      0      0   if @hosts > 1
4660  ***      0      0      0   if @hosts > 1
4669  ***      0      0      0   if ($final_o->get('lock') and not $final_o->get('explain'))
4679  ***      0      0      0   if ($final_o->get('sleep') and not $final_o->get('explain')) { }
      ***      0      0      0   elsif ($final_o->get('sleep-coef') and not $final_o->get('explain')) { }
4701  ***      0      0      0   unless $args{$arg}
4710  ***      0      0      0   if (my $override = $$args_for{$db}{$tbl})
4720  ***      0      0      0   if ($val and not is_temporal($val))
4736  ***      0      0      0   unless $args{$arg}
4743  ***      0      0      0   if $o->get('quiet')
4750  ***      0      0      0   unless printf $fmt, map({uc $_;} @headers)
4752  ***      0      0      0   unless printf $fmt, @{$tbl;}{@headers}
4754  ***      0      0      0   unless print "\n"
4762  ***      0      0      0   unless $args{$arg}
4795  ***      0      0      0   if ($EVAL_ERROR and 0)
4805  ***      0      0      0   unless $args{$arg}
4828  ***      0      0      0   if ($o->get('algorithm') and $o->get('algorithm') ne $$ret{'strat'})
4835  ***      0      0      0   if ($tc->is_hash_algorithm($$ret{'strat'}))
4840  ***      0      0      0   if ($o->get('function') and $o->get('function') ne $$ret{'func'})
4847  ***      0      0      0   if ($o->get('optimize-xor') and $$ret{'strat'} eq 'BIT_XOR')
4848  ***      0      0      0   if (not $$ret{'crc_type'} =~ /int$/) { }
4851  ***      0      0      0   if (not defined $$ret{'opt_slice'})
4869  ***      0      0      0   unless $args{$arg}
4886  ***      0      0      0   if (unique(map({$$_{'sum'};} @verify_sums)) > 1)
4908  ***      0      0      0   unless $args{$arg}
4916  ***      0      0      0   unless $replicate_table
4926  ***      0      0      0   if (not $tbl_exists) { }
4927  ***      0      0      0   if ($o->get('create-replicate-table')) { }
4928  ***      0      0      0   unless create_repl_table(%args)
4947  ***      0      0      0   unless $have_tbl_privs
4952  ***      0      0      0   if ($o->get('empty-replicate-table'))
4973  ***      0      0      0   unless $args{$arg}
4988  ***      0      0      0   if ($EVAL_ERROR)
4999  ***      0      0      0   unless $args{$arg}
5006  ***      0      0      0   unless $replicate_table
5026  ***      0      0      0   unless open my $resume_fh, '<', $resume_file
5042  ***      0      0      0   if ($line =~ /^\S+\s+\S+\s+\d+\s+/)
5056  ***      0      0      0   if (exists $$already_checksummed{$d}{$t}{$c}{$h})
5066  ***      0      0      0   unless $args{$arg}
5101  ***      0      0      0   if ($final_o->get('explain'))
5102  ***      0      0      0   if ($chunk_num == 0)
5103  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $sql
5106  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $where
5121  ***      0      0      0   if ($$warning{'Message'} =~ /Data truncated for column 'boundaries'/) { }
5137  ***      0      0      0   if (not $final_o->get('quiet') and not $final_o->get('explain'))
5138  ***      0      0      0   if ($final_o->get('checksum')) { }
5140  ***      0      0      0   unless printf $md5sum_fmt, $crc, $$host{'h'}, @{$tbl;}{'database', 'table'}, $chunk_num
5145  ***      0      0      0   unless printf $hdr, @{$tbl;}{'database', 'table'}, $chunk_num, $$host{'h'}, $$tbl{'struct'}{'engine'}, $cnt, $crc, $end - $beg, 'NULL', 'NULL', 'NULL'
5158  ***      0      0      0   unless $args{$arg}
5187  ***      0      0      0   if (not $is_master and $final_o->get('wait') and not $final_o->get('explain'))
5195  ***      0      0      0   unless defined $sta
5197  ***      0      0      0   if (not $is_master and $final_o->get('slave-lag') and not $final_o->get('explain'))
5202  ***      0      0      0   $res && defined $$res{'seconds_behind_master'} ? :
5209  ***      0      0      0   if (not $is_master or not $checksum_table_data)
5215  ***      0      0      0   $$host{'h'} ? :
      ***      0      0      0   $$host{'P'} ? :
      ***      0      0      0   unless $have_table
5224  ***      0      0      0   if ($have_table)
5226  ***      0      0      0   if ($checksum_table_data) { }
5227  ***      0      0      0   if ($strat eq 'CHECKSUM') { }
      ***      0      0      0   elsif ($final_o->get('crc')) { }
5228  ***      0      0      0   if ($final_o->get('crc'))
5231  ***      0      0      0   if ($final_o->get('count'))
5254  ***      0      0      0   if (not $final_o->get('quiet') and not $final_o->get('explain'))
5255  ***      0      0      0   if ($final_o->get('checksum')) { }
5257  ***      0      0      0   unless printf $md5sum_fmt, $crc, $$host{'h'}, @{$tbl;}{'database', 'table'}, $chunk_num
5262  ***      0      0      0   unless printf $hdr, @{$tbl;}{'database', 'table'}, $chunk_num, $$host{'h'}, $$tbl{'struct'}{'engine'}, $cnt, $crc, $end - $mid, $mid - $beg, $sta, $lag
5275  ***      0      0      0   unless $args{$arg}
5280  ***      0      0      0   if ($o->get('ask-pass') and not defined $$dsn{'p'})
5284  ***      0      0      0   $o->get('lock') ? :
5294  ***      0      0      0   unless $args{$arg}
5318  ***      0      0      0   if ($final_o->get('explain'))
5319  ***      0      0      0   if ($chunk_num == 0)
5320  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $sql
5323  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $$tbl{'chunks'}[$chunk_num]
5336  ***      0      0      0   unless $args{$arg}
5346  ***      0      0      0   if ($final_o->get('explain')) { }
5347  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $query
5352  ***      0      0      0   if ($res)
5354  ***      0      0      0   defined $$res{$key} ? :
5364  ***      0      0      0   unless $args{$arg}
5376  ***      0      0      0   if ($final_o->get('where') or $final_o->get('since'))
5382  ***      0      0      0   if ($final_o->get('explain')) { }
5383  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $sql
5401  ***      0      0      0   if not defined $msg or $o->get('quiet') and $EVAL_ERROR =~ /: Table .*? doesn't exist|Deadlock found/
5407  ***      0      0      0   if ($db and $tbl)
5410  ***      0      0      0   if ($host)
5418  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
2391  ***      0      0      0   $args{'exact'} and scalar @candidate_cols
4795  ***      0      0      0   $EVAL_ERROR and 0

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
247   ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
285   ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
316   ***      0      0      0      0   $engine =~ /InnoDB/i and not $clustered_key
318   ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
342   ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
458   ***      0      0      0      0   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
478   ***      0      0      0      0   $type eq 'bigint' and $length < 20
492   ***      0      0      0      0   $alg and not $ALGOS{$alg}
509   ***      0      0      0      0   $alg and grep {$_ eq $alg;} @choices
514   ***      0      0      0      0   $args{'count'} and grep {$_ ne 'CHECKSUM';} @choices
525   ***      0      0      0      0   $ALGOS{$algorithm} && $ALGOS{$algorithm}{'hash'}
535   ***      0      0      0      0   @funcs and not $result
544   ***      0      0      0      0   $EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/
568   ***      0      0      0      0   $start < $crc_wid and $sliced ne $unsliced
615   ***      0      0      0      0   defined $opt_slice and $opt_slice < @slices
643   ***      0      0      0      0   $type =~ /float|double/ and $args{'float_precision'}
      ***      0      0      0      0   $type =~ /varchar/ and $args{'trim'}
660   ***      0      0      0      0   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
693   ***      0      0      0      0   $algorithm and $ALGOS{$algorithm}
1000  ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
1005  ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
1144  ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
1173  ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
1180  ***      0      0      0      0   @ARGV and $$self{'strict'}
1264  ***      0      0      0      0   $opt and $$opt{'type'}
1267  ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
1332  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1340  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1354  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1443  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1537  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1716  ***     66    124    124      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33    248      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1838  ***     66     31      0     31   not $dbh and $tries--
1874  ***     33     31      0      0   not $dbh and $EVAL_ERROR
2080  ***      0      0      0      0   $trgs and @$trgs
2126  ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
2369  ***      0      0      0      0   defined $_ and next
2372  ***      0      0      0      0   $$index{'is_unique'} and @{$$index{'cols'};} == 1
2625  ***      0      0      0      0   $args{'where'} and grep {$_;} @{$args{'where'};}
2831  ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
3011  ***      0      0      0      0   $ss and %$ss
3030  ***      0      0      0      0   $ms and %$ms
3032  ***      0      0      0      0   $$ms{'file'} and $$ms{'position'}
3055  ***      0      0      0      0   $stat < 0 and not $timeoutok
3196  ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
3331  ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
3336  ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
3482  ***      0      0      0      0   $PID_file and -f $PID_file
3543  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
3617  ***      0      0      0      0   $o->has('databases-regex') and my $p = $o->get('databases-regex')
3621  ***      0      0      0      0   $o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex')
3681  ***      0      0      0      0   @reject_qtbls and not $have_qtbl
3687  ***      0      0      0      0   keys %permit_qtbls and not @permit_dbs
3702  ***      0      0      0      0   $o->has('tables-regex') and my $p = $o->get('tables-regex')
3706  ***      0      0      0      0   $o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex')
3715  ***      0      0      0      0   $o->has('engines') and $o->get('engines')
      ***      0      0      0      0   $o->has('ignore-engines') and $o->get('ignore-engines')
3971  ***      0      0      0      0   $o->get('replicate-check') and not $o->get('replicate')
3974  ***      0      0      0      0   $o->get('save-since') and not $o->get('arg-table')
      ***      0      0      0      0   $o->get('replicate') and @hosts > 1
3981  ***      0      0      0      0   $o->get('resume-replicate') and not $o->get('replicate')
3984  ***      0      0      0      0   $o->get('resume') and $o->get('replicate')
4045  ***      0      0      0      0   $$row{'db'} and $$row{'tbl'}
4116  ***      0      0      0      0   $o->get('verify') and @hosts > 1
4130  ***      0      0      0      0   $o->get('replicate') and $o->get('resume-replicate')
4149  ***      0      0      0      0   $o->get('replicate-check') and $o->get('recheck')
4229  ***      0      0      0      0   $final_o->get('replicate') and $final_o->get('replicate') eq "$db.$tbl"
4253  ***      0      0      0      0   $final_o->get('chunk-size') and $col
4332  ***      0      0      0      0   $checksum_table_data and $do_table
4380  ***      0      0      0      0   my $replicate_table = $final_o->get('replicate') and not $final_o->get('explain')
4402  ***      0      0      0      0   $time and $time lt $final_o->get('since')
4442  ***      0      0      0      0   $checksum_table_data and $do_table
4479  ***      0      0      0      0   $final_o->get('save-since') and $savesince_sth
4545  ***      0      0      0      0   $num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data
      ***      0      0      0      0   $num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data and defined $final_o->get('probability')
      ***      0      0      0      0   $num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data and defined $final_o->get('probability') and rand 100 >= $final_o->get('probability')
4553  ***      0      0      0      0   $num_chunks > 1 and $checksum_table_data
      ***      0      0      0      0   $num_chunks > 1 and $checksum_table_data and $final_o->get('modulo')
      ***      0      0      0      0   $num_chunks > 1 and $checksum_table_data and $final_o->get('modulo') and $chunk_num % $final_o->get('modulo') != $final_o->get('offset')
4635  ***      0      0      0      0   defined $pid and $pid == 0
      ***      0      0      0      0   @hosts > 1 and not defined $pid
4669  ***      0      0      0      0   $final_o->get('lock') and not $final_o->get('explain')
4679  ***      0      0      0      0   $final_o->get('sleep') and not $final_o->get('explain')
      ***      0      0      0      0   $final_o->get('sleep-coef') and not $final_o->get('explain')
4720  ***      0      0      0      0   $val and not is_temporal($val)
4730  ***      0      0      0      0   $val && $val =~ /^\d{4}-\d{2}-\d{2}(?:.[0-9:]+)?/
4828  ***      0      0      0      0   $o->get('algorithm') and $o->get('algorithm') ne $$ret{'strat'}
4840  ***      0      0      0      0   $o->get('function') and $o->get('function') ne $$ret{'func'}
4847  ***      0      0      0      0   $o->get('optimize-xor') and $$ret{'strat'} eq 'BIT_XOR'
5137  ***      0      0      0      0   not $final_o->get('quiet') and not $final_o->get('explain')
5187  ***      0      0      0      0   not $is_master and $final_o->get('wait')
      ***      0      0      0      0   not $is_master and $final_o->get('wait') and not $final_o->get('explain')
5197  ***      0      0      0      0   not $is_master and $final_o->get('slave-lag')
      ***      0      0      0      0   not $is_master and $final_o->get('slave-lag') and not $final_o->get('explain')
5202  ***      0      0      0      0   $res && defined $$res{'seconds_behind_master'}
5254  ***      0      0      0      0   not $final_o->get('quiet') and not $final_o->get('explain')
5280  ***      0      0      0      0   $o->get('ask-pass') and not defined $$dsn{'p'}
5401  ***      0      0      0      0   $o->get('quiet') and $EVAL_ERROR =~ /: Table .*? doesn't exist|Deadlock found/
5407  ***      0      0      0      0   $db and $tbl

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0     23   $ENV{'MKDEBUG'} || 0
261   ***      0      0      0   $engine || undef
284   ***      0      0      0   $type || $special || 'BTREE'
371   ***      0      0      0   $$tbl_struct{'engine'} || ''
373   ***      0      0      0   $clustered_key ||= ''
424   ***     50      0     23   $ENV{'MKDEBUG'} || 0
630   ***      0      0      0   $args{'sep'} || '#'
632   ***      0      0      0   $sep ||= '#'
785   ***     50      0     23   $ENV{'MKDEBUG'} || 0
805   ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
807   ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
849   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum'
990   ***      0      0      0   $$opt{'group'} ||= 'default'
1272  ***      0      0      0   $s || 's'
1281  ***      0      0      0   $prefix || ''
1309  ***      0      0      0   $pre || ''
1316  ***      0      0      0   $val || ''
1319  ***      0      0      0   $val || ''
1377  ***      0      0      0   $$self{'description'} || ''
1445  ***      0      0      0   $s ||= 's'
1471  ***      0      0      0   $$opt{'type'} || ''
1626  ***     50      0     23   $ENV{'MKDEBUG'} || 0
1697  ***     50      0     31   $prev ||= {}
1698  ***     50      0     31   $defaults ||= {}
1771  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1784  ***     50      0     31   $self->prop('dbidriver') || ''
1788  ***      0      0      0   $$info{'D'} || ''
1794  ***     50      0     31   $$info{'D'} || ''
1816  ***     50     31      0   $opts ||= {}
1911  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1927  ***      0      0      0   $level ||= 0
1928  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1978  ***     50      0     23   $ENV{'MKDEBUG'} || 0
2027  ***     50      0     23   $ENV{'MKDEBUG'} || 0
2297  ***      0      0      0   $$_[1] || ''
2340  ***     50      0     23   $ENV{'MKDEBUG'} || 0
2631  ***      0      0      0   $args{'index_hint'} || ''
2733  ***     50      0     23   $ENV{'MKDEBUG'} || 0
2802  ***     50      0     23   $ENV{'MKDEBUG'} || 0
2810  ***      0      0      0   $level ||= 0
2868  ***      0      0      0   $$dsn{'P'} || 3306
2977  ***      0      0      0   $$slave_status{'slave_io_state'} || ''
3323  ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
3372  ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
3407  ***     50      0     23   $ENV{'MKDEBUG'} || 0
3588  ***     50      0     23   $ENV{'MKDEBUG'} || 0
3818  ***      0      0      0   $type || ''
3877  ***     50      0     23   $ENV{'MKDEBUG'} || 0
5136  ***      0      0      0   $crc ||= 'NULL'
5237  ***      0      0      0   $crc ||= 'NULL'

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
135   ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
214   ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
235   ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
284   ***      0      0      0      0   $type || $special
495   ***      0      0      0      0   $args{'where'} or $args{'chunk'}
      ***      0      0      0      0   $args{'where'} or $args{'chunk'} or $args{'replicate'}
      ***      0      0      0      0   $args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1')
804   ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
805   ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
1267  ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1807  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1808  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1809  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1810  ***      0      0      0      0   $$dsn{'u'} ||= $user
1811  ***      0      0      0      0   $$dsn{'D'} ||= $db
2138  ***      0      0      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2177  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2207  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2241  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2260  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2274  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2286  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2385  ***      0      0      0      0   $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2471  ***      0      0      0      0   not defined $end_point or $end_point < $start_point
2483  ***      0      0      0      0   $interval ||= $args{'chunk_size'}
2560  ***      0      0      0      0   $suffix or $args{'avg_row_length'}
2816  ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
2831  ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
2844  ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
2984  ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
3005  ***      0      0      0      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
3024  ***      0      0      0      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
3048  ***      0      0      0      0   $ms ||= $self->get_master_status($master)
3055  ***      0      0      0      0   $stat eq 'NULL' or $stat < 0 and not $timeoutok
3067  ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
3082  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
3150  ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
3211  ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
3249  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
3303  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
3556  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
3625  ***      0      0      0      0   @permit_dbs or @reject_dbs
      ***      0      0      0      0   @permit_dbs or @reject_dbs or @dbs_regex
      ***      0      0      0      0   @permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex
3635  ***      0      0      0      0   $o->has('tables') or $o->has('ignore-tables')
      ***      0      0      0      0   $o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex')
3715  ***      0      0      0      0   $o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines')
3734  ***      0      0      0      0   @permit_tbls or @reject_tbls
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs
      ***      0      0      0      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs
4369  ***      0      0      0      0   $o->get('quiet') or $o->get('explain')
      ***      0      0      0      0   $o->get('quiet') or $o->get('explain') or $o->get('checksum')
      ***      0      0      0      0   $o->get('quiet') or $o->get('explain') or $o->get('checksum') or $o->get('resume')
4538  ***      0      0      0      0   not defined $lag or $lag > $final_o->get('max-lag')
4545  ***      0      0      0      0   $num_chunks > 1 || $final_o->get('single-chunk')
4585  ***      0      0      0      0   $hosts[0]{'dbh'} ||= $dbh
4618  ***      0      0      0      0   $$host{'dbh'} ||= $dbh
4621  ***      0      0      0      0   $$host{'dbh'} ||= get_cxn($host, %args)
4635  ***      0      0      0      0   @hosts == 1 or defined $pid and $pid == 0
4667  ***      0      0      0      0   $exit_status ||= $CHILD_ERROR >> 8
4819  ***      0      0      0      0   $o->get('where') || $o->get('since')
5209  ***      0      0      0      0   not $is_master or not $checksum_table_data
5376  ***      0      0      0      0   $final_o->get('where') or $final_o->get('since')
5401  ***      0      0      0      0   not defined $msg or $o->get('quiet') and $EVAL_ERROR =~ /: Table .*? doesn't exist|Deadlock found/


Covered Subroutines
-------------------

Subroutine                   Count Location                                                         
---------------------------- ----- -----------------------------------------------------------------
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1614
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1615
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1616
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1617
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1626
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1973
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1974
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1976
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1978
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2022
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2023
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2025
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2027
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:22  
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:23  
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2327
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2328
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2332
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2333
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2334
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2335
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2340
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2726
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2727
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2731
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2733
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2791
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2792
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2796
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2797
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2798
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2802
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:34  
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3401
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3402
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3404
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3405
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3407
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:35  
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3579
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3580
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3582
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3583
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3588
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:36  
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:37  
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3870
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3871
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3872
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3873
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3877
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:419 
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:42  
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:420 
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:421 
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:422 
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:424 
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:778 
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:779 
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:781 
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:782 
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:783 
BEGIN                           23 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:785 
get_cxn_params                  31 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1781
get_dbh                         31 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1815
new                             22 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1629
new                              1 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1981
parse                           31 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1691
parse                            2 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1986
prop                            93 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1682
version_ge                       1 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1993

Uncovered Subroutines
---------------------

Subroutine                   Count Location                                                         
---------------------------- ----- -----------------------------------------------------------------
DESTROY                          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3555
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1168
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3792
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3831
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4083
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1596
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1955
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2004
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2311
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2710
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3382
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3561
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3847
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:401 
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5417
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:760 
_find_slaves_by_hosts            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2910
_find_slaves_by_processlist      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2890
_get_participants                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1068
_make_PID_file                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3520
_make_filter                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3836
_parse_specs                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:954 
_pod_to_specs                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:848 
_read_config_file                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1520
_remove_PID_file                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3542
_set_option                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1114
_use_db                          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2118
_validate_type                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1263
already_checksummed              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5055
as_string                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1755
best_algorithm                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:488 
calculate_chunks                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2421
catchup_to_master                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3090
catchup_to_same_pos              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3131
change_master_to                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3160
check_PID_file                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3479
check_repl_table                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4906
check_table                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:193 
checksum_chunks                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4508
checksum_tables                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4303
choose_hash_func                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:529 
clone                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1573
copy                             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1937
crc32                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:442 
create_repl_table                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4971
daemonize                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3428
descr                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1376
detach_slave                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3312
determine_checksum_strat         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4803
disconnect                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1920
do_checksum                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5334
do_count                         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5362
do_tbl                           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5156
do_tbl_replicate                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5064
do_var_crc                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5292
dump                             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2061
errors                           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1366
eval_expr                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4789
fill_in_dsn                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1803
find_best_index                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:147 
find_chunk_columns               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2358
find_possible_keys               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:165 
find_replication_differences     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:739 
find_slave_hosts                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2860
get                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1330
get_all_tbls_info                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4175
get_columns                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2175
get_connected_slaves             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2937
get_crc_type                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:468 
get_crc_wid                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:456 
get_create_table                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2137
get_cxn                          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5273
get_databases                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2240
get_db_itr                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3771
get_defaults                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1104
get_defaults_files               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:843 
get_engine                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:258 
get_final_opts                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4699
get_first_chunkable_column       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2526
get_fks                          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:332 
get_groups                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1109
get_hostname                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1910
get_keys                         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:265 
get_master_dsn                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2996
get_master_status                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3022
get_opts                         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1131
get_range_statistics             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2572
get_slave_lag                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3351
get_slave_status                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3003
get_specs                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:836 
get_table_list                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2285
get_table_status                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2259
get_tbl_itr                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3797
get_tmp_table                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2195
get_triggers                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2206
got                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1338
has                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1346
has_slave_updates                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3327
inject_chunks                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2614
is_hash_algorithm                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:524 
is_master_of                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2958
is_temporal                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4729
literal_like                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2776
main                             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3896
make_PID_file                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3510
make_checksum_query              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:682 
make_filter                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3604
make_row_checksum                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:626 
make_sibling_of_master           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3171
make_slave_of_sibling            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3219
make_slave_of_uncle              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3258
make_xor_slices                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:597 
new                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2054
new                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2343
new                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2736
new                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2805
new                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3410
new                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3591
new                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:433 
new                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:46  
new                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:799 
optimize_xor                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:556 
opts                             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1080
parse                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:57  
parse_options                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1742
parse_resume_file                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5024
pos_cmp                          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3357
pos_to_string                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3376
print_active_handles             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1926
print_err                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5400
print_errors                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1400
print_inconsistent_tbls          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4734
print_usage                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1410
prompt                           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1371
prompt_noecho                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1485
quote                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2609
quote                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2741
quote_val                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2749
range_date                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2670
range_datetime                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2677
range_num                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2644
range_time                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2663
range_timestamp                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2685
read_para_after                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1554
read_repl_table                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4997
recurse_to_slaves                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2809
remove_auto_increment            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:361 
remove_secondary_indexes         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:367 
repl_posn                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3335
save_error                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1361
save_inconsistent_tbls           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4760
save_tbl_to_checksum             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4214
set                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1352
set_defaults                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1092
set_filter                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3764
short_host                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3362
short_opts                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1086
size_to_rows                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2535
slave_is_running                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3322
sort_indexes                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:128 
split_unquote                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2765
start_slave                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3074
stop_slave                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3066
timestampdiff                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2692
unique                           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5394
usage                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1764
usage_or_errors                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1387
verify_checksum_compat           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4867
wait_for_master                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3043


